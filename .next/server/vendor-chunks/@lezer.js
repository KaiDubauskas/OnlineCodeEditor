"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@lezer";
exports.ids = ["vendor-chunks/@lezer"];
exports.modules = {

/***/ "(ssr)/./node_modules/@lezer/common/dist/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@lezer/common/dist/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DefaultBufferLength: () => (/* binding */ DefaultBufferLength),\n/* harmony export */   IterMode: () => (/* binding */ IterMode),\n/* harmony export */   MountedTree: () => (/* binding */ MountedTree),\n/* harmony export */   NodeProp: () => (/* binding */ NodeProp),\n/* harmony export */   NodeSet: () => (/* binding */ NodeSet),\n/* harmony export */   NodeType: () => (/* binding */ NodeType),\n/* harmony export */   NodeWeakMap: () => (/* binding */ NodeWeakMap),\n/* harmony export */   Parser: () => (/* binding */ Parser),\n/* harmony export */   Tree: () => (/* binding */ Tree),\n/* harmony export */   TreeBuffer: () => (/* binding */ TreeBuffer),\n/* harmony export */   TreeCursor: () => (/* binding */ TreeCursor),\n/* harmony export */   TreeFragment: () => (/* binding */ TreeFragment),\n/* harmony export */   parseMixed: () => (/* binding */ parseMixed)\n/* harmony export */ });\n/**\nThe default maximum length of a `TreeBuffer` node.\n*/ const DefaultBufferLength = 1024;\nlet nextPropID = 0;\nclass Range {\n    constructor(from, to){\n        this.from = from;\n        this.to = to;\n    }\n}\n/**\nEach [node type](#common.NodeType) or [individual tree](#common.Tree)\ncan have metadata associated with it in props. Instances of this\nclass represent prop names.\n*/ class NodeProp {\n    /**\n    Create a new node prop type.\n    */ constructor(config = {}){\n        this.id = nextPropID++;\n        this.perNode = !!config.perNode;\n        this.deserialize = config.deserialize || (()=>{\n            throw new Error(\"This node type doesn't define a deserialize function\");\n        });\n    }\n    /**\n    This is meant to be used with\n    [`NodeSet.extend`](#common.NodeSet.extend) or\n    [`LRParser.configure`](#lr.ParserConfig.props) to compute\n    prop values for each node type in the set. Takes a [match\n    object](#common.NodeType^match) or function that returns undefined\n    if the node type doesn't get this prop, and the prop's value if\n    it does.\n    */ add(match) {\n        if (this.perNode) throw new RangeError(\"Can't add per-node props to node types\");\n        if (typeof match != \"function\") match = NodeType.match(match);\n        return (type)=>{\n            let result = match(type);\n            return result === undefined ? null : [\n                this,\n                result\n            ];\n        };\n    }\n}\n/**\nProp that is used to describe matching delimiters. For opening\ndelimiters, this holds an array of node names (written as a\nspace-separated string when declaring this prop in a grammar)\nfor the node types of closing delimiters that match it.\n*/ NodeProp.closedBy = new NodeProp({\n    deserialize: (str)=>str.split(\" \")\n});\n/**\nThe inverse of [`closedBy`](#common.NodeProp^closedBy). This is\nattached to closing delimiters, holding an array of node names\nof types of matching opening delimiters.\n*/ NodeProp.openedBy = new NodeProp({\n    deserialize: (str)=>str.split(\" \")\n});\n/**\nUsed to assign node types to groups (for example, all node\ntypes that represent an expression could be tagged with an\n`\"Expression\"` group).\n*/ NodeProp.group = new NodeProp({\n    deserialize: (str)=>str.split(\" \")\n});\n/**\nThe hash of the [context](#lr.ContextTracker.constructor)\nthat the node was parsed in, if any. Used to limit reuse of\ncontextual nodes.\n*/ NodeProp.contextHash = new NodeProp({\n    perNode: true\n});\n/**\nThe distance beyond the end of the node that the tokenizer\nlooked ahead for any of the tokens inside the node. (The LR\nparser only stores this when it is larger than 25, for\nefficiency reasons.)\n*/ NodeProp.lookAhead = new NodeProp({\n    perNode: true\n});\n/**\nThis per-node prop is used to replace a given node, or part of a\nnode, with another tree. This is useful to include trees from\ndifferent languages in mixed-language parsers.\n*/ NodeProp.mounted = new NodeProp({\n    perNode: true\n});\n/**\nA mounted tree, which can be [stored](#common.NodeProp^mounted) on\na tree node to indicate that parts of its content are\nrepresented by another tree.\n*/ class MountedTree {\n    constructor(/**\n    The inner tree.\n    */ tree, /**\n    If this is null, this tree replaces the entire node (it will\n    be included in the regular iteration instead of its host\n    node). If not, only the given ranges are considered to be\n    covered by this tree. This is used for trees that are mixed in\n    a way that isn't strictly hierarchical. Such mounted trees are\n    only entered by [`resolveInner`](#common.Tree.resolveInner)\n    and [`enter`](#common.SyntaxNode.enter).\n    */ overlay, /**\n    The parser used to create this subtree.\n    */ parser){\n        this.tree = tree;\n        this.overlay = overlay;\n        this.parser = parser;\n    }\n    /**\n    @internal\n    */ static get(tree) {\n        return tree && tree.props && tree.props[NodeProp.mounted.id];\n    }\n}\nconst noProps = Object.create(null);\n/**\nEach node in a syntax tree has a node type associated with it.\n*/ class NodeType {\n    /**\n    @internal\n    */ constructor(/**\n    The name of the node type. Not necessarily unique, but if the\n    grammar was written properly, different node types with the\n    same name within a node set should play the same semantic\n    role.\n    */ name, /**\n    @internal\n    */ props, /**\n    The id of this node in its set. Corresponds to the term ids\n    used in the parser.\n    */ id, /**\n    @internal\n    */ flags = 0){\n        this.name = name;\n        this.props = props;\n        this.id = id;\n        this.flags = flags;\n    }\n    /**\n    Define a node type.\n    */ static define(spec) {\n        let props = spec.props && spec.props.length ? Object.create(null) : noProps;\n        let flags = (spec.top ? 1 /* NodeFlag.Top */  : 0) | (spec.skipped ? 2 /* NodeFlag.Skipped */  : 0) | (spec.error ? 4 /* NodeFlag.Error */  : 0) | (spec.name == null ? 8 /* NodeFlag.Anonymous */  : 0);\n        let type = new NodeType(spec.name || \"\", props, spec.id, flags);\n        if (spec.props) for (let src of spec.props){\n            if (!Array.isArray(src)) src = src(type);\n            if (src) {\n                if (src[0].perNode) throw new RangeError(\"Can't store a per-node prop on a node type\");\n                props[src[0].id] = src[1];\n            }\n        }\n        return type;\n    }\n    /**\n    Retrieves a node prop for this type. Will return `undefined` if\n    the prop isn't present on this node.\n    */ prop(prop) {\n        return this.props[prop.id];\n    }\n    /**\n    True when this is the top node of a grammar.\n    */ get isTop() {\n        return (this.flags & 1 /* NodeFlag.Top */ ) > 0;\n    }\n    /**\n    True when this node is produced by a skip rule.\n    */ get isSkipped() {\n        return (this.flags & 2 /* NodeFlag.Skipped */ ) > 0;\n    }\n    /**\n    Indicates whether this is an error node.\n    */ get isError() {\n        return (this.flags & 4 /* NodeFlag.Error */ ) > 0;\n    }\n    /**\n    When true, this node type doesn't correspond to a user-declared\n    named node, for example because it is used to cache repetition.\n    */ get isAnonymous() {\n        return (this.flags & 8 /* NodeFlag.Anonymous */ ) > 0;\n    }\n    /**\n    Returns true when this node's name or one of its\n    [groups](#common.NodeProp^group) matches the given string.\n    */ is(name) {\n        if (typeof name == \"string\") {\n            if (this.name == name) return true;\n            let group = this.prop(NodeProp.group);\n            return group ? group.indexOf(name) > -1 : false;\n        }\n        return this.id == name;\n    }\n    /**\n    Create a function from node types to arbitrary values by\n    specifying an object whose property names are node or\n    [group](#common.NodeProp^group) names. Often useful with\n    [`NodeProp.add`](#common.NodeProp.add). You can put multiple\n    names, separated by spaces, in a single property name to map\n    multiple node names to a single value.\n    */ static match(map) {\n        let direct = Object.create(null);\n        for(let prop in map)for (let name of prop.split(\" \"))direct[name] = map[prop];\n        return (node)=>{\n            for(let groups = node.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++){\n                let found = direct[i < 0 ? node.name : groups[i]];\n                if (found) return found;\n            }\n        };\n    }\n}\n/**\nAn empty dummy node type to use when no actual type is available.\n*/ NodeType.none = new NodeType(\"\", Object.create(null), 0, 8 /* NodeFlag.Anonymous */ );\n/**\nA node set holds a collection of node types. It is used to\ncompactly represent trees by storing their type ids, rather than a\nfull pointer to the type object, in a numeric array. Each parser\n[has](#lr.LRParser.nodeSet) a node set, and [tree\nbuffers](#common.TreeBuffer) can only store collections of nodes\nfrom the same set. A set can have a maximum of 2**16 (65536) node\ntypes in it, so that the ids fit into 16-bit typed array slots.\n*/ class NodeSet {\n    /**\n    Create a set with the given types. The `id` property of each\n    type should correspond to its position within the array.\n    */ constructor(/**\n    The node types in this set, by id.\n    */ types){\n        this.types = types;\n        for(let i = 0; i < types.length; i++)if (types[i].id != i) throw new RangeError(\"Node type ids should correspond to array positions when creating a node set\");\n    }\n    /**\n    Create a copy of this set with some node properties added. The\n    arguments to this method can be created with\n    [`NodeProp.add`](#common.NodeProp.add).\n    */ extend(...props) {\n        let newTypes = [];\n        for (let type of this.types){\n            let newProps = null;\n            for (let source of props){\n                let add = source(type);\n                if (add) {\n                    if (!newProps) newProps = Object.assign({}, type.props);\n                    newProps[add[0].id] = add[1];\n                }\n            }\n            newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type);\n        }\n        return new NodeSet(newTypes);\n    }\n}\nconst CachedNode = new WeakMap(), CachedInnerNode = new WeakMap();\n/**\nOptions that control iteration. Can be combined with the `|`\noperator to enable multiple ones.\n*/ var IterMode;\n(function(IterMode) {\n    /**\n    When enabled, iteration will only visit [`Tree`](#common.Tree)\n    objects, not nodes packed into\n    [`TreeBuffer`](#common.TreeBuffer)s.\n    */ IterMode[IterMode[\"ExcludeBuffers\"] = 1] = \"ExcludeBuffers\";\n    /**\n    Enable this to make iteration include anonymous nodes (such as\n    the nodes that wrap repeated grammar constructs into a balanced\n    tree).\n    */ IterMode[IterMode[\"IncludeAnonymous\"] = 2] = \"IncludeAnonymous\";\n    /**\n    By default, regular [mounted](#common.NodeProp^mounted) nodes\n    replace their base node in iteration. Enable this to ignore them\n    instead.\n    */ IterMode[IterMode[\"IgnoreMounts\"] = 4] = \"IgnoreMounts\";\n    /**\n    This option only applies in\n    [`enter`](#common.SyntaxNode.enter)-style methods. It tells the\n    library to not enter mounted overlays if one covers the given\n    position.\n    */ IterMode[IterMode[\"IgnoreOverlays\"] = 8] = \"IgnoreOverlays\";\n})(IterMode || (IterMode = {}));\n/**\nA piece of syntax tree. There are two ways to approach these\ntrees: the way they are actually stored in memory, and the\nconvenient way.\n\nSyntax trees are stored as a tree of `Tree` and `TreeBuffer`\nobjects. By packing detail information into `TreeBuffer` leaf\nnodes, the representation is made a lot more memory-efficient.\n\nHowever, when you want to actually work with tree nodes, this\nrepresentation is very awkward, so most client code will want to\nuse the [`TreeCursor`](#common.TreeCursor) or\n[`SyntaxNode`](#common.SyntaxNode) interface instead, which provides\na view on some part of this data structure, and can be used to\nmove around to adjacent nodes.\n*/ class Tree {\n    /**\n    Construct a new tree. See also [`Tree.build`](#common.Tree^build).\n    */ constructor(/**\n    The type of the top node.\n    */ type, /**\n    This node's child nodes.\n    */ children, /**\n    The positions (offsets relative to the start of this tree) of\n    the children.\n    */ positions, /**\n    The total length of this tree\n    */ length, /**\n    Per-node [node props](#common.NodeProp) to associate with this node.\n    */ props){\n        this.type = type;\n        this.children = children;\n        this.positions = positions;\n        this.length = length;\n        /**\n        @internal\n        */ this.props = null;\n        if (props && props.length) {\n            this.props = Object.create(null);\n            for (let [prop, value] of props)this.props[typeof prop == \"number\" ? prop : prop.id] = value;\n        }\n    }\n    /**\n    @internal\n    */ toString() {\n        let mounted = MountedTree.get(this);\n        if (mounted && !mounted.overlay) return mounted.tree.toString();\n        let children = \"\";\n        for (let ch of this.children){\n            let str = ch.toString();\n            if (str) {\n                if (children) children += \",\";\n                children += str;\n            }\n        }\n        return !this.type.name ? children : (/\\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (children.length ? \"(\" + children + \")\" : \"\");\n    }\n    /**\n    Get a [tree cursor](#common.TreeCursor) positioned at the top of\n    the tree. Mode can be used to [control](#common.IterMode) which\n    nodes the cursor visits.\n    */ cursor(mode = 0) {\n        return new TreeCursor(this.topNode, mode);\n    }\n    /**\n    Get a [tree cursor](#common.TreeCursor) pointing into this tree\n    at the given position and side (see\n    [`moveTo`](#common.TreeCursor.moveTo).\n    */ cursorAt(pos, side = 0, mode = 0) {\n        let scope = CachedNode.get(this) || this.topNode;\n        let cursor = new TreeCursor(scope);\n        cursor.moveTo(pos, side);\n        CachedNode.set(this, cursor._tree);\n        return cursor;\n    }\n    /**\n    Get a [syntax node](#common.SyntaxNode) object for the top of the\n    tree.\n    */ get topNode() {\n        return new TreeNode(this, 0, 0, null);\n    }\n    /**\n    Get the [syntax node](#common.SyntaxNode) at the given position.\n    If `side` is -1, this will move into nodes that end at the\n    position. If 1, it'll move into nodes that start at the\n    position. With 0, it'll only enter nodes that cover the position\n    from both sides.\n    \n    Note that this will not enter\n    [overlays](#common.MountedTree.overlay), and you often want\n    [`resolveInner`](#common.Tree.resolveInner) instead.\n    */ resolve(pos, side = 0) {\n        let node = resolveNode(CachedNode.get(this) || this.topNode, pos, side, false);\n        CachedNode.set(this, node);\n        return node;\n    }\n    /**\n    Like [`resolve`](#common.Tree.resolve), but will enter\n    [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node\n    pointing into the innermost overlaid tree at the given position\n    (with parent links going through all parent structure, including\n    the host trees).\n    */ resolveInner(pos, side = 0) {\n        let node = resolveNode(CachedInnerNode.get(this) || this.topNode, pos, side, true);\n        CachedInnerNode.set(this, node);\n        return node;\n    }\n    /**\n    In some situations, it can be useful to iterate through all\n    nodes around a position, including those in overlays that don't\n    directly cover the position. This method gives you an iterator\n    that will produce all nodes, from small to big, around the given\n    position.\n    */ resolveStack(pos, side = 0) {\n        return stackIterator(this, pos, side);\n    }\n    /**\n    Iterate over the tree and its children, calling `enter` for any\n    node that touches the `from`/`to` region (if given) before\n    running over such a node's children, and `leave` (if given) when\n    leaving the node. When `enter` returns `false`, that node will\n    not have its children iterated over (or `leave` called).\n    */ iterate(spec) {\n        let { enter, leave, from = 0, to = this.length } = spec;\n        let mode = spec.mode || 0, anon = (mode & IterMode.IncludeAnonymous) > 0;\n        for(let c = this.cursor(mode | IterMode.IncludeAnonymous);;){\n            let entered = false;\n            if (c.from <= to && c.to >= from && (!anon && c.type.isAnonymous || enter(c) !== false)) {\n                if (c.firstChild()) continue;\n                entered = true;\n            }\n            for(;;){\n                if (entered && leave && (anon || !c.type.isAnonymous)) leave(c);\n                if (c.nextSibling()) break;\n                if (!c.parent()) return;\n                entered = true;\n            }\n        }\n    }\n    /**\n    Get the value of the given [node prop](#common.NodeProp) for this\n    node. Works with both per-node and per-type props.\n    */ prop(prop) {\n        return !prop.perNode ? this.type.prop(prop) : this.props ? this.props[prop.id] : undefined;\n    }\n    /**\n    Returns the node's [per-node props](#common.NodeProp.perNode) in a\n    format that can be passed to the [`Tree`](#common.Tree)\n    constructor.\n    */ get propValues() {\n        let result = [];\n        if (this.props) for(let id in this.props)result.push([\n            +id,\n            this.props[id]\n        ]);\n        return result;\n    }\n    /**\n    Balance the direct children of this tree, producing a copy of\n    which may have children grouped into subtrees with type\n    [`NodeType.none`](#common.NodeType^none).\n    */ balance(config = {}) {\n        return this.children.length <= 8 /* Balance.BranchFactor */  ? this : balanceRange(NodeType.none, this.children, this.positions, 0, this.children.length, 0, this.length, (children, positions, length)=>new Tree(this.type, children, positions, length, this.propValues), config.makeTree || ((children, positions, length)=>new Tree(NodeType.none, children, positions, length)));\n    }\n    /**\n    Build a tree from a postfix-ordered buffer of node information,\n    or a cursor over such a buffer.\n    */ static build(data) {\n        return buildTree(data);\n    }\n}\n/**\nThe empty tree\n*/ Tree.empty = new Tree(NodeType.none, [], [], 0);\nclass FlatBufferCursor {\n    constructor(buffer, index){\n        this.buffer = buffer;\n        this.index = index;\n    }\n    get id() {\n        return this.buffer[this.index - 4];\n    }\n    get start() {\n        return this.buffer[this.index - 3];\n    }\n    get end() {\n        return this.buffer[this.index - 2];\n    }\n    get size() {\n        return this.buffer[this.index - 1];\n    }\n    get pos() {\n        return this.index;\n    }\n    next() {\n        this.index -= 4;\n    }\n    fork() {\n        return new FlatBufferCursor(this.buffer, this.index);\n    }\n}\n/**\nTree buffers contain (type, start, end, endIndex) quads for each\nnode. In such a buffer, nodes are stored in prefix order (parents\nbefore children, with the endIndex of the parent indicating which\nchildren belong to it).\n*/ class TreeBuffer {\n    /**\n    Create a tree buffer.\n    */ constructor(/**\n    The buffer's content.\n    */ buffer, /**\n    The total length of the group of nodes in the buffer.\n    */ length, /**\n    The node set used in this buffer.\n    */ set){\n        this.buffer = buffer;\n        this.length = length;\n        this.set = set;\n    }\n    /**\n    @internal\n    */ get type() {\n        return NodeType.none;\n    }\n    /**\n    @internal\n    */ toString() {\n        let result = [];\n        for(let index = 0; index < this.buffer.length;){\n            result.push(this.childString(index));\n            index = this.buffer[index + 3];\n        }\n        return result.join(\",\");\n    }\n    /**\n    @internal\n    */ childString(index) {\n        let id = this.buffer[index], endIndex = this.buffer[index + 3];\n        let type = this.set.types[id], result = type.name;\n        if (/\\W/.test(result) && !type.isError) result = JSON.stringify(result);\n        index += 4;\n        if (endIndex == index) return result;\n        let children = [];\n        while(index < endIndex){\n            children.push(this.childString(index));\n            index = this.buffer[index + 3];\n        }\n        return result + \"(\" + children.join(\",\") + \")\";\n    }\n    /**\n    @internal\n    */ findChild(startIndex, endIndex, dir, pos, side) {\n        let { buffer } = this, pick = -1;\n        for(let i = startIndex; i != endIndex; i = buffer[i + 3]){\n            if (checkSide(side, pos, buffer[i + 1], buffer[i + 2])) {\n                pick = i;\n                if (dir > 0) break;\n            }\n        }\n        return pick;\n    }\n    /**\n    @internal\n    */ slice(startI, endI, from) {\n        let b = this.buffer;\n        let copy = new Uint16Array(endI - startI), len = 0;\n        for(let i = startI, j = 0; i < endI;){\n            copy[j++] = b[i++];\n            copy[j++] = b[i++] - from;\n            let to = copy[j++] = b[i++] - from;\n            copy[j++] = b[i++] - startI;\n            len = Math.max(len, to);\n        }\n        return new TreeBuffer(copy, len, this.set);\n    }\n}\nfunction checkSide(side, pos, from, to) {\n    switch(side){\n        case -2 /* Side.Before */ :\n            return from < pos;\n        case -1 /* Side.AtOrBefore */ :\n            return to >= pos && from < pos;\n        case 0 /* Side.Around */ :\n            return from < pos && to > pos;\n        case 1 /* Side.AtOrAfter */ :\n            return from <= pos && to > pos;\n        case 2 /* Side.After */ :\n            return to > pos;\n        case 4 /* Side.DontCare */ :\n            return true;\n    }\n}\nfunction resolveNode(node, pos, side, overlays) {\n    var _a;\n    // Move up to a node that actually holds the position, if possible\n    while(node.from == node.to || (side < 1 ? node.from >= pos : node.from > pos) || (side > -1 ? node.to <= pos : node.to < pos)){\n        let parent = !overlays && node instanceof TreeNode && node.index < 0 ? null : node.parent;\n        if (!parent) return node;\n        node = parent;\n    }\n    let mode = overlays ? 0 : IterMode.IgnoreOverlays;\n    // Must go up out of overlays when those do not overlap with pos\n    if (overlays) for(let scan = node, parent = scan.parent; parent; scan = parent, parent = scan.parent){\n        if (scan instanceof TreeNode && scan.index < 0 && ((_a = parent.enter(pos, side, mode)) === null || _a === void 0 ? void 0 : _a.from) != scan.from) node = parent;\n    }\n    for(;;){\n        let inner = node.enter(pos, side, mode);\n        if (!inner) return node;\n        node = inner;\n    }\n}\nclass BaseNode {\n    cursor(mode = 0) {\n        return new TreeCursor(this, mode);\n    }\n    getChild(type, before = null, after = null) {\n        let r = getChildren(this, type, before, after);\n        return r.length ? r[0] : null;\n    }\n    getChildren(type, before = null, after = null) {\n        return getChildren(this, type, before, after);\n    }\n    resolve(pos, side = 0) {\n        return resolveNode(this, pos, side, false);\n    }\n    resolveInner(pos, side = 0) {\n        return resolveNode(this, pos, side, true);\n    }\n    matchContext(context) {\n        return matchNodeContext(this, context);\n    }\n    enterUnfinishedNodesBefore(pos) {\n        let scan = this.childBefore(pos), node = this;\n        while(scan){\n            let last = scan.lastChild;\n            if (!last || last.to != scan.to) break;\n            if (last.type.isError && last.from == last.to) {\n                node = scan;\n                scan = last.prevSibling;\n            } else {\n                scan = last;\n            }\n        }\n        return node;\n    }\n    get node() {\n        return this;\n    }\n    get next() {\n        return this.parent;\n    }\n}\nclass TreeNode extends BaseNode {\n    constructor(_tree, from, // Index in parent node, set to -1 if the node is not a direct child of _parent.node (overlay)\n    index, _parent){\n        super();\n        this._tree = _tree;\n        this.from = from;\n        this.index = index;\n        this._parent = _parent;\n    }\n    get type() {\n        return this._tree.type;\n    }\n    get name() {\n        return this._tree.type.name;\n    }\n    get to() {\n        return this.from + this._tree.length;\n    }\n    nextChild(i, dir, pos, side, mode = 0) {\n        for(let parent = this;;){\n            for(let { children, positions } = parent._tree, e = dir > 0 ? children.length : -1; i != e; i += dir){\n                let next = children[i], start = positions[i] + parent.from;\n                if (!checkSide(side, pos, start, start + next.length)) continue;\n                if (next instanceof TreeBuffer) {\n                    if (mode & IterMode.ExcludeBuffers) continue;\n                    let index = next.findChild(0, next.buffer.length, dir, pos - start, side);\n                    if (index > -1) return new BufferNode(new BufferContext(parent, next, i, start), null, index);\n                } else if (mode & IterMode.IncludeAnonymous || !next.type.isAnonymous || hasChild(next)) {\n                    let mounted;\n                    if (!(mode & IterMode.IgnoreMounts) && (mounted = MountedTree.get(next)) && !mounted.overlay) return new TreeNode(mounted.tree, start, i, parent);\n                    let inner = new TreeNode(next, start, i, parent);\n                    return mode & IterMode.IncludeAnonymous || !inner.type.isAnonymous ? inner : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, pos, side);\n                }\n            }\n            if (mode & IterMode.IncludeAnonymous || !parent.type.isAnonymous) return null;\n            if (parent.index >= 0) i = parent.index + dir;\n            else i = dir < 0 ? -1 : parent._parent._tree.children.length;\n            parent = parent._parent;\n            if (!parent) return null;\n        }\n    }\n    get firstChild() {\n        return this.nextChild(0, 1, 0, 4 /* Side.DontCare */ );\n    }\n    get lastChild() {\n        return this.nextChild(this._tree.children.length - 1, -1, 0, 4 /* Side.DontCare */ );\n    }\n    childAfter(pos) {\n        return this.nextChild(0, 1, pos, 2 /* Side.After */ );\n    }\n    childBefore(pos) {\n        return this.nextChild(this._tree.children.length - 1, -1, pos, -2 /* Side.Before */ );\n    }\n    enter(pos, side, mode = 0) {\n        let mounted;\n        if (!(mode & IterMode.IgnoreOverlays) && (mounted = MountedTree.get(this._tree)) && mounted.overlay) {\n            let rPos = pos - this.from;\n            for (let { from, to } of mounted.overlay){\n                if ((side > 0 ? from <= rPos : from < rPos) && (side < 0 ? to >= rPos : to > rPos)) return new TreeNode(mounted.tree, mounted.overlay[0].from + this.from, -1, this);\n            }\n        }\n        return this.nextChild(0, 1, pos, side, mode);\n    }\n    nextSignificantParent() {\n        let val = this;\n        while(val.type.isAnonymous && val._parent)val = val._parent;\n        return val;\n    }\n    get parent() {\n        return this._parent ? this._parent.nextSignificantParent() : null;\n    }\n    get nextSibling() {\n        return this._parent && this.index >= 0 ? this._parent.nextChild(this.index + 1, 1, 0, 4 /* Side.DontCare */ ) : null;\n    }\n    get prevSibling() {\n        return this._parent && this.index >= 0 ? this._parent.nextChild(this.index - 1, -1, 0, 4 /* Side.DontCare */ ) : null;\n    }\n    get tree() {\n        return this._tree;\n    }\n    toTree() {\n        return this._tree;\n    }\n    /**\n    @internal\n    */ toString() {\n        return this._tree.toString();\n    }\n}\nfunction getChildren(node, type, before, after) {\n    let cur = node.cursor(), result = [];\n    if (!cur.firstChild()) return result;\n    if (before != null) {\n        while(!cur.type.is(before))if (!cur.nextSibling()) return result;\n    }\n    for(;;){\n        if (after != null && cur.type.is(after)) return result;\n        if (cur.type.is(type)) result.push(cur.node);\n        if (!cur.nextSibling()) return after == null ? result : [];\n    }\n}\nfunction matchNodeContext(node, context, i = context.length - 1) {\n    for(let p = node.parent; i >= 0; p = p.parent){\n        if (!p) return false;\n        if (!p.type.isAnonymous) {\n            if (context[i] && context[i] != p.name) return false;\n            i--;\n        }\n    }\n    return true;\n}\nclass BufferContext {\n    constructor(parent, buffer, index, start){\n        this.parent = parent;\n        this.buffer = buffer;\n        this.index = index;\n        this.start = start;\n    }\n}\nclass BufferNode extends BaseNode {\n    get name() {\n        return this.type.name;\n    }\n    get from() {\n        return this.context.start + this.context.buffer.buffer[this.index + 1];\n    }\n    get to() {\n        return this.context.start + this.context.buffer.buffer[this.index + 2];\n    }\n    constructor(context, _parent, index){\n        super();\n        this.context = context;\n        this._parent = _parent;\n        this.index = index;\n        this.type = context.buffer.set.types[context.buffer.buffer[index]];\n    }\n    child(dir, pos, side) {\n        let { buffer } = this.context;\n        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.context.start, side);\n        return index < 0 ? null : new BufferNode(this.context, this, index);\n    }\n    get firstChild() {\n        return this.child(1, 0, 4 /* Side.DontCare */ );\n    }\n    get lastChild() {\n        return this.child(-1, 0, 4 /* Side.DontCare */ );\n    }\n    childAfter(pos) {\n        return this.child(1, pos, 2 /* Side.After */ );\n    }\n    childBefore(pos) {\n        return this.child(-1, pos, -2 /* Side.Before */ );\n    }\n    enter(pos, side, mode = 0) {\n        if (mode & IterMode.ExcludeBuffers) return null;\n        let { buffer } = this.context;\n        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], side > 0 ? 1 : -1, pos - this.context.start, side);\n        return index < 0 ? null : new BufferNode(this.context, this, index);\n    }\n    get parent() {\n        return this._parent || this.context.parent.nextSignificantParent();\n    }\n    externalSibling(dir) {\n        return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, 0, 4 /* Side.DontCare */ );\n    }\n    get nextSibling() {\n        let { buffer } = this.context;\n        let after = buffer.buffer[this.index + 3];\n        if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length)) return new BufferNode(this.context, this._parent, after);\n        return this.externalSibling(1);\n    }\n    get prevSibling() {\n        let { buffer } = this.context;\n        let parentStart = this._parent ? this._parent.index + 4 : 0;\n        if (this.index == parentStart) return this.externalSibling(-1);\n        return new BufferNode(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, 0, 4 /* Side.DontCare */ ));\n    }\n    get tree() {\n        return null;\n    }\n    toTree() {\n        let children = [], positions = [];\n        let { buffer } = this.context;\n        let startI = this.index + 4, endI = buffer.buffer[this.index + 3];\n        if (endI > startI) {\n            let from = buffer.buffer[this.index + 1];\n            children.push(buffer.slice(startI, endI, from));\n            positions.push(0);\n        }\n        return new Tree(this.type, children, positions, this.to - this.from);\n    }\n    /**\n    @internal\n    */ toString() {\n        return this.context.buffer.childString(this.index);\n    }\n}\nfunction iterStack(heads) {\n    if (!heads.length) return null;\n    let pick = 0, picked = heads[0];\n    for(let i = 1; i < heads.length; i++){\n        let node = heads[i];\n        if (node.from > picked.from || node.to < picked.to) {\n            picked = node;\n            pick = i;\n        }\n    }\n    let next = picked instanceof TreeNode && picked.index < 0 ? null : picked.parent;\n    let newHeads = heads.slice();\n    if (next) newHeads[pick] = next;\n    else newHeads.splice(pick, 1);\n    return new StackIterator(newHeads, picked);\n}\nclass StackIterator {\n    constructor(heads, node){\n        this.heads = heads;\n        this.node = node;\n    }\n    get next() {\n        return iterStack(this.heads);\n    }\n}\nfunction stackIterator(tree, pos, side) {\n    let inner = tree.resolveInner(pos, side), layers = null;\n    for(let scan = inner instanceof TreeNode ? inner : inner.context.parent; scan; scan = scan.parent){\n        if (scan.index < 0) {\n            let parent = scan.parent;\n            (layers || (layers = [\n                inner\n            ])).push(parent.resolve(pos, side));\n            scan = parent;\n        } else {\n            let mount = MountedTree.get(scan.tree);\n            // Relevant overlay branching off\n            if (mount && mount.overlay && mount.overlay[0].from <= pos && mount.overlay[mount.overlay.length - 1].to >= pos) {\n                let root = new TreeNode(mount.tree, mount.overlay[0].from + scan.from, -1, scan);\n                (layers || (layers = [\n                    inner\n                ])).push(resolveNode(root, pos, side, false));\n            }\n        }\n    }\n    return layers ? iterStack(layers) : inner;\n}\n/**\nA tree cursor object focuses on a given node in a syntax tree, and\nallows you to move to adjacent nodes.\n*/ class TreeCursor {\n    /**\n    Shorthand for `.type.name`.\n    */ get name() {\n        return this.type.name;\n    }\n    /**\n    @internal\n    */ constructor(node, /**\n    @internal\n    */ mode = 0){\n        this.mode = mode;\n        /**\n        @internal\n        */ this.buffer = null;\n        this.stack = [];\n        /**\n        @internal\n        */ this.index = 0;\n        this.bufferNode = null;\n        if (node instanceof TreeNode) {\n            this.yieldNode(node);\n        } else {\n            this._tree = node.context.parent;\n            this.buffer = node.context;\n            for(let n = node._parent; n; n = n._parent)this.stack.unshift(n.index);\n            this.bufferNode = node;\n            this.yieldBuf(node.index);\n        }\n    }\n    yieldNode(node) {\n        if (!node) return false;\n        this._tree = node;\n        this.type = node.type;\n        this.from = node.from;\n        this.to = node.to;\n        return true;\n    }\n    yieldBuf(index, type) {\n        this.index = index;\n        let { start, buffer } = this.buffer;\n        this.type = type || buffer.set.types[buffer.buffer[index]];\n        this.from = start + buffer.buffer[index + 1];\n        this.to = start + buffer.buffer[index + 2];\n        return true;\n    }\n    /**\n    @internal\n    */ yield(node) {\n        if (!node) return false;\n        if (node instanceof TreeNode) {\n            this.buffer = null;\n            return this.yieldNode(node);\n        }\n        this.buffer = node.context;\n        return this.yieldBuf(node.index, node.type);\n    }\n    /**\n    @internal\n    */ toString() {\n        return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();\n    }\n    /**\n    @internal\n    */ enterChild(dir, pos, side) {\n        if (!this.buffer) return this.yield(this._tree.nextChild(dir < 0 ? this._tree._tree.children.length - 1 : 0, dir, pos, side, this.mode));\n        let { buffer } = this.buffer;\n        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.buffer.start, side);\n        if (index < 0) return false;\n        this.stack.push(this.index);\n        return this.yieldBuf(index);\n    }\n    /**\n    Move the cursor to this node's first child. When this returns\n    false, the node has no child, and the cursor has not been moved.\n    */ firstChild() {\n        return this.enterChild(1, 0, 4 /* Side.DontCare */ );\n    }\n    /**\n    Move the cursor to this node's last child.\n    */ lastChild() {\n        return this.enterChild(-1, 0, 4 /* Side.DontCare */ );\n    }\n    /**\n    Move the cursor to the first child that ends after `pos`.\n    */ childAfter(pos) {\n        return this.enterChild(1, pos, 2 /* Side.After */ );\n    }\n    /**\n    Move to the last child that starts before `pos`.\n    */ childBefore(pos) {\n        return this.enterChild(-1, pos, -2 /* Side.Before */ );\n    }\n    /**\n    Move the cursor to the child around `pos`. If side is -1 the\n    child may end at that position, when 1 it may start there. This\n    will also enter [overlaid](#common.MountedTree.overlay)\n    [mounted](#common.NodeProp^mounted) trees unless `overlays` is\n    set to false.\n    */ enter(pos, side, mode = this.mode) {\n        if (!this.buffer) return this.yield(this._tree.enter(pos, side, mode));\n        return mode & IterMode.ExcludeBuffers ? false : this.enterChild(1, pos, side);\n    }\n    /**\n    Move to the node's parent node, if this isn't the top node.\n    */ parent() {\n        if (!this.buffer) return this.yieldNode(this.mode & IterMode.IncludeAnonymous ? this._tree._parent : this._tree.parent);\n        if (this.stack.length) return this.yieldBuf(this.stack.pop());\n        let parent = this.mode & IterMode.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();\n        this.buffer = null;\n        return this.yieldNode(parent);\n    }\n    /**\n    @internal\n    */ sibling(dir) {\n        if (!this.buffer) return !this._tree._parent ? false : this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + dir, dir, 0, 4 /* Side.DontCare */ , this.mode));\n        let { buffer } = this.buffer, d = this.stack.length - 1;\n        if (dir < 0) {\n            let parentStart = d < 0 ? 0 : this.stack[d] + 4;\n            if (this.index != parentStart) return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, 0, 4 /* Side.DontCare */ ));\n        } else {\n            let after = buffer.buffer[this.index + 3];\n            if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3])) return this.yieldBuf(after);\n        }\n        return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, 0, 4 /* Side.DontCare */ , this.mode)) : false;\n    }\n    /**\n    Move to this node's next sibling, if any.\n    */ nextSibling() {\n        return this.sibling(1);\n    }\n    /**\n    Move to this node's previous sibling, if any.\n    */ prevSibling() {\n        return this.sibling(-1);\n    }\n    atLastNode(dir) {\n        let index, parent, { buffer } = this;\n        if (buffer) {\n            if (dir > 0) {\n                if (this.index < buffer.buffer.buffer.length) return false;\n            } else {\n                for(let i = 0; i < this.index; i++)if (buffer.buffer.buffer[i + 3] < this.index) return false;\n            }\n            ({ index, parent } = buffer);\n        } else {\n            ({ index, _parent: parent } = this._tree);\n        }\n        for(; parent; { index, _parent: parent } = parent){\n            if (index > -1) for(let i = index + dir, e = dir < 0 ? -1 : parent._tree.children.length; i != e; i += dir){\n                let child = parent._tree.children[i];\n                if (this.mode & IterMode.IncludeAnonymous || child instanceof TreeBuffer || !child.type.isAnonymous || hasChild(child)) return false;\n            }\n        }\n        return true;\n    }\n    move(dir, enter) {\n        if (enter && this.enterChild(dir, 0, 4 /* Side.DontCare */ )) return true;\n        for(;;){\n            if (this.sibling(dir)) return true;\n            if (this.atLastNode(dir) || !this.parent()) return false;\n        }\n    }\n    /**\n    Move to the next node in a\n    [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)\n    traversal, going from a node to its first child or, if the\n    current node is empty or `enter` is false, its next sibling or\n    the next sibling of the first parent node that has one.\n    */ next(enter = true) {\n        return this.move(1, enter);\n    }\n    /**\n    Move to the next node in a last-to-first pre-order traveral. A\n    node is followed by its last child or, if it has none, its\n    previous sibling or the previous sibling of the first parent\n    node that has one.\n    */ prev(enter = true) {\n        return this.move(-1, enter);\n    }\n    /**\n    Move the cursor to the innermost node that covers `pos`. If\n    `side` is -1, it will enter nodes that end at `pos`. If it is 1,\n    it will enter nodes that start at `pos`.\n    */ moveTo(pos, side = 0) {\n        // Move up to a node that actually holds the position, if possible\n        while(this.from == this.to || (side < 1 ? this.from >= pos : this.from > pos) || (side > -1 ? this.to <= pos : this.to < pos))if (!this.parent()) break;\n        // Then scan down into child nodes as far as possible\n        while(this.enterChild(1, pos, side)){}\n        return this;\n    }\n    /**\n    Get a [syntax node](#common.SyntaxNode) at the cursor's current\n    position.\n    */ get node() {\n        if (!this.buffer) return this._tree;\n        let cache = this.bufferNode, result = null, depth = 0;\n        if (cache && cache.context == this.buffer) {\n            scan: for(let index = this.index, d = this.stack.length; d >= 0;){\n                for(let c = cache; c; c = c._parent)if (c.index == index) {\n                    if (index == this.index) return c;\n                    result = c;\n                    depth = d + 1;\n                    break scan;\n                }\n                index = this.stack[--d];\n            }\n        }\n        for(let i = depth; i < this.stack.length; i++)result = new BufferNode(this.buffer, result, this.stack[i]);\n        return this.bufferNode = new BufferNode(this.buffer, result, this.index);\n    }\n    /**\n    Get the [tree](#common.Tree) that represents the current node, if\n    any. Will return null when the node is in a [tree\n    buffer](#common.TreeBuffer).\n    */ get tree() {\n        return this.buffer ? null : this._tree._tree;\n    }\n    /**\n    Iterate over the current node and all its descendants, calling\n    `enter` when entering a node and `leave`, if given, when leaving\n    one. When `enter` returns `false`, any children of that node are\n    skipped, and `leave` isn't called for it.\n    */ iterate(enter, leave) {\n        for(let depth = 0;;){\n            let mustLeave = false;\n            if (this.type.isAnonymous || enter(this) !== false) {\n                if (this.firstChild()) {\n                    depth++;\n                    continue;\n                }\n                if (!this.type.isAnonymous) mustLeave = true;\n            }\n            for(;;){\n                if (mustLeave && leave) leave(this);\n                mustLeave = this.type.isAnonymous;\n                if (this.nextSibling()) break;\n                if (!depth) return;\n                this.parent();\n                depth--;\n                mustLeave = true;\n            }\n        }\n    }\n    /**\n    Test whether the current node matches a given context—a sequence\n    of direct parent node names. Empty strings in the context array\n    are treated as wildcards.\n    */ matchContext(context) {\n        if (!this.buffer) return matchNodeContext(this.node, context);\n        let { buffer } = this.buffer, { types } = buffer.set;\n        for(let i = context.length - 1, d = this.stack.length - 1; i >= 0; d--){\n            if (d < 0) return matchNodeContext(this.node, context, i);\n            let type = types[buffer.buffer[this.stack[d]]];\n            if (!type.isAnonymous) {\n                if (context[i] && context[i] != type.name) return false;\n                i--;\n            }\n        }\n        return true;\n    }\n}\nfunction hasChild(tree) {\n    return tree.children.some((ch)=>ch instanceof TreeBuffer || !ch.type.isAnonymous || hasChild(ch));\n}\nfunction buildTree(data) {\n    var _a;\n    let { buffer, nodeSet, maxBufferLength = DefaultBufferLength, reused = [], minRepeatType = nodeSet.types.length } = data;\n    let cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;\n    let types = nodeSet.types;\n    let contextHash = 0, lookAhead = 0;\n    function takeNode(parentStart, minPos, children, positions, inRepeat, depth) {\n        let { id, start, end, size } = cursor;\n        let lookAheadAtStart = lookAhead;\n        while(size < 0){\n            cursor.next();\n            if (size == -1 /* SpecialRecord.Reuse */ ) {\n                let node = reused[id];\n                children.push(node);\n                positions.push(start - parentStart);\n                return;\n            } else if (size == -3 /* SpecialRecord.ContextChange */ ) {\n                contextHash = id;\n                return;\n            } else if (size == -4 /* SpecialRecord.LookAhead */ ) {\n                lookAhead = id;\n                return;\n            } else {\n                throw new RangeError(`Unrecognized record size: ${size}`);\n            }\n        }\n        let type = types[id], node, buffer;\n        let startPos = start - parentStart;\n        if (end - start <= maxBufferLength && (buffer = findBufferSize(cursor.pos - minPos, inRepeat))) {\n            // Small enough for a buffer, and no reused nodes inside\n            let data = new Uint16Array(buffer.size - buffer.skip);\n            let endPos = cursor.pos - buffer.size, index = data.length;\n            while(cursor.pos > endPos)index = copyToBuffer(buffer.start, data, index);\n            node = new TreeBuffer(data, end - buffer.start, nodeSet);\n            startPos = buffer.start - parentStart;\n        } else {\n            let endPos = cursor.pos - size;\n            cursor.next();\n            let localChildren = [], localPositions = [];\n            let localInRepeat = id >= minRepeatType ? id : -1;\n            let lastGroup = 0, lastEnd = end;\n            while(cursor.pos > endPos){\n                if (localInRepeat >= 0 && cursor.id == localInRepeat && cursor.size >= 0) {\n                    if (cursor.end <= lastEnd - maxBufferLength) {\n                        makeRepeatLeaf(localChildren, localPositions, start, lastGroup, cursor.end, lastEnd, localInRepeat, lookAheadAtStart);\n                        lastGroup = localChildren.length;\n                        lastEnd = cursor.end;\n                    }\n                    cursor.next();\n                } else if (depth > 2500 /* CutOff.Depth */ ) {\n                    takeFlatNode(start, endPos, localChildren, localPositions);\n                } else {\n                    takeNode(start, endPos, localChildren, localPositions, localInRepeat, depth + 1);\n                }\n            }\n            if (localInRepeat >= 0 && lastGroup > 0 && lastGroup < localChildren.length) makeRepeatLeaf(localChildren, localPositions, start, lastGroup, start, lastEnd, localInRepeat, lookAheadAtStart);\n            localChildren.reverse();\n            localPositions.reverse();\n            if (localInRepeat > -1 && lastGroup > 0) {\n                let make = makeBalanced(type);\n                node = balanceRange(type, localChildren, localPositions, 0, localChildren.length, 0, end - start, make, make);\n            } else {\n                node = makeTree(type, localChildren, localPositions, end - start, lookAheadAtStart - end);\n            }\n        }\n        children.push(node);\n        positions.push(startPos);\n    }\n    function takeFlatNode(parentStart, minPos, children, positions) {\n        let nodes = []; // Temporary, inverted array of leaf nodes found, with absolute positions\n        let nodeCount = 0, stopAt = -1;\n        while(cursor.pos > minPos){\n            let { id, start, end, size } = cursor;\n            if (size > 4) {\n                cursor.next();\n            } else if (stopAt > -1 && start < stopAt) {\n                break;\n            } else {\n                if (stopAt < 0) stopAt = end - maxBufferLength;\n                nodes.push(id, start, end);\n                nodeCount++;\n                cursor.next();\n            }\n        }\n        if (nodeCount) {\n            let buffer = new Uint16Array(nodeCount * 4);\n            let start = nodes[nodes.length - 2];\n            for(let i = nodes.length - 3, j = 0; i >= 0; i -= 3){\n                buffer[j++] = nodes[i];\n                buffer[j++] = nodes[i + 1] - start;\n                buffer[j++] = nodes[i + 2] - start;\n                buffer[j++] = j;\n            }\n            children.push(new TreeBuffer(buffer, nodes[2] - start, nodeSet));\n            positions.push(start - parentStart);\n        }\n    }\n    function makeBalanced(type) {\n        return (children, positions, length)=>{\n            let lookAhead = 0, lastI = children.length - 1, last, lookAheadProp;\n            if (lastI >= 0 && (last = children[lastI]) instanceof Tree) {\n                if (!lastI && last.type == type && last.length == length) return last;\n                if (lookAheadProp = last.prop(NodeProp.lookAhead)) lookAhead = positions[lastI] + last.length + lookAheadProp;\n            }\n            return makeTree(type, children, positions, length, lookAhead);\n        };\n    }\n    function makeRepeatLeaf(children, positions, base, i, from, to, type, lookAhead) {\n        let localChildren = [], localPositions = [];\n        while(children.length > i){\n            localChildren.push(children.pop());\n            localPositions.push(positions.pop() + base - from);\n        }\n        children.push(makeTree(nodeSet.types[type], localChildren, localPositions, to - from, lookAhead - to));\n        positions.push(from - base);\n    }\n    function makeTree(type, children, positions, length, lookAhead = 0, props) {\n        if (contextHash) {\n            let pair = [\n                NodeProp.contextHash,\n                contextHash\n            ];\n            props = props ? [\n                pair\n            ].concat(props) : [\n                pair\n            ];\n        }\n        if (lookAhead > 25) {\n            let pair = [\n                NodeProp.lookAhead,\n                lookAhead\n            ];\n            props = props ? [\n                pair\n            ].concat(props) : [\n                pair\n            ];\n        }\n        return new Tree(type, children, positions, length, props);\n    }\n    function findBufferSize(maxSize, inRepeat) {\n        // Scan through the buffer to find previous siblings that fit\n        // together in a TreeBuffer, and don't contain any reused nodes\n        // (which can't be stored in a buffer).\n        // If `inRepeat` is > -1, ignore node boundaries of that type for\n        // nesting, but make sure the end falls either at the start\n        // (`maxSize`) or before such a node.\n        let fork = cursor.fork();\n        let size = 0, start = 0, skip = 0, minStart = fork.end - maxBufferLength;\n        let result = {\n            size: 0,\n            start: 0,\n            skip: 0\n        };\n        scan: for(let minPos = fork.pos - maxSize; fork.pos > minPos;){\n            let nodeSize = fork.size;\n            // Pretend nested repeat nodes of the same type don't exist\n            if (fork.id == inRepeat && nodeSize >= 0) {\n                // Except that we store the current state as a valid return\n                // value.\n                result.size = size;\n                result.start = start;\n                result.skip = skip;\n                skip += 4;\n                size += 4;\n                fork.next();\n                continue;\n            }\n            let startPos = fork.pos - nodeSize;\n            if (nodeSize < 0 || startPos < minPos || fork.start < minStart) break;\n            let localSkipped = fork.id >= minRepeatType ? 4 : 0;\n            let nodeStart = fork.start;\n            fork.next();\n            while(fork.pos > startPos){\n                if (fork.size < 0) {\n                    if (fork.size == -3 /* SpecialRecord.ContextChange */ ) localSkipped += 4;\n                    else break scan;\n                } else if (fork.id >= minRepeatType) {\n                    localSkipped += 4;\n                }\n                fork.next();\n            }\n            start = nodeStart;\n            size += nodeSize;\n            skip += localSkipped;\n        }\n        if (inRepeat < 0 || size == maxSize) {\n            result.size = size;\n            result.start = start;\n            result.skip = skip;\n        }\n        return result.size > 4 ? result : undefined;\n    }\n    function copyToBuffer(bufferStart, buffer, index) {\n        let { id, start, end, size } = cursor;\n        cursor.next();\n        if (size >= 0 && id < minRepeatType) {\n            let startIndex = index;\n            if (size > 4) {\n                let endPos = cursor.pos - (size - 4);\n                while(cursor.pos > endPos)index = copyToBuffer(bufferStart, buffer, index);\n            }\n            buffer[--index] = startIndex;\n            buffer[--index] = end - bufferStart;\n            buffer[--index] = start - bufferStart;\n            buffer[--index] = id;\n        } else if (size == -3 /* SpecialRecord.ContextChange */ ) {\n            contextHash = id;\n        } else if (size == -4 /* SpecialRecord.LookAhead */ ) {\n            lookAhead = id;\n        }\n        return index;\n    }\n    let children = [], positions = [];\n    while(cursor.pos > 0)takeNode(data.start || 0, data.bufferStart || 0, children, positions, -1, 0);\n    let length = (_a = data.length) !== null && _a !== void 0 ? _a : children.length ? positions[0] + children[0].length : 0;\n    return new Tree(types[data.topID], children.reverse(), positions.reverse(), length);\n}\nconst nodeSizeCache = new WeakMap;\nfunction nodeSize(balanceType, node) {\n    if (!balanceType.isAnonymous || node instanceof TreeBuffer || node.type != balanceType) return 1;\n    let size = nodeSizeCache.get(node);\n    if (size == null) {\n        size = 1;\n        for (let child of node.children){\n            if (child.type != balanceType || !(child instanceof Tree)) {\n                size = 1;\n                break;\n            }\n            size += nodeSize(balanceType, child);\n        }\n        nodeSizeCache.set(node, size);\n    }\n    return size;\n}\nfunction balanceRange(// The type the balanced tree's inner nodes.\nbalanceType, // The direct children and their positions\nchildren, positions, // The index range in children/positions to use\nfrom, to, // The start position of the nodes, relative to their parent.\nstart, // Length of the outer node\nlength, // Function to build the top node of the balanced tree\nmkTop, // Function to build internal nodes for the balanced tree\nmkTree) {\n    let total = 0;\n    for(let i = from; i < to; i++)total += nodeSize(balanceType, children[i]);\n    let maxChild = Math.ceil(total * 1.5 / 8 /* Balance.BranchFactor */ );\n    let localChildren = [], localPositions = [];\n    function divide(children, positions, from, to, offset) {\n        for(let i = from; i < to;){\n            let groupFrom = i, groupStart = positions[i], groupSize = nodeSize(balanceType, children[i]);\n            i++;\n            for(; i < to; i++){\n                let nextSize = nodeSize(balanceType, children[i]);\n                if (groupSize + nextSize >= maxChild) break;\n                groupSize += nextSize;\n            }\n            if (i == groupFrom + 1) {\n                if (groupSize > maxChild) {\n                    let only = children[groupFrom]; // Only trees can have a size > 1\n                    divide(only.children, only.positions, 0, only.children.length, positions[groupFrom] + offset);\n                    continue;\n                }\n                localChildren.push(children[groupFrom]);\n            } else {\n                let length = positions[i - 1] + children[i - 1].length - groupStart;\n                localChildren.push(balanceRange(balanceType, children, positions, groupFrom, i, groupStart, length, null, mkTree));\n            }\n            localPositions.push(groupStart + offset - start);\n        }\n    }\n    divide(children, positions, from, to, 0);\n    return (mkTop || mkTree)(localChildren, localPositions, length);\n}\n/**\nProvides a way to associate values with pieces of trees. As long\nas that part of the tree is reused, the associated values can be\nretrieved from an updated tree.\n*/ class NodeWeakMap {\n    constructor(){\n        this.map = new WeakMap();\n    }\n    setBuffer(buffer, index, value) {\n        let inner = this.map.get(buffer);\n        if (!inner) this.map.set(buffer, inner = new Map);\n        inner.set(index, value);\n    }\n    getBuffer(buffer, index) {\n        let inner = this.map.get(buffer);\n        return inner && inner.get(index);\n    }\n    /**\n    Set the value for this syntax node.\n    */ set(node, value) {\n        if (node instanceof BufferNode) this.setBuffer(node.context.buffer, node.index, value);\n        else if (node instanceof TreeNode) this.map.set(node.tree, value);\n    }\n    /**\n    Retrieve value for this syntax node, if it exists in the map.\n    */ get(node) {\n        return node instanceof BufferNode ? this.getBuffer(node.context.buffer, node.index) : node instanceof TreeNode ? this.map.get(node.tree) : undefined;\n    }\n    /**\n    Set the value for the node that a cursor currently points to.\n    */ cursorSet(cursor, value) {\n        if (cursor.buffer) this.setBuffer(cursor.buffer.buffer, cursor.index, value);\n        else this.map.set(cursor.tree, value);\n    }\n    /**\n    Retrieve the value for the node that a cursor currently points\n    to.\n    */ cursorGet(cursor) {\n        return cursor.buffer ? this.getBuffer(cursor.buffer.buffer, cursor.index) : this.map.get(cursor.tree);\n    }\n}\n/**\nTree fragments are used during [incremental\nparsing](#common.Parser.startParse) to track parts of old trees\nthat can be reused in a new parse. An array of fragments is used\nto track regions of an old tree whose nodes might be reused in new\nparses. Use the static\n[`applyChanges`](#common.TreeFragment^applyChanges) method to\nupdate fragments for document changes.\n*/ class TreeFragment {\n    /**\n    Construct a tree fragment. You'll usually want to use\n    [`addTree`](#common.TreeFragment^addTree) and\n    [`applyChanges`](#common.TreeFragment^applyChanges) instead of\n    calling this directly.\n    */ constructor(/**\n    The start of the unchanged range pointed to by this fragment.\n    This refers to an offset in the _updated_ document (as opposed\n    to the original tree).\n    */ from, /**\n    The end of the unchanged range.\n    */ to, /**\n    The tree that this fragment is based on.\n    */ tree, /**\n    The offset between the fragment's tree and the document that\n    this fragment can be used against. Add this when going from\n    document to tree positions, subtract it to go from tree to\n    document positions.\n    */ offset, openStart = false, openEnd = false){\n        this.from = from;\n        this.to = to;\n        this.tree = tree;\n        this.offset = offset;\n        this.open = (openStart ? 1 /* Open.Start */  : 0) | (openEnd ? 2 /* Open.End */  : 0);\n    }\n    /**\n    Whether the start of the fragment represents the start of a\n    parse, or the end of a change. (In the second case, it may not\n    be safe to reuse some nodes at the start, depending on the\n    parsing algorithm.)\n    */ get openStart() {\n        return (this.open & 1 /* Open.Start */ ) > 0;\n    }\n    /**\n    Whether the end of the fragment represents the end of a\n    full-document parse, or the start of a change.\n    */ get openEnd() {\n        return (this.open & 2 /* Open.End */ ) > 0;\n    }\n    /**\n    Create a set of fragments from a freshly parsed tree, or update\n    an existing set of fragments by replacing the ones that overlap\n    with a tree with content from the new tree. When `partial` is\n    true, the parse is treated as incomplete, and the resulting\n    fragment has [`openEnd`](#common.TreeFragment.openEnd) set to\n    true.\n    */ static addTree(tree, fragments = [], partial = false) {\n        let result = [\n            new TreeFragment(0, tree.length, tree, 0, false, partial)\n        ];\n        for (let f of fragments)if (f.to > tree.length) result.push(f);\n        return result;\n    }\n    /**\n    Apply a set of edits to an array of fragments, removing or\n    splitting fragments as necessary to remove edited ranges, and\n    adjusting offsets for fragments that moved.\n    */ static applyChanges(fragments, changes, minGap = 128) {\n        if (!changes.length) return fragments;\n        let result = [];\n        let fI = 1, nextF = fragments.length ? fragments[0] : null;\n        for(let cI = 0, pos = 0, off = 0;; cI++){\n            let nextC = cI < changes.length ? changes[cI] : null;\n            let nextPos = nextC ? nextC.fromA : 1e9;\n            if (nextPos - pos >= minGap) while(nextF && nextF.from < nextPos){\n                let cut = nextF;\n                if (pos >= cut.from || nextPos <= cut.to || off) {\n                    let fFrom = Math.max(cut.from, pos) - off, fTo = Math.min(cut.to, nextPos) - off;\n                    cut = fFrom >= fTo ? null : new TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, cI > 0, !!nextC);\n                }\n                if (cut) result.push(cut);\n                if (nextF.to > nextPos) break;\n                nextF = fI < fragments.length ? fragments[fI++] : null;\n            }\n            if (!nextC) break;\n            pos = nextC.toA;\n            off = nextC.toA - nextC.toB;\n        }\n        return result;\n    }\n}\n/**\nA superclass that parsers should extend.\n*/ class Parser {\n    /**\n    Start a parse, returning a [partial parse](#common.PartialParse)\n    object. [`fragments`](#common.TreeFragment) can be passed in to\n    make the parse incremental.\n    \n    By default, the entire input is parsed. You can pass `ranges`,\n    which should be a sorted array of non-empty, non-overlapping\n    ranges, to parse only those ranges. The tree returned in that\n    case will start at `ranges[0].from`.\n    */ startParse(input, fragments, ranges) {\n        if (typeof input == \"string\") input = new StringInput(input);\n        ranges = !ranges ? [\n            new Range(0, input.length)\n        ] : ranges.length ? ranges.map((r)=>new Range(r.from, r.to)) : [\n            new Range(0, 0)\n        ];\n        return this.createParse(input, fragments || [], ranges);\n    }\n    /**\n    Run a full parse, returning the resulting tree.\n    */ parse(input, fragments, ranges) {\n        let parse = this.startParse(input, fragments, ranges);\n        for(;;){\n            let done = parse.advance();\n            if (done) return done;\n        }\n    }\n}\nclass StringInput {\n    constructor(string){\n        this.string = string;\n    }\n    get length() {\n        return this.string.length;\n    }\n    chunk(from) {\n        return this.string.slice(from);\n    }\n    get lineChunks() {\n        return false;\n    }\n    read(from, to) {\n        return this.string.slice(from, to);\n    }\n}\n/**\nCreate a parse wrapper that, after the inner parse completes,\nscans its tree for mixed language regions with the `nest`\nfunction, runs the resulting [inner parses](#common.NestedParse),\nand then [mounts](#common.NodeProp^mounted) their results onto the\ntree.\n*/ function parseMixed(nest) {\n    return (parse, input, fragments, ranges)=>new MixedParse(parse, nest, input, fragments, ranges);\n}\nclass InnerParse {\n    constructor(parser, parse, overlay, target, from){\n        this.parser = parser;\n        this.parse = parse;\n        this.overlay = overlay;\n        this.target = target;\n        this.from = from;\n    }\n}\nfunction checkRanges(ranges) {\n    if (!ranges.length || ranges.some((r)=>r.from >= r.to)) throw new RangeError(\"Invalid inner parse ranges given: \" + JSON.stringify(ranges));\n}\nclass ActiveOverlay {\n    constructor(parser, predicate, mounts, index, start, target, prev){\n        this.parser = parser;\n        this.predicate = predicate;\n        this.mounts = mounts;\n        this.index = index;\n        this.start = start;\n        this.target = target;\n        this.prev = prev;\n        this.depth = 0;\n        this.ranges = [];\n    }\n}\nconst stoppedInner = new NodeProp({\n    perNode: true\n});\nclass MixedParse {\n    constructor(base, nest, input, fragments, ranges){\n        this.nest = nest;\n        this.input = input;\n        this.fragments = fragments;\n        this.ranges = ranges;\n        this.inner = [];\n        this.innerDone = 0;\n        this.baseTree = null;\n        this.stoppedAt = null;\n        this.baseParse = base;\n    }\n    advance() {\n        if (this.baseParse) {\n            let done = this.baseParse.advance();\n            if (!done) return null;\n            this.baseParse = null;\n            this.baseTree = done;\n            this.startInner();\n            if (this.stoppedAt != null) for (let inner of this.inner)inner.parse.stopAt(this.stoppedAt);\n        }\n        if (this.innerDone == this.inner.length) {\n            let result = this.baseTree;\n            if (this.stoppedAt != null) result = new Tree(result.type, result.children, result.positions, result.length, result.propValues.concat([\n                [\n                    stoppedInner,\n                    this.stoppedAt\n                ]\n            ]));\n            return result;\n        }\n        let inner = this.inner[this.innerDone], done = inner.parse.advance();\n        if (done) {\n            this.innerDone++;\n            // This is a somewhat dodgy but super helpful hack where we\n            // patch up nodes created by the inner parse (and thus\n            // presumably not aliased anywhere else) to hold the information\n            // about the inner parse.\n            let props = Object.assign(Object.create(null), inner.target.props);\n            props[NodeProp.mounted.id] = new MountedTree(done, inner.overlay, inner.parser);\n            inner.target.props = props;\n        }\n        return null;\n    }\n    get parsedPos() {\n        if (this.baseParse) return 0;\n        let pos = this.input.length;\n        for(let i = this.innerDone; i < this.inner.length; i++){\n            if (this.inner[i].from < pos) pos = Math.min(pos, this.inner[i].parse.parsedPos);\n        }\n        return pos;\n    }\n    stopAt(pos) {\n        this.stoppedAt = pos;\n        if (this.baseParse) this.baseParse.stopAt(pos);\n        else for(let i = this.innerDone; i < this.inner.length; i++)this.inner[i].parse.stopAt(pos);\n    }\n    startInner() {\n        let fragmentCursor = new FragmentCursor(this.fragments);\n        let overlay = null;\n        let covered = null;\n        let cursor = new TreeCursor(new TreeNode(this.baseTree, this.ranges[0].from, 0, null), IterMode.IncludeAnonymous | IterMode.IgnoreMounts);\n        scan: for(let nest, isCovered;;){\n            let enter = true, range;\n            if (this.stoppedAt != null && cursor.from >= this.stoppedAt) {\n                enter = false;\n            } else if (fragmentCursor.hasNode(cursor)) {\n                if (overlay) {\n                    let match = overlay.mounts.find((m)=>m.frag.from <= cursor.from && m.frag.to >= cursor.to && m.mount.overlay);\n                    if (match) for (let r of match.mount.overlay){\n                        let from = r.from + match.pos, to = r.to + match.pos;\n                        if (from >= cursor.from && to <= cursor.to && !overlay.ranges.some((r)=>r.from < to && r.to > from)) overlay.ranges.push({\n                            from,\n                            to\n                        });\n                    }\n                }\n                enter = false;\n            } else if (covered && (isCovered = checkCover(covered.ranges, cursor.from, cursor.to))) {\n                enter = isCovered != 2 /* Cover.Full */ ;\n            } else if (!cursor.type.isAnonymous && (nest = this.nest(cursor, this.input)) && (cursor.from < cursor.to || !nest.overlay)) {\n                if (!cursor.tree) materialize(cursor);\n                let oldMounts = fragmentCursor.findMounts(cursor.from, nest.parser);\n                if (typeof nest.overlay == \"function\") {\n                    overlay = new ActiveOverlay(nest.parser, nest.overlay, oldMounts, this.inner.length, cursor.from, cursor.tree, overlay);\n                } else {\n                    let ranges = punchRanges(this.ranges, nest.overlay || (cursor.from < cursor.to ? [\n                        new Range(cursor.from, cursor.to)\n                    ] : []));\n                    if (ranges.length) checkRanges(ranges);\n                    if (ranges.length || !nest.overlay) this.inner.push(new InnerParse(nest.parser, ranges.length ? nest.parser.startParse(this.input, enterFragments(oldMounts, ranges), ranges) : nest.parser.startParse(\"\"), nest.overlay ? nest.overlay.map((r)=>new Range(r.from - cursor.from, r.to - cursor.from)) : null, cursor.tree, ranges.length ? ranges[0].from : cursor.from));\n                    if (!nest.overlay) enter = false;\n                    else if (ranges.length) covered = {\n                        ranges,\n                        depth: 0,\n                        prev: covered\n                    };\n                }\n            } else if (overlay && (range = overlay.predicate(cursor))) {\n                if (range === true) range = new Range(cursor.from, cursor.to);\n                if (range.from < range.to) overlay.ranges.push(range);\n            }\n            if (enter && cursor.firstChild()) {\n                if (overlay) overlay.depth++;\n                if (covered) covered.depth++;\n            } else {\n                for(;;){\n                    if (cursor.nextSibling()) break;\n                    if (!cursor.parent()) break scan;\n                    if (overlay && !--overlay.depth) {\n                        let ranges = punchRanges(this.ranges, overlay.ranges);\n                        if (ranges.length) {\n                            checkRanges(ranges);\n                            this.inner.splice(overlay.index, 0, new InnerParse(overlay.parser, overlay.parser.startParse(this.input, enterFragments(overlay.mounts, ranges), ranges), overlay.ranges.map((r)=>new Range(r.from - overlay.start, r.to - overlay.start)), overlay.target, ranges[0].from));\n                        }\n                        overlay = overlay.prev;\n                    }\n                    if (covered && !--covered.depth) covered = covered.prev;\n                }\n            }\n        }\n    }\n}\nfunction checkCover(covered, from, to) {\n    for (let range of covered){\n        if (range.from >= to) break;\n        if (range.to > from) return range.from <= from && range.to >= to ? 2 /* Cover.Full */  : 1 /* Cover.Partial */ ;\n    }\n    return 0 /* Cover.None */ ;\n}\n// Take a piece of buffer and convert it into a stand-alone\n// TreeBuffer.\nfunction sliceBuf(buf, startI, endI, nodes, positions, off) {\n    if (startI < endI) {\n        let from = buf.buffer[startI + 1];\n        nodes.push(buf.slice(startI, endI, from));\n        positions.push(from - off);\n    }\n}\n// This function takes a node that's in a buffer, and converts it, and\n// its parent buffer nodes, into a Tree. This is again acting on the\n// assumption that the trees and buffers have been constructed by the\n// parse that was ran via the mix parser, and thus aren't shared with\n// any other code, making violations of the immutability safe.\nfunction materialize(cursor) {\n    let { node } = cursor, stack = [];\n    // Scan up to the nearest tree\n    do {\n        stack.push(cursor.index);\n        cursor.parent();\n    }while (!cursor.tree);\n    // Find the index of the buffer in that tree\n    let i = 0, base = cursor.tree, off = 0;\n    for(;; i++){\n        off = base.positions[i] + cursor.from;\n        if (off <= node.from && off + base.children[i].length >= node.to) break;\n    }\n    let buf = base.children[i], b = buf.buffer, newStack = [\n        i\n    ];\n    // Split a level in the buffer, putting the nodes before and after\n    // the child that contains `node` into new buffers.\n    function split(startI, endI, type, innerOffset, length, stackPos) {\n        let targetI = stack[stackPos];\n        let children = [], positions = [];\n        sliceBuf(buf, startI, targetI, children, positions, innerOffset);\n        let from = b[targetI + 1], to = b[targetI + 2];\n        newStack.push(children.length);\n        let child = stackPos ? split(targetI + 4, b[targetI + 3], buf.set.types[b[targetI]], from, to - from, stackPos - 1) : node.toTree();\n        children.push(child);\n        positions.push(from - innerOffset);\n        sliceBuf(buf, b[targetI + 3], endI, children, positions, innerOffset);\n        return new Tree(type, children, positions, length);\n    }\n    base.children[i] = split(0, b.length, NodeType.none, 0, buf.length, stack.length - 1);\n    // Move the cursor back to the target node\n    for (let index of newStack){\n        let tree = cursor.tree.children[index], pos = cursor.tree.positions[index];\n        cursor.yield(new TreeNode(tree, pos + cursor.from, index, cursor._tree));\n    }\n}\nclass StructureCursor {\n    constructor(root, offset){\n        this.offset = offset;\n        this.done = false;\n        this.cursor = root.cursor(IterMode.IncludeAnonymous | IterMode.IgnoreMounts);\n    }\n    // Move to the first node (in pre-order) that starts at or after `pos`.\n    moveTo(pos) {\n        let { cursor } = this, p = pos - this.offset;\n        while(!this.done && cursor.from < p){\n            if (cursor.to >= pos && cursor.enter(p, 1, IterMode.IgnoreOverlays | IterMode.ExcludeBuffers)) ;\n            else if (!cursor.next(false)) this.done = true;\n        }\n    }\n    hasNode(cursor) {\n        this.moveTo(cursor.from);\n        if (!this.done && this.cursor.from + this.offset == cursor.from && this.cursor.tree) {\n            for(let tree = this.cursor.tree;;){\n                if (tree == cursor.tree) return true;\n                if (tree.children.length && tree.positions[0] == 0 && tree.children[0] instanceof Tree) tree = tree.children[0];\n                else break;\n            }\n        }\n        return false;\n    }\n}\nclass FragmentCursor {\n    constructor(fragments){\n        var _a;\n        this.fragments = fragments;\n        this.curTo = 0;\n        this.fragI = 0;\n        if (fragments.length) {\n            let first = this.curFrag = fragments[0];\n            this.curTo = (_a = first.tree.prop(stoppedInner)) !== null && _a !== void 0 ? _a : first.to;\n            this.inner = new StructureCursor(first.tree, -first.offset);\n        } else {\n            this.curFrag = this.inner = null;\n        }\n    }\n    hasNode(node) {\n        while(this.curFrag && node.from >= this.curTo)this.nextFrag();\n        return this.curFrag && this.curFrag.from <= node.from && this.curTo >= node.to && this.inner.hasNode(node);\n    }\n    nextFrag() {\n        var _a;\n        this.fragI++;\n        if (this.fragI == this.fragments.length) {\n            this.curFrag = this.inner = null;\n        } else {\n            let frag = this.curFrag = this.fragments[this.fragI];\n            this.curTo = (_a = frag.tree.prop(stoppedInner)) !== null && _a !== void 0 ? _a : frag.to;\n            this.inner = new StructureCursor(frag.tree, -frag.offset);\n        }\n    }\n    findMounts(pos, parser) {\n        var _a;\n        let result = [];\n        if (this.inner) {\n            this.inner.cursor.moveTo(pos, 1);\n            for(let pos = this.inner.cursor.node; pos; pos = pos.parent){\n                let mount = (_a = pos.tree) === null || _a === void 0 ? void 0 : _a.prop(NodeProp.mounted);\n                if (mount && mount.parser == parser) {\n                    for(let i = this.fragI; i < this.fragments.length; i++){\n                        let frag = this.fragments[i];\n                        if (frag.from >= pos.to) break;\n                        if (frag.tree == this.curFrag.tree) result.push({\n                            frag,\n                            pos: pos.from - frag.offset,\n                            mount\n                        });\n                    }\n                }\n            }\n        }\n        return result;\n    }\n}\nfunction punchRanges(outer, ranges) {\n    let copy = null, current = ranges;\n    for(let i = 1, j = 0; i < outer.length; i++){\n        let gapFrom = outer[i - 1].to, gapTo = outer[i].from;\n        for(; j < current.length; j++){\n            let r = current[j];\n            if (r.from >= gapTo) break;\n            if (r.to <= gapFrom) continue;\n            if (!copy) current = copy = ranges.slice();\n            if (r.from < gapFrom) {\n                copy[j] = new Range(r.from, gapFrom);\n                if (r.to > gapTo) copy.splice(j + 1, 0, new Range(gapTo, r.to));\n            } else if (r.to > gapTo) {\n                copy[j--] = new Range(gapTo, r.to);\n            } else {\n                copy.splice(j--, 1);\n            }\n        }\n    }\n    return current;\n}\nfunction findCoverChanges(a, b, from, to) {\n    let iA = 0, iB = 0, inA = false, inB = false, pos = -1e9;\n    let result = [];\n    for(;;){\n        let nextA = iA == a.length ? 1e9 : inA ? a[iA].to : a[iA].from;\n        let nextB = iB == b.length ? 1e9 : inB ? b[iB].to : b[iB].from;\n        if (inA != inB) {\n            let start = Math.max(pos, from), end = Math.min(nextA, nextB, to);\n            if (start < end) result.push(new Range(start, end));\n        }\n        pos = Math.min(nextA, nextB);\n        if (pos == 1e9) break;\n        if (nextA == pos) {\n            if (!inA) inA = true;\n            else {\n                inA = false;\n                iA++;\n            }\n        }\n        if (nextB == pos) {\n            if (!inB) inB = true;\n            else {\n                inB = false;\n                iB++;\n            }\n        }\n    }\n    return result;\n}\n// Given a number of fragments for the outer tree, and a set of ranges\n// to parse, find fragments for inner trees mounted around those\n// ranges, if any.\nfunction enterFragments(mounts, ranges) {\n    let result = [];\n    for (let { pos, mount, frag } of mounts){\n        let startPos = pos + (mount.overlay ? mount.overlay[0].from : 0), endPos = startPos + mount.tree.length;\n        let from = Math.max(frag.from, startPos), to = Math.min(frag.to, endPos);\n        if (mount.overlay) {\n            let overlay = mount.overlay.map((r)=>new Range(r.from + pos, r.to + pos));\n            let changes = findCoverChanges(ranges, overlay, from, to);\n            for(let i = 0, pos = from;; i++){\n                let last = i == changes.length, end = last ? to : changes[i].from;\n                if (end > pos) result.push(new TreeFragment(pos, end, mount.tree, -startPos, frag.from >= pos || frag.openStart, frag.to <= end || frag.openEnd));\n                if (last) break;\n                pos = changes[i].to;\n            }\n        } else {\n            result.push(new TreeFragment(from, to, mount.tree, -startPos, frag.from >= startPos || frag.openStart, frag.to <= endPos || frag.openEnd));\n        }\n    }\n    return result;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxlemVyL2NvbW1vbi9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7QUFFQSxHQUNBLE1BQU1BLHNCQUFzQjtBQUM1QixJQUFJQyxhQUFhO0FBQ2pCLE1BQU1DO0lBQ0ZDLFlBQVlDLElBQUksRUFBRUMsRUFBRSxDQUFFO1FBQ2xCLElBQUksQ0FBQ0QsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQ0MsRUFBRSxHQUFHQTtJQUNkO0FBQ0o7QUFDQTs7OztBQUlBLEdBQ0EsTUFBTUM7SUFDRjs7SUFFQSxHQUNBSCxZQUFZSSxTQUFTLENBQUMsQ0FBQyxDQUFFO1FBQ3JCLElBQUksQ0FBQ0MsRUFBRSxHQUFHUDtRQUNWLElBQUksQ0FBQ1EsT0FBTyxHQUFHLENBQUMsQ0FBQ0YsT0FBT0UsT0FBTztRQUMvQixJQUFJLENBQUNDLFdBQVcsR0FBR0gsT0FBT0csV0FBVyxJQUFLO1lBQ3RDLE1BQU0sSUFBSUMsTUFBTTtRQUNwQjtJQUNKO0lBQ0E7Ozs7Ozs7O0lBUUEsR0FDQUMsSUFBSUMsS0FBSyxFQUFFO1FBQ1AsSUFBSSxJQUFJLENBQUNKLE9BQU8sRUFDWixNQUFNLElBQUlLLFdBQVc7UUFDekIsSUFBSSxPQUFPRCxTQUFTLFlBQ2hCQSxRQUFRRSxTQUFTRixLQUFLLENBQUNBO1FBQzNCLE9BQU8sQ0FBQ0c7WUFDSixJQUFJQyxTQUFTSixNQUFNRztZQUNuQixPQUFPQyxXQUFXQyxZQUFZLE9BQU87Z0JBQUMsSUFBSTtnQkFBRUQ7YUFBTztRQUN2RDtJQUNKO0FBQ0o7QUFDQTs7Ozs7QUFLQSxHQUNBWCxTQUFTYSxRQUFRLEdBQUcsSUFBSWIsU0FBUztJQUFFSSxhQUFhVSxDQUFBQSxNQUFPQSxJQUFJQyxLQUFLLENBQUM7QUFBSztBQUN0RTs7OztBQUlBLEdBQ0FmLFNBQVNnQixRQUFRLEdBQUcsSUFBSWhCLFNBQVM7SUFBRUksYUFBYVUsQ0FBQUEsTUFBT0EsSUFBSUMsS0FBSyxDQUFDO0FBQUs7QUFDdEU7Ozs7QUFJQSxHQUNBZixTQUFTaUIsS0FBSyxHQUFHLElBQUlqQixTQUFTO0lBQUVJLGFBQWFVLENBQUFBLE1BQU9BLElBQUlDLEtBQUssQ0FBQztBQUFLO0FBQ25FOzs7O0FBSUEsR0FDQWYsU0FBU2tCLFdBQVcsR0FBRyxJQUFJbEIsU0FBUztJQUFFRyxTQUFTO0FBQUs7QUFDcEQ7Ozs7O0FBS0EsR0FDQUgsU0FBU21CLFNBQVMsR0FBRyxJQUFJbkIsU0FBUztJQUFFRyxTQUFTO0FBQUs7QUFDbEQ7Ozs7QUFJQSxHQUNBSCxTQUFTb0IsT0FBTyxHQUFHLElBQUlwQixTQUFTO0lBQUVHLFNBQVM7QUFBSztBQUNoRDs7OztBQUlBLEdBQ0EsTUFBTWtCO0lBQ0Z4QixZQUNBOztJQUVBLEdBQ0F5QixJQUFJLEVBQ0o7Ozs7Ozs7O0lBUUEsR0FDQUMsT0FBTyxFQUNQOztJQUVBLEdBQ0FDLE1BQU0sQ0FBRTtRQUNKLElBQUksQ0FBQ0YsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQ0MsT0FBTyxHQUFHQTtRQUNmLElBQUksQ0FBQ0MsTUFBTSxHQUFHQTtJQUNsQjtJQUNBOztJQUVBLEdBQ0EsT0FBT0MsSUFBSUgsSUFBSSxFQUFFO1FBQ2IsT0FBT0EsUUFBUUEsS0FBS0ksS0FBSyxJQUFJSixLQUFLSSxLQUFLLENBQUMxQixTQUFTb0IsT0FBTyxDQUFDbEIsRUFBRSxDQUFDO0lBQ2hFO0FBQ0o7QUFDQSxNQUFNeUIsVUFBVUMsT0FBT0MsTUFBTSxDQUFDO0FBQzlCOztBQUVBLEdBQ0EsTUFBTXBCO0lBQ0Y7O0lBRUEsR0FDQVosWUFDQTs7Ozs7SUFLQSxHQUNBaUMsSUFBSSxFQUNKOztJQUVBLEdBQ0FKLEtBQUssRUFDTDs7O0lBR0EsR0FDQXhCLEVBQUUsRUFDRjs7SUFFQSxHQUNBNkIsUUFBUSxDQUFDLENBQUU7UUFDUCxJQUFJLENBQUNELElBQUksR0FBR0E7UUFDWixJQUFJLENBQUNKLEtBQUssR0FBR0E7UUFDYixJQUFJLENBQUN4QixFQUFFLEdBQUdBO1FBQ1YsSUFBSSxDQUFDNkIsS0FBSyxHQUFHQTtJQUNqQjtJQUNBOztJQUVBLEdBQ0EsT0FBT0MsT0FBT0MsSUFBSSxFQUFFO1FBQ2hCLElBQUlQLFFBQVFPLEtBQUtQLEtBQUssSUFBSU8sS0FBS1AsS0FBSyxDQUFDUSxNQUFNLEdBQUdOLE9BQU9DLE1BQU0sQ0FBQyxRQUFRRjtRQUNwRSxJQUFJSSxRQUFRLENBQUNFLEtBQUtFLEdBQUcsR0FBRyxFQUFFLGdCQUFnQixNQUFLLEtBQU1GLENBQUFBLEtBQUtHLE9BQU8sR0FBRyxFQUFFLG9CQUFvQixNQUFLLEtBQzFGSCxDQUFBQSxLQUFLSSxLQUFLLEdBQUcsRUFBRSxrQkFBa0IsTUFBSyxLQUFNSixDQUFBQSxLQUFLSCxJQUFJLElBQUksT0FBTyxFQUFFLHNCQUFzQixNQUFLO1FBQ2xHLElBQUlwQixPQUFPLElBQUlELFNBQVN3QixLQUFLSCxJQUFJLElBQUksSUFBSUosT0FBT08sS0FBSy9CLEVBQUUsRUFBRTZCO1FBQ3pELElBQUlFLEtBQUtQLEtBQUssRUFDVixLQUFLLElBQUlZLE9BQU9MLEtBQUtQLEtBQUssQ0FBRTtZQUN4QixJQUFJLENBQUNhLE1BQU1DLE9BQU8sQ0FBQ0YsTUFDZkEsTUFBTUEsSUFBSTVCO1lBQ2QsSUFBSTRCLEtBQUs7Z0JBQ0wsSUFBSUEsR0FBRyxDQUFDLEVBQUUsQ0FBQ25DLE9BQU8sRUFDZCxNQUFNLElBQUlLLFdBQVc7Z0JBQ3pCa0IsS0FBSyxDQUFDWSxHQUFHLENBQUMsRUFBRSxDQUFDcEMsRUFBRSxDQUFDLEdBQUdvQyxHQUFHLENBQUMsRUFBRTtZQUM3QjtRQUNKO1FBQ0osT0FBTzVCO0lBQ1g7SUFDQTs7O0lBR0EsR0FDQStCLEtBQUtBLElBQUksRUFBRTtRQUFFLE9BQU8sSUFBSSxDQUFDZixLQUFLLENBQUNlLEtBQUt2QyxFQUFFLENBQUM7SUFBRTtJQUN6Qzs7SUFFQSxHQUNBLElBQUl3QyxRQUFRO1FBQUUsT0FBTyxDQUFDLElBQUksQ0FBQ1gsS0FBSyxHQUFHLEVBQUUsZ0JBQWdCLEdBQWxCLElBQXdCO0lBQUc7SUFDOUQ7O0lBRUEsR0FDQSxJQUFJWSxZQUFZO1FBQUUsT0FBTyxDQUFDLElBQUksQ0FBQ1osS0FBSyxHQUFHLEVBQUUsb0JBQW9CLEdBQXRCLElBQTRCO0lBQUc7SUFDdEU7O0lBRUEsR0FDQSxJQUFJYSxVQUFVO1FBQUUsT0FBTyxDQUFDLElBQUksQ0FBQ2IsS0FBSyxHQUFHLEVBQUUsa0JBQWtCLEdBQXBCLElBQTBCO0lBQUc7SUFDbEU7OztJQUdBLEdBQ0EsSUFBSWMsY0FBYztRQUFFLE9BQU8sQ0FBQyxJQUFJLENBQUNkLEtBQUssR0FBRyxFQUFFLHNCQUFzQixHQUF4QixJQUE4QjtJQUFHO0lBQzFFOzs7SUFHQSxHQUNBZSxHQUFHaEIsSUFBSSxFQUFFO1FBQ0wsSUFBSSxPQUFPQSxRQUFRLFVBQVU7WUFDekIsSUFBSSxJQUFJLENBQUNBLElBQUksSUFBSUEsTUFDYixPQUFPO1lBQ1gsSUFBSWIsUUFBUSxJQUFJLENBQUN3QixJQUFJLENBQUN6QyxTQUFTaUIsS0FBSztZQUNwQyxPQUFPQSxRQUFRQSxNQUFNOEIsT0FBTyxDQUFDakIsUUFBUSxDQUFDLElBQUk7UUFDOUM7UUFDQSxPQUFPLElBQUksQ0FBQzVCLEVBQUUsSUFBSTRCO0lBQ3RCO0lBQ0E7Ozs7Ozs7SUFPQSxHQUNBLE9BQU92QixNQUFNeUMsR0FBRyxFQUFFO1FBQ2QsSUFBSUMsU0FBU3JCLE9BQU9DLE1BQU0sQ0FBQztRQUMzQixJQUFLLElBQUlZLFFBQVFPLElBQ2IsS0FBSyxJQUFJbEIsUUFBUVcsS0FBSzFCLEtBQUssQ0FBQyxLQUN4QmtDLE1BQU0sQ0FBQ25CLEtBQUssR0FBR2tCLEdBQUcsQ0FBQ1AsS0FBSztRQUNoQyxPQUFPLENBQUNTO1lBQ0osSUFBSyxJQUFJQyxTQUFTRCxLQUFLVCxJQUFJLENBQUN6QyxTQUFTaUIsS0FBSyxHQUFHbUMsSUFBSSxDQUFDLEdBQUdBLElBQUtELENBQUFBLFNBQVNBLE9BQU9qQixNQUFNLEdBQUcsSUFBSWtCLElBQUs7Z0JBQ3hGLElBQUlDLFFBQVFKLE1BQU0sQ0FBQ0csSUFBSSxJQUFJRixLQUFLcEIsSUFBSSxHQUFHcUIsTUFBTSxDQUFDQyxFQUFFLENBQUM7Z0JBQ2pELElBQUlDLE9BQ0EsT0FBT0E7WUFDZjtRQUNKO0lBQ0o7QUFDSjtBQUNBOztBQUVBLEdBQ0E1QyxTQUFTNkMsSUFBSSxHQUFHLElBQUk3QyxTQUFTLElBQUltQixPQUFPQyxNQUFNLENBQUMsT0FBTyxHQUFHLEVBQUUsc0JBQXNCO0FBQ2pGOzs7Ozs7OztBQVFBLEdBQ0EsTUFBTTBCO0lBQ0Y7OztJQUdBLEdBQ0ExRCxZQUNBOztJQUVBLEdBQ0EyRCxLQUFLLENBQUU7UUFDSCxJQUFJLENBQUNBLEtBQUssR0FBR0E7UUFDYixJQUFLLElBQUlKLElBQUksR0FBR0EsSUFBSUksTUFBTXRCLE1BQU0sRUFBRWtCLElBQzlCLElBQUlJLEtBQUssQ0FBQ0osRUFBRSxDQUFDbEQsRUFBRSxJQUFJa0QsR0FDZixNQUFNLElBQUk1QyxXQUFXO0lBQ2pDO0lBQ0E7Ozs7SUFJQSxHQUNBaUQsT0FBTyxHQUFHL0IsS0FBSyxFQUFFO1FBQ2IsSUFBSWdDLFdBQVcsRUFBRTtRQUNqQixLQUFLLElBQUloRCxRQUFRLElBQUksQ0FBQzhDLEtBQUssQ0FBRTtZQUN6QixJQUFJRyxXQUFXO1lBQ2YsS0FBSyxJQUFJQyxVQUFVbEMsTUFBTztnQkFDdEIsSUFBSXBCLE1BQU1zRCxPQUFPbEQ7Z0JBQ2pCLElBQUlKLEtBQUs7b0JBQ0wsSUFBSSxDQUFDcUQsVUFDREEsV0FBVy9CLE9BQU9pQyxNQUFNLENBQUMsQ0FBQyxHQUFHbkQsS0FBS2dCLEtBQUs7b0JBQzNDaUMsUUFBUSxDQUFDckQsR0FBRyxDQUFDLEVBQUUsQ0FBQ0osRUFBRSxDQUFDLEdBQUdJLEdBQUcsQ0FBQyxFQUFFO2dCQUNoQztZQUNKO1lBQ0FvRCxTQUFTSSxJQUFJLENBQUNILFdBQVcsSUFBSWxELFNBQVNDLEtBQUtvQixJQUFJLEVBQUU2QixVQUFVakQsS0FBS1IsRUFBRSxFQUFFUSxLQUFLcUIsS0FBSyxJQUFJckI7UUFDdEY7UUFDQSxPQUFPLElBQUk2QyxRQUFRRztJQUN2QjtBQUNKO0FBQ0EsTUFBTUssYUFBYSxJQUFJQyxXQUFXQyxrQkFBa0IsSUFBSUQ7QUFDeEQ7OztBQUdBLEdBQ0EsSUFBSUU7QUFDSCxVQUFVQSxRQUFRO0lBQ2Y7Ozs7SUFJQSxHQUNBQSxRQUFRLENBQUNBLFFBQVEsQ0FBQyxpQkFBaUIsR0FBRyxFQUFFLEdBQUc7SUFDM0M7Ozs7SUFJQSxHQUNBQSxRQUFRLENBQUNBLFFBQVEsQ0FBQyxtQkFBbUIsR0FBRyxFQUFFLEdBQUc7SUFDN0M7Ozs7SUFJQSxHQUNBQSxRQUFRLENBQUNBLFFBQVEsQ0FBQyxlQUFlLEdBQUcsRUFBRSxHQUFHO0lBQ3pDOzs7OztJQUtBLEdBQ0FBLFFBQVEsQ0FBQ0EsUUFBUSxDQUFDLGlCQUFpQixHQUFHLEVBQUUsR0FBRztBQUMvQyxHQUFHQSxZQUFhQSxDQUFBQSxXQUFXLENBQUM7QUFDNUI7Ozs7Ozs7Ozs7Ozs7OztBQWVBLEdBQ0EsTUFBTUM7SUFDRjs7SUFFQSxHQUNBdEUsWUFDQTs7SUFFQSxHQUNBYSxJQUFJLEVBQ0o7O0lBRUEsR0FDQTBELFFBQVEsRUFDUjs7O0lBR0EsR0FDQUMsU0FBUyxFQUNUOztJQUVBLEdBQ0FuQyxNQUFNLEVBQ047O0lBRUEsR0FDQVIsS0FBSyxDQUFFO1FBQ0gsSUFBSSxDQUFDaEIsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQzBELFFBQVEsR0FBR0E7UUFDaEIsSUFBSSxDQUFDQyxTQUFTLEdBQUdBO1FBQ2pCLElBQUksQ0FBQ25DLE1BQU0sR0FBR0E7UUFDZDs7UUFFQSxHQUNBLElBQUksQ0FBQ1IsS0FBSyxHQUFHO1FBQ2IsSUFBSUEsU0FBU0EsTUFBTVEsTUFBTSxFQUFFO1lBQ3ZCLElBQUksQ0FBQ1IsS0FBSyxHQUFHRSxPQUFPQyxNQUFNLENBQUM7WUFDM0IsS0FBSyxJQUFJLENBQUNZLE1BQU02QixNQUFNLElBQUk1QyxNQUN0QixJQUFJLENBQUNBLEtBQUssQ0FBQyxPQUFPZSxRQUFRLFdBQVdBLE9BQU9BLEtBQUt2QyxFQUFFLENBQUMsR0FBR29FO1FBQy9EO0lBQ0o7SUFDQTs7SUFFQSxHQUNBQyxXQUFXO1FBQ1AsSUFBSW5ELFVBQVVDLFlBQVlJLEdBQUcsQ0FBQyxJQUFJO1FBQ2xDLElBQUlMLFdBQVcsQ0FBQ0EsUUFBUUcsT0FBTyxFQUMzQixPQUFPSCxRQUFRRSxJQUFJLENBQUNpRCxRQUFRO1FBQ2hDLElBQUlILFdBQVc7UUFDZixLQUFLLElBQUlJLE1BQU0sSUFBSSxDQUFDSixRQUFRLENBQUU7WUFDMUIsSUFBSXRELE1BQU0wRCxHQUFHRCxRQUFRO1lBQ3JCLElBQUl6RCxLQUFLO2dCQUNMLElBQUlzRCxVQUNBQSxZQUFZO2dCQUNoQkEsWUFBWXREO1lBQ2hCO1FBQ0o7UUFDQSxPQUFPLENBQUMsSUFBSSxDQUFDSixJQUFJLENBQUNvQixJQUFJLEdBQUdzQyxXQUNyQixDQUFDLEtBQUtLLElBQUksQ0FBQyxJQUFJLENBQUMvRCxJQUFJLENBQUNvQixJQUFJLEtBQUssQ0FBQyxJQUFJLENBQUNwQixJQUFJLENBQUNrQyxPQUFPLEdBQUc4QixLQUFLQyxTQUFTLENBQUMsSUFBSSxDQUFDakUsSUFBSSxDQUFDb0IsSUFBSSxJQUFJLElBQUksQ0FBQ3BCLElBQUksQ0FBQ29CLElBQUksSUFDN0ZzQyxDQUFBQSxTQUFTbEMsTUFBTSxHQUFHLE1BQU1rQyxXQUFXLE1BQU0sRUFBQztJQUN2RDtJQUNBOzs7O0lBSUEsR0FDQVEsT0FBT0MsT0FBTyxDQUFDLEVBQUU7UUFDYixPQUFPLElBQUlDLFdBQVcsSUFBSSxDQUFDQyxPQUFPLEVBQUVGO0lBQ3hDO0lBQ0E7Ozs7SUFJQSxHQUNBRyxTQUFTQyxHQUFHLEVBQUVDLE9BQU8sQ0FBQyxFQUFFTCxPQUFPLENBQUMsRUFBRTtRQUM5QixJQUFJTSxRQUFRcEIsV0FBV3RDLEdBQUcsQ0FBQyxJQUFJLEtBQUssSUFBSSxDQUFDc0QsT0FBTztRQUNoRCxJQUFJSCxTQUFTLElBQUlFLFdBQVdLO1FBQzVCUCxPQUFPUSxNQUFNLENBQUNILEtBQUtDO1FBQ25CbkIsV0FBV3NCLEdBQUcsQ0FBQyxJQUFJLEVBQUVULE9BQU9VLEtBQUs7UUFDakMsT0FBT1Y7SUFDWDtJQUNBOzs7SUFHQSxHQUNBLElBQUlHLFVBQVU7UUFDVixPQUFPLElBQUlRLFNBQVMsSUFBSSxFQUFFLEdBQUcsR0FBRztJQUNwQztJQUNBOzs7Ozs7Ozs7O0lBVUEsR0FDQUMsUUFBUVAsR0FBRyxFQUFFQyxPQUFPLENBQUMsRUFBRTtRQUNuQixJQUFJaEMsT0FBT3VDLFlBQVkxQixXQUFXdEMsR0FBRyxDQUFDLElBQUksS0FBSyxJQUFJLENBQUNzRCxPQUFPLEVBQUVFLEtBQUtDLE1BQU07UUFDeEVuQixXQUFXc0IsR0FBRyxDQUFDLElBQUksRUFBRW5DO1FBQ3JCLE9BQU9BO0lBQ1g7SUFDQTs7Ozs7O0lBTUEsR0FDQXdDLGFBQWFULEdBQUcsRUFBRUMsT0FBTyxDQUFDLEVBQUU7UUFDeEIsSUFBSWhDLE9BQU91QyxZQUFZeEIsZ0JBQWdCeEMsR0FBRyxDQUFDLElBQUksS0FBSyxJQUFJLENBQUNzRCxPQUFPLEVBQUVFLEtBQUtDLE1BQU07UUFDN0VqQixnQkFBZ0JvQixHQUFHLENBQUMsSUFBSSxFQUFFbkM7UUFDMUIsT0FBT0E7SUFDWDtJQUNBOzs7Ozs7SUFNQSxHQUNBeUMsYUFBYVYsR0FBRyxFQUFFQyxPQUFPLENBQUMsRUFBRTtRQUN4QixPQUFPVSxjQUFjLElBQUksRUFBRVgsS0FBS0M7SUFDcEM7SUFDQTs7Ozs7O0lBTUEsR0FDQVcsUUFBUTVELElBQUksRUFBRTtRQUNWLElBQUksRUFBRTZELEtBQUssRUFBRUMsS0FBSyxFQUFFakcsT0FBTyxDQUFDLEVBQUVDLEtBQUssSUFBSSxDQUFDbUMsTUFBTSxFQUFFLEdBQUdEO1FBQ25ELElBQUk0QyxPQUFPNUMsS0FBSzRDLElBQUksSUFBSSxHQUFHbUIsT0FBTyxDQUFDbkIsT0FBT1gsU0FBUytCLGdCQUFnQixJQUFJO1FBQ3ZFLElBQUssSUFBSUMsSUFBSSxJQUFJLENBQUN0QixNQUFNLENBQUNDLE9BQU9YLFNBQVMrQixnQkFBZ0IsSUFBSztZQUMxRCxJQUFJRSxVQUFVO1lBQ2QsSUFBSUQsRUFBRXBHLElBQUksSUFBSUMsTUFBTW1HLEVBQUVuRyxFQUFFLElBQUlELFFBQVMsRUFBQ2tHLFFBQVFFLEVBQUV4RixJQUFJLENBQUNtQyxXQUFXLElBQUlpRCxNQUFNSSxPQUFPLEtBQUksR0FBSTtnQkFDckYsSUFBSUEsRUFBRUUsVUFBVSxJQUNaO2dCQUNKRCxVQUFVO1lBQ2Q7WUFDQSxPQUFTO2dCQUNMLElBQUlBLFdBQVdKLFNBQVVDLENBQUFBLFFBQVEsQ0FBQ0UsRUFBRXhGLElBQUksQ0FBQ21DLFdBQVcsR0FDaERrRCxNQUFNRztnQkFDVixJQUFJQSxFQUFFRyxXQUFXLElBQ2I7Z0JBQ0osSUFBSSxDQUFDSCxFQUFFSSxNQUFNLElBQ1Q7Z0JBQ0pILFVBQVU7WUFDZDtRQUNKO0lBQ0o7SUFDQTs7O0lBR0EsR0FDQTFELEtBQUtBLElBQUksRUFBRTtRQUNQLE9BQU8sQ0FBQ0EsS0FBS3RDLE9BQU8sR0FBRyxJQUFJLENBQUNPLElBQUksQ0FBQytCLElBQUksQ0FBQ0EsUUFBUSxJQUFJLENBQUNmLEtBQUssR0FBRyxJQUFJLENBQUNBLEtBQUssQ0FBQ2UsS0FBS3ZDLEVBQUUsQ0FBQyxHQUFHVTtJQUNyRjtJQUNBOzs7O0lBSUEsR0FDQSxJQUFJMkYsYUFBYTtRQUNiLElBQUk1RixTQUFTLEVBQUU7UUFDZixJQUFJLElBQUksQ0FBQ2UsS0FBSyxFQUNWLElBQUssSUFBSXhCLE1BQU0sSUFBSSxDQUFDd0IsS0FBSyxDQUNyQmYsT0FBT21ELElBQUksQ0FBQztZQUFDLENBQUM1RDtZQUFJLElBQUksQ0FBQ3dCLEtBQUssQ0FBQ3hCLEdBQUc7U0FBQztRQUN6QyxPQUFPUztJQUNYO0lBQ0E7Ozs7SUFJQSxHQUNBNkYsUUFBUXZHLFNBQVMsQ0FBQyxDQUFDLEVBQUU7UUFDakIsT0FBTyxJQUFJLENBQUNtRSxRQUFRLENBQUNsQyxNQUFNLElBQUksRUFBRSx3QkFBd0IsTUFBSyxJQUFJLEdBQzlEdUUsYUFBYWhHLFNBQVM2QyxJQUFJLEVBQUUsSUFBSSxDQUFDYyxRQUFRLEVBQUUsSUFBSSxDQUFDQyxTQUFTLEVBQUUsR0FBRyxJQUFJLENBQUNELFFBQVEsQ0FBQ2xDLE1BQU0sRUFBRSxHQUFHLElBQUksQ0FBQ0EsTUFBTSxFQUFFLENBQUNrQyxVQUFVQyxXQUFXbkMsU0FBVyxJQUFJaUMsS0FBSyxJQUFJLENBQUN6RCxJQUFJLEVBQUUwRCxVQUFVQyxXQUFXbkMsUUFBUSxJQUFJLENBQUNxRSxVQUFVLEdBQUd0RyxPQUFPeUcsUUFBUSxJQUFLLEVBQUN0QyxVQUFVQyxXQUFXbkMsU0FBVyxJQUFJaUMsS0FBSzFELFNBQVM2QyxJQUFJLEVBQUVjLFVBQVVDLFdBQVduQyxPQUFNO0lBQ3hUO0lBQ0E7OztJQUdBLEdBQ0EsT0FBT3lFLE1BQU1DLElBQUksRUFBRTtRQUFFLE9BQU9DLFVBQVVEO0lBQU87QUFDakQ7QUFDQTs7QUFFQSxHQUNBekMsS0FBSzJDLEtBQUssR0FBRyxJQUFJM0MsS0FBSzFELFNBQVM2QyxJQUFJLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRTtBQUM3QyxNQUFNeUQ7SUFDRmxILFlBQVltSCxNQUFNLEVBQUVDLEtBQUssQ0FBRTtRQUN2QixJQUFJLENBQUNELE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUNDLEtBQUssR0FBR0E7SUFDakI7SUFDQSxJQUFJL0csS0FBSztRQUFFLE9BQU8sSUFBSSxDQUFDOEcsTUFBTSxDQUFDLElBQUksQ0FBQ0MsS0FBSyxHQUFHLEVBQUU7SUFBRTtJQUMvQyxJQUFJQyxRQUFRO1FBQUUsT0FBTyxJQUFJLENBQUNGLE1BQU0sQ0FBQyxJQUFJLENBQUNDLEtBQUssR0FBRyxFQUFFO0lBQUU7SUFDbEQsSUFBSUUsTUFBTTtRQUFFLE9BQU8sSUFBSSxDQUFDSCxNQUFNLENBQUMsSUFBSSxDQUFDQyxLQUFLLEdBQUcsRUFBRTtJQUFFO0lBQ2hELElBQUlHLE9BQU87UUFBRSxPQUFPLElBQUksQ0FBQ0osTUFBTSxDQUFDLElBQUksQ0FBQ0MsS0FBSyxHQUFHLEVBQUU7SUFBRTtJQUNqRCxJQUFJaEMsTUFBTTtRQUFFLE9BQU8sSUFBSSxDQUFDZ0MsS0FBSztJQUFFO0lBQy9CSSxPQUFPO1FBQUUsSUFBSSxDQUFDSixLQUFLLElBQUk7SUFBRztJQUMxQkssT0FBTztRQUFFLE9BQU8sSUFBSVAsaUJBQWlCLElBQUksQ0FBQ0MsTUFBTSxFQUFFLElBQUksQ0FBQ0MsS0FBSztJQUFHO0FBQ25FO0FBQ0E7Ozs7O0FBS0EsR0FDQSxNQUFNTTtJQUNGOztJQUVBLEdBQ0ExSCxZQUNBOztJQUVBLEdBQ0FtSCxNQUFNLEVBQ047O0lBRUEsR0FDQTlFLE1BQU0sRUFDTjs7SUFFQSxHQUNBbUQsR0FBRyxDQUFFO1FBQ0QsSUFBSSxDQUFDMkIsTUFBTSxHQUFHQTtRQUNkLElBQUksQ0FBQzlFLE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUNtRCxHQUFHLEdBQUdBO0lBQ2Y7SUFDQTs7SUFFQSxHQUNBLElBQUkzRSxPQUFPO1FBQUUsT0FBT0QsU0FBUzZDLElBQUk7SUFBRTtJQUNuQzs7SUFFQSxHQUNBaUIsV0FBVztRQUNQLElBQUk1RCxTQUFTLEVBQUU7UUFDZixJQUFLLElBQUlzRyxRQUFRLEdBQUdBLFFBQVEsSUFBSSxDQUFDRCxNQUFNLENBQUM5RSxNQUFNLEVBQUc7WUFDN0N2QixPQUFPbUQsSUFBSSxDQUFDLElBQUksQ0FBQzBELFdBQVcsQ0FBQ1A7WUFDN0JBLFFBQVEsSUFBSSxDQUFDRCxNQUFNLENBQUNDLFFBQVEsRUFBRTtRQUNsQztRQUNBLE9BQU90RyxPQUFPOEcsSUFBSSxDQUFDO0lBQ3ZCO0lBQ0E7O0lBRUEsR0FDQUQsWUFBWVAsS0FBSyxFQUFFO1FBQ2YsSUFBSS9HLEtBQUssSUFBSSxDQUFDOEcsTUFBTSxDQUFDQyxNQUFNLEVBQUVTLFdBQVcsSUFBSSxDQUFDVixNQUFNLENBQUNDLFFBQVEsRUFBRTtRQUM5RCxJQUFJdkcsT0FBTyxJQUFJLENBQUMyRSxHQUFHLENBQUM3QixLQUFLLENBQUN0RCxHQUFHLEVBQUVTLFNBQVNELEtBQUtvQixJQUFJO1FBQ2pELElBQUksS0FBSzJDLElBQUksQ0FBQzlELFdBQVcsQ0FBQ0QsS0FBS2tDLE9BQU8sRUFDbENqQyxTQUFTK0QsS0FBS0MsU0FBUyxDQUFDaEU7UUFDNUJzRyxTQUFTO1FBQ1QsSUFBSVMsWUFBWVQsT0FDWixPQUFPdEc7UUFDWCxJQUFJeUQsV0FBVyxFQUFFO1FBQ2pCLE1BQU82QyxRQUFRUyxTQUFVO1lBQ3JCdEQsU0FBU04sSUFBSSxDQUFDLElBQUksQ0FBQzBELFdBQVcsQ0FBQ1A7WUFDL0JBLFFBQVEsSUFBSSxDQUFDRCxNQUFNLENBQUNDLFFBQVEsRUFBRTtRQUNsQztRQUNBLE9BQU90RyxTQUFTLE1BQU15RCxTQUFTcUQsSUFBSSxDQUFDLE9BQU87SUFDL0M7SUFDQTs7SUFFQSxHQUNBRSxVQUFVQyxVQUFVLEVBQUVGLFFBQVEsRUFBRUcsR0FBRyxFQUFFNUMsR0FBRyxFQUFFQyxJQUFJLEVBQUU7UUFDNUMsSUFBSSxFQUFFOEIsTUFBTSxFQUFFLEdBQUcsSUFBSSxFQUFFYyxPQUFPLENBQUM7UUFDL0IsSUFBSyxJQUFJMUUsSUFBSXdFLFlBQVl4RSxLQUFLc0UsVUFBVXRFLElBQUk0RCxNQUFNLENBQUM1RCxJQUFJLEVBQUUsQ0FBRTtZQUN2RCxJQUFJMkUsVUFBVTdDLE1BQU1ELEtBQUsrQixNQUFNLENBQUM1RCxJQUFJLEVBQUUsRUFBRTRELE1BQU0sQ0FBQzVELElBQUksRUFBRSxHQUFHO2dCQUNwRDBFLE9BQU8xRTtnQkFDUCxJQUFJeUUsTUFBTSxHQUNOO1lBQ1I7UUFDSjtRQUNBLE9BQU9DO0lBQ1g7SUFDQTs7SUFFQSxHQUNBRSxNQUFNQyxNQUFNLEVBQUVDLElBQUksRUFBRXBJLElBQUksRUFBRTtRQUN0QixJQUFJcUksSUFBSSxJQUFJLENBQUNuQixNQUFNO1FBQ25CLElBQUlvQixPQUFPLElBQUlDLFlBQVlILE9BQU9ELFNBQVNLLE1BQU07UUFDakQsSUFBSyxJQUFJbEYsSUFBSTZFLFFBQVFNLElBQUksR0FBR25GLElBQUk4RSxNQUFPO1lBQ25DRSxJQUFJLENBQUNHLElBQUksR0FBR0osQ0FBQyxDQUFDL0UsSUFBSTtZQUNsQmdGLElBQUksQ0FBQ0csSUFBSSxHQUFHSixDQUFDLENBQUMvRSxJQUFJLEdBQUd0RDtZQUNyQixJQUFJQyxLQUFLcUksSUFBSSxDQUFDRyxJQUFJLEdBQUdKLENBQUMsQ0FBQy9FLElBQUksR0FBR3REO1lBQzlCc0ksSUFBSSxDQUFDRyxJQUFJLEdBQUdKLENBQUMsQ0FBQy9FLElBQUksR0FBRzZFO1lBQ3JCSyxNQUFNRSxLQUFLQyxHQUFHLENBQUNILEtBQUt2STtRQUN4QjtRQUNBLE9BQU8sSUFBSXdILFdBQVdhLE1BQU1FLEtBQUssSUFBSSxDQUFDakQsR0FBRztJQUM3QztBQUNKO0FBQ0EsU0FBUzBDLFVBQVU3QyxJQUFJLEVBQUVELEdBQUcsRUFBRW5GLElBQUksRUFBRUMsRUFBRTtJQUNsQyxPQUFRbUY7UUFDSixLQUFLLENBQUMsRUFBRSxlQUFlO1lBQUksT0FBT3BGLE9BQU9tRjtRQUN6QyxLQUFLLENBQUMsRUFBRSxtQkFBbUI7WUFBSSxPQUFPbEYsTUFBTWtGLE9BQU9uRixPQUFPbUY7UUFDMUQsS0FBSyxFQUFFLGVBQWU7WUFBSSxPQUFPbkYsT0FBT21GLE9BQU9sRixLQUFLa0Y7UUFDcEQsS0FBSyxFQUFFLGtCQUFrQjtZQUFJLE9BQU9uRixRQUFRbUYsT0FBT2xGLEtBQUtrRjtRQUN4RCxLQUFLLEVBQUUsY0FBYztZQUFJLE9BQU9sRixLQUFLa0Y7UUFDckMsS0FBSyxFQUFFLGlCQUFpQjtZQUFJLE9BQU87SUFDdkM7QUFDSjtBQUNBLFNBQVNRLFlBQVl2QyxJQUFJLEVBQUUrQixHQUFHLEVBQUVDLElBQUksRUFBRXdELFFBQVE7SUFDMUMsSUFBSUM7SUFDSixrRUFBa0U7SUFDbEUsTUFBT3pGLEtBQUtwRCxJQUFJLElBQUlvRCxLQUFLbkQsRUFBRSxJQUN0Qm1GLENBQUFBLE9BQU8sSUFBSWhDLEtBQUtwRCxJQUFJLElBQUltRixNQUFNL0IsS0FBS3BELElBQUksR0FBR21GLEdBQUUsS0FDNUNDLENBQUFBLE9BQU8sQ0FBQyxJQUFJaEMsS0FBS25ELEVBQUUsSUFBSWtGLE1BQU0vQixLQUFLbkQsRUFBRSxHQUFHa0YsR0FBRSxFQUFJO1FBQzlDLElBQUlxQixTQUFTLENBQUNvQyxZQUFZeEYsZ0JBQWdCcUMsWUFBWXJDLEtBQUsrRCxLQUFLLEdBQUcsSUFBSSxPQUFPL0QsS0FBS29ELE1BQU07UUFDekYsSUFBSSxDQUFDQSxRQUNELE9BQU9wRDtRQUNYQSxPQUFPb0Q7SUFDWDtJQUNBLElBQUl6QixPQUFPNkQsV0FBVyxJQUFJeEUsU0FBUzBFLGNBQWM7SUFDakQsZ0VBQWdFO0lBQ2hFLElBQUlGLFVBQ0EsSUFBSyxJQUFJRyxPQUFPM0YsTUFBTW9ELFNBQVN1QyxLQUFLdkMsTUFBTSxFQUFFQSxRQUFRdUMsT0FBT3ZDLFFBQVFBLFNBQVN1QyxLQUFLdkMsTUFBTSxDQUFFO1FBQ3JGLElBQUl1QyxnQkFBZ0J0RCxZQUFZc0QsS0FBSzVCLEtBQUssR0FBRyxLQUFLLENBQUMsQ0FBQzBCLEtBQUtyQyxPQUFPUixLQUFLLENBQUNiLEtBQUtDLE1BQU1MLEtBQUksTUFBTyxRQUFROEQsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHN0ksSUFBSSxLQUFLK0ksS0FBSy9JLElBQUksRUFDOUlvRCxPQUFPb0Q7SUFDZjtJQUNKLE9BQVM7UUFDTCxJQUFJd0MsUUFBUTVGLEtBQUs0QyxLQUFLLENBQUNiLEtBQUtDLE1BQU1MO1FBQ2xDLElBQUksQ0FBQ2lFLE9BQ0QsT0FBTzVGO1FBQ1hBLE9BQU80RjtJQUNYO0FBQ0o7QUFDQSxNQUFNQztJQUNGbkUsT0FBT0MsT0FBTyxDQUFDLEVBQUU7UUFBRSxPQUFPLElBQUlDLFdBQVcsSUFBSSxFQUFFRDtJQUFPO0lBQ3REbUUsU0FBU3RJLElBQUksRUFBRXVJLFNBQVMsSUFBSSxFQUFFQyxRQUFRLElBQUksRUFBRTtRQUN4QyxJQUFJQyxJQUFJQyxZQUFZLElBQUksRUFBRTFJLE1BQU11SSxRQUFRQztRQUN4QyxPQUFPQyxFQUFFakgsTUFBTSxHQUFHaUgsQ0FBQyxDQUFDLEVBQUUsR0FBRztJQUM3QjtJQUNBQyxZQUFZMUksSUFBSSxFQUFFdUksU0FBUyxJQUFJLEVBQUVDLFFBQVEsSUFBSSxFQUFFO1FBQzNDLE9BQU9FLFlBQVksSUFBSSxFQUFFMUksTUFBTXVJLFFBQVFDO0lBQzNDO0lBQ0ExRCxRQUFRUCxHQUFHLEVBQUVDLE9BQU8sQ0FBQyxFQUFFO1FBQ25CLE9BQU9PLFlBQVksSUFBSSxFQUFFUixLQUFLQyxNQUFNO0lBQ3hDO0lBQ0FRLGFBQWFULEdBQUcsRUFBRUMsT0FBTyxDQUFDLEVBQUU7UUFDeEIsT0FBT08sWUFBWSxJQUFJLEVBQUVSLEtBQUtDLE1BQU07SUFDeEM7SUFDQW1FLGFBQWFDLE9BQU8sRUFBRTtRQUNsQixPQUFPQyxpQkFBaUIsSUFBSSxFQUFFRDtJQUNsQztJQUNBRSwyQkFBMkJ2RSxHQUFHLEVBQUU7UUFDNUIsSUFBSTRELE9BQU8sSUFBSSxDQUFDWSxXQUFXLENBQUN4RSxNQUFNL0IsT0FBTyxJQUFJO1FBQzdDLE1BQU8yRixLQUFNO1lBQ1QsSUFBSWEsT0FBT2IsS0FBS2MsU0FBUztZQUN6QixJQUFJLENBQUNELFFBQVFBLEtBQUszSixFQUFFLElBQUk4SSxLQUFLOUksRUFBRSxFQUMzQjtZQUNKLElBQUkySixLQUFLaEosSUFBSSxDQUFDa0MsT0FBTyxJQUFJOEcsS0FBSzVKLElBQUksSUFBSTRKLEtBQUszSixFQUFFLEVBQUU7Z0JBQzNDbUQsT0FBTzJGO2dCQUNQQSxPQUFPYSxLQUFLRSxXQUFXO1lBQzNCLE9BQ0s7Z0JBQ0RmLE9BQU9hO1lBQ1g7UUFDSjtRQUNBLE9BQU94RztJQUNYO0lBQ0EsSUFBSUEsT0FBTztRQUFFLE9BQU8sSUFBSTtJQUFFO0lBQzFCLElBQUltRSxPQUFPO1FBQUUsT0FBTyxJQUFJLENBQUNmLE1BQU07SUFBRTtBQUNyQztBQUNBLE1BQU1mLGlCQUFpQndEO0lBQ25CbEosWUFBWXlGLEtBQUssRUFBRXhGLElBQUksRUFDdkIsOEZBQThGO0lBQzlGbUgsS0FBSyxFQUFFNEMsT0FBTyxDQUFFO1FBQ1osS0FBSztRQUNMLElBQUksQ0FBQ3ZFLEtBQUssR0FBR0E7UUFDYixJQUFJLENBQUN4RixJQUFJLEdBQUdBO1FBQ1osSUFBSSxDQUFDbUgsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQzRDLE9BQU8sR0FBR0E7SUFDbkI7SUFDQSxJQUFJbkosT0FBTztRQUFFLE9BQU8sSUFBSSxDQUFDNEUsS0FBSyxDQUFDNUUsSUFBSTtJQUFFO0lBQ3JDLElBQUlvQixPQUFPO1FBQUUsT0FBTyxJQUFJLENBQUN3RCxLQUFLLENBQUM1RSxJQUFJLENBQUNvQixJQUFJO0lBQUU7SUFDMUMsSUFBSS9CLEtBQUs7UUFBRSxPQUFPLElBQUksQ0FBQ0QsSUFBSSxHQUFHLElBQUksQ0FBQ3dGLEtBQUssQ0FBQ3BELE1BQU07SUFBRTtJQUNqRDRILFVBQVUxRyxDQUFDLEVBQUV5RSxHQUFHLEVBQUU1QyxHQUFHLEVBQUVDLElBQUksRUFBRUwsT0FBTyxDQUFDLEVBQUU7UUFDbkMsSUFBSyxJQUFJeUIsU0FBUyxJQUFJLEdBQUk7WUFDdEIsSUFBSyxJQUFJLEVBQUVsQyxRQUFRLEVBQUVDLFNBQVMsRUFBRSxHQUFHaUMsT0FBT2hCLEtBQUssRUFBRXlFLElBQUlsQyxNQUFNLElBQUl6RCxTQUFTbEMsTUFBTSxHQUFHLENBQUMsR0FBR2tCLEtBQUsyRyxHQUFHM0csS0FBS3lFLElBQUs7Z0JBQ25HLElBQUlSLE9BQU9qRCxRQUFRLENBQUNoQixFQUFFLEVBQUU4RCxRQUFRN0MsU0FBUyxDQUFDakIsRUFBRSxHQUFHa0QsT0FBT3hHLElBQUk7Z0JBQzFELElBQUksQ0FBQ2lJLFVBQVU3QyxNQUFNRCxLQUFLaUMsT0FBT0EsUUFBUUcsS0FBS25GLE1BQU0sR0FDaEQ7Z0JBQ0osSUFBSW1GLGdCQUFnQkUsWUFBWTtvQkFDNUIsSUFBSTFDLE9BQU9YLFNBQVM4RixjQUFjLEVBQzlCO29CQUNKLElBQUkvQyxRQUFRSSxLQUFLTSxTQUFTLENBQUMsR0FBR04sS0FBS0wsTUFBTSxDQUFDOUUsTUFBTSxFQUFFMkYsS0FBSzVDLE1BQU1pQyxPQUFPaEM7b0JBQ3BFLElBQUkrQixRQUFRLENBQUMsR0FDVCxPQUFPLElBQUlnRCxXQUFXLElBQUlDLGNBQWM1RCxRQUFRZSxNQUFNakUsR0FBRzhELFFBQVEsTUFBTUQ7Z0JBQy9FLE9BQ0ssSUFBSSxPQUFRL0MsU0FBUytCLGdCQUFnQixJQUFNLENBQUNvQixLQUFLM0csSUFBSSxDQUFDbUMsV0FBVyxJQUFJc0gsU0FBUzlDLE9BQVE7b0JBQ3ZGLElBQUlqRztvQkFDSixJQUFJLENBQUV5RCxDQUFBQSxPQUFPWCxTQUFTa0csWUFBWSxLQUFNaEosQ0FBQUEsVUFBVUMsWUFBWUksR0FBRyxDQUFDNEYsS0FBSSxLQUFNLENBQUNqRyxRQUFRRyxPQUFPLEVBQ3hGLE9BQU8sSUFBSWdFLFNBQVNuRSxRQUFRRSxJQUFJLEVBQUU0RixPQUFPOUQsR0FBR2tEO29CQUNoRCxJQUFJd0MsUUFBUSxJQUFJdkQsU0FBUzhCLE1BQU1ILE9BQU85RCxHQUFHa0Q7b0JBQ3pDLE9BQU8sT0FBUXBDLFNBQVMrQixnQkFBZ0IsSUFBSyxDQUFDNkMsTUFBTXBJLElBQUksQ0FBQ21DLFdBQVcsR0FBR2lHLFFBQ2pFQSxNQUFNZ0IsU0FBUyxDQUFDakMsTUFBTSxJQUFJUixLQUFLakQsUUFBUSxDQUFDbEMsTUFBTSxHQUFHLElBQUksR0FBRzJGLEtBQUs1QyxLQUFLQztnQkFDNUU7WUFDSjtZQUNBLElBQUksT0FBUWhCLFNBQVMrQixnQkFBZ0IsSUFBSyxDQUFDSyxPQUFPNUYsSUFBSSxDQUFDbUMsV0FBVyxFQUM5RCxPQUFPO1lBQ1gsSUFBSXlELE9BQU9XLEtBQUssSUFBSSxHQUNoQjdELElBQUlrRCxPQUFPVyxLQUFLLEdBQUdZO2lCQUVuQnpFLElBQUl5RSxNQUFNLElBQUksQ0FBQyxJQUFJdkIsT0FBT3VELE9BQU8sQ0FBQ3ZFLEtBQUssQ0FBQ2xCLFFBQVEsQ0FBQ2xDLE1BQU07WUFDM0RvRSxTQUFTQSxPQUFPdUQsT0FBTztZQUN2QixJQUFJLENBQUN2RCxRQUNELE9BQU87UUFDZjtJQUNKO0lBQ0EsSUFBSUYsYUFBYTtRQUFFLE9BQU8sSUFBSSxDQUFDMEQsU0FBUyxDQUFDLEdBQUcsR0FBRyxHQUFHLEVBQUUsaUJBQWlCO0lBQUs7SUFDMUUsSUFBSUgsWUFBWTtRQUFFLE9BQU8sSUFBSSxDQUFDRyxTQUFTLENBQUMsSUFBSSxDQUFDeEUsS0FBSyxDQUFDbEIsUUFBUSxDQUFDbEMsTUFBTSxHQUFHLEdBQUcsQ0FBQyxHQUFHLEdBQUcsRUFBRSxpQkFBaUI7SUFBSztJQUN2R21JLFdBQVdwRixHQUFHLEVBQUU7UUFBRSxPQUFPLElBQUksQ0FBQzZFLFNBQVMsQ0FBQyxHQUFHLEdBQUc3RSxLQUFLLEVBQUUsY0FBYztJQUFLO0lBQ3hFd0UsWUFBWXhFLEdBQUcsRUFBRTtRQUFFLE9BQU8sSUFBSSxDQUFDNkUsU0FBUyxDQUFDLElBQUksQ0FBQ3hFLEtBQUssQ0FBQ2xCLFFBQVEsQ0FBQ2xDLE1BQU0sR0FBRyxHQUFHLENBQUMsR0FBRytDLEtBQUssQ0FBQyxFQUFFLGVBQWU7SUFBSztJQUN6R2EsTUFBTWIsR0FBRyxFQUFFQyxJQUFJLEVBQUVMLE9BQU8sQ0FBQyxFQUFFO1FBQ3ZCLElBQUl6RDtRQUNKLElBQUksQ0FBRXlELENBQUFBLE9BQU9YLFNBQVMwRSxjQUFjLEtBQU14SCxDQUFBQSxVQUFVQyxZQUFZSSxHQUFHLENBQUMsSUFBSSxDQUFDNkQsS0FBSyxNQUFNbEUsUUFBUUcsT0FBTyxFQUFFO1lBQ2pHLElBQUkrSSxPQUFPckYsTUFBTSxJQUFJLENBQUNuRixJQUFJO1lBQzFCLEtBQUssSUFBSSxFQUFFQSxJQUFJLEVBQUVDLEVBQUUsRUFBRSxJQUFJcUIsUUFBUUcsT0FBTyxDQUFFO2dCQUN0QyxJQUFJLENBQUMyRCxPQUFPLElBQUlwRixRQUFRd0ssT0FBT3hLLE9BQU93SyxJQUFHLEtBQ3BDcEYsQ0FBQUEsT0FBTyxJQUFJbkYsTUFBTXVLLE9BQU92SyxLQUFLdUssSUFBRyxHQUNqQyxPQUFPLElBQUkvRSxTQUFTbkUsUUFBUUUsSUFBSSxFQUFFRixRQUFRRyxPQUFPLENBQUMsRUFBRSxDQUFDekIsSUFBSSxHQUFHLElBQUksQ0FBQ0EsSUFBSSxFQUFFLENBQUMsR0FBRyxJQUFJO1lBQ3ZGO1FBQ0o7UUFDQSxPQUFPLElBQUksQ0FBQ2dLLFNBQVMsQ0FBQyxHQUFHLEdBQUc3RSxLQUFLQyxNQUFNTDtJQUMzQztJQUNBMEYsd0JBQXdCO1FBQ3BCLElBQUlDLE1BQU0sSUFBSTtRQUNkLE1BQU9BLElBQUk5SixJQUFJLENBQUNtQyxXQUFXLElBQUkySCxJQUFJWCxPQUFPLENBQ3RDVyxNQUFNQSxJQUFJWCxPQUFPO1FBQ3JCLE9BQU9XO0lBQ1g7SUFDQSxJQUFJbEUsU0FBUztRQUNULE9BQU8sSUFBSSxDQUFDdUQsT0FBTyxHQUFHLElBQUksQ0FBQ0EsT0FBTyxDQUFDVSxxQkFBcUIsS0FBSztJQUNqRTtJQUNBLElBQUlsRSxjQUFjO1FBQ2QsT0FBTyxJQUFJLENBQUN3RCxPQUFPLElBQUksSUFBSSxDQUFDNUMsS0FBSyxJQUFJLElBQUksSUFBSSxDQUFDNEMsT0FBTyxDQUFDQyxTQUFTLENBQUMsSUFBSSxDQUFDN0MsS0FBSyxHQUFHLEdBQUcsR0FBRyxHQUFHLEVBQUUsaUJBQWlCLE9BQU07SUFDbkg7SUFDQSxJQUFJMkMsY0FBYztRQUNkLE9BQU8sSUFBSSxDQUFDQyxPQUFPLElBQUksSUFBSSxDQUFDNUMsS0FBSyxJQUFJLElBQUksSUFBSSxDQUFDNEMsT0FBTyxDQUFDQyxTQUFTLENBQUMsSUFBSSxDQUFDN0MsS0FBSyxHQUFHLEdBQUcsQ0FBQyxHQUFHLEdBQUcsRUFBRSxpQkFBaUIsT0FBTTtJQUNwSDtJQUNBLElBQUkzRixPQUFPO1FBQUUsT0FBTyxJQUFJLENBQUNnRSxLQUFLO0lBQUU7SUFDaENtRixTQUFTO1FBQUUsT0FBTyxJQUFJLENBQUNuRixLQUFLO0lBQUU7SUFDOUI7O0lBRUEsR0FDQWYsV0FBVztRQUFFLE9BQU8sSUFBSSxDQUFDZSxLQUFLLENBQUNmLFFBQVE7SUFBSTtBQUMvQztBQUNBLFNBQVM2RSxZQUFZbEcsSUFBSSxFQUFFeEMsSUFBSSxFQUFFdUksTUFBTSxFQUFFQyxLQUFLO0lBQzFDLElBQUl3QixNQUFNeEgsS0FBSzBCLE1BQU0sSUFBSWpFLFNBQVMsRUFBRTtJQUNwQyxJQUFJLENBQUMrSixJQUFJdEUsVUFBVSxJQUNmLE9BQU96RjtJQUNYLElBQUlzSSxVQUFVLE1BQ1Y7UUFBQSxNQUFPLENBQUN5QixJQUFJaEssSUFBSSxDQUFDb0MsRUFBRSxDQUFDbUcsUUFDaEIsSUFBSSxDQUFDeUIsSUFBSXJFLFdBQVcsSUFDaEIsT0FBTzFGO0lBQU07SUFDekIsT0FBUztRQUNMLElBQUl1SSxTQUFTLFFBQVF3QixJQUFJaEssSUFBSSxDQUFDb0MsRUFBRSxDQUFDb0csUUFDN0IsT0FBT3ZJO1FBQ1gsSUFBSStKLElBQUloSyxJQUFJLENBQUNvQyxFQUFFLENBQUNwQyxPQUNaQyxPQUFPbUQsSUFBSSxDQUFDNEcsSUFBSXhILElBQUk7UUFDeEIsSUFBSSxDQUFDd0gsSUFBSXJFLFdBQVcsSUFDaEIsT0FBTzZDLFNBQVMsT0FBT3ZJLFNBQVMsRUFBRTtJQUMxQztBQUNKO0FBQ0EsU0FBUzRJLGlCQUFpQnJHLElBQUksRUFBRW9HLE9BQU8sRUFBRWxHLElBQUlrRyxRQUFRcEgsTUFBTSxHQUFHLENBQUM7SUFDM0QsSUFBSyxJQUFJeUksSUFBSXpILEtBQUtvRCxNQUFNLEVBQUVsRCxLQUFLLEdBQUd1SCxJQUFJQSxFQUFFckUsTUFBTSxDQUFFO1FBQzVDLElBQUksQ0FBQ3FFLEdBQ0QsT0FBTztRQUNYLElBQUksQ0FBQ0EsRUFBRWpLLElBQUksQ0FBQ21DLFdBQVcsRUFBRTtZQUNyQixJQUFJeUcsT0FBTyxDQUFDbEcsRUFBRSxJQUFJa0csT0FBTyxDQUFDbEcsRUFBRSxJQUFJdUgsRUFBRTdJLElBQUksRUFDbEMsT0FBTztZQUNYc0I7UUFDSjtJQUNKO0lBQ0EsT0FBTztBQUNYO0FBQ0EsTUFBTThHO0lBQ0ZySyxZQUFZeUcsTUFBTSxFQUFFVSxNQUFNLEVBQUVDLEtBQUssRUFBRUMsS0FBSyxDQUFFO1FBQ3RDLElBQUksQ0FBQ1osTUFBTSxHQUFHQTtRQUNkLElBQUksQ0FBQ1UsTUFBTSxHQUFHQTtRQUNkLElBQUksQ0FBQ0MsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQ0MsS0FBSyxHQUFHQTtJQUNqQjtBQUNKO0FBQ0EsTUFBTStDLG1CQUFtQmxCO0lBQ3JCLElBQUlqSCxPQUFPO1FBQUUsT0FBTyxJQUFJLENBQUNwQixJQUFJLENBQUNvQixJQUFJO0lBQUU7SUFDcEMsSUFBSWhDLE9BQU87UUFBRSxPQUFPLElBQUksQ0FBQ3dKLE9BQU8sQ0FBQ3BDLEtBQUssR0FBRyxJQUFJLENBQUNvQyxPQUFPLENBQUN0QyxNQUFNLENBQUNBLE1BQU0sQ0FBQyxJQUFJLENBQUNDLEtBQUssR0FBRyxFQUFFO0lBQUU7SUFDckYsSUFBSWxILEtBQUs7UUFBRSxPQUFPLElBQUksQ0FBQ3VKLE9BQU8sQ0FBQ3BDLEtBQUssR0FBRyxJQUFJLENBQUNvQyxPQUFPLENBQUN0QyxNQUFNLENBQUNBLE1BQU0sQ0FBQyxJQUFJLENBQUNDLEtBQUssR0FBRyxFQUFFO0lBQUU7SUFDbkZwSCxZQUFZeUosT0FBTyxFQUFFTyxPQUFPLEVBQUU1QyxLQUFLLENBQUU7UUFDakMsS0FBSztRQUNMLElBQUksQ0FBQ3FDLE9BQU8sR0FBR0E7UUFDZixJQUFJLENBQUNPLE9BQU8sR0FBR0E7UUFDZixJQUFJLENBQUM1QyxLQUFLLEdBQUdBO1FBQ2IsSUFBSSxDQUFDdkcsSUFBSSxHQUFHNEksUUFBUXRDLE1BQU0sQ0FBQzNCLEdBQUcsQ0FBQzdCLEtBQUssQ0FBQzhGLFFBQVF0QyxNQUFNLENBQUNBLE1BQU0sQ0FBQ0MsTUFBTSxDQUFDO0lBQ3RFO0lBQ0EyRCxNQUFNL0MsR0FBRyxFQUFFNUMsR0FBRyxFQUFFQyxJQUFJLEVBQUU7UUFDbEIsSUFBSSxFQUFFOEIsTUFBTSxFQUFFLEdBQUcsSUFBSSxDQUFDc0MsT0FBTztRQUM3QixJQUFJckMsUUFBUUQsT0FBT1csU0FBUyxDQUFDLElBQUksQ0FBQ1YsS0FBSyxHQUFHLEdBQUdELE9BQU9BLE1BQU0sQ0FBQyxJQUFJLENBQUNDLEtBQUssR0FBRyxFQUFFLEVBQUVZLEtBQUs1QyxNQUFNLElBQUksQ0FBQ3FFLE9BQU8sQ0FBQ3BDLEtBQUssRUFBRWhDO1FBQzNHLE9BQU8rQixRQUFRLElBQUksT0FBTyxJQUFJZ0QsV0FBVyxJQUFJLENBQUNYLE9BQU8sRUFBRSxJQUFJLEVBQUVyQztJQUNqRTtJQUNBLElBQUliLGFBQWE7UUFBRSxPQUFPLElBQUksQ0FBQ3dFLEtBQUssQ0FBQyxHQUFHLEdBQUcsRUFBRSxpQkFBaUI7SUFBSztJQUNuRSxJQUFJakIsWUFBWTtRQUFFLE9BQU8sSUFBSSxDQUFDaUIsS0FBSyxDQUFDLENBQUMsR0FBRyxHQUFHLEVBQUUsaUJBQWlCO0lBQUs7SUFDbkVQLFdBQVdwRixHQUFHLEVBQUU7UUFBRSxPQUFPLElBQUksQ0FBQzJGLEtBQUssQ0FBQyxHQUFHM0YsS0FBSyxFQUFFLGNBQWM7SUFBSztJQUNqRXdFLFlBQVl4RSxHQUFHLEVBQUU7UUFBRSxPQUFPLElBQUksQ0FBQzJGLEtBQUssQ0FBQyxDQUFDLEdBQUczRixLQUFLLENBQUMsRUFBRSxlQUFlO0lBQUs7SUFDckVhLE1BQU1iLEdBQUcsRUFBRUMsSUFBSSxFQUFFTCxPQUFPLENBQUMsRUFBRTtRQUN2QixJQUFJQSxPQUFPWCxTQUFTOEYsY0FBYyxFQUM5QixPQUFPO1FBQ1gsSUFBSSxFQUFFaEQsTUFBTSxFQUFFLEdBQUcsSUFBSSxDQUFDc0MsT0FBTztRQUM3QixJQUFJckMsUUFBUUQsT0FBT1csU0FBUyxDQUFDLElBQUksQ0FBQ1YsS0FBSyxHQUFHLEdBQUdELE9BQU9BLE1BQU0sQ0FBQyxJQUFJLENBQUNDLEtBQUssR0FBRyxFQUFFLEVBQUUvQixPQUFPLElBQUksSUFBSSxDQUFDLEdBQUdELE1BQU0sSUFBSSxDQUFDcUUsT0FBTyxDQUFDcEMsS0FBSyxFQUFFaEM7UUFDekgsT0FBTytCLFFBQVEsSUFBSSxPQUFPLElBQUlnRCxXQUFXLElBQUksQ0FBQ1gsT0FBTyxFQUFFLElBQUksRUFBRXJDO0lBQ2pFO0lBQ0EsSUFBSVgsU0FBUztRQUNULE9BQU8sSUFBSSxDQUFDdUQsT0FBTyxJQUFJLElBQUksQ0FBQ1AsT0FBTyxDQUFDaEQsTUFBTSxDQUFDaUUscUJBQXFCO0lBQ3BFO0lBQ0FNLGdCQUFnQmhELEdBQUcsRUFBRTtRQUNqQixPQUFPLElBQUksQ0FBQ2dDLE9BQU8sR0FBRyxPQUFPLElBQUksQ0FBQ1AsT0FBTyxDQUFDaEQsTUFBTSxDQUFDd0QsU0FBUyxDQUFDLElBQUksQ0FBQ1IsT0FBTyxDQUFDckMsS0FBSyxHQUFHWSxLQUFLQSxLQUFLLEdBQUcsRUFBRSxpQkFBaUI7SUFDcEg7SUFDQSxJQUFJeEIsY0FBYztRQUNkLElBQUksRUFBRVcsTUFBTSxFQUFFLEdBQUcsSUFBSSxDQUFDc0MsT0FBTztRQUM3QixJQUFJSixRQUFRbEMsT0FBT0EsTUFBTSxDQUFDLElBQUksQ0FBQ0MsS0FBSyxHQUFHLEVBQUU7UUFDekMsSUFBSWlDLFFBQVMsS0FBSSxDQUFDVyxPQUFPLEdBQUc3QyxPQUFPQSxNQUFNLENBQUMsSUFBSSxDQUFDNkMsT0FBTyxDQUFDNUMsS0FBSyxHQUFHLEVBQUUsR0FBR0QsT0FBT0EsTUFBTSxDQUFDOUUsTUFBTSxHQUNwRixPQUFPLElBQUkrSCxXQUFXLElBQUksQ0FBQ1gsT0FBTyxFQUFFLElBQUksQ0FBQ08sT0FBTyxFQUFFWDtRQUN0RCxPQUFPLElBQUksQ0FBQzJCLGVBQWUsQ0FBQztJQUNoQztJQUNBLElBQUlqQixjQUFjO1FBQ2QsSUFBSSxFQUFFNUMsTUFBTSxFQUFFLEdBQUcsSUFBSSxDQUFDc0MsT0FBTztRQUM3QixJQUFJd0IsY0FBYyxJQUFJLENBQUNqQixPQUFPLEdBQUcsSUFBSSxDQUFDQSxPQUFPLENBQUM1QyxLQUFLLEdBQUcsSUFBSTtRQUMxRCxJQUFJLElBQUksQ0FBQ0EsS0FBSyxJQUFJNkQsYUFDZCxPQUFPLElBQUksQ0FBQ0QsZUFBZSxDQUFDLENBQUM7UUFDakMsT0FBTyxJQUFJWixXQUFXLElBQUksQ0FBQ1gsT0FBTyxFQUFFLElBQUksQ0FBQ08sT0FBTyxFQUFFN0MsT0FBT1csU0FBUyxDQUFDbUQsYUFBYSxJQUFJLENBQUM3RCxLQUFLLEVBQUUsQ0FBQyxHQUFHLEdBQUcsRUFBRSxpQkFBaUI7SUFDMUg7SUFDQSxJQUFJM0YsT0FBTztRQUFFLE9BQU87SUFBTTtJQUMxQm1KLFNBQVM7UUFDTCxJQUFJckcsV0FBVyxFQUFFLEVBQUVDLFlBQVksRUFBRTtRQUNqQyxJQUFJLEVBQUUyQyxNQUFNLEVBQUUsR0FBRyxJQUFJLENBQUNzQyxPQUFPO1FBQzdCLElBQUlyQixTQUFTLElBQUksQ0FBQ2hCLEtBQUssR0FBRyxHQUFHaUIsT0FBT2xCLE9BQU9BLE1BQU0sQ0FBQyxJQUFJLENBQUNDLEtBQUssR0FBRyxFQUFFO1FBQ2pFLElBQUlpQixPQUFPRCxRQUFRO1lBQ2YsSUFBSW5JLE9BQU9rSCxPQUFPQSxNQUFNLENBQUMsSUFBSSxDQUFDQyxLQUFLLEdBQUcsRUFBRTtZQUN4QzdDLFNBQVNOLElBQUksQ0FBQ2tELE9BQU9nQixLQUFLLENBQUNDLFFBQVFDLE1BQU1wSTtZQUN6Q3VFLFVBQVVQLElBQUksQ0FBQztRQUNuQjtRQUNBLE9BQU8sSUFBSUssS0FBSyxJQUFJLENBQUN6RCxJQUFJLEVBQUUwRCxVQUFVQyxXQUFXLElBQUksQ0FBQ3RFLEVBQUUsR0FBRyxJQUFJLENBQUNELElBQUk7SUFDdkU7SUFDQTs7SUFFQSxHQUNBeUUsV0FBVztRQUFFLE9BQU8sSUFBSSxDQUFDK0UsT0FBTyxDQUFDdEMsTUFBTSxDQUFDUSxXQUFXLENBQUMsSUFBSSxDQUFDUCxLQUFLO0lBQUc7QUFDckU7QUFDQSxTQUFTOEQsVUFBVUMsS0FBSztJQUNwQixJQUFJLENBQUNBLE1BQU05SSxNQUFNLEVBQ2IsT0FBTztJQUNYLElBQUk0RixPQUFPLEdBQUdtRCxTQUFTRCxLQUFLLENBQUMsRUFBRTtJQUMvQixJQUFLLElBQUk1SCxJQUFJLEdBQUdBLElBQUk0SCxNQUFNOUksTUFBTSxFQUFFa0IsSUFBSztRQUNuQyxJQUFJRixPQUFPOEgsS0FBSyxDQUFDNUgsRUFBRTtRQUNuQixJQUFJRixLQUFLcEQsSUFBSSxHQUFHbUwsT0FBT25MLElBQUksSUFBSW9ELEtBQUtuRCxFQUFFLEdBQUdrTCxPQUFPbEwsRUFBRSxFQUFFO1lBQ2hEa0wsU0FBUy9IO1lBQ1Q0RSxPQUFPMUU7UUFDWDtJQUNKO0lBQ0EsSUFBSWlFLE9BQU80RCxrQkFBa0IxRixZQUFZMEYsT0FBT2hFLEtBQUssR0FBRyxJQUFJLE9BQU9nRSxPQUFPM0UsTUFBTTtJQUNoRixJQUFJNEUsV0FBV0YsTUFBTWhELEtBQUs7SUFDMUIsSUFBSVgsTUFDQTZELFFBQVEsQ0FBQ3BELEtBQUssR0FBR1Q7U0FFakI2RCxTQUFTQyxNQUFNLENBQUNyRCxNQUFNO0lBQzFCLE9BQU8sSUFBSXNELGNBQWNGLFVBQVVEO0FBQ3ZDO0FBQ0EsTUFBTUc7SUFDRnZMLFlBQVltTCxLQUFLLEVBQUU5SCxJQUFJLENBQUU7UUFDckIsSUFBSSxDQUFDOEgsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQzlILElBQUksR0FBR0E7SUFDaEI7SUFDQSxJQUFJbUUsT0FBTztRQUFFLE9BQU8wRCxVQUFVLElBQUksQ0FBQ0MsS0FBSztJQUFHO0FBQy9DO0FBQ0EsU0FBU3BGLGNBQWN0RSxJQUFJLEVBQUUyRCxHQUFHLEVBQUVDLElBQUk7SUFDbEMsSUFBSTRELFFBQVF4SCxLQUFLb0UsWUFBWSxDQUFDVCxLQUFLQyxPQUFPbUcsU0FBUztJQUNuRCxJQUFLLElBQUl4QyxPQUFPQyxpQkFBaUJ2RCxXQUFXdUQsUUFBUUEsTUFBTVEsT0FBTyxDQUFDaEQsTUFBTSxFQUFFdUMsTUFBTUEsT0FBT0EsS0FBS3ZDLE1BQU0sQ0FBRTtRQUNoRyxJQUFJdUMsS0FBSzVCLEtBQUssR0FBRyxHQUFHO1lBQ2hCLElBQUlYLFNBQVN1QyxLQUFLdkMsTUFBTTtZQUN2QitFLENBQUFBLFVBQVdBLENBQUFBLFNBQVM7Z0JBQUN2QzthQUFNLEdBQUdoRixJQUFJLENBQUN3QyxPQUFPZCxPQUFPLENBQUNQLEtBQUtDO1lBQ3hEMkQsT0FBT3ZDO1FBQ1gsT0FDSztZQUNELElBQUlnRixRQUFRakssWUFBWUksR0FBRyxDQUFDb0gsS0FBS3ZILElBQUk7WUFDckMsaUNBQWlDO1lBQ2pDLElBQUlnSyxTQUFTQSxNQUFNL0osT0FBTyxJQUFJK0osTUFBTS9KLE9BQU8sQ0FBQyxFQUFFLENBQUN6QixJQUFJLElBQUltRixPQUFPcUcsTUFBTS9KLE9BQU8sQ0FBQytKLE1BQU0vSixPQUFPLENBQUNXLE1BQU0sR0FBRyxFQUFFLENBQUNuQyxFQUFFLElBQUlrRixLQUFLO2dCQUM3RyxJQUFJc0csT0FBTyxJQUFJaEcsU0FBUytGLE1BQU1oSyxJQUFJLEVBQUVnSyxNQUFNL0osT0FBTyxDQUFDLEVBQUUsQ0FBQ3pCLElBQUksR0FBRytJLEtBQUsvSSxJQUFJLEVBQUUsQ0FBQyxHQUFHK0k7Z0JBQzFFd0MsQ0FBQUEsVUFBV0EsQ0FBQUEsU0FBUztvQkFBQ3ZDO2lCQUFNLEdBQUdoRixJQUFJLENBQUMyQixZQUFZOEYsTUFBTXRHLEtBQUtDLE1BQU07WUFDckU7UUFDSjtJQUNKO0lBQ0EsT0FBT21HLFNBQVNOLFVBQVVNLFVBQVV2QztBQUN4QztBQUNBOzs7QUFHQSxHQUNBLE1BQU1oRTtJQUNGOztJQUVBLEdBQ0EsSUFBSWhELE9BQU87UUFBRSxPQUFPLElBQUksQ0FBQ3BCLElBQUksQ0FBQ29CLElBQUk7SUFBRTtJQUNwQzs7SUFFQSxHQUNBakMsWUFBWXFELElBQUksRUFDaEI7O0lBRUEsR0FDQTJCLE9BQU8sQ0FBQyxDQUFFO1FBQ04sSUFBSSxDQUFDQSxJQUFJLEdBQUdBO1FBQ1o7O1FBRUEsR0FDQSxJQUFJLENBQUNtQyxNQUFNLEdBQUc7UUFDZCxJQUFJLENBQUN3RSxLQUFLLEdBQUcsRUFBRTtRQUNmOztRQUVBLEdBQ0EsSUFBSSxDQUFDdkUsS0FBSyxHQUFHO1FBQ2IsSUFBSSxDQUFDd0UsVUFBVSxHQUFHO1FBQ2xCLElBQUl2SSxnQkFBZ0JxQyxVQUFVO1lBQzFCLElBQUksQ0FBQ21HLFNBQVMsQ0FBQ3hJO1FBQ25CLE9BQ0s7WUFDRCxJQUFJLENBQUNvQyxLQUFLLEdBQUdwQyxLQUFLb0csT0FBTyxDQUFDaEQsTUFBTTtZQUNoQyxJQUFJLENBQUNVLE1BQU0sR0FBRzlELEtBQUtvRyxPQUFPO1lBQzFCLElBQUssSUFBSXFDLElBQUl6SSxLQUFLMkcsT0FBTyxFQUFFOEIsR0FBR0EsSUFBSUEsRUFBRTlCLE9BQU8sQ0FDdkMsSUFBSSxDQUFDMkIsS0FBSyxDQUFDSSxPQUFPLENBQUNELEVBQUUxRSxLQUFLO1lBQzlCLElBQUksQ0FBQ3dFLFVBQVUsR0FBR3ZJO1lBQ2xCLElBQUksQ0FBQzJJLFFBQVEsQ0FBQzNJLEtBQUsrRCxLQUFLO1FBQzVCO0lBQ0o7SUFDQXlFLFVBQVV4SSxJQUFJLEVBQUU7UUFDWixJQUFJLENBQUNBLE1BQ0QsT0FBTztRQUNYLElBQUksQ0FBQ29DLEtBQUssR0FBR3BDO1FBQ2IsSUFBSSxDQUFDeEMsSUFBSSxHQUFHd0MsS0FBS3hDLElBQUk7UUFDckIsSUFBSSxDQUFDWixJQUFJLEdBQUdvRCxLQUFLcEQsSUFBSTtRQUNyQixJQUFJLENBQUNDLEVBQUUsR0FBR21ELEtBQUtuRCxFQUFFO1FBQ2pCLE9BQU87SUFDWDtJQUNBOEwsU0FBUzVFLEtBQUssRUFBRXZHLElBQUksRUFBRTtRQUNsQixJQUFJLENBQUN1RyxLQUFLLEdBQUdBO1FBQ2IsSUFBSSxFQUFFQyxLQUFLLEVBQUVGLE1BQU0sRUFBRSxHQUFHLElBQUksQ0FBQ0EsTUFBTTtRQUNuQyxJQUFJLENBQUN0RyxJQUFJLEdBQUdBLFFBQVFzRyxPQUFPM0IsR0FBRyxDQUFDN0IsS0FBSyxDQUFDd0QsT0FBT0EsTUFBTSxDQUFDQyxNQUFNLENBQUM7UUFDMUQsSUFBSSxDQUFDbkgsSUFBSSxHQUFHb0gsUUFBUUYsT0FBT0EsTUFBTSxDQUFDQyxRQUFRLEVBQUU7UUFDNUMsSUFBSSxDQUFDbEgsRUFBRSxHQUFHbUgsUUFBUUYsT0FBT0EsTUFBTSxDQUFDQyxRQUFRLEVBQUU7UUFDMUMsT0FBTztJQUNYO0lBQ0E7O0lBRUEsR0FDQTZFLE1BQU01SSxJQUFJLEVBQUU7UUFDUixJQUFJLENBQUNBLE1BQ0QsT0FBTztRQUNYLElBQUlBLGdCQUFnQnFDLFVBQVU7WUFDMUIsSUFBSSxDQUFDeUIsTUFBTSxHQUFHO1lBQ2QsT0FBTyxJQUFJLENBQUMwRSxTQUFTLENBQUN4STtRQUMxQjtRQUNBLElBQUksQ0FBQzhELE1BQU0sR0FBRzlELEtBQUtvRyxPQUFPO1FBQzFCLE9BQU8sSUFBSSxDQUFDdUMsUUFBUSxDQUFDM0ksS0FBSytELEtBQUssRUFBRS9ELEtBQUt4QyxJQUFJO0lBQzlDO0lBQ0E7O0lBRUEsR0FDQTZELFdBQVc7UUFDUCxPQUFPLElBQUksQ0FBQ3lDLE1BQU0sR0FBRyxJQUFJLENBQUNBLE1BQU0sQ0FBQ0EsTUFBTSxDQUFDUSxXQUFXLENBQUMsSUFBSSxDQUFDUCxLQUFLLElBQUksSUFBSSxDQUFDM0IsS0FBSyxDQUFDZixRQUFRO0lBQ3pGO0lBQ0E7O0lBRUEsR0FDQXdILFdBQVdsRSxHQUFHLEVBQUU1QyxHQUFHLEVBQUVDLElBQUksRUFBRTtRQUN2QixJQUFJLENBQUMsSUFBSSxDQUFDOEIsTUFBTSxFQUNaLE9BQU8sSUFBSSxDQUFDOEUsS0FBSyxDQUFDLElBQUksQ0FBQ3hHLEtBQUssQ0FBQ3dFLFNBQVMsQ0FBQ2pDLE1BQU0sSUFBSSxJQUFJLENBQUN2QyxLQUFLLENBQUNBLEtBQUssQ0FBQ2xCLFFBQVEsQ0FBQ2xDLE1BQU0sR0FBRyxJQUFJLEdBQUcyRixLQUFLNUMsS0FBS0MsTUFBTSxJQUFJLENBQUNMLElBQUk7UUFDeEgsSUFBSSxFQUFFbUMsTUFBTSxFQUFFLEdBQUcsSUFBSSxDQUFDQSxNQUFNO1FBQzVCLElBQUlDLFFBQVFELE9BQU9XLFNBQVMsQ0FBQyxJQUFJLENBQUNWLEtBQUssR0FBRyxHQUFHRCxPQUFPQSxNQUFNLENBQUMsSUFBSSxDQUFDQyxLQUFLLEdBQUcsRUFBRSxFQUFFWSxLQUFLNUMsTUFBTSxJQUFJLENBQUMrQixNQUFNLENBQUNFLEtBQUssRUFBRWhDO1FBQzFHLElBQUkrQixRQUFRLEdBQ1IsT0FBTztRQUNYLElBQUksQ0FBQ3VFLEtBQUssQ0FBQzFILElBQUksQ0FBQyxJQUFJLENBQUNtRCxLQUFLO1FBQzFCLE9BQU8sSUFBSSxDQUFDNEUsUUFBUSxDQUFDNUU7SUFDekI7SUFDQTs7O0lBR0EsR0FDQWIsYUFBYTtRQUFFLE9BQU8sSUFBSSxDQUFDMkYsVUFBVSxDQUFDLEdBQUcsR0FBRyxFQUFFLGlCQUFpQjtJQUFLO0lBQ3BFOztJQUVBLEdBQ0FwQyxZQUFZO1FBQUUsT0FBTyxJQUFJLENBQUNvQyxVQUFVLENBQUMsQ0FBQyxHQUFHLEdBQUcsRUFBRSxpQkFBaUI7SUFBSztJQUNwRTs7SUFFQSxHQUNBMUIsV0FBV3BGLEdBQUcsRUFBRTtRQUFFLE9BQU8sSUFBSSxDQUFDOEcsVUFBVSxDQUFDLEdBQUc5RyxLQUFLLEVBQUUsY0FBYztJQUFLO0lBQ3RFOztJQUVBLEdBQ0F3RSxZQUFZeEUsR0FBRyxFQUFFO1FBQUUsT0FBTyxJQUFJLENBQUM4RyxVQUFVLENBQUMsQ0FBQyxHQUFHOUcsS0FBSyxDQUFDLEVBQUUsZUFBZTtJQUFLO0lBQzFFOzs7Ozs7SUFNQSxHQUNBYSxNQUFNYixHQUFHLEVBQUVDLElBQUksRUFBRUwsT0FBTyxJQUFJLENBQUNBLElBQUksRUFBRTtRQUMvQixJQUFJLENBQUMsSUFBSSxDQUFDbUMsTUFBTSxFQUNaLE9BQU8sSUFBSSxDQUFDOEUsS0FBSyxDQUFDLElBQUksQ0FBQ3hHLEtBQUssQ0FBQ1EsS0FBSyxDQUFDYixLQUFLQyxNQUFNTDtRQUNsRCxPQUFPQSxPQUFPWCxTQUFTOEYsY0FBYyxHQUFHLFFBQVEsSUFBSSxDQUFDK0IsVUFBVSxDQUFDLEdBQUc5RyxLQUFLQztJQUM1RTtJQUNBOztJQUVBLEdBQ0FvQixTQUFTO1FBQ0wsSUFBSSxDQUFDLElBQUksQ0FBQ1UsTUFBTSxFQUNaLE9BQU8sSUFBSSxDQUFDMEUsU0FBUyxDQUFDLElBQUssQ0FBQzdHLElBQUksR0FBR1gsU0FBUytCLGdCQUFnQixHQUFJLElBQUksQ0FBQ1gsS0FBSyxDQUFDdUUsT0FBTyxHQUFHLElBQUksQ0FBQ3ZFLEtBQUssQ0FBQ2dCLE1BQU07UUFDMUcsSUFBSSxJQUFJLENBQUNrRixLQUFLLENBQUN0SixNQUFNLEVBQ2pCLE9BQU8sSUFBSSxDQUFDMkosUUFBUSxDQUFDLElBQUksQ0FBQ0wsS0FBSyxDQUFDUSxHQUFHO1FBQ3ZDLElBQUkxRixTQUFTLElBQUssQ0FBQ3pCLElBQUksR0FBR1gsU0FBUytCLGdCQUFnQixHQUFJLElBQUksQ0FBQ2UsTUFBTSxDQUFDVixNQUFNLEdBQUcsSUFBSSxDQUFDVSxNQUFNLENBQUNWLE1BQU0sQ0FBQ2lFLHFCQUFxQjtRQUNwSCxJQUFJLENBQUN2RCxNQUFNLEdBQUc7UUFDZCxPQUFPLElBQUksQ0FBQzBFLFNBQVMsQ0FBQ3BGO0lBQzFCO0lBQ0E7O0lBRUEsR0FDQTJGLFFBQVFwRSxHQUFHLEVBQUU7UUFDVCxJQUFJLENBQUMsSUFBSSxDQUFDYixNQUFNLEVBQ1osT0FBTyxDQUFDLElBQUksQ0FBQzFCLEtBQUssQ0FBQ3VFLE9BQU8sR0FBRyxRQUN2QixJQUFJLENBQUNpQyxLQUFLLENBQUMsSUFBSSxDQUFDeEcsS0FBSyxDQUFDMkIsS0FBSyxHQUFHLElBQUksT0FDOUIsSUFBSSxDQUFDM0IsS0FBSyxDQUFDdUUsT0FBTyxDQUFDQyxTQUFTLENBQUMsSUFBSSxDQUFDeEUsS0FBSyxDQUFDMkIsS0FBSyxHQUFHWSxLQUFLQSxLQUFLLEdBQUcsRUFBRSxpQkFBaUIsS0FBSSxJQUFJLENBQUNoRCxJQUFJO1FBQzNHLElBQUksRUFBRW1DLE1BQU0sRUFBRSxHQUFHLElBQUksQ0FBQ0EsTUFBTSxFQUFFa0YsSUFBSSxJQUFJLENBQUNWLEtBQUssQ0FBQ3RKLE1BQU0sR0FBRztRQUN0RCxJQUFJMkYsTUFBTSxHQUFHO1lBQ1QsSUFBSWlELGNBQWNvQixJQUFJLElBQUksSUFBSSxJQUFJLENBQUNWLEtBQUssQ0FBQ1UsRUFBRSxHQUFHO1lBQzlDLElBQUksSUFBSSxDQUFDakYsS0FBSyxJQUFJNkQsYUFDZCxPQUFPLElBQUksQ0FBQ2UsUUFBUSxDQUFDN0UsT0FBT1csU0FBUyxDQUFDbUQsYUFBYSxJQUFJLENBQUM3RCxLQUFLLEVBQUUsQ0FBQyxHQUFHLEdBQUcsRUFBRSxpQkFBaUI7UUFDakcsT0FDSztZQUNELElBQUlpQyxRQUFRbEMsT0FBT0EsTUFBTSxDQUFDLElBQUksQ0FBQ0MsS0FBSyxHQUFHLEVBQUU7WUFDekMsSUFBSWlDLFFBQVNnRCxDQUFBQSxJQUFJLElBQUlsRixPQUFPQSxNQUFNLENBQUM5RSxNQUFNLEdBQUc4RSxPQUFPQSxNQUFNLENBQUMsSUFBSSxDQUFDd0UsS0FBSyxDQUFDVSxFQUFFLEdBQUcsRUFBRSxHQUN4RSxPQUFPLElBQUksQ0FBQ0wsUUFBUSxDQUFDM0M7UUFDN0I7UUFDQSxPQUFPZ0QsSUFBSSxJQUFJLElBQUksQ0FBQ0osS0FBSyxDQUFDLElBQUksQ0FBQzlFLE1BQU0sQ0FBQ1YsTUFBTSxDQUFDd0QsU0FBUyxDQUFDLElBQUksQ0FBQzlDLE1BQU0sQ0FBQ0MsS0FBSyxHQUFHWSxLQUFLQSxLQUFLLEdBQUcsRUFBRSxpQkFBaUIsS0FBSSxJQUFJLENBQUNoRCxJQUFJLEtBQUs7SUFDakk7SUFDQTs7SUFFQSxHQUNBd0IsY0FBYztRQUFFLE9BQU8sSUFBSSxDQUFDNEYsT0FBTyxDQUFDO0lBQUk7SUFDeEM7O0lBRUEsR0FDQXJDLGNBQWM7UUFBRSxPQUFPLElBQUksQ0FBQ3FDLE9BQU8sQ0FBQyxDQUFDO0lBQUk7SUFDekNFLFdBQVd0RSxHQUFHLEVBQUU7UUFDWixJQUFJWixPQUFPWCxRQUFRLEVBQUVVLE1BQU0sRUFBRSxHQUFHLElBQUk7UUFDcEMsSUFBSUEsUUFBUTtZQUNSLElBQUlhLE1BQU0sR0FBRztnQkFDVCxJQUFJLElBQUksQ0FBQ1osS0FBSyxHQUFHRCxPQUFPQSxNQUFNLENBQUNBLE1BQU0sQ0FBQzlFLE1BQU0sRUFDeEMsT0FBTztZQUNmLE9BQ0s7Z0JBQ0QsSUFBSyxJQUFJa0IsSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQzZELEtBQUssRUFBRTdELElBQzVCLElBQUk0RCxPQUFPQSxNQUFNLENBQUNBLE1BQU0sQ0FBQzVELElBQUksRUFBRSxHQUFHLElBQUksQ0FBQzZELEtBQUssRUFDeEMsT0FBTztZQUNuQjtZQUNDLEdBQUVBLEtBQUssRUFBRVgsTUFBTSxFQUFFLEdBQUdVLE1BQUs7UUFDOUIsT0FDSztZQUNBLEdBQUVDLEtBQUssRUFBRTRDLFNBQVN2RCxNQUFNLEVBQUUsR0FBRyxJQUFJLENBQUNoQixLQUFLO1FBQzVDO1FBQ0EsTUFBT2dCLFFBQVEsRUFBRVcsS0FBSyxFQUFFNEMsU0FBU3ZELE1BQU0sRUFBRSxHQUFHQSxPQUFRO1lBQ2hELElBQUlXLFFBQVEsQ0FBQyxHQUNULElBQUssSUFBSTdELElBQUk2RCxRQUFRWSxLQUFLa0MsSUFBSWxDLE1BQU0sSUFBSSxDQUFDLElBQUl2QixPQUFPaEIsS0FBSyxDQUFDbEIsUUFBUSxDQUFDbEMsTUFBTSxFQUFFa0IsS0FBSzJHLEdBQUczRyxLQUFLeUUsSUFBSztnQkFDekYsSUFBSStDLFFBQVF0RSxPQUFPaEIsS0FBSyxDQUFDbEIsUUFBUSxDQUFDaEIsRUFBRTtnQkFDcEMsSUFBSSxJQUFLLENBQUN5QixJQUFJLEdBQUdYLFNBQVMrQixnQkFBZ0IsSUFDdEMyRSxpQkFBaUJyRCxjQUNqQixDQUFDcUQsTUFBTWxLLElBQUksQ0FBQ21DLFdBQVcsSUFDdkJzSCxTQUFTUyxRQUNULE9BQU87WUFDZjtRQUNSO1FBQ0EsT0FBTztJQUNYO0lBQ0F3QixLQUFLdkUsR0FBRyxFQUFFL0IsS0FBSyxFQUFFO1FBQ2IsSUFBSUEsU0FBUyxJQUFJLENBQUNpRyxVQUFVLENBQUNsRSxLQUFLLEdBQUcsRUFBRSxpQkFBaUIsTUFDcEQsT0FBTztRQUNYLE9BQVM7WUFDTCxJQUFJLElBQUksQ0FBQ29FLE9BQU8sQ0FBQ3BFLE1BQ2IsT0FBTztZQUNYLElBQUksSUFBSSxDQUFDc0UsVUFBVSxDQUFDdEUsUUFBUSxDQUFDLElBQUksQ0FBQ3ZCLE1BQU0sSUFDcEMsT0FBTztRQUNmO0lBQ0o7SUFDQTs7Ozs7O0lBTUEsR0FDQWUsS0FBS3ZCLFFBQVEsSUFBSSxFQUFFO1FBQUUsT0FBTyxJQUFJLENBQUNzRyxJQUFJLENBQUMsR0FBR3RHO0lBQVE7SUFDakQ7Ozs7O0lBS0EsR0FDQXVHLEtBQUt2RyxRQUFRLElBQUksRUFBRTtRQUFFLE9BQU8sSUFBSSxDQUFDc0csSUFBSSxDQUFDLENBQUMsR0FBR3RHO0lBQVE7SUFDbEQ7Ozs7SUFJQSxHQUNBVixPQUFPSCxHQUFHLEVBQUVDLE9BQU8sQ0FBQyxFQUFFO1FBQ2xCLGtFQUFrRTtRQUNsRSxNQUFPLElBQUksQ0FBQ3BGLElBQUksSUFBSSxJQUFJLENBQUNDLEVBQUUsSUFDdEJtRixDQUFBQSxPQUFPLElBQUksSUFBSSxDQUFDcEYsSUFBSSxJQUFJbUYsTUFBTSxJQUFJLENBQUNuRixJQUFJLEdBQUdtRixHQUFFLEtBQzVDQyxDQUFBQSxPQUFPLENBQUMsSUFBSSxJQUFJLENBQUNuRixFQUFFLElBQUlrRixNQUFNLElBQUksQ0FBQ2xGLEVBQUUsR0FBR2tGLEdBQUUsRUFDMUMsSUFBSSxDQUFDLElBQUksQ0FBQ3FCLE1BQU0sSUFDWjtRQUNSLHFEQUFxRDtRQUNyRCxNQUFPLElBQUksQ0FBQ3lGLFVBQVUsQ0FBQyxHQUFHOUcsS0FBS0MsTUFBTyxDQUFFO1FBQ3hDLE9BQU8sSUFBSTtJQUNmO0lBQ0E7OztJQUdBLEdBQ0EsSUFBSWhDLE9BQU87UUFDUCxJQUFJLENBQUMsSUFBSSxDQUFDOEQsTUFBTSxFQUNaLE9BQU8sSUFBSSxDQUFDMUIsS0FBSztRQUNyQixJQUFJZ0gsUUFBUSxJQUFJLENBQUNiLFVBQVUsRUFBRTlLLFNBQVMsTUFBTTRMLFFBQVE7UUFDcEQsSUFBSUQsU0FBU0EsTUFBTWhELE9BQU8sSUFBSSxJQUFJLENBQUN0QyxNQUFNLEVBQUU7WUFDdkM2QixNQUFNLElBQUssSUFBSTVCLFFBQVEsSUFBSSxDQUFDQSxLQUFLLEVBQUVpRixJQUFJLElBQUksQ0FBQ1YsS0FBSyxDQUFDdEosTUFBTSxFQUFFZ0ssS0FBSyxHQUFJO2dCQUMvRCxJQUFLLElBQUloRyxJQUFJb0csT0FBT3BHLEdBQUdBLElBQUlBLEVBQUUyRCxPQUFPLENBQ2hDLElBQUkzRCxFQUFFZSxLQUFLLElBQUlBLE9BQU87b0JBQ2xCLElBQUlBLFNBQVMsSUFBSSxDQUFDQSxLQUFLLEVBQ25CLE9BQU9mO29CQUNYdkYsU0FBU3VGO29CQUNUcUcsUUFBUUwsSUFBSTtvQkFDWixNQUFNckQ7Z0JBQ1Y7Z0JBQ0o1QixRQUFRLElBQUksQ0FBQ3VFLEtBQUssQ0FBQyxFQUFFVSxFQUFFO1lBQzNCO1FBQ0o7UUFDQSxJQUFLLElBQUk5SSxJQUFJbUosT0FBT25KLElBQUksSUFBSSxDQUFDb0ksS0FBSyxDQUFDdEosTUFBTSxFQUFFa0IsSUFDdkN6QyxTQUFTLElBQUlzSixXQUFXLElBQUksQ0FBQ2pELE1BQU0sRUFBRXJHLFFBQVEsSUFBSSxDQUFDNkssS0FBSyxDQUFDcEksRUFBRTtRQUM5RCxPQUFPLElBQUksQ0FBQ3FJLFVBQVUsR0FBRyxJQUFJeEIsV0FBVyxJQUFJLENBQUNqRCxNQUFNLEVBQUVyRyxRQUFRLElBQUksQ0FBQ3NHLEtBQUs7SUFDM0U7SUFDQTs7OztJQUlBLEdBQ0EsSUFBSTNGLE9BQU87UUFDUCxPQUFPLElBQUksQ0FBQzBGLE1BQU0sR0FBRyxPQUFPLElBQUksQ0FBQzFCLEtBQUssQ0FBQ0EsS0FBSztJQUNoRDtJQUNBOzs7OztJQUtBLEdBQ0FPLFFBQVFDLEtBQUssRUFBRUMsS0FBSyxFQUFFO1FBQ2xCLElBQUssSUFBSXdHLFFBQVEsSUFBSztZQUNsQixJQUFJQyxZQUFZO1lBQ2hCLElBQUksSUFBSSxDQUFDOUwsSUFBSSxDQUFDbUMsV0FBVyxJQUFJaUQsTUFBTSxJQUFJLE1BQU0sT0FBTztnQkFDaEQsSUFBSSxJQUFJLENBQUNNLFVBQVUsSUFBSTtvQkFDbkJtRztvQkFDQTtnQkFDSjtnQkFDQSxJQUFJLENBQUMsSUFBSSxDQUFDN0wsSUFBSSxDQUFDbUMsV0FBVyxFQUN0QjJKLFlBQVk7WUFDcEI7WUFDQSxPQUFTO2dCQUNMLElBQUlBLGFBQWF6RyxPQUNiQSxNQUFNLElBQUk7Z0JBQ2R5RyxZQUFZLElBQUksQ0FBQzlMLElBQUksQ0FBQ21DLFdBQVc7Z0JBQ2pDLElBQUksSUFBSSxDQUFDd0QsV0FBVyxJQUNoQjtnQkFDSixJQUFJLENBQUNrRyxPQUNEO2dCQUNKLElBQUksQ0FBQ2pHLE1BQU07Z0JBQ1hpRztnQkFDQUMsWUFBWTtZQUNoQjtRQUNKO0lBQ0o7SUFDQTs7OztJQUlBLEdBQ0FuRCxhQUFhQyxPQUFPLEVBQUU7UUFDbEIsSUFBSSxDQUFDLElBQUksQ0FBQ3RDLE1BQU0sRUFDWixPQUFPdUMsaUJBQWlCLElBQUksQ0FBQ3JHLElBQUksRUFBRW9HO1FBQ3ZDLElBQUksRUFBRXRDLE1BQU0sRUFBRSxHQUFHLElBQUksQ0FBQ0EsTUFBTSxFQUFFLEVBQUV4RCxLQUFLLEVBQUUsR0FBR3dELE9BQU8zQixHQUFHO1FBQ3BELElBQUssSUFBSWpDLElBQUlrRyxRQUFRcEgsTUFBTSxHQUFHLEdBQUdnSyxJQUFJLElBQUksQ0FBQ1YsS0FBSyxDQUFDdEosTUFBTSxHQUFHLEdBQUdrQixLQUFLLEdBQUc4SSxJQUFLO1lBQ3JFLElBQUlBLElBQUksR0FDSixPQUFPM0MsaUJBQWlCLElBQUksQ0FBQ3JHLElBQUksRUFBRW9HLFNBQVNsRztZQUNoRCxJQUFJMUMsT0FBTzhDLEtBQUssQ0FBQ3dELE9BQU9BLE1BQU0sQ0FBQyxJQUFJLENBQUN3RSxLQUFLLENBQUNVLEVBQUUsQ0FBQyxDQUFDO1lBQzlDLElBQUksQ0FBQ3hMLEtBQUttQyxXQUFXLEVBQUU7Z0JBQ25CLElBQUl5RyxPQUFPLENBQUNsRyxFQUFFLElBQUlrRyxPQUFPLENBQUNsRyxFQUFFLElBQUkxQyxLQUFLb0IsSUFBSSxFQUNyQyxPQUFPO2dCQUNYc0I7WUFDSjtRQUNKO1FBQ0EsT0FBTztJQUNYO0FBQ0o7QUFDQSxTQUFTK0csU0FBUzdJLElBQUk7SUFDbEIsT0FBT0EsS0FBSzhDLFFBQVEsQ0FBQ3FJLElBQUksQ0FBQ2pJLENBQUFBLEtBQU1BLGNBQWMrQyxjQUFjLENBQUMvQyxHQUFHOUQsSUFBSSxDQUFDbUMsV0FBVyxJQUFJc0gsU0FBUzNGO0FBQ2pHO0FBQ0EsU0FBU3FDLFVBQVVELElBQUk7SUFDbkIsSUFBSStCO0lBQ0osSUFBSSxFQUFFM0IsTUFBTSxFQUFFMEYsT0FBTyxFQUFFQyxrQkFBa0JqTixtQkFBbUIsRUFBRWtOLFNBQVMsRUFBRSxFQUFFQyxnQkFBZ0JILFFBQVFsSixLQUFLLENBQUN0QixNQUFNLEVBQUUsR0FBRzBFO0lBQ3BILElBQUloQyxTQUFTckMsTUFBTUMsT0FBTyxDQUFDd0UsVUFBVSxJQUFJRCxpQkFBaUJDLFFBQVFBLE9BQU85RSxNQUFNLElBQUk4RTtJQUNuRixJQUFJeEQsUUFBUWtKLFFBQVFsSixLQUFLO0lBQ3pCLElBQUl0QyxjQUFjLEdBQUdDLFlBQVk7SUFDakMsU0FBUzJMLFNBQVNoQyxXQUFXLEVBQUVpQyxNQUFNLEVBQUUzSSxRQUFRLEVBQUVDLFNBQVMsRUFBRTJJLFFBQVEsRUFBRVQsS0FBSztRQUN2RSxJQUFJLEVBQUVyTSxFQUFFLEVBQUVnSCxLQUFLLEVBQUVDLEdBQUcsRUFBRUMsSUFBSSxFQUFFLEdBQUd4QztRQUMvQixJQUFJcUksbUJBQW1COUw7UUFDdkIsTUFBT2lHLE9BQU8sRUFBRztZQUNieEMsT0FBT3lDLElBQUk7WUFDWCxJQUFJRCxRQUFRLENBQUMsRUFBRSx1QkFBdUIsS0FBSTtnQkFDdEMsSUFBSWxFLE9BQU8wSixNQUFNLENBQUMxTSxHQUFHO2dCQUNyQmtFLFNBQVNOLElBQUksQ0FBQ1o7Z0JBQ2RtQixVQUFVUCxJQUFJLENBQUNvRCxRQUFRNEQ7Z0JBQ3ZCO1lBQ0osT0FDSyxJQUFJMUQsUUFBUSxDQUFDLEVBQUUsK0JBQStCLEtBQUk7Z0JBQ25EbEcsY0FBY2hCO2dCQUNkO1lBQ0osT0FDSyxJQUFJa0gsUUFBUSxDQUFDLEVBQUUsMkJBQTJCLEtBQUk7Z0JBQy9DakcsWUFBWWpCO2dCQUNaO1lBQ0osT0FDSztnQkFDRCxNQUFNLElBQUlNLFdBQVcsQ0FBQywwQkFBMEIsRUFBRTRHLEtBQUssQ0FBQztZQUM1RDtRQUNKO1FBQ0EsSUFBSTFHLE9BQU84QyxLQUFLLENBQUN0RCxHQUFHLEVBQUVnRCxNQUFNOEQ7UUFDNUIsSUFBSWtHLFdBQVdoRyxRQUFRNEQ7UUFDdkIsSUFBSTNELE1BQU1ELFNBQVN5RixtQkFBb0IzRixDQUFBQSxTQUFTbUcsZUFBZXZJLE9BQU9LLEdBQUcsR0FBRzhILFFBQVFDLFNBQVEsR0FBSTtZQUM1Rix3REFBd0Q7WUFDeEQsSUFBSXBHLE9BQU8sSUFBSXlCLFlBQVlyQixPQUFPSSxJQUFJLEdBQUdKLE9BQU9vRyxJQUFJO1lBQ3BELElBQUlDLFNBQVN6SSxPQUFPSyxHQUFHLEdBQUcrQixPQUFPSSxJQUFJLEVBQUVILFFBQVFMLEtBQUsxRSxNQUFNO1lBQzFELE1BQU8wQyxPQUFPSyxHQUFHLEdBQUdvSSxPQUNoQnBHLFFBQVFxRyxhQUFhdEcsT0FBT0UsS0FBSyxFQUFFTixNQUFNSztZQUM3Qy9ELE9BQU8sSUFBSXFFLFdBQVdYLE1BQU1PLE1BQU1ILE9BQU9FLEtBQUssRUFBRXdGO1lBQ2hEUSxXQUFXbEcsT0FBT0UsS0FBSyxHQUFHNEQ7UUFDOUIsT0FDSztZQUNELElBQUl1QyxTQUFTekksT0FBT0ssR0FBRyxHQUFHbUM7WUFDMUJ4QyxPQUFPeUMsSUFBSTtZQUNYLElBQUlrRyxnQkFBZ0IsRUFBRSxFQUFFQyxpQkFBaUIsRUFBRTtZQUMzQyxJQUFJQyxnQkFBZ0J2TixNQUFNMk0sZ0JBQWdCM00sS0FBSyxDQUFDO1lBQ2hELElBQUl3TixZQUFZLEdBQUdDLFVBQVV4RztZQUM3QixNQUFPdkMsT0FBT0ssR0FBRyxHQUFHb0ksT0FBUTtnQkFDeEIsSUFBSUksaUJBQWlCLEtBQUs3SSxPQUFPMUUsRUFBRSxJQUFJdU4saUJBQWlCN0ksT0FBT3dDLElBQUksSUFBSSxHQUFHO29CQUN0RSxJQUFJeEMsT0FBT3VDLEdBQUcsSUFBSXdHLFVBQVVoQixpQkFBaUI7d0JBQ3pDaUIsZUFBZUwsZUFBZUMsZ0JBQWdCdEcsT0FBT3dHLFdBQVc5SSxPQUFPdUMsR0FBRyxFQUFFd0csU0FBU0YsZUFBZVI7d0JBQ3BHUyxZQUFZSCxjQUFjckwsTUFBTTt3QkFDaEN5TCxVQUFVL0ksT0FBT3VDLEdBQUc7b0JBQ3hCO29CQUNBdkMsT0FBT3lDLElBQUk7Z0JBQ2YsT0FDSyxJQUFJa0YsUUFBUSxLQUFLLGdCQUFnQixLQUFJO29CQUN0Q3NCLGFBQWEzRyxPQUFPbUcsUUFBUUUsZUFBZUM7Z0JBQy9DLE9BQ0s7b0JBQ0RWLFNBQVM1RixPQUFPbUcsUUFBUUUsZUFBZUMsZ0JBQWdCQyxlQUFlbEIsUUFBUTtnQkFDbEY7WUFDSjtZQUNBLElBQUlrQixpQkFBaUIsS0FBS0MsWUFBWSxLQUFLQSxZQUFZSCxjQUFjckwsTUFBTSxFQUN2RTBMLGVBQWVMLGVBQWVDLGdCQUFnQnRHLE9BQU93RyxXQUFXeEcsT0FBT3lHLFNBQVNGLGVBQWVSO1lBQ25HTSxjQUFjTyxPQUFPO1lBQ3JCTixlQUFlTSxPQUFPO1lBQ3RCLElBQUlMLGdCQUFnQixDQUFDLEtBQUtDLFlBQVksR0FBRztnQkFDckMsSUFBSUssT0FBT0MsYUFBYXROO2dCQUN4QndDLE9BQU91RCxhQUFhL0YsTUFBTTZNLGVBQWVDLGdCQUFnQixHQUFHRCxjQUFjckwsTUFBTSxFQUFFLEdBQUdpRixNQUFNRCxPQUFPNkcsTUFBTUE7WUFDNUcsT0FDSztnQkFDRDdLLE9BQU93RCxTQUFTaEcsTUFBTTZNLGVBQWVDLGdCQUFnQnJHLE1BQU1ELE9BQU8rRixtQkFBbUI5RjtZQUN6RjtRQUNKO1FBQ0EvQyxTQUFTTixJQUFJLENBQUNaO1FBQ2RtQixVQUFVUCxJQUFJLENBQUNvSjtJQUNuQjtJQUNBLFNBQVNXLGFBQWEvQyxXQUFXLEVBQUVpQyxNQUFNLEVBQUUzSSxRQUFRLEVBQUVDLFNBQVM7UUFDMUQsSUFBSTRKLFFBQVEsRUFBRSxFQUFFLHlFQUF5RTtRQUN6RixJQUFJQyxZQUFZLEdBQUdDLFNBQVMsQ0FBQztRQUM3QixNQUFPdkosT0FBT0ssR0FBRyxHQUFHOEgsT0FBUTtZQUN4QixJQUFJLEVBQUU3TSxFQUFFLEVBQUVnSCxLQUFLLEVBQUVDLEdBQUcsRUFBRUMsSUFBSSxFQUFFLEdBQUd4QztZQUMvQixJQUFJd0MsT0FBTyxHQUFHO2dCQUNWeEMsT0FBT3lDLElBQUk7WUFDZixPQUNLLElBQUk4RyxTQUFTLENBQUMsS0FBS2pILFFBQVFpSCxRQUFRO2dCQUNwQztZQUNKLE9BQ0s7Z0JBQ0QsSUFBSUEsU0FBUyxHQUNUQSxTQUFTaEgsTUFBTXdGO2dCQUNuQnNCLE1BQU1uSyxJQUFJLENBQUM1RCxJQUFJZ0gsT0FBT0M7Z0JBQ3RCK0c7Z0JBQ0F0SixPQUFPeUMsSUFBSTtZQUNmO1FBQ0o7UUFDQSxJQUFJNkcsV0FBVztZQUNYLElBQUlsSCxTQUFTLElBQUlxQixZQUFZNkYsWUFBWTtZQUN6QyxJQUFJaEgsUUFBUStHLEtBQUssQ0FBQ0EsTUFBTS9MLE1BQU0sR0FBRyxFQUFFO1lBQ25DLElBQUssSUFBSWtCLElBQUk2SyxNQUFNL0wsTUFBTSxHQUFHLEdBQUdxRyxJQUFJLEdBQUduRixLQUFLLEdBQUdBLEtBQUssRUFBRztnQkFDbEQ0RCxNQUFNLENBQUN1QixJQUFJLEdBQUcwRixLQUFLLENBQUM3SyxFQUFFO2dCQUN0QjRELE1BQU0sQ0FBQ3VCLElBQUksR0FBRzBGLEtBQUssQ0FBQzdLLElBQUksRUFBRSxHQUFHOEQ7Z0JBQzdCRixNQUFNLENBQUN1QixJQUFJLEdBQUcwRixLQUFLLENBQUM3SyxJQUFJLEVBQUUsR0FBRzhEO2dCQUM3QkYsTUFBTSxDQUFDdUIsSUFBSSxHQUFHQTtZQUNsQjtZQUNBbkUsU0FBU04sSUFBSSxDQUFDLElBQUl5RCxXQUFXUCxRQUFRaUgsS0FBSyxDQUFDLEVBQUUsR0FBRy9HLE9BQU93RjtZQUN2RHJJLFVBQVVQLElBQUksQ0FBQ29ELFFBQVE0RDtRQUMzQjtJQUNKO0lBQ0EsU0FBU2tELGFBQWF0TixJQUFJO1FBQ3RCLE9BQU8sQ0FBQzBELFVBQVVDLFdBQVduQztZQUN6QixJQUFJZixZQUFZLEdBQUdpTixRQUFRaEssU0FBU2xDLE1BQU0sR0FBRyxHQUFHd0gsTUFBTTJFO1lBQ3RELElBQUlELFNBQVMsS0FBSyxDQUFDMUUsT0FBT3RGLFFBQVEsQ0FBQ2dLLE1BQU0sYUFBYWpLLE1BQU07Z0JBQ3hELElBQUksQ0FBQ2lLLFNBQVMxRSxLQUFLaEosSUFBSSxJQUFJQSxRQUFRZ0osS0FBS3hILE1BQU0sSUFBSUEsUUFDOUMsT0FBT3dIO2dCQUNYLElBQUkyRSxnQkFBZ0IzRSxLQUFLakgsSUFBSSxDQUFDekMsU0FBU21CLFNBQVMsR0FDNUNBLFlBQVlrRCxTQUFTLENBQUMrSixNQUFNLEdBQUcxRSxLQUFLeEgsTUFBTSxHQUFHbU07WUFDckQ7WUFDQSxPQUFPM0gsU0FBU2hHLE1BQU0wRCxVQUFVQyxXQUFXbkMsUUFBUWY7UUFDdkQ7SUFDSjtJQUNBLFNBQVN5TSxlQUFleEosUUFBUSxFQUFFQyxTQUFTLEVBQUVpSyxJQUFJLEVBQUVsTCxDQUFDLEVBQUV0RCxJQUFJLEVBQUVDLEVBQUUsRUFBRVcsSUFBSSxFQUFFUyxTQUFTO1FBQzNFLElBQUlvTSxnQkFBZ0IsRUFBRSxFQUFFQyxpQkFBaUIsRUFBRTtRQUMzQyxNQUFPcEosU0FBU2xDLE1BQU0sR0FBR2tCLEVBQUc7WUFDeEJtSyxjQUFjekosSUFBSSxDQUFDTSxTQUFTNEgsR0FBRztZQUMvQndCLGVBQWUxSixJQUFJLENBQUNPLFVBQVUySCxHQUFHLEtBQUtzQyxPQUFPeE87UUFDakQ7UUFDQXNFLFNBQVNOLElBQUksQ0FBQzRDLFNBQVNnRyxRQUFRbEosS0FBSyxDQUFDOUMsS0FBSyxFQUFFNk0sZUFBZUMsZ0JBQWdCek4sS0FBS0QsTUFBTXFCLFlBQVlwQjtRQUNsR3NFLFVBQVVQLElBQUksQ0FBQ2hFLE9BQU93TztJQUMxQjtJQUNBLFNBQVM1SCxTQUFTaEcsSUFBSSxFQUFFMEQsUUFBUSxFQUFFQyxTQUFTLEVBQUVuQyxNQUFNLEVBQUVmLFlBQVksQ0FBQyxFQUFFTyxLQUFLO1FBQ3JFLElBQUlSLGFBQWE7WUFDYixJQUFJcU4sT0FBTztnQkFBQ3ZPLFNBQVNrQixXQUFXO2dCQUFFQTthQUFZO1lBQzlDUSxRQUFRQSxRQUFRO2dCQUFDNk07YUFBSyxDQUFDQyxNQUFNLENBQUM5TSxTQUFTO2dCQUFDNk07YUFBSztRQUNqRDtRQUNBLElBQUlwTixZQUFZLElBQUk7WUFDaEIsSUFBSW9OLE9BQU87Z0JBQUN2TyxTQUFTbUIsU0FBUztnQkFBRUE7YUFBVTtZQUMxQ08sUUFBUUEsUUFBUTtnQkFBQzZNO2FBQUssQ0FBQ0MsTUFBTSxDQUFDOU0sU0FBUztnQkFBQzZNO2FBQUs7UUFDakQ7UUFDQSxPQUFPLElBQUlwSyxLQUFLekQsTUFBTTBELFVBQVVDLFdBQVduQyxRQUFRUjtJQUN2RDtJQUNBLFNBQVN5TCxlQUFlc0IsT0FBTyxFQUFFekIsUUFBUTtRQUNyQyw2REFBNkQ7UUFDN0QsK0RBQStEO1FBQy9ELHVDQUF1QztRQUN2QyxpRUFBaUU7UUFDakUsMkRBQTJEO1FBQzNELHFDQUFxQztRQUNyQyxJQUFJMUYsT0FBTzFDLE9BQU8wQyxJQUFJO1FBQ3RCLElBQUlGLE9BQU8sR0FBR0YsUUFBUSxHQUFHa0csT0FBTyxHQUFHc0IsV0FBV3BILEtBQUtILEdBQUcsR0FBR3dGO1FBQ3pELElBQUloTSxTQUFTO1lBQUV5RyxNQUFNO1lBQUdGLE9BQU87WUFBR2tHLE1BQU07UUFBRTtRQUMxQ3ZFLE1BQU0sSUFBSyxJQUFJa0UsU0FBU3pGLEtBQUtyQyxHQUFHLEdBQUd3SixTQUFTbkgsS0FBS3JDLEdBQUcsR0FBRzhILFFBQVM7WUFDNUQsSUFBSTRCLFdBQVdySCxLQUFLRixJQUFJO1lBQ3hCLDJEQUEyRDtZQUMzRCxJQUFJRSxLQUFLcEgsRUFBRSxJQUFJOE0sWUFBWTJCLFlBQVksR0FBRztnQkFDdEMsMkRBQTJEO2dCQUMzRCxTQUFTO2dCQUNUaE8sT0FBT3lHLElBQUksR0FBR0E7Z0JBQ2R6RyxPQUFPdUcsS0FBSyxHQUFHQTtnQkFDZnZHLE9BQU95TSxJQUFJLEdBQUdBO2dCQUNkQSxRQUFRO2dCQUNSaEcsUUFBUTtnQkFDUkUsS0FBS0QsSUFBSTtnQkFDVDtZQUNKO1lBQ0EsSUFBSTZGLFdBQVc1RixLQUFLckMsR0FBRyxHQUFHMEo7WUFDMUIsSUFBSUEsV0FBVyxLQUFLekIsV0FBV0gsVUFBVXpGLEtBQUtKLEtBQUssR0FBR3dILFVBQ2xEO1lBQ0osSUFBSUUsZUFBZXRILEtBQUtwSCxFQUFFLElBQUkyTSxnQkFBZ0IsSUFBSTtZQUNsRCxJQUFJZ0MsWUFBWXZILEtBQUtKLEtBQUs7WUFDMUJJLEtBQUtELElBQUk7WUFDVCxNQUFPQyxLQUFLckMsR0FBRyxHQUFHaUksU0FBVTtnQkFDeEIsSUFBSTVGLEtBQUtGLElBQUksR0FBRyxHQUFHO29CQUNmLElBQUlFLEtBQUtGLElBQUksSUFBSSxDQUFDLEVBQUUsK0JBQStCLEtBQy9Dd0gsZ0JBQWdCO3lCQUVoQixNQUFNL0Y7Z0JBQ2QsT0FDSyxJQUFJdkIsS0FBS3BILEVBQUUsSUFBSTJNLGVBQWU7b0JBQy9CK0IsZ0JBQWdCO2dCQUNwQjtnQkFDQXRILEtBQUtELElBQUk7WUFDYjtZQUNBSCxRQUFRMkg7WUFDUnpILFFBQVF1SDtZQUNSdkIsUUFBUXdCO1FBQ1o7UUFDQSxJQUFJNUIsV0FBVyxLQUFLNUYsUUFBUXFILFNBQVM7WUFDakM5TixPQUFPeUcsSUFBSSxHQUFHQTtZQUNkekcsT0FBT3VHLEtBQUssR0FBR0E7WUFDZnZHLE9BQU95TSxJQUFJLEdBQUdBO1FBQ2xCO1FBQ0EsT0FBT3pNLE9BQU95RyxJQUFJLEdBQUcsSUFBSXpHLFNBQVNDO0lBQ3RDO0lBQ0EsU0FBUzBNLGFBQWF3QixXQUFXLEVBQUU5SCxNQUFNLEVBQUVDLEtBQUs7UUFDNUMsSUFBSSxFQUFFL0csRUFBRSxFQUFFZ0gsS0FBSyxFQUFFQyxHQUFHLEVBQUVDLElBQUksRUFBRSxHQUFHeEM7UUFDL0JBLE9BQU95QyxJQUFJO1FBQ1gsSUFBSUQsUUFBUSxLQUFLbEgsS0FBSzJNLGVBQWU7WUFDakMsSUFBSWpGLGFBQWFYO1lBQ2pCLElBQUlHLE9BQU8sR0FBRztnQkFDVixJQUFJaUcsU0FBU3pJLE9BQU9LLEdBQUcsR0FBSW1DLENBQUFBLE9BQU87Z0JBQ2xDLE1BQU94QyxPQUFPSyxHQUFHLEdBQUdvSSxPQUNoQnBHLFFBQVFxRyxhQUFhd0IsYUFBYTlILFFBQVFDO1lBQ2xEO1lBQ0FELE1BQU0sQ0FBQyxFQUFFQyxNQUFNLEdBQUdXO1lBQ2xCWixNQUFNLENBQUMsRUFBRUMsTUFBTSxHQUFHRSxNQUFNMkg7WUFDeEI5SCxNQUFNLENBQUMsRUFBRUMsTUFBTSxHQUFHQyxRQUFRNEg7WUFDMUI5SCxNQUFNLENBQUMsRUFBRUMsTUFBTSxHQUFHL0c7UUFDdEIsT0FDSyxJQUFJa0gsUUFBUSxDQUFDLEVBQUUsK0JBQStCLEtBQUk7WUFDbkRsRyxjQUFjaEI7UUFDbEIsT0FDSyxJQUFJa0gsUUFBUSxDQUFDLEVBQUUsMkJBQTJCLEtBQUk7WUFDL0NqRyxZQUFZakI7UUFDaEI7UUFDQSxPQUFPK0c7SUFDWDtJQUNBLElBQUk3QyxXQUFXLEVBQUUsRUFBRUMsWUFBWSxFQUFFO0lBQ2pDLE1BQU9PLE9BQU9LLEdBQUcsR0FBRyxFQUNoQjZILFNBQVNsRyxLQUFLTSxLQUFLLElBQUksR0FBR04sS0FBS2tJLFdBQVcsSUFBSSxHQUFHMUssVUFBVUMsV0FBVyxDQUFDLEdBQUc7SUFDOUUsSUFBSW5DLFNBQVMsQ0FBQ3lHLEtBQUsvQixLQUFLMUUsTUFBTSxNQUFNLFFBQVF5RyxPQUFPLEtBQUssSUFBSUEsS0FBTXZFLFNBQVNsQyxNQUFNLEdBQUdtQyxTQUFTLENBQUMsRUFBRSxHQUFHRCxRQUFRLENBQUMsRUFBRSxDQUFDbEMsTUFBTSxHQUFHO0lBQ3hILE9BQU8sSUFBSWlDLEtBQUtYLEtBQUssQ0FBQ29ELEtBQUttSSxLQUFLLENBQUMsRUFBRTNLLFNBQVMwSixPQUFPLElBQUl6SixVQUFVeUosT0FBTyxJQUFJNUw7QUFDaEY7QUFDQSxNQUFNOE0sZ0JBQWdCLElBQUloTDtBQUMxQixTQUFTMkssU0FBU00sV0FBVyxFQUFFL0wsSUFBSTtJQUMvQixJQUFJLENBQUMrTCxZQUFZcE0sV0FBVyxJQUFJSyxnQkFBZ0JxRSxjQUFjckUsS0FBS3hDLElBQUksSUFBSXVPLGFBQ3ZFLE9BQU87SUFDWCxJQUFJN0gsT0FBTzRILGNBQWN2TixHQUFHLENBQUN5QjtJQUM3QixJQUFJa0UsUUFBUSxNQUFNO1FBQ2RBLE9BQU87UUFDUCxLQUFLLElBQUl3RCxTQUFTMUgsS0FBS2tCLFFBQVEsQ0FBRTtZQUM3QixJQUFJd0csTUFBTWxLLElBQUksSUFBSXVPLGVBQWUsQ0FBRXJFLENBQUFBLGlCQUFpQnpHLElBQUcsR0FBSTtnQkFDdkRpRCxPQUFPO2dCQUNQO1lBQ0o7WUFDQUEsUUFBUXVILFNBQVNNLGFBQWFyRTtRQUNsQztRQUNBb0UsY0FBYzNKLEdBQUcsQ0FBQ25DLE1BQU1rRTtJQUM1QjtJQUNBLE9BQU9BO0FBQ1g7QUFDQSxTQUFTWCxhQUNULDRDQUE0QztBQUM1Q3dJLFdBQVcsRUFDWCwwQ0FBMEM7QUFDMUM3SyxRQUFRLEVBQUVDLFNBQVMsRUFDbkIsK0NBQStDO0FBQy9DdkUsSUFBSSxFQUFFQyxFQUFFLEVBQ1IsNkRBQTZEO0FBQzdEbUgsS0FBSyxFQUNMLDJCQUEyQjtBQUMzQmhGLE1BQU0sRUFDTixzREFBc0Q7QUFDdERnTixLQUFLLEVBQ0wseURBQXlEO0FBQ3pEQyxNQUFNO0lBQ0YsSUFBSUMsUUFBUTtJQUNaLElBQUssSUFBSWhNLElBQUl0RCxNQUFNc0QsSUFBSXJELElBQUlxRCxJQUN2QmdNLFNBQVNULFNBQVNNLGFBQWE3SyxRQUFRLENBQUNoQixFQUFFO0lBQzlDLElBQUlpTSxXQUFXN0csS0FBSzhHLElBQUksQ0FBQyxRQUFTLE1BQU8sRUFBRSx3QkFBd0I7SUFDbkUsSUFBSS9CLGdCQUFnQixFQUFFLEVBQUVDLGlCQUFpQixFQUFFO0lBQzNDLFNBQVMrQixPQUFPbkwsUUFBUSxFQUFFQyxTQUFTLEVBQUV2RSxJQUFJLEVBQUVDLEVBQUUsRUFBRXlQLE1BQU07UUFDakQsSUFBSyxJQUFJcE0sSUFBSXRELE1BQU1zRCxJQUFJckQsSUFBSztZQUN4QixJQUFJMFAsWUFBWXJNLEdBQUdzTSxhQUFhckwsU0FBUyxDQUFDakIsRUFBRSxFQUFFdU0sWUFBWWhCLFNBQVNNLGFBQWE3SyxRQUFRLENBQUNoQixFQUFFO1lBQzNGQTtZQUNBLE1BQU9BLElBQUlyRCxJQUFJcUQsSUFBSztnQkFDaEIsSUFBSXdNLFdBQVdqQixTQUFTTSxhQUFhN0ssUUFBUSxDQUFDaEIsRUFBRTtnQkFDaEQsSUFBSXVNLFlBQVlDLFlBQVlQLFVBQ3hCO2dCQUNKTSxhQUFhQztZQUNqQjtZQUNBLElBQUl4TSxLQUFLcU0sWUFBWSxHQUFHO2dCQUNwQixJQUFJRSxZQUFZTixVQUFVO29CQUN0QixJQUFJUSxPQUFPekwsUUFBUSxDQUFDcUwsVUFBVSxFQUFFLGlDQUFpQztvQkFDakVGLE9BQU9NLEtBQUt6TCxRQUFRLEVBQUV5TCxLQUFLeEwsU0FBUyxFQUFFLEdBQUd3TCxLQUFLekwsUUFBUSxDQUFDbEMsTUFBTSxFQUFFbUMsU0FBUyxDQUFDb0wsVUFBVSxHQUFHRDtvQkFDdEY7Z0JBQ0o7Z0JBQ0FqQyxjQUFjekosSUFBSSxDQUFDTSxRQUFRLENBQUNxTCxVQUFVO1lBQzFDLE9BQ0s7Z0JBQ0QsSUFBSXZOLFNBQVNtQyxTQUFTLENBQUNqQixJQUFJLEVBQUUsR0FBR2dCLFFBQVEsQ0FBQ2hCLElBQUksRUFBRSxDQUFDbEIsTUFBTSxHQUFHd047Z0JBQ3pEbkMsY0FBY3pKLElBQUksQ0FBQzJDLGFBQWF3SSxhQUFhN0ssVUFBVUMsV0FBV29MLFdBQVdyTSxHQUFHc00sWUFBWXhOLFFBQVEsTUFBTWlOO1lBQzlHO1lBQ0EzQixlQUFlMUosSUFBSSxDQUFDNEwsYUFBYUYsU0FBU3RJO1FBQzlDO0lBQ0o7SUFDQXFJLE9BQU9uTCxVQUFVQyxXQUFXdkUsTUFBTUMsSUFBSTtJQUN0QyxPQUFPLENBQUNtUCxTQUFTQyxNQUFLLEVBQUc1QixlQUFlQyxnQkFBZ0J0TDtBQUM1RDtBQUNBOzs7O0FBSUEsR0FDQSxNQUFNNE47SUFDRmpRLGFBQWM7UUFDVixJQUFJLENBQUNtRCxHQUFHLEdBQUcsSUFBSWdCO0lBQ25CO0lBQ0ErTCxVQUFVL0ksTUFBTSxFQUFFQyxLQUFLLEVBQUUzQyxLQUFLLEVBQUU7UUFDNUIsSUFBSXdFLFFBQVEsSUFBSSxDQUFDOUYsR0FBRyxDQUFDdkIsR0FBRyxDQUFDdUY7UUFDekIsSUFBSSxDQUFDOEIsT0FDRCxJQUFJLENBQUM5RixHQUFHLENBQUNxQyxHQUFHLENBQUMyQixRQUFROEIsUUFBUSxJQUFJa0g7UUFDckNsSCxNQUFNekQsR0FBRyxDQUFDNEIsT0FBTzNDO0lBQ3JCO0lBQ0EyTCxVQUFVakosTUFBTSxFQUFFQyxLQUFLLEVBQUU7UUFDckIsSUFBSTZCLFFBQVEsSUFBSSxDQUFDOUYsR0FBRyxDQUFDdkIsR0FBRyxDQUFDdUY7UUFDekIsT0FBTzhCLFNBQVNBLE1BQU1ySCxHQUFHLENBQUN3RjtJQUM5QjtJQUNBOztJQUVBLEdBQ0E1QixJQUFJbkMsSUFBSSxFQUFFb0IsS0FBSyxFQUFFO1FBQ2IsSUFBSXBCLGdCQUFnQitHLFlBQ2hCLElBQUksQ0FBQzhGLFNBQVMsQ0FBQzdNLEtBQUtvRyxPQUFPLENBQUN0QyxNQUFNLEVBQUU5RCxLQUFLK0QsS0FBSyxFQUFFM0M7YUFDL0MsSUFBSXBCLGdCQUFnQnFDLFVBQ3JCLElBQUksQ0FBQ3ZDLEdBQUcsQ0FBQ3FDLEdBQUcsQ0FBQ25DLEtBQUs1QixJQUFJLEVBQUVnRDtJQUNoQztJQUNBOztJQUVBLEdBQ0E3QyxJQUFJeUIsSUFBSSxFQUFFO1FBQ04sT0FBT0EsZ0JBQWdCK0csYUFBYSxJQUFJLENBQUNnRyxTQUFTLENBQUMvTSxLQUFLb0csT0FBTyxDQUFDdEMsTUFBTSxFQUFFOUQsS0FBSytELEtBQUssSUFDNUUvRCxnQkFBZ0JxQyxXQUFXLElBQUksQ0FBQ3ZDLEdBQUcsQ0FBQ3ZCLEdBQUcsQ0FBQ3lCLEtBQUs1QixJQUFJLElBQUlWO0lBQy9EO0lBQ0E7O0lBRUEsR0FDQXNQLFVBQVV0TCxNQUFNLEVBQUVOLEtBQUssRUFBRTtRQUNyQixJQUFJTSxPQUFPb0MsTUFBTSxFQUNiLElBQUksQ0FBQytJLFNBQVMsQ0FBQ25MLE9BQU9vQyxNQUFNLENBQUNBLE1BQU0sRUFBRXBDLE9BQU9xQyxLQUFLLEVBQUUzQzthQUVuRCxJQUFJLENBQUN0QixHQUFHLENBQUNxQyxHQUFHLENBQUNULE9BQU90RCxJQUFJLEVBQUVnRDtJQUNsQztJQUNBOzs7SUFHQSxHQUNBNkwsVUFBVXZMLE1BQU0sRUFBRTtRQUNkLE9BQU9BLE9BQU9vQyxNQUFNLEdBQUcsSUFBSSxDQUFDaUosU0FBUyxDQUFDckwsT0FBT29DLE1BQU0sQ0FBQ0EsTUFBTSxFQUFFcEMsT0FBT3FDLEtBQUssSUFBSSxJQUFJLENBQUNqRSxHQUFHLENBQUN2QixHQUFHLENBQUNtRCxPQUFPdEQsSUFBSTtJQUN4RztBQUNKO0FBRUE7Ozs7Ozs7O0FBUUEsR0FDQSxNQUFNOE87SUFDRjs7Ozs7SUFLQSxHQUNBdlEsWUFDQTs7OztJQUlBLEdBQ0FDLElBQUksRUFDSjs7SUFFQSxHQUNBQyxFQUFFLEVBQ0Y7O0lBRUEsR0FDQXVCLElBQUksRUFDSjs7Ozs7SUFLQSxHQUNBa08sTUFBTSxFQUFFYSxZQUFZLEtBQUssRUFBRUMsVUFBVSxLQUFLLENBQUU7UUFDeEMsSUFBSSxDQUFDeFEsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQ0MsRUFBRSxHQUFHQTtRQUNWLElBQUksQ0FBQ3VCLElBQUksR0FBR0E7UUFDWixJQUFJLENBQUNrTyxNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDZSxJQUFJLEdBQUcsQ0FBQ0YsWUFBWSxFQUFFLGNBQWMsTUFBSyxLQUFNQyxDQUFBQSxVQUFVLEVBQUUsWUFBWSxNQUFLO0lBQ3JGO0lBQ0E7Ozs7O0lBS0EsR0FDQSxJQUFJRCxZQUFZO1FBQUUsT0FBTyxDQUFDLElBQUksQ0FBQ0UsSUFBSSxHQUFHLEVBQUUsY0FBYyxHQUFoQixJQUFzQjtJQUFHO0lBQy9EOzs7SUFHQSxHQUNBLElBQUlELFVBQVU7UUFBRSxPQUFPLENBQUMsSUFBSSxDQUFDQyxJQUFJLEdBQUcsRUFBRSxZQUFZLEdBQWQsSUFBb0I7SUFBRztJQUMzRDs7Ozs7OztJQU9BLEdBQ0EsT0FBT0MsUUFBUWxQLElBQUksRUFBRW1QLFlBQVksRUFBRSxFQUFFQyxVQUFVLEtBQUssRUFBRTtRQUNsRCxJQUFJL1AsU0FBUztZQUFDLElBQUl5UCxhQUFhLEdBQUc5TyxLQUFLWSxNQUFNLEVBQUVaLE1BQU0sR0FBRyxPQUFPb1A7U0FBUztRQUN4RSxLQUFLLElBQUlDLEtBQUtGLFVBQ1YsSUFBSUUsRUFBRTVRLEVBQUUsR0FBR3VCLEtBQUtZLE1BQU0sRUFDbEJ2QixPQUFPbUQsSUFBSSxDQUFDNk07UUFDcEIsT0FBT2hRO0lBQ1g7SUFDQTs7OztJQUlBLEdBQ0EsT0FBT2lRLGFBQWFILFNBQVMsRUFBRUksT0FBTyxFQUFFQyxTQUFTLEdBQUcsRUFBRTtRQUNsRCxJQUFJLENBQUNELFFBQVEzTyxNQUFNLEVBQ2YsT0FBT3VPO1FBQ1gsSUFBSTlQLFNBQVMsRUFBRTtRQUNmLElBQUlvUSxLQUFLLEdBQUdDLFFBQVFQLFVBQVV2TyxNQUFNLEdBQUd1TyxTQUFTLENBQUMsRUFBRSxHQUFHO1FBQ3RELElBQUssSUFBSVEsS0FBSyxHQUFHaE0sTUFBTSxHQUFHaU0sTUFBTSxJQUFJRCxLQUFNO1lBQ3RDLElBQUlFLFFBQVFGLEtBQUtKLFFBQVEzTyxNQUFNLEdBQUcyTyxPQUFPLENBQUNJLEdBQUcsR0FBRztZQUNoRCxJQUFJRyxVQUFVRCxRQUFRQSxNQUFNRSxLQUFLLEdBQUc7WUFDcEMsSUFBSUQsVUFBVW5NLE9BQU82TCxRQUNqQixNQUFPRSxTQUFTQSxNQUFNbFIsSUFBSSxHQUFHc1IsUUFBUztnQkFDbEMsSUFBSUUsTUFBTU47Z0JBQ1YsSUFBSS9MLE9BQU9xTSxJQUFJeFIsSUFBSSxJQUFJc1IsV0FBV0UsSUFBSXZSLEVBQUUsSUFBSW1SLEtBQUs7b0JBQzdDLElBQUlLLFFBQVEvSSxLQUFLQyxHQUFHLENBQUM2SSxJQUFJeFIsSUFBSSxFQUFFbUYsT0FBT2lNLEtBQUtNLE1BQU1oSixLQUFLaUosR0FBRyxDQUFDSCxJQUFJdlIsRUFBRSxFQUFFcVIsV0FBV0Y7b0JBQzdFSSxNQUFNQyxTQUFTQyxNQUFNLE9BQU8sSUFBSXBCLGFBQWFtQixPQUFPQyxLQUFLRixJQUFJaFEsSUFBSSxFQUFFZ1EsSUFBSTlCLE1BQU0sR0FBRzBCLEtBQUtELEtBQUssR0FBRyxDQUFDLENBQUNFO2dCQUNuRztnQkFDQSxJQUFJRyxLQUNBM1EsT0FBT21ELElBQUksQ0FBQ3dOO2dCQUNoQixJQUFJTixNQUFNalIsRUFBRSxHQUFHcVIsU0FDWDtnQkFDSkosUUFBUUQsS0FBS04sVUFBVXZPLE1BQU0sR0FBR3VPLFNBQVMsQ0FBQ00sS0FBSyxHQUFHO1lBQ3REO1lBQ0osSUFBSSxDQUFDSSxPQUNEO1lBQ0psTSxNQUFNa00sTUFBTU8sR0FBRztZQUNmUixNQUFNQyxNQUFNTyxHQUFHLEdBQUdQLE1BQU1RLEdBQUc7UUFDL0I7UUFDQSxPQUFPaFI7SUFDWDtBQUNKO0FBQ0E7O0FBRUEsR0FDQSxNQUFNaVI7SUFDRjs7Ozs7Ozs7O0lBU0EsR0FDQUMsV0FBV0MsS0FBSyxFQUFFckIsU0FBUyxFQUFFc0IsTUFBTSxFQUFFO1FBQ2pDLElBQUksT0FBT0QsU0FBUyxVQUNoQkEsUUFBUSxJQUFJRSxZQUFZRjtRQUM1QkMsU0FBUyxDQUFDQSxTQUFTO1lBQUMsSUFBSW5TLE1BQU0sR0FBR2tTLE1BQU01UCxNQUFNO1NBQUUsR0FBRzZQLE9BQU83UCxNQUFNLEdBQUc2UCxPQUFPL08sR0FBRyxDQUFDbUcsQ0FBQUEsSUFBSyxJQUFJdkosTUFBTXVKLEVBQUVySixJQUFJLEVBQUVxSixFQUFFcEosRUFBRSxLQUFLO1lBQUMsSUFBSUgsTUFBTSxHQUFHO1NBQUc7UUFDOUgsT0FBTyxJQUFJLENBQUNxUyxXQUFXLENBQUNILE9BQU9yQixhQUFhLEVBQUUsRUFBRXNCO0lBQ3BEO0lBQ0E7O0lBRUEsR0FDQUcsTUFBTUosS0FBSyxFQUFFckIsU0FBUyxFQUFFc0IsTUFBTSxFQUFFO1FBQzVCLElBQUlHLFFBQVEsSUFBSSxDQUFDTCxVQUFVLENBQUNDLE9BQU9yQixXQUFXc0I7UUFDOUMsT0FBUztZQUNMLElBQUlJLE9BQU9ELE1BQU1FLE9BQU87WUFDeEIsSUFBSUQsTUFDQSxPQUFPQTtRQUNmO0lBQ0o7QUFDSjtBQUNBLE1BQU1IO0lBQ0ZuUyxZQUFZd1MsTUFBTSxDQUFFO1FBQ2hCLElBQUksQ0FBQ0EsTUFBTSxHQUFHQTtJQUNsQjtJQUNBLElBQUluUSxTQUFTO1FBQUUsT0FBTyxJQUFJLENBQUNtUSxNQUFNLENBQUNuUSxNQUFNO0lBQUU7SUFDMUNvUSxNQUFNeFMsSUFBSSxFQUFFO1FBQUUsT0FBTyxJQUFJLENBQUN1UyxNQUFNLENBQUNySyxLQUFLLENBQUNsSTtJQUFPO0lBQzlDLElBQUl5UyxhQUFhO1FBQUUsT0FBTztJQUFPO0lBQ2pDQyxLQUFLMVMsSUFBSSxFQUFFQyxFQUFFLEVBQUU7UUFBRSxPQUFPLElBQUksQ0FBQ3NTLE1BQU0sQ0FBQ3JLLEtBQUssQ0FBQ2xJLE1BQU1DO0lBQUs7QUFDekQ7QUFFQTs7Ozs7O0FBTUEsR0FDQSxTQUFTMFMsV0FBV0MsSUFBSTtJQUNwQixPQUFPLENBQUNSLE9BQU9KLE9BQU9yQixXQUFXc0IsU0FBVyxJQUFJWSxXQUFXVCxPQUFPUSxNQUFNWixPQUFPckIsV0FBV3NCO0FBQzlGO0FBQ0EsTUFBTWE7SUFDRi9TLFlBQVkyQixNQUFNLEVBQUUwUSxLQUFLLEVBQUUzUSxPQUFPLEVBQUVzUixNQUFNLEVBQUUvUyxJQUFJLENBQUU7UUFDOUMsSUFBSSxDQUFDMEIsTUFBTSxHQUFHQTtRQUNkLElBQUksQ0FBQzBRLEtBQUssR0FBR0E7UUFDYixJQUFJLENBQUMzUSxPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDc1IsTUFBTSxHQUFHQTtRQUNkLElBQUksQ0FBQy9TLElBQUksR0FBR0E7SUFDaEI7QUFDSjtBQUNBLFNBQVNnVCxZQUFZZixNQUFNO0lBQ3ZCLElBQUksQ0FBQ0EsT0FBTzdQLE1BQU0sSUFBSTZQLE9BQU90RixJQUFJLENBQUN0RCxDQUFBQSxJQUFLQSxFQUFFckosSUFBSSxJQUFJcUosRUFBRXBKLEVBQUUsR0FDakQsTUFBTSxJQUFJUyxXQUFXLHVDQUF1Q2tFLEtBQUtDLFNBQVMsQ0FBQ29OO0FBQ25GO0FBQ0EsTUFBTWdCO0lBQ0ZsVCxZQUFZMkIsTUFBTSxFQUFFd1IsU0FBUyxFQUFFQyxNQUFNLEVBQUVoTSxLQUFLLEVBQUVDLEtBQUssRUFBRTJMLE1BQU0sRUFBRXhHLElBQUksQ0FBRTtRQUMvRCxJQUFJLENBQUM3SyxNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDd1IsU0FBUyxHQUFHQTtRQUNqQixJQUFJLENBQUNDLE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUNoTSxLQUFLLEdBQUdBO1FBQ2IsSUFBSSxDQUFDQyxLQUFLLEdBQUdBO1FBQ2IsSUFBSSxDQUFDMkwsTUFBTSxHQUFHQTtRQUNkLElBQUksQ0FBQ3hHLElBQUksR0FBR0E7UUFDWixJQUFJLENBQUNFLEtBQUssR0FBRztRQUNiLElBQUksQ0FBQ3dGLE1BQU0sR0FBRyxFQUFFO0lBQ3BCO0FBQ0o7QUFDQSxNQUFNbUIsZUFBZSxJQUFJbFQsU0FBUztJQUFFRyxTQUFTO0FBQUs7QUFDbEQsTUFBTXdTO0lBQ0Y5UyxZQUFZeU8sSUFBSSxFQUFFb0UsSUFBSSxFQUFFWixLQUFLLEVBQUVyQixTQUFTLEVBQUVzQixNQUFNLENBQUU7UUFDOUMsSUFBSSxDQUFDVyxJQUFJLEdBQUdBO1FBQ1osSUFBSSxDQUFDWixLQUFLLEdBQUdBO1FBQ2IsSUFBSSxDQUFDckIsU0FBUyxHQUFHQTtRQUNqQixJQUFJLENBQUNzQixNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDakosS0FBSyxHQUFHLEVBQUU7UUFDZixJQUFJLENBQUNxSyxTQUFTLEdBQUc7UUFDakIsSUFBSSxDQUFDQyxRQUFRLEdBQUc7UUFDaEIsSUFBSSxDQUFDQyxTQUFTLEdBQUc7UUFDakIsSUFBSSxDQUFDQyxTQUFTLEdBQUdoRjtJQUNyQjtJQUNBOEQsVUFBVTtRQUNOLElBQUksSUFBSSxDQUFDa0IsU0FBUyxFQUFFO1lBQ2hCLElBQUluQixPQUFPLElBQUksQ0FBQ21CLFNBQVMsQ0FBQ2xCLE9BQU87WUFDakMsSUFBSSxDQUFDRCxNQUNELE9BQU87WUFDWCxJQUFJLENBQUNtQixTQUFTLEdBQUc7WUFDakIsSUFBSSxDQUFDRixRQUFRLEdBQUdqQjtZQUNoQixJQUFJLENBQUNvQixVQUFVO1lBQ2YsSUFBSSxJQUFJLENBQUNGLFNBQVMsSUFBSSxNQUNsQixLQUFLLElBQUl2SyxTQUFTLElBQUksQ0FBQ0EsS0FBSyxDQUN4QkEsTUFBTW9KLEtBQUssQ0FBQy9ELE1BQU0sQ0FBQyxJQUFJLENBQUNrRixTQUFTO1FBQzdDO1FBQ0EsSUFBSSxJQUFJLENBQUNGLFNBQVMsSUFBSSxJQUFJLENBQUNySyxLQUFLLENBQUM1RyxNQUFNLEVBQUU7WUFDckMsSUFBSXZCLFNBQVMsSUFBSSxDQUFDeVMsUUFBUTtZQUMxQixJQUFJLElBQUksQ0FBQ0MsU0FBUyxJQUFJLE1BQ2xCMVMsU0FBUyxJQUFJd0QsS0FBS3hELE9BQU9ELElBQUksRUFBRUMsT0FBT3lELFFBQVEsRUFBRXpELE9BQU8wRCxTQUFTLEVBQUUxRCxPQUFPdUIsTUFBTSxFQUFFdkIsT0FBTzRGLFVBQVUsQ0FBQ2lJLE1BQU0sQ0FBQztnQkFBQztvQkFBQzBFO29CQUFjLElBQUksQ0FBQ0csU0FBUztpQkFBQzthQUFDO1lBQzlJLE9BQU8xUztRQUNYO1FBQ0EsSUFBSW1JLFFBQVEsSUFBSSxDQUFDQSxLQUFLLENBQUMsSUFBSSxDQUFDcUssU0FBUyxDQUFDLEVBQUVoQixPQUFPckosTUFBTW9KLEtBQUssQ0FBQ0UsT0FBTztRQUNsRSxJQUFJRCxNQUFNO1lBQ04sSUFBSSxDQUFDZ0IsU0FBUztZQUNkLDJEQUEyRDtZQUMzRCxzREFBc0Q7WUFDdEQsZ0VBQWdFO1lBQ2hFLHlCQUF5QjtZQUN6QixJQUFJelIsUUFBUUUsT0FBT2lDLE1BQU0sQ0FBQ2pDLE9BQU9DLE1BQU0sQ0FBQyxPQUFPaUgsTUFBTStKLE1BQU0sQ0FBQ25SLEtBQUs7WUFDakVBLEtBQUssQ0FBQzFCLFNBQVNvQixPQUFPLENBQUNsQixFQUFFLENBQUMsR0FBRyxJQUFJbUIsWUFBWThRLE1BQU1ySixNQUFNdkgsT0FBTyxFQUFFdUgsTUFBTXRILE1BQU07WUFDOUVzSCxNQUFNK0osTUFBTSxDQUFDblIsS0FBSyxHQUFHQTtRQUN6QjtRQUNBLE9BQU87SUFDWDtJQUNBLElBQUk4UixZQUFZO1FBQ1osSUFBSSxJQUFJLENBQUNGLFNBQVMsRUFDZCxPQUFPO1FBQ1gsSUFBSXJPLE1BQU0sSUFBSSxDQUFDNk0sS0FBSyxDQUFDNVAsTUFBTTtRQUMzQixJQUFLLElBQUlrQixJQUFJLElBQUksQ0FBQytQLFNBQVMsRUFBRS9QLElBQUksSUFBSSxDQUFDMEYsS0FBSyxDQUFDNUcsTUFBTSxFQUFFa0IsSUFBSztZQUNyRCxJQUFJLElBQUksQ0FBQzBGLEtBQUssQ0FBQzFGLEVBQUUsQ0FBQ3RELElBQUksR0FBR21GLEtBQ3JCQSxNQUFNdUQsS0FBS2lKLEdBQUcsQ0FBQ3hNLEtBQUssSUFBSSxDQUFDNkQsS0FBSyxDQUFDMUYsRUFBRSxDQUFDOE8sS0FBSyxDQUFDc0IsU0FBUztRQUN6RDtRQUNBLE9BQU92TztJQUNYO0lBQ0FrSixPQUFPbEosR0FBRyxFQUFFO1FBQ1IsSUFBSSxDQUFDb08sU0FBUyxHQUFHcE87UUFDakIsSUFBSSxJQUFJLENBQUNxTyxTQUFTLEVBQ2QsSUFBSSxDQUFDQSxTQUFTLENBQUNuRixNQUFNLENBQUNsSjthQUV0QixJQUFLLElBQUk3QixJQUFJLElBQUksQ0FBQytQLFNBQVMsRUFBRS9QLElBQUksSUFBSSxDQUFDMEYsS0FBSyxDQUFDNUcsTUFBTSxFQUFFa0IsSUFDaEQsSUFBSSxDQUFDMEYsS0FBSyxDQUFDMUYsRUFBRSxDQUFDOE8sS0FBSyxDQUFDL0QsTUFBTSxDQUFDbEo7SUFDdkM7SUFDQXNPLGFBQWE7UUFDVCxJQUFJRSxpQkFBaUIsSUFBSUMsZUFBZSxJQUFJLENBQUNqRCxTQUFTO1FBQ3RELElBQUlsUCxVQUFVO1FBQ2QsSUFBSW9TLFVBQVU7UUFDZCxJQUFJL08sU0FBUyxJQUFJRSxXQUFXLElBQUlTLFNBQVMsSUFBSSxDQUFDNk4sUUFBUSxFQUFFLElBQUksQ0FBQ3JCLE1BQU0sQ0FBQyxFQUFFLENBQUNqUyxJQUFJLEVBQUUsR0FBRyxPQUFPb0UsU0FBUytCLGdCQUFnQixHQUFHL0IsU0FBU2tHLFlBQVk7UUFDeEl2QixNQUFNLElBQUssSUFBSTZKLE1BQU1rQixZQUFhO1lBQzlCLElBQUk5TixRQUFRLE1BQU0rTjtZQUNsQixJQUFJLElBQUksQ0FBQ1IsU0FBUyxJQUFJLFFBQVF6TyxPQUFPOUUsSUFBSSxJQUFJLElBQUksQ0FBQ3VULFNBQVMsRUFBRTtnQkFDekR2TixRQUFRO1lBQ1osT0FDSyxJQUFJMk4sZUFBZUssT0FBTyxDQUFDbFAsU0FBUztnQkFDckMsSUFBSXJELFNBQVM7b0JBQ1QsSUFBSWhCLFFBQVFnQixRQUFRMFIsTUFBTSxDQUFDYyxJQUFJLENBQUNDLENBQUFBLElBQUtBLEVBQUVDLElBQUksQ0FBQ25VLElBQUksSUFBSThFLE9BQU85RSxJQUFJLElBQUlrVSxFQUFFQyxJQUFJLENBQUNsVSxFQUFFLElBQUk2RSxPQUFPN0UsRUFBRSxJQUFJaVUsRUFBRTFJLEtBQUssQ0FBQy9KLE9BQU87b0JBQzVHLElBQUloQixPQUNBLEtBQUssSUFBSTRJLEtBQUs1SSxNQUFNK0ssS0FBSyxDQUFDL0osT0FBTyxDQUFFO3dCQUMvQixJQUFJekIsT0FBT3FKLEVBQUVySixJQUFJLEdBQUdTLE1BQU0wRSxHQUFHLEVBQUVsRixLQUFLb0osRUFBRXBKLEVBQUUsR0FBR1EsTUFBTTBFLEdBQUc7d0JBQ3BELElBQUluRixRQUFROEUsT0FBTzlFLElBQUksSUFBSUMsTUFBTTZFLE9BQU83RSxFQUFFLElBQUksQ0FBQ3dCLFFBQVF3USxNQUFNLENBQUN0RixJQUFJLENBQUN0RCxDQUFBQSxJQUFLQSxFQUFFckosSUFBSSxHQUFHQyxNQUFNb0osRUFBRXBKLEVBQUUsR0FBR0QsT0FDMUZ5QixRQUFRd1EsTUFBTSxDQUFDak8sSUFBSSxDQUFDOzRCQUFFaEU7NEJBQU1DO3dCQUFHO29CQUN2QztnQkFDUjtnQkFDQStGLFFBQVE7WUFDWixPQUNLLElBQUk2TixXQUFZQyxDQUFBQSxZQUFZTSxXQUFXUCxRQUFRNUIsTUFBTSxFQUFFbk4sT0FBTzlFLElBQUksRUFBRThFLE9BQU83RSxFQUFFLElBQUk7Z0JBQ2xGK0YsUUFBUThOLGFBQWEsRUFBRSxjQUFjO1lBQ3pDLE9BQ0ssSUFBSSxDQUFDaFAsT0FBT2xFLElBQUksQ0FBQ21DLFdBQVcsSUFBSzZQLENBQUFBLE9BQU8sSUFBSSxDQUFDQSxJQUFJLENBQUM5TixRQUFRLElBQUksQ0FBQ2tOLEtBQUssTUFDcEVsTixDQUFBQSxPQUFPOUUsSUFBSSxHQUFHOEUsT0FBTzdFLEVBQUUsSUFBSSxDQUFDMlMsS0FBS25SLE9BQU8sR0FBRztnQkFDNUMsSUFBSSxDQUFDcUQsT0FBT3RELElBQUksRUFDWjZTLFlBQVl2UDtnQkFDaEIsSUFBSXdQLFlBQVlYLGVBQWVZLFVBQVUsQ0FBQ3pQLE9BQU85RSxJQUFJLEVBQUU0UyxLQUFLbFIsTUFBTTtnQkFDbEUsSUFBSSxPQUFPa1IsS0FBS25SLE9BQU8sSUFBSSxZQUFZO29CQUNuQ0EsVUFBVSxJQUFJd1IsY0FBY0wsS0FBS2xSLE1BQU0sRUFBRWtSLEtBQUtuUixPQUFPLEVBQUU2UyxXQUFXLElBQUksQ0FBQ3RMLEtBQUssQ0FBQzVHLE1BQU0sRUFBRTBDLE9BQU85RSxJQUFJLEVBQUU4RSxPQUFPdEQsSUFBSSxFQUFFQztnQkFDbkgsT0FDSztvQkFDRCxJQUFJd1EsU0FBU3VDLFlBQVksSUFBSSxDQUFDdkMsTUFBTSxFQUFFVyxLQUFLblIsT0FBTyxJQUM3Q3FELENBQUFBLE9BQU85RSxJQUFJLEdBQUc4RSxPQUFPN0UsRUFBRSxHQUFHO3dCQUFDLElBQUlILE1BQU1nRixPQUFPOUUsSUFBSSxFQUFFOEUsT0FBTzdFLEVBQUU7cUJBQUUsR0FBRyxFQUFFO29CQUN2RSxJQUFJZ1MsT0FBTzdQLE1BQU0sRUFDYjRRLFlBQVlmO29CQUNoQixJQUFJQSxPQUFPN1AsTUFBTSxJQUFJLENBQUN3USxLQUFLblIsT0FBTyxFQUM5QixJQUFJLENBQUN1SCxLQUFLLENBQUNoRixJQUFJLENBQUMsSUFBSThPLFdBQVdGLEtBQUtsUixNQUFNLEVBQUV1USxPQUFPN1AsTUFBTSxHQUFHd1EsS0FBS2xSLE1BQU0sQ0FBQ3FRLFVBQVUsQ0FBQyxJQUFJLENBQUNDLEtBQUssRUFBRXlDLGVBQWVILFdBQVdyQyxTQUFTQSxVQUM1SFcsS0FBS2xSLE1BQU0sQ0FBQ3FRLFVBQVUsQ0FBQyxLQUFLYSxLQUFLblIsT0FBTyxHQUFHbVIsS0FBS25SLE9BQU8sQ0FBQ3lCLEdBQUcsQ0FBQ21HLENBQUFBLElBQUssSUFBSXZKLE1BQU11SixFQUFFckosSUFBSSxHQUFHOEUsT0FBTzlFLElBQUksRUFBRXFKLEVBQUVwSixFQUFFLEdBQUc2RSxPQUFPOUUsSUFBSSxLQUFLLE1BQU04RSxPQUFPdEQsSUFBSSxFQUFFeVEsT0FBTzdQLE1BQU0sR0FBRzZQLE1BQU0sQ0FBQyxFQUFFLENBQUNqUyxJQUFJLEdBQUc4RSxPQUFPOUUsSUFBSTtvQkFDak0sSUFBSSxDQUFDNFMsS0FBS25SLE9BQU8sRUFDYnVFLFFBQVE7eUJBQ1AsSUFBSWlNLE9BQU83UCxNQUFNLEVBQ2xCeVIsVUFBVTt3QkFBRTVCO3dCQUFReEYsT0FBTzt3QkFBR0YsTUFBTXNIO29CQUFRO2dCQUNwRDtZQUNKLE9BQ0ssSUFBSXBTLFdBQVlzUyxDQUFBQSxRQUFRdFMsUUFBUXlSLFNBQVMsQ0FBQ3BPLE9BQU0sR0FBSTtnQkFDckQsSUFBSWlQLFVBQVUsTUFDVkEsUUFBUSxJQUFJalUsTUFBTWdGLE9BQU85RSxJQUFJLEVBQUU4RSxPQUFPN0UsRUFBRTtnQkFDNUMsSUFBSThULE1BQU0vVCxJQUFJLEdBQUcrVCxNQUFNOVQsRUFBRSxFQUNyQndCLFFBQVF3USxNQUFNLENBQUNqTyxJQUFJLENBQUMrUDtZQUM1QjtZQUNBLElBQUkvTixTQUFTbEIsT0FBT3dCLFVBQVUsSUFBSTtnQkFDOUIsSUFBSTdFLFNBQ0FBLFFBQVFnTCxLQUFLO2dCQUNqQixJQUFJb0gsU0FDQUEsUUFBUXBILEtBQUs7WUFDckIsT0FDSztnQkFDRCxPQUFTO29CQUNMLElBQUkzSCxPQUFPeUIsV0FBVyxJQUNsQjtvQkFDSixJQUFJLENBQUN6QixPQUFPMEIsTUFBTSxJQUNkLE1BQU11QztvQkFDVixJQUFJdEgsV0FBVyxDQUFDLEVBQUVBLFFBQVFnTCxLQUFLLEVBQUU7d0JBQzdCLElBQUl3RixTQUFTdUMsWUFBWSxJQUFJLENBQUN2QyxNQUFNLEVBQUV4USxRQUFRd1EsTUFBTTt3QkFDcEQsSUFBSUEsT0FBTzdQLE1BQU0sRUFBRTs0QkFDZjRRLFlBQVlmOzRCQUNaLElBQUksQ0FBQ2pKLEtBQUssQ0FBQ3FDLE1BQU0sQ0FBQzVKLFFBQVEwRixLQUFLLEVBQUUsR0FBRyxJQUFJMkwsV0FBV3JSLFFBQVFDLE1BQU0sRUFBRUQsUUFBUUMsTUFBTSxDQUFDcVEsVUFBVSxDQUFDLElBQUksQ0FBQ0MsS0FBSyxFQUFFeUMsZUFBZWhULFFBQVEwUixNQUFNLEVBQUVsQixTQUFTQSxTQUFTeFEsUUFBUXdRLE1BQU0sQ0FBQy9PLEdBQUcsQ0FBQ21HLENBQUFBLElBQUssSUFBSXZKLE1BQU11SixFQUFFckosSUFBSSxHQUFHeUIsUUFBUTJGLEtBQUssRUFBRWlDLEVBQUVwSixFQUFFLEdBQUd3QixRQUFRMkYsS0FBSyxJQUFJM0YsUUFBUXNSLE1BQU0sRUFBRWQsTUFBTSxDQUFDLEVBQUUsQ0FBQ2pTLElBQUk7d0JBQzlRO3dCQUNBeUIsVUFBVUEsUUFBUThLLElBQUk7b0JBQzFCO29CQUNBLElBQUlzSCxXQUFXLENBQUMsRUFBRUEsUUFBUXBILEtBQUssRUFDM0JvSCxVQUFVQSxRQUFRdEgsSUFBSTtnQkFDOUI7WUFDSjtRQUNKO0lBQ0o7QUFDSjtBQUNBLFNBQVM2SCxXQUFXUCxPQUFPLEVBQUU3VCxJQUFJLEVBQUVDLEVBQUU7SUFDakMsS0FBSyxJQUFJOFQsU0FBU0YsUUFBUztRQUN2QixJQUFJRSxNQUFNL1QsSUFBSSxJQUFJQyxJQUNkO1FBQ0osSUFBSThULE1BQU05VCxFQUFFLEdBQUdELE1BQ1gsT0FBTytULE1BQU0vVCxJQUFJLElBQUlBLFFBQVErVCxNQUFNOVQsRUFBRSxJQUFJQSxLQUFLLEVBQUUsY0FBYyxNQUFLLEVBQUUsaUJBQWlCO0lBQzlGO0lBQ0EsT0FBTyxFQUFFLGNBQWM7QUFDM0I7QUFDQSwyREFBMkQ7QUFDM0QsY0FBYztBQUNkLFNBQVN5VSxTQUFTQyxHQUFHLEVBQUV4TSxNQUFNLEVBQUVDLElBQUksRUFBRStGLEtBQUssRUFBRTVKLFNBQVMsRUFBRTZNLEdBQUc7SUFDdEQsSUFBSWpKLFNBQVNDLE1BQU07UUFDZixJQUFJcEksT0FBTzJVLElBQUl6TixNQUFNLENBQUNpQixTQUFTLEVBQUU7UUFDakNnRyxNQUFNbkssSUFBSSxDQUFDMlEsSUFBSXpNLEtBQUssQ0FBQ0MsUUFBUUMsTUFBTXBJO1FBQ25DdUUsVUFBVVAsSUFBSSxDQUFDaEUsT0FBT29SO0lBQzFCO0FBQ0o7QUFDQSxzRUFBc0U7QUFDdEUsb0VBQW9FO0FBQ3BFLHFFQUFxRTtBQUNyRSxxRUFBcUU7QUFDckUsOERBQThEO0FBQzlELFNBQVNpRCxZQUFZdlAsTUFBTTtJQUN2QixJQUFJLEVBQUUxQixJQUFJLEVBQUUsR0FBRzBCLFFBQVE0RyxRQUFRLEVBQUU7SUFDakMsOEJBQThCO0lBQzlCLEdBQUc7UUFDQ0EsTUFBTTFILElBQUksQ0FBQ2MsT0FBT3FDLEtBQUs7UUFDdkJyQyxPQUFPMEIsTUFBTTtJQUNqQixRQUFTLENBQUMxQixPQUFPdEQsSUFBSSxFQUFFO0lBQ3ZCLDRDQUE0QztJQUM1QyxJQUFJOEIsSUFBSSxHQUFHa0wsT0FBTzFKLE9BQU90RCxJQUFJLEVBQUU0UCxNQUFNO0lBQ3JDLE9BQVE5TixJQUFLO1FBQ1Q4TixNQUFNNUMsS0FBS2pLLFNBQVMsQ0FBQ2pCLEVBQUUsR0FBR3dCLE9BQU85RSxJQUFJO1FBQ3JDLElBQUlvUixPQUFPaE8sS0FBS3BELElBQUksSUFBSW9SLE1BQU01QyxLQUFLbEssUUFBUSxDQUFDaEIsRUFBRSxDQUFDbEIsTUFBTSxJQUFJZ0IsS0FBS25ELEVBQUUsRUFDNUQ7SUFDUjtJQUNBLElBQUkwVSxNQUFNbkcsS0FBS2xLLFFBQVEsQ0FBQ2hCLEVBQUUsRUFBRStFLElBQUlzTSxJQUFJek4sTUFBTSxFQUFFME4sV0FBVztRQUFDdFI7S0FBRTtJQUMxRCxrRUFBa0U7SUFDbEUsbURBQW1EO0lBQ25ELFNBQVNyQyxNQUFNa0gsTUFBTSxFQUFFQyxJQUFJLEVBQUV4SCxJQUFJLEVBQUVpVSxXQUFXLEVBQUV6UyxNQUFNLEVBQUUwUyxRQUFRO1FBQzVELElBQUlDLFVBQVVySixLQUFLLENBQUNvSixTQUFTO1FBQzdCLElBQUl4USxXQUFXLEVBQUUsRUFBRUMsWUFBWSxFQUFFO1FBQ2pDbVEsU0FBU0MsS0FBS3hNLFFBQVE0TSxTQUFTelEsVUFBVUMsV0FBV3NRO1FBQ3BELElBQUk3VSxPQUFPcUksQ0FBQyxDQUFDME0sVUFBVSxFQUFFLEVBQUU5VSxLQUFLb0ksQ0FBQyxDQUFDME0sVUFBVSxFQUFFO1FBQzlDSCxTQUFTNVEsSUFBSSxDQUFDTSxTQUFTbEMsTUFBTTtRQUM3QixJQUFJMEksUUFBUWdLLFdBQ043VCxNQUFNOFQsVUFBVSxHQUFHMU0sQ0FBQyxDQUFDME0sVUFBVSxFQUFFLEVBQUVKLElBQUlwUCxHQUFHLENBQUM3QixLQUFLLENBQUMyRSxDQUFDLENBQUMwTSxRQUFRLENBQUMsRUFBRS9VLE1BQU1DLEtBQUtELE1BQU04VSxXQUFXLEtBQzFGMVIsS0FBS3VILE1BQU07UUFDakJyRyxTQUFTTixJQUFJLENBQUM4RztRQUNkdkcsVUFBVVAsSUFBSSxDQUFDaEUsT0FBTzZVO1FBQ3RCSCxTQUFTQyxLQUFLdE0sQ0FBQyxDQUFDME0sVUFBVSxFQUFFLEVBQUUzTSxNQUFNOUQsVUFBVUMsV0FBV3NRO1FBQ3pELE9BQU8sSUFBSXhRLEtBQUt6RCxNQUFNMEQsVUFBVUMsV0FBV25DO0lBQy9DO0lBQ0FvTSxLQUFLbEssUUFBUSxDQUFDaEIsRUFBRSxHQUFHckMsTUFBTSxHQUFHb0gsRUFBRWpHLE1BQU0sRUFBRXpCLFNBQVM2QyxJQUFJLEVBQUUsR0FBR21SLElBQUl2UyxNQUFNLEVBQUVzSixNQUFNdEosTUFBTSxHQUFHO0lBQ25GLDBDQUEwQztJQUMxQyxLQUFLLElBQUkrRSxTQUFTeU4sU0FBVTtRQUN4QixJQUFJcFQsT0FBT3NELE9BQU90RCxJQUFJLENBQUM4QyxRQUFRLENBQUM2QyxNQUFNLEVBQUVoQyxNQUFNTCxPQUFPdEQsSUFBSSxDQUFDK0MsU0FBUyxDQUFDNEMsTUFBTTtRQUMxRXJDLE9BQU9rSCxLQUFLLENBQUMsSUFBSXZHLFNBQVNqRSxNQUFNMkQsTUFBTUwsT0FBTzlFLElBQUksRUFBRW1ILE9BQU9yQyxPQUFPVSxLQUFLO0lBQzFFO0FBQ0o7QUFDQSxNQUFNd1A7SUFDRmpWLFlBQVkwTCxJQUFJLEVBQUVpRSxNQUFNLENBQUU7UUFDdEIsSUFBSSxDQUFDQSxNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDMkMsSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDdk4sTUFBTSxHQUFHMkcsS0FBSzNHLE1BQU0sQ0FBQ1YsU0FBUytCLGdCQUFnQixHQUFHL0IsU0FBU2tHLFlBQVk7SUFDL0U7SUFDQSx1RUFBdUU7SUFDdkVoRixPQUFPSCxHQUFHLEVBQUU7UUFDUixJQUFJLEVBQUVMLE1BQU0sRUFBRSxHQUFHLElBQUksRUFBRStGLElBQUkxRixNQUFNLElBQUksQ0FBQ3VLLE1BQU07UUFDNUMsTUFBTyxDQUFDLElBQUksQ0FBQzJDLElBQUksSUFBSXZOLE9BQU85RSxJQUFJLEdBQUc2SyxFQUFHO1lBQ2xDLElBQUkvRixPQUFPN0UsRUFBRSxJQUFJa0YsT0FBT0wsT0FBT2tCLEtBQUssQ0FBQzZFLEdBQUcsR0FBR3pHLFNBQVMwRSxjQUFjLEdBQUcxRSxTQUFTOEYsY0FBYztpQkFDdkYsSUFBSSxDQUFDcEYsT0FBT3lDLElBQUksQ0FBQyxRQUNsQixJQUFJLENBQUM4SyxJQUFJLEdBQUc7UUFDcEI7SUFDSjtJQUNBMkIsUUFBUWxQLE1BQU0sRUFBRTtRQUNaLElBQUksQ0FBQ1EsTUFBTSxDQUFDUixPQUFPOUUsSUFBSTtRQUN2QixJQUFJLENBQUMsSUFBSSxDQUFDcVMsSUFBSSxJQUFJLElBQUksQ0FBQ3ZOLE1BQU0sQ0FBQzlFLElBQUksR0FBRyxJQUFJLENBQUMwUCxNQUFNLElBQUk1SyxPQUFPOUUsSUFBSSxJQUFJLElBQUksQ0FBQzhFLE1BQU0sQ0FBQ3RELElBQUksRUFBRTtZQUNqRixJQUFLLElBQUlBLE9BQU8sSUFBSSxDQUFDc0QsTUFBTSxDQUFDdEQsSUFBSSxHQUFJO2dCQUNoQyxJQUFJQSxRQUFRc0QsT0FBT3RELElBQUksRUFDbkIsT0FBTztnQkFDWCxJQUFJQSxLQUFLOEMsUUFBUSxDQUFDbEMsTUFBTSxJQUFJWixLQUFLK0MsU0FBUyxDQUFDLEVBQUUsSUFBSSxLQUFLL0MsS0FBSzhDLFFBQVEsQ0FBQyxFQUFFLFlBQVlELE1BQzlFN0MsT0FBT0EsS0FBSzhDLFFBQVEsQ0FBQyxFQUFFO3FCQUV2QjtZQUNSO1FBQ0o7UUFDQSxPQUFPO0lBQ1g7QUFDSjtBQUNBLE1BQU1zUDtJQUNGN1QsWUFBWTRRLFNBQVMsQ0FBRTtRQUNuQixJQUFJOUg7UUFDSixJQUFJLENBQUM4SCxTQUFTLEdBQUdBO1FBQ2pCLElBQUksQ0FBQ3NFLEtBQUssR0FBRztRQUNiLElBQUksQ0FBQ0MsS0FBSyxHQUFHO1FBQ2IsSUFBSXZFLFVBQVV2TyxNQUFNLEVBQUU7WUFDbEIsSUFBSStTLFFBQVEsSUFBSSxDQUFDQyxPQUFPLEdBQUd6RSxTQUFTLENBQUMsRUFBRTtZQUN2QyxJQUFJLENBQUNzRSxLQUFLLEdBQUcsQ0FBQ3BNLEtBQUtzTSxNQUFNM1QsSUFBSSxDQUFDbUIsSUFBSSxDQUFDeVEsYUFBWSxNQUFPLFFBQVF2SyxPQUFPLEtBQUssSUFBSUEsS0FBS3NNLE1BQU1sVixFQUFFO1lBQzNGLElBQUksQ0FBQytJLEtBQUssR0FBRyxJQUFJZ00sZ0JBQWdCRyxNQUFNM1QsSUFBSSxFQUFFLENBQUMyVCxNQUFNekYsTUFBTTtRQUM5RCxPQUNLO1lBQ0QsSUFBSSxDQUFDMEYsT0FBTyxHQUFHLElBQUksQ0FBQ3BNLEtBQUssR0FBRztRQUNoQztJQUNKO0lBQ0FnTCxRQUFRNVEsSUFBSSxFQUFFO1FBQ1YsTUFBTyxJQUFJLENBQUNnUyxPQUFPLElBQUloUyxLQUFLcEQsSUFBSSxJQUFJLElBQUksQ0FBQ2lWLEtBQUssQ0FDMUMsSUFBSSxDQUFDSSxRQUFRO1FBQ2pCLE9BQU8sSUFBSSxDQUFDRCxPQUFPLElBQUksSUFBSSxDQUFDQSxPQUFPLENBQUNwVixJQUFJLElBQUlvRCxLQUFLcEQsSUFBSSxJQUFJLElBQUksQ0FBQ2lWLEtBQUssSUFBSTdSLEtBQUtuRCxFQUFFLElBQUksSUFBSSxDQUFDK0ksS0FBSyxDQUFDZ0wsT0FBTyxDQUFDNVE7SUFDekc7SUFDQWlTLFdBQVc7UUFDUCxJQUFJeE07UUFDSixJQUFJLENBQUNxTSxLQUFLO1FBQ1YsSUFBSSxJQUFJLENBQUNBLEtBQUssSUFBSSxJQUFJLENBQUN2RSxTQUFTLENBQUN2TyxNQUFNLEVBQUU7WUFDckMsSUFBSSxDQUFDZ1QsT0FBTyxHQUFHLElBQUksQ0FBQ3BNLEtBQUssR0FBRztRQUNoQyxPQUNLO1lBQ0QsSUFBSW1MLE9BQU8sSUFBSSxDQUFDaUIsT0FBTyxHQUFHLElBQUksQ0FBQ3pFLFNBQVMsQ0FBQyxJQUFJLENBQUN1RSxLQUFLLENBQUM7WUFDcEQsSUFBSSxDQUFDRCxLQUFLLEdBQUcsQ0FBQ3BNLEtBQUtzTCxLQUFLM1MsSUFBSSxDQUFDbUIsSUFBSSxDQUFDeVEsYUFBWSxNQUFPLFFBQVF2SyxPQUFPLEtBQUssSUFBSUEsS0FBS3NMLEtBQUtsVSxFQUFFO1lBQ3pGLElBQUksQ0FBQytJLEtBQUssR0FBRyxJQUFJZ00sZ0JBQWdCYixLQUFLM1MsSUFBSSxFQUFFLENBQUMyUyxLQUFLekUsTUFBTTtRQUM1RDtJQUNKO0lBQ0E2RSxXQUFXcFAsR0FBRyxFQUFFekQsTUFBTSxFQUFFO1FBQ3BCLElBQUltSDtRQUNKLElBQUloSSxTQUFTLEVBQUU7UUFDZixJQUFJLElBQUksQ0FBQ21JLEtBQUssRUFBRTtZQUNaLElBQUksQ0FBQ0EsS0FBSyxDQUFDbEUsTUFBTSxDQUFDUSxNQUFNLENBQUNILEtBQUs7WUFDOUIsSUFBSyxJQUFJQSxNQUFNLElBQUksQ0FBQzZELEtBQUssQ0FBQ2xFLE1BQU0sQ0FBQzFCLElBQUksRUFBRStCLEtBQUtBLE1BQU1BLElBQUlxQixNQUFNLENBQUU7Z0JBQzFELElBQUlnRixRQUFRLENBQUMzQyxLQUFLMUQsSUFBSTNELElBQUksTUFBTSxRQUFRcUgsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHbEcsSUFBSSxDQUFDekMsU0FBU29CLE9BQU87Z0JBQ3pGLElBQUlrSyxTQUFTQSxNQUFNOUosTUFBTSxJQUFJQSxRQUFRO29CQUNqQyxJQUFLLElBQUk0QixJQUFJLElBQUksQ0FBQzRSLEtBQUssRUFBRTVSLElBQUksSUFBSSxDQUFDcU4sU0FBUyxDQUFDdk8sTUFBTSxFQUFFa0IsSUFBSzt3QkFDckQsSUFBSTZRLE9BQU8sSUFBSSxDQUFDeEQsU0FBUyxDQUFDck4sRUFBRTt3QkFDNUIsSUFBSTZRLEtBQUtuVSxJQUFJLElBQUltRixJQUFJbEYsRUFBRSxFQUNuQjt3QkFDSixJQUFJa1UsS0FBSzNTLElBQUksSUFBSSxJQUFJLENBQUM0VCxPQUFPLENBQUM1VCxJQUFJLEVBQzlCWCxPQUFPbUQsSUFBSSxDQUFDOzRCQUNSbVE7NEJBQ0FoUCxLQUFLQSxJQUFJbkYsSUFBSSxHQUFHbVUsS0FBS3pFLE1BQU07NEJBQzNCbEU7d0JBQ0o7b0JBQ1I7Z0JBQ0o7WUFDSjtRQUNKO1FBQ0EsT0FBTzNLO0lBQ1g7QUFDSjtBQUNBLFNBQVMyVCxZQUFZYyxLQUFLLEVBQUVyRCxNQUFNO0lBQzlCLElBQUkzSixPQUFPLE1BQU1pTixVQUFVdEQ7SUFDM0IsSUFBSyxJQUFJM08sSUFBSSxHQUFHbUYsSUFBSSxHQUFHbkYsSUFBSWdTLE1BQU1sVCxNQUFNLEVBQUVrQixJQUFLO1FBQzFDLElBQUlrUyxVQUFVRixLQUFLLENBQUNoUyxJQUFJLEVBQUUsQ0FBQ3JELEVBQUUsRUFBRXdWLFFBQVFILEtBQUssQ0FBQ2hTLEVBQUUsQ0FBQ3RELElBQUk7UUFDcEQsTUFBT3lJLElBQUk4TSxRQUFRblQsTUFBTSxFQUFFcUcsSUFBSztZQUM1QixJQUFJWSxJQUFJa00sT0FBTyxDQUFDOU0sRUFBRTtZQUNsQixJQUFJWSxFQUFFckosSUFBSSxJQUFJeVYsT0FDVjtZQUNKLElBQUlwTSxFQUFFcEosRUFBRSxJQUFJdVYsU0FDUjtZQUNKLElBQUksQ0FBQ2xOLE1BQ0RpTixVQUFVak4sT0FBTzJKLE9BQU8vSixLQUFLO1lBQ2pDLElBQUltQixFQUFFckosSUFBSSxHQUFHd1YsU0FBUztnQkFDbEJsTixJQUFJLENBQUNHLEVBQUUsR0FBRyxJQUFJM0ksTUFBTXVKLEVBQUVySixJQUFJLEVBQUV3VjtnQkFDNUIsSUFBSW5NLEVBQUVwSixFQUFFLEdBQUd3VixPQUNQbk4sS0FBSytDLE1BQU0sQ0FBQzVDLElBQUksR0FBRyxHQUFHLElBQUkzSSxNQUFNMlYsT0FBT3BNLEVBQUVwSixFQUFFO1lBQ25ELE9BQ0ssSUFBSW9KLEVBQUVwSixFQUFFLEdBQUd3VixPQUFPO2dCQUNuQm5OLElBQUksQ0FBQ0csSUFBSSxHQUFHLElBQUkzSSxNQUFNMlYsT0FBT3BNLEVBQUVwSixFQUFFO1lBQ3JDLE9BQ0s7Z0JBQ0RxSSxLQUFLK0MsTUFBTSxDQUFDNUMsS0FBSztZQUNyQjtRQUNKO0lBQ0o7SUFDQSxPQUFPOE07QUFDWDtBQUNBLFNBQVNHLGlCQUFpQkMsQ0FBQyxFQUFFdE4sQ0FBQyxFQUFFckksSUFBSSxFQUFFQyxFQUFFO0lBQ3BDLElBQUkyVixLQUFLLEdBQUdDLEtBQUssR0FBR0MsTUFBTSxPQUFPQyxNQUFNLE9BQU81USxNQUFNLENBQUM7SUFDckQsSUFBSXRFLFNBQVMsRUFBRTtJQUNmLE9BQVM7UUFDTCxJQUFJbVYsUUFBUUosTUFBTUQsRUFBRXZULE1BQU0sR0FBRyxNQUFNMFQsTUFBTUgsQ0FBQyxDQUFDQyxHQUFHLENBQUMzVixFQUFFLEdBQUcwVixDQUFDLENBQUNDLEdBQUcsQ0FBQzVWLElBQUk7UUFDOUQsSUFBSWlXLFFBQVFKLE1BQU14TixFQUFFakcsTUFBTSxHQUFHLE1BQU0yVCxNQUFNMU4sQ0FBQyxDQUFDd04sR0FBRyxDQUFDNVYsRUFBRSxHQUFHb0ksQ0FBQyxDQUFDd04sR0FBRyxDQUFDN1YsSUFBSTtRQUM5RCxJQUFJOFYsT0FBT0MsS0FBSztZQUNaLElBQUkzTyxRQUFRc0IsS0FBS0MsR0FBRyxDQUFDeEQsS0FBS25GLE9BQU9xSCxNQUFNcUIsS0FBS2lKLEdBQUcsQ0FBQ3FFLE9BQU9DLE9BQU9oVztZQUM5RCxJQUFJbUgsUUFBUUMsS0FDUnhHLE9BQU9tRCxJQUFJLENBQUMsSUFBSWxFLE1BQU1zSCxPQUFPQztRQUNyQztRQUNBbEMsTUFBTXVELEtBQUtpSixHQUFHLENBQUNxRSxPQUFPQztRQUN0QixJQUFJOVEsT0FBTyxLQUNQO1FBQ0osSUFBSTZRLFNBQVM3USxLQUFLO1lBQ2QsSUFBSSxDQUFDMlEsS0FDREEsTUFBTTtpQkFDTDtnQkFDREEsTUFBTTtnQkFDTkY7WUFDSjtRQUNKO1FBQ0EsSUFBSUssU0FBUzlRLEtBQUs7WUFDZCxJQUFJLENBQUM0USxLQUNEQSxNQUFNO2lCQUNMO2dCQUNEQSxNQUFNO2dCQUNORjtZQUNKO1FBQ0o7SUFDSjtJQUNBLE9BQU9oVjtBQUNYO0FBQ0Esc0VBQXNFO0FBQ3RFLGdFQUFnRTtBQUNoRSxrQkFBa0I7QUFDbEIsU0FBUzRULGVBQWV0QixNQUFNLEVBQUVsQixNQUFNO0lBQ2xDLElBQUlwUixTQUFTLEVBQUU7SUFDZixLQUFLLElBQUksRUFBRXNFLEdBQUcsRUFBRXFHLEtBQUssRUFBRTJJLElBQUksRUFBRSxJQUFJaEIsT0FBUTtRQUNyQyxJQUFJL0YsV0FBV2pJLE1BQU9xRyxDQUFBQSxNQUFNL0osT0FBTyxHQUFHK0osTUFBTS9KLE9BQU8sQ0FBQyxFQUFFLENBQUN6QixJQUFJLEdBQUcsSUFBSXVOLFNBQVNILFdBQVc1QixNQUFNaEssSUFBSSxDQUFDWSxNQUFNO1FBQ3ZHLElBQUlwQyxPQUFPMEksS0FBS0MsR0FBRyxDQUFDd0wsS0FBS25VLElBQUksRUFBRW9OLFdBQVduTixLQUFLeUksS0FBS2lKLEdBQUcsQ0FBQ3dDLEtBQUtsVSxFQUFFLEVBQUVzTjtRQUNqRSxJQUFJL0IsTUFBTS9KLE9BQU8sRUFBRTtZQUNmLElBQUlBLFVBQVUrSixNQUFNL0osT0FBTyxDQUFDeUIsR0FBRyxDQUFDbUcsQ0FBQUEsSUFBSyxJQUFJdkosTUFBTXVKLEVBQUVySixJQUFJLEdBQUdtRixLQUFLa0UsRUFBRXBKLEVBQUUsR0FBR2tGO1lBQ3BFLElBQUk0TCxVQUFVMkUsaUJBQWlCekQsUUFBUXhRLFNBQVN6QixNQUFNQztZQUN0RCxJQUFLLElBQUlxRCxJQUFJLEdBQUc2QixNQUFNbkYsT0FBT3NELElBQUs7Z0JBQzlCLElBQUlzRyxPQUFPdEcsS0FBS3lOLFFBQVEzTyxNQUFNLEVBQUVpRixNQUFNdUMsT0FBTzNKLEtBQUs4USxPQUFPLENBQUN6TixFQUFFLENBQUN0RCxJQUFJO2dCQUNqRSxJQUFJcUgsTUFBTWxDLEtBQ050RSxPQUFPbUQsSUFBSSxDQUFDLElBQUlzTSxhQUFhbkwsS0FBS2tDLEtBQUttRSxNQUFNaEssSUFBSSxFQUFFLENBQUM0TCxVQUFVK0csS0FBS25VLElBQUksSUFBSW1GLE9BQU9nUCxLQUFLNUQsU0FBUyxFQUFFNEQsS0FBS2xVLEVBQUUsSUFBSW9ILE9BQU84TSxLQUFLM0QsT0FBTztnQkFDcEksSUFBSTVHLE1BQ0E7Z0JBQ0p6RSxNQUFNNEwsT0FBTyxDQUFDek4sRUFBRSxDQUFDckQsRUFBRTtZQUN2QjtRQUNKLE9BQ0s7WUFDRFksT0FBT21ELElBQUksQ0FBQyxJQUFJc00sYUFBYXRRLE1BQU1DLElBQUl1TCxNQUFNaEssSUFBSSxFQUFFLENBQUM0TCxVQUFVK0csS0FBS25VLElBQUksSUFBSW9OLFlBQVkrRyxLQUFLNUQsU0FBUyxFQUFFNEQsS0FBS2xVLEVBQUUsSUFBSXNOLFVBQVU0RyxLQUFLM0QsT0FBTztRQUM1STtJQUNKO0lBQ0EsT0FBTzNQO0FBQ1g7QUFFZ0siLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9weXRob24tb25saW5lLWVkaXRvci8uL25vZGVfbW9kdWxlcy9AbGV6ZXIvY29tbW9uL2Rpc3QvaW5kZXguanM/YzE5MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcblRoZSBkZWZhdWx0IG1heGltdW0gbGVuZ3RoIG9mIGEgYFRyZWVCdWZmZXJgIG5vZGUuXG4qL1xuY29uc3QgRGVmYXVsdEJ1ZmZlckxlbmd0aCA9IDEwMjQ7XG5sZXQgbmV4dFByb3BJRCA9IDA7XG5jbGFzcyBSYW5nZSB7XG4gICAgY29uc3RydWN0b3IoZnJvbSwgdG8pIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgIH1cbn1cbi8qKlxuRWFjaCBbbm9kZSB0eXBlXSgjY29tbW9uLk5vZGVUeXBlKSBvciBbaW5kaXZpZHVhbCB0cmVlXSgjY29tbW9uLlRyZWUpXG5jYW4gaGF2ZSBtZXRhZGF0YSBhc3NvY2lhdGVkIHdpdGggaXQgaW4gcHJvcHMuIEluc3RhbmNlcyBvZiB0aGlzXG5jbGFzcyByZXByZXNlbnQgcHJvcCBuYW1lcy5cbiovXG5jbGFzcyBOb2RlUHJvcCB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbmV3IG5vZGUgcHJvcCB0eXBlLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnID0ge30pIHtcbiAgICAgICAgdGhpcy5pZCA9IG5leHRQcm9wSUQrKztcbiAgICAgICAgdGhpcy5wZXJOb2RlID0gISFjb25maWcucGVyTm9kZTtcbiAgICAgICAgdGhpcy5kZXNlcmlhbGl6ZSA9IGNvbmZpZy5kZXNlcmlhbGl6ZSB8fCAoKCkgPT4ge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBub2RlIHR5cGUgZG9lc24ndCBkZWZpbmUgYSBkZXNlcmlhbGl6ZSBmdW5jdGlvblwiKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoaXMgaXMgbWVhbnQgdG8gYmUgdXNlZCB3aXRoXG4gICAgW2BOb2RlU2V0LmV4dGVuZGBdKCNjb21tb24uTm9kZVNldC5leHRlbmQpIG9yXG4gICAgW2BMUlBhcnNlci5jb25maWd1cmVgXSgjbHIuUGFyc2VyQ29uZmlnLnByb3BzKSB0byBjb21wdXRlXG4gICAgcHJvcCB2YWx1ZXMgZm9yIGVhY2ggbm9kZSB0eXBlIGluIHRoZSBzZXQuIFRha2VzIGEgW21hdGNoXG4gICAgb2JqZWN0XSgjY29tbW9uLk5vZGVUeXBlXm1hdGNoKSBvciBmdW5jdGlvbiB0aGF0IHJldHVybnMgdW5kZWZpbmVkXG4gICAgaWYgdGhlIG5vZGUgdHlwZSBkb2Vzbid0IGdldCB0aGlzIHByb3AsIGFuZCB0aGUgcHJvcCdzIHZhbHVlIGlmXG4gICAgaXQgZG9lcy5cbiAgICAqL1xuICAgIGFkZChtYXRjaCkge1xuICAgICAgICBpZiAodGhpcy5wZXJOb2RlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJDYW4ndCBhZGQgcGVyLW5vZGUgcHJvcHMgdG8gbm9kZSB0eXBlc1wiKTtcbiAgICAgICAgaWYgKHR5cGVvZiBtYXRjaCAhPSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgICBtYXRjaCA9IE5vZGVUeXBlLm1hdGNoKG1hdGNoKTtcbiAgICAgICAgcmV0dXJuICh0eXBlKSA9PiB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gbWF0Y2godHlwZSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBudWxsIDogW3RoaXMsIHJlc3VsdF07XG4gICAgICAgIH07XG4gICAgfVxufVxuLyoqXG5Qcm9wIHRoYXQgaXMgdXNlZCB0byBkZXNjcmliZSBtYXRjaGluZyBkZWxpbWl0ZXJzLiBGb3Igb3BlbmluZ1xuZGVsaW1pdGVycywgdGhpcyBob2xkcyBhbiBhcnJheSBvZiBub2RlIG5hbWVzICh3cml0dGVuIGFzIGFcbnNwYWNlLXNlcGFyYXRlZCBzdHJpbmcgd2hlbiBkZWNsYXJpbmcgdGhpcyBwcm9wIGluIGEgZ3JhbW1hcilcbmZvciB0aGUgbm9kZSB0eXBlcyBvZiBjbG9zaW5nIGRlbGltaXRlcnMgdGhhdCBtYXRjaCBpdC5cbiovXG5Ob2RlUHJvcC5jbG9zZWRCeSA9IG5ldyBOb2RlUHJvcCh7IGRlc2VyaWFsaXplOiBzdHIgPT4gc3RyLnNwbGl0KFwiIFwiKSB9KTtcbi8qKlxuVGhlIGludmVyc2Ugb2YgW2BjbG9zZWRCeWBdKCNjb21tb24uTm9kZVByb3BeY2xvc2VkQnkpLiBUaGlzIGlzXG5hdHRhY2hlZCB0byBjbG9zaW5nIGRlbGltaXRlcnMsIGhvbGRpbmcgYW4gYXJyYXkgb2Ygbm9kZSBuYW1lc1xub2YgdHlwZXMgb2YgbWF0Y2hpbmcgb3BlbmluZyBkZWxpbWl0ZXJzLlxuKi9cbk5vZGVQcm9wLm9wZW5lZEJ5ID0gbmV3IE5vZGVQcm9wKHsgZGVzZXJpYWxpemU6IHN0ciA9PiBzdHIuc3BsaXQoXCIgXCIpIH0pO1xuLyoqXG5Vc2VkIHRvIGFzc2lnbiBub2RlIHR5cGVzIHRvIGdyb3VwcyAoZm9yIGV4YW1wbGUsIGFsbCBub2RlXG50eXBlcyB0aGF0IHJlcHJlc2VudCBhbiBleHByZXNzaW9uIGNvdWxkIGJlIHRhZ2dlZCB3aXRoIGFuXG5gXCJFeHByZXNzaW9uXCJgIGdyb3VwKS5cbiovXG5Ob2RlUHJvcC5ncm91cCA9IG5ldyBOb2RlUHJvcCh7IGRlc2VyaWFsaXplOiBzdHIgPT4gc3RyLnNwbGl0KFwiIFwiKSB9KTtcbi8qKlxuVGhlIGhhc2ggb2YgdGhlIFtjb250ZXh0XSgjbHIuQ29udGV4dFRyYWNrZXIuY29uc3RydWN0b3IpXG50aGF0IHRoZSBub2RlIHdhcyBwYXJzZWQgaW4sIGlmIGFueS4gVXNlZCB0byBsaW1pdCByZXVzZSBvZlxuY29udGV4dHVhbCBub2Rlcy5cbiovXG5Ob2RlUHJvcC5jb250ZXh0SGFzaCA9IG5ldyBOb2RlUHJvcCh7IHBlck5vZGU6IHRydWUgfSk7XG4vKipcblRoZSBkaXN0YW5jZSBiZXlvbmQgdGhlIGVuZCBvZiB0aGUgbm9kZSB0aGF0IHRoZSB0b2tlbml6ZXJcbmxvb2tlZCBhaGVhZCBmb3IgYW55IG9mIHRoZSB0b2tlbnMgaW5zaWRlIHRoZSBub2RlLiAoVGhlIExSXG5wYXJzZXIgb25seSBzdG9yZXMgdGhpcyB3aGVuIGl0IGlzIGxhcmdlciB0aGFuIDI1LCBmb3JcbmVmZmljaWVuY3kgcmVhc29ucy4pXG4qL1xuTm9kZVByb3AubG9va0FoZWFkID0gbmV3IE5vZGVQcm9wKHsgcGVyTm9kZTogdHJ1ZSB9KTtcbi8qKlxuVGhpcyBwZXItbm9kZSBwcm9wIGlzIHVzZWQgdG8gcmVwbGFjZSBhIGdpdmVuIG5vZGUsIG9yIHBhcnQgb2YgYVxubm9kZSwgd2l0aCBhbm90aGVyIHRyZWUuIFRoaXMgaXMgdXNlZnVsIHRvIGluY2x1ZGUgdHJlZXMgZnJvbVxuZGlmZmVyZW50IGxhbmd1YWdlcyBpbiBtaXhlZC1sYW5ndWFnZSBwYXJzZXJzLlxuKi9cbk5vZGVQcm9wLm1vdW50ZWQgPSBuZXcgTm9kZVByb3AoeyBwZXJOb2RlOiB0cnVlIH0pO1xuLyoqXG5BIG1vdW50ZWQgdHJlZSwgd2hpY2ggY2FuIGJlIFtzdG9yZWRdKCNjb21tb24uTm9kZVByb3BebW91bnRlZCkgb25cbmEgdHJlZSBub2RlIHRvIGluZGljYXRlIHRoYXQgcGFydHMgb2YgaXRzIGNvbnRlbnQgYXJlXG5yZXByZXNlbnRlZCBieSBhbm90aGVyIHRyZWUuXG4qL1xuY2xhc3MgTW91bnRlZFRyZWUge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBpbm5lciB0cmVlLlxuICAgICovXG4gICAgdHJlZSwgXG4gICAgLyoqXG4gICAgSWYgdGhpcyBpcyBudWxsLCB0aGlzIHRyZWUgcmVwbGFjZXMgdGhlIGVudGlyZSBub2RlIChpdCB3aWxsXG4gICAgYmUgaW5jbHVkZWQgaW4gdGhlIHJlZ3VsYXIgaXRlcmF0aW9uIGluc3RlYWQgb2YgaXRzIGhvc3RcbiAgICBub2RlKS4gSWYgbm90LCBvbmx5IHRoZSBnaXZlbiByYW5nZXMgYXJlIGNvbnNpZGVyZWQgdG8gYmVcbiAgICBjb3ZlcmVkIGJ5IHRoaXMgdHJlZS4gVGhpcyBpcyB1c2VkIGZvciB0cmVlcyB0aGF0IGFyZSBtaXhlZCBpblxuICAgIGEgd2F5IHRoYXQgaXNuJ3Qgc3RyaWN0bHkgaGllcmFyY2hpY2FsLiBTdWNoIG1vdW50ZWQgdHJlZXMgYXJlXG4gICAgb25seSBlbnRlcmVkIGJ5IFtgcmVzb2x2ZUlubmVyYF0oI2NvbW1vbi5UcmVlLnJlc29sdmVJbm5lcilcbiAgICBhbmQgW2BlbnRlcmBdKCNjb21tb24uU3ludGF4Tm9kZS5lbnRlcikuXG4gICAgKi9cbiAgICBvdmVybGF5LCBcbiAgICAvKipcbiAgICBUaGUgcGFyc2VyIHVzZWQgdG8gY3JlYXRlIHRoaXMgc3VidHJlZS5cbiAgICAqL1xuICAgIHBhcnNlcikge1xuICAgICAgICB0aGlzLnRyZWUgPSB0cmVlO1xuICAgICAgICB0aGlzLm92ZXJsYXkgPSBvdmVybGF5O1xuICAgICAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgZ2V0KHRyZWUpIHtcbiAgICAgICAgcmV0dXJuIHRyZWUgJiYgdHJlZS5wcm9wcyAmJiB0cmVlLnByb3BzW05vZGVQcm9wLm1vdW50ZWQuaWRdO1xuICAgIH1cbn1cbmNvbnN0IG5vUHJvcHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuLyoqXG5FYWNoIG5vZGUgaW4gYSBzeW50YXggdHJlZSBoYXMgYSBub2RlIHR5cGUgYXNzb2NpYXRlZCB3aXRoIGl0LlxuKi9cbmNsYXNzIE5vZGVUeXBlIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBuYW1lIG9mIHRoZSBub2RlIHR5cGUuIE5vdCBuZWNlc3NhcmlseSB1bmlxdWUsIGJ1dCBpZiB0aGVcbiAgICBncmFtbWFyIHdhcyB3cml0dGVuIHByb3Blcmx5LCBkaWZmZXJlbnQgbm9kZSB0eXBlcyB3aXRoIHRoZVxuICAgIHNhbWUgbmFtZSB3aXRoaW4gYSBub2RlIHNldCBzaG91bGQgcGxheSB0aGUgc2FtZSBzZW1hbnRpY1xuICAgIHJvbGUuXG4gICAgKi9cbiAgICBuYW1lLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHByb3BzLCBcbiAgICAvKipcbiAgICBUaGUgaWQgb2YgdGhpcyBub2RlIGluIGl0cyBzZXQuIENvcnJlc3BvbmRzIHRvIHRoZSB0ZXJtIGlkc1xuICAgIHVzZWQgaW4gdGhlIHBhcnNlci5cbiAgICAqL1xuICAgIGlkLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGZsYWdzID0gMCkge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5mbGFncyA9IGZsYWdzO1xuICAgIH1cbiAgICAvKipcbiAgICBEZWZpbmUgYSBub2RlIHR5cGUuXG4gICAgKi9cbiAgICBzdGF0aWMgZGVmaW5lKHNwZWMpIHtcbiAgICAgICAgbGV0IHByb3BzID0gc3BlYy5wcm9wcyAmJiBzcGVjLnByb3BzLmxlbmd0aCA/IE9iamVjdC5jcmVhdGUobnVsbCkgOiBub1Byb3BzO1xuICAgICAgICBsZXQgZmxhZ3MgPSAoc3BlYy50b3AgPyAxIC8qIE5vZGVGbGFnLlRvcCAqLyA6IDApIHwgKHNwZWMuc2tpcHBlZCA/IDIgLyogTm9kZUZsYWcuU2tpcHBlZCAqLyA6IDApIHxcbiAgICAgICAgICAgIChzcGVjLmVycm9yID8gNCAvKiBOb2RlRmxhZy5FcnJvciAqLyA6IDApIHwgKHNwZWMubmFtZSA9PSBudWxsID8gOCAvKiBOb2RlRmxhZy5Bbm9ueW1vdXMgKi8gOiAwKTtcbiAgICAgICAgbGV0IHR5cGUgPSBuZXcgTm9kZVR5cGUoc3BlYy5uYW1lIHx8IFwiXCIsIHByb3BzLCBzcGVjLmlkLCBmbGFncyk7XG4gICAgICAgIGlmIChzcGVjLnByb3BzKVxuICAgICAgICAgICAgZm9yIChsZXQgc3JjIG9mIHNwZWMucHJvcHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc3JjKSlcbiAgICAgICAgICAgICAgICAgICAgc3JjID0gc3JjKHR5cGUpO1xuICAgICAgICAgICAgICAgIGlmIChzcmMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNyY1swXS5wZXJOb2RlKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJDYW4ndCBzdG9yZSBhIHBlci1ub2RlIHByb3Agb24gYSBub2RlIHR5cGVcIik7XG4gICAgICAgICAgICAgICAgICAgIHByb3BzW3NyY1swXS5pZF0gPSBzcmNbMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0cmlldmVzIGEgbm9kZSBwcm9wIGZvciB0aGlzIHR5cGUuIFdpbGwgcmV0dXJuIGB1bmRlZmluZWRgIGlmXG4gICAgdGhlIHByb3AgaXNuJ3QgcHJlc2VudCBvbiB0aGlzIG5vZGUuXG4gICAgKi9cbiAgICBwcm9wKHByb3ApIHsgcmV0dXJuIHRoaXMucHJvcHNbcHJvcC5pZF07IH1cbiAgICAvKipcbiAgICBUcnVlIHdoZW4gdGhpcyBpcyB0aGUgdG9wIG5vZGUgb2YgYSBncmFtbWFyLlxuICAgICovXG4gICAgZ2V0IGlzVG9wKCkgeyByZXR1cm4gKHRoaXMuZmxhZ3MgJiAxIC8qIE5vZGVGbGFnLlRvcCAqLykgPiAwOyB9XG4gICAgLyoqXG4gICAgVHJ1ZSB3aGVuIHRoaXMgbm9kZSBpcyBwcm9kdWNlZCBieSBhIHNraXAgcnVsZS5cbiAgICAqL1xuICAgIGdldCBpc1NraXBwZWQoKSB7IHJldHVybiAodGhpcy5mbGFncyAmIDIgLyogTm9kZUZsYWcuU2tpcHBlZCAqLykgPiAwOyB9XG4gICAgLyoqXG4gICAgSW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBpcyBhbiBlcnJvciBub2RlLlxuICAgICovXG4gICAgZ2V0IGlzRXJyb3IoKSB7IHJldHVybiAodGhpcy5mbGFncyAmIDQgLyogTm9kZUZsYWcuRXJyb3IgKi8pID4gMDsgfVxuICAgIC8qKlxuICAgIFdoZW4gdHJ1ZSwgdGhpcyBub2RlIHR5cGUgZG9lc24ndCBjb3JyZXNwb25kIHRvIGEgdXNlci1kZWNsYXJlZFxuICAgIG5hbWVkIG5vZGUsIGZvciBleGFtcGxlIGJlY2F1c2UgaXQgaXMgdXNlZCB0byBjYWNoZSByZXBldGl0aW9uLlxuICAgICovXG4gICAgZ2V0IGlzQW5vbnltb3VzKCkgeyByZXR1cm4gKHRoaXMuZmxhZ3MgJiA4IC8qIE5vZGVGbGFnLkFub255bW91cyAqLykgPiAwOyB9XG4gICAgLyoqXG4gICAgUmV0dXJucyB0cnVlIHdoZW4gdGhpcyBub2RlJ3MgbmFtZSBvciBvbmUgb2YgaXRzXG4gICAgW2dyb3Vwc10oI2NvbW1vbi5Ob2RlUHJvcF5ncm91cCkgbWF0Y2hlcyB0aGUgZ2l2ZW4gc3RyaW5nLlxuICAgICovXG4gICAgaXMobmFtZSkge1xuICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm5hbWUgPT0gbmFtZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGxldCBncm91cCA9IHRoaXMucHJvcChOb2RlUHJvcC5ncm91cCk7XG4gICAgICAgICAgICByZXR1cm4gZ3JvdXAgPyBncm91cC5pbmRleE9mKG5hbWUpID4gLTEgOiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5pZCA9PSBuYW1lO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBmdW5jdGlvbiBmcm9tIG5vZGUgdHlwZXMgdG8gYXJiaXRyYXJ5IHZhbHVlcyBieVxuICAgIHNwZWNpZnlpbmcgYW4gb2JqZWN0IHdob3NlIHByb3BlcnR5IG5hbWVzIGFyZSBub2RlIG9yXG4gICAgW2dyb3VwXSgjY29tbW9uLk5vZGVQcm9wXmdyb3VwKSBuYW1lcy4gT2Z0ZW4gdXNlZnVsIHdpdGhcbiAgICBbYE5vZGVQcm9wLmFkZGBdKCNjb21tb24uTm9kZVByb3AuYWRkKS4gWW91IGNhbiBwdXQgbXVsdGlwbGVcbiAgICBuYW1lcywgc2VwYXJhdGVkIGJ5IHNwYWNlcywgaW4gYSBzaW5nbGUgcHJvcGVydHkgbmFtZSB0byBtYXBcbiAgICBtdWx0aXBsZSBub2RlIG5hbWVzIHRvIGEgc2luZ2xlIHZhbHVlLlxuICAgICovXG4gICAgc3RhdGljIG1hdGNoKG1hcCkge1xuICAgICAgICBsZXQgZGlyZWN0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZm9yIChsZXQgcHJvcCBpbiBtYXApXG4gICAgICAgICAgICBmb3IgKGxldCBuYW1lIG9mIHByb3Auc3BsaXQoXCIgXCIpKVxuICAgICAgICAgICAgICAgIGRpcmVjdFtuYW1lXSA9IG1hcFtwcm9wXTtcbiAgICAgICAgcmV0dXJuIChub2RlKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGxldCBncm91cHMgPSBub2RlLnByb3AoTm9kZVByb3AuZ3JvdXApLCBpID0gLTE7IGkgPCAoZ3JvdXBzID8gZ3JvdXBzLmxlbmd0aCA6IDApOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgZm91bmQgPSBkaXJlY3RbaSA8IDAgPyBub2RlLm5hbWUgOiBncm91cHNbaV1dO1xuICAgICAgICAgICAgICAgIGlmIChmb3VuZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbn1cbi8qKlxuQW4gZW1wdHkgZHVtbXkgbm9kZSB0eXBlIHRvIHVzZSB3aGVuIG5vIGFjdHVhbCB0eXBlIGlzIGF2YWlsYWJsZS5cbiovXG5Ob2RlVHlwZS5ub25lID0gbmV3IE5vZGVUeXBlKFwiXCIsIE9iamVjdC5jcmVhdGUobnVsbCksIDAsIDggLyogTm9kZUZsYWcuQW5vbnltb3VzICovKTtcbi8qKlxuQSBub2RlIHNldCBob2xkcyBhIGNvbGxlY3Rpb24gb2Ygbm9kZSB0eXBlcy4gSXQgaXMgdXNlZCB0b1xuY29tcGFjdGx5IHJlcHJlc2VudCB0cmVlcyBieSBzdG9yaW5nIHRoZWlyIHR5cGUgaWRzLCByYXRoZXIgdGhhbiBhXG5mdWxsIHBvaW50ZXIgdG8gdGhlIHR5cGUgb2JqZWN0LCBpbiBhIG51bWVyaWMgYXJyYXkuIEVhY2ggcGFyc2VyXG5baGFzXSgjbHIuTFJQYXJzZXIubm9kZVNldCkgYSBub2RlIHNldCwgYW5kIFt0cmVlXG5idWZmZXJzXSgjY29tbW9uLlRyZWVCdWZmZXIpIGNhbiBvbmx5IHN0b3JlIGNvbGxlY3Rpb25zIG9mIG5vZGVzXG5mcm9tIHRoZSBzYW1lIHNldC4gQSBzZXQgY2FuIGhhdmUgYSBtYXhpbXVtIG9mIDIqKjE2ICg2NTUzNikgbm9kZVxudHlwZXMgaW4gaXQsIHNvIHRoYXQgdGhlIGlkcyBmaXQgaW50byAxNi1iaXQgdHlwZWQgYXJyYXkgc2xvdHMuXG4qL1xuY2xhc3MgTm9kZVNldCB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgc2V0IHdpdGggdGhlIGdpdmVuIHR5cGVzLiBUaGUgYGlkYCBwcm9wZXJ0eSBvZiBlYWNoXG4gICAgdHlwZSBzaG91bGQgY29ycmVzcG9uZCB0byBpdHMgcG9zaXRpb24gd2l0aGluIHRoZSBhcnJheS5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBub2RlIHR5cGVzIGluIHRoaXMgc2V0LCBieSBpZC5cbiAgICAqL1xuICAgIHR5cGVzKSB7XG4gICAgICAgIHRoaXMudHlwZXMgPSB0eXBlcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmICh0eXBlc1tpXS5pZCAhPSBpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTm9kZSB0eXBlIGlkcyBzaG91bGQgY29ycmVzcG9uZCB0byBhcnJheSBwb3NpdGlvbnMgd2hlbiBjcmVhdGluZyBhIG5vZGUgc2V0XCIpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBjb3B5IG9mIHRoaXMgc2V0IHdpdGggc29tZSBub2RlIHByb3BlcnRpZXMgYWRkZWQuIFRoZVxuICAgIGFyZ3VtZW50cyB0byB0aGlzIG1ldGhvZCBjYW4gYmUgY3JlYXRlZCB3aXRoXG4gICAgW2BOb2RlUHJvcC5hZGRgXSgjY29tbW9uLk5vZGVQcm9wLmFkZCkuXG4gICAgKi9cbiAgICBleHRlbmQoLi4ucHJvcHMpIHtcbiAgICAgICAgbGV0IG5ld1R5cGVzID0gW107XG4gICAgICAgIGZvciAobGV0IHR5cGUgb2YgdGhpcy50eXBlcykge1xuICAgICAgICAgICAgbGV0IG5ld1Byb3BzID0gbnVsbDtcbiAgICAgICAgICAgIGZvciAobGV0IHNvdXJjZSBvZiBwcm9wcykge1xuICAgICAgICAgICAgICAgIGxldCBhZGQgPSBzb3VyY2UodHlwZSk7XG4gICAgICAgICAgICAgICAgaWYgKGFkZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5ld1Byb3BzKVxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3UHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCB0eXBlLnByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgbmV3UHJvcHNbYWRkWzBdLmlkXSA9IGFkZFsxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdUeXBlcy5wdXNoKG5ld1Byb3BzID8gbmV3IE5vZGVUeXBlKHR5cGUubmFtZSwgbmV3UHJvcHMsIHR5cGUuaWQsIHR5cGUuZmxhZ3MpIDogdHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlU2V0KG5ld1R5cGVzKTtcbiAgICB9XG59XG5jb25zdCBDYWNoZWROb2RlID0gbmV3IFdlYWtNYXAoKSwgQ2FjaGVkSW5uZXJOb2RlID0gbmV3IFdlYWtNYXAoKTtcbi8qKlxuT3B0aW9ucyB0aGF0IGNvbnRyb2wgaXRlcmF0aW9uLiBDYW4gYmUgY29tYmluZWQgd2l0aCB0aGUgYHxgXG5vcGVyYXRvciB0byBlbmFibGUgbXVsdGlwbGUgb25lcy5cbiovXG52YXIgSXRlck1vZGU7XG4oZnVuY3Rpb24gKEl0ZXJNb2RlKSB7XG4gICAgLyoqXG4gICAgV2hlbiBlbmFibGVkLCBpdGVyYXRpb24gd2lsbCBvbmx5IHZpc2l0IFtgVHJlZWBdKCNjb21tb24uVHJlZSlcbiAgICBvYmplY3RzLCBub3Qgbm9kZXMgcGFja2VkIGludG9cbiAgICBbYFRyZWVCdWZmZXJgXSgjY29tbW9uLlRyZWVCdWZmZXIpcy5cbiAgICAqL1xuICAgIEl0ZXJNb2RlW0l0ZXJNb2RlW1wiRXhjbHVkZUJ1ZmZlcnNcIl0gPSAxXSA9IFwiRXhjbHVkZUJ1ZmZlcnNcIjtcbiAgICAvKipcbiAgICBFbmFibGUgdGhpcyB0byBtYWtlIGl0ZXJhdGlvbiBpbmNsdWRlIGFub255bW91cyBub2RlcyAoc3VjaCBhc1xuICAgIHRoZSBub2RlcyB0aGF0IHdyYXAgcmVwZWF0ZWQgZ3JhbW1hciBjb25zdHJ1Y3RzIGludG8gYSBiYWxhbmNlZFxuICAgIHRyZWUpLlxuICAgICovXG4gICAgSXRlck1vZGVbSXRlck1vZGVbXCJJbmNsdWRlQW5vbnltb3VzXCJdID0gMl0gPSBcIkluY2x1ZGVBbm9ueW1vdXNcIjtcbiAgICAvKipcbiAgICBCeSBkZWZhdWx0LCByZWd1bGFyIFttb3VudGVkXSgjY29tbW9uLk5vZGVQcm9wXm1vdW50ZWQpIG5vZGVzXG4gICAgcmVwbGFjZSB0aGVpciBiYXNlIG5vZGUgaW4gaXRlcmF0aW9uLiBFbmFibGUgdGhpcyB0byBpZ25vcmUgdGhlbVxuICAgIGluc3RlYWQuXG4gICAgKi9cbiAgICBJdGVyTW9kZVtJdGVyTW9kZVtcIklnbm9yZU1vdW50c1wiXSA9IDRdID0gXCJJZ25vcmVNb3VudHNcIjtcbiAgICAvKipcbiAgICBUaGlzIG9wdGlvbiBvbmx5IGFwcGxpZXMgaW5cbiAgICBbYGVudGVyYF0oI2NvbW1vbi5TeW50YXhOb2RlLmVudGVyKS1zdHlsZSBtZXRob2RzLiBJdCB0ZWxscyB0aGVcbiAgICBsaWJyYXJ5IHRvIG5vdCBlbnRlciBtb3VudGVkIG92ZXJsYXlzIGlmIG9uZSBjb3ZlcnMgdGhlIGdpdmVuXG4gICAgcG9zaXRpb24uXG4gICAgKi9cbiAgICBJdGVyTW9kZVtJdGVyTW9kZVtcIklnbm9yZU92ZXJsYXlzXCJdID0gOF0gPSBcIklnbm9yZU92ZXJsYXlzXCI7XG59KShJdGVyTW9kZSB8fCAoSXRlck1vZGUgPSB7fSkpO1xuLyoqXG5BIHBpZWNlIG9mIHN5bnRheCB0cmVlLiBUaGVyZSBhcmUgdHdvIHdheXMgdG8gYXBwcm9hY2ggdGhlc2VcbnRyZWVzOiB0aGUgd2F5IHRoZXkgYXJlIGFjdHVhbGx5IHN0b3JlZCBpbiBtZW1vcnksIGFuZCB0aGVcbmNvbnZlbmllbnQgd2F5LlxuXG5TeW50YXggdHJlZXMgYXJlIHN0b3JlZCBhcyBhIHRyZWUgb2YgYFRyZWVgIGFuZCBgVHJlZUJ1ZmZlcmBcbm9iamVjdHMuIEJ5IHBhY2tpbmcgZGV0YWlsIGluZm9ybWF0aW9uIGludG8gYFRyZWVCdWZmZXJgIGxlYWZcbm5vZGVzLCB0aGUgcmVwcmVzZW50YXRpb24gaXMgbWFkZSBhIGxvdCBtb3JlIG1lbW9yeS1lZmZpY2llbnQuXG5cbkhvd2V2ZXIsIHdoZW4geW91IHdhbnQgdG8gYWN0dWFsbHkgd29yayB3aXRoIHRyZWUgbm9kZXMsIHRoaXNcbnJlcHJlc2VudGF0aW9uIGlzIHZlcnkgYXdrd2FyZCwgc28gbW9zdCBjbGllbnQgY29kZSB3aWxsIHdhbnQgdG9cbnVzZSB0aGUgW2BUcmVlQ3Vyc29yYF0oI2NvbW1vbi5UcmVlQ3Vyc29yKSBvclxuW2BTeW50YXhOb2RlYF0oI2NvbW1vbi5TeW50YXhOb2RlKSBpbnRlcmZhY2UgaW5zdGVhZCwgd2hpY2ggcHJvdmlkZXNcbmEgdmlldyBvbiBzb21lIHBhcnQgb2YgdGhpcyBkYXRhIHN0cnVjdHVyZSwgYW5kIGNhbiBiZSB1c2VkIHRvXG5tb3ZlIGFyb3VuZCB0byBhZGphY2VudCBub2Rlcy5cbiovXG5jbGFzcyBUcmVlIHtcbiAgICAvKipcbiAgICBDb25zdHJ1Y3QgYSBuZXcgdHJlZS4gU2VlIGFsc28gW2BUcmVlLmJ1aWxkYF0oI2NvbW1vbi5UcmVlXmJ1aWxkKS5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSB0eXBlIG9mIHRoZSB0b3Agbm9kZS5cbiAgICAqL1xuICAgIHR5cGUsIFxuICAgIC8qKlxuICAgIFRoaXMgbm9kZSdzIGNoaWxkIG5vZGVzLlxuICAgICovXG4gICAgY2hpbGRyZW4sIFxuICAgIC8qKlxuICAgIFRoZSBwb3NpdGlvbnMgKG9mZnNldHMgcmVsYXRpdmUgdG8gdGhlIHN0YXJ0IG9mIHRoaXMgdHJlZSkgb2ZcbiAgICB0aGUgY2hpbGRyZW4uXG4gICAgKi9cbiAgICBwb3NpdGlvbnMsIFxuICAgIC8qKlxuICAgIFRoZSB0b3RhbCBsZW5ndGggb2YgdGhpcyB0cmVlXG4gICAgKi9cbiAgICBsZW5ndGgsIFxuICAgIC8qKlxuICAgIFBlci1ub2RlIFtub2RlIHByb3BzXSgjY29tbW9uLk5vZGVQcm9wKSB0byBhc3NvY2lhdGUgd2l0aCB0aGlzIG5vZGUuXG4gICAgKi9cbiAgICBwcm9wcykge1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIHRoaXMucG9zaXRpb25zID0gcG9zaXRpb25zO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnByb3BzID0gbnVsbDtcbiAgICAgICAgaWYgKHByb3BzICYmIHByb3BzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5wcm9wcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICBmb3IgKGxldCBbcHJvcCwgdmFsdWVdIG9mIHByb3BzKVxuICAgICAgICAgICAgICAgIHRoaXMucHJvcHNbdHlwZW9mIHByb3AgPT0gXCJudW1iZXJcIiA/IHByb3AgOiBwcm9wLmlkXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCBtb3VudGVkID0gTW91bnRlZFRyZWUuZ2V0KHRoaXMpO1xuICAgICAgICBpZiAobW91bnRlZCAmJiAhbW91bnRlZC5vdmVybGF5KVxuICAgICAgICAgICAgcmV0dXJuIG1vdW50ZWQudHJlZS50b1N0cmluZygpO1xuICAgICAgICBsZXQgY2hpbGRyZW4gPSBcIlwiO1xuICAgICAgICBmb3IgKGxldCBjaCBvZiB0aGlzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBsZXQgc3RyID0gY2gudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGlmIChzdHIpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRyZW4pXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuICs9IFwiLFwiO1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuICs9IHN0cjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gIXRoaXMudHlwZS5uYW1lID8gY2hpbGRyZW4gOlxuICAgICAgICAgICAgKC9cXFcvLnRlc3QodGhpcy50eXBlLm5hbWUpICYmICF0aGlzLnR5cGUuaXNFcnJvciA/IEpTT04uc3RyaW5naWZ5KHRoaXMudHlwZS5uYW1lKSA6IHRoaXMudHlwZS5uYW1lKSArXG4gICAgICAgICAgICAgICAgKGNoaWxkcmVuLmxlbmd0aCA/IFwiKFwiICsgY2hpbGRyZW4gKyBcIilcIiA6IFwiXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgYSBbdHJlZSBjdXJzb3JdKCNjb21tb24uVHJlZUN1cnNvcikgcG9zaXRpb25lZCBhdCB0aGUgdG9wIG9mXG4gICAgdGhlIHRyZWUuIE1vZGUgY2FuIGJlIHVzZWQgdG8gW2NvbnRyb2xdKCNjb21tb24uSXRlck1vZGUpIHdoaWNoXG4gICAgbm9kZXMgdGhlIGN1cnNvciB2aXNpdHMuXG4gICAgKi9cbiAgICBjdXJzb3IobW9kZSA9IDApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlQ3Vyc29yKHRoaXMudG9wTm9kZSwgbW9kZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCBhIFt0cmVlIGN1cnNvcl0oI2NvbW1vbi5UcmVlQ3Vyc29yKSBwb2ludGluZyBpbnRvIHRoaXMgdHJlZVxuICAgIGF0IHRoZSBnaXZlbiBwb3NpdGlvbiBhbmQgc2lkZSAoc2VlXG4gICAgW2Btb3ZlVG9gXSgjY29tbW9uLlRyZWVDdXJzb3IubW92ZVRvKS5cbiAgICAqL1xuICAgIGN1cnNvckF0KHBvcywgc2lkZSA9IDAsIG1vZGUgPSAwKSB7XG4gICAgICAgIGxldCBzY29wZSA9IENhY2hlZE5vZGUuZ2V0KHRoaXMpIHx8IHRoaXMudG9wTm9kZTtcbiAgICAgICAgbGV0IGN1cnNvciA9IG5ldyBUcmVlQ3Vyc29yKHNjb3BlKTtcbiAgICAgICAgY3Vyc29yLm1vdmVUbyhwb3MsIHNpZGUpO1xuICAgICAgICBDYWNoZWROb2RlLnNldCh0aGlzLCBjdXJzb3IuX3RyZWUpO1xuICAgICAgICByZXR1cm4gY3Vyc29yO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgYSBbc3ludGF4IG5vZGVdKCNjb21tb24uU3ludGF4Tm9kZSkgb2JqZWN0IGZvciB0aGUgdG9wIG9mIHRoZVxuICAgIHRyZWUuXG4gICAgKi9cbiAgICBnZXQgdG9wTm9kZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlTm9kZSh0aGlzLCAwLCAwLCBudWxsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBbc3ludGF4IG5vZGVdKCNjb21tb24uU3ludGF4Tm9kZSkgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLlxuICAgIElmIGBzaWRlYCBpcyAtMSwgdGhpcyB3aWxsIG1vdmUgaW50byBub2RlcyB0aGF0IGVuZCBhdCB0aGVcbiAgICBwb3NpdGlvbi4gSWYgMSwgaXQnbGwgbW92ZSBpbnRvIG5vZGVzIHRoYXQgc3RhcnQgYXQgdGhlXG4gICAgcG9zaXRpb24uIFdpdGggMCwgaXQnbGwgb25seSBlbnRlciBub2RlcyB0aGF0IGNvdmVyIHRoZSBwb3NpdGlvblxuICAgIGZyb20gYm90aCBzaWRlcy5cbiAgICBcbiAgICBOb3RlIHRoYXQgdGhpcyB3aWxsIG5vdCBlbnRlclxuICAgIFtvdmVybGF5c10oI2NvbW1vbi5Nb3VudGVkVHJlZS5vdmVybGF5KSwgYW5kIHlvdSBvZnRlbiB3YW50XG4gICAgW2ByZXNvbHZlSW5uZXJgXSgjY29tbW9uLlRyZWUucmVzb2x2ZUlubmVyKSBpbnN0ZWFkLlxuICAgICovXG4gICAgcmVzb2x2ZShwb3MsIHNpZGUgPSAwKSB7XG4gICAgICAgIGxldCBub2RlID0gcmVzb2x2ZU5vZGUoQ2FjaGVkTm9kZS5nZXQodGhpcykgfHwgdGhpcy50b3BOb2RlLCBwb3MsIHNpZGUsIGZhbHNlKTtcbiAgICAgICAgQ2FjaGVkTm9kZS5zZXQodGhpcywgbm9kZSk7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICAvKipcbiAgICBMaWtlIFtgcmVzb2x2ZWBdKCNjb21tb24uVHJlZS5yZXNvbHZlKSwgYnV0IHdpbGwgZW50ZXJcbiAgICBbb3ZlcmxhaWRdKCNjb21tb24uTW91bnRlZFRyZWUub3ZlcmxheSkgbm9kZXMsIHByb2R1Y2luZyBhIHN5bnRheCBub2RlXG4gICAgcG9pbnRpbmcgaW50byB0aGUgaW5uZXJtb3N0IG92ZXJsYWlkIHRyZWUgYXQgdGhlIGdpdmVuIHBvc2l0aW9uXG4gICAgKHdpdGggcGFyZW50IGxpbmtzIGdvaW5nIHRocm91Z2ggYWxsIHBhcmVudCBzdHJ1Y3R1cmUsIGluY2x1ZGluZ1xuICAgIHRoZSBob3N0IHRyZWVzKS5cbiAgICAqL1xuICAgIHJlc29sdmVJbm5lcihwb3MsIHNpZGUgPSAwKSB7XG4gICAgICAgIGxldCBub2RlID0gcmVzb2x2ZU5vZGUoQ2FjaGVkSW5uZXJOb2RlLmdldCh0aGlzKSB8fCB0aGlzLnRvcE5vZGUsIHBvcywgc2lkZSwgdHJ1ZSk7XG4gICAgICAgIENhY2hlZElubmVyTm9kZS5zZXQodGhpcywgbm9kZSk7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICAvKipcbiAgICBJbiBzb21lIHNpdHVhdGlvbnMsIGl0IGNhbiBiZSB1c2VmdWwgdG8gaXRlcmF0ZSB0aHJvdWdoIGFsbFxuICAgIG5vZGVzIGFyb3VuZCBhIHBvc2l0aW9uLCBpbmNsdWRpbmcgdGhvc2UgaW4gb3ZlcmxheXMgdGhhdCBkb24ndFxuICAgIGRpcmVjdGx5IGNvdmVyIHRoZSBwb3NpdGlvbi4gVGhpcyBtZXRob2QgZ2l2ZXMgeW91IGFuIGl0ZXJhdG9yXG4gICAgdGhhdCB3aWxsIHByb2R1Y2UgYWxsIG5vZGVzLCBmcm9tIHNtYWxsIHRvIGJpZywgYXJvdW5kIHRoZSBnaXZlblxuICAgIHBvc2l0aW9uLlxuICAgICovXG4gICAgcmVzb2x2ZVN0YWNrKHBvcywgc2lkZSA9IDApIHtcbiAgICAgICAgcmV0dXJuIHN0YWNrSXRlcmF0b3IodGhpcywgcG9zLCBzaWRlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgSXRlcmF0ZSBvdmVyIHRoZSB0cmVlIGFuZCBpdHMgY2hpbGRyZW4sIGNhbGxpbmcgYGVudGVyYCBmb3IgYW55XG4gICAgbm9kZSB0aGF0IHRvdWNoZXMgdGhlIGBmcm9tYC9gdG9gIHJlZ2lvbiAoaWYgZ2l2ZW4pIGJlZm9yZVxuICAgIHJ1bm5pbmcgb3ZlciBzdWNoIGEgbm9kZSdzIGNoaWxkcmVuLCBhbmQgYGxlYXZlYCAoaWYgZ2l2ZW4pIHdoZW5cbiAgICBsZWF2aW5nIHRoZSBub2RlLiBXaGVuIGBlbnRlcmAgcmV0dXJucyBgZmFsc2VgLCB0aGF0IG5vZGUgd2lsbFxuICAgIG5vdCBoYXZlIGl0cyBjaGlsZHJlbiBpdGVyYXRlZCBvdmVyIChvciBgbGVhdmVgIGNhbGxlZCkuXG4gICAgKi9cbiAgICBpdGVyYXRlKHNwZWMpIHtcbiAgICAgICAgbGV0IHsgZW50ZXIsIGxlYXZlLCBmcm9tID0gMCwgdG8gPSB0aGlzLmxlbmd0aCB9ID0gc3BlYztcbiAgICAgICAgbGV0IG1vZGUgPSBzcGVjLm1vZGUgfHwgMCwgYW5vbiA9IChtb2RlICYgSXRlck1vZGUuSW5jbHVkZUFub255bW91cykgPiAwO1xuICAgICAgICBmb3IgKGxldCBjID0gdGhpcy5jdXJzb3IobW9kZSB8IEl0ZXJNb2RlLkluY2x1ZGVBbm9ueW1vdXMpOzspIHtcbiAgICAgICAgICAgIGxldCBlbnRlcmVkID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoYy5mcm9tIDw9IHRvICYmIGMudG8gPj0gZnJvbSAmJiAoIWFub24gJiYgYy50eXBlLmlzQW5vbnltb3VzIHx8IGVudGVyKGMpICE9PSBmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoYy5maXJzdENoaWxkKCkpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGVudGVyZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgIGlmIChlbnRlcmVkICYmIGxlYXZlICYmIChhbm9uIHx8ICFjLnR5cGUuaXNBbm9ueW1vdXMpKVxuICAgICAgICAgICAgICAgICAgICBsZWF2ZShjKTtcbiAgICAgICAgICAgICAgICBpZiAoYy5uZXh0U2libGluZygpKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAoIWMucGFyZW50KCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBlbnRlcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIHZhbHVlIG9mIHRoZSBnaXZlbiBbbm9kZSBwcm9wXSgjY29tbW9uLk5vZGVQcm9wKSBmb3IgdGhpc1xuICAgIG5vZGUuIFdvcmtzIHdpdGggYm90aCBwZXItbm9kZSBhbmQgcGVyLXR5cGUgcHJvcHMuXG4gICAgKi9cbiAgICBwcm9wKHByb3ApIHtcbiAgICAgICAgcmV0dXJuICFwcm9wLnBlck5vZGUgPyB0aGlzLnR5cGUucHJvcChwcm9wKSA6IHRoaXMucHJvcHMgPyB0aGlzLnByb3BzW3Byb3AuaWRdIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIHRoZSBub2RlJ3MgW3Blci1ub2RlIHByb3BzXSgjY29tbW9uLk5vZGVQcm9wLnBlck5vZGUpIGluIGFcbiAgICBmb3JtYXQgdGhhdCBjYW4gYmUgcGFzc2VkIHRvIHRoZSBbYFRyZWVgXSgjY29tbW9uLlRyZWUpXG4gICAgY29uc3RydWN0b3IuXG4gICAgKi9cbiAgICBnZXQgcHJvcFZhbHVlcygpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBpZiAodGhpcy5wcm9wcylcbiAgICAgICAgICAgIGZvciAobGV0IGlkIGluIHRoaXMucHJvcHMpXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goWytpZCwgdGhpcy5wcm9wc1tpZF1dKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgQmFsYW5jZSB0aGUgZGlyZWN0IGNoaWxkcmVuIG9mIHRoaXMgdHJlZSwgcHJvZHVjaW5nIGEgY29weSBvZlxuICAgIHdoaWNoIG1heSBoYXZlIGNoaWxkcmVuIGdyb3VwZWQgaW50byBzdWJ0cmVlcyB3aXRoIHR5cGVcbiAgICBbYE5vZGVUeXBlLm5vbmVgXSgjY29tbW9uLk5vZGVUeXBlXm5vbmUpLlxuICAgICovXG4gICAgYmFsYW5jZShjb25maWcgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5sZW5ndGggPD0gOCAvKiBCYWxhbmNlLkJyYW5jaEZhY3RvciAqLyA/IHRoaXMgOlxuICAgICAgICAgICAgYmFsYW5jZVJhbmdlKE5vZGVUeXBlLm5vbmUsIHRoaXMuY2hpbGRyZW4sIHRoaXMucG9zaXRpb25zLCAwLCB0aGlzLmNoaWxkcmVuLmxlbmd0aCwgMCwgdGhpcy5sZW5ndGgsIChjaGlsZHJlbiwgcG9zaXRpb25zLCBsZW5ndGgpID0+IG5ldyBUcmVlKHRoaXMudHlwZSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgbGVuZ3RoLCB0aGlzLnByb3BWYWx1ZXMpLCBjb25maWcubWFrZVRyZWUgfHwgKChjaGlsZHJlbiwgcG9zaXRpb25zLCBsZW5ndGgpID0+IG5ldyBUcmVlKE5vZGVUeXBlLm5vbmUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGxlbmd0aCkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQnVpbGQgYSB0cmVlIGZyb20gYSBwb3N0Zml4LW9yZGVyZWQgYnVmZmVyIG9mIG5vZGUgaW5mb3JtYXRpb24sXG4gICAgb3IgYSBjdXJzb3Igb3ZlciBzdWNoIGEgYnVmZmVyLlxuICAgICovXG4gICAgc3RhdGljIGJ1aWxkKGRhdGEpIHsgcmV0dXJuIGJ1aWxkVHJlZShkYXRhKTsgfVxufVxuLyoqXG5UaGUgZW1wdHkgdHJlZVxuKi9cblRyZWUuZW1wdHkgPSBuZXcgVHJlZShOb2RlVHlwZS5ub25lLCBbXSwgW10sIDApO1xuY2xhc3MgRmxhdEJ1ZmZlckN1cnNvciB7XG4gICAgY29uc3RydWN0b3IoYnVmZmVyLCBpbmRleCkge1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgIH1cbiAgICBnZXQgaWQoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gNF07IH1cbiAgICBnZXQgc3RhcnQoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gM107IH1cbiAgICBnZXQgZW5kKCkgeyByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCAtIDJdOyB9XG4gICAgZ2V0IHNpemUoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gMV07IH1cbiAgICBnZXQgcG9zKCkgeyByZXR1cm4gdGhpcy5pbmRleDsgfVxuICAgIG5leHQoKSB7IHRoaXMuaW5kZXggLT0gNDsgfVxuICAgIGZvcmsoKSB7IHJldHVybiBuZXcgRmxhdEJ1ZmZlckN1cnNvcih0aGlzLmJ1ZmZlciwgdGhpcy5pbmRleCk7IH1cbn1cbi8qKlxuVHJlZSBidWZmZXJzIGNvbnRhaW4gKHR5cGUsIHN0YXJ0LCBlbmQsIGVuZEluZGV4KSBxdWFkcyBmb3IgZWFjaFxubm9kZS4gSW4gc3VjaCBhIGJ1ZmZlciwgbm9kZXMgYXJlIHN0b3JlZCBpbiBwcmVmaXggb3JkZXIgKHBhcmVudHNcbmJlZm9yZSBjaGlsZHJlbiwgd2l0aCB0aGUgZW5kSW5kZXggb2YgdGhlIHBhcmVudCBpbmRpY2F0aW5nIHdoaWNoXG5jaGlsZHJlbiBiZWxvbmcgdG8gaXQpLlxuKi9cbmNsYXNzIFRyZWVCdWZmZXIge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIHRyZWUgYnVmZmVyLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIGJ1ZmZlcidzIGNvbnRlbnQuXG4gICAgKi9cbiAgICBidWZmZXIsIFxuICAgIC8qKlxuICAgIFRoZSB0b3RhbCBsZW5ndGggb2YgdGhlIGdyb3VwIG9mIG5vZGVzIGluIHRoZSBidWZmZXIuXG4gICAgKi9cbiAgICBsZW5ndGgsIFxuICAgIC8qKlxuICAgIFRoZSBub2RlIHNldCB1c2VkIGluIHRoaXMgYnVmZmVyLlxuICAgICovXG4gICAgc2V0KSB7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdGhpcy5zZXQgPSBzZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZ2V0IHR5cGUoKSB7IHJldHVybiBOb2RlVHlwZS5ub25lOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5idWZmZXIubGVuZ3RoOykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5jaGlsZFN0cmluZyhpbmRleCkpO1xuICAgICAgICAgICAgaW5kZXggPSB0aGlzLmJ1ZmZlcltpbmRleCArIDNdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQuam9pbihcIixcIik7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY2hpbGRTdHJpbmcoaW5kZXgpIHtcbiAgICAgICAgbGV0IGlkID0gdGhpcy5idWZmZXJbaW5kZXhdLCBlbmRJbmRleCA9IHRoaXMuYnVmZmVyW2luZGV4ICsgM107XG4gICAgICAgIGxldCB0eXBlID0gdGhpcy5zZXQudHlwZXNbaWRdLCByZXN1bHQgPSB0eXBlLm5hbWU7XG4gICAgICAgIGlmICgvXFxXLy50ZXN0KHJlc3VsdCkgJiYgIXR5cGUuaXNFcnJvcilcbiAgICAgICAgICAgIHJlc3VsdCA9IEpTT04uc3RyaW5naWZ5KHJlc3VsdCk7XG4gICAgICAgIGluZGV4ICs9IDQ7XG4gICAgICAgIGlmIChlbmRJbmRleCA9PSBpbmRleClcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IFtdO1xuICAgICAgICB3aGlsZSAoaW5kZXggPCBlbmRJbmRleCkge1xuICAgICAgICAgICAgY2hpbGRyZW4ucHVzaCh0aGlzLmNoaWxkU3RyaW5nKGluZGV4KSk7XG4gICAgICAgICAgICBpbmRleCA9IHRoaXMuYnVmZmVyW2luZGV4ICsgM107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdCArIFwiKFwiICsgY2hpbGRyZW4uam9pbihcIixcIikgKyBcIilcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBmaW5kQ2hpbGQoc3RhcnRJbmRleCwgZW5kSW5kZXgsIGRpciwgcG9zLCBzaWRlKSB7XG4gICAgICAgIGxldCB7IGJ1ZmZlciB9ID0gdGhpcywgcGljayA9IC0xO1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnRJbmRleDsgaSAhPSBlbmRJbmRleDsgaSA9IGJ1ZmZlcltpICsgM10pIHtcbiAgICAgICAgICAgIGlmIChjaGVja1NpZGUoc2lkZSwgcG9zLCBidWZmZXJbaSArIDFdLCBidWZmZXJbaSArIDJdKSkge1xuICAgICAgICAgICAgICAgIHBpY2sgPSBpO1xuICAgICAgICAgICAgICAgIGlmIChkaXIgPiAwKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGljaztcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzbGljZShzdGFydEksIGVuZEksIGZyb20pIHtcbiAgICAgICAgbGV0IGIgPSB0aGlzLmJ1ZmZlcjtcbiAgICAgICAgbGV0IGNvcHkgPSBuZXcgVWludDE2QXJyYXkoZW5kSSAtIHN0YXJ0SSksIGxlbiA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydEksIGogPSAwOyBpIDwgZW5kSTspIHtcbiAgICAgICAgICAgIGNvcHlbaisrXSA9IGJbaSsrXTtcbiAgICAgICAgICAgIGNvcHlbaisrXSA9IGJbaSsrXSAtIGZyb207XG4gICAgICAgICAgICBsZXQgdG8gPSBjb3B5W2orK10gPSBiW2krK10gLSBmcm9tO1xuICAgICAgICAgICAgY29weVtqKytdID0gYltpKytdIC0gc3RhcnRJO1xuICAgICAgICAgICAgbGVuID0gTWF0aC5tYXgobGVuLCB0byk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlQnVmZmVyKGNvcHksIGxlbiwgdGhpcy5zZXQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNoZWNrU2lkZShzaWRlLCBwb3MsIGZyb20sIHRvKSB7XG4gICAgc3dpdGNoIChzaWRlKSB7XG4gICAgICAgIGNhc2UgLTIgLyogU2lkZS5CZWZvcmUgKi86IHJldHVybiBmcm9tIDwgcG9zO1xuICAgICAgICBjYXNlIC0xIC8qIFNpZGUuQXRPckJlZm9yZSAqLzogcmV0dXJuIHRvID49IHBvcyAmJiBmcm9tIDwgcG9zO1xuICAgICAgICBjYXNlIDAgLyogU2lkZS5Bcm91bmQgKi86IHJldHVybiBmcm9tIDwgcG9zICYmIHRvID4gcG9zO1xuICAgICAgICBjYXNlIDEgLyogU2lkZS5BdE9yQWZ0ZXIgKi86IHJldHVybiBmcm9tIDw9IHBvcyAmJiB0byA+IHBvcztcbiAgICAgICAgY2FzZSAyIC8qIFNpZGUuQWZ0ZXIgKi86IHJldHVybiB0byA+IHBvcztcbiAgICAgICAgY2FzZSA0IC8qIFNpZGUuRG9udENhcmUgKi86IHJldHVybiB0cnVlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlc29sdmVOb2RlKG5vZGUsIHBvcywgc2lkZSwgb3ZlcmxheXMpIHtcbiAgICB2YXIgX2E7XG4gICAgLy8gTW92ZSB1cCB0byBhIG5vZGUgdGhhdCBhY3R1YWxseSBob2xkcyB0aGUgcG9zaXRpb24sIGlmIHBvc3NpYmxlXG4gICAgd2hpbGUgKG5vZGUuZnJvbSA9PSBub2RlLnRvIHx8XG4gICAgICAgIChzaWRlIDwgMSA/IG5vZGUuZnJvbSA+PSBwb3MgOiBub2RlLmZyb20gPiBwb3MpIHx8XG4gICAgICAgIChzaWRlID4gLTEgPyBub2RlLnRvIDw9IHBvcyA6IG5vZGUudG8gPCBwb3MpKSB7XG4gICAgICAgIGxldCBwYXJlbnQgPSAhb3ZlcmxheXMgJiYgbm9kZSBpbnN0YW5jZW9mIFRyZWVOb2RlICYmIG5vZGUuaW5kZXggPCAwID8gbnVsbCA6IG5vZGUucGFyZW50O1xuICAgICAgICBpZiAoIXBhcmVudClcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICBub2RlID0gcGFyZW50O1xuICAgIH1cbiAgICBsZXQgbW9kZSA9IG92ZXJsYXlzID8gMCA6IEl0ZXJNb2RlLklnbm9yZU92ZXJsYXlzO1xuICAgIC8vIE11c3QgZ28gdXAgb3V0IG9mIG92ZXJsYXlzIHdoZW4gdGhvc2UgZG8gbm90IG92ZXJsYXAgd2l0aCBwb3NcbiAgICBpZiAob3ZlcmxheXMpXG4gICAgICAgIGZvciAobGV0IHNjYW4gPSBub2RlLCBwYXJlbnQgPSBzY2FuLnBhcmVudDsgcGFyZW50OyBzY2FuID0gcGFyZW50LCBwYXJlbnQgPSBzY2FuLnBhcmVudCkge1xuICAgICAgICAgICAgaWYgKHNjYW4gaW5zdGFuY2VvZiBUcmVlTm9kZSAmJiBzY2FuLmluZGV4IDwgMCAmJiAoKF9hID0gcGFyZW50LmVudGVyKHBvcywgc2lkZSwgbW9kZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mcm9tKSAhPSBzY2FuLmZyb20pXG4gICAgICAgICAgICAgICAgbm9kZSA9IHBhcmVudDtcbiAgICAgICAgfVxuICAgIGZvciAoOzspIHtcbiAgICAgICAgbGV0IGlubmVyID0gbm9kZS5lbnRlcihwb3MsIHNpZGUsIG1vZGUpO1xuICAgICAgICBpZiAoIWlubmVyKVxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIG5vZGUgPSBpbm5lcjtcbiAgICB9XG59XG5jbGFzcyBCYXNlTm9kZSB7XG4gICAgY3Vyc29yKG1vZGUgPSAwKSB7IHJldHVybiBuZXcgVHJlZUN1cnNvcih0aGlzLCBtb2RlKTsgfVxuICAgIGdldENoaWxkKHR5cGUsIGJlZm9yZSA9IG51bGwsIGFmdGVyID0gbnVsbCkge1xuICAgICAgICBsZXQgciA9IGdldENoaWxkcmVuKHRoaXMsIHR5cGUsIGJlZm9yZSwgYWZ0ZXIpO1xuICAgICAgICByZXR1cm4gci5sZW5ndGggPyByWzBdIDogbnVsbDtcbiAgICB9XG4gICAgZ2V0Q2hpbGRyZW4odHlwZSwgYmVmb3JlID0gbnVsbCwgYWZ0ZXIgPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBnZXRDaGlsZHJlbih0aGlzLCB0eXBlLCBiZWZvcmUsIGFmdGVyKTtcbiAgICB9XG4gICAgcmVzb2x2ZShwb3MsIHNpZGUgPSAwKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlTm9kZSh0aGlzLCBwb3MsIHNpZGUsIGZhbHNlKTtcbiAgICB9XG4gICAgcmVzb2x2ZUlubmVyKHBvcywgc2lkZSA9IDApIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVOb2RlKHRoaXMsIHBvcywgc2lkZSwgdHJ1ZSk7XG4gICAgfVxuICAgIG1hdGNoQ29udGV4dChjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBtYXRjaE5vZGVDb250ZXh0KHRoaXMsIGNvbnRleHQpO1xuICAgIH1cbiAgICBlbnRlclVuZmluaXNoZWROb2Rlc0JlZm9yZShwb3MpIHtcbiAgICAgICAgbGV0IHNjYW4gPSB0aGlzLmNoaWxkQmVmb3JlKHBvcyksIG5vZGUgPSB0aGlzO1xuICAgICAgICB3aGlsZSAoc2Nhbikge1xuICAgICAgICAgICAgbGV0IGxhc3QgPSBzY2FuLmxhc3RDaGlsZDtcbiAgICAgICAgICAgIGlmICghbGFzdCB8fCBsYXN0LnRvICE9IHNjYW4udG8pXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpZiAobGFzdC50eXBlLmlzRXJyb3IgJiYgbGFzdC5mcm9tID09IGxhc3QudG8pIHtcbiAgICAgICAgICAgICAgICBub2RlID0gc2NhbjtcbiAgICAgICAgICAgICAgICBzY2FuID0gbGFzdC5wcmV2U2libGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNjYW4gPSBsYXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICBnZXQgbm9kZSgpIHsgcmV0dXJuIHRoaXM7IH1cbiAgICBnZXQgbmV4dCgpIHsgcmV0dXJuIHRoaXMucGFyZW50OyB9XG59XG5jbGFzcyBUcmVlTm9kZSBleHRlbmRzIEJhc2VOb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihfdHJlZSwgZnJvbSwgXG4gICAgLy8gSW5kZXggaW4gcGFyZW50IG5vZGUsIHNldCB0byAtMSBpZiB0aGUgbm9kZSBpcyBub3QgYSBkaXJlY3QgY2hpbGQgb2YgX3BhcmVudC5ub2RlIChvdmVybGF5KVxuICAgIGluZGV4LCBfcGFyZW50KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX3RyZWUgPSBfdHJlZTtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLl9wYXJlbnQgPSBfcGFyZW50O1xuICAgIH1cbiAgICBnZXQgdHlwZSgpIHsgcmV0dXJuIHRoaXMuX3RyZWUudHlwZTsgfVxuICAgIGdldCBuYW1lKCkgeyByZXR1cm4gdGhpcy5fdHJlZS50eXBlLm5hbWU7IH1cbiAgICBnZXQgdG8oKSB7IHJldHVybiB0aGlzLmZyb20gKyB0aGlzLl90cmVlLmxlbmd0aDsgfVxuICAgIG5leHRDaGlsZChpLCBkaXIsIHBvcywgc2lkZSwgbW9kZSA9IDApIHtcbiAgICAgICAgZm9yIChsZXQgcGFyZW50ID0gdGhpczs7KSB7XG4gICAgICAgICAgICBmb3IgKGxldCB7IGNoaWxkcmVuLCBwb3NpdGlvbnMgfSA9IHBhcmVudC5fdHJlZSwgZSA9IGRpciA+IDAgPyBjaGlsZHJlbi5sZW5ndGggOiAtMTsgaSAhPSBlOyBpICs9IGRpcikge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gY2hpbGRyZW5baV0sIHN0YXJ0ID0gcG9zaXRpb25zW2ldICsgcGFyZW50LmZyb207XG4gICAgICAgICAgICAgICAgaWYgKCFjaGVja1NpZGUoc2lkZSwgcG9zLCBzdGFydCwgc3RhcnQgKyBuZXh0Lmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0IGluc3RhbmNlb2YgVHJlZUJ1ZmZlcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAobW9kZSAmIEl0ZXJNb2RlLkV4Y2x1ZGVCdWZmZXJzKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpbmRleCA9IG5leHQuZmluZENoaWxkKDAsIG5leHQuYnVmZmVyLmxlbmd0aCwgZGlyLCBwb3MgLSBzdGFydCwgc2lkZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXJOb2RlKG5ldyBCdWZmZXJDb250ZXh0KHBhcmVudCwgbmV4dCwgaSwgc3RhcnQpLCBudWxsLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChtb2RlICYgSXRlck1vZGUuSW5jbHVkZUFub255bW91cykgfHwgKCFuZXh0LnR5cGUuaXNBbm9ueW1vdXMgfHwgaGFzQ2hpbGQobmV4dCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBtb3VudGVkO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShtb2RlICYgSXRlck1vZGUuSWdub3JlTW91bnRzKSAmJiAobW91bnRlZCA9IE1vdW50ZWRUcmVlLmdldChuZXh0KSkgJiYgIW1vdW50ZWQub3ZlcmxheSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVHJlZU5vZGUobW91bnRlZC50cmVlLCBzdGFydCwgaSwgcGFyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGlubmVyID0gbmV3IFRyZWVOb2RlKG5leHQsIHN0YXJ0LCBpLCBwYXJlbnQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKG1vZGUgJiBJdGVyTW9kZS5JbmNsdWRlQW5vbnltb3VzKSB8fCAhaW5uZXIudHlwZS5pc0Fub255bW91cyA/IGlubmVyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGlubmVyLm5leHRDaGlsZChkaXIgPCAwID8gbmV4dC5jaGlsZHJlbi5sZW5ndGggLSAxIDogMCwgZGlyLCBwb3MsIHNpZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgobW9kZSAmIEl0ZXJNb2RlLkluY2x1ZGVBbm9ueW1vdXMpIHx8ICFwYXJlbnQudHlwZS5pc0Fub255bW91cylcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGlmIChwYXJlbnQuaW5kZXggPj0gMClcbiAgICAgICAgICAgICAgICBpID0gcGFyZW50LmluZGV4ICsgZGlyO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGkgPSBkaXIgPCAwID8gLTEgOiBwYXJlbnQuX3BhcmVudC5fdHJlZS5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQuX3BhcmVudDtcbiAgICAgICAgICAgIGlmICghcGFyZW50KVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBmaXJzdENoaWxkKCkgeyByZXR1cm4gdGhpcy5uZXh0Q2hpbGQoMCwgMSwgMCwgNCAvKiBTaWRlLkRvbnRDYXJlICovKTsgfVxuICAgIGdldCBsYXN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLm5leHRDaGlsZCh0aGlzLl90cmVlLmNoaWxkcmVuLmxlbmd0aCAtIDEsIC0xLCAwLCA0IC8qIFNpZGUuRG9udENhcmUgKi8pOyB9XG4gICAgY2hpbGRBZnRlcihwb3MpIHsgcmV0dXJuIHRoaXMubmV4dENoaWxkKDAsIDEsIHBvcywgMiAvKiBTaWRlLkFmdGVyICovKTsgfVxuICAgIGNoaWxkQmVmb3JlKHBvcykgeyByZXR1cm4gdGhpcy5uZXh0Q2hpbGQodGhpcy5fdHJlZS5jaGlsZHJlbi5sZW5ndGggLSAxLCAtMSwgcG9zLCAtMiAvKiBTaWRlLkJlZm9yZSAqLyk7IH1cbiAgICBlbnRlcihwb3MsIHNpZGUsIG1vZGUgPSAwKSB7XG4gICAgICAgIGxldCBtb3VudGVkO1xuICAgICAgICBpZiAoIShtb2RlICYgSXRlck1vZGUuSWdub3JlT3ZlcmxheXMpICYmIChtb3VudGVkID0gTW91bnRlZFRyZWUuZ2V0KHRoaXMuX3RyZWUpKSAmJiBtb3VudGVkLm92ZXJsYXkpIHtcbiAgICAgICAgICAgIGxldCByUG9zID0gcG9zIC0gdGhpcy5mcm9tO1xuICAgICAgICAgICAgZm9yIChsZXQgeyBmcm9tLCB0byB9IG9mIG1vdW50ZWQub3ZlcmxheSkge1xuICAgICAgICAgICAgICAgIGlmICgoc2lkZSA+IDAgPyBmcm9tIDw9IHJQb3MgOiBmcm9tIDwgclBvcykgJiZcbiAgICAgICAgICAgICAgICAgICAgKHNpZGUgPCAwID8gdG8gPj0gclBvcyA6IHRvID4gclBvcykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVHJlZU5vZGUobW91bnRlZC50cmVlLCBtb3VudGVkLm92ZXJsYXlbMF0uZnJvbSArIHRoaXMuZnJvbSwgLTEsIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm5leHRDaGlsZCgwLCAxLCBwb3MsIHNpZGUsIG1vZGUpO1xuICAgIH1cbiAgICBuZXh0U2lnbmlmaWNhbnRQYXJlbnQoKSB7XG4gICAgICAgIGxldCB2YWwgPSB0aGlzO1xuICAgICAgICB3aGlsZSAodmFsLnR5cGUuaXNBbm9ueW1vdXMgJiYgdmFsLl9wYXJlbnQpXG4gICAgICAgICAgICB2YWwgPSB2YWwuX3BhcmVudDtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gICAgZ2V0IHBhcmVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCA/IHRoaXMuX3BhcmVudC5uZXh0U2lnbmlmaWNhbnRQYXJlbnQoKSA6IG51bGw7XG4gICAgfVxuICAgIGdldCBuZXh0U2libGluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCAmJiB0aGlzLmluZGV4ID49IDAgPyB0aGlzLl9wYXJlbnQubmV4dENoaWxkKHRoaXMuaW5kZXggKyAxLCAxLCAwLCA0IC8qIFNpZGUuRG9udENhcmUgKi8pIDogbnVsbDtcbiAgICB9XG4gICAgZ2V0IHByZXZTaWJsaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50ICYmIHRoaXMuaW5kZXggPj0gMCA/IHRoaXMuX3BhcmVudC5uZXh0Q2hpbGQodGhpcy5pbmRleCAtIDEsIC0xLCAwLCA0IC8qIFNpZGUuRG9udENhcmUgKi8pIDogbnVsbDtcbiAgICB9XG4gICAgZ2V0IHRyZWUoKSB7IHJldHVybiB0aGlzLl90cmVlOyB9XG4gICAgdG9UcmVlKCkgeyByZXR1cm4gdGhpcy5fdHJlZTsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdG9TdHJpbmcoKSB7IHJldHVybiB0aGlzLl90cmVlLnRvU3RyaW5nKCk7IH1cbn1cbmZ1bmN0aW9uIGdldENoaWxkcmVuKG5vZGUsIHR5cGUsIGJlZm9yZSwgYWZ0ZXIpIHtcbiAgICBsZXQgY3VyID0gbm9kZS5jdXJzb3IoKSwgcmVzdWx0ID0gW107XG4gICAgaWYgKCFjdXIuZmlyc3RDaGlsZCgpKVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIGlmIChiZWZvcmUgIT0gbnVsbClcbiAgICAgICAgd2hpbGUgKCFjdXIudHlwZS5pcyhiZWZvcmUpKVxuICAgICAgICAgICAgaWYgKCFjdXIubmV4dFNpYmxpbmcoKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgaWYgKGFmdGVyICE9IG51bGwgJiYgY3VyLnR5cGUuaXMoYWZ0ZXIpKVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgaWYgKGN1ci50eXBlLmlzKHR5cGUpKVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goY3VyLm5vZGUpO1xuICAgICAgICBpZiAoIWN1ci5uZXh0U2libGluZygpKVxuICAgICAgICAgICAgcmV0dXJuIGFmdGVyID09IG51bGwgPyByZXN1bHQgOiBbXTtcbiAgICB9XG59XG5mdW5jdGlvbiBtYXRjaE5vZGVDb250ZXh0KG5vZGUsIGNvbnRleHQsIGkgPSBjb250ZXh0Lmxlbmd0aCAtIDEpIHtcbiAgICBmb3IgKGxldCBwID0gbm9kZS5wYXJlbnQ7IGkgPj0gMDsgcCA9IHAucGFyZW50KSB7XG4gICAgICAgIGlmICghcClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKCFwLnR5cGUuaXNBbm9ueW1vdXMpIHtcbiAgICAgICAgICAgIGlmIChjb250ZXh0W2ldICYmIGNvbnRleHRbaV0gIT0gcC5uYW1lKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmNsYXNzIEJ1ZmZlckNvbnRleHQge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudCwgYnVmZmVyLCBpbmRleCwgc3RhcnQpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcbiAgICB9XG59XG5jbGFzcyBCdWZmZXJOb2RlIGV4dGVuZHMgQmFzZU5vZGUge1xuICAgIGdldCBuYW1lKCkgeyByZXR1cm4gdGhpcy50eXBlLm5hbWU7IH1cbiAgICBnZXQgZnJvbSgpIHsgcmV0dXJuIHRoaXMuY29udGV4dC5zdGFydCArIHRoaXMuY29udGV4dC5idWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAxXTsgfVxuICAgIGdldCB0bygpIHsgcmV0dXJuIHRoaXMuY29udGV4dC5zdGFydCArIHRoaXMuY29udGV4dC5idWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAyXTsgfVxuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQsIF9wYXJlbnQsIGluZGV4KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMuX3BhcmVudCA9IF9wYXJlbnQ7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy50eXBlID0gY29udGV4dC5idWZmZXIuc2V0LnR5cGVzW2NvbnRleHQuYnVmZmVyLmJ1ZmZlcltpbmRleF1dO1xuICAgIH1cbiAgICBjaGlsZChkaXIsIHBvcywgc2lkZSkge1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IGluZGV4ID0gYnVmZmVyLmZpbmRDaGlsZCh0aGlzLmluZGV4ICsgNCwgYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgM10sIGRpciwgcG9zIC0gdGhpcy5jb250ZXh0LnN0YXJ0LCBzaWRlKTtcbiAgICAgICAgcmV0dXJuIGluZGV4IDwgMCA/IG51bGwgOiBuZXcgQnVmZmVyTm9kZSh0aGlzLmNvbnRleHQsIHRoaXMsIGluZGV4KTtcbiAgICB9XG4gICAgZ2V0IGZpcnN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLmNoaWxkKDEsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLyk7IH1cbiAgICBnZXQgbGFzdENoaWxkKCkgeyByZXR1cm4gdGhpcy5jaGlsZCgtMSwgMCwgNCAvKiBTaWRlLkRvbnRDYXJlICovKTsgfVxuICAgIGNoaWxkQWZ0ZXIocG9zKSB7IHJldHVybiB0aGlzLmNoaWxkKDEsIHBvcywgMiAvKiBTaWRlLkFmdGVyICovKTsgfVxuICAgIGNoaWxkQmVmb3JlKHBvcykgeyByZXR1cm4gdGhpcy5jaGlsZCgtMSwgcG9zLCAtMiAvKiBTaWRlLkJlZm9yZSAqLyk7IH1cbiAgICBlbnRlcihwb3MsIHNpZGUsIG1vZGUgPSAwKSB7XG4gICAgICAgIGlmIChtb2RlICYgSXRlck1vZGUuRXhjbHVkZUJ1ZmZlcnMpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCBpbmRleCA9IGJ1ZmZlci5maW5kQ2hpbGQodGhpcy5pbmRleCArIDQsIGJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDNdLCBzaWRlID4gMCA/IDEgOiAtMSwgcG9zIC0gdGhpcy5jb250ZXh0LnN0YXJ0LCBzaWRlKTtcbiAgICAgICAgcmV0dXJuIGluZGV4IDwgMCA/IG51bGwgOiBuZXcgQnVmZmVyTm9kZSh0aGlzLmNvbnRleHQsIHRoaXMsIGluZGV4KTtcbiAgICB9XG4gICAgZ2V0IHBhcmVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCB8fCB0aGlzLmNvbnRleHQucGFyZW50Lm5leHRTaWduaWZpY2FudFBhcmVudCgpO1xuICAgIH1cbiAgICBleHRlcm5hbFNpYmxpbmcoZGlyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQgPyBudWxsIDogdGhpcy5jb250ZXh0LnBhcmVudC5uZXh0Q2hpbGQodGhpcy5jb250ZXh0LmluZGV4ICsgZGlyLCBkaXIsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLyk7XG4gICAgfVxuICAgIGdldCBuZXh0U2libGluZygpIHtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCBhZnRlciA9IGJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDNdO1xuICAgICAgICBpZiAoYWZ0ZXIgPCAodGhpcy5fcGFyZW50ID8gYnVmZmVyLmJ1ZmZlclt0aGlzLl9wYXJlbnQuaW5kZXggKyAzXSA6IGJ1ZmZlci5idWZmZXIubGVuZ3RoKSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgQnVmZmVyTm9kZSh0aGlzLmNvbnRleHQsIHRoaXMuX3BhcmVudCwgYWZ0ZXIpO1xuICAgICAgICByZXR1cm4gdGhpcy5leHRlcm5hbFNpYmxpbmcoMSk7XG4gICAgfVxuICAgIGdldCBwcmV2U2libGluZygpIHtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCBwYXJlbnRTdGFydCA9IHRoaXMuX3BhcmVudCA/IHRoaXMuX3BhcmVudC5pbmRleCArIDQgOiAwO1xuICAgICAgICBpZiAodGhpcy5pbmRleCA9PSBwYXJlbnRTdGFydClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV4dGVybmFsU2libGluZygtMSk7XG4gICAgICAgIHJldHVybiBuZXcgQnVmZmVyTm9kZSh0aGlzLmNvbnRleHQsIHRoaXMuX3BhcmVudCwgYnVmZmVyLmZpbmRDaGlsZChwYXJlbnRTdGFydCwgdGhpcy5pbmRleCwgLTEsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLykpO1xuICAgIH1cbiAgICBnZXQgdHJlZSgpIHsgcmV0dXJuIG51bGw7IH1cbiAgICB0b1RyZWUoKSB7XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IFtdLCBwb3NpdGlvbnMgPSBbXTtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCBzdGFydEkgPSB0aGlzLmluZGV4ICsgNCwgZW5kSSA9IGJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDNdO1xuICAgICAgICBpZiAoZW5kSSA+IHN0YXJ0SSkge1xuICAgICAgICAgICAgbGV0IGZyb20gPSBidWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAxXTtcbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2goYnVmZmVyLnNsaWNlKHN0YXJ0SSwgZW5kSSwgZnJvbSkpO1xuICAgICAgICAgICAgcG9zaXRpb25zLnB1c2goMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlKHRoaXMudHlwZSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgdGhpcy50byAtIHRoaXMuZnJvbSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdG9TdHJpbmcoKSB7IHJldHVybiB0aGlzLmNvbnRleHQuYnVmZmVyLmNoaWxkU3RyaW5nKHRoaXMuaW5kZXgpOyB9XG59XG5mdW5jdGlvbiBpdGVyU3RhY2soaGVhZHMpIHtcbiAgICBpZiAoIWhlYWRzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IHBpY2sgPSAwLCBwaWNrZWQgPSBoZWFkc1swXTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGhlYWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBub2RlID0gaGVhZHNbaV07XG4gICAgICAgIGlmIChub2RlLmZyb20gPiBwaWNrZWQuZnJvbSB8fCBub2RlLnRvIDwgcGlja2VkLnRvKSB7XG4gICAgICAgICAgICBwaWNrZWQgPSBub2RlO1xuICAgICAgICAgICAgcGljayA9IGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IG5leHQgPSBwaWNrZWQgaW5zdGFuY2VvZiBUcmVlTm9kZSAmJiBwaWNrZWQuaW5kZXggPCAwID8gbnVsbCA6IHBpY2tlZC5wYXJlbnQ7XG4gICAgbGV0IG5ld0hlYWRzID0gaGVhZHMuc2xpY2UoKTtcbiAgICBpZiAobmV4dClcbiAgICAgICAgbmV3SGVhZHNbcGlja10gPSBuZXh0O1xuICAgIGVsc2VcbiAgICAgICAgbmV3SGVhZHMuc3BsaWNlKHBpY2ssIDEpO1xuICAgIHJldHVybiBuZXcgU3RhY2tJdGVyYXRvcihuZXdIZWFkcywgcGlja2VkKTtcbn1cbmNsYXNzIFN0YWNrSXRlcmF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKGhlYWRzLCBub2RlKSB7XG4gICAgICAgIHRoaXMuaGVhZHMgPSBoZWFkcztcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICB9XG4gICAgZ2V0IG5leHQoKSB7IHJldHVybiBpdGVyU3RhY2sodGhpcy5oZWFkcyk7IH1cbn1cbmZ1bmN0aW9uIHN0YWNrSXRlcmF0b3IodHJlZSwgcG9zLCBzaWRlKSB7XG4gICAgbGV0IGlubmVyID0gdHJlZS5yZXNvbHZlSW5uZXIocG9zLCBzaWRlKSwgbGF5ZXJzID0gbnVsbDtcbiAgICBmb3IgKGxldCBzY2FuID0gaW5uZXIgaW5zdGFuY2VvZiBUcmVlTm9kZSA/IGlubmVyIDogaW5uZXIuY29udGV4dC5wYXJlbnQ7IHNjYW47IHNjYW4gPSBzY2FuLnBhcmVudCkge1xuICAgICAgICBpZiAoc2Nhbi5pbmRleCA8IDApIHsgLy8gVGhpcyBpcyBhbiBvdmVybGF5IHJvb3RcbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSBzY2FuLnBhcmVudDtcbiAgICAgICAgICAgIChsYXllcnMgfHwgKGxheWVycyA9IFtpbm5lcl0pKS5wdXNoKHBhcmVudC5yZXNvbHZlKHBvcywgc2lkZSkpO1xuICAgICAgICAgICAgc2NhbiA9IHBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBtb3VudCA9IE1vdW50ZWRUcmVlLmdldChzY2FuLnRyZWUpO1xuICAgICAgICAgICAgLy8gUmVsZXZhbnQgb3ZlcmxheSBicmFuY2hpbmcgb2ZmXG4gICAgICAgICAgICBpZiAobW91bnQgJiYgbW91bnQub3ZlcmxheSAmJiBtb3VudC5vdmVybGF5WzBdLmZyb20gPD0gcG9zICYmIG1vdW50Lm92ZXJsYXlbbW91bnQub3ZlcmxheS5sZW5ndGggLSAxXS50byA+PSBwb3MpIHtcbiAgICAgICAgICAgICAgICBsZXQgcm9vdCA9IG5ldyBUcmVlTm9kZShtb3VudC50cmVlLCBtb3VudC5vdmVybGF5WzBdLmZyb20gKyBzY2FuLmZyb20sIC0xLCBzY2FuKTtcbiAgICAgICAgICAgICAgICAobGF5ZXJzIHx8IChsYXllcnMgPSBbaW5uZXJdKSkucHVzaChyZXNvbHZlTm9kZShyb290LCBwb3MsIHNpZGUsIGZhbHNlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxheWVycyA/IGl0ZXJTdGFjayhsYXllcnMpIDogaW5uZXI7XG59XG4vKipcbkEgdHJlZSBjdXJzb3Igb2JqZWN0IGZvY3VzZXMgb24gYSBnaXZlbiBub2RlIGluIGEgc3ludGF4IHRyZWUsIGFuZFxuYWxsb3dzIHlvdSB0byBtb3ZlIHRvIGFkamFjZW50IG5vZGVzLlxuKi9cbmNsYXNzIFRyZWVDdXJzb3Ige1xuICAgIC8qKlxuICAgIFNob3J0aGFuZCBmb3IgYC50eXBlLm5hbWVgLlxuICAgICovXG4gICAgZ2V0IG5hbWUoKSB7IHJldHVybiB0aGlzLnR5cGUubmFtZTsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3Iobm9kZSwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBtb2RlID0gMCkge1xuICAgICAgICB0aGlzLm1vZGUgPSBtb2RlO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuYnVmZmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdGFjayA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgICB0aGlzLmJ1ZmZlck5vZGUgPSBudWxsO1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIFRyZWVOb2RlKSB7XG4gICAgICAgICAgICB0aGlzLnlpZWxkTm9kZShub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3RyZWUgPSBub2RlLmNvbnRleHQucGFyZW50O1xuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBub2RlLmNvbnRleHQ7XG4gICAgICAgICAgICBmb3IgKGxldCBuID0gbm9kZS5fcGFyZW50OyBuOyBuID0gbi5fcGFyZW50KVxuICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sudW5zaGlmdChuLmluZGV4KTtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyTm9kZSA9IG5vZGU7XG4gICAgICAgICAgICB0aGlzLnlpZWxkQnVmKG5vZGUuaW5kZXgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHlpZWxkTm9kZShub2RlKSB7XG4gICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy5fdHJlZSA9IG5vZGU7XG4gICAgICAgIHRoaXMudHlwZSA9IG5vZGUudHlwZTtcbiAgICAgICAgdGhpcy5mcm9tID0gbm9kZS5mcm9tO1xuICAgICAgICB0aGlzLnRvID0gbm9kZS50bztcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHlpZWxkQnVmKGluZGV4LCB0eXBlKSB7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgbGV0IHsgc3RhcnQsIGJ1ZmZlciB9ID0gdGhpcy5idWZmZXI7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGUgfHwgYnVmZmVyLnNldC50eXBlc1tidWZmZXIuYnVmZmVyW2luZGV4XV07XG4gICAgICAgIHRoaXMuZnJvbSA9IHN0YXJ0ICsgYnVmZmVyLmJ1ZmZlcltpbmRleCArIDFdO1xuICAgICAgICB0aGlzLnRvID0gc3RhcnQgKyBidWZmZXIuYnVmZmVyW2luZGV4ICsgMl07XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHlpZWxkKG5vZGUpIHtcbiAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIFRyZWVOb2RlKSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZE5vZGUobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5idWZmZXIgPSBub2RlLmNvbnRleHQ7XG4gICAgICAgIHJldHVybiB0aGlzLnlpZWxkQnVmKG5vZGUuaW5kZXgsIG5vZGUudHlwZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlciA/IHRoaXMuYnVmZmVyLmJ1ZmZlci5jaGlsZFN0cmluZyh0aGlzLmluZGV4KSA6IHRoaXMuX3RyZWUudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBlbnRlckNoaWxkKGRpciwgcG9zLCBzaWRlKSB7XG4gICAgICAgIGlmICghdGhpcy5idWZmZXIpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZCh0aGlzLl90cmVlLm5leHRDaGlsZChkaXIgPCAwID8gdGhpcy5fdHJlZS5fdHJlZS5jaGlsZHJlbi5sZW5ndGggLSAxIDogMCwgZGlyLCBwb3MsIHNpZGUsIHRoaXMubW9kZSkpO1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuYnVmZmVyO1xuICAgICAgICBsZXQgaW5kZXggPSBidWZmZXIuZmluZENoaWxkKHRoaXMuaW5kZXggKyA0LCBidWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAzXSwgZGlyLCBwb3MgLSB0aGlzLmJ1ZmZlci5zdGFydCwgc2lkZSk7XG4gICAgICAgIGlmIChpbmRleCA8IDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMuc3RhY2sucHVzaCh0aGlzLmluZGV4KTtcbiAgICAgICAgcmV0dXJuIHRoaXMueWllbGRCdWYoaW5kZXgpO1xuICAgIH1cbiAgICAvKipcbiAgICBNb3ZlIHRoZSBjdXJzb3IgdG8gdGhpcyBub2RlJ3MgZmlyc3QgY2hpbGQuIFdoZW4gdGhpcyByZXR1cm5zXG4gICAgZmFsc2UsIHRoZSBub2RlIGhhcyBubyBjaGlsZCwgYW5kIHRoZSBjdXJzb3IgaGFzIG5vdCBiZWVuIG1vdmVkLlxuICAgICovXG4gICAgZmlyc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMuZW50ZXJDaGlsZCgxLCAwLCA0IC8qIFNpZGUuRG9udENhcmUgKi8pOyB9XG4gICAgLyoqXG4gICAgTW92ZSB0aGUgY3Vyc29yIHRvIHRoaXMgbm9kZSdzIGxhc3QgY2hpbGQuXG4gICAgKi9cbiAgICBsYXN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLmVudGVyQ2hpbGQoLTEsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLyk7IH1cbiAgICAvKipcbiAgICBNb3ZlIHRoZSBjdXJzb3IgdG8gdGhlIGZpcnN0IGNoaWxkIHRoYXQgZW5kcyBhZnRlciBgcG9zYC5cbiAgICAqL1xuICAgIGNoaWxkQWZ0ZXIocG9zKSB7IHJldHVybiB0aGlzLmVudGVyQ2hpbGQoMSwgcG9zLCAyIC8qIFNpZGUuQWZ0ZXIgKi8pOyB9XG4gICAgLyoqXG4gICAgTW92ZSB0byB0aGUgbGFzdCBjaGlsZCB0aGF0IHN0YXJ0cyBiZWZvcmUgYHBvc2AuXG4gICAgKi9cbiAgICBjaGlsZEJlZm9yZShwb3MpIHsgcmV0dXJuIHRoaXMuZW50ZXJDaGlsZCgtMSwgcG9zLCAtMiAvKiBTaWRlLkJlZm9yZSAqLyk7IH1cbiAgICAvKipcbiAgICBNb3ZlIHRoZSBjdXJzb3IgdG8gdGhlIGNoaWxkIGFyb3VuZCBgcG9zYC4gSWYgc2lkZSBpcyAtMSB0aGVcbiAgICBjaGlsZCBtYXkgZW5kIGF0IHRoYXQgcG9zaXRpb24sIHdoZW4gMSBpdCBtYXkgc3RhcnQgdGhlcmUuIFRoaXNcbiAgICB3aWxsIGFsc28gZW50ZXIgW292ZXJsYWlkXSgjY29tbW9uLk1vdW50ZWRUcmVlLm92ZXJsYXkpXG4gICAgW21vdW50ZWRdKCNjb21tb24uTm9kZVByb3BebW91bnRlZCkgdHJlZXMgdW5sZXNzIGBvdmVybGF5c2AgaXNcbiAgICBzZXQgdG8gZmFsc2UuXG4gICAgKi9cbiAgICBlbnRlcihwb3MsIHNpZGUsIG1vZGUgPSB0aGlzLm1vZGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmJ1ZmZlcilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkKHRoaXMuX3RyZWUuZW50ZXIocG9zLCBzaWRlLCBtb2RlKSk7XG4gICAgICAgIHJldHVybiBtb2RlICYgSXRlck1vZGUuRXhjbHVkZUJ1ZmZlcnMgPyBmYWxzZSA6IHRoaXMuZW50ZXJDaGlsZCgxLCBwb3MsIHNpZGUpO1xuICAgIH1cbiAgICAvKipcbiAgICBNb3ZlIHRvIHRoZSBub2RlJ3MgcGFyZW50IG5vZGUsIGlmIHRoaXMgaXNuJ3QgdGhlIHRvcCBub2RlLlxuICAgICovXG4gICAgcGFyZW50KCkge1xuICAgICAgICBpZiAoIXRoaXMuYnVmZmVyKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMueWllbGROb2RlKCh0aGlzLm1vZGUgJiBJdGVyTW9kZS5JbmNsdWRlQW5vbnltb3VzKSA/IHRoaXMuX3RyZWUuX3BhcmVudCA6IHRoaXMuX3RyZWUucGFyZW50KTtcbiAgICAgICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMueWllbGRCdWYodGhpcy5zdGFjay5wb3AoKSk7XG4gICAgICAgIGxldCBwYXJlbnQgPSAodGhpcy5tb2RlICYgSXRlck1vZGUuSW5jbHVkZUFub255bW91cykgPyB0aGlzLmJ1ZmZlci5wYXJlbnQgOiB0aGlzLmJ1ZmZlci5wYXJlbnQubmV4dFNpZ25pZmljYW50UGFyZW50KCk7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXMueWllbGROb2RlKHBhcmVudCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc2libGluZyhkaXIpIHtcbiAgICAgICAgaWYgKCF0aGlzLmJ1ZmZlcilcbiAgICAgICAgICAgIHJldHVybiAhdGhpcy5fdHJlZS5fcGFyZW50ID8gZmFsc2VcbiAgICAgICAgICAgICAgICA6IHRoaXMueWllbGQodGhpcy5fdHJlZS5pbmRleCA8IDAgPyBudWxsXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5fdHJlZS5fcGFyZW50Lm5leHRDaGlsZCh0aGlzLl90cmVlLmluZGV4ICsgZGlyLCBkaXIsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLywgdGhpcy5tb2RlKSk7XG4gICAgICAgIGxldCB7IGJ1ZmZlciB9ID0gdGhpcy5idWZmZXIsIGQgPSB0aGlzLnN0YWNrLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChkaXIgPCAwKSB7XG4gICAgICAgICAgICBsZXQgcGFyZW50U3RhcnQgPSBkIDwgMCA/IDAgOiB0aGlzLnN0YWNrW2RdICsgNDtcbiAgICAgICAgICAgIGlmICh0aGlzLmluZGV4ICE9IHBhcmVudFN0YXJ0KVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkQnVmKGJ1ZmZlci5maW5kQ2hpbGQocGFyZW50U3RhcnQsIHRoaXMuaW5kZXgsIC0xLCAwLCA0IC8qIFNpZGUuRG9udENhcmUgKi8pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBhZnRlciA9IGJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDNdO1xuICAgICAgICAgICAgaWYgKGFmdGVyIDwgKGQgPCAwID8gYnVmZmVyLmJ1ZmZlci5sZW5ndGggOiBidWZmZXIuYnVmZmVyW3RoaXMuc3RhY2tbZF0gKyAzXSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMueWllbGRCdWYoYWZ0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkIDwgMCA/IHRoaXMueWllbGQodGhpcy5idWZmZXIucGFyZW50Lm5leHRDaGlsZCh0aGlzLmJ1ZmZlci5pbmRleCArIGRpciwgZGlyLCAwLCA0IC8qIFNpZGUuRG9udENhcmUgKi8sIHRoaXMubW9kZSkpIDogZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgIE1vdmUgdG8gdGhpcyBub2RlJ3MgbmV4dCBzaWJsaW5nLCBpZiBhbnkuXG4gICAgKi9cbiAgICBuZXh0U2libGluZygpIHsgcmV0dXJuIHRoaXMuc2libGluZygxKTsgfVxuICAgIC8qKlxuICAgIE1vdmUgdG8gdGhpcyBub2RlJ3MgcHJldmlvdXMgc2libGluZywgaWYgYW55LlxuICAgICovXG4gICAgcHJldlNpYmxpbmcoKSB7IHJldHVybiB0aGlzLnNpYmxpbmcoLTEpOyB9XG4gICAgYXRMYXN0Tm9kZShkaXIpIHtcbiAgICAgICAgbGV0IGluZGV4LCBwYXJlbnQsIHsgYnVmZmVyIH0gPSB0aGlzO1xuICAgICAgICBpZiAoYnVmZmVyKSB7XG4gICAgICAgICAgICBpZiAoZGlyID4gMCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmluZGV4IDwgYnVmZmVyLmJ1ZmZlci5idWZmZXIubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuaW5kZXg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJ1ZmZlci5idWZmZXIuYnVmZmVyW2kgKyAzXSA8IHRoaXMuaW5kZXgpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoeyBpbmRleCwgcGFyZW50IH0gPSBidWZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgKHsgaW5kZXgsIF9wYXJlbnQ6IHBhcmVudCB9ID0gdGhpcy5fdHJlZSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICg7IHBhcmVudDsgeyBpbmRleCwgX3BhcmVudDogcGFyZW50IH0gPSBwYXJlbnQpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBpbmRleCArIGRpciwgZSA9IGRpciA8IDAgPyAtMSA6IHBhcmVudC5fdHJlZS5jaGlsZHJlbi5sZW5ndGg7IGkgIT0gZTsgaSArPSBkaXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNoaWxkID0gcGFyZW50Ll90cmVlLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHRoaXMubW9kZSAmIEl0ZXJNb2RlLkluY2x1ZGVBbm9ueW1vdXMpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZCBpbnN0YW5jZW9mIFRyZWVCdWZmZXIgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICFjaGlsZC50eXBlLmlzQW5vbnltb3VzIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNDaGlsZChjaGlsZCkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBtb3ZlKGRpciwgZW50ZXIpIHtcbiAgICAgICAgaWYgKGVudGVyICYmIHRoaXMuZW50ZXJDaGlsZChkaXIsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLykpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2libGluZyhkaXIpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuYXRMYXN0Tm9kZShkaXIpIHx8ICF0aGlzLnBhcmVudCgpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBNb3ZlIHRvIHRoZSBuZXh0IG5vZGUgaW4gYVxuICAgIFtwcmUtb3JkZXJdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1RyZWVfdHJhdmVyc2FsI1ByZS1vcmRlcixfTkxSKVxuICAgIHRyYXZlcnNhbCwgZ29pbmcgZnJvbSBhIG5vZGUgdG8gaXRzIGZpcnN0IGNoaWxkIG9yLCBpZiB0aGVcbiAgICBjdXJyZW50IG5vZGUgaXMgZW1wdHkgb3IgYGVudGVyYCBpcyBmYWxzZSwgaXRzIG5leHQgc2libGluZyBvclxuICAgIHRoZSBuZXh0IHNpYmxpbmcgb2YgdGhlIGZpcnN0IHBhcmVudCBub2RlIHRoYXQgaGFzIG9uZS5cbiAgICAqL1xuICAgIG5leHQoZW50ZXIgPSB0cnVlKSB7IHJldHVybiB0aGlzLm1vdmUoMSwgZW50ZXIpOyB9XG4gICAgLyoqXG4gICAgTW92ZSB0byB0aGUgbmV4dCBub2RlIGluIGEgbGFzdC10by1maXJzdCBwcmUtb3JkZXIgdHJhdmVyYWwuIEFcbiAgICBub2RlIGlzIGZvbGxvd2VkIGJ5IGl0cyBsYXN0IGNoaWxkIG9yLCBpZiBpdCBoYXMgbm9uZSwgaXRzXG4gICAgcHJldmlvdXMgc2libGluZyBvciB0aGUgcHJldmlvdXMgc2libGluZyBvZiB0aGUgZmlyc3QgcGFyZW50XG4gICAgbm9kZSB0aGF0IGhhcyBvbmUuXG4gICAgKi9cbiAgICBwcmV2KGVudGVyID0gdHJ1ZSkgeyByZXR1cm4gdGhpcy5tb3ZlKC0xLCBlbnRlcik7IH1cbiAgICAvKipcbiAgICBNb3ZlIHRoZSBjdXJzb3IgdG8gdGhlIGlubmVybW9zdCBub2RlIHRoYXQgY292ZXJzIGBwb3NgLiBJZlxuICAgIGBzaWRlYCBpcyAtMSwgaXQgd2lsbCBlbnRlciBub2RlcyB0aGF0IGVuZCBhdCBgcG9zYC4gSWYgaXQgaXMgMSxcbiAgICBpdCB3aWxsIGVudGVyIG5vZGVzIHRoYXQgc3RhcnQgYXQgYHBvc2AuXG4gICAgKi9cbiAgICBtb3ZlVG8ocG9zLCBzaWRlID0gMCkge1xuICAgICAgICAvLyBNb3ZlIHVwIHRvIGEgbm9kZSB0aGF0IGFjdHVhbGx5IGhvbGRzIHRoZSBwb3NpdGlvbiwgaWYgcG9zc2libGVcbiAgICAgICAgd2hpbGUgKHRoaXMuZnJvbSA9PSB0aGlzLnRvIHx8XG4gICAgICAgICAgICAoc2lkZSA8IDEgPyB0aGlzLmZyb20gPj0gcG9zIDogdGhpcy5mcm9tID4gcG9zKSB8fFxuICAgICAgICAgICAgKHNpZGUgPiAtMSA/IHRoaXMudG8gPD0gcG9zIDogdGhpcy50byA8IHBvcykpXG4gICAgICAgICAgICBpZiAoIXRoaXMucGFyZW50KCkpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIFRoZW4gc2NhbiBkb3duIGludG8gY2hpbGQgbm9kZXMgYXMgZmFyIGFzIHBvc3NpYmxlXG4gICAgICAgIHdoaWxlICh0aGlzLmVudGVyQ2hpbGQoMSwgcG9zLCBzaWRlKSkgeyB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgYSBbc3ludGF4IG5vZGVdKCNjb21tb24uU3ludGF4Tm9kZSkgYXQgdGhlIGN1cnNvcidzIGN1cnJlbnRcbiAgICBwb3NpdGlvbi5cbiAgICAqL1xuICAgIGdldCBub2RlKCkge1xuICAgICAgICBpZiAoIXRoaXMuYnVmZmVyKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RyZWU7XG4gICAgICAgIGxldCBjYWNoZSA9IHRoaXMuYnVmZmVyTm9kZSwgcmVzdWx0ID0gbnVsbCwgZGVwdGggPSAwO1xuICAgICAgICBpZiAoY2FjaGUgJiYgY2FjaGUuY29udGV4dCA9PSB0aGlzLmJ1ZmZlcikge1xuICAgICAgICAgICAgc2NhbjogZm9yIChsZXQgaW5kZXggPSB0aGlzLmluZGV4LCBkID0gdGhpcy5zdGFjay5sZW5ndGg7IGQgPj0gMDspIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjID0gY2FjaGU7IGM7IGMgPSBjLl9wYXJlbnQpXG4gICAgICAgICAgICAgICAgICAgIGlmIChjLmluZGV4ID09IGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT0gdGhpcy5pbmRleClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGM7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXB0aCA9IGQgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgc2NhbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluZGV4ID0gdGhpcy5zdGFja1stLWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSBkZXB0aDsgaSA8IHRoaXMuc3RhY2subGVuZ3RoOyBpKyspXG4gICAgICAgICAgICByZXN1bHQgPSBuZXcgQnVmZmVyTm9kZSh0aGlzLmJ1ZmZlciwgcmVzdWx0LCB0aGlzLnN0YWNrW2ldKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyTm9kZSA9IG5ldyBCdWZmZXJOb2RlKHRoaXMuYnVmZmVyLCByZXN1bHQsIHRoaXMuaW5kZXgpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIFt0cmVlXSgjY29tbW9uLlRyZWUpIHRoYXQgcmVwcmVzZW50cyB0aGUgY3VycmVudCBub2RlLCBpZlxuICAgIGFueS4gV2lsbCByZXR1cm4gbnVsbCB3aGVuIHRoZSBub2RlIGlzIGluIGEgW3RyZWVcbiAgICBidWZmZXJdKCNjb21tb24uVHJlZUJ1ZmZlcikuXG4gICAgKi9cbiAgICBnZXQgdHJlZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyID8gbnVsbCA6IHRoaXMuX3RyZWUuX3RyZWU7XG4gICAgfVxuICAgIC8qKlxuICAgIEl0ZXJhdGUgb3ZlciB0aGUgY3VycmVudCBub2RlIGFuZCBhbGwgaXRzIGRlc2NlbmRhbnRzLCBjYWxsaW5nXG4gICAgYGVudGVyYCB3aGVuIGVudGVyaW5nIGEgbm9kZSBhbmQgYGxlYXZlYCwgaWYgZ2l2ZW4sIHdoZW4gbGVhdmluZ1xuICAgIG9uZS4gV2hlbiBgZW50ZXJgIHJldHVybnMgYGZhbHNlYCwgYW55IGNoaWxkcmVuIG9mIHRoYXQgbm9kZSBhcmVcbiAgICBza2lwcGVkLCBhbmQgYGxlYXZlYCBpc24ndCBjYWxsZWQgZm9yIGl0LlxuICAgICovXG4gICAgaXRlcmF0ZShlbnRlciwgbGVhdmUpIHtcbiAgICAgICAgZm9yIChsZXQgZGVwdGggPSAwOzspIHtcbiAgICAgICAgICAgIGxldCBtdXN0TGVhdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnR5cGUuaXNBbm9ueW1vdXMgfHwgZW50ZXIodGhpcykgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZmlyc3RDaGlsZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlcHRoKys7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMudHlwZS5pc0Fub255bW91cylcbiAgICAgICAgICAgICAgICAgICAgbXVzdExlYXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICBpZiAobXVzdExlYXZlICYmIGxlYXZlKVxuICAgICAgICAgICAgICAgICAgICBsZWF2ZSh0aGlzKTtcbiAgICAgICAgICAgICAgICBtdXN0TGVhdmUgPSB0aGlzLnR5cGUuaXNBbm9ueW1vdXM7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubmV4dFNpYmxpbmcoKSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgaWYgKCFkZXB0aClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50KCk7XG4gICAgICAgICAgICAgICAgZGVwdGgtLTtcbiAgICAgICAgICAgICAgICBtdXN0TGVhdmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIFRlc3Qgd2hldGhlciB0aGUgY3VycmVudCBub2RlIG1hdGNoZXMgYSBnaXZlbiBjb250ZXh04oCUYSBzZXF1ZW5jZVxuICAgIG9mIGRpcmVjdCBwYXJlbnQgbm9kZSBuYW1lcy4gRW1wdHkgc3RyaW5ncyBpbiB0aGUgY29udGV4dCBhcnJheVxuICAgIGFyZSB0cmVhdGVkIGFzIHdpbGRjYXJkcy5cbiAgICAqL1xuICAgIG1hdGNoQ29udGV4dChjb250ZXh0KSB7XG4gICAgICAgIGlmICghdGhpcy5idWZmZXIpXG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hOb2RlQ29udGV4dCh0aGlzLm5vZGUsIGNvbnRleHQpO1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuYnVmZmVyLCB7IHR5cGVzIH0gPSBidWZmZXIuc2V0O1xuICAgICAgICBmb3IgKGxldCBpID0gY29udGV4dC5sZW5ndGggLSAxLCBkID0gdGhpcy5zdGFjay5sZW5ndGggLSAxOyBpID49IDA7IGQtLSkge1xuICAgICAgICAgICAgaWYgKGQgPCAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaE5vZGVDb250ZXh0KHRoaXMubm9kZSwgY29udGV4dCwgaSk7XG4gICAgICAgICAgICBsZXQgdHlwZSA9IHR5cGVzW2J1ZmZlci5idWZmZXJbdGhpcy5zdGFja1tkXV1dO1xuICAgICAgICAgICAgaWYgKCF0eXBlLmlzQW5vbnltb3VzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRleHRbaV0gJiYgY29udGV4dFtpXSAhPSB0eXBlLm5hbWUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuZnVuY3Rpb24gaGFzQ2hpbGQodHJlZSkge1xuICAgIHJldHVybiB0cmVlLmNoaWxkcmVuLnNvbWUoY2ggPT4gY2ggaW5zdGFuY2VvZiBUcmVlQnVmZmVyIHx8ICFjaC50eXBlLmlzQW5vbnltb3VzIHx8IGhhc0NoaWxkKGNoKSk7XG59XG5mdW5jdGlvbiBidWlsZFRyZWUoZGF0YSkge1xuICAgIHZhciBfYTtcbiAgICBsZXQgeyBidWZmZXIsIG5vZGVTZXQsIG1heEJ1ZmZlckxlbmd0aCA9IERlZmF1bHRCdWZmZXJMZW5ndGgsIHJldXNlZCA9IFtdLCBtaW5SZXBlYXRUeXBlID0gbm9kZVNldC50eXBlcy5sZW5ndGggfSA9IGRhdGE7XG4gICAgbGV0IGN1cnNvciA9IEFycmF5LmlzQXJyYXkoYnVmZmVyKSA/IG5ldyBGbGF0QnVmZmVyQ3Vyc29yKGJ1ZmZlciwgYnVmZmVyLmxlbmd0aCkgOiBidWZmZXI7XG4gICAgbGV0IHR5cGVzID0gbm9kZVNldC50eXBlcztcbiAgICBsZXQgY29udGV4dEhhc2ggPSAwLCBsb29rQWhlYWQgPSAwO1xuICAgIGZ1bmN0aW9uIHRha2VOb2RlKHBhcmVudFN0YXJ0LCBtaW5Qb3MsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGluUmVwZWF0LCBkZXB0aCkge1xuICAgICAgICBsZXQgeyBpZCwgc3RhcnQsIGVuZCwgc2l6ZSB9ID0gY3Vyc29yO1xuICAgICAgICBsZXQgbG9va0FoZWFkQXRTdGFydCA9IGxvb2tBaGVhZDtcbiAgICAgICAgd2hpbGUgKHNpemUgPCAwKSB7XG4gICAgICAgICAgICBjdXJzb3IubmV4dCgpO1xuICAgICAgICAgICAgaWYgKHNpemUgPT0gLTEgLyogU3BlY2lhbFJlY29yZC5SZXVzZSAqLykge1xuICAgICAgICAgICAgICAgIGxldCBub2RlID0gcmV1c2VkW2lkXTtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgIHBvc2l0aW9ucy5wdXNoKHN0YXJ0IC0gcGFyZW50U3RhcnQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNpemUgPT0gLTMgLyogU3BlY2lhbFJlY29yZC5Db250ZXh0Q2hhbmdlICovKSB7IC8vIENvbnRleHQgY2hhbmdlXG4gICAgICAgICAgICAgICAgY29udGV4dEhhc2ggPSBpZDtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzaXplID09IC00IC8qIFNwZWNpYWxSZWNvcmQuTG9va0FoZWFkICovKSB7XG4gICAgICAgICAgICAgICAgbG9va0FoZWFkID0gaWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFVucmVjb2duaXplZCByZWNvcmQgc2l6ZTogJHtzaXplfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCB0eXBlID0gdHlwZXNbaWRdLCBub2RlLCBidWZmZXI7XG4gICAgICAgIGxldCBzdGFydFBvcyA9IHN0YXJ0IC0gcGFyZW50U3RhcnQ7XG4gICAgICAgIGlmIChlbmQgLSBzdGFydCA8PSBtYXhCdWZmZXJMZW5ndGggJiYgKGJ1ZmZlciA9IGZpbmRCdWZmZXJTaXplKGN1cnNvci5wb3MgLSBtaW5Qb3MsIGluUmVwZWF0KSkpIHtcbiAgICAgICAgICAgIC8vIFNtYWxsIGVub3VnaCBmb3IgYSBidWZmZXIsIGFuZCBubyByZXVzZWQgbm9kZXMgaW5zaWRlXG4gICAgICAgICAgICBsZXQgZGF0YSA9IG5ldyBVaW50MTZBcnJheShidWZmZXIuc2l6ZSAtIGJ1ZmZlci5za2lwKTtcbiAgICAgICAgICAgIGxldCBlbmRQb3MgPSBjdXJzb3IucG9zIC0gYnVmZmVyLnNpemUsIGluZGV4ID0gZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoY3Vyc29yLnBvcyA+IGVuZFBvcylcbiAgICAgICAgICAgICAgICBpbmRleCA9IGNvcHlUb0J1ZmZlcihidWZmZXIuc3RhcnQsIGRhdGEsIGluZGV4KTtcbiAgICAgICAgICAgIG5vZGUgPSBuZXcgVHJlZUJ1ZmZlcihkYXRhLCBlbmQgLSBidWZmZXIuc3RhcnQsIG5vZGVTZXQpO1xuICAgICAgICAgICAgc3RhcnRQb3MgPSBidWZmZXIuc3RhcnQgLSBwYXJlbnRTdGFydDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gTWFrZSBpdCBhIG5vZGVcbiAgICAgICAgICAgIGxldCBlbmRQb3MgPSBjdXJzb3IucG9zIC0gc2l6ZTtcbiAgICAgICAgICAgIGN1cnNvci5uZXh0KCk7XG4gICAgICAgICAgICBsZXQgbG9jYWxDaGlsZHJlbiA9IFtdLCBsb2NhbFBvc2l0aW9ucyA9IFtdO1xuICAgICAgICAgICAgbGV0IGxvY2FsSW5SZXBlYXQgPSBpZCA+PSBtaW5SZXBlYXRUeXBlID8gaWQgOiAtMTtcbiAgICAgICAgICAgIGxldCBsYXN0R3JvdXAgPSAwLCBsYXN0RW5kID0gZW5kO1xuICAgICAgICAgICAgd2hpbGUgKGN1cnNvci5wb3MgPiBlbmRQb3MpIHtcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxJblJlcGVhdCA+PSAwICYmIGN1cnNvci5pZCA9PSBsb2NhbEluUmVwZWF0ICYmIGN1cnNvci5zaXplID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnNvci5lbmQgPD0gbGFzdEVuZCAtIG1heEJ1ZmZlckxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFrZVJlcGVhdExlYWYobG9jYWxDaGlsZHJlbiwgbG9jYWxQb3NpdGlvbnMsIHN0YXJ0LCBsYXN0R3JvdXAsIGN1cnNvci5lbmQsIGxhc3RFbmQsIGxvY2FsSW5SZXBlYXQsIGxvb2tBaGVhZEF0U3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEdyb3VwID0gbG9jYWxDaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0RW5kID0gY3Vyc29yLmVuZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjdXJzb3IubmV4dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChkZXB0aCA+IDI1MDAgLyogQ3V0T2ZmLkRlcHRoICovKSB7XG4gICAgICAgICAgICAgICAgICAgIHRha2VGbGF0Tm9kZShzdGFydCwgZW5kUG9zLCBsb2NhbENoaWxkcmVuLCBsb2NhbFBvc2l0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0YWtlTm9kZShzdGFydCwgZW5kUG9zLCBsb2NhbENoaWxkcmVuLCBsb2NhbFBvc2l0aW9ucywgbG9jYWxJblJlcGVhdCwgZGVwdGggKyAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobG9jYWxJblJlcGVhdCA+PSAwICYmIGxhc3RHcm91cCA+IDAgJiYgbGFzdEdyb3VwIDwgbG9jYWxDaGlsZHJlbi5sZW5ndGgpXG4gICAgICAgICAgICAgICAgbWFrZVJlcGVhdExlYWYobG9jYWxDaGlsZHJlbiwgbG9jYWxQb3NpdGlvbnMsIHN0YXJ0LCBsYXN0R3JvdXAsIHN0YXJ0LCBsYXN0RW5kLCBsb2NhbEluUmVwZWF0LCBsb29rQWhlYWRBdFN0YXJ0KTtcbiAgICAgICAgICAgIGxvY2FsQ2hpbGRyZW4ucmV2ZXJzZSgpO1xuICAgICAgICAgICAgbG9jYWxQb3NpdGlvbnMucmV2ZXJzZSgpO1xuICAgICAgICAgICAgaWYgKGxvY2FsSW5SZXBlYXQgPiAtMSAmJiBsYXN0R3JvdXAgPiAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IG1ha2UgPSBtYWtlQmFsYW5jZWQodHlwZSk7XG4gICAgICAgICAgICAgICAgbm9kZSA9IGJhbGFuY2VSYW5nZSh0eXBlLCBsb2NhbENoaWxkcmVuLCBsb2NhbFBvc2l0aW9ucywgMCwgbG9jYWxDaGlsZHJlbi5sZW5ndGgsIDAsIGVuZCAtIHN0YXJ0LCBtYWtlLCBtYWtlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBtYWtlVHJlZSh0eXBlLCBsb2NhbENoaWxkcmVuLCBsb2NhbFBvc2l0aW9ucywgZW5kIC0gc3RhcnQsIGxvb2tBaGVhZEF0U3RhcnQgLSBlbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNoaWxkcmVuLnB1c2gobm9kZSk7XG4gICAgICAgIHBvc2l0aW9ucy5wdXNoKHN0YXJ0UG9zKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdGFrZUZsYXROb2RlKHBhcmVudFN0YXJ0LCBtaW5Qb3MsIGNoaWxkcmVuLCBwb3NpdGlvbnMpIHtcbiAgICAgICAgbGV0IG5vZGVzID0gW107IC8vIFRlbXBvcmFyeSwgaW52ZXJ0ZWQgYXJyYXkgb2YgbGVhZiBub2RlcyBmb3VuZCwgd2l0aCBhYnNvbHV0ZSBwb3NpdGlvbnNcbiAgICAgICAgbGV0IG5vZGVDb3VudCA9IDAsIHN0b3BBdCA9IC0xO1xuICAgICAgICB3aGlsZSAoY3Vyc29yLnBvcyA+IG1pblBvcykge1xuICAgICAgICAgICAgbGV0IHsgaWQsIHN0YXJ0LCBlbmQsIHNpemUgfSA9IGN1cnNvcjtcbiAgICAgICAgICAgIGlmIChzaXplID4gNCkgeyAvLyBOb3QgYSBsZWFmXG4gICAgICAgICAgICAgICAgY3Vyc29yLm5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHN0b3BBdCA+IC0xICYmIHN0YXJ0IDwgc3RvcEF0KSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RvcEF0IDwgMClcbiAgICAgICAgICAgICAgICAgICAgc3RvcEF0ID0gZW5kIC0gbWF4QnVmZmVyTGVuZ3RoO1xuICAgICAgICAgICAgICAgIG5vZGVzLnB1c2goaWQsIHN0YXJ0LCBlbmQpO1xuICAgICAgICAgICAgICAgIG5vZGVDb3VudCsrO1xuICAgICAgICAgICAgICAgIGN1cnNvci5uZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGVDb3VudCkge1xuICAgICAgICAgICAgbGV0IGJ1ZmZlciA9IG5ldyBVaW50MTZBcnJheShub2RlQ291bnQgKiA0KTtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IG5vZGVzW25vZGVzLmxlbmd0aCAtIDJdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IG5vZGVzLmxlbmd0aCAtIDMsIGogPSAwOyBpID49IDA7IGkgLT0gMykge1xuICAgICAgICAgICAgICAgIGJ1ZmZlcltqKytdID0gbm9kZXNbaV07XG4gICAgICAgICAgICAgICAgYnVmZmVyW2orK10gPSBub2Rlc1tpICsgMV0gLSBzdGFydDtcbiAgICAgICAgICAgICAgICBidWZmZXJbaisrXSA9IG5vZGVzW2kgKyAyXSAtIHN0YXJ0O1xuICAgICAgICAgICAgICAgIGJ1ZmZlcltqKytdID0gajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2gobmV3IFRyZWVCdWZmZXIoYnVmZmVyLCBub2Rlc1syXSAtIHN0YXJ0LCBub2RlU2V0KSk7XG4gICAgICAgICAgICBwb3NpdGlvbnMucHVzaChzdGFydCAtIHBhcmVudFN0YXJ0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBtYWtlQmFsYW5jZWQodHlwZSkge1xuICAgICAgICByZXR1cm4gKGNoaWxkcmVuLCBwb3NpdGlvbnMsIGxlbmd0aCkgPT4ge1xuICAgICAgICAgICAgbGV0IGxvb2tBaGVhZCA9IDAsIGxhc3RJID0gY2hpbGRyZW4ubGVuZ3RoIC0gMSwgbGFzdCwgbG9va0FoZWFkUHJvcDtcbiAgICAgICAgICAgIGlmIChsYXN0SSA+PSAwICYmIChsYXN0ID0gY2hpbGRyZW5bbGFzdEldKSBpbnN0YW5jZW9mIFRyZWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWxhc3RJICYmIGxhc3QudHlwZSA9PSB0eXBlICYmIGxhc3QubGVuZ3RoID09IGxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxhc3Q7XG4gICAgICAgICAgICAgICAgaWYgKGxvb2tBaGVhZFByb3AgPSBsYXN0LnByb3AoTm9kZVByb3AubG9va0FoZWFkKSlcbiAgICAgICAgICAgICAgICAgICAgbG9va0FoZWFkID0gcG9zaXRpb25zW2xhc3RJXSArIGxhc3QubGVuZ3RoICsgbG9va0FoZWFkUHJvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYWtlVHJlZSh0eXBlLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBsZW5ndGgsIGxvb2tBaGVhZCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1ha2VSZXBlYXRMZWFmKGNoaWxkcmVuLCBwb3NpdGlvbnMsIGJhc2UsIGksIGZyb20sIHRvLCB0eXBlLCBsb29rQWhlYWQpIHtcbiAgICAgICAgbGV0IGxvY2FsQ2hpbGRyZW4gPSBbXSwgbG9jYWxQb3NpdGlvbnMgPSBbXTtcbiAgICAgICAgd2hpbGUgKGNoaWxkcmVuLmxlbmd0aCA+IGkpIHtcbiAgICAgICAgICAgIGxvY2FsQ2hpbGRyZW4ucHVzaChjaGlsZHJlbi5wb3AoKSk7XG4gICAgICAgICAgICBsb2NhbFBvc2l0aW9ucy5wdXNoKHBvc2l0aW9ucy5wb3AoKSArIGJhc2UgLSBmcm9tKTtcbiAgICAgICAgfVxuICAgICAgICBjaGlsZHJlbi5wdXNoKG1ha2VUcmVlKG5vZGVTZXQudHlwZXNbdHlwZV0sIGxvY2FsQ2hpbGRyZW4sIGxvY2FsUG9zaXRpb25zLCB0byAtIGZyb20sIGxvb2tBaGVhZCAtIHRvKSk7XG4gICAgICAgIHBvc2l0aW9ucy5wdXNoKGZyb20gLSBiYXNlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFrZVRyZWUodHlwZSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgbGVuZ3RoLCBsb29rQWhlYWQgPSAwLCBwcm9wcykge1xuICAgICAgICBpZiAoY29udGV4dEhhc2gpIHtcbiAgICAgICAgICAgIGxldCBwYWlyID0gW05vZGVQcm9wLmNvbnRleHRIYXNoLCBjb250ZXh0SGFzaF07XG4gICAgICAgICAgICBwcm9wcyA9IHByb3BzID8gW3BhaXJdLmNvbmNhdChwcm9wcykgOiBbcGFpcl07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvb2tBaGVhZCA+IDI1KSB7XG4gICAgICAgICAgICBsZXQgcGFpciA9IFtOb2RlUHJvcC5sb29rQWhlYWQsIGxvb2tBaGVhZF07XG4gICAgICAgICAgICBwcm9wcyA9IHByb3BzID8gW3BhaXJdLmNvbmNhdChwcm9wcykgOiBbcGFpcl07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlKHR5cGUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGxlbmd0aCwgcHJvcHMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmaW5kQnVmZmVyU2l6ZShtYXhTaXplLCBpblJlcGVhdCkge1xuICAgICAgICAvLyBTY2FuIHRocm91Z2ggdGhlIGJ1ZmZlciB0byBmaW5kIHByZXZpb3VzIHNpYmxpbmdzIHRoYXQgZml0XG4gICAgICAgIC8vIHRvZ2V0aGVyIGluIGEgVHJlZUJ1ZmZlciwgYW5kIGRvbid0IGNvbnRhaW4gYW55IHJldXNlZCBub2Rlc1xuICAgICAgICAvLyAod2hpY2ggY2FuJ3QgYmUgc3RvcmVkIGluIGEgYnVmZmVyKS5cbiAgICAgICAgLy8gSWYgYGluUmVwZWF0YCBpcyA+IC0xLCBpZ25vcmUgbm9kZSBib3VuZGFyaWVzIG9mIHRoYXQgdHlwZSBmb3JcbiAgICAgICAgLy8gbmVzdGluZywgYnV0IG1ha2Ugc3VyZSB0aGUgZW5kIGZhbGxzIGVpdGhlciBhdCB0aGUgc3RhcnRcbiAgICAgICAgLy8gKGBtYXhTaXplYCkgb3IgYmVmb3JlIHN1Y2ggYSBub2RlLlxuICAgICAgICBsZXQgZm9yayA9IGN1cnNvci5mb3JrKCk7XG4gICAgICAgIGxldCBzaXplID0gMCwgc3RhcnQgPSAwLCBza2lwID0gMCwgbWluU3RhcnQgPSBmb3JrLmVuZCAtIG1heEJ1ZmZlckxlbmd0aDtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgc2l6ZTogMCwgc3RhcnQ6IDAsIHNraXA6IDAgfTtcbiAgICAgICAgc2NhbjogZm9yIChsZXQgbWluUG9zID0gZm9yay5wb3MgLSBtYXhTaXplOyBmb3JrLnBvcyA+IG1pblBvczspIHtcbiAgICAgICAgICAgIGxldCBub2RlU2l6ZSA9IGZvcmsuc2l6ZTtcbiAgICAgICAgICAgIC8vIFByZXRlbmQgbmVzdGVkIHJlcGVhdCBub2RlcyBvZiB0aGUgc2FtZSB0eXBlIGRvbid0IGV4aXN0XG4gICAgICAgICAgICBpZiAoZm9yay5pZCA9PSBpblJlcGVhdCAmJiBub2RlU2l6ZSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gRXhjZXB0IHRoYXQgd2Ugc3RvcmUgdGhlIGN1cnJlbnQgc3RhdGUgYXMgYSB2YWxpZCByZXR1cm5cbiAgICAgICAgICAgICAgICAvLyB2YWx1ZS5cbiAgICAgICAgICAgICAgICByZXN1bHQuc2l6ZSA9IHNpemU7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnNraXAgPSBza2lwO1xuICAgICAgICAgICAgICAgIHNraXAgKz0gNDtcbiAgICAgICAgICAgICAgICBzaXplICs9IDQ7XG4gICAgICAgICAgICAgICAgZm9yay5uZXh0KCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgc3RhcnRQb3MgPSBmb3JrLnBvcyAtIG5vZGVTaXplO1xuICAgICAgICAgICAgaWYgKG5vZGVTaXplIDwgMCB8fCBzdGFydFBvcyA8IG1pblBvcyB8fCBmb3JrLnN0YXJ0IDwgbWluU3RhcnQpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBsZXQgbG9jYWxTa2lwcGVkID0gZm9yay5pZCA+PSBtaW5SZXBlYXRUeXBlID8gNCA6IDA7XG4gICAgICAgICAgICBsZXQgbm9kZVN0YXJ0ID0gZm9yay5zdGFydDtcbiAgICAgICAgICAgIGZvcmsubmV4dCgpO1xuICAgICAgICAgICAgd2hpbGUgKGZvcmsucG9zID4gc3RhcnRQb3MpIHtcbiAgICAgICAgICAgICAgICBpZiAoZm9yay5zaXplIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZm9yay5zaXplID09IC0zIC8qIFNwZWNpYWxSZWNvcmQuQ29udGV4dENoYW5nZSAqLylcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsU2tpcHBlZCArPSA0O1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhayBzY2FuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmb3JrLmlkID49IG1pblJlcGVhdFR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxTa2lwcGVkICs9IDQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvcmsubmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhcnQgPSBub2RlU3RhcnQ7XG4gICAgICAgICAgICBzaXplICs9IG5vZGVTaXplO1xuICAgICAgICAgICAgc2tpcCArPSBsb2NhbFNraXBwZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluUmVwZWF0IDwgMCB8fCBzaXplID09IG1heFNpemUpIHtcbiAgICAgICAgICAgIHJlc3VsdC5zaXplID0gc2l6ZTtcbiAgICAgICAgICAgIHJlc3VsdC5zdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgcmVzdWx0LnNraXAgPSBza2lwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQuc2l6ZSA+IDQgPyByZXN1bHQgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvcHlUb0J1ZmZlcihidWZmZXJTdGFydCwgYnVmZmVyLCBpbmRleCkge1xuICAgICAgICBsZXQgeyBpZCwgc3RhcnQsIGVuZCwgc2l6ZSB9ID0gY3Vyc29yO1xuICAgICAgICBjdXJzb3IubmV4dCgpO1xuICAgICAgICBpZiAoc2l6ZSA+PSAwICYmIGlkIDwgbWluUmVwZWF0VHlwZSkge1xuICAgICAgICAgICAgbGV0IHN0YXJ0SW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgIGlmIChzaXplID4gNCkge1xuICAgICAgICAgICAgICAgIGxldCBlbmRQb3MgPSBjdXJzb3IucG9zIC0gKHNpemUgLSA0KTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoY3Vyc29yLnBvcyA+IGVuZFBvcylcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBjb3B5VG9CdWZmZXIoYnVmZmVyU3RhcnQsIGJ1ZmZlciwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVmZmVyWy0taW5kZXhdID0gc3RhcnRJbmRleDtcbiAgICAgICAgICAgIGJ1ZmZlclstLWluZGV4XSA9IGVuZCAtIGJ1ZmZlclN0YXJ0O1xuICAgICAgICAgICAgYnVmZmVyWy0taW5kZXhdID0gc3RhcnQgLSBidWZmZXJTdGFydDtcbiAgICAgICAgICAgIGJ1ZmZlclstLWluZGV4XSA9IGlkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNpemUgPT0gLTMgLyogU3BlY2lhbFJlY29yZC5Db250ZXh0Q2hhbmdlICovKSB7XG4gICAgICAgICAgICBjb250ZXh0SGFzaCA9IGlkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNpemUgPT0gLTQgLyogU3BlY2lhbFJlY29yZC5Mb29rQWhlYWQgKi8pIHtcbiAgICAgICAgICAgIGxvb2tBaGVhZCA9IGlkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gICAgbGV0IGNoaWxkcmVuID0gW10sIHBvc2l0aW9ucyA9IFtdO1xuICAgIHdoaWxlIChjdXJzb3IucG9zID4gMClcbiAgICAgICAgdGFrZU5vZGUoZGF0YS5zdGFydCB8fCAwLCBkYXRhLmJ1ZmZlclN0YXJ0IHx8IDAsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIC0xLCAwKTtcbiAgICBsZXQgbGVuZ3RoID0gKF9hID0gZGF0YS5sZW5ndGgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChjaGlsZHJlbi5sZW5ndGggPyBwb3NpdGlvbnNbMF0gKyBjaGlsZHJlblswXS5sZW5ndGggOiAwKTtcbiAgICByZXR1cm4gbmV3IFRyZWUodHlwZXNbZGF0YS50b3BJRF0sIGNoaWxkcmVuLnJldmVyc2UoKSwgcG9zaXRpb25zLnJldmVyc2UoKSwgbGVuZ3RoKTtcbn1cbmNvbnN0IG5vZGVTaXplQ2FjaGUgPSBuZXcgV2Vha01hcDtcbmZ1bmN0aW9uIG5vZGVTaXplKGJhbGFuY2VUeXBlLCBub2RlKSB7XG4gICAgaWYgKCFiYWxhbmNlVHlwZS5pc0Fub255bW91cyB8fCBub2RlIGluc3RhbmNlb2YgVHJlZUJ1ZmZlciB8fCBub2RlLnR5cGUgIT0gYmFsYW5jZVR5cGUpXG4gICAgICAgIHJldHVybiAxO1xuICAgIGxldCBzaXplID0gbm9kZVNpemVDYWNoZS5nZXQobm9kZSk7XG4gICAgaWYgKHNpemUgPT0gbnVsbCkge1xuICAgICAgICBzaXplID0gMTtcbiAgICAgICAgZm9yIChsZXQgY2hpbGQgb2Ygbm9kZS5jaGlsZHJlbikge1xuICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUgIT0gYmFsYW5jZVR5cGUgfHwgIShjaGlsZCBpbnN0YW5jZW9mIFRyZWUpKSB7XG4gICAgICAgICAgICAgICAgc2l6ZSA9IDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzaXplICs9IG5vZGVTaXplKGJhbGFuY2VUeXBlLCBjaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZVNpemVDYWNoZS5zZXQobm9kZSwgc2l6ZSk7XG4gICAgfVxuICAgIHJldHVybiBzaXplO1xufVxuZnVuY3Rpb24gYmFsYW5jZVJhbmdlKFxuLy8gVGhlIHR5cGUgdGhlIGJhbGFuY2VkIHRyZWUncyBpbm5lciBub2Rlcy5cbmJhbGFuY2VUeXBlLCBcbi8vIFRoZSBkaXJlY3QgY2hpbGRyZW4gYW5kIHRoZWlyIHBvc2l0aW9uc1xuY2hpbGRyZW4sIHBvc2l0aW9ucywgXG4vLyBUaGUgaW5kZXggcmFuZ2UgaW4gY2hpbGRyZW4vcG9zaXRpb25zIHRvIHVzZVxuZnJvbSwgdG8sIFxuLy8gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSBub2RlcywgcmVsYXRpdmUgdG8gdGhlaXIgcGFyZW50Llxuc3RhcnQsIFxuLy8gTGVuZ3RoIG9mIHRoZSBvdXRlciBub2RlXG5sZW5ndGgsIFxuLy8gRnVuY3Rpb24gdG8gYnVpbGQgdGhlIHRvcCBub2RlIG9mIHRoZSBiYWxhbmNlZCB0cmVlXG5ta1RvcCwgXG4vLyBGdW5jdGlvbiB0byBidWlsZCBpbnRlcm5hbCBub2RlcyBmb3IgdGhlIGJhbGFuY2VkIHRyZWVcbm1rVHJlZSkge1xuICAgIGxldCB0b3RhbCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IGZyb207IGkgPCB0bzsgaSsrKVxuICAgICAgICB0b3RhbCArPSBub2RlU2l6ZShiYWxhbmNlVHlwZSwgY2hpbGRyZW5baV0pO1xuICAgIGxldCBtYXhDaGlsZCA9IE1hdGguY2VpbCgodG90YWwgKiAxLjUpIC8gOCAvKiBCYWxhbmNlLkJyYW5jaEZhY3RvciAqLyk7XG4gICAgbGV0IGxvY2FsQ2hpbGRyZW4gPSBbXSwgbG9jYWxQb3NpdGlvbnMgPSBbXTtcbiAgICBmdW5jdGlvbiBkaXZpZGUoY2hpbGRyZW4sIHBvc2l0aW9ucywgZnJvbSwgdG8sIG9mZnNldCkge1xuICAgICAgICBmb3IgKGxldCBpID0gZnJvbTsgaSA8IHRvOykge1xuICAgICAgICAgICAgbGV0IGdyb3VwRnJvbSA9IGksIGdyb3VwU3RhcnQgPSBwb3NpdGlvbnNbaV0sIGdyb3VwU2l6ZSA9IG5vZGVTaXplKGJhbGFuY2VUeXBlLCBjaGlsZHJlbltpXSk7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBmb3IgKDsgaSA8IHRvOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dFNpemUgPSBub2RlU2l6ZShiYWxhbmNlVHlwZSwgY2hpbGRyZW5baV0pO1xuICAgICAgICAgICAgICAgIGlmIChncm91cFNpemUgKyBuZXh0U2l6ZSA+PSBtYXhDaGlsZClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZ3JvdXBTaXplICs9IG5leHRTaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgPT0gZ3JvdXBGcm9tICsgMSkge1xuICAgICAgICAgICAgICAgIGlmIChncm91cFNpemUgPiBtYXhDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgb25seSA9IGNoaWxkcmVuW2dyb3VwRnJvbV07IC8vIE9ubHkgdHJlZXMgY2FuIGhhdmUgYSBzaXplID4gMVxuICAgICAgICAgICAgICAgICAgICBkaXZpZGUob25seS5jaGlsZHJlbiwgb25seS5wb3NpdGlvbnMsIDAsIG9ubHkuY2hpbGRyZW4ubGVuZ3RoLCBwb3NpdGlvbnNbZ3JvdXBGcm9tXSArIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsb2NhbENoaWxkcmVuLnB1c2goY2hpbGRyZW5bZ3JvdXBGcm9tXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgbGVuZ3RoID0gcG9zaXRpb25zW2kgLSAxXSArIGNoaWxkcmVuW2kgLSAxXS5sZW5ndGggLSBncm91cFN0YXJ0O1xuICAgICAgICAgICAgICAgIGxvY2FsQ2hpbGRyZW4ucHVzaChiYWxhbmNlUmFuZ2UoYmFsYW5jZVR5cGUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGdyb3VwRnJvbSwgaSwgZ3JvdXBTdGFydCwgbGVuZ3RoLCBudWxsLCBta1RyZWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvY2FsUG9zaXRpb25zLnB1c2goZ3JvdXBTdGFydCArIG9mZnNldCAtIHN0YXJ0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkaXZpZGUoY2hpbGRyZW4sIHBvc2l0aW9ucywgZnJvbSwgdG8sIDApO1xuICAgIHJldHVybiAobWtUb3AgfHwgbWtUcmVlKShsb2NhbENoaWxkcmVuLCBsb2NhbFBvc2l0aW9ucywgbGVuZ3RoKTtcbn1cbi8qKlxuUHJvdmlkZXMgYSB3YXkgdG8gYXNzb2NpYXRlIHZhbHVlcyB3aXRoIHBpZWNlcyBvZiB0cmVlcy4gQXMgbG9uZ1xuYXMgdGhhdCBwYXJ0IG9mIHRoZSB0cmVlIGlzIHJldXNlZCwgdGhlIGFzc29jaWF0ZWQgdmFsdWVzIGNhbiBiZVxucmV0cmlldmVkIGZyb20gYW4gdXBkYXRlZCB0cmVlLlxuKi9cbmNsYXNzIE5vZGVXZWFrTWFwIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5tYXAgPSBuZXcgV2Vha01hcCgpO1xuICAgIH1cbiAgICBzZXRCdWZmZXIoYnVmZmVyLCBpbmRleCwgdmFsdWUpIHtcbiAgICAgICAgbGV0IGlubmVyID0gdGhpcy5tYXAuZ2V0KGJ1ZmZlcik7XG4gICAgICAgIGlmICghaW5uZXIpXG4gICAgICAgICAgICB0aGlzLm1hcC5zZXQoYnVmZmVyLCBpbm5lciA9IG5ldyBNYXApO1xuICAgICAgICBpbm5lci5zZXQoaW5kZXgsIHZhbHVlKTtcbiAgICB9XG4gICAgZ2V0QnVmZmVyKGJ1ZmZlciwgaW5kZXgpIHtcbiAgICAgICAgbGV0IGlubmVyID0gdGhpcy5tYXAuZ2V0KGJ1ZmZlcik7XG4gICAgICAgIHJldHVybiBpbm5lciAmJiBpbm5lci5nZXQoaW5kZXgpO1xuICAgIH1cbiAgICAvKipcbiAgICBTZXQgdGhlIHZhbHVlIGZvciB0aGlzIHN5bnRheCBub2RlLlxuICAgICovXG4gICAgc2V0KG5vZGUsIHZhbHVlKSB7XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQnVmZmVyTm9kZSlcbiAgICAgICAgICAgIHRoaXMuc2V0QnVmZmVyKG5vZGUuY29udGV4dC5idWZmZXIsIG5vZGUuaW5kZXgsIHZhbHVlKTtcbiAgICAgICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIFRyZWVOb2RlKVxuICAgICAgICAgICAgdGhpcy5tYXAuc2V0KG5vZGUudHJlZSwgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXRyaWV2ZSB2YWx1ZSBmb3IgdGhpcyBzeW50YXggbm9kZSwgaWYgaXQgZXhpc3RzIGluIHRoZSBtYXAuXG4gICAgKi9cbiAgICBnZXQobm9kZSkge1xuICAgICAgICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIEJ1ZmZlck5vZGUgPyB0aGlzLmdldEJ1ZmZlcihub2RlLmNvbnRleHQuYnVmZmVyLCBub2RlLmluZGV4KVxuICAgICAgICAgICAgOiBub2RlIGluc3RhbmNlb2YgVHJlZU5vZGUgPyB0aGlzLm1hcC5nZXQobm9kZS50cmVlKSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgU2V0IHRoZSB2YWx1ZSBmb3IgdGhlIG5vZGUgdGhhdCBhIGN1cnNvciBjdXJyZW50bHkgcG9pbnRzIHRvLlxuICAgICovXG4gICAgY3Vyc29yU2V0KGN1cnNvciwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGN1cnNvci5idWZmZXIpXG4gICAgICAgICAgICB0aGlzLnNldEJ1ZmZlcihjdXJzb3IuYnVmZmVyLmJ1ZmZlciwgY3Vyc29yLmluZGV4LCB2YWx1ZSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMubWFwLnNldChjdXJzb3IudHJlZSwgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXRyaWV2ZSB0aGUgdmFsdWUgZm9yIHRoZSBub2RlIHRoYXQgYSBjdXJzb3IgY3VycmVudGx5IHBvaW50c1xuICAgIHRvLlxuICAgICovXG4gICAgY3Vyc29yR2V0KGN1cnNvcikge1xuICAgICAgICByZXR1cm4gY3Vyc29yLmJ1ZmZlciA/IHRoaXMuZ2V0QnVmZmVyKGN1cnNvci5idWZmZXIuYnVmZmVyLCBjdXJzb3IuaW5kZXgpIDogdGhpcy5tYXAuZ2V0KGN1cnNvci50cmVlKTtcbiAgICB9XG59XG5cbi8qKlxuVHJlZSBmcmFnbWVudHMgYXJlIHVzZWQgZHVyaW5nIFtpbmNyZW1lbnRhbFxucGFyc2luZ10oI2NvbW1vbi5QYXJzZXIuc3RhcnRQYXJzZSkgdG8gdHJhY2sgcGFydHMgb2Ygb2xkIHRyZWVzXG50aGF0IGNhbiBiZSByZXVzZWQgaW4gYSBuZXcgcGFyc2UuIEFuIGFycmF5IG9mIGZyYWdtZW50cyBpcyB1c2VkXG50byB0cmFjayByZWdpb25zIG9mIGFuIG9sZCB0cmVlIHdob3NlIG5vZGVzIG1pZ2h0IGJlIHJldXNlZCBpbiBuZXdcbnBhcnNlcy4gVXNlIHRoZSBzdGF0aWNcbltgYXBwbHlDaGFuZ2VzYF0oI2NvbW1vbi5UcmVlRnJhZ21lbnReYXBwbHlDaGFuZ2VzKSBtZXRob2QgdG9cbnVwZGF0ZSBmcmFnbWVudHMgZm9yIGRvY3VtZW50IGNoYW5nZXMuXG4qL1xuY2xhc3MgVHJlZUZyYWdtZW50IHtcbiAgICAvKipcbiAgICBDb25zdHJ1Y3QgYSB0cmVlIGZyYWdtZW50LiBZb3UnbGwgdXN1YWxseSB3YW50IHRvIHVzZVxuICAgIFtgYWRkVHJlZWBdKCNjb21tb24uVHJlZUZyYWdtZW50XmFkZFRyZWUpIGFuZFxuICAgIFtgYXBwbHlDaGFuZ2VzYF0oI2NvbW1vbi5UcmVlRnJhZ21lbnReYXBwbHlDaGFuZ2VzKSBpbnN0ZWFkIG9mXG4gICAgY2FsbGluZyB0aGlzIGRpcmVjdGx5LlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHN0YXJ0IG9mIHRoZSB1bmNoYW5nZWQgcmFuZ2UgcG9pbnRlZCB0byBieSB0aGlzIGZyYWdtZW50LlxuICAgIFRoaXMgcmVmZXJzIHRvIGFuIG9mZnNldCBpbiB0aGUgX3VwZGF0ZWRfIGRvY3VtZW50IChhcyBvcHBvc2VkXG4gICAgdG8gdGhlIG9yaWdpbmFsIHRyZWUpLlxuICAgICovXG4gICAgZnJvbSwgXG4gICAgLyoqXG4gICAgVGhlIGVuZCBvZiB0aGUgdW5jaGFuZ2VkIHJhbmdlLlxuICAgICovXG4gICAgdG8sIFxuICAgIC8qKlxuICAgIFRoZSB0cmVlIHRoYXQgdGhpcyBmcmFnbWVudCBpcyBiYXNlZCBvbi5cbiAgICAqL1xuICAgIHRyZWUsIFxuICAgIC8qKlxuICAgIFRoZSBvZmZzZXQgYmV0d2VlbiB0aGUgZnJhZ21lbnQncyB0cmVlIGFuZCB0aGUgZG9jdW1lbnQgdGhhdFxuICAgIHRoaXMgZnJhZ21lbnQgY2FuIGJlIHVzZWQgYWdhaW5zdC4gQWRkIHRoaXMgd2hlbiBnb2luZyBmcm9tXG4gICAgZG9jdW1lbnQgdG8gdHJlZSBwb3NpdGlvbnMsIHN1YnRyYWN0IGl0IHRvIGdvIGZyb20gdHJlZSB0b1xuICAgIGRvY3VtZW50IHBvc2l0aW9ucy5cbiAgICAqL1xuICAgIG9mZnNldCwgb3BlblN0YXJ0ID0gZmFsc2UsIG9wZW5FbmQgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMudHJlZSA9IHRyZWU7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICB0aGlzLm9wZW4gPSAob3BlblN0YXJ0ID8gMSAvKiBPcGVuLlN0YXJ0ICovIDogMCkgfCAob3BlbkVuZCA/IDIgLyogT3Blbi5FbmQgKi8gOiAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgV2hldGhlciB0aGUgc3RhcnQgb2YgdGhlIGZyYWdtZW50IHJlcHJlc2VudHMgdGhlIHN0YXJ0IG9mIGFcbiAgICBwYXJzZSwgb3IgdGhlIGVuZCBvZiBhIGNoYW5nZS4gKEluIHRoZSBzZWNvbmQgY2FzZSwgaXQgbWF5IG5vdFxuICAgIGJlIHNhZmUgdG8gcmV1c2Ugc29tZSBub2RlcyBhdCB0aGUgc3RhcnQsIGRlcGVuZGluZyBvbiB0aGVcbiAgICBwYXJzaW5nIGFsZ29yaXRobS4pXG4gICAgKi9cbiAgICBnZXQgb3BlblN0YXJ0KCkgeyByZXR1cm4gKHRoaXMub3BlbiAmIDEgLyogT3Blbi5TdGFydCAqLykgPiAwOyB9XG4gICAgLyoqXG4gICAgV2hldGhlciB0aGUgZW5kIG9mIHRoZSBmcmFnbWVudCByZXByZXNlbnRzIHRoZSBlbmQgb2YgYVxuICAgIGZ1bGwtZG9jdW1lbnQgcGFyc2UsIG9yIHRoZSBzdGFydCBvZiBhIGNoYW5nZS5cbiAgICAqL1xuICAgIGdldCBvcGVuRW5kKCkgeyByZXR1cm4gKHRoaXMub3BlbiAmIDIgLyogT3Blbi5FbmQgKi8pID4gMDsgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHNldCBvZiBmcmFnbWVudHMgZnJvbSBhIGZyZXNobHkgcGFyc2VkIHRyZWUsIG9yIHVwZGF0ZVxuICAgIGFuIGV4aXN0aW5nIHNldCBvZiBmcmFnbWVudHMgYnkgcmVwbGFjaW5nIHRoZSBvbmVzIHRoYXQgb3ZlcmxhcFxuICAgIHdpdGggYSB0cmVlIHdpdGggY29udGVudCBmcm9tIHRoZSBuZXcgdHJlZS4gV2hlbiBgcGFydGlhbGAgaXNcbiAgICB0cnVlLCB0aGUgcGFyc2UgaXMgdHJlYXRlZCBhcyBpbmNvbXBsZXRlLCBhbmQgdGhlIHJlc3VsdGluZ1xuICAgIGZyYWdtZW50IGhhcyBbYG9wZW5FbmRgXSgjY29tbW9uLlRyZWVGcmFnbWVudC5vcGVuRW5kKSBzZXQgdG9cbiAgICB0cnVlLlxuICAgICovXG4gICAgc3RhdGljIGFkZFRyZWUodHJlZSwgZnJhZ21lbnRzID0gW10sIHBhcnRpYWwgPSBmYWxzZSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gW25ldyBUcmVlRnJhZ21lbnQoMCwgdHJlZS5sZW5ndGgsIHRyZWUsIDAsIGZhbHNlLCBwYXJ0aWFsKV07XG4gICAgICAgIGZvciAobGV0IGYgb2YgZnJhZ21lbnRzKVxuICAgICAgICAgICAgaWYgKGYudG8gPiB0cmVlLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChmKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgQXBwbHkgYSBzZXQgb2YgZWRpdHMgdG8gYW4gYXJyYXkgb2YgZnJhZ21lbnRzLCByZW1vdmluZyBvclxuICAgIHNwbGl0dGluZyBmcmFnbWVudHMgYXMgbmVjZXNzYXJ5IHRvIHJlbW92ZSBlZGl0ZWQgcmFuZ2VzLCBhbmRcbiAgICBhZGp1c3Rpbmcgb2Zmc2V0cyBmb3IgZnJhZ21lbnRzIHRoYXQgbW92ZWQuXG4gICAgKi9cbiAgICBzdGF0aWMgYXBwbHlDaGFuZ2VzKGZyYWdtZW50cywgY2hhbmdlcywgbWluR2FwID0gMTI4KSB7XG4gICAgICAgIGlmICghY2hhbmdlcy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZnJhZ21lbnRzO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGxldCBmSSA9IDEsIG5leHRGID0gZnJhZ21lbnRzLmxlbmd0aCA/IGZyYWdtZW50c1swXSA6IG51bGw7XG4gICAgICAgIGZvciAobGV0IGNJID0gMCwgcG9zID0gMCwgb2ZmID0gMDs7IGNJKyspIHtcbiAgICAgICAgICAgIGxldCBuZXh0QyA9IGNJIDwgY2hhbmdlcy5sZW5ndGggPyBjaGFuZ2VzW2NJXSA6IG51bGw7XG4gICAgICAgICAgICBsZXQgbmV4dFBvcyA9IG5leHRDID8gbmV4dEMuZnJvbUEgOiAxZTk7XG4gICAgICAgICAgICBpZiAobmV4dFBvcyAtIHBvcyA+PSBtaW5HYXApXG4gICAgICAgICAgICAgICAgd2hpbGUgKG5leHRGICYmIG5leHRGLmZyb20gPCBuZXh0UG9zKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjdXQgPSBuZXh0RjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcyA+PSBjdXQuZnJvbSB8fCBuZXh0UG9zIDw9IGN1dC50byB8fCBvZmYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmRnJvbSA9IE1hdGgubWF4KGN1dC5mcm9tLCBwb3MpIC0gb2ZmLCBmVG8gPSBNYXRoLm1pbihjdXQudG8sIG5leHRQb3MpIC0gb2ZmO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3V0ID0gZkZyb20gPj0gZlRvID8gbnVsbCA6IG5ldyBUcmVlRnJhZ21lbnQoZkZyb20sIGZUbywgY3V0LnRyZWUsIGN1dC5vZmZzZXQgKyBvZmYsIGNJID4gMCwgISFuZXh0Qyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1dClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGN1dCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0Ri50byA+IG5leHRQb3MpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgbmV4dEYgPSBmSSA8IGZyYWdtZW50cy5sZW5ndGggPyBmcmFnbWVudHNbZkkrK10gOiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbmV4dEMpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBwb3MgPSBuZXh0Qy50b0E7XG4gICAgICAgICAgICBvZmYgPSBuZXh0Qy50b0EgLSBuZXh0Qy50b0I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG4vKipcbkEgc3VwZXJjbGFzcyB0aGF0IHBhcnNlcnMgc2hvdWxkIGV4dGVuZC5cbiovXG5jbGFzcyBQYXJzZXIge1xuICAgIC8qKlxuICAgIFN0YXJ0IGEgcGFyc2UsIHJldHVybmluZyBhIFtwYXJ0aWFsIHBhcnNlXSgjY29tbW9uLlBhcnRpYWxQYXJzZSlcbiAgICBvYmplY3QuIFtgZnJhZ21lbnRzYF0oI2NvbW1vbi5UcmVlRnJhZ21lbnQpIGNhbiBiZSBwYXNzZWQgaW4gdG9cbiAgICBtYWtlIHRoZSBwYXJzZSBpbmNyZW1lbnRhbC5cbiAgICBcbiAgICBCeSBkZWZhdWx0LCB0aGUgZW50aXJlIGlucHV0IGlzIHBhcnNlZC4gWW91IGNhbiBwYXNzIGByYW5nZXNgLFxuICAgIHdoaWNoIHNob3VsZCBiZSBhIHNvcnRlZCBhcnJheSBvZiBub24tZW1wdHksIG5vbi1vdmVybGFwcGluZ1xuICAgIHJhbmdlcywgdG8gcGFyc2Ugb25seSB0aG9zZSByYW5nZXMuIFRoZSB0cmVlIHJldHVybmVkIGluIHRoYXRcbiAgICBjYXNlIHdpbGwgc3RhcnQgYXQgYHJhbmdlc1swXS5mcm9tYC5cbiAgICAqL1xuICAgIHN0YXJ0UGFyc2UoaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIGlucHV0ID0gbmV3IFN0cmluZ0lucHV0KGlucHV0KTtcbiAgICAgICAgcmFuZ2VzID0gIXJhbmdlcyA/IFtuZXcgUmFuZ2UoMCwgaW5wdXQubGVuZ3RoKV0gOiByYW5nZXMubGVuZ3RoID8gcmFuZ2VzLm1hcChyID0+IG5ldyBSYW5nZShyLmZyb20sIHIudG8pKSA6IFtuZXcgUmFuZ2UoMCwgMCldO1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVQYXJzZShpbnB1dCwgZnJhZ21lbnRzIHx8IFtdLCByYW5nZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICBSdW4gYSBmdWxsIHBhcnNlLCByZXR1cm5pbmcgdGhlIHJlc3VsdGluZyB0cmVlLlxuICAgICovXG4gICAgcGFyc2UoaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKSB7XG4gICAgICAgIGxldCBwYXJzZSA9IHRoaXMuc3RhcnRQYXJzZShpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgZG9uZSA9IHBhcnNlLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIGlmIChkb25lKVxuICAgICAgICAgICAgICAgIHJldHVybiBkb25lO1xuICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgU3RyaW5nSW5wdXQge1xuICAgIGNvbnN0cnVjdG9yKHN0cmluZykge1xuICAgICAgICB0aGlzLnN0cmluZyA9IHN0cmluZztcbiAgICB9XG4gICAgZ2V0IGxlbmd0aCgpIHsgcmV0dXJuIHRoaXMuc3RyaW5nLmxlbmd0aDsgfVxuICAgIGNodW5rKGZyb20pIHsgcmV0dXJuIHRoaXMuc3RyaW5nLnNsaWNlKGZyb20pOyB9XG4gICAgZ2V0IGxpbmVDaHVua3MoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIHJlYWQoZnJvbSwgdG8pIHsgcmV0dXJuIHRoaXMuc3RyaW5nLnNsaWNlKGZyb20sIHRvKTsgfVxufVxuXG4vKipcbkNyZWF0ZSBhIHBhcnNlIHdyYXBwZXIgdGhhdCwgYWZ0ZXIgdGhlIGlubmVyIHBhcnNlIGNvbXBsZXRlcyxcbnNjYW5zIGl0cyB0cmVlIGZvciBtaXhlZCBsYW5ndWFnZSByZWdpb25zIHdpdGggdGhlIGBuZXN0YFxuZnVuY3Rpb24sIHJ1bnMgdGhlIHJlc3VsdGluZyBbaW5uZXIgcGFyc2VzXSgjY29tbW9uLk5lc3RlZFBhcnNlKSxcbmFuZCB0aGVuIFttb3VudHNdKCNjb21tb24uTm9kZVByb3BebW91bnRlZCkgdGhlaXIgcmVzdWx0cyBvbnRvIHRoZVxudHJlZS5cbiovXG5mdW5jdGlvbiBwYXJzZU1peGVkKG5lc3QpIHtcbiAgICByZXR1cm4gKHBhcnNlLCBpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpID0+IG5ldyBNaXhlZFBhcnNlKHBhcnNlLCBuZXN0LCBpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpO1xufVxuY2xhc3MgSW5uZXJQYXJzZSB7XG4gICAgY29uc3RydWN0b3IocGFyc2VyLCBwYXJzZSwgb3ZlcmxheSwgdGFyZ2V0LCBmcm9tKSB7XG4gICAgICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgICAgICB0aGlzLnBhcnNlID0gcGFyc2U7XG4gICAgICAgIHRoaXMub3ZlcmxheSA9IG92ZXJsYXk7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNoZWNrUmFuZ2VzKHJhbmdlcykge1xuICAgIGlmICghcmFuZ2VzLmxlbmd0aCB8fCByYW5nZXMuc29tZShyID0+IHIuZnJvbSA+PSByLnRvKSlcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlubmVyIHBhcnNlIHJhbmdlcyBnaXZlbjogXCIgKyBKU09OLnN0cmluZ2lmeShyYW5nZXMpKTtcbn1cbmNsYXNzIEFjdGl2ZU92ZXJsYXkge1xuICAgIGNvbnN0cnVjdG9yKHBhcnNlciwgcHJlZGljYXRlLCBtb3VudHMsIGluZGV4LCBzdGFydCwgdGFyZ2V0LCBwcmV2KSB7XG4gICAgICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgICAgICB0aGlzLnByZWRpY2F0ZSA9IHByZWRpY2F0ZTtcbiAgICAgICAgdGhpcy5tb3VudHMgPSBtb3VudHM7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgdGhpcy5wcmV2ID0gcHJldjtcbiAgICAgICAgdGhpcy5kZXB0aCA9IDA7XG4gICAgICAgIHRoaXMucmFuZ2VzID0gW107XG4gICAgfVxufVxuY29uc3Qgc3RvcHBlZElubmVyID0gbmV3IE5vZGVQcm9wKHsgcGVyTm9kZTogdHJ1ZSB9KTtcbmNsYXNzIE1peGVkUGFyc2Uge1xuICAgIGNvbnN0cnVjdG9yKGJhc2UsIG5lc3QsIGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcykge1xuICAgICAgICB0aGlzLm5lc3QgPSBuZXN0O1xuICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRzID0gZnJhZ21lbnRzO1xuICAgICAgICB0aGlzLnJhbmdlcyA9IHJhbmdlcztcbiAgICAgICAgdGhpcy5pbm5lciA9IFtdO1xuICAgICAgICB0aGlzLmlubmVyRG9uZSA9IDA7XG4gICAgICAgIHRoaXMuYmFzZVRyZWUgPSBudWxsO1xuICAgICAgICB0aGlzLnN0b3BwZWRBdCA9IG51bGw7XG4gICAgICAgIHRoaXMuYmFzZVBhcnNlID0gYmFzZTtcbiAgICB9XG4gICAgYWR2YW5jZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuYmFzZVBhcnNlKSB7XG4gICAgICAgICAgICBsZXQgZG9uZSA9IHRoaXMuYmFzZVBhcnNlLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIGlmICghZG9uZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuYmFzZVBhcnNlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuYmFzZVRyZWUgPSBkb25lO1xuICAgICAgICAgICAgdGhpcy5zdGFydElubmVyKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5zdG9wcGVkQXQgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpbm5lciBvZiB0aGlzLmlubmVyKVxuICAgICAgICAgICAgICAgICAgICBpbm5lci5wYXJzZS5zdG9wQXQodGhpcy5zdG9wcGVkQXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlubmVyRG9uZSA9PSB0aGlzLmlubmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMuYmFzZVRyZWU7XG4gICAgICAgICAgICBpZiAodGhpcy5zdG9wcGVkQXQgIT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgVHJlZShyZXN1bHQudHlwZSwgcmVzdWx0LmNoaWxkcmVuLCByZXN1bHQucG9zaXRpb25zLCByZXN1bHQubGVuZ3RoLCByZXN1bHQucHJvcFZhbHVlcy5jb25jYXQoW1tzdG9wcGVkSW5uZXIsIHRoaXMuc3RvcHBlZEF0XV0pKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGlubmVyID0gdGhpcy5pbm5lclt0aGlzLmlubmVyRG9uZV0sIGRvbmUgPSBpbm5lci5wYXJzZS5hZHZhbmNlKCk7XG4gICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICB0aGlzLmlubmVyRG9uZSsrO1xuICAgICAgICAgICAgLy8gVGhpcyBpcyBhIHNvbWV3aGF0IGRvZGd5IGJ1dCBzdXBlciBoZWxwZnVsIGhhY2sgd2hlcmUgd2VcbiAgICAgICAgICAgIC8vIHBhdGNoIHVwIG5vZGVzIGNyZWF0ZWQgYnkgdGhlIGlubmVyIHBhcnNlIChhbmQgdGh1c1xuICAgICAgICAgICAgLy8gcHJlc3VtYWJseSBub3QgYWxpYXNlZCBhbnl3aGVyZSBlbHNlKSB0byBob2xkIHRoZSBpbmZvcm1hdGlvblxuICAgICAgICAgICAgLy8gYWJvdXQgdGhlIGlubmVyIHBhcnNlLlxuICAgICAgICAgICAgbGV0IHByb3BzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCBpbm5lci50YXJnZXQucHJvcHMpO1xuICAgICAgICAgICAgcHJvcHNbTm9kZVByb3AubW91bnRlZC5pZF0gPSBuZXcgTW91bnRlZFRyZWUoZG9uZSwgaW5uZXIub3ZlcmxheSwgaW5uZXIucGFyc2VyKTtcbiAgICAgICAgICAgIGlubmVyLnRhcmdldC5wcm9wcyA9IHByb3BzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBnZXQgcGFyc2VkUG9zKCkge1xuICAgICAgICBpZiAodGhpcy5iYXNlUGFyc2UpXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgbGV0IHBvcyA9IHRoaXMuaW5wdXQubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5pbm5lckRvbmU7IGkgPCB0aGlzLmlubmVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pbm5lcltpXS5mcm9tIDwgcG9zKVxuICAgICAgICAgICAgICAgIHBvcyA9IE1hdGgubWluKHBvcywgdGhpcy5pbm5lcltpXS5wYXJzZS5wYXJzZWRQb3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgfVxuICAgIHN0b3BBdChwb3MpIHtcbiAgICAgICAgdGhpcy5zdG9wcGVkQXQgPSBwb3M7XG4gICAgICAgIGlmICh0aGlzLmJhc2VQYXJzZSlcbiAgICAgICAgICAgIHRoaXMuYmFzZVBhcnNlLnN0b3BBdChwb3MpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5pbm5lckRvbmU7IGkgPCB0aGlzLmlubmVyLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIHRoaXMuaW5uZXJbaV0ucGFyc2Uuc3RvcEF0KHBvcyk7XG4gICAgfVxuICAgIHN0YXJ0SW5uZXIoKSB7XG4gICAgICAgIGxldCBmcmFnbWVudEN1cnNvciA9IG5ldyBGcmFnbWVudEN1cnNvcih0aGlzLmZyYWdtZW50cyk7XG4gICAgICAgIGxldCBvdmVybGF5ID0gbnVsbDtcbiAgICAgICAgbGV0IGNvdmVyZWQgPSBudWxsO1xuICAgICAgICBsZXQgY3Vyc29yID0gbmV3IFRyZWVDdXJzb3IobmV3IFRyZWVOb2RlKHRoaXMuYmFzZVRyZWUsIHRoaXMucmFuZ2VzWzBdLmZyb20sIDAsIG51bGwpLCBJdGVyTW9kZS5JbmNsdWRlQW5vbnltb3VzIHwgSXRlck1vZGUuSWdub3JlTW91bnRzKTtcbiAgICAgICAgc2NhbjogZm9yIChsZXQgbmVzdCwgaXNDb3ZlcmVkOzspIHtcbiAgICAgICAgICAgIGxldCBlbnRlciA9IHRydWUsIHJhbmdlO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RvcHBlZEF0ICE9IG51bGwgJiYgY3Vyc29yLmZyb20gPj0gdGhpcy5zdG9wcGVkQXQpIHtcbiAgICAgICAgICAgICAgICBlbnRlciA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZnJhZ21lbnRDdXJzb3IuaGFzTm9kZShjdXJzb3IpKSB7XG4gICAgICAgICAgICAgICAgaWYgKG92ZXJsYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1hdGNoID0gb3ZlcmxheS5tb3VudHMuZmluZChtID0+IG0uZnJhZy5mcm9tIDw9IGN1cnNvci5mcm9tICYmIG0uZnJhZy50byA+PSBjdXJzb3IudG8gJiYgbS5tb3VudC5vdmVybGF5KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoKVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgciBvZiBtYXRjaC5tb3VudC5vdmVybGF5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZyb20gPSByLmZyb20gKyBtYXRjaC5wb3MsIHRvID0gci50byArIG1hdGNoLnBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnJvbSA+PSBjdXJzb3IuZnJvbSAmJiB0byA8PSBjdXJzb3IudG8gJiYgIW92ZXJsYXkucmFuZ2VzLnNvbWUociA9PiByLmZyb20gPCB0byAmJiByLnRvID4gZnJvbSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJsYXkucmFuZ2VzLnB1c2goeyBmcm9tLCB0byB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZW50ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvdmVyZWQgJiYgKGlzQ292ZXJlZCA9IGNoZWNrQ292ZXIoY292ZXJlZC5yYW5nZXMsIGN1cnNvci5mcm9tLCBjdXJzb3IudG8pKSkge1xuICAgICAgICAgICAgICAgIGVudGVyID0gaXNDb3ZlcmVkICE9IDIgLyogQ292ZXIuRnVsbCAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFjdXJzb3IudHlwZS5pc0Fub255bW91cyAmJiAobmVzdCA9IHRoaXMubmVzdChjdXJzb3IsIHRoaXMuaW5wdXQpKSAmJlxuICAgICAgICAgICAgICAgIChjdXJzb3IuZnJvbSA8IGN1cnNvci50byB8fCAhbmVzdC5vdmVybGF5KSkge1xuICAgICAgICAgICAgICAgIGlmICghY3Vyc29yLnRyZWUpXG4gICAgICAgICAgICAgICAgICAgIG1hdGVyaWFsaXplKGN1cnNvcik7XG4gICAgICAgICAgICAgICAgbGV0IG9sZE1vdW50cyA9IGZyYWdtZW50Q3Vyc29yLmZpbmRNb3VudHMoY3Vyc29yLmZyb20sIG5lc3QucGFyc2VyKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG5lc3Qub3ZlcmxheSA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmxheSA9IG5ldyBBY3RpdmVPdmVybGF5KG5lc3QucGFyc2VyLCBuZXN0Lm92ZXJsYXksIG9sZE1vdW50cywgdGhpcy5pbm5lci5sZW5ndGgsIGN1cnNvci5mcm9tLCBjdXJzb3IudHJlZSwgb3ZlcmxheSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmFuZ2VzID0gcHVuY2hSYW5nZXModGhpcy5yYW5nZXMsIG5lc3Qub3ZlcmxheSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKGN1cnNvci5mcm9tIDwgY3Vyc29yLnRvID8gW25ldyBSYW5nZShjdXJzb3IuZnJvbSwgY3Vyc29yLnRvKV0gOiBbXSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmFuZ2VzLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrUmFuZ2VzKHJhbmdlcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyYW5nZXMubGVuZ3RoIHx8ICFuZXN0Lm92ZXJsYXkpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlubmVyLnB1c2gobmV3IElubmVyUGFyc2UobmVzdC5wYXJzZXIsIHJhbmdlcy5sZW5ndGggPyBuZXN0LnBhcnNlci5zdGFydFBhcnNlKHRoaXMuaW5wdXQsIGVudGVyRnJhZ21lbnRzKG9sZE1vdW50cywgcmFuZ2VzKSwgcmFuZ2VzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogbmVzdC5wYXJzZXIuc3RhcnRQYXJzZShcIlwiKSwgbmVzdC5vdmVybGF5ID8gbmVzdC5vdmVybGF5Lm1hcChyID0+IG5ldyBSYW5nZShyLmZyb20gLSBjdXJzb3IuZnJvbSwgci50byAtIGN1cnNvci5mcm9tKSkgOiBudWxsLCBjdXJzb3IudHJlZSwgcmFuZ2VzLmxlbmd0aCA/IHJhbmdlc1swXS5mcm9tIDogY3Vyc29yLmZyb20pKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXN0Lm92ZXJsYXkpXG4gICAgICAgICAgICAgICAgICAgICAgICBlbnRlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChyYW5nZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICAgICAgY292ZXJlZCA9IHsgcmFuZ2VzLCBkZXB0aDogMCwgcHJldjogY292ZXJlZCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG92ZXJsYXkgJiYgKHJhbmdlID0gb3ZlcmxheS5wcmVkaWNhdGUoY3Vyc29yKSkpIHtcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2UgPT09IHRydWUpXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlID0gbmV3IFJhbmdlKGN1cnNvci5mcm9tLCBjdXJzb3IudG8pO1xuICAgICAgICAgICAgICAgIGlmIChyYW5nZS5mcm9tIDwgcmFuZ2UudG8pXG4gICAgICAgICAgICAgICAgICAgIG92ZXJsYXkucmFuZ2VzLnB1c2gocmFuZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVudGVyICYmIGN1cnNvci5maXJzdENoaWxkKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAob3ZlcmxheSlcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmxheS5kZXB0aCsrO1xuICAgICAgICAgICAgICAgIGlmIChjb3ZlcmVkKVxuICAgICAgICAgICAgICAgICAgICBjb3ZlcmVkLmRlcHRoKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJzb3IubmV4dFNpYmxpbmcoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWN1cnNvci5wYXJlbnQoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIHNjYW47XG4gICAgICAgICAgICAgICAgICAgIGlmIChvdmVybGF5ICYmICEtLW92ZXJsYXkuZGVwdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByYW5nZXMgPSBwdW5jaFJhbmdlcyh0aGlzLnJhbmdlcywgb3ZlcmxheS5yYW5nZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGVja1JhbmdlcyhyYW5nZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5uZXIuc3BsaWNlKG92ZXJsYXkuaW5kZXgsIDAsIG5ldyBJbm5lclBhcnNlKG92ZXJsYXkucGFyc2VyLCBvdmVybGF5LnBhcnNlci5zdGFydFBhcnNlKHRoaXMuaW5wdXQsIGVudGVyRnJhZ21lbnRzKG92ZXJsYXkubW91bnRzLCByYW5nZXMpLCByYW5nZXMpLCBvdmVybGF5LnJhbmdlcy5tYXAociA9PiBuZXcgUmFuZ2Uoci5mcm9tIC0gb3ZlcmxheS5zdGFydCwgci50byAtIG92ZXJsYXkuc3RhcnQpKSwgb3ZlcmxheS50YXJnZXQsIHJhbmdlc1swXS5mcm9tKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBvdmVybGF5ID0gb3ZlcmxheS5wcmV2O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3ZlcmVkICYmICEtLWNvdmVyZWQuZGVwdGgpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3ZlcmVkID0gY292ZXJlZC5wcmV2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGNoZWNrQ292ZXIoY292ZXJlZCwgZnJvbSwgdG8pIHtcbiAgICBmb3IgKGxldCByYW5nZSBvZiBjb3ZlcmVkKSB7XG4gICAgICAgIGlmIChyYW5nZS5mcm9tID49IHRvKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGlmIChyYW5nZS50byA+IGZyb20pXG4gICAgICAgICAgICByZXR1cm4gcmFuZ2UuZnJvbSA8PSBmcm9tICYmIHJhbmdlLnRvID49IHRvID8gMiAvKiBDb3Zlci5GdWxsICovIDogMSAvKiBDb3Zlci5QYXJ0aWFsICovO1xuICAgIH1cbiAgICByZXR1cm4gMCAvKiBDb3Zlci5Ob25lICovO1xufVxuLy8gVGFrZSBhIHBpZWNlIG9mIGJ1ZmZlciBhbmQgY29udmVydCBpdCBpbnRvIGEgc3RhbmQtYWxvbmVcbi8vIFRyZWVCdWZmZXIuXG5mdW5jdGlvbiBzbGljZUJ1ZihidWYsIHN0YXJ0SSwgZW5kSSwgbm9kZXMsIHBvc2l0aW9ucywgb2ZmKSB7XG4gICAgaWYgKHN0YXJ0SSA8IGVuZEkpIHtcbiAgICAgICAgbGV0IGZyb20gPSBidWYuYnVmZmVyW3N0YXJ0SSArIDFdO1xuICAgICAgICBub2Rlcy5wdXNoKGJ1Zi5zbGljZShzdGFydEksIGVuZEksIGZyb20pKTtcbiAgICAgICAgcG9zaXRpb25zLnB1c2goZnJvbSAtIG9mZik7XG4gICAgfVxufVxuLy8gVGhpcyBmdW5jdGlvbiB0YWtlcyBhIG5vZGUgdGhhdCdzIGluIGEgYnVmZmVyLCBhbmQgY29udmVydHMgaXQsIGFuZFxuLy8gaXRzIHBhcmVudCBidWZmZXIgbm9kZXMsIGludG8gYSBUcmVlLiBUaGlzIGlzIGFnYWluIGFjdGluZyBvbiB0aGVcbi8vIGFzc3VtcHRpb24gdGhhdCB0aGUgdHJlZXMgYW5kIGJ1ZmZlcnMgaGF2ZSBiZWVuIGNvbnN0cnVjdGVkIGJ5IHRoZVxuLy8gcGFyc2UgdGhhdCB3YXMgcmFuIHZpYSB0aGUgbWl4IHBhcnNlciwgYW5kIHRodXMgYXJlbid0IHNoYXJlZCB3aXRoXG4vLyBhbnkgb3RoZXIgY29kZSwgbWFraW5nIHZpb2xhdGlvbnMgb2YgdGhlIGltbXV0YWJpbGl0eSBzYWZlLlxuZnVuY3Rpb24gbWF0ZXJpYWxpemUoY3Vyc29yKSB7XG4gICAgbGV0IHsgbm9kZSB9ID0gY3Vyc29yLCBzdGFjayA9IFtdO1xuICAgIC8vIFNjYW4gdXAgdG8gdGhlIG5lYXJlc3QgdHJlZVxuICAgIGRvIHtcbiAgICAgICAgc3RhY2sucHVzaChjdXJzb3IuaW5kZXgpO1xuICAgICAgICBjdXJzb3IucGFyZW50KCk7XG4gICAgfSB3aGlsZSAoIWN1cnNvci50cmVlKTtcbiAgICAvLyBGaW5kIHRoZSBpbmRleCBvZiB0aGUgYnVmZmVyIGluIHRoYXQgdHJlZVxuICAgIGxldCBpID0gMCwgYmFzZSA9IGN1cnNvci50cmVlLCBvZmYgPSAwO1xuICAgIGZvciAoOzsgaSsrKSB7XG4gICAgICAgIG9mZiA9IGJhc2UucG9zaXRpb25zW2ldICsgY3Vyc29yLmZyb207XG4gICAgICAgIGlmIChvZmYgPD0gbm9kZS5mcm9tICYmIG9mZiArIGJhc2UuY2hpbGRyZW5baV0ubGVuZ3RoID49IG5vZGUudG8pXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgbGV0IGJ1ZiA9IGJhc2UuY2hpbGRyZW5baV0sIGIgPSBidWYuYnVmZmVyLCBuZXdTdGFjayA9IFtpXTtcbiAgICAvLyBTcGxpdCBhIGxldmVsIGluIHRoZSBidWZmZXIsIHB1dHRpbmcgdGhlIG5vZGVzIGJlZm9yZSBhbmQgYWZ0ZXJcbiAgICAvLyB0aGUgY2hpbGQgdGhhdCBjb250YWlucyBgbm9kZWAgaW50byBuZXcgYnVmZmVycy5cbiAgICBmdW5jdGlvbiBzcGxpdChzdGFydEksIGVuZEksIHR5cGUsIGlubmVyT2Zmc2V0LCBsZW5ndGgsIHN0YWNrUG9zKSB7XG4gICAgICAgIGxldCB0YXJnZXRJID0gc3RhY2tbc3RhY2tQb3NdO1xuICAgICAgICBsZXQgY2hpbGRyZW4gPSBbXSwgcG9zaXRpb25zID0gW107XG4gICAgICAgIHNsaWNlQnVmKGJ1Ziwgc3RhcnRJLCB0YXJnZXRJLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBpbm5lck9mZnNldCk7XG4gICAgICAgIGxldCBmcm9tID0gYlt0YXJnZXRJICsgMV0sIHRvID0gYlt0YXJnZXRJICsgMl07XG4gICAgICAgIG5ld1N0YWNrLnB1c2goY2hpbGRyZW4ubGVuZ3RoKTtcbiAgICAgICAgbGV0IGNoaWxkID0gc3RhY2tQb3NcbiAgICAgICAgICAgID8gc3BsaXQodGFyZ2V0SSArIDQsIGJbdGFyZ2V0SSArIDNdLCBidWYuc2V0LnR5cGVzW2JbdGFyZ2V0SV1dLCBmcm9tLCB0byAtIGZyb20sIHN0YWNrUG9zIC0gMSlcbiAgICAgICAgICAgIDogbm9kZS50b1RyZWUoKTtcbiAgICAgICAgY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgICAgIHBvc2l0aW9ucy5wdXNoKGZyb20gLSBpbm5lck9mZnNldCk7XG4gICAgICAgIHNsaWNlQnVmKGJ1ZiwgYlt0YXJnZXRJICsgM10sIGVuZEksIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGlubmVyT2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlKHR5cGUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGxlbmd0aCk7XG4gICAgfVxuICAgIGJhc2UuY2hpbGRyZW5baV0gPSBzcGxpdCgwLCBiLmxlbmd0aCwgTm9kZVR5cGUubm9uZSwgMCwgYnVmLmxlbmd0aCwgc3RhY2subGVuZ3RoIC0gMSk7XG4gICAgLy8gTW92ZSB0aGUgY3Vyc29yIGJhY2sgdG8gdGhlIHRhcmdldCBub2RlXG4gICAgZm9yIChsZXQgaW5kZXggb2YgbmV3U3RhY2spIHtcbiAgICAgICAgbGV0IHRyZWUgPSBjdXJzb3IudHJlZS5jaGlsZHJlbltpbmRleF0sIHBvcyA9IGN1cnNvci50cmVlLnBvc2l0aW9uc1tpbmRleF07XG4gICAgICAgIGN1cnNvci55aWVsZChuZXcgVHJlZU5vZGUodHJlZSwgcG9zICsgY3Vyc29yLmZyb20sIGluZGV4LCBjdXJzb3IuX3RyZWUpKTtcbiAgICB9XG59XG5jbGFzcyBTdHJ1Y3R1cmVDdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKHJvb3QsIG9mZnNldCkge1xuICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY3Vyc29yID0gcm9vdC5jdXJzb3IoSXRlck1vZGUuSW5jbHVkZUFub255bW91cyB8IEl0ZXJNb2RlLklnbm9yZU1vdW50cyk7XG4gICAgfVxuICAgIC8vIE1vdmUgdG8gdGhlIGZpcnN0IG5vZGUgKGluIHByZS1vcmRlcikgdGhhdCBzdGFydHMgYXQgb3IgYWZ0ZXIgYHBvc2AuXG4gICAgbW92ZVRvKHBvcykge1xuICAgICAgICBsZXQgeyBjdXJzb3IgfSA9IHRoaXMsIHAgPSBwb3MgLSB0aGlzLm9mZnNldDtcbiAgICAgICAgd2hpbGUgKCF0aGlzLmRvbmUgJiYgY3Vyc29yLmZyb20gPCBwKSB7XG4gICAgICAgICAgICBpZiAoY3Vyc29yLnRvID49IHBvcyAmJiBjdXJzb3IuZW50ZXIocCwgMSwgSXRlck1vZGUuSWdub3JlT3ZlcmxheXMgfCBJdGVyTW9kZS5FeGNsdWRlQnVmZmVycykpIDtcbiAgICAgICAgICAgIGVsc2UgaWYgKCFjdXJzb3IubmV4dChmYWxzZSkpXG4gICAgICAgICAgICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYXNOb2RlKGN1cnNvcikge1xuICAgICAgICB0aGlzLm1vdmVUbyhjdXJzb3IuZnJvbSk7XG4gICAgICAgIGlmICghdGhpcy5kb25lICYmIHRoaXMuY3Vyc29yLmZyb20gKyB0aGlzLm9mZnNldCA9PSBjdXJzb3IuZnJvbSAmJiB0aGlzLmN1cnNvci50cmVlKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB0cmVlID0gdGhpcy5jdXJzb3IudHJlZTs7KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRyZWUgPT0gY3Vyc29yLnRyZWUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIGlmICh0cmVlLmNoaWxkcmVuLmxlbmd0aCAmJiB0cmVlLnBvc2l0aW9uc1swXSA9PSAwICYmIHRyZWUuY2hpbGRyZW5bMF0gaW5zdGFuY2VvZiBUcmVlKVxuICAgICAgICAgICAgICAgICAgICB0cmVlID0gdHJlZS5jaGlsZHJlblswXTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5jbGFzcyBGcmFnbWVudEN1cnNvciB7XG4gICAgY29uc3RydWN0b3IoZnJhZ21lbnRzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5mcmFnbWVudHMgPSBmcmFnbWVudHM7XG4gICAgICAgIHRoaXMuY3VyVG8gPSAwO1xuICAgICAgICB0aGlzLmZyYWdJID0gMDtcbiAgICAgICAgaWYgKGZyYWdtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBmaXJzdCA9IHRoaXMuY3VyRnJhZyA9IGZyYWdtZW50c1swXTtcbiAgICAgICAgICAgIHRoaXMuY3VyVG8gPSAoX2EgPSBmaXJzdC50cmVlLnByb3Aoc3RvcHBlZElubmVyKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmlyc3QudG87XG4gICAgICAgICAgICB0aGlzLmlubmVyID0gbmV3IFN0cnVjdHVyZUN1cnNvcihmaXJzdC50cmVlLCAtZmlyc3Qub2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY3VyRnJhZyA9IHRoaXMuaW5uZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhc05vZGUobm9kZSkge1xuICAgICAgICB3aGlsZSAodGhpcy5jdXJGcmFnICYmIG5vZGUuZnJvbSA+PSB0aGlzLmN1clRvKVxuICAgICAgICAgICAgdGhpcy5uZXh0RnJhZygpO1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJGcmFnICYmIHRoaXMuY3VyRnJhZy5mcm9tIDw9IG5vZGUuZnJvbSAmJiB0aGlzLmN1clRvID49IG5vZGUudG8gJiYgdGhpcy5pbm5lci5oYXNOb2RlKG5vZGUpO1xuICAgIH1cbiAgICBuZXh0RnJhZygpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLmZyYWdJKys7XG4gICAgICAgIGlmICh0aGlzLmZyYWdJID09IHRoaXMuZnJhZ21lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5jdXJGcmFnID0gdGhpcy5pbm5lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgZnJhZyA9IHRoaXMuY3VyRnJhZyA9IHRoaXMuZnJhZ21lbnRzW3RoaXMuZnJhZ0ldO1xuICAgICAgICAgICAgdGhpcy5jdXJUbyA9IChfYSA9IGZyYWcudHJlZS5wcm9wKHN0b3BwZWRJbm5lcikpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZyYWcudG87XG4gICAgICAgICAgICB0aGlzLmlubmVyID0gbmV3IFN0cnVjdHVyZUN1cnNvcihmcmFnLnRyZWUsIC1mcmFnLm9mZnNldCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmluZE1vdW50cyhwb3MsIHBhcnNlcikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMuaW5uZXIpIHtcbiAgICAgICAgICAgIHRoaXMuaW5uZXIuY3Vyc29yLm1vdmVUbyhwb3MsIDEpO1xuICAgICAgICAgICAgZm9yIChsZXQgcG9zID0gdGhpcy5pbm5lci5jdXJzb3Iubm9kZTsgcG9zOyBwb3MgPSBwb3MucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgbGV0IG1vdW50ID0gKF9hID0gcG9zLnRyZWUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wcm9wKE5vZGVQcm9wLm1vdW50ZWQpO1xuICAgICAgICAgICAgICAgIGlmIChtb3VudCAmJiBtb3VudC5wYXJzZXIgPT0gcGFyc2VyKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmZyYWdJOyBpIDwgdGhpcy5mcmFnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmcmFnID0gdGhpcy5mcmFnbWVudHNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnJhZy5mcm9tID49IHBvcy50bylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcmFnLnRyZWUgPT0gdGhpcy5jdXJGcmFnLnRyZWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3M6IHBvcy5mcm9tIC0gZnJhZy5vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vdW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5mdW5jdGlvbiBwdW5jaFJhbmdlcyhvdXRlciwgcmFuZ2VzKSB7XG4gICAgbGV0IGNvcHkgPSBudWxsLCBjdXJyZW50ID0gcmFuZ2VzO1xuICAgIGZvciAobGV0IGkgPSAxLCBqID0gMDsgaSA8IG91dGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBnYXBGcm9tID0gb3V0ZXJbaSAtIDFdLnRvLCBnYXBUbyA9IG91dGVyW2ldLmZyb207XG4gICAgICAgIGZvciAoOyBqIDwgY3VycmVudC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgbGV0IHIgPSBjdXJyZW50W2pdO1xuICAgICAgICAgICAgaWYgKHIuZnJvbSA+PSBnYXBUbylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGlmIChyLnRvIDw9IGdhcEZyb20pXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAoIWNvcHkpXG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGNvcHkgPSByYW5nZXMuc2xpY2UoKTtcbiAgICAgICAgICAgIGlmIChyLmZyb20gPCBnYXBGcm9tKSB7XG4gICAgICAgICAgICAgICAgY29weVtqXSA9IG5ldyBSYW5nZShyLmZyb20sIGdhcEZyb20pO1xuICAgICAgICAgICAgICAgIGlmIChyLnRvID4gZ2FwVG8pXG4gICAgICAgICAgICAgICAgICAgIGNvcHkuc3BsaWNlKGogKyAxLCAwLCBuZXcgUmFuZ2UoZ2FwVG8sIHIudG8pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHIudG8gPiBnYXBUbykge1xuICAgICAgICAgICAgICAgIGNvcHlbai0tXSA9IG5ldyBSYW5nZShnYXBUbywgci50byk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb3B5LnNwbGljZShqLS0sIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjdXJyZW50O1xufVxuZnVuY3Rpb24gZmluZENvdmVyQ2hhbmdlcyhhLCBiLCBmcm9tLCB0bykge1xuICAgIGxldCBpQSA9IDAsIGlCID0gMCwgaW5BID0gZmFsc2UsIGluQiA9IGZhbHNlLCBwb3MgPSAtMWU5O1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGxldCBuZXh0QSA9IGlBID09IGEubGVuZ3RoID8gMWU5IDogaW5BID8gYVtpQV0udG8gOiBhW2lBXS5mcm9tO1xuICAgICAgICBsZXQgbmV4dEIgPSBpQiA9PSBiLmxlbmd0aCA/IDFlOSA6IGluQiA/IGJbaUJdLnRvIDogYltpQl0uZnJvbTtcbiAgICAgICAgaWYgKGluQSAhPSBpbkIpIHtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IE1hdGgubWF4KHBvcywgZnJvbSksIGVuZCA9IE1hdGgubWluKG5leHRBLCBuZXh0QiwgdG8pO1xuICAgICAgICAgICAgaWYgKHN0YXJ0IDwgZW5kKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyBSYW5nZShzdGFydCwgZW5kKSk7XG4gICAgICAgIH1cbiAgICAgICAgcG9zID0gTWF0aC5taW4obmV4dEEsIG5leHRCKTtcbiAgICAgICAgaWYgKHBvcyA9PSAxZTkpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgaWYgKG5leHRBID09IHBvcykge1xuICAgICAgICAgICAgaWYgKCFpbkEpXG4gICAgICAgICAgICAgICAgaW5BID0gdHJ1ZTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGluQSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlBKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5leHRCID09IHBvcykge1xuICAgICAgICAgICAgaWYgKCFpbkIpXG4gICAgICAgICAgICAgICAgaW5CID0gdHJ1ZTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGluQiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlCKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vIEdpdmVuIGEgbnVtYmVyIG9mIGZyYWdtZW50cyBmb3IgdGhlIG91dGVyIHRyZWUsIGFuZCBhIHNldCBvZiByYW5nZXNcbi8vIHRvIHBhcnNlLCBmaW5kIGZyYWdtZW50cyBmb3IgaW5uZXIgdHJlZXMgbW91bnRlZCBhcm91bmQgdGhvc2Vcbi8vIHJhbmdlcywgaWYgYW55LlxuZnVuY3Rpb24gZW50ZXJGcmFnbWVudHMobW91bnRzLCByYW5nZXMpIHtcbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgZm9yIChsZXQgeyBwb3MsIG1vdW50LCBmcmFnIH0gb2YgbW91bnRzKSB7XG4gICAgICAgIGxldCBzdGFydFBvcyA9IHBvcyArIChtb3VudC5vdmVybGF5ID8gbW91bnQub3ZlcmxheVswXS5mcm9tIDogMCksIGVuZFBvcyA9IHN0YXJ0UG9zICsgbW91bnQudHJlZS5sZW5ndGg7XG4gICAgICAgIGxldCBmcm9tID0gTWF0aC5tYXgoZnJhZy5mcm9tLCBzdGFydFBvcyksIHRvID0gTWF0aC5taW4oZnJhZy50bywgZW5kUG9zKTtcbiAgICAgICAgaWYgKG1vdW50Lm92ZXJsYXkpIHtcbiAgICAgICAgICAgIGxldCBvdmVybGF5ID0gbW91bnQub3ZlcmxheS5tYXAociA9PiBuZXcgUmFuZ2Uoci5mcm9tICsgcG9zLCByLnRvICsgcG9zKSk7XG4gICAgICAgICAgICBsZXQgY2hhbmdlcyA9IGZpbmRDb3ZlckNoYW5nZXMocmFuZ2VzLCBvdmVybGF5LCBmcm9tLCB0byk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gZnJvbTs7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBsYXN0ID0gaSA9PSBjaGFuZ2VzLmxlbmd0aCwgZW5kID0gbGFzdCA/IHRvIDogY2hhbmdlc1tpXS5mcm9tO1xuICAgICAgICAgICAgICAgIGlmIChlbmQgPiBwb3MpXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyBUcmVlRnJhZ21lbnQocG9zLCBlbmQsIG1vdW50LnRyZWUsIC1zdGFydFBvcywgZnJhZy5mcm9tID49IHBvcyB8fCBmcmFnLm9wZW5TdGFydCwgZnJhZy50byA8PSBlbmQgfHwgZnJhZy5vcGVuRW5kKSk7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3QpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIHBvcyA9IGNoYW5nZXNbaV0udG87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChuZXcgVHJlZUZyYWdtZW50KGZyb20sIHRvLCBtb3VudC50cmVlLCAtc3RhcnRQb3MsIGZyYWcuZnJvbSA+PSBzdGFydFBvcyB8fCBmcmFnLm9wZW5TdGFydCwgZnJhZy50byA8PSBlbmRQb3MgfHwgZnJhZy5vcGVuRW5kKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IHsgRGVmYXVsdEJ1ZmZlckxlbmd0aCwgSXRlck1vZGUsIE1vdW50ZWRUcmVlLCBOb2RlUHJvcCwgTm9kZVNldCwgTm9kZVR5cGUsIE5vZGVXZWFrTWFwLCBQYXJzZXIsIFRyZWUsIFRyZWVCdWZmZXIsIFRyZWVDdXJzb3IsIFRyZWVGcmFnbWVudCwgcGFyc2VNaXhlZCB9O1xuIl0sIm5hbWVzIjpbIkRlZmF1bHRCdWZmZXJMZW5ndGgiLCJuZXh0UHJvcElEIiwiUmFuZ2UiLCJjb25zdHJ1Y3RvciIsImZyb20iLCJ0byIsIk5vZGVQcm9wIiwiY29uZmlnIiwiaWQiLCJwZXJOb2RlIiwiZGVzZXJpYWxpemUiLCJFcnJvciIsImFkZCIsIm1hdGNoIiwiUmFuZ2VFcnJvciIsIk5vZGVUeXBlIiwidHlwZSIsInJlc3VsdCIsInVuZGVmaW5lZCIsImNsb3NlZEJ5Iiwic3RyIiwic3BsaXQiLCJvcGVuZWRCeSIsImdyb3VwIiwiY29udGV4dEhhc2giLCJsb29rQWhlYWQiLCJtb3VudGVkIiwiTW91bnRlZFRyZWUiLCJ0cmVlIiwib3ZlcmxheSIsInBhcnNlciIsImdldCIsInByb3BzIiwibm9Qcm9wcyIsIk9iamVjdCIsImNyZWF0ZSIsIm5hbWUiLCJmbGFncyIsImRlZmluZSIsInNwZWMiLCJsZW5ndGgiLCJ0b3AiLCJza2lwcGVkIiwiZXJyb3IiLCJzcmMiLCJBcnJheSIsImlzQXJyYXkiLCJwcm9wIiwiaXNUb3AiLCJpc1NraXBwZWQiLCJpc0Vycm9yIiwiaXNBbm9ueW1vdXMiLCJpcyIsImluZGV4T2YiLCJtYXAiLCJkaXJlY3QiLCJub2RlIiwiZ3JvdXBzIiwiaSIsImZvdW5kIiwibm9uZSIsIk5vZGVTZXQiLCJ0eXBlcyIsImV4dGVuZCIsIm5ld1R5cGVzIiwibmV3UHJvcHMiLCJzb3VyY2UiLCJhc3NpZ24iLCJwdXNoIiwiQ2FjaGVkTm9kZSIsIldlYWtNYXAiLCJDYWNoZWRJbm5lck5vZGUiLCJJdGVyTW9kZSIsIlRyZWUiLCJjaGlsZHJlbiIsInBvc2l0aW9ucyIsInZhbHVlIiwidG9TdHJpbmciLCJjaCIsInRlc3QiLCJKU09OIiwic3RyaW5naWZ5IiwiY3Vyc29yIiwibW9kZSIsIlRyZWVDdXJzb3IiLCJ0b3BOb2RlIiwiY3Vyc29yQXQiLCJwb3MiLCJzaWRlIiwic2NvcGUiLCJtb3ZlVG8iLCJzZXQiLCJfdHJlZSIsIlRyZWVOb2RlIiwicmVzb2x2ZSIsInJlc29sdmVOb2RlIiwicmVzb2x2ZUlubmVyIiwicmVzb2x2ZVN0YWNrIiwic3RhY2tJdGVyYXRvciIsIml0ZXJhdGUiLCJlbnRlciIsImxlYXZlIiwiYW5vbiIsIkluY2x1ZGVBbm9ueW1vdXMiLCJjIiwiZW50ZXJlZCIsImZpcnN0Q2hpbGQiLCJuZXh0U2libGluZyIsInBhcmVudCIsInByb3BWYWx1ZXMiLCJiYWxhbmNlIiwiYmFsYW5jZVJhbmdlIiwibWFrZVRyZWUiLCJidWlsZCIsImRhdGEiLCJidWlsZFRyZWUiLCJlbXB0eSIsIkZsYXRCdWZmZXJDdXJzb3IiLCJidWZmZXIiLCJpbmRleCIsInN0YXJ0IiwiZW5kIiwic2l6ZSIsIm5leHQiLCJmb3JrIiwiVHJlZUJ1ZmZlciIsImNoaWxkU3RyaW5nIiwiam9pbiIsImVuZEluZGV4IiwiZmluZENoaWxkIiwic3RhcnRJbmRleCIsImRpciIsInBpY2siLCJjaGVja1NpZGUiLCJzbGljZSIsInN0YXJ0SSIsImVuZEkiLCJiIiwiY29weSIsIlVpbnQxNkFycmF5IiwibGVuIiwiaiIsIk1hdGgiLCJtYXgiLCJvdmVybGF5cyIsIl9hIiwiSWdub3JlT3ZlcmxheXMiLCJzY2FuIiwiaW5uZXIiLCJCYXNlTm9kZSIsImdldENoaWxkIiwiYmVmb3JlIiwiYWZ0ZXIiLCJyIiwiZ2V0Q2hpbGRyZW4iLCJtYXRjaENvbnRleHQiLCJjb250ZXh0IiwibWF0Y2hOb2RlQ29udGV4dCIsImVudGVyVW5maW5pc2hlZE5vZGVzQmVmb3JlIiwiY2hpbGRCZWZvcmUiLCJsYXN0IiwibGFzdENoaWxkIiwicHJldlNpYmxpbmciLCJfcGFyZW50IiwibmV4dENoaWxkIiwiZSIsIkV4Y2x1ZGVCdWZmZXJzIiwiQnVmZmVyTm9kZSIsIkJ1ZmZlckNvbnRleHQiLCJoYXNDaGlsZCIsIklnbm9yZU1vdW50cyIsImNoaWxkQWZ0ZXIiLCJyUG9zIiwibmV4dFNpZ25pZmljYW50UGFyZW50IiwidmFsIiwidG9UcmVlIiwiY3VyIiwicCIsImNoaWxkIiwiZXh0ZXJuYWxTaWJsaW5nIiwicGFyZW50U3RhcnQiLCJpdGVyU3RhY2siLCJoZWFkcyIsInBpY2tlZCIsIm5ld0hlYWRzIiwic3BsaWNlIiwiU3RhY2tJdGVyYXRvciIsImxheWVycyIsIm1vdW50Iiwicm9vdCIsInN0YWNrIiwiYnVmZmVyTm9kZSIsInlpZWxkTm9kZSIsIm4iLCJ1bnNoaWZ0IiwieWllbGRCdWYiLCJ5aWVsZCIsImVudGVyQ2hpbGQiLCJwb3AiLCJzaWJsaW5nIiwiZCIsImF0TGFzdE5vZGUiLCJtb3ZlIiwicHJldiIsImNhY2hlIiwiZGVwdGgiLCJtdXN0TGVhdmUiLCJzb21lIiwibm9kZVNldCIsIm1heEJ1ZmZlckxlbmd0aCIsInJldXNlZCIsIm1pblJlcGVhdFR5cGUiLCJ0YWtlTm9kZSIsIm1pblBvcyIsImluUmVwZWF0IiwibG9va0FoZWFkQXRTdGFydCIsInN0YXJ0UG9zIiwiZmluZEJ1ZmZlclNpemUiLCJza2lwIiwiZW5kUG9zIiwiY29weVRvQnVmZmVyIiwibG9jYWxDaGlsZHJlbiIsImxvY2FsUG9zaXRpb25zIiwibG9jYWxJblJlcGVhdCIsImxhc3RHcm91cCIsImxhc3RFbmQiLCJtYWtlUmVwZWF0TGVhZiIsInRha2VGbGF0Tm9kZSIsInJldmVyc2UiLCJtYWtlIiwibWFrZUJhbGFuY2VkIiwibm9kZXMiLCJub2RlQ291bnQiLCJzdG9wQXQiLCJsYXN0SSIsImxvb2tBaGVhZFByb3AiLCJiYXNlIiwicGFpciIsImNvbmNhdCIsIm1heFNpemUiLCJtaW5TdGFydCIsIm5vZGVTaXplIiwibG9jYWxTa2lwcGVkIiwibm9kZVN0YXJ0IiwiYnVmZmVyU3RhcnQiLCJ0b3BJRCIsIm5vZGVTaXplQ2FjaGUiLCJiYWxhbmNlVHlwZSIsIm1rVG9wIiwibWtUcmVlIiwidG90YWwiLCJtYXhDaGlsZCIsImNlaWwiLCJkaXZpZGUiLCJvZmZzZXQiLCJncm91cEZyb20iLCJncm91cFN0YXJ0IiwiZ3JvdXBTaXplIiwibmV4dFNpemUiLCJvbmx5IiwiTm9kZVdlYWtNYXAiLCJzZXRCdWZmZXIiLCJNYXAiLCJnZXRCdWZmZXIiLCJjdXJzb3JTZXQiLCJjdXJzb3JHZXQiLCJUcmVlRnJhZ21lbnQiLCJvcGVuU3RhcnQiLCJvcGVuRW5kIiwib3BlbiIsImFkZFRyZWUiLCJmcmFnbWVudHMiLCJwYXJ0aWFsIiwiZiIsImFwcGx5Q2hhbmdlcyIsImNoYW5nZXMiLCJtaW5HYXAiLCJmSSIsIm5leHRGIiwiY0kiLCJvZmYiLCJuZXh0QyIsIm5leHRQb3MiLCJmcm9tQSIsImN1dCIsImZGcm9tIiwiZlRvIiwibWluIiwidG9BIiwidG9CIiwiUGFyc2VyIiwic3RhcnRQYXJzZSIsImlucHV0IiwicmFuZ2VzIiwiU3RyaW5nSW5wdXQiLCJjcmVhdGVQYXJzZSIsInBhcnNlIiwiZG9uZSIsImFkdmFuY2UiLCJzdHJpbmciLCJjaHVuayIsImxpbmVDaHVua3MiLCJyZWFkIiwicGFyc2VNaXhlZCIsIm5lc3QiLCJNaXhlZFBhcnNlIiwiSW5uZXJQYXJzZSIsInRhcmdldCIsImNoZWNrUmFuZ2VzIiwiQWN0aXZlT3ZlcmxheSIsInByZWRpY2F0ZSIsIm1vdW50cyIsInN0b3BwZWRJbm5lciIsImlubmVyRG9uZSIsImJhc2VUcmVlIiwic3RvcHBlZEF0IiwiYmFzZVBhcnNlIiwic3RhcnRJbm5lciIsInBhcnNlZFBvcyIsImZyYWdtZW50Q3Vyc29yIiwiRnJhZ21lbnRDdXJzb3IiLCJjb3ZlcmVkIiwiaXNDb3ZlcmVkIiwicmFuZ2UiLCJoYXNOb2RlIiwiZmluZCIsIm0iLCJmcmFnIiwiY2hlY2tDb3ZlciIsIm1hdGVyaWFsaXplIiwib2xkTW91bnRzIiwiZmluZE1vdW50cyIsInB1bmNoUmFuZ2VzIiwiZW50ZXJGcmFnbWVudHMiLCJzbGljZUJ1ZiIsImJ1ZiIsIm5ld1N0YWNrIiwiaW5uZXJPZmZzZXQiLCJzdGFja1BvcyIsInRhcmdldEkiLCJTdHJ1Y3R1cmVDdXJzb3IiLCJjdXJUbyIsImZyYWdJIiwiZmlyc3QiLCJjdXJGcmFnIiwibmV4dEZyYWciLCJvdXRlciIsImN1cnJlbnQiLCJnYXBGcm9tIiwiZ2FwVG8iLCJmaW5kQ292ZXJDaGFuZ2VzIiwiYSIsImlBIiwiaUIiLCJpbkEiLCJpbkIiLCJuZXh0QSIsIm5leHRCIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lezer/common/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lezer/highlight/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@lezer/highlight/dist/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Tag: () => (/* binding */ Tag),\n/* harmony export */   classHighlighter: () => (/* binding */ classHighlighter),\n/* harmony export */   getStyleTags: () => (/* binding */ getStyleTags),\n/* harmony export */   highlightCode: () => (/* binding */ highlightCode),\n/* harmony export */   highlightTree: () => (/* binding */ highlightTree),\n/* harmony export */   styleTags: () => (/* binding */ styleTags),\n/* harmony export */   tagHighlighter: () => (/* binding */ tagHighlighter),\n/* harmony export */   tags: () => (/* binding */ tags)\n/* harmony export */ });\n/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/common */ \"(ssr)/./node_modules/@lezer/common/dist/index.js\");\n\nlet nextTagID = 0;\n/**\nHighlighting tags are markers that denote a highlighting category.\nThey are [associated](#highlight.styleTags) with parts of a syntax\ntree by a language mode, and then mapped to an actual CSS style by\na [highlighter](#highlight.Highlighter).\n\nBecause syntax tree node types and highlight styles have to be\nable to talk the same language, CodeMirror uses a mostly _closed_\n[vocabulary](#highlight.tags) of syntax tags (as opposed to\ntraditional open string-based systems, which make it hard for\nhighlighting themes to cover all the tokens produced by the\nvarious languages).\n\nIt _is_ possible to [define](#highlight.Tag^define) your own\nhighlighting tags for system-internal use (where you control both\nthe language package and the highlighter), but such tags will not\nbe picked up by regular highlighters (though you can derive them\nfrom standard tags to allow highlighters to fall back to those).\n*/ class Tag {\n    /**\n    @internal\n    */ constructor(/**\n    The set of this tag and all its parent tags, starting with\n    this one itself and sorted in order of decreasing specificity.\n    */ set, /**\n    The base unmodified tag that this one is based on, if it's\n    modified @internal\n    */ base, /**\n    The modifiers applied to this.base @internal\n    */ modified){\n        this.set = set;\n        this.base = base;\n        this.modified = modified;\n        /**\n        @internal\n        */ this.id = nextTagID++;\n    }\n    /**\n    Define a new tag. If `parent` is given, the tag is treated as a\n    sub-tag of that parent, and\n    [highlighters](#highlight.tagHighlighter) that don't mention\n    this tag will try to fall back to the parent tag (or grandparent\n    tag, etc).\n    */ static define(parent) {\n        if (parent === null || parent === void 0 ? void 0 : parent.base) throw new Error(\"Can not derive from a modified tag\");\n        let tag = new Tag([], null, []);\n        tag.set.push(tag);\n        if (parent) for (let t of parent.set)tag.set.push(t);\n        return tag;\n    }\n    /**\n    Define a tag _modifier_, which is a function that, given a tag,\n    will return a tag that is a subtag of the original. Applying the\n    same modifier to a twice tag will return the same value (`m1(t1)\n    == m1(t1)`) and applying multiple modifiers will, regardless or\n    order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).\n    \n    When multiple modifiers are applied to a given base tag, each\n    smaller set of modifiers is registered as a parent, so that for\n    example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,\n    `m1(m3(t1)`, and so on.\n    */ static defineModifier() {\n        let mod = new Modifier;\n        return (tag)=>{\n            if (tag.modified.indexOf(mod) > -1) return tag;\n            return Modifier.get(tag.base || tag, tag.modified.concat(mod).sort((a, b)=>a.id - b.id));\n        };\n    }\n}\nlet nextModifierID = 0;\nclass Modifier {\n    constructor(){\n        this.instances = [];\n        this.id = nextModifierID++;\n    }\n    static get(base, mods) {\n        if (!mods.length) return base;\n        let exists = mods[0].instances.find((t)=>t.base == base && sameArray(mods, t.modified));\n        if (exists) return exists;\n        let set = [], tag = new Tag(set, base, mods);\n        for (let m of mods)m.instances.push(tag);\n        let configs = powerSet(mods);\n        for (let parent of base.set)if (!parent.modified.length) for (let config of configs)set.push(Modifier.get(parent, config));\n        return tag;\n    }\n}\nfunction sameArray(a, b) {\n    return a.length == b.length && a.every((x, i)=>x == b[i]);\n}\nfunction powerSet(array) {\n    let sets = [\n        []\n    ];\n    for(let i = 0; i < array.length; i++){\n        for(let j = 0, e = sets.length; j < e; j++){\n            sets.push(sets[j].concat(array[i]));\n        }\n    }\n    return sets.sort((a, b)=>b.length - a.length);\n}\n/**\nThis function is used to add a set of tags to a language syntax\nvia [`NodeSet.extend`](#common.NodeSet.extend) or\n[`LRParser.configure`](#lr.LRParser.configure).\n\nThe argument object maps node selectors to [highlighting\ntags](#highlight.Tag) or arrays of tags.\n\nNode selectors may hold one or more (space-separated) node paths.\nSuch a path can be a [node name](#common.NodeType.name), or\nmultiple node names (or `*` wildcards) separated by slash\ncharacters, as in `\"Block/Declaration/VariableName\"`. Such a path\nmatches the final node but only if its direct parent nodes are the\nother nodes mentioned. A `*` in such a path matches any parent,\nbut only a single level—wildcards that match multiple parents\naren't supported, both for efficiency reasons and because Lezer\ntrees make it rather hard to reason about what they would match.)\n\nA path can be ended with `/...` to indicate that the tag assigned\nto the node should also apply to all child nodes, even if they\nmatch their own style (by default, only the innermost style is\nused).\n\nWhen a path ends in `!`, as in `Attribute!`, no further matching\nhappens for the node's child nodes, and the entire node gets the\ngiven style.\n\nIn this notation, node names that contain `/`, `!`, `*`, or `...`\nmust be quoted as JSON strings.\n\nFor example:\n\n```javascript\nparser.withProps(\n  styleTags({\n    // Style Number and BigNumber nodes\n    \"Number BigNumber\": tags.number,\n    // Style Escape nodes whose parent is String\n    \"String/Escape\": tags.escape,\n    // Style anything inside Attributes nodes\n    \"Attributes!\": tags.meta,\n    // Add a style to all content inside Italic nodes\n    \"Italic/...\": tags.emphasis,\n    // Style InvalidString nodes as both `string` and `invalid`\n    \"InvalidString\": [tags.string, tags.invalid],\n    // Style the node named \"/\" as punctuation\n    '\"/\"': tags.punctuation\n  })\n)\n```\n*/ function styleTags(spec) {\n    let byName = Object.create(null);\n    for(let prop in spec){\n        let tags = spec[prop];\n        if (!Array.isArray(tags)) tags = [\n            tags\n        ];\n        for (let part of prop.split(\" \"))if (part) {\n            let pieces = [], mode = 2 /* Mode.Normal */ , rest = part;\n            for(let pos = 0;;){\n                if (rest == \"...\" && pos > 0 && pos + 3 == part.length) {\n                    mode = 1 /* Mode.Inherit */ ;\n                    break;\n                }\n                let m = /^\"(?:[^\"\\\\]|\\\\.)*?\"|[^\\/!]+/.exec(rest);\n                if (!m) throw new RangeError(\"Invalid path: \" + part);\n                pieces.push(m[0] == \"*\" ? \"\" : m[0][0] == '\"' ? JSON.parse(m[0]) : m[0]);\n                pos += m[0].length;\n                if (pos == part.length) break;\n                let next = part[pos++];\n                if (pos == part.length && next == \"!\") {\n                    mode = 0 /* Mode.Opaque */ ;\n                    break;\n                }\n                if (next != \"/\") throw new RangeError(\"Invalid path: \" + part);\n                rest = part.slice(pos);\n            }\n            let last = pieces.length - 1, inner = pieces[last];\n            if (!inner) throw new RangeError(\"Invalid path: \" + part);\n            let rule = new Rule(tags, mode, last > 0 ? pieces.slice(0, last) : null);\n            byName[inner] = rule.sort(byName[inner]);\n        }\n    }\n    return ruleNodeProp.add(byName);\n}\nconst ruleNodeProp = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp();\nclass Rule {\n    constructor(tags, mode, context, next){\n        this.tags = tags;\n        this.mode = mode;\n        this.context = context;\n        this.next = next;\n    }\n    get opaque() {\n        return this.mode == 0 /* Mode.Opaque */ ;\n    }\n    get inherit() {\n        return this.mode == 1 /* Mode.Inherit */ ;\n    }\n    sort(other) {\n        if (!other || other.depth < this.depth) {\n            this.next = other;\n            return this;\n        }\n        other.next = this.sort(other.next);\n        return other;\n    }\n    get depth() {\n        return this.context ? this.context.length : 0;\n    }\n}\nRule.empty = new Rule([], 2 /* Mode.Normal */ , null);\n/**\nDefine a [highlighter](#highlight.Highlighter) from an array of\ntag/class pairs. Classes associated with more specific tags will\ntake precedence.\n*/ function tagHighlighter(tags, options) {\n    let map = Object.create(null);\n    for (let style of tags){\n        if (!Array.isArray(style.tag)) map[style.tag.id] = style.class;\n        else for (let tag of style.tag)map[tag.id] = style.class;\n    }\n    let { scope, all = null } = options || {};\n    return {\n        style: (tags)=>{\n            let cls = all;\n            for (let tag of tags){\n                for (let sub of tag.set){\n                    let tagClass = map[sub.id];\n                    if (tagClass) {\n                        cls = cls ? cls + \" \" + tagClass : tagClass;\n                        break;\n                    }\n                }\n            }\n            return cls;\n        },\n        scope\n    };\n}\nfunction highlightTags(highlighters, tags) {\n    let result = null;\n    for (let highlighter of highlighters){\n        let value = highlighter.style(tags);\n        if (value) result = result ? result + \" \" + value : value;\n    }\n    return result;\n}\n/**\nHighlight the given [tree](#common.Tree) with the given\n[highlighter](#highlight.Highlighter). Often, the higher-level\n[`highlightCode`](#highlight.highlightCode) function is easier to\nuse.\n*/ function highlightTree(tree, highlighter, /**\nAssign styling to a region of the text. Will be called, in order\nof position, for any ranges where more than zero classes apply.\n`classes` is a space separated string of CSS classes.\n*/ putStyle, /**\nThe start of the range to highlight.\n*/ from = 0, /**\nThe end of the range.\n*/ to = tree.length) {\n    let builder = new HighlightBuilder(from, Array.isArray(highlighter) ? highlighter : [\n        highlighter\n    ], putStyle);\n    builder.highlightRange(tree.cursor(), from, to, \"\", builder.highlighters);\n    builder.flush(to);\n}\n/**\nHighlight the given tree with the given highlighter, calling\n`putText` for every piece of text, either with a set of classes or\nwith the empty string when unstyled, and `putBreak` for every line\nbreak.\n*/ function highlightCode(code, tree, highlighter, putText, putBreak, from = 0, to = code.length) {\n    let pos = from;\n    function writeTo(p, classes) {\n        if (p <= pos) return;\n        for(let text = code.slice(pos, p), i = 0;;){\n            let nextBreak = text.indexOf(\"\\n\", i);\n            let upto = nextBreak < 0 ? text.length : nextBreak;\n            if (upto > i) putText(text.slice(i, upto), classes);\n            if (nextBreak < 0) break;\n            putBreak();\n            i = nextBreak + 1;\n        }\n        pos = p;\n    }\n    highlightTree(tree, highlighter, (from, to, classes)=>{\n        writeTo(from, \"\");\n        writeTo(to, classes);\n    }, from, to);\n    writeTo(to, \"\");\n}\nclass HighlightBuilder {\n    constructor(at, highlighters, span){\n        this.at = at;\n        this.highlighters = highlighters;\n        this.span = span;\n        this.class = \"\";\n    }\n    startSpan(at, cls) {\n        if (cls != this.class) {\n            this.flush(at);\n            if (at > this.at) this.at = at;\n            this.class = cls;\n        }\n    }\n    flush(to) {\n        if (to > this.at && this.class) this.span(this.at, to, this.class);\n    }\n    highlightRange(cursor, from, to, inheritedClass, highlighters) {\n        let { type, from: start, to: end } = cursor;\n        if (start >= to || end <= from) return;\n        if (type.isTop) highlighters = this.highlighters.filter((h)=>!h.scope || h.scope(type));\n        let cls = inheritedClass;\n        let rule = getStyleTags(cursor) || Rule.empty;\n        let tagCls = highlightTags(highlighters, rule.tags);\n        if (tagCls) {\n            if (cls) cls += \" \";\n            cls += tagCls;\n            if (rule.mode == 1 /* Mode.Inherit */ ) inheritedClass += (inheritedClass ? \" \" : \"\") + tagCls;\n        }\n        this.startSpan(Math.max(from, start), cls);\n        if (rule.opaque) return;\n        let mounted = cursor.tree && cursor.tree.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.mounted);\n        if (mounted && mounted.overlay) {\n            let inner = cursor.node.enter(mounted.overlay[0].from + start, 1);\n            let innerHighlighters = this.highlighters.filter((h)=>!h.scope || h.scope(mounted.tree.type));\n            let hasChild = cursor.firstChild();\n            for(let i = 0, pos = start;; i++){\n                let next = i < mounted.overlay.length ? mounted.overlay[i] : null;\n                let nextPos = next ? next.from + start : end;\n                let rangeFrom = Math.max(from, pos), rangeTo = Math.min(to, nextPos);\n                if (rangeFrom < rangeTo && hasChild) {\n                    while(cursor.from < rangeTo){\n                        this.highlightRange(cursor, rangeFrom, rangeTo, inheritedClass, highlighters);\n                        this.startSpan(Math.min(rangeTo, cursor.to), cls);\n                        if (cursor.to >= nextPos || !cursor.nextSibling()) break;\n                    }\n                }\n                if (!next || nextPos > to) break;\n                pos = next.to + start;\n                if (pos > from) {\n                    this.highlightRange(inner.cursor(), Math.max(from, next.from + start), Math.min(to, pos), \"\", innerHighlighters);\n                    this.startSpan(Math.min(to, pos), cls);\n                }\n            }\n            if (hasChild) cursor.parent();\n        } else if (cursor.firstChild()) {\n            if (mounted) inheritedClass = \"\";\n            do {\n                if (cursor.to <= from) continue;\n                if (cursor.from >= to) break;\n                this.highlightRange(cursor, from, to, inheritedClass, highlighters);\n                this.startSpan(Math.min(to, cursor.to), cls);\n            }while (cursor.nextSibling());\n            cursor.parent();\n        }\n    }\n}\n/**\nMatch a syntax node's [highlight rules](#highlight.styleTags). If\nthere's a match, return its set of tags, and whether it is\nopaque (uses a `!`) or applies to all child nodes (`/...`).\n*/ function getStyleTags(node) {\n    let rule = node.type.prop(ruleNodeProp);\n    while(rule && rule.context && !node.matchContext(rule.context))rule = rule.next;\n    return rule || null;\n}\nconst t = Tag.define;\nconst comment = t(), name = t(), typeName = t(name), propertyName = t(name), literal = t(), string = t(literal), number = t(literal), content = t(), heading = t(content), keyword = t(), operator = t(), punctuation = t(), bracket = t(punctuation), meta = t();\n/**\nThe default set of highlighting [tags](#highlight.Tag).\n\nThis collection is heavily biased towards programming languages,\nand necessarily incomplete. A full ontology of syntactic\nconstructs would fill a stack of books, and be impractical to\nwrite themes for. So try to make do with this set. If all else\nfails, [open an\nissue](https://github.com/codemirror/codemirror.next) to propose a\nnew tag, or [define](#highlight.Tag^define) a local custom tag for\nyour use case.\n\nNote that it is not obligatory to always attach the most specific\ntag possible to an element—if your grammar can't easily\ndistinguish a certain type of element (such as a local variable),\nit is okay to style it as its more general variant (a variable).\n\nFor tags that extend some parent tag, the documentation links to\nthe parent.\n*/ const tags = {\n    /**\n    A comment.\n    */ comment,\n    /**\n    A line [comment](#highlight.tags.comment).\n    */ lineComment: t(comment),\n    /**\n    A block [comment](#highlight.tags.comment).\n    */ blockComment: t(comment),\n    /**\n    A documentation [comment](#highlight.tags.comment).\n    */ docComment: t(comment),\n    /**\n    Any kind of identifier.\n    */ name,\n    /**\n    The [name](#highlight.tags.name) of a variable.\n    */ variableName: t(name),\n    /**\n    A type [name](#highlight.tags.name).\n    */ typeName: typeName,\n    /**\n    A tag name (subtag of [`typeName`](#highlight.tags.typeName)).\n    */ tagName: t(typeName),\n    /**\n    A property or field [name](#highlight.tags.name).\n    */ propertyName: propertyName,\n    /**\n    An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).\n    */ attributeName: t(propertyName),\n    /**\n    The [name](#highlight.tags.name) of a class.\n    */ className: t(name),\n    /**\n    A label [name](#highlight.tags.name).\n    */ labelName: t(name),\n    /**\n    A namespace [name](#highlight.tags.name).\n    */ namespace: t(name),\n    /**\n    The [name](#highlight.tags.name) of a macro.\n    */ macroName: t(name),\n    /**\n    A literal value.\n    */ literal,\n    /**\n    A string [literal](#highlight.tags.literal).\n    */ string,\n    /**\n    A documentation [string](#highlight.tags.string).\n    */ docString: t(string),\n    /**\n    A character literal (subtag of [string](#highlight.tags.string)).\n    */ character: t(string),\n    /**\n    An attribute value (subtag of [string](#highlight.tags.string)).\n    */ attributeValue: t(string),\n    /**\n    A number [literal](#highlight.tags.literal).\n    */ number,\n    /**\n    An integer [number](#highlight.tags.number) literal.\n    */ integer: t(number),\n    /**\n    A floating-point [number](#highlight.tags.number) literal.\n    */ float: t(number),\n    /**\n    A boolean [literal](#highlight.tags.literal).\n    */ bool: t(literal),\n    /**\n    Regular expression [literal](#highlight.tags.literal).\n    */ regexp: t(literal),\n    /**\n    An escape [literal](#highlight.tags.literal), for example a\n    backslash escape in a string.\n    */ escape: t(literal),\n    /**\n    A color [literal](#highlight.tags.literal).\n    */ color: t(literal),\n    /**\n    A URL [literal](#highlight.tags.literal).\n    */ url: t(literal),\n    /**\n    A language keyword.\n    */ keyword,\n    /**\n    The [keyword](#highlight.tags.keyword) for the self or this\n    object.\n    */ self: t(keyword),\n    /**\n    The [keyword](#highlight.tags.keyword) for null.\n    */ null: t(keyword),\n    /**\n    A [keyword](#highlight.tags.keyword) denoting some atomic value.\n    */ atom: t(keyword),\n    /**\n    A [keyword](#highlight.tags.keyword) that represents a unit.\n    */ unit: t(keyword),\n    /**\n    A modifier [keyword](#highlight.tags.keyword).\n    */ modifier: t(keyword),\n    /**\n    A [keyword](#highlight.tags.keyword) that acts as an operator.\n    */ operatorKeyword: t(keyword),\n    /**\n    A control-flow related [keyword](#highlight.tags.keyword).\n    */ controlKeyword: t(keyword),\n    /**\n    A [keyword](#highlight.tags.keyword) that defines something.\n    */ definitionKeyword: t(keyword),\n    /**\n    A [keyword](#highlight.tags.keyword) related to defining or\n    interfacing with modules.\n    */ moduleKeyword: t(keyword),\n    /**\n    An operator.\n    */ operator,\n    /**\n    An [operator](#highlight.tags.operator) that dereferences something.\n    */ derefOperator: t(operator),\n    /**\n    Arithmetic-related [operator](#highlight.tags.operator).\n    */ arithmeticOperator: t(operator),\n    /**\n    Logical [operator](#highlight.tags.operator).\n    */ logicOperator: t(operator),\n    /**\n    Bit [operator](#highlight.tags.operator).\n    */ bitwiseOperator: t(operator),\n    /**\n    Comparison [operator](#highlight.tags.operator).\n    */ compareOperator: t(operator),\n    /**\n    [Operator](#highlight.tags.operator) that updates its operand.\n    */ updateOperator: t(operator),\n    /**\n    [Operator](#highlight.tags.operator) that defines something.\n    */ definitionOperator: t(operator),\n    /**\n    Type-related [operator](#highlight.tags.operator).\n    */ typeOperator: t(operator),\n    /**\n    Control-flow [operator](#highlight.tags.operator).\n    */ controlOperator: t(operator),\n    /**\n    Program or markup punctuation.\n    */ punctuation,\n    /**\n    [Punctuation](#highlight.tags.punctuation) that separates\n    things.\n    */ separator: t(punctuation),\n    /**\n    Bracket-style [punctuation](#highlight.tags.punctuation).\n    */ bracket,\n    /**\n    Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`\n    tokens).\n    */ angleBracket: t(bracket),\n    /**\n    Square [brackets](#highlight.tags.bracket) (usually `[` and `]`\n    tokens).\n    */ squareBracket: t(bracket),\n    /**\n    Parentheses (usually `(` and `)` tokens). Subtag of\n    [bracket](#highlight.tags.bracket).\n    */ paren: t(bracket),\n    /**\n    Braces (usually `{` and `}` tokens). Subtag of\n    [bracket](#highlight.tags.bracket).\n    */ brace: t(bracket),\n    /**\n    Content, for example plain text in XML or markup documents.\n    */ content,\n    /**\n    [Content](#highlight.tags.content) that represents a heading.\n    */ heading,\n    /**\n    A level 1 [heading](#highlight.tags.heading).\n    */ heading1: t(heading),\n    /**\n    A level 2 [heading](#highlight.tags.heading).\n    */ heading2: t(heading),\n    /**\n    A level 3 [heading](#highlight.tags.heading).\n    */ heading3: t(heading),\n    /**\n    A level 4 [heading](#highlight.tags.heading).\n    */ heading4: t(heading),\n    /**\n    A level 5 [heading](#highlight.tags.heading).\n    */ heading5: t(heading),\n    /**\n    A level 6 [heading](#highlight.tags.heading).\n    */ heading6: t(heading),\n    /**\n    A prose separator (such as a horizontal rule).\n    */ contentSeparator: t(content),\n    /**\n    [Content](#highlight.tags.content) that represents a list.\n    */ list: t(content),\n    /**\n    [Content](#highlight.tags.content) that represents a quote.\n    */ quote: t(content),\n    /**\n    [Content](#highlight.tags.content) that is emphasized.\n    */ emphasis: t(content),\n    /**\n    [Content](#highlight.tags.content) that is styled strong.\n    */ strong: t(content),\n    /**\n    [Content](#highlight.tags.content) that is part of a link.\n    */ link: t(content),\n    /**\n    [Content](#highlight.tags.content) that is styled as code or\n    monospace.\n    */ monospace: t(content),\n    /**\n    [Content](#highlight.tags.content) that has a strike-through\n    style.\n    */ strikethrough: t(content),\n    /**\n    Inserted text in a change-tracking format.\n    */ inserted: t(),\n    /**\n    Deleted text.\n    */ deleted: t(),\n    /**\n    Changed text.\n    */ changed: t(),\n    /**\n    An invalid or unsyntactic element.\n    */ invalid: t(),\n    /**\n    Metadata or meta-instruction.\n    */ meta,\n    /**\n    [Metadata](#highlight.tags.meta) that applies to the entire\n    document.\n    */ documentMeta: t(meta),\n    /**\n    [Metadata](#highlight.tags.meta) that annotates or adds\n    attributes to a given syntactic element.\n    */ annotation: t(meta),\n    /**\n    Processing instruction or preprocessor directive. Subtag of\n    [meta](#highlight.tags.meta).\n    */ processingInstruction: t(meta),\n    /**\n    [Modifier](#highlight.Tag^defineModifier) that indicates that a\n    given element is being defined. Expected to be used with the\n    various [name](#highlight.tags.name) tags.\n    */ definition: Tag.defineModifier(),\n    /**\n    [Modifier](#highlight.Tag^defineModifier) that indicates that\n    something is constant. Mostly expected to be used with\n    [variable names](#highlight.tags.variableName).\n    */ constant: Tag.defineModifier(),\n    /**\n    [Modifier](#highlight.Tag^defineModifier) used to indicate that\n    a [variable](#highlight.tags.variableName) or [property\n    name](#highlight.tags.propertyName) is being called or defined\n    as a function.\n    */ function: Tag.defineModifier(),\n    /**\n    [Modifier](#highlight.Tag^defineModifier) that can be applied to\n    [names](#highlight.tags.name) to indicate that they belong to\n    the language's standard environment.\n    */ standard: Tag.defineModifier(),\n    /**\n    [Modifier](#highlight.Tag^defineModifier) that indicates a given\n    [names](#highlight.tags.name) is local to some scope.\n    */ local: Tag.defineModifier(),\n    /**\n    A generic variant [modifier](#highlight.Tag^defineModifier) that\n    can be used to tag language-specific alternative variants of\n    some common tag. It is recommended for themes to define special\n    forms of at least the [string](#highlight.tags.string) and\n    [variable name](#highlight.tags.variableName) tags, since those\n    come up a lot.\n    */ special: Tag.defineModifier()\n};\n/**\nThis is a highlighter that adds stable, predictable classes to\ntokens, for styling with external CSS.\n\nThe following tags are mapped to their name prefixed with `\"tok-\"`\n(for example `\"tok-comment\"`):\n\n* [`link`](#highlight.tags.link)\n* [`heading`](#highlight.tags.heading)\n* [`emphasis`](#highlight.tags.emphasis)\n* [`strong`](#highlight.tags.strong)\n* [`keyword`](#highlight.tags.keyword)\n* [`atom`](#highlight.tags.atom)\n* [`bool`](#highlight.tags.bool)\n* [`url`](#highlight.tags.url)\n* [`labelName`](#highlight.tags.labelName)\n* [`inserted`](#highlight.tags.inserted)\n* [`deleted`](#highlight.tags.deleted)\n* [`literal`](#highlight.tags.literal)\n* [`string`](#highlight.tags.string)\n* [`number`](#highlight.tags.number)\n* [`variableName`](#highlight.tags.variableName)\n* [`typeName`](#highlight.tags.typeName)\n* [`namespace`](#highlight.tags.namespace)\n* [`className`](#highlight.tags.className)\n* [`macroName`](#highlight.tags.macroName)\n* [`propertyName`](#highlight.tags.propertyName)\n* [`operator`](#highlight.tags.operator)\n* [`comment`](#highlight.tags.comment)\n* [`meta`](#highlight.tags.meta)\n* [`punctuation`](#highlight.tags.punctuation)\n* [`invalid`](#highlight.tags.invalid)\n\nIn addition, these mappings are provided:\n\n* [`regexp`](#highlight.tags.regexp),\n  [`escape`](#highlight.tags.escape), and\n  [`special`](#highlight.tags.special)[`(string)`](#highlight.tags.string)\n  are mapped to `\"tok-string2\"`\n* [`special`](#highlight.tags.special)[`(variableName)`](#highlight.tags.variableName)\n  to `\"tok-variableName2\"`\n* [`local`](#highlight.tags.local)[`(variableName)`](#highlight.tags.variableName)\n  to `\"tok-variableName tok-local\"`\n* [`definition`](#highlight.tags.definition)[`(variableName)`](#highlight.tags.variableName)\n  to `\"tok-variableName tok-definition\"`\n* [`definition`](#highlight.tags.definition)[`(propertyName)`](#highlight.tags.propertyName)\n  to `\"tok-propertyName tok-definition\"`\n*/ const classHighlighter = tagHighlighter([\n    {\n        tag: tags.link,\n        class: \"tok-link\"\n    },\n    {\n        tag: tags.heading,\n        class: \"tok-heading\"\n    },\n    {\n        tag: tags.emphasis,\n        class: \"tok-emphasis\"\n    },\n    {\n        tag: tags.strong,\n        class: \"tok-strong\"\n    },\n    {\n        tag: tags.keyword,\n        class: \"tok-keyword\"\n    },\n    {\n        tag: tags.atom,\n        class: \"tok-atom\"\n    },\n    {\n        tag: tags.bool,\n        class: \"tok-bool\"\n    },\n    {\n        tag: tags.url,\n        class: \"tok-url\"\n    },\n    {\n        tag: tags.labelName,\n        class: \"tok-labelName\"\n    },\n    {\n        tag: tags.inserted,\n        class: \"tok-inserted\"\n    },\n    {\n        tag: tags.deleted,\n        class: \"tok-deleted\"\n    },\n    {\n        tag: tags.literal,\n        class: \"tok-literal\"\n    },\n    {\n        tag: tags.string,\n        class: \"tok-string\"\n    },\n    {\n        tag: tags.number,\n        class: \"tok-number\"\n    },\n    {\n        tag: [\n            tags.regexp,\n            tags.escape,\n            tags.special(tags.string)\n        ],\n        class: \"tok-string2\"\n    },\n    {\n        tag: tags.variableName,\n        class: \"tok-variableName\"\n    },\n    {\n        tag: tags.local(tags.variableName),\n        class: \"tok-variableName tok-local\"\n    },\n    {\n        tag: tags.definition(tags.variableName),\n        class: \"tok-variableName tok-definition\"\n    },\n    {\n        tag: tags.special(tags.variableName),\n        class: \"tok-variableName2\"\n    },\n    {\n        tag: tags.definition(tags.propertyName),\n        class: \"tok-propertyName tok-definition\"\n    },\n    {\n        tag: tags.typeName,\n        class: \"tok-typeName\"\n    },\n    {\n        tag: tags.namespace,\n        class: \"tok-namespace\"\n    },\n    {\n        tag: tags.className,\n        class: \"tok-className\"\n    },\n    {\n        tag: tags.macroName,\n        class: \"tok-macroName\"\n    },\n    {\n        tag: tags.propertyName,\n        class: \"tok-propertyName\"\n    },\n    {\n        tag: tags.operator,\n        class: \"tok-operator\"\n    },\n    {\n        tag: tags.comment,\n        class: \"tok-comment\"\n    },\n    {\n        tag: tags.meta,\n        class: \"tok-meta\"\n    },\n    {\n        tag: tags.invalid,\n        class: \"tok-invalid\"\n    },\n    {\n        tag: tags.punctuation,\n        class: \"tok-punctuation\"\n    }\n]);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxlemVyL2hpZ2hsaWdodC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUF5QztBQUV6QyxJQUFJQyxZQUFZO0FBQ2hCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQkEsR0FDQSxNQUFNQztJQUNGOztJQUVBLEdBQ0FDLFlBQ0E7OztJQUdBLEdBQ0FDLEdBQUcsRUFDSDs7O0lBR0EsR0FDQUMsSUFBSSxFQUNKOztJQUVBLEdBQ0FDLFFBQVEsQ0FBRTtRQUNOLElBQUksQ0FBQ0YsR0FBRyxHQUFHQTtRQUNYLElBQUksQ0FBQ0MsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQ0MsUUFBUSxHQUFHQTtRQUNoQjs7UUFFQSxHQUNBLElBQUksQ0FBQ0MsRUFBRSxHQUFHTjtJQUNkO0lBQ0E7Ozs7OztJQU1BLEdBQ0EsT0FBT08sT0FBT0MsTUFBTSxFQUFFO1FBQ2xCLElBQUlBLFdBQVcsUUFBUUEsV0FBVyxLQUFLLElBQUksS0FBSyxJQUFJQSxPQUFPSixJQUFJLEVBQzNELE1BQU0sSUFBSUssTUFBTTtRQUNwQixJQUFJQyxNQUFNLElBQUlULElBQUksRUFBRSxFQUFFLE1BQU0sRUFBRTtRQUM5QlMsSUFBSVAsR0FBRyxDQUFDUSxJQUFJLENBQUNEO1FBQ2IsSUFBSUYsUUFDQSxLQUFLLElBQUlJLEtBQUtKLE9BQU9MLEdBQUcsQ0FDcEJPLElBQUlQLEdBQUcsQ0FBQ1EsSUFBSSxDQUFDQztRQUNyQixPQUFPRjtJQUNYO0lBQ0E7Ozs7Ozs7Ozs7O0lBV0EsR0FDQSxPQUFPRyxpQkFBaUI7UUFDcEIsSUFBSUMsTUFBTSxJQUFJQztRQUNkLE9BQU8sQ0FBQ0w7WUFDSixJQUFJQSxJQUFJTCxRQUFRLENBQUNXLE9BQU8sQ0FBQ0YsT0FBTyxDQUFDLEdBQzdCLE9BQU9KO1lBQ1gsT0FBT0ssU0FBU0UsR0FBRyxDQUFDUCxJQUFJTixJQUFJLElBQUlNLEtBQUtBLElBQUlMLFFBQVEsQ0FBQ2EsTUFBTSxDQUFDSixLQUFL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ZXplci9oaWdobGlnaHQvZGlzdC9pbmRleC5qcz9mMjlhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE5vZGVQcm9wIH0gZnJvbSAnQGxlemVyL2NvbW1vbic7XG5cbmxldCBuZXh0VGFnSUQgPSAwO1xuLyoqXG5IaWdobGlnaHRpbmcgdGFncyBhcmUgbWFya2VycyB0aGF0IGRlbm90ZSBhIGhpZ2hsaWdodGluZyBjYXRlZ29yeS5cblRoZXkgYXJlIFthc3NvY2lhdGVkXSgjaGlnaGxpZ2h0LnN0eWxlVGFncykgd2l0aCBwYXJ0cyBvZiBhIHN5bnRheFxudHJlZSBieSBhIGxhbmd1YWdlIG1vZGUsIGFuZCB0aGVuIG1hcHBlZCB0byBhbiBhY3R1YWwgQ1NTIHN0eWxlIGJ5XG5hIFtoaWdobGlnaHRlcl0oI2hpZ2hsaWdodC5IaWdobGlnaHRlcikuXG5cbkJlY2F1c2Ugc3ludGF4IHRyZWUgbm9kZSB0eXBlcyBhbmQgaGlnaGxpZ2h0IHN0eWxlcyBoYXZlIHRvIGJlXG5hYmxlIHRvIHRhbGsgdGhlIHNhbWUgbGFuZ3VhZ2UsIENvZGVNaXJyb3IgdXNlcyBhIG1vc3RseSBfY2xvc2VkX1xuW3ZvY2FidWxhcnldKCNoaWdobGlnaHQudGFncykgb2Ygc3ludGF4IHRhZ3MgKGFzIG9wcG9zZWQgdG9cbnRyYWRpdGlvbmFsIG9wZW4gc3RyaW5nLWJhc2VkIHN5c3RlbXMsIHdoaWNoIG1ha2UgaXQgaGFyZCBmb3JcbmhpZ2hsaWdodGluZyB0aGVtZXMgdG8gY292ZXIgYWxsIHRoZSB0b2tlbnMgcHJvZHVjZWQgYnkgdGhlXG52YXJpb3VzIGxhbmd1YWdlcykuXG5cbkl0IF9pc18gcG9zc2libGUgdG8gW2RlZmluZV0oI2hpZ2hsaWdodC5UYWdeZGVmaW5lKSB5b3VyIG93blxuaGlnaGxpZ2h0aW5nIHRhZ3MgZm9yIHN5c3RlbS1pbnRlcm5hbCB1c2UgKHdoZXJlIHlvdSBjb250cm9sIGJvdGhcbnRoZSBsYW5ndWFnZSBwYWNrYWdlIGFuZCB0aGUgaGlnaGxpZ2h0ZXIpLCBidXQgc3VjaCB0YWdzIHdpbGwgbm90XG5iZSBwaWNrZWQgdXAgYnkgcmVndWxhciBoaWdobGlnaHRlcnMgKHRob3VnaCB5b3UgY2FuIGRlcml2ZSB0aGVtXG5mcm9tIHN0YW5kYXJkIHRhZ3MgdG8gYWxsb3cgaGlnaGxpZ2h0ZXJzIHRvIGZhbGwgYmFjayB0byB0aG9zZSkuXG4qL1xuY2xhc3MgVGFnIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBzZXQgb2YgdGhpcyB0YWcgYW5kIGFsbCBpdHMgcGFyZW50IHRhZ3MsIHN0YXJ0aW5nIHdpdGhcbiAgICB0aGlzIG9uZSBpdHNlbGYgYW5kIHNvcnRlZCBpbiBvcmRlciBvZiBkZWNyZWFzaW5nIHNwZWNpZmljaXR5LlxuICAgICovXG4gICAgc2V0LCBcbiAgICAvKipcbiAgICBUaGUgYmFzZSB1bm1vZGlmaWVkIHRhZyB0aGF0IHRoaXMgb25lIGlzIGJhc2VkIG9uLCBpZiBpdCdzXG4gICAgbW9kaWZpZWQgQGludGVybmFsXG4gICAgKi9cbiAgICBiYXNlLCBcbiAgICAvKipcbiAgICBUaGUgbW9kaWZpZXJzIGFwcGxpZWQgdG8gdGhpcy5iYXNlIEBpbnRlcm5hbFxuICAgICovXG4gICAgbW9kaWZpZWQpIHtcbiAgICAgICAgdGhpcy5zZXQgPSBzZXQ7XG4gICAgICAgIHRoaXMuYmFzZSA9IGJhc2U7XG4gICAgICAgIHRoaXMubW9kaWZpZWQgPSBtb2RpZmllZDtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmlkID0gbmV4dFRhZ0lEKys7XG4gICAgfVxuICAgIC8qKlxuICAgIERlZmluZSBhIG5ldyB0YWcuIElmIGBwYXJlbnRgIGlzIGdpdmVuLCB0aGUgdGFnIGlzIHRyZWF0ZWQgYXMgYVxuICAgIHN1Yi10YWcgb2YgdGhhdCBwYXJlbnQsIGFuZFxuICAgIFtoaWdobGlnaHRlcnNdKCNoaWdobGlnaHQudGFnSGlnaGxpZ2h0ZXIpIHRoYXQgZG9uJ3QgbWVudGlvblxuICAgIHRoaXMgdGFnIHdpbGwgdHJ5IHRvIGZhbGwgYmFjayB0byB0aGUgcGFyZW50IHRhZyAob3IgZ3JhbmRwYXJlbnRcbiAgICB0YWcsIGV0YykuXG4gICAgKi9cbiAgICBzdGF0aWMgZGVmaW5lKHBhcmVudCkge1xuICAgICAgICBpZiAocGFyZW50ID09PSBudWxsIHx8IHBhcmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyZW50LmJhc2UpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IGRlcml2ZSBmcm9tIGEgbW9kaWZpZWQgdGFnXCIpO1xuICAgICAgICBsZXQgdGFnID0gbmV3IFRhZyhbXSwgbnVsbCwgW10pO1xuICAgICAgICB0YWcuc2V0LnB1c2godGFnKTtcbiAgICAgICAgaWYgKHBhcmVudClcbiAgICAgICAgICAgIGZvciAobGV0IHQgb2YgcGFyZW50LnNldClcbiAgICAgICAgICAgICAgICB0YWcuc2V0LnB1c2godCk7XG4gICAgICAgIHJldHVybiB0YWc7XG4gICAgfVxuICAgIC8qKlxuICAgIERlZmluZSBhIHRhZyBfbW9kaWZpZXJfLCB3aGljaCBpcyBhIGZ1bmN0aW9uIHRoYXQsIGdpdmVuIGEgdGFnLFxuICAgIHdpbGwgcmV0dXJuIGEgdGFnIHRoYXQgaXMgYSBzdWJ0YWcgb2YgdGhlIG9yaWdpbmFsLiBBcHBseWluZyB0aGVcbiAgICBzYW1lIG1vZGlmaWVyIHRvIGEgdHdpY2UgdGFnIHdpbGwgcmV0dXJuIHRoZSBzYW1lIHZhbHVlIChgbTEodDEpXG4gICAgPT0gbTEodDEpYCkgYW5kIGFwcGx5aW5nIG11bHRpcGxlIG1vZGlmaWVycyB3aWxsLCByZWdhcmRsZXNzIG9yXG4gICAgb3JkZXIsIHByb2R1Y2UgdGhlIHNhbWUgdGFnIChgbTEobTIodDEpKSA9PSBtMihtMSh0MSkpYCkuXG4gICAgXG4gICAgV2hlbiBtdWx0aXBsZSBtb2RpZmllcnMgYXJlIGFwcGxpZWQgdG8gYSBnaXZlbiBiYXNlIHRhZywgZWFjaFxuICAgIHNtYWxsZXIgc2V0IG9mIG1vZGlmaWVycyBpcyByZWdpc3RlcmVkIGFzIGEgcGFyZW50LCBzbyB0aGF0IGZvclxuICAgIGV4YW1wbGUgYG0xKG0yKG0zKHQxKSkpYCBpcyBhIHN1YnR5cGUgb2YgYG0xKG0yKHQxKSlgLFxuICAgIGBtMShtMyh0MSlgLCBhbmQgc28gb24uXG4gICAgKi9cbiAgICBzdGF0aWMgZGVmaW5lTW9kaWZpZXIoKSB7XG4gICAgICAgIGxldCBtb2QgPSBuZXcgTW9kaWZpZXI7XG4gICAgICAgIHJldHVybiAodGFnKSA9PiB7XG4gICAgICAgICAgICBpZiAodGFnLm1vZGlmaWVkLmluZGV4T2YobW9kKSA+IC0xKVxuICAgICAgICAgICAgICAgIHJldHVybiB0YWc7XG4gICAgICAgICAgICByZXR1cm4gTW9kaWZpZXIuZ2V0KHRhZy5iYXNlIHx8IHRhZywgdGFnLm1vZGlmaWVkLmNvbmNhdChtb2QpLnNvcnQoKGEsIGIpID0+IGEuaWQgLSBiLmlkKSk7XG4gICAgICAgIH07XG4gICAgfVxufVxubGV0IG5leHRNb2RpZmllcklEID0gMDtcbmNsYXNzIE1vZGlmaWVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5pbnN0YW5jZXMgPSBbXTtcbiAgICAgICAgdGhpcy5pZCA9IG5leHRNb2RpZmllcklEKys7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQoYmFzZSwgbW9kcykge1xuICAgICAgICBpZiAoIW1vZHMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgICAgIGxldCBleGlzdHMgPSBtb2RzWzBdLmluc3RhbmNlcy5maW5kKHQgPT4gdC5iYXNlID09IGJhc2UgJiYgc2FtZUFycmF5KG1vZHMsIHQubW9kaWZpZWQpKTtcbiAgICAgICAgaWYgKGV4aXN0cylcbiAgICAgICAgICAgIHJldHVybiBleGlzdHM7XG4gICAgICAgIGxldCBzZXQgPSBbXSwgdGFnID0gbmV3IFRhZyhzZXQsIGJhc2UsIG1vZHMpO1xuICAgICAgICBmb3IgKGxldCBtIG9mIG1vZHMpXG4gICAgICAgICAgICBtLmluc3RhbmNlcy5wdXNoKHRhZyk7XG4gICAgICAgIGxldCBjb25maWdzID0gcG93ZXJTZXQobW9kcyk7XG4gICAgICAgIGZvciAobGV0IHBhcmVudCBvZiBiYXNlLnNldClcbiAgICAgICAgICAgIGlmICghcGFyZW50Lm1vZGlmaWVkLmxlbmd0aClcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjb25maWcgb2YgY29uZmlncylcbiAgICAgICAgICAgICAgICAgICAgc2V0LnB1c2goTW9kaWZpZXIuZ2V0KHBhcmVudCwgY29uZmlnKSk7XG4gICAgICAgIHJldHVybiB0YWc7XG4gICAgfVxufVxuZnVuY3Rpb24gc2FtZUFycmF5KGEsIGIpIHtcbiAgICByZXR1cm4gYS5sZW5ndGggPT0gYi5sZW5ndGggJiYgYS5ldmVyeSgoeCwgaSkgPT4geCA9PSBiW2ldKTtcbn1cbmZ1bmN0aW9uIHBvd2VyU2V0KGFycmF5KSB7XG4gICAgbGV0IHNldHMgPSBbW11dO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZm9yIChsZXQgaiA9IDAsIGUgPSBzZXRzLmxlbmd0aDsgaiA8IGU7IGorKykge1xuICAgICAgICAgICAgc2V0cy5wdXNoKHNldHNbal0uY29uY2F0KGFycmF5W2ldKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNldHMuc29ydCgoYSwgYikgPT4gYi5sZW5ndGggLSBhLmxlbmd0aCk7XG59XG4vKipcblRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byBhZGQgYSBzZXQgb2YgdGFncyB0byBhIGxhbmd1YWdlIHN5bnRheFxudmlhIFtgTm9kZVNldC5leHRlbmRgXSgjY29tbW9uLk5vZGVTZXQuZXh0ZW5kKSBvclxuW2BMUlBhcnNlci5jb25maWd1cmVgXSgjbHIuTFJQYXJzZXIuY29uZmlndXJlKS5cblxuVGhlIGFyZ3VtZW50IG9iamVjdCBtYXBzIG5vZGUgc2VsZWN0b3JzIHRvIFtoaWdobGlnaHRpbmdcbnRhZ3NdKCNoaWdobGlnaHQuVGFnKSBvciBhcnJheXMgb2YgdGFncy5cblxuTm9kZSBzZWxlY3RvcnMgbWF5IGhvbGQgb25lIG9yIG1vcmUgKHNwYWNlLXNlcGFyYXRlZCkgbm9kZSBwYXRocy5cblN1Y2ggYSBwYXRoIGNhbiBiZSBhIFtub2RlIG5hbWVdKCNjb21tb24uTm9kZVR5cGUubmFtZSksIG9yXG5tdWx0aXBsZSBub2RlIG5hbWVzIChvciBgKmAgd2lsZGNhcmRzKSBzZXBhcmF0ZWQgYnkgc2xhc2hcbmNoYXJhY3RlcnMsIGFzIGluIGBcIkJsb2NrL0RlY2xhcmF0aW9uL1ZhcmlhYmxlTmFtZVwiYC4gU3VjaCBhIHBhdGhcbm1hdGNoZXMgdGhlIGZpbmFsIG5vZGUgYnV0IG9ubHkgaWYgaXRzIGRpcmVjdCBwYXJlbnQgbm9kZXMgYXJlIHRoZVxub3RoZXIgbm9kZXMgbWVudGlvbmVkLiBBIGAqYCBpbiBzdWNoIGEgcGF0aCBtYXRjaGVzIGFueSBwYXJlbnQsXG5idXQgb25seSBhIHNpbmdsZSBsZXZlbOKAlHdpbGRjYXJkcyB0aGF0IG1hdGNoIG11bHRpcGxlIHBhcmVudHNcbmFyZW4ndCBzdXBwb3J0ZWQsIGJvdGggZm9yIGVmZmljaWVuY3kgcmVhc29ucyBhbmQgYmVjYXVzZSBMZXplclxudHJlZXMgbWFrZSBpdCByYXRoZXIgaGFyZCB0byByZWFzb24gYWJvdXQgd2hhdCB0aGV5IHdvdWxkIG1hdGNoLilcblxuQSBwYXRoIGNhbiBiZSBlbmRlZCB3aXRoIGAvLi4uYCB0byBpbmRpY2F0ZSB0aGF0IHRoZSB0YWcgYXNzaWduZWRcbnRvIHRoZSBub2RlIHNob3VsZCBhbHNvIGFwcGx5IHRvIGFsbCBjaGlsZCBub2RlcywgZXZlbiBpZiB0aGV5XG5tYXRjaCB0aGVpciBvd24gc3R5bGUgKGJ5IGRlZmF1bHQsIG9ubHkgdGhlIGlubmVybW9zdCBzdHlsZSBpc1xudXNlZCkuXG5cbldoZW4gYSBwYXRoIGVuZHMgaW4gYCFgLCBhcyBpbiBgQXR0cmlidXRlIWAsIG5vIGZ1cnRoZXIgbWF0Y2hpbmdcbmhhcHBlbnMgZm9yIHRoZSBub2RlJ3MgY2hpbGQgbm9kZXMsIGFuZCB0aGUgZW50aXJlIG5vZGUgZ2V0cyB0aGVcbmdpdmVuIHN0eWxlLlxuXG5JbiB0aGlzIG5vdGF0aW9uLCBub2RlIG5hbWVzIHRoYXQgY29udGFpbiBgL2AsIGAhYCwgYCpgLCBvciBgLi4uYFxubXVzdCBiZSBxdW90ZWQgYXMgSlNPTiBzdHJpbmdzLlxuXG5Gb3IgZXhhbXBsZTpcblxuYGBgamF2YXNjcmlwdFxucGFyc2VyLndpdGhQcm9wcyhcbiAgc3R5bGVUYWdzKHtcbiAgICAvLyBTdHlsZSBOdW1iZXIgYW5kIEJpZ051bWJlciBub2Rlc1xuICAgIFwiTnVtYmVyIEJpZ051bWJlclwiOiB0YWdzLm51bWJlcixcbiAgICAvLyBTdHlsZSBFc2NhcGUgbm9kZXMgd2hvc2UgcGFyZW50IGlzIFN0cmluZ1xuICAgIFwiU3RyaW5nL0VzY2FwZVwiOiB0YWdzLmVzY2FwZSxcbiAgICAvLyBTdHlsZSBhbnl0aGluZyBpbnNpZGUgQXR0cmlidXRlcyBub2Rlc1xuICAgIFwiQXR0cmlidXRlcyFcIjogdGFncy5tZXRhLFxuICAgIC8vIEFkZCBhIHN0eWxlIHRvIGFsbCBjb250ZW50IGluc2lkZSBJdGFsaWMgbm9kZXNcbiAgICBcIkl0YWxpYy8uLi5cIjogdGFncy5lbXBoYXNpcyxcbiAgICAvLyBTdHlsZSBJbnZhbGlkU3RyaW5nIG5vZGVzIGFzIGJvdGggYHN0cmluZ2AgYW5kIGBpbnZhbGlkYFxuICAgIFwiSW52YWxpZFN0cmluZ1wiOiBbdGFncy5zdHJpbmcsIHRhZ3MuaW52YWxpZF0sXG4gICAgLy8gU3R5bGUgdGhlIG5vZGUgbmFtZWQgXCIvXCIgYXMgcHVuY3R1YXRpb25cbiAgICAnXCIvXCInOiB0YWdzLnB1bmN0dWF0aW9uXG4gIH0pXG4pXG5gYGBcbiovXG5mdW5jdGlvbiBzdHlsZVRhZ3Moc3BlYykge1xuICAgIGxldCBieU5hbWUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGZvciAobGV0IHByb3AgaW4gc3BlYykge1xuICAgICAgICBsZXQgdGFncyA9IHNwZWNbcHJvcF07XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh0YWdzKSlcbiAgICAgICAgICAgIHRhZ3MgPSBbdGFnc107XG4gICAgICAgIGZvciAobGV0IHBhcnQgb2YgcHJvcC5zcGxpdChcIiBcIikpXG4gICAgICAgICAgICBpZiAocGFydCkge1xuICAgICAgICAgICAgICAgIGxldCBwaWVjZXMgPSBbXSwgbW9kZSA9IDIgLyogTW9kZS5Ob3JtYWwgKi8sIHJlc3QgPSBwYXJ0O1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHBvcyA9IDA7Oykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdCA9PSBcIi4uLlwiICYmIHBvcyA+IDAgJiYgcG9zICsgMyA9PSBwYXJ0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZSA9IDEgLyogTW9kZS5Jbmhlcml0ICovO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGV0IG0gPSAvXlwiKD86W15cIlxcXFxdfFxcXFwuKSo/XCJ8W15cXC8hXSsvLmV4ZWMocmVzdCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBwYXRoOiBcIiArIHBhcnQpO1xuICAgICAgICAgICAgICAgICAgICBwaWVjZXMucHVzaChtWzBdID09IFwiKlwiID8gXCJcIiA6IG1bMF1bMF0gPT0gJ1wiJyA/IEpTT04ucGFyc2UobVswXSkgOiBtWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgcG9zICs9IG1bMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zID09IHBhcnQubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gcGFydFtwb3MrK107XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3MgPT0gcGFydC5sZW5ndGggJiYgbmV4dCA9PSBcIiFcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZSA9IDAgLyogTW9kZS5PcGFxdWUgKi87XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCAhPSBcIi9cIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBwYXRoOiBcIiArIHBhcnQpO1xuICAgICAgICAgICAgICAgICAgICByZXN0ID0gcGFydC5zbGljZShwb3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgbGFzdCA9IHBpZWNlcy5sZW5ndGggLSAxLCBpbm5lciA9IHBpZWNlc1tsYXN0XTtcbiAgICAgICAgICAgICAgICBpZiAoIWlubmVyKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgcGF0aDogXCIgKyBwYXJ0KTtcbiAgICAgICAgICAgICAgICBsZXQgcnVsZSA9IG5ldyBSdWxlKHRhZ3MsIG1vZGUsIGxhc3QgPiAwID8gcGllY2VzLnNsaWNlKDAsIGxhc3QpIDogbnVsbCk7XG4gICAgICAgICAgICAgICAgYnlOYW1lW2lubmVyXSA9IHJ1bGUuc29ydChieU5hbWVbaW5uZXJdKTtcbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJ1bGVOb2RlUHJvcC5hZGQoYnlOYW1lKTtcbn1cbmNvbnN0IHJ1bGVOb2RlUHJvcCA9IG5ldyBOb2RlUHJvcCgpO1xuY2xhc3MgUnVsZSB7XG4gICAgY29uc3RydWN0b3IodGFncywgbW9kZSwgY29udGV4dCwgbmV4dCkge1xuICAgICAgICB0aGlzLnRhZ3MgPSB0YWdzO1xuICAgICAgICB0aGlzLm1vZGUgPSBtb2RlO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLm5leHQgPSBuZXh0O1xuICAgIH1cbiAgICBnZXQgb3BhcXVlKCkgeyByZXR1cm4gdGhpcy5tb2RlID09IDAgLyogTW9kZS5PcGFxdWUgKi87IH1cbiAgICBnZXQgaW5oZXJpdCgpIHsgcmV0dXJuIHRoaXMubW9kZSA9PSAxIC8qIE1vZGUuSW5oZXJpdCAqLzsgfVxuICAgIHNvcnQob3RoZXIpIHtcbiAgICAgICAgaWYgKCFvdGhlciB8fCBvdGhlci5kZXB0aCA8IHRoaXMuZGVwdGgpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dCA9IG90aGVyO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgb3RoZXIubmV4dCA9IHRoaXMuc29ydChvdGhlci5uZXh0KTtcbiAgICAgICAgcmV0dXJuIG90aGVyO1xuICAgIH1cbiAgICBnZXQgZGVwdGgoKSB7IHJldHVybiB0aGlzLmNvbnRleHQgPyB0aGlzLmNvbnRleHQubGVuZ3RoIDogMDsgfVxufVxuUnVsZS5lbXB0eSA9IG5ldyBSdWxlKFtdLCAyIC8qIE1vZGUuTm9ybWFsICovLCBudWxsKTtcbi8qKlxuRGVmaW5lIGEgW2hpZ2hsaWdodGVyXSgjaGlnaGxpZ2h0LkhpZ2hsaWdodGVyKSBmcm9tIGFuIGFycmF5IG9mXG50YWcvY2xhc3MgcGFpcnMuIENsYXNzZXMgYXNzb2NpYXRlZCB3aXRoIG1vcmUgc3BlY2lmaWMgdGFncyB3aWxsXG50YWtlIHByZWNlZGVuY2UuXG4qL1xuZnVuY3Rpb24gdGFnSGlnaGxpZ2h0ZXIodGFncywgb3B0aW9ucykge1xuICAgIGxldCBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGZvciAobGV0IHN0eWxlIG9mIHRhZ3MpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHN0eWxlLnRhZykpXG4gICAgICAgICAgICBtYXBbc3R5bGUudGFnLmlkXSA9IHN0eWxlLmNsYXNzO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBmb3IgKGxldCB0YWcgb2Ygc3R5bGUudGFnKVxuICAgICAgICAgICAgICAgIG1hcFt0YWcuaWRdID0gc3R5bGUuY2xhc3M7XG4gICAgfVxuICAgIGxldCB7IHNjb3BlLCBhbGwgPSBudWxsIH0gPSBvcHRpb25zIHx8IHt9O1xuICAgIHJldHVybiB7XG4gICAgICAgIHN0eWxlOiAodGFncykgPT4ge1xuICAgICAgICAgICAgbGV0IGNscyA9IGFsbDtcbiAgICAgICAgICAgIGZvciAobGV0IHRhZyBvZiB0YWdzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgc3ViIG9mIHRhZy5zZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRhZ0NsYXNzID0gbWFwW3N1Yi5pZF07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWdDbGFzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xzID0gY2xzID8gY2xzICsgXCIgXCIgKyB0YWdDbGFzcyA6IHRhZ0NsYXNzO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2xzO1xuICAgICAgICB9LFxuICAgICAgICBzY29wZVxuICAgIH07XG59XG5mdW5jdGlvbiBoaWdobGlnaHRUYWdzKGhpZ2hsaWdodGVycywgdGFncykge1xuICAgIGxldCByZXN1bHQgPSBudWxsO1xuICAgIGZvciAobGV0IGhpZ2hsaWdodGVyIG9mIGhpZ2hsaWdodGVycykge1xuICAgICAgICBsZXQgdmFsdWUgPSBoaWdobGlnaHRlci5zdHlsZSh0YWdzKTtcbiAgICAgICAgaWYgKHZhbHVlKVxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0ID8gcmVzdWx0ICsgXCIgXCIgKyB2YWx1ZSA6IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG5IaWdobGlnaHQgdGhlIGdpdmVuIFt0cmVlXSgjY29tbW9uLlRyZWUpIHdpdGggdGhlIGdpdmVuXG5baGlnaGxpZ2h0ZXJdKCNoaWdobGlnaHQuSGlnaGxpZ2h0ZXIpLiBPZnRlbiwgdGhlIGhpZ2hlci1sZXZlbFxuW2BoaWdobGlnaHRDb2RlYF0oI2hpZ2hsaWdodC5oaWdobGlnaHRDb2RlKSBmdW5jdGlvbiBpcyBlYXNpZXIgdG9cbnVzZS5cbiovXG5mdW5jdGlvbiBoaWdobGlnaHRUcmVlKHRyZWUsIGhpZ2hsaWdodGVyLCBcbi8qKlxuQXNzaWduIHN0eWxpbmcgdG8gYSByZWdpb24gb2YgdGhlIHRleHQuIFdpbGwgYmUgY2FsbGVkLCBpbiBvcmRlclxub2YgcG9zaXRpb24sIGZvciBhbnkgcmFuZ2VzIHdoZXJlIG1vcmUgdGhhbiB6ZXJvIGNsYXNzZXMgYXBwbHkuXG5gY2xhc3Nlc2AgaXMgYSBzcGFjZSBzZXBhcmF0ZWQgc3RyaW5nIG9mIENTUyBjbGFzc2VzLlxuKi9cbnB1dFN0eWxlLCBcbi8qKlxuVGhlIHN0YXJ0IG9mIHRoZSByYW5nZSB0byBoaWdobGlnaHQuXG4qL1xuZnJvbSA9IDAsIFxuLyoqXG5UaGUgZW5kIG9mIHRoZSByYW5nZS5cbiovXG50byA9IHRyZWUubGVuZ3RoKSB7XG4gICAgbGV0IGJ1aWxkZXIgPSBuZXcgSGlnaGxpZ2h0QnVpbGRlcihmcm9tLCBBcnJheS5pc0FycmF5KGhpZ2hsaWdodGVyKSA/IGhpZ2hsaWdodGVyIDogW2hpZ2hsaWdodGVyXSwgcHV0U3R5bGUpO1xuICAgIGJ1aWxkZXIuaGlnaGxpZ2h0UmFuZ2UodHJlZS5jdXJzb3IoKSwgZnJvbSwgdG8sIFwiXCIsIGJ1aWxkZXIuaGlnaGxpZ2h0ZXJzKTtcbiAgICBidWlsZGVyLmZsdXNoKHRvKTtcbn1cbi8qKlxuSGlnaGxpZ2h0IHRoZSBnaXZlbiB0cmVlIHdpdGggdGhlIGdpdmVuIGhpZ2hsaWdodGVyLCBjYWxsaW5nXG5gcHV0VGV4dGAgZm9yIGV2ZXJ5IHBpZWNlIG9mIHRleHQsIGVpdGhlciB3aXRoIGEgc2V0IG9mIGNsYXNzZXMgb3JcbndpdGggdGhlIGVtcHR5IHN0cmluZyB3aGVuIHVuc3R5bGVkLCBhbmQgYHB1dEJyZWFrYCBmb3IgZXZlcnkgbGluZVxuYnJlYWsuXG4qL1xuZnVuY3Rpb24gaGlnaGxpZ2h0Q29kZShjb2RlLCB0cmVlLCBoaWdobGlnaHRlciwgcHV0VGV4dCwgcHV0QnJlYWssIGZyb20gPSAwLCB0byA9IGNvZGUubGVuZ3RoKSB7XG4gICAgbGV0IHBvcyA9IGZyb207XG4gICAgZnVuY3Rpb24gd3JpdGVUbyhwLCBjbGFzc2VzKSB7XG4gICAgICAgIGlmIChwIDw9IHBvcylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZm9yIChsZXQgdGV4dCA9IGNvZGUuc2xpY2UocG9zLCBwKSwgaSA9IDA7Oykge1xuICAgICAgICAgICAgbGV0IG5leHRCcmVhayA9IHRleHQuaW5kZXhPZihcIlxcblwiLCBpKTtcbiAgICAgICAgICAgIGxldCB1cHRvID0gbmV4dEJyZWFrIDwgMCA/IHRleHQubGVuZ3RoIDogbmV4dEJyZWFrO1xuICAgICAgICAgICAgaWYgKHVwdG8gPiBpKVxuICAgICAgICAgICAgICAgIHB1dFRleHQodGV4dC5zbGljZShpLCB1cHRvKSwgY2xhc3Nlcyk7XG4gICAgICAgICAgICBpZiAobmV4dEJyZWFrIDwgMClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHB1dEJyZWFrKCk7XG4gICAgICAgICAgICBpID0gbmV4dEJyZWFrICsgMTtcbiAgICAgICAgfVxuICAgICAgICBwb3MgPSBwO1xuICAgIH1cbiAgICBoaWdobGlnaHRUcmVlKHRyZWUsIGhpZ2hsaWdodGVyLCAoZnJvbSwgdG8sIGNsYXNzZXMpID0+IHtcbiAgICAgICAgd3JpdGVUbyhmcm9tLCBcIlwiKTtcbiAgICAgICAgd3JpdGVUbyh0bywgY2xhc3Nlcyk7XG4gICAgfSwgZnJvbSwgdG8pO1xuICAgIHdyaXRlVG8odG8sIFwiXCIpO1xufVxuY2xhc3MgSGlnaGxpZ2h0QnVpbGRlciB7XG4gICAgY29uc3RydWN0b3IoYXQsIGhpZ2hsaWdodGVycywgc3Bhbikge1xuICAgICAgICB0aGlzLmF0ID0gYXQ7XG4gICAgICAgIHRoaXMuaGlnaGxpZ2h0ZXJzID0gaGlnaGxpZ2h0ZXJzO1xuICAgICAgICB0aGlzLnNwYW4gPSBzcGFuO1xuICAgICAgICB0aGlzLmNsYXNzID0gXCJcIjtcbiAgICB9XG4gICAgc3RhcnRTcGFuKGF0LCBjbHMpIHtcbiAgICAgICAgaWYgKGNscyAhPSB0aGlzLmNsYXNzKSB7XG4gICAgICAgICAgICB0aGlzLmZsdXNoKGF0KTtcbiAgICAgICAgICAgIGlmIChhdCA+IHRoaXMuYXQpXG4gICAgICAgICAgICAgICAgdGhpcy5hdCA9IGF0O1xuICAgICAgICAgICAgdGhpcy5jbGFzcyA9IGNscztcbiAgICAgICAgfVxuICAgIH1cbiAgICBmbHVzaCh0bykge1xuICAgICAgICBpZiAodG8gPiB0aGlzLmF0ICYmIHRoaXMuY2xhc3MpXG4gICAgICAgICAgICB0aGlzLnNwYW4odGhpcy5hdCwgdG8sIHRoaXMuY2xhc3MpO1xuICAgIH1cbiAgICBoaWdobGlnaHRSYW5nZShjdXJzb3IsIGZyb20sIHRvLCBpbmhlcml0ZWRDbGFzcywgaGlnaGxpZ2h0ZXJzKSB7XG4gICAgICAgIGxldCB7IHR5cGUsIGZyb206IHN0YXJ0LCB0bzogZW5kIH0gPSBjdXJzb3I7XG4gICAgICAgIGlmIChzdGFydCA+PSB0byB8fCBlbmQgPD0gZnJvbSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHR5cGUuaXNUb3ApXG4gICAgICAgICAgICBoaWdobGlnaHRlcnMgPSB0aGlzLmhpZ2hsaWdodGVycy5maWx0ZXIoaCA9PiAhaC5zY29wZSB8fCBoLnNjb3BlKHR5cGUpKTtcbiAgICAgICAgbGV0IGNscyA9IGluaGVyaXRlZENsYXNzO1xuICAgICAgICBsZXQgcnVsZSA9IGdldFN0eWxlVGFncyhjdXJzb3IpIHx8IFJ1bGUuZW1wdHk7XG4gICAgICAgIGxldCB0YWdDbHMgPSBoaWdobGlnaHRUYWdzKGhpZ2hsaWdodGVycywgcnVsZS50YWdzKTtcbiAgICAgICAgaWYgKHRhZ0Nscykge1xuICAgICAgICAgICAgaWYgKGNscylcbiAgICAgICAgICAgICAgICBjbHMgKz0gXCIgXCI7XG4gICAgICAgICAgICBjbHMgKz0gdGFnQ2xzO1xuICAgICAgICAgICAgaWYgKHJ1bGUubW9kZSA9PSAxIC8qIE1vZGUuSW5oZXJpdCAqLylcbiAgICAgICAgICAgICAgICBpbmhlcml0ZWRDbGFzcyArPSAoaW5oZXJpdGVkQ2xhc3MgPyBcIiBcIiA6IFwiXCIpICsgdGFnQ2xzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhcnRTcGFuKE1hdGgubWF4KGZyb20sIHN0YXJ0KSwgY2xzKTtcbiAgICAgICAgaWYgKHJ1bGUub3BhcXVlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgbW91bnRlZCA9IGN1cnNvci50cmVlICYmIGN1cnNvci50cmVlLnByb3AoTm9kZVByb3AubW91bnRlZCk7XG4gICAgICAgIGlmIChtb3VudGVkICYmIG1vdW50ZWQub3ZlcmxheSkge1xuICAgICAgICAgICAgbGV0IGlubmVyID0gY3Vyc29yLm5vZGUuZW50ZXIobW91bnRlZC5vdmVybGF5WzBdLmZyb20gKyBzdGFydCwgMSk7XG4gICAgICAgICAgICBsZXQgaW5uZXJIaWdobGlnaHRlcnMgPSB0aGlzLmhpZ2hsaWdodGVycy5maWx0ZXIoaCA9PiAhaC5zY29wZSB8fCBoLnNjb3BlKG1vdW50ZWQudHJlZS50eXBlKSk7XG4gICAgICAgICAgICBsZXQgaGFzQ2hpbGQgPSBjdXJzb3IuZmlyc3RDaGlsZCgpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBvcyA9IHN0YXJ0OzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSBpIDwgbW91bnRlZC5vdmVybGF5Lmxlbmd0aCA/IG1vdW50ZWQub3ZlcmxheVtpXSA6IG51bGw7XG4gICAgICAgICAgICAgICAgbGV0IG5leHRQb3MgPSBuZXh0ID8gbmV4dC5mcm9tICsgc3RhcnQgOiBlbmQ7XG4gICAgICAgICAgICAgICAgbGV0IHJhbmdlRnJvbSA9IE1hdGgubWF4KGZyb20sIHBvcyksIHJhbmdlVG8gPSBNYXRoLm1pbih0bywgbmV4dFBvcyk7XG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlRnJvbSA8IHJhbmdlVG8gJiYgaGFzQ2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGN1cnNvci5mcm9tIDwgcmFuZ2VUbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRSYW5nZShjdXJzb3IsIHJhbmdlRnJvbSwgcmFuZ2VUbywgaW5oZXJpdGVkQ2xhc3MsIGhpZ2hsaWdodGVycyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0U3BhbihNYXRoLm1pbihyYW5nZVRvLCBjdXJzb3IudG8pLCBjbHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnNvci50byA+PSBuZXh0UG9zIHx8ICFjdXJzb3IubmV4dFNpYmxpbmcoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIW5leHQgfHwgbmV4dFBvcyA+IHRvKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBwb3MgPSBuZXh0LnRvICsgc3RhcnQ7XG4gICAgICAgICAgICAgICAgaWYgKHBvcyA+IGZyb20pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRSYW5nZShpbm5lci5jdXJzb3IoKSwgTWF0aC5tYXgoZnJvbSwgbmV4dC5mcm9tICsgc3RhcnQpLCBNYXRoLm1pbih0bywgcG9zKSwgXCJcIiwgaW5uZXJIaWdobGlnaHRlcnMpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0U3BhbihNYXRoLm1pbih0bywgcG9zKSwgY2xzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGFzQ2hpbGQpXG4gICAgICAgICAgICAgICAgY3Vyc29yLnBhcmVudCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGN1cnNvci5maXJzdENoaWxkKCkpIHtcbiAgICAgICAgICAgIGlmIChtb3VudGVkKVxuICAgICAgICAgICAgICAgIGluaGVyaXRlZENsYXNzID0gXCJcIjtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBpZiAoY3Vyc29yLnRvIDw9IGZyb20pXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGlmIChjdXJzb3IuZnJvbSA+PSB0bylcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRSYW5nZShjdXJzb3IsIGZyb20sIHRvLCBpbmhlcml0ZWRDbGFzcywgaGlnaGxpZ2h0ZXJzKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0U3BhbihNYXRoLm1pbih0bywgY3Vyc29yLnRvKSwgY2xzKTtcbiAgICAgICAgICAgIH0gd2hpbGUgKGN1cnNvci5uZXh0U2libGluZygpKTtcbiAgICAgICAgICAgIGN1cnNvci5wYXJlbnQoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuTWF0Y2ggYSBzeW50YXggbm9kZSdzIFtoaWdobGlnaHQgcnVsZXNdKCNoaWdobGlnaHQuc3R5bGVUYWdzKS4gSWZcbnRoZXJlJ3MgYSBtYXRjaCwgcmV0dXJuIGl0cyBzZXQgb2YgdGFncywgYW5kIHdoZXRoZXIgaXQgaXNcbm9wYXF1ZSAodXNlcyBhIGAhYCkgb3IgYXBwbGllcyB0byBhbGwgY2hpbGQgbm9kZXMgKGAvLi4uYCkuXG4qL1xuZnVuY3Rpb24gZ2V0U3R5bGVUYWdzKG5vZGUpIHtcbiAgICBsZXQgcnVsZSA9IG5vZGUudHlwZS5wcm9wKHJ1bGVOb2RlUHJvcCk7XG4gICAgd2hpbGUgKHJ1bGUgJiYgcnVsZS5jb250ZXh0ICYmICFub2RlLm1hdGNoQ29udGV4dChydWxlLmNvbnRleHQpKVxuICAgICAgICBydWxlID0gcnVsZS5uZXh0O1xuICAgIHJldHVybiBydWxlIHx8IG51bGw7XG59XG5jb25zdCB0ID0gVGFnLmRlZmluZTtcbmNvbnN0IGNvbW1lbnQgPSB0KCksIG5hbWUgPSB0KCksIHR5cGVOYW1lID0gdChuYW1lKSwgcHJvcGVydHlOYW1lID0gdChuYW1lKSwgbGl0ZXJhbCA9IHQoKSwgc3RyaW5nID0gdChsaXRlcmFsKSwgbnVtYmVyID0gdChsaXRlcmFsKSwgY29udGVudCA9IHQoKSwgaGVhZGluZyA9IHQoY29udGVudCksIGtleXdvcmQgPSB0KCksIG9wZXJhdG9yID0gdCgpLCBwdW5jdHVhdGlvbiA9IHQoKSwgYnJhY2tldCA9IHQocHVuY3R1YXRpb24pLCBtZXRhID0gdCgpO1xuLyoqXG5UaGUgZGVmYXVsdCBzZXQgb2YgaGlnaGxpZ2h0aW5nIFt0YWdzXSgjaGlnaGxpZ2h0LlRhZykuXG5cblRoaXMgY29sbGVjdGlvbiBpcyBoZWF2aWx5IGJpYXNlZCB0b3dhcmRzIHByb2dyYW1taW5nIGxhbmd1YWdlcyxcbmFuZCBuZWNlc3NhcmlseSBpbmNvbXBsZXRlLiBBIGZ1bGwgb250b2xvZ3kgb2Ygc3ludGFjdGljXG5jb25zdHJ1Y3RzIHdvdWxkIGZpbGwgYSBzdGFjayBvZiBib29rcywgYW5kIGJlIGltcHJhY3RpY2FsIHRvXG53cml0ZSB0aGVtZXMgZm9yLiBTbyB0cnkgdG8gbWFrZSBkbyB3aXRoIHRoaXMgc2V0LiBJZiBhbGwgZWxzZVxuZmFpbHMsIFtvcGVuIGFuXG5pc3N1ZV0oaHR0cHM6Ly9naXRodWIuY29tL2NvZGVtaXJyb3IvY29kZW1pcnJvci5uZXh0KSB0byBwcm9wb3NlIGFcbm5ldyB0YWcsIG9yIFtkZWZpbmVdKCNoaWdobGlnaHQuVGFnXmRlZmluZSkgYSBsb2NhbCBjdXN0b20gdGFnIGZvclxueW91ciB1c2UgY2FzZS5cblxuTm90ZSB0aGF0IGl0IGlzIG5vdCBvYmxpZ2F0b3J5IHRvIGFsd2F5cyBhdHRhY2ggdGhlIG1vc3Qgc3BlY2lmaWNcbnRhZyBwb3NzaWJsZSB0byBhbiBlbGVtZW504oCUaWYgeW91ciBncmFtbWFyIGNhbid0IGVhc2lseVxuZGlzdGluZ3Vpc2ggYSBjZXJ0YWluIHR5cGUgb2YgZWxlbWVudCAoc3VjaCBhcyBhIGxvY2FsIHZhcmlhYmxlKSxcbml0IGlzIG9rYXkgdG8gc3R5bGUgaXQgYXMgaXRzIG1vcmUgZ2VuZXJhbCB2YXJpYW50IChhIHZhcmlhYmxlKS5cblxuRm9yIHRhZ3MgdGhhdCBleHRlbmQgc29tZSBwYXJlbnQgdGFnLCB0aGUgZG9jdW1lbnRhdGlvbiBsaW5rcyB0b1xudGhlIHBhcmVudC5cbiovXG5jb25zdCB0YWdzID0ge1xuICAgIC8qKlxuICAgIEEgY29tbWVudC5cbiAgICAqL1xuICAgIGNvbW1lbnQsXG4gICAgLyoqXG4gICAgQSBsaW5lIFtjb21tZW50XSgjaGlnaGxpZ2h0LnRhZ3MuY29tbWVudCkuXG4gICAgKi9cbiAgICBsaW5lQ29tbWVudDogdChjb21tZW50KSxcbiAgICAvKipcbiAgICBBIGJsb2NrIFtjb21tZW50XSgjaGlnaGxpZ2h0LnRhZ3MuY29tbWVudCkuXG4gICAgKi9cbiAgICBibG9ja0NvbW1lbnQ6IHQoY29tbWVudCksXG4gICAgLyoqXG4gICAgQSBkb2N1bWVudGF0aW9uIFtjb21tZW50XSgjaGlnaGxpZ2h0LnRhZ3MuY29tbWVudCkuXG4gICAgKi9cbiAgICBkb2NDb21tZW50OiB0KGNvbW1lbnQpLFxuICAgIC8qKlxuICAgIEFueSBraW5kIG9mIGlkZW50aWZpZXIuXG4gICAgKi9cbiAgICBuYW1lLFxuICAgIC8qKlxuICAgIFRoZSBbbmFtZV0oI2hpZ2hsaWdodC50YWdzLm5hbWUpIG9mIGEgdmFyaWFibGUuXG4gICAgKi9cbiAgICB2YXJpYWJsZU5hbWU6IHQobmFtZSksXG4gICAgLyoqXG4gICAgQSB0eXBlIFtuYW1lXSgjaGlnaGxpZ2h0LnRhZ3MubmFtZSkuXG4gICAgKi9cbiAgICB0eXBlTmFtZTogdHlwZU5hbWUsXG4gICAgLyoqXG4gICAgQSB0YWcgbmFtZSAoc3VidGFnIG9mIFtgdHlwZU5hbWVgXSgjaGlnaGxpZ2h0LnRhZ3MudHlwZU5hbWUpKS5cbiAgICAqL1xuICAgIHRhZ05hbWU6IHQodHlwZU5hbWUpLFxuICAgIC8qKlxuICAgIEEgcHJvcGVydHkgb3IgZmllbGQgW25hbWVdKCNoaWdobGlnaHQudGFncy5uYW1lKS5cbiAgICAqL1xuICAgIHByb3BlcnR5TmFtZTogcHJvcGVydHlOYW1lLFxuICAgIC8qKlxuICAgIEFuIGF0dHJpYnV0ZSBuYW1lIChzdWJ0YWcgb2YgW2Bwcm9wZXJ0eU5hbWVgXSgjaGlnaGxpZ2h0LnRhZ3MucHJvcGVydHlOYW1lKSkuXG4gICAgKi9cbiAgICBhdHRyaWJ1dGVOYW1lOiB0KHByb3BlcnR5TmFtZSksXG4gICAgLyoqXG4gICAgVGhlIFtuYW1lXSgjaGlnaGxpZ2h0LnRhZ3MubmFtZSkgb2YgYSBjbGFzcy5cbiAgICAqL1xuICAgIGNsYXNzTmFtZTogdChuYW1lKSxcbiAgICAvKipcbiAgICBBIGxhYmVsIFtuYW1lXSgjaGlnaGxpZ2h0LnRhZ3MubmFtZSkuXG4gICAgKi9cbiAgICBsYWJlbE5hbWU6IHQobmFtZSksXG4gICAgLyoqXG4gICAgQSBuYW1lc3BhY2UgW25hbWVdKCNoaWdobGlnaHQudGFncy5uYW1lKS5cbiAgICAqL1xuICAgIG5hbWVzcGFjZTogdChuYW1lKSxcbiAgICAvKipcbiAgICBUaGUgW25hbWVdKCNoaWdobGlnaHQudGFncy5uYW1lKSBvZiBhIG1hY3JvLlxuICAgICovXG4gICAgbWFjcm9OYW1lOiB0KG5hbWUpLFxuICAgIC8qKlxuICAgIEEgbGl0ZXJhbCB2YWx1ZS5cbiAgICAqL1xuICAgIGxpdGVyYWwsXG4gICAgLyoqXG4gICAgQSBzdHJpbmcgW2xpdGVyYWxdKCNoaWdobGlnaHQudGFncy5saXRlcmFsKS5cbiAgICAqL1xuICAgIHN0cmluZyxcbiAgICAvKipcbiAgICBBIGRvY3VtZW50YXRpb24gW3N0cmluZ10oI2hpZ2hsaWdodC50YWdzLnN0cmluZykuXG4gICAgKi9cbiAgICBkb2NTdHJpbmc6IHQoc3RyaW5nKSxcbiAgICAvKipcbiAgICBBIGNoYXJhY3RlciBsaXRlcmFsIChzdWJ0YWcgb2YgW3N0cmluZ10oI2hpZ2hsaWdodC50YWdzLnN0cmluZykpLlxuICAgICovXG4gICAgY2hhcmFjdGVyOiB0KHN0cmluZyksXG4gICAgLyoqXG4gICAgQW4gYXR0cmlidXRlIHZhbHVlIChzdWJ0YWcgb2YgW3N0cmluZ10oI2hpZ2hsaWdodC50YWdzLnN0cmluZykpLlxuICAgICovXG4gICAgYXR0cmlidXRlVmFsdWU6IHQoc3RyaW5nKSxcbiAgICAvKipcbiAgICBBIG51bWJlciBbbGl0ZXJhbF0oI2hpZ2hsaWdodC50YWdzLmxpdGVyYWwpLlxuICAgICovXG4gICAgbnVtYmVyLFxuICAgIC8qKlxuICAgIEFuIGludGVnZXIgW251bWJlcl0oI2hpZ2hsaWdodC50YWdzLm51bWJlcikgbGl0ZXJhbC5cbiAgICAqL1xuICAgIGludGVnZXI6IHQobnVtYmVyKSxcbiAgICAvKipcbiAgICBBIGZsb2F0aW5nLXBvaW50IFtudW1iZXJdKCNoaWdobGlnaHQudGFncy5udW1iZXIpIGxpdGVyYWwuXG4gICAgKi9cbiAgICBmbG9hdDogdChudW1iZXIpLFxuICAgIC8qKlxuICAgIEEgYm9vbGVhbiBbbGl0ZXJhbF0oI2hpZ2hsaWdodC50YWdzLmxpdGVyYWwpLlxuICAgICovXG4gICAgYm9vbDogdChsaXRlcmFsKSxcbiAgICAvKipcbiAgICBSZWd1bGFyIGV4cHJlc3Npb24gW2xpdGVyYWxdKCNoaWdobGlnaHQudGFncy5saXRlcmFsKS5cbiAgICAqL1xuICAgIHJlZ2V4cDogdChsaXRlcmFsKSxcbiAgICAvKipcbiAgICBBbiBlc2NhcGUgW2xpdGVyYWxdKCNoaWdobGlnaHQudGFncy5saXRlcmFsKSwgZm9yIGV4YW1wbGUgYVxuICAgIGJhY2tzbGFzaCBlc2NhcGUgaW4gYSBzdHJpbmcuXG4gICAgKi9cbiAgICBlc2NhcGU6IHQobGl0ZXJhbCksXG4gICAgLyoqXG4gICAgQSBjb2xvciBbbGl0ZXJhbF0oI2hpZ2hsaWdodC50YWdzLmxpdGVyYWwpLlxuICAgICovXG4gICAgY29sb3I6IHQobGl0ZXJhbCksXG4gICAgLyoqXG4gICAgQSBVUkwgW2xpdGVyYWxdKCNoaWdobGlnaHQudGFncy5saXRlcmFsKS5cbiAgICAqL1xuICAgIHVybDogdChsaXRlcmFsKSxcbiAgICAvKipcbiAgICBBIGxhbmd1YWdlIGtleXdvcmQuXG4gICAgKi9cbiAgICBrZXl3b3JkLFxuICAgIC8qKlxuICAgIFRoZSBba2V5d29yZF0oI2hpZ2hsaWdodC50YWdzLmtleXdvcmQpIGZvciB0aGUgc2VsZiBvciB0aGlzXG4gICAgb2JqZWN0LlxuICAgICovXG4gICAgc2VsZjogdChrZXl3b3JkKSxcbiAgICAvKipcbiAgICBUaGUgW2tleXdvcmRdKCNoaWdobGlnaHQudGFncy5rZXl3b3JkKSBmb3IgbnVsbC5cbiAgICAqL1xuICAgIG51bGw6IHQoa2V5d29yZCksXG4gICAgLyoqXG4gICAgQSBba2V5d29yZF0oI2hpZ2hsaWdodC50YWdzLmtleXdvcmQpIGRlbm90aW5nIHNvbWUgYXRvbWljIHZhbHVlLlxuICAgICovXG4gICAgYXRvbTogdChrZXl3b3JkKSxcbiAgICAvKipcbiAgICBBIFtrZXl3b3JkXSgjaGlnaGxpZ2h0LnRhZ3Mua2V5d29yZCkgdGhhdCByZXByZXNlbnRzIGEgdW5pdC5cbiAgICAqL1xuICAgIHVuaXQ6IHQoa2V5d29yZCksXG4gICAgLyoqXG4gICAgQSBtb2RpZmllciBba2V5d29yZF0oI2hpZ2hsaWdodC50YWdzLmtleXdvcmQpLlxuICAgICovXG4gICAgbW9kaWZpZXI6IHQoa2V5d29yZCksXG4gICAgLyoqXG4gICAgQSBba2V5d29yZF0oI2hpZ2hsaWdodC50YWdzLmtleXdvcmQpIHRoYXQgYWN0cyBhcyBhbiBvcGVyYXRvci5cbiAgICAqL1xuICAgIG9wZXJhdG9yS2V5d29yZDogdChrZXl3b3JkKSxcbiAgICAvKipcbiAgICBBIGNvbnRyb2wtZmxvdyByZWxhdGVkIFtrZXl3b3JkXSgjaGlnaGxpZ2h0LnRhZ3Mua2V5d29yZCkuXG4gICAgKi9cbiAgICBjb250cm9sS2V5d29yZDogdChrZXl3b3JkKSxcbiAgICAvKipcbiAgICBBIFtrZXl3b3JkXSgjaGlnaGxpZ2h0LnRhZ3Mua2V5d29yZCkgdGhhdCBkZWZpbmVzIHNvbWV0aGluZy5cbiAgICAqL1xuICAgIGRlZmluaXRpb25LZXl3b3JkOiB0KGtleXdvcmQpLFxuICAgIC8qKlxuICAgIEEgW2tleXdvcmRdKCNoaWdobGlnaHQudGFncy5rZXl3b3JkKSByZWxhdGVkIHRvIGRlZmluaW5nIG9yXG4gICAgaW50ZXJmYWNpbmcgd2l0aCBtb2R1bGVzLlxuICAgICovXG4gICAgbW9kdWxlS2V5d29yZDogdChrZXl3b3JkKSxcbiAgICAvKipcbiAgICBBbiBvcGVyYXRvci5cbiAgICAqL1xuICAgIG9wZXJhdG9yLFxuICAgIC8qKlxuICAgIEFuIFtvcGVyYXRvcl0oI2hpZ2hsaWdodC50YWdzLm9wZXJhdG9yKSB0aGF0IGRlcmVmZXJlbmNlcyBzb21ldGhpbmcuXG4gICAgKi9cbiAgICBkZXJlZk9wZXJhdG9yOiB0KG9wZXJhdG9yKSxcbiAgICAvKipcbiAgICBBcml0aG1ldGljLXJlbGF0ZWQgW29wZXJhdG9yXSgjaGlnaGxpZ2h0LnRhZ3Mub3BlcmF0b3IpLlxuICAgICovXG4gICAgYXJpdGhtZXRpY09wZXJhdG9yOiB0KG9wZXJhdG9yKSxcbiAgICAvKipcbiAgICBMb2dpY2FsIFtvcGVyYXRvcl0oI2hpZ2hsaWdodC50YWdzLm9wZXJhdG9yKS5cbiAgICAqL1xuICAgIGxvZ2ljT3BlcmF0b3I6IHQob3BlcmF0b3IpLFxuICAgIC8qKlxuICAgIEJpdCBbb3BlcmF0b3JdKCNoaWdobGlnaHQudGFncy5vcGVyYXRvcikuXG4gICAgKi9cbiAgICBiaXR3aXNlT3BlcmF0b3I6IHQob3BlcmF0b3IpLFxuICAgIC8qKlxuICAgIENvbXBhcmlzb24gW29wZXJhdG9yXSgjaGlnaGxpZ2h0LnRhZ3Mub3BlcmF0b3IpLlxuICAgICovXG4gICAgY29tcGFyZU9wZXJhdG9yOiB0KG9wZXJhdG9yKSxcbiAgICAvKipcbiAgICBbT3BlcmF0b3JdKCNoaWdobGlnaHQudGFncy5vcGVyYXRvcikgdGhhdCB1cGRhdGVzIGl0cyBvcGVyYW5kLlxuICAgICovXG4gICAgdXBkYXRlT3BlcmF0b3I6IHQob3BlcmF0b3IpLFxuICAgIC8qKlxuICAgIFtPcGVyYXRvcl0oI2hpZ2hsaWdodC50YWdzLm9wZXJhdG9yKSB0aGF0IGRlZmluZXMgc29tZXRoaW5nLlxuICAgICovXG4gICAgZGVmaW5pdGlvbk9wZXJhdG9yOiB0KG9wZXJhdG9yKSxcbiAgICAvKipcbiAgICBUeXBlLXJlbGF0ZWQgW29wZXJhdG9yXSgjaGlnaGxpZ2h0LnRhZ3Mub3BlcmF0b3IpLlxuICAgICovXG4gICAgdHlwZU9wZXJhdG9yOiB0KG9wZXJhdG9yKSxcbiAgICAvKipcbiAgICBDb250cm9sLWZsb3cgW29wZXJhdG9yXSgjaGlnaGxpZ2h0LnRhZ3Mub3BlcmF0b3IpLlxuICAgICovXG4gICAgY29udHJvbE9wZXJhdG9yOiB0KG9wZXJhdG9yKSxcbiAgICAvKipcbiAgICBQcm9ncmFtIG9yIG1hcmt1cCBwdW5jdHVhdGlvbi5cbiAgICAqL1xuICAgIHB1bmN0dWF0aW9uLFxuICAgIC8qKlxuICAgIFtQdW5jdHVhdGlvbl0oI2hpZ2hsaWdodC50YWdzLnB1bmN0dWF0aW9uKSB0aGF0IHNlcGFyYXRlc1xuICAgIHRoaW5ncy5cbiAgICAqL1xuICAgIHNlcGFyYXRvcjogdChwdW5jdHVhdGlvbiksXG4gICAgLyoqXG4gICAgQnJhY2tldC1zdHlsZSBbcHVuY3R1YXRpb25dKCNoaWdobGlnaHQudGFncy5wdW5jdHVhdGlvbikuXG4gICAgKi9cbiAgICBicmFja2V0LFxuICAgIC8qKlxuICAgIEFuZ2xlIFticmFja2V0c10oI2hpZ2hsaWdodC50YWdzLmJyYWNrZXQpICh1c3VhbGx5IGA8YCBhbmQgYD5gXG4gICAgdG9rZW5zKS5cbiAgICAqL1xuICAgIGFuZ2xlQnJhY2tldDogdChicmFja2V0KSxcbiAgICAvKipcbiAgICBTcXVhcmUgW2JyYWNrZXRzXSgjaGlnaGxpZ2h0LnRhZ3MuYnJhY2tldCkgKHVzdWFsbHkgYFtgIGFuZCBgXWBcbiAgICB0b2tlbnMpLlxuICAgICovXG4gICAgc3F1YXJlQnJhY2tldDogdChicmFja2V0KSxcbiAgICAvKipcbiAgICBQYXJlbnRoZXNlcyAodXN1YWxseSBgKGAgYW5kIGApYCB0b2tlbnMpLiBTdWJ0YWcgb2ZcbiAgICBbYnJhY2tldF0oI2hpZ2hsaWdodC50YWdzLmJyYWNrZXQpLlxuICAgICovXG4gICAgcGFyZW46IHQoYnJhY2tldCksXG4gICAgLyoqXG4gICAgQnJhY2VzICh1c3VhbGx5IGB7YCBhbmQgYH1gIHRva2VucykuIFN1YnRhZyBvZlxuICAgIFticmFja2V0XSgjaGlnaGxpZ2h0LnRhZ3MuYnJhY2tldCkuXG4gICAgKi9cbiAgICBicmFjZTogdChicmFja2V0KSxcbiAgICAvKipcbiAgICBDb250ZW50LCBmb3IgZXhhbXBsZSBwbGFpbiB0ZXh0IGluIFhNTCBvciBtYXJrdXAgZG9jdW1lbnRzLlxuICAgICovXG4gICAgY29udGVudCxcbiAgICAvKipcbiAgICBbQ29udGVudF0oI2hpZ2hsaWdodC50YWdzLmNvbnRlbnQpIHRoYXQgcmVwcmVzZW50cyBhIGhlYWRpbmcuXG4gICAgKi9cbiAgICBoZWFkaW5nLFxuICAgIC8qKlxuICAgIEEgbGV2ZWwgMSBbaGVhZGluZ10oI2hpZ2hsaWdodC50YWdzLmhlYWRpbmcpLlxuICAgICovXG4gICAgaGVhZGluZzE6IHQoaGVhZGluZyksXG4gICAgLyoqXG4gICAgQSBsZXZlbCAyIFtoZWFkaW5nXSgjaGlnaGxpZ2h0LnRhZ3MuaGVhZGluZykuXG4gICAgKi9cbiAgICBoZWFkaW5nMjogdChoZWFkaW5nKSxcbiAgICAvKipcbiAgICBBIGxldmVsIDMgW2hlYWRpbmddKCNoaWdobGlnaHQudGFncy5oZWFkaW5nKS5cbiAgICAqL1xuICAgIGhlYWRpbmczOiB0KGhlYWRpbmcpLFxuICAgIC8qKlxuICAgIEEgbGV2ZWwgNCBbaGVhZGluZ10oI2hpZ2hsaWdodC50YWdzLmhlYWRpbmcpLlxuICAgICovXG4gICAgaGVhZGluZzQ6IHQoaGVhZGluZyksXG4gICAgLyoqXG4gICAgQSBsZXZlbCA1IFtoZWFkaW5nXSgjaGlnaGxpZ2h0LnRhZ3MuaGVhZGluZykuXG4gICAgKi9cbiAgICBoZWFkaW5nNTogdChoZWFkaW5nKSxcbiAgICAvKipcbiAgICBBIGxldmVsIDYgW2hlYWRpbmddKCNoaWdobGlnaHQudGFncy5oZWFkaW5nKS5cbiAgICAqL1xuICAgIGhlYWRpbmc2OiB0KGhlYWRpbmcpLFxuICAgIC8qKlxuICAgIEEgcHJvc2Ugc2VwYXJhdG9yIChzdWNoIGFzIGEgaG9yaXpvbnRhbCBydWxlKS5cbiAgICAqL1xuICAgIGNvbnRlbnRTZXBhcmF0b3I6IHQoY29udGVudCksXG4gICAgLyoqXG4gICAgW0NvbnRlbnRdKCNoaWdobGlnaHQudGFncy5jb250ZW50KSB0aGF0IHJlcHJlc2VudHMgYSBsaXN0LlxuICAgICovXG4gICAgbGlzdDogdChjb250ZW50KSxcbiAgICAvKipcbiAgICBbQ29udGVudF0oI2hpZ2hsaWdodC50YWdzLmNvbnRlbnQpIHRoYXQgcmVwcmVzZW50cyBhIHF1b3RlLlxuICAgICovXG4gICAgcXVvdGU6IHQoY29udGVudCksXG4gICAgLyoqXG4gICAgW0NvbnRlbnRdKCNoaWdobGlnaHQudGFncy5jb250ZW50KSB0aGF0IGlzIGVtcGhhc2l6ZWQuXG4gICAgKi9cbiAgICBlbXBoYXNpczogdChjb250ZW50KSxcbiAgICAvKipcbiAgICBbQ29udGVudF0oI2hpZ2hsaWdodC50YWdzLmNvbnRlbnQpIHRoYXQgaXMgc3R5bGVkIHN0cm9uZy5cbiAgICAqL1xuICAgIHN0cm9uZzogdChjb250ZW50KSxcbiAgICAvKipcbiAgICBbQ29udGVudF0oI2hpZ2hsaWdodC50YWdzLmNvbnRlbnQpIHRoYXQgaXMgcGFydCBvZiBhIGxpbmsuXG4gICAgKi9cbiAgICBsaW5rOiB0KGNvbnRlbnQpLFxuICAgIC8qKlxuICAgIFtDb250ZW50XSgjaGlnaGxpZ2h0LnRhZ3MuY29udGVudCkgdGhhdCBpcyBzdHlsZWQgYXMgY29kZSBvclxuICAgIG1vbm9zcGFjZS5cbiAgICAqL1xuICAgIG1vbm9zcGFjZTogdChjb250ZW50KSxcbiAgICAvKipcbiAgICBbQ29udGVudF0oI2hpZ2hsaWdodC50YWdzLmNvbnRlbnQpIHRoYXQgaGFzIGEgc3RyaWtlLXRocm91Z2hcbiAgICBzdHlsZS5cbiAgICAqL1xuICAgIHN0cmlrZXRocm91Z2g6IHQoY29udGVudCksXG4gICAgLyoqXG4gICAgSW5zZXJ0ZWQgdGV4dCBpbiBhIGNoYW5nZS10cmFja2luZyBmb3JtYXQuXG4gICAgKi9cbiAgICBpbnNlcnRlZDogdCgpLFxuICAgIC8qKlxuICAgIERlbGV0ZWQgdGV4dC5cbiAgICAqL1xuICAgIGRlbGV0ZWQ6IHQoKSxcbiAgICAvKipcbiAgICBDaGFuZ2VkIHRleHQuXG4gICAgKi9cbiAgICBjaGFuZ2VkOiB0KCksXG4gICAgLyoqXG4gICAgQW4gaW52YWxpZCBvciB1bnN5bnRhY3RpYyBlbGVtZW50LlxuICAgICovXG4gICAgaW52YWxpZDogdCgpLFxuICAgIC8qKlxuICAgIE1ldGFkYXRhIG9yIG1ldGEtaW5zdHJ1Y3Rpb24uXG4gICAgKi9cbiAgICBtZXRhLFxuICAgIC8qKlxuICAgIFtNZXRhZGF0YV0oI2hpZ2hsaWdodC50YWdzLm1ldGEpIHRoYXQgYXBwbGllcyB0byB0aGUgZW50aXJlXG4gICAgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBkb2N1bWVudE1ldGE6IHQobWV0YSksXG4gICAgLyoqXG4gICAgW01ldGFkYXRhXSgjaGlnaGxpZ2h0LnRhZ3MubWV0YSkgdGhhdCBhbm5vdGF0ZXMgb3IgYWRkc1xuICAgIGF0dHJpYnV0ZXMgdG8gYSBnaXZlbiBzeW50YWN0aWMgZWxlbWVudC5cbiAgICAqL1xuICAgIGFubm90YXRpb246IHQobWV0YSksXG4gICAgLyoqXG4gICAgUHJvY2Vzc2luZyBpbnN0cnVjdGlvbiBvciBwcmVwcm9jZXNzb3IgZGlyZWN0aXZlLiBTdWJ0YWcgb2ZcbiAgICBbbWV0YV0oI2hpZ2hsaWdodC50YWdzLm1ldGEpLlxuICAgICovXG4gICAgcHJvY2Vzc2luZ0luc3RydWN0aW9uOiB0KG1ldGEpLFxuICAgIC8qKlxuICAgIFtNb2RpZmllcl0oI2hpZ2hsaWdodC5UYWdeZGVmaW5lTW9kaWZpZXIpIHRoYXQgaW5kaWNhdGVzIHRoYXQgYVxuICAgIGdpdmVuIGVsZW1lbnQgaXMgYmVpbmcgZGVmaW5lZC4gRXhwZWN0ZWQgdG8gYmUgdXNlZCB3aXRoIHRoZVxuICAgIHZhcmlvdXMgW25hbWVdKCNoaWdobGlnaHQudGFncy5uYW1lKSB0YWdzLlxuICAgICovXG4gICAgZGVmaW5pdGlvbjogVGFnLmRlZmluZU1vZGlmaWVyKCksXG4gICAgLyoqXG4gICAgW01vZGlmaWVyXSgjaGlnaGxpZ2h0LlRhZ15kZWZpbmVNb2RpZmllcikgdGhhdCBpbmRpY2F0ZXMgdGhhdFxuICAgIHNvbWV0aGluZyBpcyBjb25zdGFudC4gTW9zdGx5IGV4cGVjdGVkIHRvIGJlIHVzZWQgd2l0aFxuICAgIFt2YXJpYWJsZSBuYW1lc10oI2hpZ2hsaWdodC50YWdzLnZhcmlhYmxlTmFtZSkuXG4gICAgKi9cbiAgICBjb25zdGFudDogVGFnLmRlZmluZU1vZGlmaWVyKCksXG4gICAgLyoqXG4gICAgW01vZGlmaWVyXSgjaGlnaGxpZ2h0LlRhZ15kZWZpbmVNb2RpZmllcikgdXNlZCB0byBpbmRpY2F0ZSB0aGF0XG4gICAgYSBbdmFyaWFibGVdKCNoaWdobGlnaHQudGFncy52YXJpYWJsZU5hbWUpIG9yIFtwcm9wZXJ0eVxuICAgIG5hbWVdKCNoaWdobGlnaHQudGFncy5wcm9wZXJ0eU5hbWUpIGlzIGJlaW5nIGNhbGxlZCBvciBkZWZpbmVkXG4gICAgYXMgYSBmdW5jdGlvbi5cbiAgICAqL1xuICAgIGZ1bmN0aW9uOiBUYWcuZGVmaW5lTW9kaWZpZXIoKSxcbiAgICAvKipcbiAgICBbTW9kaWZpZXJdKCNoaWdobGlnaHQuVGFnXmRlZmluZU1vZGlmaWVyKSB0aGF0IGNhbiBiZSBhcHBsaWVkIHRvXG4gICAgW25hbWVzXSgjaGlnaGxpZ2h0LnRhZ3MubmFtZSkgdG8gaW5kaWNhdGUgdGhhdCB0aGV5IGJlbG9uZyB0b1xuICAgIHRoZSBsYW5ndWFnZSdzIHN0YW5kYXJkIGVudmlyb25tZW50LlxuICAgICovXG4gICAgc3RhbmRhcmQ6IFRhZy5kZWZpbmVNb2RpZmllcigpLFxuICAgIC8qKlxuICAgIFtNb2RpZmllcl0oI2hpZ2hsaWdodC5UYWdeZGVmaW5lTW9kaWZpZXIpIHRoYXQgaW5kaWNhdGVzIGEgZ2l2ZW5cbiAgICBbbmFtZXNdKCNoaWdobGlnaHQudGFncy5uYW1lKSBpcyBsb2NhbCB0byBzb21lIHNjb3BlLlxuICAgICovXG4gICAgbG9jYWw6IFRhZy5kZWZpbmVNb2RpZmllcigpLFxuICAgIC8qKlxuICAgIEEgZ2VuZXJpYyB2YXJpYW50IFttb2RpZmllcl0oI2hpZ2hsaWdodC5UYWdeZGVmaW5lTW9kaWZpZXIpIHRoYXRcbiAgICBjYW4gYmUgdXNlZCB0byB0YWcgbGFuZ3VhZ2Utc3BlY2lmaWMgYWx0ZXJuYXRpdmUgdmFyaWFudHMgb2ZcbiAgICBzb21lIGNvbW1vbiB0YWcuIEl0IGlzIHJlY29tbWVuZGVkIGZvciB0aGVtZXMgdG8gZGVmaW5lIHNwZWNpYWxcbiAgICBmb3JtcyBvZiBhdCBsZWFzdCB0aGUgW3N0cmluZ10oI2hpZ2hsaWdodC50YWdzLnN0cmluZykgYW5kXG4gICAgW3ZhcmlhYmxlIG5hbWVdKCNoaWdobGlnaHQudGFncy52YXJpYWJsZU5hbWUpIHRhZ3MsIHNpbmNlIHRob3NlXG4gICAgY29tZSB1cCBhIGxvdC5cbiAgICAqL1xuICAgIHNwZWNpYWw6IFRhZy5kZWZpbmVNb2RpZmllcigpXG59O1xuLyoqXG5UaGlzIGlzIGEgaGlnaGxpZ2h0ZXIgdGhhdCBhZGRzIHN0YWJsZSwgcHJlZGljdGFibGUgY2xhc3NlcyB0b1xudG9rZW5zLCBmb3Igc3R5bGluZyB3aXRoIGV4dGVybmFsIENTUy5cblxuVGhlIGZvbGxvd2luZyB0YWdzIGFyZSBtYXBwZWQgdG8gdGhlaXIgbmFtZSBwcmVmaXhlZCB3aXRoIGBcInRvay1cImBcbihmb3IgZXhhbXBsZSBgXCJ0b2stY29tbWVudFwiYCk6XG5cbiogW2BsaW5rYF0oI2hpZ2hsaWdodC50YWdzLmxpbmspXG4qIFtgaGVhZGluZ2BdKCNoaWdobGlnaHQudGFncy5oZWFkaW5nKVxuKiBbYGVtcGhhc2lzYF0oI2hpZ2hsaWdodC50YWdzLmVtcGhhc2lzKVxuKiBbYHN0cm9uZ2BdKCNoaWdobGlnaHQudGFncy5zdHJvbmcpXG4qIFtga2V5d29yZGBdKCNoaWdobGlnaHQudGFncy5rZXl3b3JkKVxuKiBbYGF0b21gXSgjaGlnaGxpZ2h0LnRhZ3MuYXRvbSlcbiogW2Bib29sYF0oI2hpZ2hsaWdodC50YWdzLmJvb2wpXG4qIFtgdXJsYF0oI2hpZ2hsaWdodC50YWdzLnVybClcbiogW2BsYWJlbE5hbWVgXSgjaGlnaGxpZ2h0LnRhZ3MubGFiZWxOYW1lKVxuKiBbYGluc2VydGVkYF0oI2hpZ2hsaWdodC50YWdzLmluc2VydGVkKVxuKiBbYGRlbGV0ZWRgXSgjaGlnaGxpZ2h0LnRhZ3MuZGVsZXRlZClcbiogW2BsaXRlcmFsYF0oI2hpZ2hsaWdodC50YWdzLmxpdGVyYWwpXG4qIFtgc3RyaW5nYF0oI2hpZ2hsaWdodC50YWdzLnN0cmluZylcbiogW2BudW1iZXJgXSgjaGlnaGxpZ2h0LnRhZ3MubnVtYmVyKVxuKiBbYHZhcmlhYmxlTmFtZWBdKCNoaWdobGlnaHQudGFncy52YXJpYWJsZU5hbWUpXG4qIFtgdHlwZU5hbWVgXSgjaGlnaGxpZ2h0LnRhZ3MudHlwZU5hbWUpXG4qIFtgbmFtZXNwYWNlYF0oI2hpZ2hsaWdodC50YWdzLm5hbWVzcGFjZSlcbiogW2BjbGFzc05hbWVgXSgjaGlnaGxpZ2h0LnRhZ3MuY2xhc3NOYW1lKVxuKiBbYG1hY3JvTmFtZWBdKCNoaWdobGlnaHQudGFncy5tYWNyb05hbWUpXG4qIFtgcHJvcGVydHlOYW1lYF0oI2hpZ2hsaWdodC50YWdzLnByb3BlcnR5TmFtZSlcbiogW2BvcGVyYXRvcmBdKCNoaWdobGlnaHQudGFncy5vcGVyYXRvcilcbiogW2Bjb21tZW50YF0oI2hpZ2hsaWdodC50YWdzLmNvbW1lbnQpXG4qIFtgbWV0YWBdKCNoaWdobGlnaHQudGFncy5tZXRhKVxuKiBbYHB1bmN0dWF0aW9uYF0oI2hpZ2hsaWdodC50YWdzLnB1bmN0dWF0aW9uKVxuKiBbYGludmFsaWRgXSgjaGlnaGxpZ2h0LnRhZ3MuaW52YWxpZClcblxuSW4gYWRkaXRpb24sIHRoZXNlIG1hcHBpbmdzIGFyZSBwcm92aWRlZDpcblxuKiBbYHJlZ2V4cGBdKCNoaWdobGlnaHQudGFncy5yZWdleHApLFxuICBbYGVzY2FwZWBdKCNoaWdobGlnaHQudGFncy5lc2NhcGUpLCBhbmRcbiAgW2BzcGVjaWFsYF0oI2hpZ2hsaWdodC50YWdzLnNwZWNpYWwpW2Aoc3RyaW5nKWBdKCNoaWdobGlnaHQudGFncy5zdHJpbmcpXG4gIGFyZSBtYXBwZWQgdG8gYFwidG9rLXN0cmluZzJcImBcbiogW2BzcGVjaWFsYF0oI2hpZ2hsaWdodC50YWdzLnNwZWNpYWwpW2AodmFyaWFibGVOYW1lKWBdKCNoaWdobGlnaHQudGFncy52YXJpYWJsZU5hbWUpXG4gIHRvIGBcInRvay12YXJpYWJsZU5hbWUyXCJgXG4qIFtgbG9jYWxgXSgjaGlnaGxpZ2h0LnRhZ3MubG9jYWwpW2AodmFyaWFibGVOYW1lKWBdKCNoaWdobGlnaHQudGFncy52YXJpYWJsZU5hbWUpXG4gIHRvIGBcInRvay12YXJpYWJsZU5hbWUgdG9rLWxvY2FsXCJgXG4qIFtgZGVmaW5pdGlvbmBdKCNoaWdobGlnaHQudGFncy5kZWZpbml0aW9uKVtgKHZhcmlhYmxlTmFtZSlgXSgjaGlnaGxpZ2h0LnRhZ3MudmFyaWFibGVOYW1lKVxuICB0byBgXCJ0b2stdmFyaWFibGVOYW1lIHRvay1kZWZpbml0aW9uXCJgXG4qIFtgZGVmaW5pdGlvbmBdKCNoaWdobGlnaHQudGFncy5kZWZpbml0aW9uKVtgKHByb3BlcnR5TmFtZSlgXSgjaGlnaGxpZ2h0LnRhZ3MucHJvcGVydHlOYW1lKVxuICB0byBgXCJ0b2stcHJvcGVydHlOYW1lIHRvay1kZWZpbml0aW9uXCJgXG4qL1xuY29uc3QgY2xhc3NIaWdobGlnaHRlciA9IHRhZ0hpZ2hsaWdodGVyKFtcbiAgICB7IHRhZzogdGFncy5saW5rLCBjbGFzczogXCJ0b2stbGlua1wiIH0sXG4gICAgeyB0YWc6IHRhZ3MuaGVhZGluZywgY2xhc3M6IFwidG9rLWhlYWRpbmdcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmVtcGhhc2lzLCBjbGFzczogXCJ0b2stZW1waGFzaXNcIiB9LFxuICAgIHsgdGFnOiB0YWdzLnN0cm9uZywgY2xhc3M6IFwidG9rLXN0cm9uZ1wiIH0sXG4gICAgeyB0YWc6IHRhZ3Mua2V5d29yZCwgY2xhc3M6IFwidG9rLWtleXdvcmRcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmF0b20sIGNsYXNzOiBcInRvay1hdG9tXCIgfSxcbiAgICB7IHRhZzogdGFncy5ib29sLCBjbGFzczogXCJ0b2stYm9vbFwiIH0sXG4gICAgeyB0YWc6IHRhZ3MudXJsLCBjbGFzczogXCJ0b2stdXJsXCIgfSxcbiAgICB7IHRhZzogdGFncy5sYWJlbE5hbWUsIGNsYXNzOiBcInRvay1sYWJlbE5hbWVcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmluc2VydGVkLCBjbGFzczogXCJ0b2staW5zZXJ0ZWRcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmRlbGV0ZWQsIGNsYXNzOiBcInRvay1kZWxldGVkXCIgfSxcbiAgICB7IHRhZzogdGFncy5saXRlcmFsLCBjbGFzczogXCJ0b2stbGl0ZXJhbFwiIH0sXG4gICAgeyB0YWc6IHRhZ3Muc3RyaW5nLCBjbGFzczogXCJ0b2stc3RyaW5nXCIgfSxcbiAgICB7IHRhZzogdGFncy5udW1iZXIsIGNsYXNzOiBcInRvay1udW1iZXJcIiB9LFxuICAgIHsgdGFnOiBbdGFncy5yZWdleHAsIHRhZ3MuZXNjYXBlLCB0YWdzLnNwZWNpYWwodGFncy5zdHJpbmcpXSwgY2xhc3M6IFwidG9rLXN0cmluZzJcIiB9LFxuICAgIHsgdGFnOiB0YWdzLnZhcmlhYmxlTmFtZSwgY2xhc3M6IFwidG9rLXZhcmlhYmxlTmFtZVwiIH0sXG4gICAgeyB0YWc6IHRhZ3MubG9jYWwodGFncy52YXJpYWJsZU5hbWUpLCBjbGFzczogXCJ0b2stdmFyaWFibGVOYW1lIHRvay1sb2NhbFwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuZGVmaW5pdGlvbih0YWdzLnZhcmlhYmxlTmFtZSksIGNsYXNzOiBcInRvay12YXJpYWJsZU5hbWUgdG9rLWRlZmluaXRpb25cIiB9LFxuICAgIHsgdGFnOiB0YWdzLnNwZWNpYWwodGFncy52YXJpYWJsZU5hbWUpLCBjbGFzczogXCJ0b2stdmFyaWFibGVOYW1lMlwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuZGVmaW5pdGlvbih0YWdzLnByb3BlcnR5TmFtZSksIGNsYXNzOiBcInRvay1wcm9wZXJ0eU5hbWUgdG9rLWRlZmluaXRpb25cIiB9LFxuICAgIHsgdGFnOiB0YWdzLnR5cGVOYW1lLCBjbGFzczogXCJ0b2stdHlwZU5hbWVcIiB9LFxuICAgIHsgdGFnOiB0YWdzLm5hbWVzcGFjZSwgY2xhc3M6IFwidG9rLW5hbWVzcGFjZVwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuY2xhc3NOYW1lLCBjbGFzczogXCJ0b2stY2xhc3NOYW1lXCIgfSxcbiAgICB7IHRhZzogdGFncy5tYWNyb05hbWUsIGNsYXNzOiBcInRvay1tYWNyb05hbWVcIiB9LFxuICAgIHsgdGFnOiB0YWdzLnByb3BlcnR5TmFtZSwgY2xhc3M6IFwidG9rLXByb3BlcnR5TmFtZVwiIH0sXG4gICAgeyB0YWc6IHRhZ3Mub3BlcmF0b3IsIGNsYXNzOiBcInRvay1vcGVyYXRvclwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuY29tbWVudCwgY2xhc3M6IFwidG9rLWNvbW1lbnRcIiB9LFxuICAgIHsgdGFnOiB0YWdzLm1ldGEsIGNsYXNzOiBcInRvay1tZXRhXCIgfSxcbiAgICB7IHRhZzogdGFncy5pbnZhbGlkLCBjbGFzczogXCJ0b2staW52YWxpZFwiIH0sXG4gICAgeyB0YWc6IHRhZ3MucHVuY3R1YXRpb24sIGNsYXNzOiBcInRvay1wdW5jdHVhdGlvblwiIH1cbl0pO1xuXG5leHBvcnQgeyBUYWcsIGNsYXNzSGlnaGxpZ2h0ZXIsIGdldFN0eWxlVGFncywgaGlnaGxpZ2h0Q29kZSwgaGlnaGxpZ2h0VHJlZSwgc3R5bGVUYWdzLCB0YWdIaWdobGlnaHRlciwgdGFncyB9O1xuIl0sIm5hbWVzIjpbIk5vZGVQcm9wIiwibmV4dFRhZ0lEIiwiVGFnIiwiY29uc3RydWN0b3IiLCJzZXQiLCJiYXNlIiwibW9kaWZpZWQiLCJpZCIsImRlZmluZSIsInBhcmVudCIsIkVycm9yIiwidGFnIiwicHVzaCIsInQiLCJkZWZpbmVNb2RpZmllciIsIm1vZCIsIk1vZGlmaWVyIiwiaW5kZXhPZiIsImdldCIsImNvbmNhdCIsInNvcnQiLCJhIiwiYiIsIm5leHRNb2RpZmllcklEIiwiaW5zdGFuY2VzIiwibW9kcyIsImxlbmd0aCIsImV4aXN0cyIsImZpbmQiLCJzYW1lQXJyYXkiLCJtIiwiY29uZmlncyIsInBvd2VyU2V0IiwiY29uZmlnIiwiZXZlcnkiLCJ4IiwiaSIsImFycmF5Iiwic2V0cyIsImoiLCJlIiwic3R5bGVUYWdzIiwic3BlYyIsImJ5TmFtZSIsIk9iamVjdCIsImNyZWF0ZSIsInByb3AiLCJ0YWdzIiwiQXJyYXkiLCJpc0FycmF5IiwicGFydCIsInNwbGl0IiwicGllY2VzIiwibW9kZSIsInJlc3QiLCJwb3MiLCJleGVjIiwiUmFuZ2VFcnJvciIsIkpTT04iLCJwYXJzZSIsIm5leHQiLCJzbGljZSIsImxhc3QiLCJpbm5lciIsInJ1bGUiLCJSdWxlIiwicnVsZU5vZGVQcm9wIiwiYWRkIiwiY29udGV4dCIsIm9wYXF1ZSIsImluaGVyaXQiLCJvdGhlciIsImRlcHRoIiwiZW1wdHkiLCJ0YWdIaWdobGlnaHRlciIsIm9wdGlvbnMiLCJtYXAiLCJzdHlsZSIsImNsYXNzIiwic2NvcGUiLCJhbGwiLCJjbHMiLCJzdWIiLCJ0YWdDbGFzcyIsImhpZ2hsaWdodFRhZ3MiLCJoaWdobGlnaHRlcnMiLCJyZXN1bHQiLCJoaWdobGlnaHRlciIsInZhbHVlIiwiaGlnaGxpZ2h0VHJlZSIsInRyZWUiLCJwdXRTdHlsZSIsImZyb20iLCJ0byIsImJ1aWxkZXIiLCJIaWdobGlnaHRCdWlsZGVyIiwiaGlnaGxpZ2h0UmFuZ2UiLCJjdXJzb3IiLCJmbHVzaCIsImhpZ2hsaWdodENvZGUiLCJjb2RlIiwicHV0VGV4dCIsInB1dEJyZWFrIiwid3JpdGVUbyIsInAiLCJjbGFzc2VzIiwidGV4dCIsIm5leHRCcmVhayIsInVwdG8iLCJhdCIsInNwYW4iLCJzdGFydFNwYW4iLCJpbmhlcml0ZWRDbGFzcyIsInR5cGUiLCJzdGFydCIsImVuZCIsImlzVG9wIiwiZmlsdGVyIiwiaCIsImdldFN0eWxlVGFncyIsInRhZ0NscyIsIk1hdGgiLCJtYXgiLCJtb3VudGVkIiwib3ZlcmxheSIsIm5vZGUiLCJlbnRlciIsImlubmVySGlnaGxpZ2h0ZXJzIiwiaGFzQ2hpbGQiLCJmaXJzdENoaWxkIiwibmV4dFBvcyIsInJhbmdlRnJvbSIsInJhbmdlVG8iLCJtaW4iLCJuZXh0U2libGluZyIsIm1hdGNoQ29udGV4dCIsImNvbW1lbnQiLCJuYW1lIiwidHlwZU5hbWUiLCJwcm9wZXJ0eU5hbWUiLCJsaXRlcmFsIiwic3RyaW5nIiwibnVtYmVyIiwiY29udGVudCIsImhlYWRpbmciLCJrZXl3b3JkIiwib3BlcmF0b3IiLCJwdW5jdHVhdGlvbiIsImJyYWNrZXQiLCJtZXRhIiwibGluZUNvbW1lbnQiLCJibG9ja0NvbW1lbnQiLCJkb2NDb21tZW50IiwidmFyaWFibGVOYW1lIiwidGFnTmFtZSIsImF0dHJpYnV0ZU5hbWUiLCJjbGFzc05hbWUiLCJsYWJlbE5hbWUiLCJuYW1lc3BhY2UiLCJtYWNyb05hbWUiLCJkb2NTdHJpbmciLCJjaGFyYWN0ZXIiLCJhdHRyaWJ1dGVWYWx1ZSIsImludGVnZXIiLCJmbG9hdCIsImJvb2wiLCJyZWdleHAiLCJlc2NhcGUiLCJjb2xvciIsInVybCIsInNlbGYiLCJudWxsIiwiYXRvbSIsInVuaXQiLCJtb2RpZmllciIsIm9wZXJhdG9yS2V5d29yZCIsImNvbnRyb2xLZXl3b3JkIiwiZGVmaW5pdGlvbktleXdvcmQiLCJtb2R1bGVLZXl3b3JkIiwiZGVyZWZPcGVyYXRvciIsImFyaXRobWV0aWNPcGVyYXRvciIsImxvZ2ljT3BlcmF0b3IiLCJiaXR3aXNlT3BlcmF0b3IiLCJjb21wYXJlT3BlcmF0b3IiLCJ1cGRhdGVPcGVyYXRvciIsImRlZmluaXRpb25PcGVyYXRvciIsInR5cGVPcGVyYXRvciIsImNvbnRyb2xPcGVyYXRvciIsInNlcGFyYXRvciIsImFuZ2xlQnJhY2tldCIsInNxdWFyZUJyYWNrZXQiLCJwYXJlbiIsImJyYWNlIiwiaGVhZGluZzEiLCJoZWFkaW5nMiIsImhlYWRpbmczIiwiaGVhZGluZzQiLCJoZWFkaW5nNSIsImhlYWRpbmc2IiwiY29udGVudFNlcGFyYXRvciIsImxpc3QiLCJxdW90ZSIsImVtcGhhc2lzIiwic3Ryb25nIiwibGluayIsIm1vbm9zcGFjZSIsInN0cmlrZXRocm91Z2giLCJpbnNlcnRlZCIsImRlbGV0ZWQiLCJjaGFuZ2VkIiwiaW52YWxpZCIsImRvY3VtZW50TWV0YSIsImFubm90YXRpb24iLCJwcm9jZXNzaW5nSW5zdHJ1Y3Rpb24iLCJkZWZpbml0aW9uIiwiY29uc3RhbnQiLCJmdW5jdGlvbiIsInN0YW5kYXJkIiwibG9jYWwiLCJzcGVjaWFsIiwiY2xhc3NIaWdobGlnaHRlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lezer/highlight/dist/index.js\n");

/***/ })

};
;