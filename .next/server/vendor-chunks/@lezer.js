"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@lezer";
exports.ids = ["vendor-chunks/@lezer"];
exports.modules = {

/***/ "(ssr)/./node_modules/@lezer/common/dist/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@lezer/common/dist/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DefaultBufferLength: () => (/* binding */ DefaultBufferLength),\n/* harmony export */   IterMode: () => (/* binding */ IterMode),\n/* harmony export */   MountedTree: () => (/* binding */ MountedTree),\n/* harmony export */   NodeProp: () => (/* binding */ NodeProp),\n/* harmony export */   NodeSet: () => (/* binding */ NodeSet),\n/* harmony export */   NodeType: () => (/* binding */ NodeType),\n/* harmony export */   NodeWeakMap: () => (/* binding */ NodeWeakMap),\n/* harmony export */   Parser: () => (/* binding */ Parser),\n/* harmony export */   Tree: () => (/* binding */ Tree),\n/* harmony export */   TreeBuffer: () => (/* binding */ TreeBuffer),\n/* harmony export */   TreeCursor: () => (/* binding */ TreeCursor),\n/* harmony export */   TreeFragment: () => (/* binding */ TreeFragment),\n/* harmony export */   parseMixed: () => (/* binding */ parseMixed)\n/* harmony export */ });\n/**\nThe default maximum length of a `TreeBuffer` node.\n*/ const DefaultBufferLength = 1024;\nlet nextPropID = 0;\nclass Range {\n    constructor(from, to){\n        this.from = from;\n        this.to = to;\n    }\n}\n/**\nEach [node type](#common.NodeType) or [individual tree](#common.Tree)\ncan have metadata associated with it in props. Instances of this\nclass represent prop names.\n*/ class NodeProp {\n    /**\n    Create a new node prop type.\n    */ constructor(config = {}){\n        this.id = nextPropID++;\n        this.perNode = !!config.perNode;\n        this.deserialize = config.deserialize || (()=>{\n            throw new Error(\"This node type doesn't define a deserialize function\");\n        });\n    }\n    /**\n    This is meant to be used with\n    [`NodeSet.extend`](#common.NodeSet.extend) or\n    [`LRParser.configure`](#lr.ParserConfig.props) to compute\n    prop values for each node type in the set. Takes a [match\n    object](#common.NodeType^match) or function that returns undefined\n    if the node type doesn't get this prop, and the prop's value if\n    it does.\n    */ add(match) {\n        if (this.perNode) throw new RangeError(\"Can't add per-node props to node types\");\n        if (typeof match != \"function\") match = NodeType.match(match);\n        return (type)=>{\n            let result = match(type);\n            return result === undefined ? null : [\n                this,\n                result\n            ];\n        };\n    }\n}\n/**\nProp that is used to describe matching delimiters. For opening\ndelimiters, this holds an array of node names (written as a\nspace-separated string when declaring this prop in a grammar)\nfor the node types of closing delimiters that match it.\n*/ NodeProp.closedBy = new NodeProp({\n    deserialize: (str)=>str.split(\" \")\n});\n/**\nThe inverse of [`closedBy`](#common.NodeProp^closedBy). This is\nattached to closing delimiters, holding an array of node names\nof types of matching opening delimiters.\n*/ NodeProp.openedBy = new NodeProp({\n    deserialize: (str)=>str.split(\" \")\n});\n/**\nUsed to assign node types to groups (for example, all node\ntypes that represent an expression could be tagged with an\n`\"Expression\"` group).\n*/ NodeProp.group = new NodeProp({\n    deserialize: (str)=>str.split(\" \")\n});\n/**\nThe hash of the [context](#lr.ContextTracker.constructor)\nthat the node was parsed in, if any. Used to limit reuse of\ncontextual nodes.\n*/ NodeProp.contextHash = new NodeProp({\n    perNode: true\n});\n/**\nThe distance beyond the end of the node that the tokenizer\nlooked ahead for any of the tokens inside the node. (The LR\nparser only stores this when it is larger than 25, for\nefficiency reasons.)\n*/ NodeProp.lookAhead = new NodeProp({\n    perNode: true\n});\n/**\nThis per-node prop is used to replace a given node, or part of a\nnode, with another tree. This is useful to include trees from\ndifferent languages in mixed-language parsers.\n*/ NodeProp.mounted = new NodeProp({\n    perNode: true\n});\n/**\nA mounted tree, which can be [stored](#common.NodeProp^mounted) on\na tree node to indicate that parts of its content are\nrepresented by another tree.\n*/ class MountedTree {\n    constructor(/**\n    The inner tree.\n    */ tree, /**\n    If this is null, this tree replaces the entire node (it will\n    be included in the regular iteration instead of its host\n    node). If not, only the given ranges are considered to be\n    covered by this tree. This is used for trees that are mixed in\n    a way that isn't strictly hierarchical. Such mounted trees are\n    only entered by [`resolveInner`](#common.Tree.resolveInner)\n    and [`enter`](#common.SyntaxNode.enter).\n    */ overlay, /**\n    The parser used to create this subtree.\n    */ parser){\n        this.tree = tree;\n        this.overlay = overlay;\n        this.parser = parser;\n    }\n    /**\n    @internal\n    */ static get(tree) {\n        return tree && tree.props && tree.props[NodeProp.mounted.id];\n    }\n}\nconst noProps = Object.create(null);\n/**\nEach node in a syntax tree has a node type associated with it.\n*/ class NodeType {\n    /**\n    @internal\n    */ constructor(/**\n    The name of the node type. Not necessarily unique, but if the\n    grammar was written properly, different node types with the\n    same name within a node set should play the same semantic\n    role.\n    */ name, /**\n    @internal\n    */ props, /**\n    The id of this node in its set. Corresponds to the term ids\n    used in the parser.\n    */ id, /**\n    @internal\n    */ flags = 0){\n        this.name = name;\n        this.props = props;\n        this.id = id;\n        this.flags = flags;\n    }\n    /**\n    Define a node type.\n    */ static define(spec) {\n        let props = spec.props && spec.props.length ? Object.create(null) : noProps;\n        let flags = (spec.top ? 1 /* NodeFlag.Top */  : 0) | (spec.skipped ? 2 /* NodeFlag.Skipped */  : 0) | (spec.error ? 4 /* NodeFlag.Error */  : 0) | (spec.name == null ? 8 /* NodeFlag.Anonymous */  : 0);\n        let type = new NodeType(spec.name || \"\", props, spec.id, flags);\n        if (spec.props) for (let src of spec.props){\n            if (!Array.isArray(src)) src = src(type);\n            if (src) {\n                if (src[0].perNode) throw new RangeError(\"Can't store a per-node prop on a node type\");\n                props[src[0].id] = src[1];\n            }\n        }\n        return type;\n    }\n    /**\n    Retrieves a node prop for this type. Will return `undefined` if\n    the prop isn't present on this node.\n    */ prop(prop) {\n        return this.props[prop.id];\n    }\n    /**\n    True when this is the top node of a grammar.\n    */ get isTop() {\n        return (this.flags & 1 /* NodeFlag.Top */ ) > 0;\n    }\n    /**\n    True when this node is produced by a skip rule.\n    */ get isSkipped() {\n        return (this.flags & 2 /* NodeFlag.Skipped */ ) > 0;\n    }\n    /**\n    Indicates whether this is an error node.\n    */ get isError() {\n        return (this.flags & 4 /* NodeFlag.Error */ ) > 0;\n    }\n    /**\n    When true, this node type doesn't correspond to a user-declared\n    named node, for example because it is used to cache repetition.\n    */ get isAnonymous() {\n        return (this.flags & 8 /* NodeFlag.Anonymous */ ) > 0;\n    }\n    /**\n    Returns true when this node's name or one of its\n    [groups](#common.NodeProp^group) matches the given string.\n    */ is(name) {\n        if (typeof name == \"string\") {\n            if (this.name == name) return true;\n            let group = this.prop(NodeProp.group);\n            return group ? group.indexOf(name) > -1 : false;\n        }\n        return this.id == name;\n    }\n    /**\n    Create a function from node types to arbitrary values by\n    specifying an object whose property names are node or\n    [group](#common.NodeProp^group) names. Often useful with\n    [`NodeProp.add`](#common.NodeProp.add). You can put multiple\n    names, separated by spaces, in a single property name to map\n    multiple node names to a single value.\n    */ static match(map) {\n        let direct = Object.create(null);\n        for(let prop in map)for (let name of prop.split(\" \"))direct[name] = map[prop];\n        return (node)=>{\n            for(let groups = node.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++){\n                let found = direct[i < 0 ? node.name : groups[i]];\n                if (found) return found;\n            }\n        };\n    }\n}\n/**\nAn empty dummy node type to use when no actual type is available.\n*/ NodeType.none = new NodeType(\"\", Object.create(null), 0, 8 /* NodeFlag.Anonymous */ );\n/**\nA node set holds a collection of node types. It is used to\ncompactly represent trees by storing their type ids, rather than a\nfull pointer to the type object, in a numeric array. Each parser\n[has](#lr.LRParser.nodeSet) a node set, and [tree\nbuffers](#common.TreeBuffer) can only store collections of nodes\nfrom the same set. A set can have a maximum of 2**16 (65536) node\ntypes in it, so that the ids fit into 16-bit typed array slots.\n*/ class NodeSet {\n    /**\n    Create a set with the given types. The `id` property of each\n    type should correspond to its position within the array.\n    */ constructor(/**\n    The node types in this set, by id.\n    */ types){\n        this.types = types;\n        for(let i = 0; i < types.length; i++)if (types[i].id != i) throw new RangeError(\"Node type ids should correspond to array positions when creating a node set\");\n    }\n    /**\n    Create a copy of this set with some node properties added. The\n    arguments to this method can be created with\n    [`NodeProp.add`](#common.NodeProp.add).\n    */ extend(...props) {\n        let newTypes = [];\n        for (let type of this.types){\n            let newProps = null;\n            for (let source of props){\n                let add = source(type);\n                if (add) {\n                    if (!newProps) newProps = Object.assign({}, type.props);\n                    newProps[add[0].id] = add[1];\n                }\n            }\n            newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type);\n        }\n        return new NodeSet(newTypes);\n    }\n}\nconst CachedNode = new WeakMap(), CachedInnerNode = new WeakMap();\n/**\nOptions that control iteration. Can be combined with the `|`\noperator to enable multiple ones.\n*/ var IterMode;\n(function(IterMode) {\n    /**\n    When enabled, iteration will only visit [`Tree`](#common.Tree)\n    objects, not nodes packed into\n    [`TreeBuffer`](#common.TreeBuffer)s.\n    */ IterMode[IterMode[\"ExcludeBuffers\"] = 1] = \"ExcludeBuffers\";\n    /**\n    Enable this to make iteration include anonymous nodes (such as\n    the nodes that wrap repeated grammar constructs into a balanced\n    tree).\n    */ IterMode[IterMode[\"IncludeAnonymous\"] = 2] = \"IncludeAnonymous\";\n    /**\n    By default, regular [mounted](#common.NodeProp^mounted) nodes\n    replace their base node in iteration. Enable this to ignore them\n    instead.\n    */ IterMode[IterMode[\"IgnoreMounts\"] = 4] = \"IgnoreMounts\";\n    /**\n    This option only applies in\n    [`enter`](#common.SyntaxNode.enter)-style methods. It tells the\n    library to not enter mounted overlays if one covers the given\n    position.\n    */ IterMode[IterMode[\"IgnoreOverlays\"] = 8] = \"IgnoreOverlays\";\n})(IterMode || (IterMode = {}));\n/**\nA piece of syntax tree. There are two ways to approach these\ntrees: the way they are actually stored in memory, and the\nconvenient way.\n\nSyntax trees are stored as a tree of `Tree` and `TreeBuffer`\nobjects. By packing detail information into `TreeBuffer` leaf\nnodes, the representation is made a lot more memory-efficient.\n\nHowever, when you want to actually work with tree nodes, this\nrepresentation is very awkward, so most client code will want to\nuse the [`TreeCursor`](#common.TreeCursor) or\n[`SyntaxNode`](#common.SyntaxNode) interface instead, which provides\na view on some part of this data structure, and can be used to\nmove around to adjacent nodes.\n*/ class Tree {\n    /**\n    Construct a new tree. See also [`Tree.build`](#common.Tree^build).\n    */ constructor(/**\n    The type of the top node.\n    */ type, /**\n    This node's child nodes.\n    */ children, /**\n    The positions (offsets relative to the start of this tree) of\n    the children.\n    */ positions, /**\n    The total length of this tree\n    */ length, /**\n    Per-node [node props](#common.NodeProp) to associate with this node.\n    */ props){\n        this.type = type;\n        this.children = children;\n        this.positions = positions;\n        this.length = length;\n        /**\n        @internal\n        */ this.props = null;\n        if (props && props.length) {\n            this.props = Object.create(null);\n            for (let [prop, value] of props)this.props[typeof prop == \"number\" ? prop : prop.id] = value;\n        }\n    }\n    /**\n    @internal\n    */ toString() {\n        let mounted = MountedTree.get(this);\n        if (mounted && !mounted.overlay) return mounted.tree.toString();\n        let children = \"\";\n        for (let ch of this.children){\n            let str = ch.toString();\n            if (str) {\n                if (children) children += \",\";\n                children += str;\n            }\n        }\n        return !this.type.name ? children : (/\\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (children.length ? \"(\" + children + \")\" : \"\");\n    }\n    /**\n    Get a [tree cursor](#common.TreeCursor) positioned at the top of\n    the tree. Mode can be used to [control](#common.IterMode) which\n    nodes the cursor visits.\n    */ cursor(mode = 0) {\n        return new TreeCursor(this.topNode, mode);\n    }\n    /**\n    Get a [tree cursor](#common.TreeCursor) pointing into this tree\n    at the given position and side (see\n    [`moveTo`](#common.TreeCursor.moveTo).\n    */ cursorAt(pos, side = 0, mode = 0) {\n        let scope = CachedNode.get(this) || this.topNode;\n        let cursor = new TreeCursor(scope);\n        cursor.moveTo(pos, side);\n        CachedNode.set(this, cursor._tree);\n        return cursor;\n    }\n    /**\n    Get a [syntax node](#common.SyntaxNode) object for the top of the\n    tree.\n    */ get topNode() {\n        return new TreeNode(this, 0, 0, null);\n    }\n    /**\n    Get the [syntax node](#common.SyntaxNode) at the given position.\n    If `side` is -1, this will move into nodes that end at the\n    position. If 1, it'll move into nodes that start at the\n    position. With 0, it'll only enter nodes that cover the position\n    from both sides.\n    \n    Note that this will not enter\n    [overlays](#common.MountedTree.overlay), and you often want\n    [`resolveInner`](#common.Tree.resolveInner) instead.\n    */ resolve(pos, side = 0) {\n        let node = resolveNode(CachedNode.get(this) || this.topNode, pos, side, false);\n        CachedNode.set(this, node);\n        return node;\n    }\n    /**\n    Like [`resolve`](#common.Tree.resolve), but will enter\n    [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node\n    pointing into the innermost overlaid tree at the given position\n    (with parent links going through all parent structure, including\n    the host trees).\n    */ resolveInner(pos, side = 0) {\n        let node = resolveNode(CachedInnerNode.get(this) || this.topNode, pos, side, true);\n        CachedInnerNode.set(this, node);\n        return node;\n    }\n    /**\n    In some situations, it can be useful to iterate through all\n    nodes around a position, including those in overlays that don't\n    directly cover the position. This method gives you an iterator\n    that will produce all nodes, from small to big, around the given\n    position.\n    */ resolveStack(pos, side = 0) {\n        return stackIterator(this, pos, side);\n    }\n    /**\n    Iterate over the tree and its children, calling `enter` for any\n    node that touches the `from`/`to` region (if given) before\n    running over such a node's children, and `leave` (if given) when\n    leaving the node. When `enter` returns `false`, that node will\n    not have its children iterated over (or `leave` called).\n    */ iterate(spec) {\n        let { enter, leave, from = 0, to = this.length } = spec;\n        let mode = spec.mode || 0, anon = (mode & IterMode.IncludeAnonymous) > 0;\n        for(let c = this.cursor(mode | IterMode.IncludeAnonymous);;){\n            let entered = false;\n            if (c.from <= to && c.to >= from && (!anon && c.type.isAnonymous || enter(c) !== false)) {\n                if (c.firstChild()) continue;\n                entered = true;\n            }\n            for(;;){\n                if (entered && leave && (anon || !c.type.isAnonymous)) leave(c);\n                if (c.nextSibling()) break;\n                if (!c.parent()) return;\n                entered = true;\n            }\n        }\n    }\n    /**\n    Get the value of the given [node prop](#common.NodeProp) for this\n    node. Works with both per-node and per-type props.\n    */ prop(prop) {\n        return !prop.perNode ? this.type.prop(prop) : this.props ? this.props[prop.id] : undefined;\n    }\n    /**\n    Returns the node's [per-node props](#common.NodeProp.perNode) in a\n    format that can be passed to the [`Tree`](#common.Tree)\n    constructor.\n    */ get propValues() {\n        let result = [];\n        if (this.props) for(let id in this.props)result.push([\n            +id,\n            this.props[id]\n        ]);\n        return result;\n    }\n    /**\n    Balance the direct children of this tree, producing a copy of\n    which may have children grouped into subtrees with type\n    [`NodeType.none`](#common.NodeType^none).\n    */ balance(config = {}) {\n        return this.children.length <= 8 /* Balance.BranchFactor */  ? this : balanceRange(NodeType.none, this.children, this.positions, 0, this.children.length, 0, this.length, (children, positions, length)=>new Tree(this.type, children, positions, length, this.propValues), config.makeTree || ((children, positions, length)=>new Tree(NodeType.none, children, positions, length)));\n    }\n    /**\n    Build a tree from a postfix-ordered buffer of node information,\n    or a cursor over such a buffer.\n    */ static build(data) {\n        return buildTree(data);\n    }\n}\n/**\nThe empty tree\n*/ Tree.empty = new Tree(NodeType.none, [], [], 0);\nclass FlatBufferCursor {\n    constructor(buffer, index){\n        this.buffer = buffer;\n        this.index = index;\n    }\n    get id() {\n        return this.buffer[this.index - 4];\n    }\n    get start() {\n        return this.buffer[this.index - 3];\n    }\n    get end() {\n        return this.buffer[this.index - 2];\n    }\n    get size() {\n        return this.buffer[this.index - 1];\n    }\n    get pos() {\n        return this.index;\n    }\n    next() {\n        this.index -= 4;\n    }\n    fork() {\n        return new FlatBufferCursor(this.buffer, this.index);\n    }\n}\n/**\nTree buffers contain (type, start, end, endIndex) quads for each\nnode. In such a buffer, nodes are stored in prefix order (parents\nbefore children, with the endIndex of the parent indicating which\nchildren belong to it).\n*/ class TreeBuffer {\n    /**\n    Create a tree buffer.\n    */ constructor(/**\n    The buffer's content.\n    */ buffer, /**\n    The total length of the group of nodes in the buffer.\n    */ length, /**\n    The node set used in this buffer.\n    */ set){\n        this.buffer = buffer;\n        this.length = length;\n        this.set = set;\n    }\n    /**\n    @internal\n    */ get type() {\n        return NodeType.none;\n    }\n    /**\n    @internal\n    */ toString() {\n        let result = [];\n        for(let index = 0; index < this.buffer.length;){\n            result.push(this.childString(index));\n            index = this.buffer[index + 3];\n        }\n        return result.join(\",\");\n    }\n    /**\n    @internal\n    */ childString(index) {\n        let id = this.buffer[index], endIndex = this.buffer[index + 3];\n        let type = this.set.types[id], result = type.name;\n        if (/\\W/.test(result) && !type.isError) result = JSON.stringify(result);\n        index += 4;\n        if (endIndex == index) return result;\n        let children = [];\n        while(index < endIndex){\n            children.push(this.childString(index));\n            index = this.buffer[index + 3];\n        }\n        return result + \"(\" + children.join(\",\") + \")\";\n    }\n    /**\n    @internal\n    */ findChild(startIndex, endIndex, dir, pos, side) {\n        let { buffer } = this, pick = -1;\n        for(let i = startIndex; i != endIndex; i = buffer[i + 3]){\n            if (checkSide(side, pos, buffer[i + 1], buffer[i + 2])) {\n                pick = i;\n                if (dir > 0) break;\n            }\n        }\n        return pick;\n    }\n    /**\n    @internal\n    */ slice(startI, endI, from) {\n        let b = this.buffer;\n        let copy = new Uint16Array(endI - startI), len = 0;\n        for(let i = startI, j = 0; i < endI;){\n            copy[j++] = b[i++];\n            copy[j++] = b[i++] - from;\n            let to = copy[j++] = b[i++] - from;\n            copy[j++] = b[i++] - startI;\n            len = Math.max(len, to);\n        }\n        return new TreeBuffer(copy, len, this.set);\n    }\n}\nfunction checkSide(side, pos, from, to) {\n    switch(side){\n        case -2 /* Side.Before */ :\n            return from < pos;\n        case -1 /* Side.AtOrBefore */ :\n            return to >= pos && from < pos;\n        case 0 /* Side.Around */ :\n            return from < pos && to > pos;\n        case 1 /* Side.AtOrAfter */ :\n            return from <= pos && to > pos;\n        case 2 /* Side.After */ :\n            return to > pos;\n        case 4 /* Side.DontCare */ :\n            return true;\n    }\n}\nfunction resolveNode(node, pos, side, overlays) {\n    var _a;\n    // Move up to a node that actually holds the position, if possible\n    while(node.from == node.to || (side < 1 ? node.from >= pos : node.from > pos) || (side > -1 ? node.to <= pos : node.to < pos)){\n        let parent = !overlays && node instanceof TreeNode && node.index < 0 ? null : node.parent;\n        if (!parent) return node;\n        node = parent;\n    }\n    let mode = overlays ? 0 : IterMode.IgnoreOverlays;\n    // Must go up out of overlays when those do not overlap with pos\n    if (overlays) for(let scan = node, parent = scan.parent; parent; scan = parent, parent = scan.parent){\n        if (scan instanceof TreeNode && scan.index < 0 && ((_a = parent.enter(pos, side, mode)) === null || _a === void 0 ? void 0 : _a.from) != scan.from) node = parent;\n    }\n    for(;;){\n        let inner = node.enter(pos, side, mode);\n        if (!inner) return node;\n        node = inner;\n    }\n}\nclass BaseNode {\n    cursor(mode = 0) {\n        return new TreeCursor(this, mode);\n    }\n    getChild(type, before = null, after = null) {\n        let r = getChildren(this, type, before, after);\n        return r.length ? r[0] : null;\n    }\n    getChildren(type, before = null, after = null) {\n        return getChildren(this, type, before, after);\n    }\n    resolve(pos, side = 0) {\n        return resolveNode(this, pos, side, false);\n    }\n    resolveInner(pos, side = 0) {\n        return resolveNode(this, pos, side, true);\n    }\n    matchContext(context) {\n        return matchNodeContext(this, context);\n    }\n    enterUnfinishedNodesBefore(pos) {\n        let scan = this.childBefore(pos), node = this;\n        while(scan){\n            let last = scan.lastChild;\n            if (!last || last.to != scan.to) break;\n            if (last.type.isError && last.from == last.to) {\n                node = scan;\n                scan = last.prevSibling;\n            } else {\n                scan = last;\n            }\n        }\n        return node;\n    }\n    get node() {\n        return this;\n    }\n    get next() {\n        return this.parent;\n    }\n}\nclass TreeNode extends BaseNode {\n    constructor(_tree, from, // Index in parent node, set to -1 if the node is not a direct child of _parent.node (overlay)\n    index, _parent){\n        super();\n        this._tree = _tree;\n        this.from = from;\n        this.index = index;\n        this._parent = _parent;\n    }\n    get type() {\n        return this._tree.type;\n    }\n    get name() {\n        return this._tree.type.name;\n    }\n    get to() {\n        return this.from + this._tree.length;\n    }\n    nextChild(i, dir, pos, side, mode = 0) {\n        for(let parent = this;;){\n            for(let { children, positions } = parent._tree, e = dir > 0 ? children.length : -1; i != e; i += dir){\n                let next = children[i], start = positions[i] + parent.from;\n                if (!checkSide(side, pos, start, start + next.length)) continue;\n                if (next instanceof TreeBuffer) {\n                    if (mode & IterMode.ExcludeBuffers) continue;\n                    let index = next.findChild(0, next.buffer.length, dir, pos - start, side);\n                    if (index > -1) return new BufferNode(new BufferContext(parent, next, i, start), null, index);\n                } else if (mode & IterMode.IncludeAnonymous || !next.type.isAnonymous || hasChild(next)) {\n                    let mounted;\n                    if (!(mode & IterMode.IgnoreMounts) && (mounted = MountedTree.get(next)) && !mounted.overlay) return new TreeNode(mounted.tree, start, i, parent);\n                    let inner = new TreeNode(next, start, i, parent);\n                    return mode & IterMode.IncludeAnonymous || !inner.type.isAnonymous ? inner : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, pos, side);\n                }\n            }\n            if (mode & IterMode.IncludeAnonymous || !parent.type.isAnonymous) return null;\n            if (parent.index >= 0) i = parent.index + dir;\n            else i = dir < 0 ? -1 : parent._parent._tree.children.length;\n            parent = parent._parent;\n            if (!parent) return null;\n        }\n    }\n    get firstChild() {\n        return this.nextChild(0, 1, 0, 4 /* Side.DontCare */ );\n    }\n    get lastChild() {\n        return this.nextChild(this._tree.children.length - 1, -1, 0, 4 /* Side.DontCare */ );\n    }\n    childAfter(pos) {\n        return this.nextChild(0, 1, pos, 2 /* Side.After */ );\n    }\n    childBefore(pos) {\n        return this.nextChild(this._tree.children.length - 1, -1, pos, -2 /* Side.Before */ );\n    }\n    enter(pos, side, mode = 0) {\n        let mounted;\n        if (!(mode & IterMode.IgnoreOverlays) && (mounted = MountedTree.get(this._tree)) && mounted.overlay) {\n            let rPos = pos - this.from;\n            for (let { from, to } of mounted.overlay){\n                if ((side > 0 ? from <= rPos : from < rPos) && (side < 0 ? to >= rPos : to > rPos)) return new TreeNode(mounted.tree, mounted.overlay[0].from + this.from, -1, this);\n            }\n        }\n        return this.nextChild(0, 1, pos, side, mode);\n    }\n    nextSignificantParent() {\n        let val = this;\n        while(val.type.isAnonymous && val._parent)val = val._parent;\n        return val;\n    }\n    get parent() {\n        return this._parent ? this._parent.nextSignificantParent() : null;\n    }\n    get nextSibling() {\n        return this._parent && this.index >= 0 ? this._parent.nextChild(this.index + 1, 1, 0, 4 /* Side.DontCare */ ) : null;\n    }\n    get prevSibling() {\n        return this._parent && this.index >= 0 ? this._parent.nextChild(this.index - 1, -1, 0, 4 /* Side.DontCare */ ) : null;\n    }\n    get tree() {\n        return this._tree;\n    }\n    toTree() {\n        return this._tree;\n    }\n    /**\n    @internal\n    */ toString() {\n        return this._tree.toString();\n    }\n}\nfunction getChildren(node, type, before, after) {\n    let cur = node.cursor(), result = [];\n    if (!cur.firstChild()) return result;\n    if (before != null) {\n        while(!cur.type.is(before))if (!cur.nextSibling()) return result;\n    }\n    for(;;){\n        if (after != null && cur.type.is(after)) return result;\n        if (cur.type.is(type)) result.push(cur.node);\n        if (!cur.nextSibling()) return after == null ? result : [];\n    }\n}\nfunction matchNodeContext(node, context, i = context.length - 1) {\n    for(let p = node.parent; i >= 0; p = p.parent){\n        if (!p) return false;\n        if (!p.type.isAnonymous) {\n            if (context[i] && context[i] != p.name) return false;\n            i--;\n        }\n    }\n    return true;\n}\nclass BufferContext {\n    constructor(parent, buffer, index, start){\n        this.parent = parent;\n        this.buffer = buffer;\n        this.index = index;\n        this.start = start;\n    }\n}\nclass BufferNode extends BaseNode {\n    get name() {\n        return this.type.name;\n    }\n    get from() {\n        return this.context.start + this.context.buffer.buffer[this.index + 1];\n    }\n    get to() {\n        return this.context.start + this.context.buffer.buffer[this.index + 2];\n    }\n    constructor(context, _parent, index){\n        super();\n        this.context = context;\n        this._parent = _parent;\n        this.index = index;\n        this.type = context.buffer.set.types[context.buffer.buffer[index]];\n    }\n    child(dir, pos, side) {\n        let { buffer } = this.context;\n        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.context.start, side);\n        return index < 0 ? null : new BufferNode(this.context, this, index);\n    }\n    get firstChild() {\n        return this.child(1, 0, 4 /* Side.DontCare */ );\n    }\n    get lastChild() {\n        return this.child(-1, 0, 4 /* Side.DontCare */ );\n    }\n    childAfter(pos) {\n        return this.child(1, pos, 2 /* Side.After */ );\n    }\n    childBefore(pos) {\n        return this.child(-1, pos, -2 /* Side.Before */ );\n    }\n    enter(pos, side, mode = 0) {\n        if (mode & IterMode.ExcludeBuffers) return null;\n        let { buffer } = this.context;\n        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], side > 0 ? 1 : -1, pos - this.context.start, side);\n        return index < 0 ? null : new BufferNode(this.context, this, index);\n    }\n    get parent() {\n        return this._parent || this.context.parent.nextSignificantParent();\n    }\n    externalSibling(dir) {\n        return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, 0, 4 /* Side.DontCare */ );\n    }\n    get nextSibling() {\n        let { buffer } = this.context;\n        let after = buffer.buffer[this.index + 3];\n        if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length)) return new BufferNode(this.context, this._parent, after);\n        return this.externalSibling(1);\n    }\n    get prevSibling() {\n        let { buffer } = this.context;\n        let parentStart = this._parent ? this._parent.index + 4 : 0;\n        if (this.index == parentStart) return this.externalSibling(-1);\n        return new BufferNode(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, 0, 4 /* Side.DontCare */ ));\n    }\n    get tree() {\n        return null;\n    }\n    toTree() {\n        let children = [], positions = [];\n        let { buffer } = this.context;\n        let startI = this.index + 4, endI = buffer.buffer[this.index + 3];\n        if (endI > startI) {\n            let from = buffer.buffer[this.index + 1];\n            children.push(buffer.slice(startI, endI, from));\n            positions.push(0);\n        }\n        return new Tree(this.type, children, positions, this.to - this.from);\n    }\n    /**\n    @internal\n    */ toString() {\n        return this.context.buffer.childString(this.index);\n    }\n}\nfunction iterStack(heads) {\n    if (!heads.length) return null;\n    let pick = 0, picked = heads[0];\n    for(let i = 1; i < heads.length; i++){\n        let node = heads[i];\n        if (node.from > picked.from || node.to < picked.to) {\n            picked = node;\n            pick = i;\n        }\n    }\n    let next = picked instanceof TreeNode && picked.index < 0 ? null : picked.parent;\n    let newHeads = heads.slice();\n    if (next) newHeads[pick] = next;\n    else newHeads.splice(pick, 1);\n    return new StackIterator(newHeads, picked);\n}\nclass StackIterator {\n    constructor(heads, node){\n        this.heads = heads;\n        this.node = node;\n    }\n    get next() {\n        return iterStack(this.heads);\n    }\n}\nfunction stackIterator(tree, pos, side) {\n    let inner = tree.resolveInner(pos, side), layers = null;\n    for(let scan = inner instanceof TreeNode ? inner : inner.context.parent; scan; scan = scan.parent){\n        if (scan.index < 0) {\n            let parent = scan.parent;\n            (layers || (layers = [\n                inner\n            ])).push(parent.resolve(pos, side));\n            scan = parent;\n        } else {\n            let mount = MountedTree.get(scan.tree);\n            // Relevant overlay branching off\n            if (mount && mount.overlay && mount.overlay[0].from <= pos && mount.overlay[mount.overlay.length - 1].to >= pos) {\n                let root = new TreeNode(mount.tree, mount.overlay[0].from + scan.from, -1, scan);\n                (layers || (layers = [\n                    inner\n                ])).push(resolveNode(root, pos, side, false));\n            }\n        }\n    }\n    return layers ? iterStack(layers) : inner;\n}\n/**\nA tree cursor object focuses on a given node in a syntax tree, and\nallows you to move to adjacent nodes.\n*/ class TreeCursor {\n    /**\n    Shorthand for `.type.name`.\n    */ get name() {\n        return this.type.name;\n    }\n    /**\n    @internal\n    */ constructor(node, /**\n    @internal\n    */ mode = 0){\n        this.mode = mode;\n        /**\n        @internal\n        */ this.buffer = null;\n        this.stack = [];\n        /**\n        @internal\n        */ this.index = 0;\n        this.bufferNode = null;\n        if (node instanceof TreeNode) {\n            this.yieldNode(node);\n        } else {\n            this._tree = node.context.parent;\n            this.buffer = node.context;\n            for(let n = node._parent; n; n = n._parent)this.stack.unshift(n.index);\n            this.bufferNode = node;\n            this.yieldBuf(node.index);\n        }\n    }\n    yieldNode(node) {\n        if (!node) return false;\n        this._tree = node;\n        this.type = node.type;\n        this.from = node.from;\n        this.to = node.to;\n        return true;\n    }\n    yieldBuf(index, type) {\n        this.index = index;\n        let { start, buffer } = this.buffer;\n        this.type = type || buffer.set.types[buffer.buffer[index]];\n        this.from = start + buffer.buffer[index + 1];\n        this.to = start + buffer.buffer[index + 2];\n        return true;\n    }\n    /**\n    @internal\n    */ yield(node) {\n        if (!node) return false;\n        if (node instanceof TreeNode) {\n            this.buffer = null;\n            return this.yieldNode(node);\n        }\n        this.buffer = node.context;\n        return this.yieldBuf(node.index, node.type);\n    }\n    /**\n    @internal\n    */ toString() {\n        return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();\n    }\n    /**\n    @internal\n    */ enterChild(dir, pos, side) {\n        if (!this.buffer) return this.yield(this._tree.nextChild(dir < 0 ? this._tree._tree.children.length - 1 : 0, dir, pos, side, this.mode));\n        let { buffer } = this.buffer;\n        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.buffer.start, side);\n        if (index < 0) return false;\n        this.stack.push(this.index);\n        return this.yieldBuf(index);\n    }\n    /**\n    Move the cursor to this node's first child. When this returns\n    false, the node has no child, and the cursor has not been moved.\n    */ firstChild() {\n        return this.enterChild(1, 0, 4 /* Side.DontCare */ );\n    }\n    /**\n    Move the cursor to this node's last child.\n    */ lastChild() {\n        return this.enterChild(-1, 0, 4 /* Side.DontCare */ );\n    }\n    /**\n    Move the cursor to the first child that ends after `pos`.\n    */ childAfter(pos) {\n        return this.enterChild(1, pos, 2 /* Side.After */ );\n    }\n    /**\n    Move to the last child that starts before `pos`.\n    */ childBefore(pos) {\n        return this.enterChild(-1, pos, -2 /* Side.Before */ );\n    }\n    /**\n    Move the cursor to the child around `pos`. If side is -1 the\n    child may end at that position, when 1 it may start there. This\n    will also enter [overlaid](#common.MountedTree.overlay)\n    [mounted](#common.NodeProp^mounted) trees unless `overlays` is\n    set to false.\n    */ enter(pos, side, mode = this.mode) {\n        if (!this.buffer) return this.yield(this._tree.enter(pos, side, mode));\n        return mode & IterMode.ExcludeBuffers ? false : this.enterChild(1, pos, side);\n    }\n    /**\n    Move to the node's parent node, if this isn't the top node.\n    */ parent() {\n        if (!this.buffer) return this.yieldNode(this.mode & IterMode.IncludeAnonymous ? this._tree._parent : this._tree.parent);\n        if (this.stack.length) return this.yieldBuf(this.stack.pop());\n        let parent = this.mode & IterMode.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();\n        this.buffer = null;\n        return this.yieldNode(parent);\n    }\n    /**\n    @internal\n    */ sibling(dir) {\n        if (!this.buffer) return !this._tree._parent ? false : this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + dir, dir, 0, 4 /* Side.DontCare */ , this.mode));\n        let { buffer } = this.buffer, d = this.stack.length - 1;\n        if (dir < 0) {\n            let parentStart = d < 0 ? 0 : this.stack[d] + 4;\n            if (this.index != parentStart) return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, 0, 4 /* Side.DontCare */ ));\n        } else {\n            let after = buffer.buffer[this.index + 3];\n            if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3])) return this.yieldBuf(after);\n        }\n        return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, 0, 4 /* Side.DontCare */ , this.mode)) : false;\n    }\n    /**\n    Move to this node's next sibling, if any.\n    */ nextSibling() {\n        return this.sibling(1);\n    }\n    /**\n    Move to this node's previous sibling, if any.\n    */ prevSibling() {\n        return this.sibling(-1);\n    }\n    atLastNode(dir) {\n        let index, parent, { buffer } = this;\n        if (buffer) {\n            if (dir > 0) {\n                if (this.index < buffer.buffer.buffer.length) return false;\n            } else {\n                for(let i = 0; i < this.index; i++)if (buffer.buffer.buffer[i + 3] < this.index) return false;\n            }\n            ({ index, parent } = buffer);\n        } else {\n            ({ index, _parent: parent } = this._tree);\n        }\n        for(; parent; { index, _parent: parent } = parent){\n            if (index > -1) for(let i = index + dir, e = dir < 0 ? -1 : parent._tree.children.length; i != e; i += dir){\n                let child = parent._tree.children[i];\n                if (this.mode & IterMode.IncludeAnonymous || child instanceof TreeBuffer || !child.type.isAnonymous || hasChild(child)) return false;\n            }\n        }\n        return true;\n    }\n    move(dir, enter) {\n        if (enter && this.enterChild(dir, 0, 4 /* Side.DontCare */ )) return true;\n        for(;;){\n            if (this.sibling(dir)) return true;\n            if (this.atLastNode(dir) || !this.parent()) return false;\n        }\n    }\n    /**\n    Move to the next node in a\n    [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)\n    traversal, going from a node to its first child or, if the\n    current node is empty or `enter` is false, its next sibling or\n    the next sibling of the first parent node that has one.\n    */ next(enter = true) {\n        return this.move(1, enter);\n    }\n    /**\n    Move to the next node in a last-to-first pre-order traveral. A\n    node is followed by its last child or, if it has none, its\n    previous sibling or the previous sibling of the first parent\n    node that has one.\n    */ prev(enter = true) {\n        return this.move(-1, enter);\n    }\n    /**\n    Move the cursor to the innermost node that covers `pos`. If\n    `side` is -1, it will enter nodes that end at `pos`. If it is 1,\n    it will enter nodes that start at `pos`.\n    */ moveTo(pos, side = 0) {\n        // Move up to a node that actually holds the position, if possible\n        while(this.from == this.to || (side < 1 ? this.from >= pos : this.from > pos) || (side > -1 ? this.to <= pos : this.to < pos))if (!this.parent()) break;\n        // Then scan down into child nodes as far as possible\n        while(this.enterChild(1, pos, side)){}\n        return this;\n    }\n    /**\n    Get a [syntax node](#common.SyntaxNode) at the cursor's current\n    position.\n    */ get node() {\n        if (!this.buffer) return this._tree;\n        let cache = this.bufferNode, result = null, depth = 0;\n        if (cache && cache.context == this.buffer) {\n            scan: for(let index = this.index, d = this.stack.length; d >= 0;){\n                for(let c = cache; c; c = c._parent)if (c.index == index) {\n                    if (index == this.index) return c;\n                    result = c;\n                    depth = d + 1;\n                    break scan;\n                }\n                index = this.stack[--d];\n            }\n        }\n        for(let i = depth; i < this.stack.length; i++)result = new BufferNode(this.buffer, result, this.stack[i]);\n        return this.bufferNode = new BufferNode(this.buffer, result, this.index);\n    }\n    /**\n    Get the [tree](#common.Tree) that represents the current node, if\n    any. Will return null when the node is in a [tree\n    buffer](#common.TreeBuffer).\n    */ get tree() {\n        return this.buffer ? null : this._tree._tree;\n    }\n    /**\n    Iterate over the current node and all its descendants, calling\n    `enter` when entering a node and `leave`, if given, when leaving\n    one. When `enter` returns `false`, any children of that node are\n    skipped, and `leave` isn't called for it.\n    */ iterate(enter, leave) {\n        for(let depth = 0;;){\n            let mustLeave = false;\n            if (this.type.isAnonymous || enter(this) !== false) {\n                if (this.firstChild()) {\n                    depth++;\n                    continue;\n                }\n                if (!this.type.isAnonymous) mustLeave = true;\n            }\n            for(;;){\n                if (mustLeave && leave) leave(this);\n                mustLeave = this.type.isAnonymous;\n                if (this.nextSibling()) break;\n                if (!depth) return;\n                this.parent();\n                depth--;\n                mustLeave = true;\n            }\n        }\n    }\n    /**\n    Test whether the current node matches a given context—a sequence\n    of direct parent node names. Empty strings in the context array\n    are treated as wildcards.\n    */ matchContext(context) {\n        if (!this.buffer) return matchNodeContext(this.node, context);\n        let { buffer } = this.buffer, { types } = buffer.set;\n        for(let i = context.length - 1, d = this.stack.length - 1; i >= 0; d--){\n            if (d < 0) return matchNodeContext(this.node, context, i);\n            let type = types[buffer.buffer[this.stack[d]]];\n            if (!type.isAnonymous) {\n                if (context[i] && context[i] != type.name) return false;\n                i--;\n            }\n        }\n        return true;\n    }\n}\nfunction hasChild(tree) {\n    return tree.children.some((ch)=>ch instanceof TreeBuffer || !ch.type.isAnonymous || hasChild(ch));\n}\nfunction buildTree(data) {\n    var _a;\n    let { buffer, nodeSet, maxBufferLength = DefaultBufferLength, reused = [], minRepeatType = nodeSet.types.length } = data;\n    let cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;\n    let types = nodeSet.types;\n    let contextHash = 0, lookAhead = 0;\n    function takeNode(parentStart, minPos, children, positions, inRepeat, depth) {\n        let { id, start, end, size } = cursor;\n        let lookAheadAtStart = lookAhead;\n        while(size < 0){\n            cursor.next();\n            if (size == -1 /* SpecialRecord.Reuse */ ) {\n                let node = reused[id];\n                children.push(node);\n                positions.push(start - parentStart);\n                return;\n            } else if (size == -3 /* SpecialRecord.ContextChange */ ) {\n                contextHash = id;\n                return;\n            } else if (size == -4 /* SpecialRecord.LookAhead */ ) {\n                lookAhead = id;\n                return;\n            } else {\n                throw new RangeError(`Unrecognized record size: ${size}`);\n            }\n        }\n        let type = types[id], node, buffer;\n        let startPos = start - parentStart;\n        if (end - start <= maxBufferLength && (buffer = findBufferSize(cursor.pos - minPos, inRepeat))) {\n            // Small enough for a buffer, and no reused nodes inside\n            let data = new Uint16Array(buffer.size - buffer.skip);\n            let endPos = cursor.pos - buffer.size, index = data.length;\n            while(cursor.pos > endPos)index = copyToBuffer(buffer.start, data, index);\n            node = new TreeBuffer(data, end - buffer.start, nodeSet);\n            startPos = buffer.start - parentStart;\n        } else {\n            let endPos = cursor.pos - size;\n            cursor.next();\n            let localChildren = [], localPositions = [];\n            let localInRepeat = id >= minRepeatType ? id : -1;\n            let lastGroup = 0, lastEnd = end;\n            while(cursor.pos > endPos){\n                if (localInRepeat >= 0 && cursor.id == localInRepeat && cursor.size >= 0) {\n                    if (cursor.end <= lastEnd - maxBufferLength) {\n                        makeRepeatLeaf(localChildren, localPositions, start, lastGroup, cursor.end, lastEnd, localInRepeat, lookAheadAtStart);\n                        lastGroup = localChildren.length;\n                        lastEnd = cursor.end;\n                    }\n                    cursor.next();\n                } else if (depth > 2500 /* CutOff.Depth */ ) {\n                    takeFlatNode(start, endPos, localChildren, localPositions);\n                } else {\n                    takeNode(start, endPos, localChildren, localPositions, localInRepeat, depth + 1);\n                }\n            }\n            if (localInRepeat >= 0 && lastGroup > 0 && lastGroup < localChildren.length) makeRepeatLeaf(localChildren, localPositions, start, lastGroup, start, lastEnd, localInRepeat, lookAheadAtStart);\n            localChildren.reverse();\n            localPositions.reverse();\n            if (localInRepeat > -1 && lastGroup > 0) {\n                let make = makeBalanced(type);\n                node = balanceRange(type, localChildren, localPositions, 0, localChildren.length, 0, end - start, make, make);\n            } else {\n                node = makeTree(type, localChildren, localPositions, end - start, lookAheadAtStart - end);\n            }\n        }\n        children.push(node);\n        positions.push(startPos);\n    }\n    function takeFlatNode(parentStart, minPos, children, positions) {\n        let nodes = []; // Temporary, inverted array of leaf nodes found, with absolute positions\n        let nodeCount = 0, stopAt = -1;\n        while(cursor.pos > minPos){\n            let { id, start, end, size } = cursor;\n            if (size > 4) {\n                cursor.next();\n            } else if (stopAt > -1 && start < stopAt) {\n                break;\n            } else {\n                if (stopAt < 0) stopAt = end - maxBufferLength;\n                nodes.push(id, start, end);\n                nodeCount++;\n                cursor.next();\n            }\n        }\n        if (nodeCount) {\n            let buffer = new Uint16Array(nodeCount * 4);\n            let start = nodes[nodes.length - 2];\n            for(let i = nodes.length - 3, j = 0; i >= 0; i -= 3){\n                buffer[j++] = nodes[i];\n                buffer[j++] = nodes[i + 1] - start;\n                buffer[j++] = nodes[i + 2] - start;\n                buffer[j++] = j;\n            }\n            children.push(new TreeBuffer(buffer, nodes[2] - start, nodeSet));\n            positions.push(start - parentStart);\n        }\n    }\n    function makeBalanced(type) {\n        return (children, positions, length)=>{\n            let lookAhead = 0, lastI = children.length - 1, last, lookAheadProp;\n            if (lastI >= 0 && (last = children[lastI]) instanceof Tree) {\n                if (!lastI && last.type == type && last.length == length) return last;\n                if (lookAheadProp = last.prop(NodeProp.lookAhead)) lookAhead = positions[lastI] + last.length + lookAheadProp;\n            }\n            return makeTree(type, children, positions, length, lookAhead);\n        };\n    }\n    function makeRepeatLeaf(children, positions, base, i, from, to, type, lookAhead) {\n        let localChildren = [], localPositions = [];\n        while(children.length > i){\n            localChildren.push(children.pop());\n            localPositions.push(positions.pop() + base - from);\n        }\n        children.push(makeTree(nodeSet.types[type], localChildren, localPositions, to - from, lookAhead - to));\n        positions.push(from - base);\n    }\n    function makeTree(type, children, positions, length, lookAhead = 0, props) {\n        if (contextHash) {\n            let pair = [\n                NodeProp.contextHash,\n                contextHash\n            ];\n            props = props ? [\n                pair\n            ].concat(props) : [\n                pair\n            ];\n        }\n        if (lookAhead > 25) {\n            let pair = [\n                NodeProp.lookAhead,\n                lookAhead\n            ];\n            props = props ? [\n                pair\n            ].concat(props) : [\n                pair\n            ];\n        }\n        return new Tree(type, children, positions, length, props);\n    }\n    function findBufferSize(maxSize, inRepeat) {\n        // Scan through the buffer to find previous siblings that fit\n        // together in a TreeBuffer, and don't contain any reused nodes\n        // (which can't be stored in a buffer).\n        // If `inRepeat` is > -1, ignore node boundaries of that type for\n        // nesting, but make sure the end falls either at the start\n        // (`maxSize`) or before such a node.\n        let fork = cursor.fork();\n        let size = 0, start = 0, skip = 0, minStart = fork.end - maxBufferLength;\n        let result = {\n            size: 0,\n            start: 0,\n            skip: 0\n        };\n        scan: for(let minPos = fork.pos - maxSize; fork.pos > minPos;){\n            let nodeSize = fork.size;\n            // Pretend nested repeat nodes of the same type don't exist\n            if (fork.id == inRepeat && nodeSize >= 0) {\n                // Except that we store the current state as a valid return\n                // value.\n                result.size = size;\n                result.start = start;\n                result.skip = skip;\n                skip += 4;\n                size += 4;\n                fork.next();\n                continue;\n            }\n            let startPos = fork.pos - nodeSize;\n            if (nodeSize < 0 || startPos < minPos || fork.start < minStart) break;\n            let localSkipped = fork.id >= minRepeatType ? 4 : 0;\n            let nodeStart = fork.start;\n            fork.next();\n            while(fork.pos > startPos){\n                if (fork.size < 0) {\n                    if (fork.size == -3 /* SpecialRecord.ContextChange */ ) localSkipped += 4;\n                    else break scan;\n                } else if (fork.id >= minRepeatType) {\n                    localSkipped += 4;\n                }\n                fork.next();\n            }\n            start = nodeStart;\n            size += nodeSize;\n            skip += localSkipped;\n        }\n        if (inRepeat < 0 || size == maxSize) {\n            result.size = size;\n            result.start = start;\n            result.skip = skip;\n        }\n        return result.size > 4 ? result : undefined;\n    }\n    function copyToBuffer(bufferStart, buffer, index) {\n        let { id, start, end, size } = cursor;\n        cursor.next();\n        if (size >= 0 && id < minRepeatType) {\n            let startIndex = index;\n            if (size > 4) {\n                let endPos = cursor.pos - (size - 4);\n                while(cursor.pos > endPos)index = copyToBuffer(bufferStart, buffer, index);\n            }\n            buffer[--index] = startIndex;\n            buffer[--index] = end - bufferStart;\n            buffer[--index] = start - bufferStart;\n            buffer[--index] = id;\n        } else if (size == -3 /* SpecialRecord.ContextChange */ ) {\n            contextHash = id;\n        } else if (size == -4 /* SpecialRecord.LookAhead */ ) {\n            lookAhead = id;\n        }\n        return index;\n    }\n    let children = [], positions = [];\n    while(cursor.pos > 0)takeNode(data.start || 0, data.bufferStart || 0, children, positions, -1, 0);\n    let length = (_a = data.length) !== null && _a !== void 0 ? _a : children.length ? positions[0] + children[0].length : 0;\n    return new Tree(types[data.topID], children.reverse(), positions.reverse(), length);\n}\nconst nodeSizeCache = new WeakMap;\nfunction nodeSize(balanceType, node) {\n    if (!balanceType.isAnonymous || node instanceof TreeBuffer || node.type != balanceType) return 1;\n    let size = nodeSizeCache.get(node);\n    if (size == null) {\n        size = 1;\n        for (let child of node.children){\n            if (child.type != balanceType || !(child instanceof Tree)) {\n                size = 1;\n                break;\n            }\n            size += nodeSize(balanceType, child);\n        }\n        nodeSizeCache.set(node, size);\n    }\n    return size;\n}\nfunction balanceRange(// The type the balanced tree's inner nodes.\nbalanceType, // The direct children and their positions\nchildren, positions, // The index range in children/positions to use\nfrom, to, // The start position of the nodes, relative to their parent.\nstart, // Length of the outer node\nlength, // Function to build the top node of the balanced tree\nmkTop, // Function to build internal nodes for the balanced tree\nmkTree) {\n    let total = 0;\n    for(let i = from; i < to; i++)total += nodeSize(balanceType, children[i]);\n    let maxChild = Math.ceil(total * 1.5 / 8 /* Balance.BranchFactor */ );\n    let localChildren = [], localPositions = [];\n    function divide(children, positions, from, to, offset) {\n        for(let i = from; i < to;){\n            let groupFrom = i, groupStart = positions[i], groupSize = nodeSize(balanceType, children[i]);\n            i++;\n            for(; i < to; i++){\n                let nextSize = nodeSize(balanceType, children[i]);\n                if (groupSize + nextSize >= maxChild) break;\n                groupSize += nextSize;\n            }\n            if (i == groupFrom + 1) {\n                if (groupSize > maxChild) {\n                    let only = children[groupFrom]; // Only trees can have a size > 1\n                    divide(only.children, only.positions, 0, only.children.length, positions[groupFrom] + offset);\n                    continue;\n                }\n                localChildren.push(children[groupFrom]);\n            } else {\n                let length = positions[i - 1] + children[i - 1].length - groupStart;\n                localChildren.push(balanceRange(balanceType, children, positions, groupFrom, i, groupStart, length, null, mkTree));\n            }\n            localPositions.push(groupStart + offset - start);\n        }\n    }\n    divide(children, positions, from, to, 0);\n    return (mkTop || mkTree)(localChildren, localPositions, length);\n}\n/**\nProvides a way to associate values with pieces of trees. As long\nas that part of the tree is reused, the associated values can be\nretrieved from an updated tree.\n*/ class NodeWeakMap {\n    constructor(){\n        this.map = new WeakMap();\n    }\n    setBuffer(buffer, index, value) {\n        let inner = this.map.get(buffer);\n        if (!inner) this.map.set(buffer, inner = new Map);\n        inner.set(index, value);\n    }\n    getBuffer(buffer, index) {\n        let inner = this.map.get(buffer);\n        return inner && inner.get(index);\n    }\n    /**\n    Set the value for this syntax node.\n    */ set(node, value) {\n        if (node instanceof BufferNode) this.setBuffer(node.context.buffer, node.index, value);\n        else if (node instanceof TreeNode) this.map.set(node.tree, value);\n    }\n    /**\n    Retrieve value for this syntax node, if it exists in the map.\n    */ get(node) {\n        return node instanceof BufferNode ? this.getBuffer(node.context.buffer, node.index) : node instanceof TreeNode ? this.map.get(node.tree) : undefined;\n    }\n    /**\n    Set the value for the node that a cursor currently points to.\n    */ cursorSet(cursor, value) {\n        if (cursor.buffer) this.setBuffer(cursor.buffer.buffer, cursor.index, value);\n        else this.map.set(cursor.tree, value);\n    }\n    /**\n    Retrieve the value for the node that a cursor currently points\n    to.\n    */ cursorGet(cursor) {\n        return cursor.buffer ? this.getBuffer(cursor.buffer.buffer, cursor.index) : this.map.get(cursor.tree);\n    }\n}\n/**\nTree fragments are used during [incremental\nparsing](#common.Parser.startParse) to track parts of old trees\nthat can be reused in a new parse. An array of fragments is used\nto track regions of an old tree whose nodes might be reused in new\nparses. Use the static\n[`applyChanges`](#common.TreeFragment^applyChanges) method to\nupdate fragments for document changes.\n*/ class TreeFragment {\n    /**\n    Construct a tree fragment. You'll usually want to use\n    [`addTree`](#common.TreeFragment^addTree) and\n    [`applyChanges`](#common.TreeFragment^applyChanges) instead of\n    calling this directly.\n    */ constructor(/**\n    The start of the unchanged range pointed to by this fragment.\n    This refers to an offset in the _updated_ document (as opposed\n    to the original tree).\n    */ from, /**\n    The end of the unchanged range.\n    */ to, /**\n    The tree that this fragment is based on.\n    */ tree, /**\n    The offset between the fragment's tree and the document that\n    this fragment can be used against. Add this when going from\n    document to tree positions, subtract it to go from tree to\n    document positions.\n    */ offset, openStart = false, openEnd = false){\n        this.from = from;\n        this.to = to;\n        this.tree = tree;\n        this.offset = offset;\n        this.open = (openStart ? 1 /* Open.Start */  : 0) | (openEnd ? 2 /* Open.End */  : 0);\n    }\n    /**\n    Whether the start of the fragment represents the start of a\n    parse, or the end of a change. (In the second case, it may not\n    be safe to reuse some nodes at the start, depending on the\n    parsing algorithm.)\n    */ get openStart() {\n        return (this.open & 1 /* Open.Start */ ) > 0;\n    }\n    /**\n    Whether the end of the fragment represents the end of a\n    full-document parse, or the start of a change.\n    */ get openEnd() {\n        return (this.open & 2 /* Open.End */ ) > 0;\n    }\n    /**\n    Create a set of fragments from a freshly parsed tree, or update\n    an existing set of fragments by replacing the ones that overlap\n    with a tree with content from the new tree. When `partial` is\n    true, the parse is treated as incomplete, and the resulting\n    fragment has [`openEnd`](#common.TreeFragment.openEnd) set to\n    true.\n    */ static addTree(tree, fragments = [], partial = false) {\n        let result = [\n            new TreeFragment(0, tree.length, tree, 0, false, partial)\n        ];\n        for (let f of fragments)if (f.to > tree.length) result.push(f);\n        return result;\n    }\n    /**\n    Apply a set of edits to an array of fragments, removing or\n    splitting fragments as necessary to remove edited ranges, and\n    adjusting offsets for fragments that moved.\n    */ static applyChanges(fragments, changes, minGap = 128) {\n        if (!changes.length) return fragments;\n        let result = [];\n        let fI = 1, nextF = fragments.length ? fragments[0] : null;\n        for(let cI = 0, pos = 0, off = 0;; cI++){\n            let nextC = cI < changes.length ? changes[cI] : null;\n            let nextPos = nextC ? nextC.fromA : 1e9;\n            if (nextPos - pos >= minGap) while(nextF && nextF.from < nextPos){\n                let cut = nextF;\n                if (pos >= cut.from || nextPos <= cut.to || off) {\n                    let fFrom = Math.max(cut.from, pos) - off, fTo = Math.min(cut.to, nextPos) - off;\n                    cut = fFrom >= fTo ? null : new TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, cI > 0, !!nextC);\n                }\n                if (cut) result.push(cut);\n                if (nextF.to > nextPos) break;\n                nextF = fI < fragments.length ? fragments[fI++] : null;\n            }\n            if (!nextC) break;\n            pos = nextC.toA;\n            off = nextC.toA - nextC.toB;\n        }\n        return result;\n    }\n}\n/**\nA superclass that parsers should extend.\n*/ class Parser {\n    /**\n    Start a parse, returning a [partial parse](#common.PartialParse)\n    object. [`fragments`](#common.TreeFragment) can be passed in to\n    make the parse incremental.\n    \n    By default, the entire input is parsed. You can pass `ranges`,\n    which should be a sorted array of non-empty, non-overlapping\n    ranges, to parse only those ranges. The tree returned in that\n    case will start at `ranges[0].from`.\n    */ startParse(input, fragments, ranges) {\n        if (typeof input == \"string\") input = new StringInput(input);\n        ranges = !ranges ? [\n            new Range(0, input.length)\n        ] : ranges.length ? ranges.map((r)=>new Range(r.from, r.to)) : [\n            new Range(0, 0)\n        ];\n        return this.createParse(input, fragments || [], ranges);\n    }\n    /**\n    Run a full parse, returning the resulting tree.\n    */ parse(input, fragments, ranges) {\n        let parse = this.startParse(input, fragments, ranges);\n        for(;;){\n            let done = parse.advance();\n            if (done) return done;\n        }\n    }\n}\nclass StringInput {\n    constructor(string){\n        this.string = string;\n    }\n    get length() {\n        return this.string.length;\n    }\n    chunk(from) {\n        return this.string.slice(from);\n    }\n    get lineChunks() {\n        return false;\n    }\n    read(from, to) {\n        return this.string.slice(from, to);\n    }\n}\n/**\nCreate a parse wrapper that, after the inner parse completes,\nscans its tree for mixed language regions with the `nest`\nfunction, runs the resulting [inner parses](#common.NestedParse),\nand then [mounts](#common.NodeProp^mounted) their results onto the\ntree.\n*/ function parseMixed(nest) {\n    return (parse, input, fragments, ranges)=>new MixedParse(parse, nest, input, fragments, ranges);\n}\nclass InnerParse {\n    constructor(parser, parse, overlay, target, from){\n        this.parser = parser;\n        this.parse = parse;\n        this.overlay = overlay;\n        this.target = target;\n        this.from = from;\n    }\n}\nfunction checkRanges(ranges) {\n    if (!ranges.length || ranges.some((r)=>r.from >= r.to)) throw new RangeError(\"Invalid inner parse ranges given: \" + JSON.stringify(ranges));\n}\nclass ActiveOverlay {\n    constructor(parser, predicate, mounts, index, start, target, prev){\n        this.parser = parser;\n        this.predicate = predicate;\n        this.mounts = mounts;\n        this.index = index;\n        this.start = start;\n        this.target = target;\n        this.prev = prev;\n        this.depth = 0;\n        this.ranges = [];\n    }\n}\nconst stoppedInner = new NodeProp({\n    perNode: true\n});\nclass MixedParse {\n    constructor(base, nest, input, fragments, ranges){\n        this.nest = nest;\n        this.input = input;\n        this.fragments = fragments;\n        this.ranges = ranges;\n        this.inner = [];\n        this.innerDone = 0;\n        this.baseTree = null;\n        this.stoppedAt = null;\n        this.baseParse = base;\n    }\n    advance() {\n        if (this.baseParse) {\n            let done = this.baseParse.advance();\n            if (!done) return null;\n            this.baseParse = null;\n            this.baseTree = done;\n            this.startInner();\n            if (this.stoppedAt != null) for (let inner of this.inner)inner.parse.stopAt(this.stoppedAt);\n        }\n        if (this.innerDone == this.inner.length) {\n            let result = this.baseTree;\n            if (this.stoppedAt != null) result = new Tree(result.type, result.children, result.positions, result.length, result.propValues.concat([\n                [\n                    stoppedInner,\n                    this.stoppedAt\n                ]\n            ]));\n            return result;\n        }\n        let inner = this.inner[this.innerDone], done = inner.parse.advance();\n        if (done) {\n            this.innerDone++;\n            // This is a somewhat dodgy but super helpful hack where we\n            // patch up nodes created by the inner parse (and thus\n            // presumably not aliased anywhere else) to hold the information\n            // about the inner parse.\n            let props = Object.assign(Object.create(null), inner.target.props);\n            props[NodeProp.mounted.id] = new MountedTree(done, inner.overlay, inner.parser);\n            inner.target.props = props;\n        }\n        return null;\n    }\n    get parsedPos() {\n        if (this.baseParse) return 0;\n        let pos = this.input.length;\n        for(let i = this.innerDone; i < this.inner.length; i++){\n            if (this.inner[i].from < pos) pos = Math.min(pos, this.inner[i].parse.parsedPos);\n        }\n        return pos;\n    }\n    stopAt(pos) {\n        this.stoppedAt = pos;\n        if (this.baseParse) this.baseParse.stopAt(pos);\n        else for(let i = this.innerDone; i < this.inner.length; i++)this.inner[i].parse.stopAt(pos);\n    }\n    startInner() {\n        let fragmentCursor = new FragmentCursor(this.fragments);\n        let overlay = null;\n        let covered = null;\n        let cursor = new TreeCursor(new TreeNode(this.baseTree, this.ranges[0].from, 0, null), IterMode.IncludeAnonymous | IterMode.IgnoreMounts);\n        scan: for(let nest, isCovered;;){\n            let enter = true, range;\n            if (this.stoppedAt != null && cursor.from >= this.stoppedAt) {\n                enter = false;\n            } else if (fragmentCursor.hasNode(cursor)) {\n                if (overlay) {\n                    let match = overlay.mounts.find((m)=>m.frag.from <= cursor.from && m.frag.to >= cursor.to && m.mount.overlay);\n                    if (match) for (let r of match.mount.overlay){\n                        let from = r.from + match.pos, to = r.to + match.pos;\n                        if (from >= cursor.from && to <= cursor.to && !overlay.ranges.some((r)=>r.from < to && r.to > from)) overlay.ranges.push({\n                            from,\n                            to\n                        });\n                    }\n                }\n                enter = false;\n            } else if (covered && (isCovered = checkCover(covered.ranges, cursor.from, cursor.to))) {\n                enter = isCovered != 2 /* Cover.Full */ ;\n            } else if (!cursor.type.isAnonymous && (nest = this.nest(cursor, this.input)) && (cursor.from < cursor.to || !nest.overlay)) {\n                if (!cursor.tree) materialize(cursor);\n                let oldMounts = fragmentCursor.findMounts(cursor.from, nest.parser);\n                if (typeof nest.overlay == \"function\") {\n                    overlay = new ActiveOverlay(nest.parser, nest.overlay, oldMounts, this.inner.length, cursor.from, cursor.tree, overlay);\n                } else {\n                    let ranges = punchRanges(this.ranges, nest.overlay || (cursor.from < cursor.to ? [\n                        new Range(cursor.from, cursor.to)\n                    ] : []));\n                    if (ranges.length) checkRanges(ranges);\n                    if (ranges.length || !nest.overlay) this.inner.push(new InnerParse(nest.parser, ranges.length ? nest.parser.startParse(this.input, enterFragments(oldMounts, ranges), ranges) : nest.parser.startParse(\"\"), nest.overlay ? nest.overlay.map((r)=>new Range(r.from - cursor.from, r.to - cursor.from)) : null, cursor.tree, ranges.length ? ranges[0].from : cursor.from));\n                    if (!nest.overlay) enter = false;\n                    else if (ranges.length) covered = {\n                        ranges,\n                        depth: 0,\n                        prev: covered\n                    };\n                }\n            } else if (overlay && (range = overlay.predicate(cursor))) {\n                if (range === true) range = new Range(cursor.from, cursor.to);\n                if (range.from < range.to) overlay.ranges.push(range);\n            }\n            if (enter && cursor.firstChild()) {\n                if (overlay) overlay.depth++;\n                if (covered) covered.depth++;\n            } else {\n                for(;;){\n                    if (cursor.nextSibling()) break;\n                    if (!cursor.parent()) break scan;\n                    if (overlay && !--overlay.depth) {\n                        let ranges = punchRanges(this.ranges, overlay.ranges);\n                        if (ranges.length) {\n                            checkRanges(ranges);\n                            this.inner.splice(overlay.index, 0, new InnerParse(overlay.parser, overlay.parser.startParse(this.input, enterFragments(overlay.mounts, ranges), ranges), overlay.ranges.map((r)=>new Range(r.from - overlay.start, r.to - overlay.start)), overlay.target, ranges[0].from));\n                        }\n                        overlay = overlay.prev;\n                    }\n                    if (covered && !--covered.depth) covered = covered.prev;\n                }\n            }\n        }\n    }\n}\nfunction checkCover(covered, from, to) {\n    for (let range of covered){\n        if (range.from >= to) break;\n        if (range.to > from) return range.from <= from && range.to >= to ? 2 /* Cover.Full */  : 1 /* Cover.Partial */ ;\n    }\n    return 0 /* Cover.None */ ;\n}\n// Take a piece of buffer and convert it into a stand-alone\n// TreeBuffer.\nfunction sliceBuf(buf, startI, endI, nodes, positions, off) {\n    if (startI < endI) {\n        let from = buf.buffer[startI + 1];\n        nodes.push(buf.slice(startI, endI, from));\n        positions.push(from - off);\n    }\n}\n// This function takes a node that's in a buffer, and converts it, and\n// its parent buffer nodes, into a Tree. This is again acting on the\n// assumption that the trees and buffers have been constructed by the\n// parse that was ran via the mix parser, and thus aren't shared with\n// any other code, making violations of the immutability safe.\nfunction materialize(cursor) {\n    let { node } = cursor, stack = [];\n    // Scan up to the nearest tree\n    do {\n        stack.push(cursor.index);\n        cursor.parent();\n    }while (!cursor.tree);\n    // Find the index of the buffer in that tree\n    let i = 0, base = cursor.tree, off = 0;\n    for(;; i++){\n        off = base.positions[i] + cursor.from;\n        if (off <= node.from && off + base.children[i].length >= node.to) break;\n    }\n    let buf = base.children[i], b = buf.buffer, newStack = [\n        i\n    ];\n    // Split a level in the buffer, putting the nodes before and after\n    // the child that contains `node` into new buffers.\n    function split(startI, endI, type, innerOffset, length, stackPos) {\n        let targetI = stack[stackPos];\n        let children = [], positions = [];\n        sliceBuf(buf, startI, targetI, children, positions, innerOffset);\n        let from = b[targetI + 1], to = b[targetI + 2];\n        newStack.push(children.length);\n        let child = stackPos ? split(targetI + 4, b[targetI + 3], buf.set.types[b[targetI]], from, to - from, stackPos - 1) : node.toTree();\n        children.push(child);\n        positions.push(from - innerOffset);\n        sliceBuf(buf, b[targetI + 3], endI, children, positions, innerOffset);\n        return new Tree(type, children, positions, length);\n    }\n    base.children[i] = split(0, b.length, NodeType.none, 0, buf.length, stack.length - 1);\n    // Move the cursor back to the target node\n    for (let index of newStack){\n        let tree = cursor.tree.children[index], pos = cursor.tree.positions[index];\n        cursor.yield(new TreeNode(tree, pos + cursor.from, index, cursor._tree));\n    }\n}\nclass StructureCursor {\n    constructor(root, offset){\n        this.offset = offset;\n        this.done = false;\n        this.cursor = root.cursor(IterMode.IncludeAnonymous | IterMode.IgnoreMounts);\n    }\n    // Move to the first node (in pre-order) that starts at or after `pos`.\n    moveTo(pos) {\n        let { cursor } = this, p = pos - this.offset;\n        while(!this.done && cursor.from < p){\n            if (cursor.to >= pos && cursor.enter(p, 1, IterMode.IgnoreOverlays | IterMode.ExcludeBuffers)) ;\n            else if (!cursor.next(false)) this.done = true;\n        }\n    }\n    hasNode(cursor) {\n        this.moveTo(cursor.from);\n        if (!this.done && this.cursor.from + this.offset == cursor.from && this.cursor.tree) {\n            for(let tree = this.cursor.tree;;){\n                if (tree == cursor.tree) return true;\n                if (tree.children.length && tree.positions[0] == 0 && tree.children[0] instanceof Tree) tree = tree.children[0];\n                else break;\n            }\n        }\n        return false;\n    }\n}\nclass FragmentCursor {\n    constructor(fragments){\n        var _a;\n        this.fragments = fragments;\n        this.curTo = 0;\n        this.fragI = 0;\n        if (fragments.length) {\n            let first = this.curFrag = fragments[0];\n            this.curTo = (_a = first.tree.prop(stoppedInner)) !== null && _a !== void 0 ? _a : first.to;\n            this.inner = new StructureCursor(first.tree, -first.offset);\n        } else {\n            this.curFrag = this.inner = null;\n        }\n    }\n    hasNode(node) {\n        while(this.curFrag && node.from >= this.curTo)this.nextFrag();\n        return this.curFrag && this.curFrag.from <= node.from && this.curTo >= node.to && this.inner.hasNode(node);\n    }\n    nextFrag() {\n        var _a;\n        this.fragI++;\n        if (this.fragI == this.fragments.length) {\n            this.curFrag = this.inner = null;\n        } else {\n            let frag = this.curFrag = this.fragments[this.fragI];\n            this.curTo = (_a = frag.tree.prop(stoppedInner)) !== null && _a !== void 0 ? _a : frag.to;\n            this.inner = new StructureCursor(frag.tree, -frag.offset);\n        }\n    }\n    findMounts(pos, parser) {\n        var _a;\n        let result = [];\n        if (this.inner) {\n            this.inner.cursor.moveTo(pos, 1);\n            for(let pos = this.inner.cursor.node; pos; pos = pos.parent){\n                let mount = (_a = pos.tree) === null || _a === void 0 ? void 0 : _a.prop(NodeProp.mounted);\n                if (mount && mount.parser == parser) {\n                    for(let i = this.fragI; i < this.fragments.length; i++){\n                        let frag = this.fragments[i];\n                        if (frag.from >= pos.to) break;\n                        if (frag.tree == this.curFrag.tree) result.push({\n                            frag,\n                            pos: pos.from - frag.offset,\n                            mount\n                        });\n                    }\n                }\n            }\n        }\n        return result;\n    }\n}\nfunction punchRanges(outer, ranges) {\n    let copy = null, current = ranges;\n    for(let i = 1, j = 0; i < outer.length; i++){\n        let gapFrom = outer[i - 1].to, gapTo = outer[i].from;\n        for(; j < current.length; j++){\n            let r = current[j];\n            if (r.from >= gapTo) break;\n            if (r.to <= gapFrom) continue;\n            if (!copy) current = copy = ranges.slice();\n            if (r.from < gapFrom) {\n                copy[j] = new Range(r.from, gapFrom);\n                if (r.to > gapTo) copy.splice(j + 1, 0, new Range(gapTo, r.to));\n            } else if (r.to > gapTo) {\n                copy[j--] = new Range(gapTo, r.to);\n            } else {\n                copy.splice(j--, 1);\n            }\n        }\n    }\n    return current;\n}\nfunction findCoverChanges(a, b, from, to) {\n    let iA = 0, iB = 0, inA = false, inB = false, pos = -1e9;\n    let result = [];\n    for(;;){\n        let nextA = iA == a.length ? 1e9 : inA ? a[iA].to : a[iA].from;\n        let nextB = iB == b.length ? 1e9 : inB ? b[iB].to : b[iB].from;\n        if (inA != inB) {\n            let start = Math.max(pos, from), end = Math.min(nextA, nextB, to);\n            if (start < end) result.push(new Range(start, end));\n        }\n        pos = Math.min(nextA, nextB);\n        if (pos == 1e9) break;\n        if (nextA == pos) {\n            if (!inA) inA = true;\n            else {\n                inA = false;\n                iA++;\n            }\n        }\n        if (nextB == pos) {\n            if (!inB) inB = true;\n            else {\n                inB = false;\n                iB++;\n            }\n        }\n    }\n    return result;\n}\n// Given a number of fragments for the outer tree, and a set of ranges\n// to parse, find fragments for inner trees mounted around those\n// ranges, if any.\nfunction enterFragments(mounts, ranges) {\n    let result = [];\n    for (let { pos, mount, frag } of mounts){\n        let startPos = pos + (mount.overlay ? mount.overlay[0].from : 0), endPos = startPos + mount.tree.length;\n        let from = Math.max(frag.from, startPos), to = Math.min(frag.to, endPos);\n        if (mount.overlay) {\n            let overlay = mount.overlay.map((r)=>new Range(r.from + pos, r.to + pos));\n            let changes = findCoverChanges(ranges, overlay, from, to);\n            for(let i = 0, pos = from;; i++){\n                let last = i == changes.length, end = last ? to : changes[i].from;\n                if (end > pos) result.push(new TreeFragment(pos, end, mount.tree, -startPos, frag.from >= pos || frag.openStart, frag.to <= end || frag.openEnd));\n                if (last) break;\n                pos = changes[i].to;\n            }\n        } else {\n            result.push(new TreeFragment(from, to, mount.tree, -startPos, frag.from >= startPos || frag.openStart, frag.to <= endPos || frag.openEnd));\n        }\n    }\n    return result;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxlemVyL2NvbW1vbi9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7QUFFQSxHQUNBLE1BQU1BLHNCQUFzQjtBQUM1QixJQUFJQyxhQUFhO0FBQ2pCLE1BQU1DO0lBQ0ZDLFlBQVlDLElBQUksRUFBRUMsRUFBRSxDQUFFO1FBQ2xCLElBQUksQ0FBQ0QsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQ0MsRUFBRSxHQUFHQTtJQUNkO0FBQ0o7QUFDQTs7OztBQUlBLEdBQ0EsTUFBTUM7SUFDRjs7SUFFQSxHQUNBSCxZQUFZSSxTQUFTLENBQUMsQ0FBQyxDQUFFO1FBQ3JCLElBQUksQ0FBQ0MsRUFBRSxHQUFHUDtRQUNWLElBQUksQ0FBQ1EsT0FBTyxHQUFHLENBQUMsQ0FBQ0YsT0FBT0UsT0FBTztRQUMvQixJQUFJLENBQUNDLFdBQVcsR0FBR0gsT0FBT0csV0FBVyxJQUFLO1lBQ3RDLE1BQU0sSUFBSUMsTUFBTTtRQUNwQjtJQUNKO0lBQ0E7Ozs7Ozs7O0lBUUEsR0FDQUMsSUFBSUMsS0FBSyxFQUFFO1FBQ1AsSUFBSSxJQUFJLENBQUNKLE9BQU8sRUFDWixNQUFNLElBQUlLLFdBQVc7UUFDekIsSUFBSSxPQUFPRCxTQUFTLFlBQ2hCQSxRQUFRRSxTQUFTRixLQUFLLENBQUNBO1FBQzNCLE9BQU8sQ0FBQ0c7WUFDSixJQUFJQyxTQUFTSixNQUFNRztZQUNuQixPQUFPQyxXQUFXQyxZQUFZLE9BQU87Z0JBQUMsSUFBSTtnQkFBRUQ7YUFBTztRQUN2RDtJQUNKO0FBQ0o7QUFDQTs7Ozs7QUFLQSxHQUNBWCxTQUFTYSxRQUFRLEdBQUcsSUFBSWIsU0FBUztJQUFFSSxhQUFhVSxDQUFBQSxNQUFPQSxJQUFJQyxLQUFLLENBQUM7QUFBSztBQUN0RTs7OztBQUlBLEdBQ0FmLFNBQVNnQixRQUFRLEdBQUcsSUFBSWhCLFNBQVM7SUFBRUksYUFBYVUsQ0FBQUEsTUFBT0EsSUFBSUMsS0FBSyxDQUFD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O2dCQUNqRSxJQUFJcUgsTUFBTWxDLEtBQ050RSxPQUFPbUQsSUFBSSxDQUFDLElBQUlzTSxhQUFhbkwsS0FBS2tDLEtBQUttRSxNQUFNaEssSUFBSSxFQUFFLENBQUM0TCxVQUFVK0csS0FBS25VLElBQUksSUFBSW1GLE9BQU9nUCxLQUFLNUQsU0FBUyxFQUFFNEQsS0FBS2xVLEVBQUUsSUFBSW9ILE9BQU84TSxLQUFLM0QsT0FBTztnQkFDcEksSUFBSTVHLE1BQ0E7Z0JBQ0p6RSxNQUFNNEwsT0FBTyxDQUFDek4sRUFBRSxDQUFDckQsRUFBRTtZQUN2QjtRQUNKLE9BQ0s7WUFDRFksT0FBT21ELElBQUksQ0FBQyxJQUFJc00sYUFBYXRRLE1BQU1DLElBQUl1TCxNQUFNaEssSUFBSSxFQUFFLENBQUM0TCxVQUFVK0csS0FBS25VLElBQUksSUFBSW9OLFlBQVkrRyxLQUFLNUQsU0FBUyxFQUFFNEQsS0FBS2xVLEVBQUUsSUFBSXNOLFVBQVU0RyxLQUFLM0QsT0FBTztRQUM1STtJQUNKO0lBQ0EsT0FBTzNQO0FBQ1g7QUFFZ0siLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9weXRob24tb25saW5lLWVkaXRvci8uL25vZGVfbW9kdWxlcy9AbGV6ZXIvY29tbW9uL2Rpc3QvaW5kZXguanM/YzE5MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcblRoZSBkZWZhdWx0IG1heGltdW0gbGVuZ3RoIG9mIGEgYFRyZWVCdWZmZXJgIG5vZGUuXG4qL1xuY29uc3QgRGVmYXVsdEJ1ZmZlckxlbmd0aCA9IDEwMjQ7XG5sZXQgbmV4dFByb3BJRCA9IDA7XG5jbGFzcyBSYW5nZSB7XG4gICAgY29uc3RydWN0b3IoZnJvbSwgdG8pIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgIH1cbn1cbi8qKlxuRWFjaCBbbm9kZSB0eXBlXSgjY29tbW9uLk5vZGVUeXBlKSBvciBbaW5kaXZpZHVhbCB0cmVlXSgjY29tbW9uLlRyZWUpXG5jYW4gaGF2ZSBtZXRhZGF0YSBhc3NvY2lhdGVkIHdpdGggaXQgaW4gcHJvcHMuIEluc3RhbmNlcyBvZiB0aGlzXG5jbGFzcyByZXByZXNlbnQgcHJvcCBuYW1lcy5cbiovXG5jbGFzcyBOb2RlUHJvcCB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbmV3IG5vZGUgcHJvcCB0eXBlLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnID0ge30pIHtcbiAgICAgICAgdGhpcy5pZCA9IG5leHRQcm9wSUQrKztcbiAgICAgICAgdGhpcy5wZXJOb2RlID0gISFjb25maWcucGVyTm9kZTtcbiAgICAgICAgdGhpcy5kZXNlcmlhbGl6ZSA9IGNvbmZpZy5kZXNlcmlhbGl6ZSB8fCAoKCkgPT4ge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBub2RlIHR5cGUgZG9lc24ndCBkZWZpbmUgYSBkZXNlcmlhbGl6ZSBmdW5jdGlvblwiKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoaXMgaXMgbWVhbnQgdG8gYmUgdXNlZCB3aXRoXG4gICAgW2BOb2RlU2V0LmV4dGVuZGBdKCNjb21tb24uTm9kZVNldC5leHRlbmQpIG9yXG4gICAgW2BMUlBhcnNlci5jb25maWd1cmVgXSgjbHIuUGFyc2VyQ29uZmlnLnByb3BzKSB0byBjb21wdXRlXG4gICAgcHJvcCB2YWx1ZXMgZm9yIGVhY2ggbm9kZSB0eXBlIGluIHRoZSBzZXQuIFRha2VzIGEgW21hdGNoXG4gICAgb2JqZWN0XSgjY29tbW9uLk5vZGVUeXBlXm1hdGNoKSBvciBmdW5jdGlvbiB0aGF0IHJldHVybnMgdW5kZWZpbmVkXG4gICAgaWYgdGhlIG5vZGUgdHlwZSBkb2Vzbid0IGdldCB0aGlzIHByb3AsIGFuZCB0aGUgcHJvcCdzIHZhbHVlIGlmXG4gICAgaXQgZG9lcy5cbiAgICAqL1xuICAgIGFkZChtYXRjaCkge1xuICAgICAgICBpZiAodGhpcy5wZXJOb2RlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJDYW4ndCBhZGQgcGVyLW5vZGUgcHJvcHMgdG8gbm9kZSB0eXBlc1wiKTtcbiAgICAgICAgaWYgKHR5cGVvZiBtYXRjaCAhPSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgICBtYXRjaCA9IE5vZGVUeXBlLm1hdGNoKG1hdGNoKTtcbiAgICAgICAgcmV0dXJuICh0eXBlKSA9PiB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gbWF0Y2godHlwZSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBudWxsIDogW3RoaXMsIHJlc3VsdF07XG4gICAgICAgIH07XG4gICAgfVxufVxuLyoqXG5Qcm9wIHRoYXQgaXMgdXNlZCB0byBkZXNjcmliZSBtYXRjaGluZyBkZWxpbWl0ZXJzLiBGb3Igb3BlbmluZ1xuZGVsaW1pdGVycywgdGhpcyBob2xkcyBhbiBhcnJheSBvZiBub2RlIG5hbWVzICh3cml0dGVuIGFzIGFcbnNwYWNlLXNlcGFyYXRlZCBzdHJpbmcgd2hlbiBkZWNsYXJpbmcgdGhpcyBwcm9wIGluIGEgZ3JhbW1hcilcbmZvciB0aGUgbm9kZSB0eXBlcyBvZiBjbG9zaW5nIGRlbGltaXRlcnMgdGhhdCBtYXRjaCBpdC5cbiovXG5Ob2RlUHJvcC5jbG9zZWRCeSA9IG5ldyBOb2RlUHJvcCh7IGRlc2VyaWFsaXplOiBzdHIgPT4gc3RyLnNwbGl0KFwiIFwiKSB9KTtcbi8qKlxuVGhlIGludmVyc2Ugb2YgW2BjbG9zZWRCeWBdKCNjb21tb24uTm9kZVByb3BeY2xvc2VkQnkpLiBUaGlzIGlzXG5hdHRhY2hlZCB0byBjbG9zaW5nIGRlbGltaXRlcnMsIGhvbGRpbmcgYW4gYXJyYXkgb2Ygbm9kZSBuYW1lc1xub2YgdHlwZXMgb2YgbWF0Y2hpbmcgb3BlbmluZyBkZWxpbWl0ZXJzLlxuKi9cbk5vZGVQcm9wLm9wZW5lZEJ5ID0gbmV3IE5vZGVQcm9wKHsgZGVzZXJpYWxpemU6IHN0ciA9PiBzdHIuc3BsaXQoXCIgXCIpIH0pO1xuLyoqXG5Vc2VkIHRvIGFzc2lnbiBub2RlIHR5cGVzIHRvIGdyb3VwcyAoZm9yIGV4YW1wbGUsIGFsbCBub2RlXG50eXBlcyB0aGF0IHJlcHJlc2VudCBhbiBleHByZXNzaW9uIGNvdWxkIGJlIHRhZ2dlZCB3aXRoIGFuXG5gXCJFeHByZXNzaW9uXCJgIGdyb3VwKS5cbiovXG5Ob2RlUHJvcC5ncm91cCA9IG5ldyBOb2RlUHJvcCh7IGRlc2VyaWFsaXplOiBzdHIgPT4gc3RyLnNwbGl0KFwiIFwiKSB9KTtcbi8qKlxuVGhlIGhhc2ggb2YgdGhlIFtjb250ZXh0XSgjbHIuQ29udGV4dFRyYWNrZXIuY29uc3RydWN0b3IpXG50aGF0IHRoZSBub2RlIHdhcyBwYXJzZWQgaW4sIGlmIGFueS4gVXNlZCB0byBsaW1pdCByZXVzZSBvZlxuY29udGV4dHVhbCBub2Rlcy5cbiovXG5Ob2RlUHJvcC5jb250ZXh0SGFzaCA9IG5ldyBOb2RlUHJvcCh7IHBlck5vZGU6IHRydWUgfSk7XG4vKipcblRoZSBkaXN0YW5jZSBiZXlvbmQgdGhlIGVuZCBvZiB0aGUgbm9kZSB0aGF0IHRoZSB0b2tlbml6ZXJcbmxvb2tlZCBhaGVhZCBmb3IgYW55IG9mIHRoZSB0b2tlbnMgaW5zaWRlIHRoZSBub2RlLiAoVGhlIExSXG5wYXJzZXIgb25seSBzdG9yZXMgdGhpcyB3aGVuIGl0IGlzIGxhcmdlciB0aGFuIDI1LCBmb3JcbmVmZmljaWVuY3kgcmVhc29ucy4pXG4qL1xuTm9kZVByb3AubG9va0FoZWFkID0gbmV3IE5vZGVQcm9wKHsgcGVyTm9kZTogdHJ1ZSB9KTtcbi8qKlxuVGhpcyBwZXItbm9kZSBwcm9wIGlzIHVzZWQgdG8gcmVwbGFjZSBhIGdpdmVuIG5vZGUsIG9yIHBhcnQgb2YgYVxubm9kZSwgd2l0aCBhbm90aGVyIHRyZWUuIFRoaXMgaXMgdXNlZnVsIHRvIGluY2x1ZGUgdHJlZXMgZnJvbVxuZGlmZmVyZW50IGxhbmd1YWdlcyBpbiBtaXhlZC1sYW5ndWFnZSBwYXJzZXJzLlxuKi9cbk5vZGVQcm9wLm1vdW50ZWQgPSBuZXcgTm9kZVByb3AoeyBwZXJOb2RlOiB0cnVlIH0pO1xuLyoqXG5BIG1vdW50ZWQgdHJlZSwgd2hpY2ggY2FuIGJlIFtzdG9yZWRdKCNjb21tb24uTm9kZVByb3BebW91bnRlZCkgb25cbmEgdHJlZSBub2RlIHRvIGluZGljYXRlIHRoYXQgcGFydHMgb2YgaXRzIGNvbnRlbnQgYXJlXG5yZXByZXNlbnRlZCBieSBhbm90aGVyIHRyZWUuXG4qL1xuY2xhc3MgTW91bnRlZFRyZWUge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBpbm5lciB0cmVlLlxuICAgICovXG4gICAgdHJlZSwgXG4gICAgLyoqXG4gICAgSWYgdGhpcyBpcyBudWxsLCB0aGlzIHRyZWUgcmVwbGFjZXMgdGhlIGVudGlyZSBub2RlIChpdCB3aWxsXG4gICAgYmUgaW5jbHVkZWQgaW4gdGhlIHJlZ3VsYXIgaXRlcmF0aW9uIGluc3RlYWQgb2YgaXRzIGhvc3RcbiAgICBub2RlKS4gSWYgbm90LCBvbmx5IHRoZSBnaXZlbiByYW5nZXMgYXJlIGNvbnNpZGVyZWQgdG8gYmVcbiAgICBjb3ZlcmVkIGJ5IHRoaXMgdHJlZS4gVGhpcyBpcyB1c2VkIGZvciB0cmVlcyB0aGF0IGFyZSBtaXhlZCBpblxuICAgIGEgd2F5IHRoYXQgaXNuJ3Qgc3RyaWN0bHkgaGllcmFyY2hpY2FsLiBTdWNoIG1vdW50ZWQgdHJlZXMgYXJlXG4gICAgb25seSBlbnRlcmVkIGJ5IFtgcmVzb2x2ZUlubmVyYF0oI2NvbW1vbi5UcmVlLnJlc29sdmVJbm5lcilcbiAgICBhbmQgW2BlbnRlcmBdKCNjb21tb24uU3ludGF4Tm9kZS5lbnRlcikuXG4gICAgKi9cbiAgICBvdmVybGF5LCBcbiAgICAvKipcbiAgICBUaGUgcGFyc2VyIHVzZWQgdG8gY3JlYXRlIHRoaXMgc3VidHJlZS5cbiAgICAqL1xuICAgIHBhcnNlcikge1xuICAgICAgICB0aGlzLnRyZWUgPSB0cmVlO1xuICAgICAgICB0aGlzLm92ZXJsYXkgPSBvdmVybGF5O1xuICAgICAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgZ2V0KHRyZWUpIHtcbiAgICAgICAgcmV0dXJuIHRyZWUgJiYgdHJlZS5wcm9wcyAmJiB0cmVlLnByb3BzW05vZGVQcm9wLm1vdW50ZWQuaWRdO1xuICAgIH1cbn1cbmNvbnN0IG5vUHJvcHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuLyoqXG5FYWNoIG5vZGUgaW4gYSBzeW50YXggdHJlZSBoYXMgYSBub2RlIHR5cGUgYXNzb2NpYXRlZCB3aXRoIGl0LlxuKi9cbmNsYXNzIE5vZGVUeXBlIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBuYW1lIG9mIHRoZSBub2RlIHR5cGUuIE5vdCBuZWNlc3NhcmlseSB1bmlxdWUsIGJ1dCBpZiB0aGVcbiAgICBncmFtbWFyIHdhcyB3cml0dGVuIHByb3Blcmx5LCBkaWZmZXJlbnQgbm9kZSB0eXBlcyB3aXRoIHRoZVxuICAgIHNhbWUgbmFtZSB3aXRoaW4gYSBub2RlIHNldCBzaG91bGQgcGxheSB0aGUgc2FtZSBzZW1hbnRpY1xuICAgIHJvbGUuXG4gICAgKi9cbiAgICBuYW1lLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHByb3BzLCBcbiAgICAvKipcbiAgICBUaGUgaWQgb2YgdGhpcyBub2RlIGluIGl0cyBzZXQuIENvcnJlc3BvbmRzIHRvIHRoZSB0ZXJtIGlkc1xuICAgIHVzZWQgaW4gdGhlIHBhcnNlci5cbiAgICAqL1xuICAgIGlkLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGZsYWdzID0gMCkge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5mbGFncyA9IGZsYWdzO1xuICAgIH1cbiAgICAvKipcbiAgICBEZWZpbmUgYSBub2RlIHR5cGUuXG4gICAgKi9cbiAgICBzdGF0aWMgZGVmaW5lKHNwZWMpIHtcbiAgICAgICAgbGV0IHByb3BzID0gc3BlYy5wcm9wcyAmJiBzcGVjLnByb3BzLmxlbmd0aCA/IE9iamVjdC5jcmVhdGUobnVsbCkgOiBub1Byb3BzO1xuICAgICAgICBsZXQgZmxhZ3MgPSAoc3BlYy50b3AgPyAxIC8qIE5vZGVGbGFnLlRvcCAqLyA6IDApIHwgKHNwZWMuc2tpcHBlZCA/IDIgLyogTm9kZUZsYWcuU2tpcHBlZCAqLyA6IDApIHxcbiAgICAgICAgICAgIChzcGVjLmVycm9yID8gNCAvKiBOb2RlRmxhZy5FcnJvciAqLyA6IDApIHwgKHNwZWMubmFtZSA9PSBudWxsID8gOCAvKiBOb2RlRmxhZy5Bbm9ueW1vdXMgKi8gOiAwKTtcbiAgICAgICAgbGV0IHR5cGUgPSBuZXcgTm9kZVR5cGUoc3BlYy5uYW1lIHx8IFwiXCIsIHByb3BzLCBzcGVjLmlkLCBmbGFncyk7XG4gICAgICAgIGlmIChzcGVjLnByb3BzKVxuICAgICAgICAgICAgZm9yIChsZXQgc3JjIG9mIHNwZWMucHJvcHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc3JjKSlcbiAgICAgICAgICAgICAgICAgICAgc3JjID0gc3JjKHR5cGUpO1xuICAgICAgICAgICAgICAgIGlmIChzcmMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNyY1swXS5wZXJOb2RlKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJDYW4ndCBzdG9yZSBhIHBlci1ub2RlIHByb3Agb24gYSBub2RlIHR5cGVcIik7XG4gICAgICAgICAgICAgICAgICAgIHByb3BzW3NyY1swXS5pZF0gPSBzcmNbMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0cmlldmVzIGEgbm9kZSBwcm9wIGZvciB0aGlzIHR5cGUuIFdpbGwgcmV0dXJuIGB1bmRlZmluZWRgIGlmXG4gICAgdGhlIHByb3AgaXNuJ3QgcHJlc2VudCBvbiB0aGlzIG5vZGUuXG4gICAgKi9cbiAgICBwcm9wKHByb3ApIHsgcmV0dXJuIHRoaXMucHJvcHNbcHJvcC5pZF07IH1cbiAgICAvKipcbiAgICBUcnVlIHdoZW4gdGhpcyBpcyB0aGUgdG9wIG5vZGUgb2YgYSBncmFtbWFyLlxuICAgICovXG4gICAgZ2V0IGlzVG9wKCkgeyByZXR1cm4gKHRoaXMuZmxhZ3MgJiAxIC8qIE5vZGVGbGFnLlRvcCAqLykgPiAwOyB9XG4gICAgLyoqXG4gICAgVHJ1ZSB3aGVuIHRoaXMgbm9kZSBpcyBwcm9kdWNlZCBieSBhIHNraXAgcnVsZS5cbiAgICAqL1xuICAgIGdldCBpc1NraXBwZWQoKSB7IHJldHVybiAodGhpcy5mbGFncyAmIDIgLyogTm9kZUZsYWcuU2tpcHBlZCAqLykgPiAwOyB9XG4gICAgLyoqXG4gICAgSW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBpcyBhbiBlcnJvciBub2RlLlxuICAgICovXG4gICAgZ2V0IGlzRXJyb3IoKSB7IHJldHVybiAodGhpcy5mbGFncyAmIDQgLyogTm9kZUZsYWcuRXJyb3IgKi8pID4gMDsgfVxuICAgIC8qKlxuICAgIFdoZW4gdHJ1ZSwgdGhpcyBub2RlIHR5cGUgZG9lc24ndCBjb3JyZXNwb25kIHRvIGEgdXNlci1kZWNsYXJlZFxuICAgIG5hbWVkIG5vZGUsIGZvciBleGFtcGxlIGJlY2F1c2UgaXQgaXMgdXNlZCB0byBjYWNoZSByZXBldGl0aW9uLlxuICAgICovXG4gICAgZ2V0IGlzQW5vbnltb3VzKCkgeyByZXR1cm4gKHRoaXMuZmxhZ3MgJiA4IC8qIE5vZGVGbGFnLkFub255bW91cyAqLykgPiAwOyB9XG4gICAgLyoqXG4gICAgUmV0dXJucyB0cnVlIHdoZW4gdGhpcyBub2RlJ3MgbmFtZSBvciBvbmUgb2YgaXRzXG4gICAgW2dyb3Vwc10oI2NvbW1vbi5Ob2RlUHJvcF5ncm91cCkgbWF0Y2hlcyB0aGUgZ2l2ZW4gc3RyaW5nLlxuICAgICovXG4gICAgaXMobmFtZSkge1xuICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm5hbWUgPT0gbmFtZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGxldCBncm91cCA9IHRoaXMucHJvcChOb2RlUHJvcC5ncm91cCk7XG4gICAgICAgICAgICByZXR1cm4gZ3JvdXAgPyBncm91cC5pbmRleE9mKG5hbWUpID4gLTEgOiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5pZCA9PSBuYW1lO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBmdW5jdGlvbiBmcm9tIG5vZGUgdHlwZXMgdG8gYXJiaXRyYXJ5IHZhbHVlcyBieVxuICAgIHNwZWNpZnlpbmcgYW4gb2JqZWN0IHdob3NlIHByb3BlcnR5IG5hbWVzIGFyZSBub2RlIG9yXG4gICAgW2dyb3VwXSgjY29tbW9uLk5vZGVQcm9wXmdyb3VwKSBuYW1lcy4gT2Z0ZW4gdXNlZnVsIHdpdGhcbiAgICBbYE5vZGVQcm9wLmFkZGBdKCNjb21tb24uTm9kZVByb3AuYWRkKS4gWW91IGNhbiBwdXQgbXVsdGlwbGVcbiAgICBuYW1lcywgc2VwYXJhdGVkIGJ5IHNwYWNlcywgaW4gYSBzaW5nbGUgcHJvcGVydHkgbmFtZSB0byBtYXBcbiAgICBtdWx0aXBsZSBub2RlIG5hbWVzIHRvIGEgc2luZ2xlIHZhbHVlLlxuICAgICovXG4gICAgc3RhdGljIG1hdGNoKG1hcCkge1xuICAgICAgICBsZXQgZGlyZWN0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZm9yIChsZXQgcHJvcCBpbiBtYXApXG4gICAgICAgICAgICBmb3IgKGxldCBuYW1lIG9mIHByb3Auc3BsaXQoXCIgXCIpKVxuICAgICAgICAgICAgICAgIGRpcmVjdFtuYW1lXSA9IG1hcFtwcm9wXTtcbiAgICAgICAgcmV0dXJuIChub2RlKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGxldCBncm91cHMgPSBub2RlLnByb3AoTm9kZVByb3AuZ3JvdXApLCBpID0gLTE7IGkgPCAoZ3JvdXBzID8gZ3JvdXBzLmxlbmd0aCA6IDApOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgZm91bmQgPSBkaXJlY3RbaSA8IDAgPyBub2RlLm5hbWUgOiBncm91cHNbaV1dO1xuICAgICAgICAgICAgICAgIGlmIChmb3VuZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbn1cbi8qKlxuQW4gZW1wdHkgZHVtbXkgbm9kZSB0eXBlIHRvIHVzZSB3aGVuIG5vIGFjdHVhbCB0eXBlIGlzIGF2YWlsYWJsZS5cbiovXG5Ob2RlVHlwZS5ub25lID0gbmV3IE5vZGVUeXBlKFwiXCIsIE9iamVjdC5jcmVhdGUobnVsbCksIDAsIDggLyogTm9kZUZsYWcuQW5vbnltb3VzICovKTtcbi8qKlxuQSBub2RlIHNldCBob2xkcyBhIGNvbGxlY3Rpb24gb2Ygbm9kZSB0eXBlcy4gSXQgaXMgdXNlZCB0b1xuY29tcGFjdGx5IHJlcHJlc2VudCB0cmVlcyBieSBzdG9yaW5nIHRoZWlyIHR5cGUgaWRzLCByYXRoZXIgdGhhbiBhXG5mdWxsIHBvaW50ZXIgdG8gdGhlIHR5cGUgb2JqZWN0LCBpbiBhIG51bWVyaWMgYXJyYXkuIEVhY2ggcGFyc2VyXG5baGFzXSgjbHIuTFJQYXJzZXIubm9kZVNldCkgYSBub2RlIHNldCwgYW5kIFt0cmVlXG5idWZmZXJzXSgjY29tbW9uLlRyZWVCdWZmZXIpIGNhbiBvbmx5IHN0b3JlIGNvbGxlY3Rpb25zIG9mIG5vZGVzXG5mcm9tIHRoZSBzYW1lIHNldC4gQSBzZXQgY2FuIGhhdmUgYSBtYXhpbXVtIG9mIDIqKjE2ICg2NTUzNikgbm9kZVxudHlwZXMgaW4gaXQsIHNvIHRoYXQgdGhlIGlkcyBmaXQgaW50byAxNi1iaXQgdHlwZWQgYXJyYXkgc2xvdHMuXG4qL1xuY2xhc3MgTm9kZVNldCB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgc2V0IHdpdGggdGhlIGdpdmVuIHR5cGVzLiBUaGUgYGlkYCBwcm9wZXJ0eSBvZiBlYWNoXG4gICAgdHlwZSBzaG91bGQgY29ycmVzcG9uZCB0byBpdHMgcG9zaXRpb24gd2l0aGluIHRoZSBhcnJheS5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBub2RlIHR5cGVzIGluIHRoaXMgc2V0LCBieSBpZC5cbiAgICAqL1xuICAgIHR5cGVzKSB7XG4gICAgICAgIHRoaXMudHlwZXMgPSB0eXBlcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmICh0eXBlc1tpXS5pZCAhPSBpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTm9kZSB0eXBlIGlkcyBzaG91bGQgY29ycmVzcG9uZCB0byBhcnJheSBwb3NpdGlvbnMgd2hlbiBjcmVhdGluZyBhIG5vZGUgc2V0XCIpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBjb3B5IG9mIHRoaXMgc2V0IHdpdGggc29tZSBub2RlIHByb3BlcnRpZXMgYWRkZWQuIFRoZVxuICAgIGFyZ3VtZW50cyB0byB0aGlzIG1ldGhvZCBjYW4gYmUgY3JlYXRlZCB3aXRoXG4gICAgW2BOb2RlUHJvcC5hZGRgXSgjY29tbW9uLk5vZGVQcm9wLmFkZCkuXG4gICAgKi9cbiAgICBleHRlbmQoLi4ucHJvcHMpIHtcbiAgICAgICAgbGV0IG5ld1R5cGVzID0gW107XG4gICAgICAgIGZvciAobGV0IHR5cGUgb2YgdGhpcy50eXBlcykge1xuICAgICAgICAgICAgbGV0IG5ld1Byb3BzID0gbnVsbDtcbiAgICAgICAgICAgIGZvciAobGV0IHNvdXJjZSBvZiBwcm9wcykge1xuICAgICAgICAgICAgICAgIGxldCBhZGQgPSBzb3VyY2UodHlwZSk7XG4gICAgICAgICAgICAgICAgaWYgKGFkZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5ld1Byb3BzKVxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3UHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCB0eXBlLnByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgbmV3UHJvcHNbYWRkWzBdLmlkXSA9IGFkZFsxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdUeXBlcy5wdXNoKG5ld1Byb3BzID8gbmV3IE5vZGVUeXBlKHR5cGUubmFtZSwgbmV3UHJvcHMsIHR5cGUuaWQsIHR5cGUuZmxhZ3MpIDogdHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlU2V0KG5ld1R5cGVzKTtcbiAgICB9XG59XG5jb25zdCBDYWNoZWROb2RlID0gbmV3IFdlYWtNYXAoKSwgQ2FjaGVkSW5uZXJOb2RlID0gbmV3IFdlYWtNYXAoKTtcbi8qKlxuT3B0aW9ucyB0aGF0IGNvbnRyb2wgaXRlcmF0aW9uLiBDYW4gYmUgY29tYmluZWQgd2l0aCB0aGUgYHxgXG5vcGVyYXRvciB0byBlbmFibGUgbXVsdGlwbGUgb25lcy5cbiovXG52YXIgSXRlck1vZGU7XG4oZnVuY3Rpb24gKEl0ZXJNb2RlKSB7XG4gICAgLyoqXG4gICAgV2hlbiBlbmFibGVkLCBpdGVyYXRpb24gd2lsbCBvbmx5IHZpc2l0IFtgVHJlZWBdKCNjb21tb24uVHJlZSlcbiAgICBvYmplY3RzLCBub3Qgbm9kZXMgcGFja2VkIGludG9cbiAgICBbYFRyZWVCdWZmZXJgXSgjY29tbW9uLlRyZWVCdWZmZXIpcy5cbiAgICAqL1xuICAgIEl0ZXJNb2RlW0l0ZXJNb2RlW1wiRXhjbHVkZUJ1ZmZlcnNcIl0gPSAxXSA9IFwiRXhjbHVkZUJ1ZmZlcnNcIjtcbiAgICAvKipcbiAgICBFbmFibGUgdGhpcyB0byBtYWtlIGl0ZXJhdGlvbiBpbmNsdWRlIGFub255bW91cyBub2RlcyAoc3VjaCBhc1xuICAgIHRoZSBub2RlcyB0aGF0IHdyYXAgcmVwZWF0ZWQgZ3JhbW1hciBjb25zdHJ1Y3RzIGludG8gYSBiYWxhbmNlZFxuICAgIHRyZWUpLlxuICAgICovXG4gICAgSXRlck1vZGVbSXRlck1vZGVbXCJJbmNsdWRlQW5vbnltb3VzXCJdID0gMl0gPSBcIkluY2x1ZGVBbm9ueW1vdXNcIjtcbiAgICAvKipcbiAgICBCeSBkZWZhdWx0LCByZWd1bGFyIFttb3VudGVkXSgjY29tbW9uLk5vZGVQcm9wXm1vdW50ZWQpIG5vZGVzXG4gICAgcmVwbGFjZSB0aGVpciBiYXNlIG5vZGUgaW4gaXRlcmF0aW9uLiBFbmFibGUgdGhpcyB0byBpZ25vcmUgdGhlbVxuICAgIGluc3RlYWQuXG4gICAgKi9cbiAgICBJdGVyTW9kZVtJdGVyTW9kZVtcIklnbm9yZU1vdW50c1wiXSA9IDRdID0gXCJJZ25vcmVNb3VudHNcIjtcbiAgICAvKipcbiAgICBUaGlzIG9wdGlvbiBvbmx5IGFwcGxpZXMgaW5cbiAgICBbYGVudGVyYF0oI2NvbW1vbi5TeW50YXhOb2RlLmVudGVyKS1zdHlsZSBtZXRob2RzLiBJdCB0ZWxscyB0aGVcbiAgICBsaWJyYXJ5IHRvIG5vdCBlbnRlciBtb3VudGVkIG92ZXJsYXlzIGlmIG9uZSBjb3ZlcnMgdGhlIGdpdmVuXG4gICAgcG9zaXRpb24uXG4gICAgKi9cbiAgICBJdGVyTW9kZVtJdGVyTW9kZVtcIklnbm9yZU92ZXJsYXlzXCJdID0gOF0gPSBcIklnbm9yZU92ZXJsYXlzXCI7XG59KShJdGVyTW9kZSB8fCAoSXRlck1vZGUgPSB7fSkpO1xuLyoqXG5BIHBpZWNlIG9mIHN5bnRheCB0cmVlLiBUaGVyZSBhcmUgdHdvIHdheXMgdG8gYXBwcm9hY2ggdGhlc2VcbnRyZWVzOiB0aGUgd2F5IHRoZXkgYXJlIGFjdHVhbGx5IHN0b3JlZCBpbiBtZW1vcnksIGFuZCB0aGVcbmNvbnZlbmllbnQgd2F5LlxuXG5TeW50YXggdHJlZXMgYXJlIHN0b3JlZCBhcyBhIHRyZWUgb2YgYFRyZWVgIGFuZCBgVHJlZUJ1ZmZlcmBcbm9iamVjdHMuIEJ5IHBhY2tpbmcgZGV0YWlsIGluZm9ybWF0aW9uIGludG8gYFRyZWVCdWZmZXJgIGxlYWZcbm5vZGVzLCB0aGUgcmVwcmVzZW50YXRpb24gaXMgbWFkZSBhIGxvdCBtb3JlIG1lbW9yeS1lZmZpY2llbnQuXG5cbkhvd2V2ZXIsIHdoZW4geW91IHdhbnQgdG8gYWN0dWFsbHkgd29yayB3aXRoIHRyZWUgbm9kZXMsIHRoaXNcbnJlcHJlc2VudGF0aW9uIGlzIHZlcnkgYXdrd2FyZCwgc28gbW9zdCBjbGllbnQgY29kZSB3aWxsIHdhbnQgdG9cbnVzZSB0aGUgW2BUcmVlQ3Vyc29yYF0oI2NvbW1vbi5UcmVlQ3Vyc29yKSBvclxuW2BTeW50YXhOb2RlYF0oI2NvbW1vbi5TeW50YXhOb2RlKSBpbnRlcmZhY2UgaW5zdGVhZCwgd2hpY2ggcHJvdmlkZXNcbmEgdmlldyBvbiBzb21lIHBhcnQgb2YgdGhpcyBkYXRhIHN0cnVjdHVyZSwgYW5kIGNhbiBiZSB1c2VkIHRvXG5tb3ZlIGFyb3VuZCB0byBhZGphY2VudCBub2Rlcy5cbiovXG5jbGFzcyBUcmVlIHtcbiAgICAvKipcbiAgICBDb25zdHJ1Y3QgYSBuZXcgdHJlZS4gU2VlIGFsc28gW2BUcmVlLmJ1aWxkYF0oI2NvbW1vbi5UcmVlXmJ1aWxkKS5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSB0eXBlIG9mIHRoZSB0b3Agbm9kZS5cbiAgICAqL1xuICAgIHR5cGUsIFxuICAgIC8qKlxuICAgIFRoaXMgbm9kZSdzIGNoaWxkIG5vZGVzLlxuICAgICovXG4gICAgY2hpbGRyZW4sIFxuICAgIC8qKlxuICAgIFRoZSBwb3NpdGlvbnMgKG9mZnNldHMgcmVsYXRpdmUgdG8gdGhlIHN0YXJ0IG9mIHRoaXMgdHJlZSkgb2ZcbiAgICB0aGUgY2hpbGRyZW4uXG4gICAgKi9cbiAgICBwb3NpdGlvbnMsIFxuICAgIC8qKlxuICAgIFRoZSB0b3RhbCBsZW5ndGggb2YgdGhpcyB0cmVlXG4gICAgKi9cbiAgICBsZW5ndGgsIFxuICAgIC8qKlxuICAgIFBlci1ub2RlIFtub2RlIHByb3BzXSgjY29tbW9uLk5vZGVQcm9wKSB0byBhc3NvY2lhdGUgd2l0aCB0aGlzIG5vZGUuXG4gICAgKi9cbiAgICBwcm9wcykge1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIHRoaXMucG9zaXRpb25zID0gcG9zaXRpb25zO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnByb3BzID0gbnVsbDtcbiAgICAgICAgaWYgKHByb3BzICYmIHByb3BzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5wcm9wcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICBmb3IgKGxldCBbcHJvcCwgdmFsdWVdIG9mIHByb3BzKVxuICAgICAgICAgICAgICAgIHRoaXMucHJvcHNbdHlwZW9mIHByb3AgPT0gXCJudW1iZXJcIiA/IHByb3AgOiBwcm9wLmlkXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCBtb3VudGVkID0gTW91bnRlZFRyZWUuZ2V0KHRoaXMpO1xuICAgICAgICBpZiAobW91bnRlZCAmJiAhbW91bnRlZC5vdmVybGF5KVxuICAgICAgICAgICAgcmV0dXJuIG1vdW50ZWQudHJlZS50b1N0cmluZygpO1xuICAgICAgICBsZXQgY2hpbGRyZW4gPSBcIlwiO1xuICAgICAgICBmb3IgKGxldCBjaCBvZiB0aGlzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBsZXQgc3RyID0gY2gudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGlmIChzdHIpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRyZW4pXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuICs9IFwiLFwiO1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuICs9IHN0cjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gIXRoaXMudHlwZS5uYW1lID8gY2hpbGRyZW4gOlxuICAgICAgICAgICAgKC9cXFcvLnRlc3QodGhpcy50eXBlLm5hbWUpICYmICF0aGlzLnR5cGUuaXNFcnJvciA/IEpTT04uc3RyaW5naWZ5KHRoaXMudHlwZS5uYW1lKSA6IHRoaXMudHlwZS5uYW1lKSArXG4gICAgICAgICAgICAgICAgKGNoaWxkcmVuLmxlbmd0aCA/IFwiKFwiICsgY2hpbGRyZW4gKyBcIilcIiA6IFwiXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgYSBbdHJlZSBjdXJzb3JdKCNjb21tb24uVHJlZUN1cnNvcikgcG9zaXRpb25lZCBhdCB0aGUgdG9wIG9mXG4gICAgdGhlIHRyZWUuIE1vZGUgY2FuIGJlIHVzZWQgdG8gW2NvbnRyb2xdKCNjb21tb24uSXRlck1vZGUpIHdoaWNoXG4gICAgbm9kZXMgdGhlIGN1cnNvciB2aXNpdHMuXG4gICAgKi9cbiAgICBjdXJzb3IobW9kZSA9IDApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlQ3Vyc29yKHRoaXMudG9wTm9kZSwgbW9kZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCBhIFt0cmVlIGN1cnNvcl0oI2NvbW1vbi5UcmVlQ3Vyc29yKSBwb2ludGluZyBpbnRvIHRoaXMgdHJlZVxuICAgIGF0IHRoZSBnaXZlbiBwb3NpdGlvbiBhbmQgc2lkZSAoc2VlXG4gICAgW2Btb3ZlVG9gXSgjY29tbW9uLlRyZWVDdXJzb3IubW92ZVRvKS5cbiAgICAqL1xuICAgIGN1cnNvckF0KHBvcywgc2lkZSA9IDAsIG1vZGUgPSAwKSB7XG4gICAgICAgIGxldCBzY29wZSA9IENhY2hlZE5vZGUuZ2V0KHRoaXMpIHx8IHRoaXMudG9wTm9kZTtcbiAgICAgICAgbGV0IGN1cnNvciA9IG5ldyBUcmVlQ3Vyc29yKHNjb3BlKTtcbiAgICAgICAgY3Vyc29yLm1vdmVUbyhwb3MsIHNpZGUpO1xuICAgICAgICBDYWNoZWROb2RlLnNldCh0aGlzLCBjdXJzb3IuX3RyZWUpO1xuICAgICAgICByZXR1cm4gY3Vyc29yO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgYSBbc3ludGF4IG5vZGVdKCNjb21tb24uU3ludGF4Tm9kZSkgb2JqZWN0IGZvciB0aGUgdG9wIG9mIHRoZVxuICAgIHRyZWUuXG4gICAgKi9cbiAgICBnZXQgdG9wTm9kZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlTm9kZSh0aGlzLCAwLCAwLCBudWxsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBbc3ludGF4IG5vZGVdKCNjb21tb24uU3ludGF4Tm9kZSkgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLlxuICAgIElmIGBzaWRlYCBpcyAtMSwgdGhpcyB3aWxsIG1vdmUgaW50byBub2RlcyB0aGF0IGVuZCBhdCB0aGVcbiAgICBwb3NpdGlvbi4gSWYgMSwgaXQnbGwgbW92ZSBpbnRvIG5vZGVzIHRoYXQgc3RhcnQgYXQgdGhlXG4gICAgcG9zaXRpb24uIFdpdGggMCwgaXQnbGwgb25seSBlbnRlciBub2RlcyB0aGF0IGNvdmVyIHRoZSBwb3NpdGlvblxuICAgIGZyb20gYm90aCBzaWRlcy5cbiAgICBcbiAgICBOb3RlIHRoYXQgdGhpcyB3aWxsIG5vdCBlbnRlclxuICAgIFtvdmVybGF5c10oI2NvbW1vbi5Nb3VudGVkVHJlZS5vdmVybGF5KSwgYW5kIHlvdSBvZnRlbiB3YW50XG4gICAgW2ByZXNvbHZlSW5uZXJgXSgjY29tbW9uLlRyZWUucmVzb2x2ZUlubmVyKSBpbnN0ZWFkLlxuICAgICovXG4gICAgcmVzb2x2ZShwb3MsIHNpZGUgPSAwKSB7XG4gICAgICAgIGxldCBub2RlID0gcmVzb2x2ZU5vZGUoQ2FjaGVkTm9kZS5nZXQodGhpcykgfHwgdGhpcy50b3BOb2RlLCBwb3MsIHNpZGUsIGZhbHNlKTtcbiAgICAgICAgQ2FjaGVkTm9kZS5zZXQodGhpcywgbm9kZSk7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICAvKipcbiAgICBMaWtlIFtgcmVzb2x2ZWBdKCNjb21tb24uVHJlZS5yZXNvbHZlKSwgYnV0IHdpbGwgZW50ZXJcbiAgICBbb3ZlcmxhaWRdKCNjb21tb24uTW91bnRlZFRyZWUub3ZlcmxheSkgbm9kZXMsIHByb2R1Y2luZyBhIHN5bnRheCBub2RlXG4gICAgcG9pbnRpbmcgaW50byB0aGUgaW5uZXJtb3N0IG92ZXJsYWlkIHRyZWUgYXQgdGhlIGdpdmVuIHBvc2l0aW9uXG4gICAgKHdpdGggcGFyZW50IGxpbmtzIGdvaW5nIHRocm91Z2ggYWxsIHBhcmVudCBzdHJ1Y3R1cmUsIGluY2x1ZGluZ1xuICAgIHRoZSBob3N0IHRyZWVzKS5cbiAgICAqL1xuICAgIHJlc29sdmVJbm5lcihwb3MsIHNpZGUgPSAwKSB7XG4gICAgICAgIGxldCBub2RlID0gcmVzb2x2ZU5vZGUoQ2FjaGVkSW5uZXJOb2RlLmdldCh0aGlzKSB8fCB0aGlzLnRvcE5vZGUsIHBvcywgc2lkZSwgdHJ1ZSk7XG4gICAgICAgIENhY2hlZElubmVyTm9kZS5zZXQodGhpcywgbm9kZSk7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICAvKipcbiAgICBJbiBzb21lIHNpdHVhdGlvbnMsIGl0IGNhbiBiZSB1c2VmdWwgdG8gaXRlcmF0ZSB0aHJvdWdoIGFsbFxuICAgIG5vZGVzIGFyb3VuZCBhIHBvc2l0aW9uLCBpbmNsdWRpbmcgdGhvc2UgaW4gb3ZlcmxheXMgdGhhdCBkb24ndFxuICAgIGRpcmVjdGx5IGNvdmVyIHRoZSBwb3NpdGlvbi4gVGhpcyBtZXRob2QgZ2l2ZXMgeW91IGFuIGl0ZXJhdG9yXG4gICAgdGhhdCB3aWxsIHByb2R1Y2UgYWxsIG5vZGVzLCBmcm9tIHNtYWxsIHRvIGJpZywgYXJvdW5kIHRoZSBnaXZlblxuICAgIHBvc2l0aW9uLlxuICAgICovXG4gICAgcmVzb2x2ZVN0YWNrKHBvcywgc2lkZSA9IDApIHtcbiAgICAgICAgcmV0dXJuIHN0YWNrSXRlcmF0b3IodGhpcywgcG9zLCBzaWRlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgSXRlcmF0ZSBvdmVyIHRoZSB0cmVlIGFuZCBpdHMgY2hpbGRyZW4sIGNhbGxpbmcgYGVudGVyYCBmb3IgYW55XG4gICAgbm9kZSB0aGF0IHRvdWNoZXMgdGhlIGBmcm9tYC9gdG9gIHJlZ2lvbiAoaWYgZ2l2ZW4pIGJlZm9yZVxuICAgIHJ1bm5pbmcgb3ZlciBzdWNoIGEgbm9kZSdzIGNoaWxkcmVuLCBhbmQgYGxlYXZlYCAoaWYgZ2l2ZW4pIHdoZW5cbiAgICBsZWF2aW5nIHRoZSBub2RlLiBXaGVuIGBlbnRlcmAgcmV0dXJucyBgZmFsc2VgLCB0aGF0IG5vZGUgd2lsbFxuICAgIG5vdCBoYXZlIGl0cyBjaGlsZHJlbiBpdGVyYXRlZCBvdmVyIChvciBgbGVhdmVgIGNhbGxlZCkuXG4gICAgKi9cbiAgICBpdGVyYXRlKHNwZWMpIHtcbiAgICAgICAgbGV0IHsgZW50ZXIsIGxlYXZlLCBmcm9tID0gMCwgdG8gPSB0aGlzLmxlbmd0aCB9ID0gc3BlYztcbiAgICAgICAgbGV0IG1vZGUgPSBzcGVjLm1vZGUgfHwgMCwgYW5vbiA9IChtb2RlICYgSXRlck1vZGUuSW5jbHVkZUFub255bW91cykgPiAwO1xuICAgICAgICBmb3IgKGxldCBjID0gdGhpcy5jdXJzb3IobW9kZSB8IEl0ZXJNb2RlLkluY2x1ZGVBbm9ueW1vdXMpOzspIHtcbiAgICAgICAgICAgIGxldCBlbnRlcmVkID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoYy5mcm9tIDw9IHRvICYmIGMudG8gPj0gZnJvbSAmJiAoIWFub24gJiYgYy50eXBlLmlzQW5vbnltb3VzIHx8IGVudGVyKGMpICE9PSBmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoYy5maXJzdENoaWxkKCkpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGVudGVyZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgIGlmIChlbnRlcmVkICYmIGxlYXZlICYmIChhbm9uIHx8ICFjLnR5cGUuaXNBbm9ueW1vdXMpKVxuICAgICAgICAgICAgICAgICAgICBsZWF2ZShjKTtcbiAgICAgICAgICAgICAgICBpZiAoYy5uZXh0U2libGluZygpKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAoIWMucGFyZW50KCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBlbnRlcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIHZhbHVlIG9mIHRoZSBnaXZlbiBbbm9kZSBwcm9wXSgjY29tbW9uLk5vZGVQcm9wKSBmb3IgdGhpc1xuICAgIG5vZGUuIFdvcmtzIHdpdGggYm90aCBwZXItbm9kZSBhbmQgcGVyLXR5cGUgcHJvcHMuXG4gICAgKi9cbiAgICBwcm9wKHByb3ApIHtcbiAgICAgICAgcmV0dXJuICFwcm9wLnBlck5vZGUgPyB0aGlzLnR5cGUucHJvcChwcm9wKSA6IHRoaXMucHJvcHMgPyB0aGlzLnByb3BzW3Byb3AuaWRdIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIHRoZSBub2RlJ3MgW3Blci1ub2RlIHByb3BzXSgjY29tbW9uLk5vZGVQcm9wLnBlck5vZGUpIGluIGFcbiAgICBmb3JtYXQgdGhhdCBjYW4gYmUgcGFzc2VkIHRvIHRoZSBbYFRyZWVgXSgjY29tbW9uLlRyZWUpXG4gICAgY29uc3RydWN0b3IuXG4gICAgKi9cbiAgICBnZXQgcHJvcFZhbHVlcygpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBpZiAodGhpcy5wcm9wcylcbiAgICAgICAgICAgIGZvciAobGV0IGlkIGluIHRoaXMucHJvcHMpXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goWytpZCwgdGhpcy5wcm9wc1tpZF1dKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgQmFsYW5jZSB0aGUgZGlyZWN0IGNoaWxkcmVuIG9mIHRoaXMgdHJlZSwgcHJvZHVjaW5nIGEgY29weSBvZlxuICAgIHdoaWNoIG1heSBoYXZlIGNoaWxkcmVuIGdyb3VwZWQgaW50byBzdWJ0cmVlcyB3aXRoIHR5cGVcbiAgICBbYE5vZGVUeXBlLm5vbmVgXSgjY29tbW9uLk5vZGVUeXBlXm5vbmUpLlxuICAgICovXG4gICAgYmFsYW5jZShjb25maWcgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5sZW5ndGggPD0gOCAvKiBCYWxhbmNlLkJyYW5jaEZhY3RvciAqLyA/IHRoaXMgOlxuICAgICAgICAgICAgYmFsYW5jZVJhbmdlKE5vZGVUeXBlLm5vbmUsIHRoaXMuY2hpbGRyZW4sIHRoaXMucG9zaXRpb25zLCAwLCB0aGlzLmNoaWxkcmVuLmxlbmd0aCwgMCwgdGhpcy5sZW5ndGgsIChjaGlsZHJlbiwgcG9zaXRpb25zLCBsZW5ndGgpID0+IG5ldyBUcmVlKHRoaXMudHlwZSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgbGVuZ3RoLCB0aGlzLnByb3BWYWx1ZXMpLCBjb25maWcubWFrZVRyZWUgfHwgKChjaGlsZHJlbiwgcG9zaXRpb25zLCBsZW5ndGgpID0+IG5ldyBUcmVlKE5vZGVUeXBlLm5vbmUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGxlbmd0aCkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQnVpbGQgYSB0cmVlIGZyb20gYSBwb3N0Zml4LW9yZGVyZWQgYnVmZmVyIG9mIG5vZGUgaW5mb3JtYXRpb24sXG4gICAgb3IgYSBjdXJzb3Igb3ZlciBzdWNoIGEgYnVmZmVyLlxuICAgICovXG4gICAgc3RhdGljIGJ1aWxkKGRhdGEpIHsgcmV0dXJuIGJ1aWxkVHJlZShkYXRhKTsgfVxufVxuLyoqXG5UaGUgZW1wdHkgdHJlZVxuKi9cblRyZWUuZW1wdHkgPSBuZXcgVHJlZShOb2RlVHlwZS5ub25lLCBbXSwgW10sIDApO1xuY2xhc3MgRmxhdEJ1ZmZlckN1cnNvciB7XG4gICAgY29uc3RydWN0b3IoYnVmZmVyLCBpbmRleCkge1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgIH1cbiAgICBnZXQgaWQoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gNF07IH1cbiAgICBnZXQgc3RhcnQoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gM107IH1cbiAgICBnZXQgZW5kKCkgeyByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCAtIDJdOyB9XG4gICAgZ2V0IHNpemUoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gMV07IH1cbiAgICBnZXQgcG9zKCkgeyByZXR1cm4gdGhpcy5pbmRleDsgfVxuICAgIG5leHQoKSB7IHRoaXMuaW5kZXggLT0gNDsgfVxuICAgIGZvcmsoKSB7IHJldHVybiBuZXcgRmxhdEJ1ZmZlckN1cnNvcih0aGlzLmJ1ZmZlciwgdGhpcy5pbmRleCk7IH1cbn1cbi8qKlxuVHJlZSBidWZmZXJzIGNvbnRhaW4gKHR5cGUsIHN0YXJ0LCBlbmQsIGVuZEluZGV4KSBxdWFkcyBmb3IgZWFjaFxubm9kZS4gSW4gc3VjaCBhIGJ1ZmZlciwgbm9kZXMgYXJlIHN0b3JlZCBpbiBwcmVmaXggb3JkZXIgKHBhcmVudHNcbmJlZm9yZSBjaGlsZHJlbiwgd2l0aCB0aGUgZW5kSW5kZXggb2YgdGhlIHBhcmVudCBpbmRpY2F0aW5nIHdoaWNoXG5jaGlsZHJlbiBiZWxvbmcgdG8gaXQpLlxuKi9cbmNsYXNzIFRyZWVCdWZmZXIge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIHRyZWUgYnVmZmVyLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIGJ1ZmZlcidzIGNvbnRlbnQuXG4gICAgKi9cbiAgICBidWZmZXIsIFxuICAgIC8qKlxuICAgIFRoZSB0b3RhbCBsZW5ndGggb2YgdGhlIGdyb3VwIG9mIG5vZGVzIGluIHRoZSBidWZmZXIuXG4gICAgKi9cbiAgICBsZW5ndGgsIFxuICAgIC8qKlxuICAgIFRoZSBub2RlIHNldCB1c2VkIGluIHRoaXMgYnVmZmVyLlxuICAgICovXG4gICAgc2V0KSB7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdGhpcy5zZXQgPSBzZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZ2V0IHR5cGUoKSB7IHJldHVybiBOb2RlVHlwZS5ub25lOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5idWZmZXIubGVuZ3RoOykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5jaGlsZFN0cmluZyhpbmRleCkpO1xuICAgICAgICAgICAgaW5kZXggPSB0aGlzLmJ1ZmZlcltpbmRleCArIDNdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQuam9pbihcIixcIik7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY2hpbGRTdHJpbmcoaW5kZXgpIHtcbiAgICAgICAgbGV0IGlkID0gdGhpcy5idWZmZXJbaW5kZXhdLCBlbmRJbmRleCA9IHRoaXMuYnVmZmVyW2luZGV4ICsgM107XG4gICAgICAgIGxldCB0eXBlID0gdGhpcy5zZXQudHlwZXNbaWRdLCByZXN1bHQgPSB0eXBlLm5hbWU7XG4gICAgICAgIGlmICgvXFxXLy50ZXN0KHJlc3VsdCkgJiYgIXR5cGUuaXNFcnJvcilcbiAgICAgICAgICAgIHJlc3VsdCA9IEpTT04uc3RyaW5naWZ5KHJlc3VsdCk7XG4gICAgICAgIGluZGV4ICs9IDQ7XG4gICAgICAgIGlmIChlbmRJbmRleCA9PSBpbmRleClcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IFtdO1xuICAgICAgICB3aGlsZSAoaW5kZXggPCBlbmRJbmRleCkge1xuICAgICAgICAgICAgY2hpbGRyZW4ucHVzaCh0aGlzLmNoaWxkU3RyaW5nKGluZGV4KSk7XG4gICAgICAgICAgICBpbmRleCA9IHRoaXMuYnVmZmVyW2luZGV4ICsgM107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdCArIFwiKFwiICsgY2hpbGRyZW4uam9pbihcIixcIikgKyBcIilcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBmaW5kQ2hpbGQoc3RhcnRJbmRleCwgZW5kSW5kZXgsIGRpciwgcG9zLCBzaWRlKSB7XG4gICAgICAgIGxldCB7IGJ1ZmZlciB9ID0gdGhpcywgcGljayA9IC0xO1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnRJbmRleDsgaSAhPSBlbmRJbmRleDsgaSA9IGJ1ZmZlcltpICsgM10pIHtcbiAgICAgICAgICAgIGlmIChjaGVja1NpZGUoc2lkZSwgcG9zLCBidWZmZXJbaSArIDFdLCBidWZmZXJbaSArIDJdKSkge1xuICAgICAgICAgICAgICAgIHBpY2sgPSBpO1xuICAgICAgICAgICAgICAgIGlmIChkaXIgPiAwKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGljaztcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzbGljZShzdGFydEksIGVuZEksIGZyb20pIHtcbiAgICAgICAgbGV0IGIgPSB0aGlzLmJ1ZmZlcjtcbiAgICAgICAgbGV0IGNvcHkgPSBuZXcgVWludDE2QXJyYXkoZW5kSSAtIHN0YXJ0SSksIGxlbiA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydEksIGogPSAwOyBpIDwgZW5kSTspIHtcbiAgICAgICAgICAgIGNvcHlbaisrXSA9IGJbaSsrXTtcbiAgICAgICAgICAgIGNvcHlbaisrXSA9IGJbaSsrXSAtIGZyb207XG4gICAgICAgICAgICBsZXQgdG8gPSBjb3B5W2orK10gPSBiW2krK10gLSBmcm9tO1xuICAgICAgICAgICAgY29weVtqKytdID0gYltpKytdIC0gc3RhcnRJO1xuICAgICAgICAgICAgbGVuID0gTWF0aC5tYXgobGVuLCB0byk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlQnVmZmVyKGNvcHksIGxlbiwgdGhpcy5zZXQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNoZWNrU2lkZShzaWRlLCBwb3MsIGZyb20sIHRvKSB7XG4gICAgc3dpdGNoIChzaWRlKSB7XG4gICAgICAgIGNhc2UgLTIgLyogU2lkZS5CZWZvcmUgKi86IHJldHVybiBmcm9tIDwgcG9zO1xuICAgICAgICBjYXNlIC0xIC8qIFNpZGUuQXRPckJlZm9yZSAqLzogcmV0dXJuIHRvID49IHBvcyAmJiBmcm9tIDwgcG9zO1xuICAgICAgICBjYXNlIDAgLyogU2lkZS5Bcm91bmQgKi86IHJldHVybiBmcm9tIDwgcG9zICYmIHRvID4gcG9zO1xuICAgICAgICBjYXNlIDEgLyogU2lkZS5BdE9yQWZ0ZXIgKi86IHJldHVybiBmcm9tIDw9IHBvcyAmJiB0byA+IHBvcztcbiAgICAgICAgY2FzZSAyIC8qIFNpZGUuQWZ0ZXIgKi86IHJldHVybiB0byA+IHBvcztcbiAgICAgICAgY2FzZSA0IC8qIFNpZGUuRG9udENhcmUgKi86IHJldHVybiB0cnVlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlc29sdmVOb2RlKG5vZGUsIHBvcywgc2lkZSwgb3ZlcmxheXMpIHtcbiAgICB2YXIgX2E7XG4gICAgLy8gTW92ZSB1cCB0byBhIG5vZGUgdGhhdCBhY3R1YWxseSBob2xkcyB0aGUgcG9zaXRpb24sIGlmIHBvc3NpYmxlXG4gICAgd2hpbGUgKG5vZGUuZnJvbSA9PSBub2RlLnRvIHx8XG4gICAgICAgIChzaWRlIDwgMSA/IG5vZGUuZnJvbSA+PSBwb3MgOiBub2RlLmZyb20gPiBwb3MpIHx8XG4gICAgICAgIChzaWRlID4gLTEgPyBub2RlLnRvIDw9IHBvcyA6IG5vZGUudG8gPCBwb3MpKSB7XG4gICAgICAgIGxldCBwYXJlbnQgPSAhb3ZlcmxheXMgJiYgbm9kZSBpbnN0YW5jZW9mIFRyZWVOb2RlICYmIG5vZGUuaW5kZXggPCAwID8gbnVsbCA6IG5vZGUucGFyZW50O1xuICAgICAgICBpZiAoIXBhcmVudClcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICBub2RlID0gcGFyZW50O1xuICAgIH1cbiAgICBsZXQgbW9kZSA9IG92ZXJsYXlzID8gMCA6IEl0ZXJNb2RlLklnbm9yZU92ZXJsYXlzO1xuICAgIC8vIE11c3QgZ28gdXAgb3V0IG9mIG92ZXJsYXlzIHdoZW4gdGhvc2UgZG8gbm90IG92ZXJsYXAgd2l0aCBwb3NcbiAgICBpZiAob3ZlcmxheXMpXG4gICAgICAgIGZvciAobGV0IHNjYW4gPSBub2RlLCBwYXJlbnQgPSBzY2FuLnBhcmVudDsgcGFyZW50OyBzY2FuID0gcGFyZW50LCBwYXJlbnQgPSBzY2FuLnBhcmVudCkge1xuICAgICAgICAgICAgaWYgKHNjYW4gaW5zdGFuY2VvZiBUcmVlTm9kZSAmJiBzY2FuLmluZGV4IDwgMCAmJiAoKF9hID0gcGFyZW50LmVudGVyKHBvcywgc2lkZSwgbW9kZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mcm9tKSAhPSBzY2FuLmZyb20pXG4gICAgICAgICAgICAgICAgbm9kZSA9IHBhcmVudDtcbiAgICAgICAgfVxuICAgIGZvciAoOzspIHtcbiAgICAgICAgbGV0IGlubmVyID0gbm9kZS5lbnRlcihwb3MsIHNpZGUsIG1vZGUpO1xuICAgICAgICBpZiAoIWlubmVyKVxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIG5vZGUgPSBpbm5lcjtcbiAgICB9XG59XG5jbGFzcyBCYXNlTm9kZSB7XG4gICAgY3Vyc29yKG1vZGUgPSAwKSB7IHJldHVybiBuZXcgVHJlZUN1cnNvcih0aGlzLCBtb2RlKTsgfVxuICAgIGdldENoaWxkKHR5cGUsIGJlZm9yZSA9IG51bGwsIGFmdGVyID0gbnVsbCkge1xuICAgICAgICBsZXQgciA9IGdldENoaWxkcmVuKHRoaXMsIHR5cGUsIGJlZm9yZSwgYWZ0ZXIpO1xuICAgICAgICByZXR1cm4gci5sZW5ndGggPyByWzBdIDogbnVsbDtcbiAgICB9XG4gICAgZ2V0Q2hpbGRyZW4odHlwZSwgYmVmb3JlID0gbnVsbCwgYWZ0ZXIgPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBnZXRDaGlsZHJlbih0aGlzLCB0eXBlLCBiZWZvcmUsIGFmdGVyKTtcbiAgICB9XG4gICAgcmVzb2x2ZShwb3MsIHNpZGUgPSAwKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlTm9kZSh0aGlzLCBwb3MsIHNpZGUsIGZhbHNlKTtcbiAgICB9XG4gICAgcmVzb2x2ZUlubmVyKHBvcywgc2lkZSA9IDApIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVOb2RlKHRoaXMsIHBvcywgc2lkZSwgdHJ1ZSk7XG4gICAgfVxuICAgIG1hdGNoQ29udGV4dChjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBtYXRjaE5vZGVDb250ZXh0KHRoaXMsIGNvbnRleHQpO1xuICAgIH1cbiAgICBlbnRlclVuZmluaXNoZWROb2Rlc0JlZm9yZShwb3MpIHtcbiAgICAgICAgbGV0IHNjYW4gPSB0aGlzLmNoaWxkQmVmb3JlKHBvcyksIG5vZGUgPSB0aGlzO1xuICAgICAgICB3aGlsZSAoc2Nhbikge1xuICAgICAgICAgICAgbGV0IGxhc3QgPSBzY2FuLmxhc3RDaGlsZDtcbiAgICAgICAgICAgIGlmICghbGFzdCB8fCBsYXN0LnRvICE9IHNjYW4udG8pXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpZiAobGFzdC50eXBlLmlzRXJyb3IgJiYgbGFzdC5mcm9tID09IGxhc3QudG8pIHtcbiAgICAgICAgICAgICAgICBub2RlID0gc2NhbjtcbiAgICAgICAgICAgICAgICBzY2FuID0gbGFzdC5wcmV2U2libGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNjYW4gPSBsYXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICBnZXQgbm9kZSgpIHsgcmV0dXJuIHRoaXM7IH1cbiAgICBnZXQgbmV4dCgpIHsgcmV0dXJuIHRoaXMucGFyZW50OyB9XG59XG5jbGFzcyBUcmVlTm9kZSBleHRlbmRzIEJhc2VOb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihfdHJlZSwgZnJvbSwgXG4gICAgLy8gSW5kZXggaW4gcGFyZW50IG5vZGUsIHNldCB0byAtMSBpZiB0aGUgbm9kZSBpcyBub3QgYSBkaXJlY3QgY2hpbGQgb2YgX3BhcmVudC5ub2RlIChvdmVybGF5KVxuICAgIGluZGV4LCBfcGFyZW50KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX3RyZWUgPSBfdHJlZTtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLl9wYXJlbnQgPSBfcGFyZW50O1xuICAgIH1cbiAgICBnZXQgdHlwZSgpIHsgcmV0dXJuIHRoaXMuX3RyZWUudHlwZTsgfVxuICAgIGdldCBuYW1lKCkgeyByZXR1cm4gdGhpcy5fdHJlZS50eXBlLm5hbWU7IH1cbiAgICBnZXQgdG8oKSB7IHJldHVybiB0aGlzLmZyb20gKyB0aGlzLl90cmVlLmxlbmd0aDsgfVxuICAgIG5leHRDaGlsZChpLCBkaXIsIHBvcywgc2lkZSwgbW9kZSA9IDApIHtcbiAgICAgICAgZm9yIChsZXQgcGFyZW50ID0gdGhpczs7KSB7XG4gICAgICAgICAgICBmb3IgKGxldCB7IGNoaWxkcmVuLCBwb3NpdGlvbnMgfSA9IHBhcmVudC5fdHJlZSwgZSA9IGRpciA+IDAgPyBjaGlsZHJlbi5sZW5ndGggOiAtMTsgaSAhPSBlOyBpICs9IGRpcikge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gY2hpbGRyZW5baV0sIHN0YXJ0ID0gcG9zaXRpb25zW2ldICsgcGFyZW50LmZyb207XG4gICAgICAgICAgICAgICAgaWYgKCFjaGVja1NpZGUoc2lkZSwgcG9zLCBzdGFydCwgc3RhcnQgKyBuZXh0Lmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0IGluc3RhbmNlb2YgVHJlZUJ1ZmZlcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAobW9kZSAmIEl0ZXJNb2RlLkV4Y2x1ZGVCdWZmZXJzKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpbmRleCA9IG5leHQuZmluZENoaWxkKDAsIG5leHQuYnVmZmVyLmxlbmd0aCwgZGlyLCBwb3MgLSBzdGFydCwgc2lkZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXJOb2RlKG5ldyBCdWZmZXJDb250ZXh0KHBhcmVudCwgbmV4dCwgaSwgc3RhcnQpLCBudWxsLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChtb2RlICYgSXRlck1vZGUuSW5jbHVkZUFub255bW91cykgfHwgKCFuZXh0LnR5cGUuaXNBbm9ueW1vdXMgfHwgaGFzQ2hpbGQobmV4dCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBtb3VudGVkO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShtb2RlICYgSXRlck1vZGUuSWdub3JlTW91bnRzKSAmJiAobW91bnRlZCA9IE1vdW50ZWRUcmVlLmdldChuZXh0KSkgJiYgIW1vdW50ZWQub3ZlcmxheSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVHJlZU5vZGUobW91bnRlZC50cmVlLCBzdGFydCwgaSwgcGFyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGlubmVyID0gbmV3IFRyZWVOb2RlKG5leHQsIHN0YXJ0LCBpLCBwYXJlbnQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKG1vZGUgJiBJdGVyTW9kZS5JbmNsdWRlQW5vbnltb3VzKSB8fCAhaW5uZXIudHlwZS5pc0Fub255bW91cyA/IGlubmVyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGlubmVyLm5leHRDaGlsZChkaXIgPCAwID8gbmV4dC5jaGlsZHJlbi5sZW5ndGggLSAxIDogMCwgZGlyLCBwb3MsIHNpZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgobW9kZSAmIEl0ZXJNb2RlLkluY2x1ZGVBbm9ueW1vdXMpIHx8ICFwYXJlbnQudHlwZS5pc0Fub255bW91cylcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGlmIChwYXJlbnQuaW5kZXggPj0gMClcbiAgICAgICAgICAgICAgICBpID0gcGFyZW50LmluZGV4ICsgZGlyO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGkgPSBkaXIgPCAwID8gLTEgOiBwYXJlbnQuX3BhcmVudC5fdHJlZS5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQuX3BhcmVudDtcbiAgICAgICAgICAgIGlmICghcGFyZW50KVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBmaXJzdENoaWxkKCkgeyByZXR1cm4gdGhpcy5uZXh0Q2hpbGQoMCwgMSwgMCwgNCAvKiBTaWRlLkRvbnRDYXJlICovKTsgfVxuICAgIGdldCBsYXN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLm5leHRDaGlsZCh0aGlzLl90cmVlLmNoaWxkcmVuLmxlbmd0aCAtIDEsIC0xLCAwLCA0IC8qIFNpZGUuRG9udENhcmUgKi8pOyB9XG4gICAgY2hpbGRBZnRlcihwb3MpIHsgcmV0dXJuIHRoaXMubmV4dENoaWxkKDAsIDEsIHBvcywgMiAvKiBTaWRlLkFmdGVyICovKTsgfVxuICAgIGNoaWxkQmVmb3JlKHBvcykgeyByZXR1cm4gdGhpcy5uZXh0Q2hpbGQodGhpcy5fdHJlZS5jaGlsZHJlbi5sZW5ndGggLSAxLCAtMSwgcG9zLCAtMiAvKiBTaWRlLkJlZm9yZSAqLyk7IH1cbiAgICBlbnRlcihwb3MsIHNpZGUsIG1vZGUgPSAwKSB7XG4gICAgICAgIGxldCBtb3VudGVkO1xuICAgICAgICBpZiAoIShtb2RlICYgSXRlck1vZGUuSWdub3JlT3ZlcmxheXMpICYmIChtb3VudGVkID0gTW91bnRlZFRyZWUuZ2V0KHRoaXMuX3RyZWUpKSAmJiBtb3VudGVkLm92ZXJsYXkpIHtcbiAgICAgICAgICAgIGxldCByUG9zID0gcG9zIC0gdGhpcy5mcm9tO1xuICAgICAgICAgICAgZm9yIChsZXQgeyBmcm9tLCB0byB9IG9mIG1vdW50ZWQub3ZlcmxheSkge1xuICAgICAgICAgICAgICAgIGlmICgoc2lkZSA+IDAgPyBmcm9tIDw9IHJQb3MgOiBmcm9tIDwgclBvcykgJiZcbiAgICAgICAgICAgICAgICAgICAgKHNpZGUgPCAwID8gdG8gPj0gclBvcyA6IHRvID4gclBvcykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVHJlZU5vZGUobW91bnRlZC50cmVlLCBtb3VudGVkLm92ZXJsYXlbMF0uZnJvbSArIHRoaXMuZnJvbSwgLTEsIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm5leHRDaGlsZCgwLCAxLCBwb3MsIHNpZGUsIG1vZGUpO1xuICAgIH1cbiAgICBuZXh0U2lnbmlmaWNhbnRQYXJlbnQoKSB7XG4gICAgICAgIGxldCB2YWwgPSB0aGlzO1xuICAgICAgICB3aGlsZSAodmFsLnR5cGUuaXNBbm9ueW1vdXMgJiYgdmFsLl9wYXJlbnQpXG4gICAgICAgICAgICB2YWwgPSB2YWwuX3BhcmVudDtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gICAgZ2V0IHBhcmVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCA/IHRoaXMuX3BhcmVudC5uZXh0U2lnbmlmaWNhbnRQYXJlbnQoKSA6IG51bGw7XG4gICAgfVxuICAgIGdldCBuZXh0U2libGluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCAmJiB0aGlzLmluZGV4ID49IDAgPyB0aGlzLl9wYXJlbnQubmV4dENoaWxkKHRoaXMuaW5kZXggKyAxLCAxLCAwLCA0IC8qIFNpZGUuRG9udENhcmUgKi8pIDogbnVsbDtcbiAgICB9XG4gICAgZ2V0IHByZXZTaWJsaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50ICYmIHRoaXMuaW5kZXggPj0gMCA/IHRoaXMuX3BhcmVudC5uZXh0Q2hpbGQodGhpcy5pbmRleCAtIDEsIC0xLCAwLCA0IC8qIFNpZGUuRG9udENhcmUgKi8pIDogbnVsbDtcbiAgICB9XG4gICAgZ2V0IHRyZWUoKSB7IHJldHVybiB0aGlzLl90cmVlOyB9XG4gICAgdG9UcmVlKCkgeyByZXR1cm4gdGhpcy5fdHJlZTsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdG9TdHJpbmcoKSB7IHJldHVybiB0aGlzLl90cmVlLnRvU3RyaW5nKCk7IH1cbn1cbmZ1bmN0aW9uIGdldENoaWxkcmVuKG5vZGUsIHR5cGUsIGJlZm9yZSwgYWZ0ZXIpIHtcbiAgICBsZXQgY3VyID0gbm9kZS5jdXJzb3IoKSwgcmVzdWx0ID0gW107XG4gICAgaWYgKCFjdXIuZmlyc3RDaGlsZCgpKVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIGlmIChiZWZvcmUgIT0gbnVsbClcbiAgICAgICAgd2hpbGUgKCFjdXIudHlwZS5pcyhiZWZvcmUpKVxuICAgICAgICAgICAgaWYgKCFjdXIubmV4dFNpYmxpbmcoKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgaWYgKGFmdGVyICE9IG51bGwgJiYgY3VyLnR5cGUuaXMoYWZ0ZXIpKVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgaWYgKGN1ci50eXBlLmlzKHR5cGUpKVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goY3VyLm5vZGUpO1xuICAgICAgICBpZiAoIWN1ci5uZXh0U2libGluZygpKVxuICAgICAgICAgICAgcmV0dXJuIGFmdGVyID09IG51bGwgPyByZXN1bHQgOiBbXTtcbiAgICB9XG59XG5mdW5jdGlvbiBtYXRjaE5vZGVDb250ZXh0KG5vZGUsIGNvbnRleHQsIGkgPSBjb250ZXh0Lmxlbmd0aCAtIDEpIHtcbiAgICBmb3IgKGxldCBwID0gbm9kZS5wYXJlbnQ7IGkgPj0gMDsgcCA9IHAucGFyZW50KSB7XG4gICAgICAgIGlmICghcClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKCFwLnR5cGUuaXNBbm9ueW1vdXMpIHtcbiAgICAgICAgICAgIGlmIChjb250ZXh0W2ldICYmIGNvbnRleHRbaV0gIT0gcC5uYW1lKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmNsYXNzIEJ1ZmZlckNvbnRleHQge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudCwgYnVmZmVyLCBpbmRleCwgc3RhcnQpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcbiAgICB9XG59XG5jbGFzcyBCdWZmZXJOb2RlIGV4dGVuZHMgQmFzZU5vZGUge1xuICAgIGdldCBuYW1lKCkgeyByZXR1cm4gdGhpcy50eXBlLm5hbWU7IH1cbiAgICBnZXQgZnJvbSgpIHsgcmV0dXJuIHRoaXMuY29udGV4dC5zdGFydCArIHRoaXMuY29udGV4dC5idWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAxXTsgfVxuICAgIGdldCB0bygpIHsgcmV0dXJuIHRoaXMuY29udGV4dC5zdGFydCArIHRoaXMuY29udGV4dC5idWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAyXTsgfVxuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQsIF9wYXJlbnQsIGluZGV4KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMuX3BhcmVudCA9IF9wYXJlbnQ7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy50eXBlID0gY29udGV4dC5idWZmZXIuc2V0LnR5cGVzW2NvbnRleHQuYnVmZmVyLmJ1ZmZlcltpbmRleF1dO1xuICAgIH1cbiAgICBjaGlsZChkaXIsIHBvcywgc2lkZSkge1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IGluZGV4ID0gYnVmZmVyLmZpbmRDaGlsZCh0aGlzLmluZGV4ICsgNCwgYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgM10sIGRpciwgcG9zIC0gdGhpcy5jb250ZXh0LnN0YXJ0LCBzaWRlKTtcbiAgICAgICAgcmV0dXJuIGluZGV4IDwgMCA/IG51bGwgOiBuZXcgQnVmZmVyTm9kZSh0aGlzLmNvbnRleHQsIHRoaXMsIGluZGV4KTtcbiAgICB9XG4gICAgZ2V0IGZpcnN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLmNoaWxkKDEsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLyk7IH1cbiAgICBnZXQgbGFzdENoaWxkKCkgeyByZXR1cm4gdGhpcy5jaGlsZCgtMSwgMCwgNCAvKiBTaWRlLkRvbnRDYXJlICovKTsgfVxuICAgIGNoaWxkQWZ0ZXIocG9zKSB7IHJldHVybiB0aGlzLmNoaWxkKDEsIHBvcywgMiAvKiBTaWRlLkFmdGVyICovKTsgfVxuICAgIGNoaWxkQmVmb3JlKHBvcykgeyByZXR1cm4gdGhpcy5jaGlsZCgtMSwgcG9zLCAtMiAvKiBTaWRlLkJlZm9yZSAqLyk7IH1cbiAgICBlbnRlcihwb3MsIHNpZGUsIG1vZGUgPSAwKSB7XG4gICAgICAgIGlmIChtb2RlICYgSXRlck1vZGUuRXhjbHVkZUJ1ZmZlcnMpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCBpbmRleCA9IGJ1ZmZlci5maW5kQ2hpbGQodGhpcy5pbmRleCArIDQsIGJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDNdLCBzaWRlID4gMCA/IDEgOiAtMSwgcG9zIC0gdGhpcy5jb250ZXh0LnN0YXJ0LCBzaWRlKTtcbiAgICAgICAgcmV0dXJuIGluZGV4IDwgMCA/IG51bGwgOiBuZXcgQnVmZmVyTm9kZSh0aGlzLmNvbnRleHQsIHRoaXMsIGluZGV4KTtcbiAgICB9XG4gICAgZ2V0IHBhcmVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCB8fCB0aGlzLmNvbnRleHQucGFyZW50Lm5leHRTaWduaWZpY2FudFBhcmVudCgpO1xuICAgIH1cbiAgICBleHRlcm5hbFNpYmxpbmcoZGlyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQgPyBudWxsIDogdGhpcy5jb250ZXh0LnBhcmVudC5uZXh0Q2hpbGQodGhpcy5jb250ZXh0LmluZGV4ICsgZGlyLCBkaXIsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLyk7XG4gICAgfVxuICAgIGdldCBuZXh0U2libGluZygpIHtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCBhZnRlciA9IGJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDNdO1xuICAgICAgICBpZiAoYWZ0ZXIgPCAodGhpcy5fcGFyZW50ID8gYnVmZmVyLmJ1ZmZlclt0aGlzLl9wYXJlbnQuaW5kZXggKyAzXSA6IGJ1ZmZlci5idWZmZXIubGVuZ3RoKSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgQnVmZmVyTm9kZSh0aGlzLmNvbnRleHQsIHRoaXMuX3BhcmVudCwgYWZ0ZXIpO1xuICAgICAgICByZXR1cm4gdGhpcy5leHRlcm5hbFNpYmxpbmcoMSk7XG4gICAgfVxuICAgIGdldCBwcmV2U2libGluZygpIHtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCBwYXJlbnRTdGFydCA9IHRoaXMuX3BhcmVudCA/IHRoaXMuX3BhcmVudC5pbmRleCArIDQgOiAwO1xuICAgICAgICBpZiAodGhpcy5pbmRleCA9PSBwYXJlbnRTdGFydClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV4dGVybmFsU2libGluZygtMSk7XG4gICAgICAgIHJldHVybiBuZXcgQnVmZmVyTm9kZSh0aGlzLmNvbnRleHQsIHRoaXMuX3BhcmVudCwgYnVmZmVyLmZpbmRDaGlsZChwYXJlbnRTdGFydCwgdGhpcy5pbmRleCwgLTEsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLykpO1xuICAgIH1cbiAgICBnZXQgdHJlZSgpIHsgcmV0dXJuIG51bGw7IH1cbiAgICB0b1RyZWUoKSB7XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IFtdLCBwb3NpdGlvbnMgPSBbXTtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCBzdGFydEkgPSB0aGlzLmluZGV4ICsgNCwgZW5kSSA9IGJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDNdO1xuICAgICAgICBpZiAoZW5kSSA+IHN0YXJ0SSkge1xuICAgICAgICAgICAgbGV0IGZyb20gPSBidWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAxXTtcbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2goYnVmZmVyLnNsaWNlKHN0YXJ0SSwgZW5kSSwgZnJvbSkpO1xuICAgICAgICAgICAgcG9zaXRpb25zLnB1c2goMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlKHRoaXMudHlwZSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgdGhpcy50byAtIHRoaXMuZnJvbSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdG9TdHJpbmcoKSB7IHJldHVybiB0aGlzLmNvbnRleHQuYnVmZmVyLmNoaWxkU3RyaW5nKHRoaXMuaW5kZXgpOyB9XG59XG5mdW5jdGlvbiBpdGVyU3RhY2soaGVhZHMpIHtcbiAgICBpZiAoIWhlYWRzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IHBpY2sgPSAwLCBwaWNrZWQgPSBoZWFkc1swXTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGhlYWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBub2RlID0gaGVhZHNbaV07XG4gICAgICAgIGlmIChub2RlLmZyb20gPiBwaWNrZWQuZnJvbSB8fCBub2RlLnRvIDwgcGlja2VkLnRvKSB7XG4gICAgICAgICAgICBwaWNrZWQgPSBub2RlO1xuICAgICAgICAgICAgcGljayA9IGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IG5leHQgPSBwaWNrZWQgaW5zdGFuY2VvZiBUcmVlTm9kZSAmJiBwaWNrZWQuaW5kZXggPCAwID8gbnVsbCA6IHBpY2tlZC5wYXJlbnQ7XG4gICAgbGV0IG5ld0hlYWRzID0gaGVhZHMuc2xpY2UoKTtcbiAgICBpZiAobmV4dClcbiAgICAgICAgbmV3SGVhZHNbcGlja10gPSBuZXh0O1xuICAgIGVsc2VcbiAgICAgICAgbmV3SGVhZHMuc3BsaWNlKHBpY2ssIDEpO1xuICAgIHJldHVybiBuZXcgU3RhY2tJdGVyYXRvcihuZXdIZWFkcywgcGlja2VkKTtcbn1cbmNsYXNzIFN0YWNrSXRlcmF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKGhlYWRzLCBub2RlKSB7XG4gICAgICAgIHRoaXMuaGVhZHMgPSBoZWFkcztcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICB9XG4gICAgZ2V0IG5leHQoKSB7IHJldHVybiBpdGVyU3RhY2sodGhpcy5oZWFkcyk7IH1cbn1cbmZ1bmN0aW9uIHN0YWNrSXRlcmF0b3IodHJlZSwgcG9zLCBzaWRlKSB7XG4gICAgbGV0IGlubmVyID0gdHJlZS5yZXNvbHZlSW5uZXIocG9zLCBzaWRlKSwgbGF5ZXJzID0gbnVsbDtcbiAgICBmb3IgKGxldCBzY2FuID0gaW5uZXIgaW5zdGFuY2VvZiBUcmVlTm9kZSA/IGlubmVyIDogaW5uZXIuY29udGV4dC5wYXJlbnQ7IHNjYW47IHNjYW4gPSBzY2FuLnBhcmVudCkge1xuICAgICAgICBpZiAoc2Nhbi5pbmRleCA8IDApIHsgLy8gVGhpcyBpcyBhbiBvdmVybGF5IHJvb3RcbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSBzY2FuLnBhcmVudDtcbiAgICAgICAgICAgIChsYXllcnMgfHwgKGxheWVycyA9IFtpbm5lcl0pKS5wdXNoKHBhcmVudC5yZXNvbHZlKHBvcywgc2lkZSkpO1xuICAgICAgICAgICAgc2NhbiA9IHBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBtb3VudCA9IE1vdW50ZWRUcmVlLmdldChzY2FuLnRyZWUpO1xuICAgICAgICAgICAgLy8gUmVsZXZhbnQgb3ZlcmxheSBicmFuY2hpbmcgb2ZmXG4gICAgICAgICAgICBpZiAobW91bnQgJiYgbW91bnQub3ZlcmxheSAmJiBtb3VudC5vdmVybGF5WzBdLmZyb20gPD0gcG9zICYmIG1vdW50Lm92ZXJsYXlbbW91bnQub3ZlcmxheS5sZW5ndGggLSAxXS50byA+PSBwb3MpIHtcbiAgICAgICAgICAgICAgICBsZXQgcm9vdCA9IG5ldyBUcmVlTm9kZShtb3VudC50cmVlLCBtb3VudC5vdmVybGF5WzBdLmZyb20gKyBzY2FuLmZyb20sIC0xLCBzY2FuKTtcbiAgICAgICAgICAgICAgICAobGF5ZXJzIHx8IChsYXllcnMgPSBbaW5uZXJdKSkucHVzaChyZXNvbHZlTm9kZShyb290LCBwb3MsIHNpZGUsIGZhbHNlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxheWVycyA/IGl0ZXJTdGFjayhsYXllcnMpIDogaW5uZXI7XG59XG4vKipcbkEgdHJlZSBjdXJzb3Igb2JqZWN0IGZvY3VzZXMgb24gYSBnaXZlbiBub2RlIGluIGEgc3ludGF4IHRyZWUsIGFuZFxuYWxsb3dzIHlvdSB0byBtb3ZlIHRvIGFkamFjZW50IG5vZGVzLlxuKi9cbmNsYXNzIFRyZWVDdXJzb3Ige1xuICAgIC8qKlxuICAgIFNob3J0aGFuZCBmb3IgYC50eXBlLm5hbWVgLlxuICAgICovXG4gICAgZ2V0IG5hbWUoKSB7IHJldHVybiB0aGlzLnR5cGUubmFtZTsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3Iobm9kZSwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBtb2RlID0gMCkge1xuICAgICAgICB0aGlzLm1vZGUgPSBtb2RlO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuYnVmZmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdGFjayA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgICB0aGlzLmJ1ZmZlck5vZGUgPSBudWxsO1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIFRyZWVOb2RlKSB7XG4gICAgICAgICAgICB0aGlzLnlpZWxkTm9kZShub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3RyZWUgPSBub2RlLmNvbnRleHQucGFyZW50O1xuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBub2RlLmNvbnRleHQ7XG4gICAgICAgICAgICBmb3IgKGxldCBuID0gbm9kZS5fcGFyZW50OyBuOyBuID0gbi5fcGFyZW50KVxuICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sudW5zaGlmdChuLmluZGV4KTtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyTm9kZSA9IG5vZGU7XG4gICAgICAgICAgICB0aGlzLnlpZWxkQnVmKG5vZGUuaW5kZXgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHlpZWxkTm9kZShub2RlKSB7XG4gICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy5fdHJlZSA9IG5vZGU7XG4gICAgICAgIHRoaXMudHlwZSA9IG5vZGUudHlwZTtcbiAgICAgICAgdGhpcy5mcm9tID0gbm9kZS5mcm9tO1xuICAgICAgICB0aGlzLnRvID0gbm9kZS50bztcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHlpZWxkQnVmKGluZGV4LCB0eXBlKSB7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgbGV0IHsgc3RhcnQsIGJ1ZmZlciB9ID0gdGhpcy5idWZmZXI7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGUgfHwgYnVmZmVyLnNldC50eXBlc1tidWZmZXIuYnVmZmVyW2luZGV4XV07XG4gICAgICAgIHRoaXMuZnJvbSA9IHN0YXJ0ICsgYnVmZmVyLmJ1ZmZlcltpbmRleCArIDFdO1xuICAgICAgICB0aGlzLnRvID0gc3RhcnQgKyBidWZmZXIuYnVmZmVyW2luZGV4ICsgMl07XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHlpZWxkKG5vZGUpIHtcbiAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIFRyZWVOb2RlKSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZE5vZGUobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5idWZmZXIgPSBub2RlLmNvbnRleHQ7XG4gICAgICAgIHJldHVybiB0aGlzLnlpZWxkQnVmKG5vZGUuaW5kZXgsIG5vZGUudHlwZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlciA/IHRoaXMuYnVmZmVyLmJ1ZmZlci5jaGlsZFN0cmluZyh0aGlzLmluZGV4KSA6IHRoaXMuX3RyZWUudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBlbnRlckNoaWxkKGRpciwgcG9zLCBzaWRlKSB7XG4gICAgICAgIGlmICghdGhpcy5idWZmZXIpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZCh0aGlzLl90cmVlLm5leHRDaGlsZChkaXIgPCAwID8gdGhpcy5fdHJlZS5fdHJlZS5jaGlsZHJlbi5sZW5ndGggLSAxIDogMCwgZGlyLCBwb3MsIHNpZGUsIHRoaXMubW9kZSkpO1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuYnVmZmVyO1xuICAgICAgICBsZXQgaW5kZXggPSBidWZmZXIuZmluZENoaWxkKHRoaXMuaW5kZXggKyA0LCBidWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAzXSwgZGlyLCBwb3MgLSB0aGlzLmJ1ZmZlci5zdGFydCwgc2lkZSk7XG4gICAgICAgIGlmIChpbmRleCA8IDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMuc3RhY2sucHVzaCh0aGlzLmluZGV4KTtcbiAgICAgICAgcmV0dXJuIHRoaXMueWllbGRCdWYoaW5kZXgpO1xuICAgIH1cbiAgICAvKipcbiAgICBNb3ZlIHRoZSBjdXJzb3IgdG8gdGhpcyBub2RlJ3MgZmlyc3QgY2hpbGQuIFdoZW4gdGhpcyByZXR1cm5zXG4gICAgZmFsc2UsIHRoZSBub2RlIGhhcyBubyBjaGlsZCwgYW5kIHRoZSBjdXJzb3IgaGFzIG5vdCBiZWVuIG1vdmVkLlxuICAgICovXG4gICAgZmlyc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMuZW50ZXJDaGlsZCgxLCAwLCA0IC8qIFNpZGUuRG9udENhcmUgKi8pOyB9XG4gICAgLyoqXG4gICAgTW92ZSB0aGUgY3Vyc29yIHRvIHRoaXMgbm9kZSdzIGxhc3QgY2hpbGQuXG4gICAgKi9cbiAgICBsYXN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLmVudGVyQ2hpbGQoLTEsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLyk7IH1cbiAgICAvKipcbiAgICBNb3ZlIHRoZSBjdXJzb3IgdG8gdGhlIGZpcnN0IGNoaWxkIHRoYXQgZW5kcyBhZnRlciBgcG9zYC5cbiAgICAqL1xuICAgIGNoaWxkQWZ0ZXIocG9zKSB7IHJldHVybiB0aGlzLmVudGVyQ2hpbGQoMSwgcG9zLCAyIC8qIFNpZGUuQWZ0ZXIgKi8pOyB9XG4gICAgLyoqXG4gICAgTW92ZSB0byB0aGUgbGFzdCBjaGlsZCB0aGF0IHN0YXJ0cyBiZWZvcmUgYHBvc2AuXG4gICAgKi9cbiAgICBjaGlsZEJlZm9yZShwb3MpIHsgcmV0dXJuIHRoaXMuZW50ZXJDaGlsZCgtMSwgcG9zLCAtMiAvKiBTaWRlLkJlZm9yZSAqLyk7IH1cbiAgICAvKipcbiAgICBNb3ZlIHRoZSBjdXJzb3IgdG8gdGhlIGNoaWxkIGFyb3VuZCBgcG9zYC4gSWYgc2lkZSBpcyAtMSB0aGVcbiAgICBjaGlsZCBtYXkgZW5kIGF0IHRoYXQgcG9zaXRpb24sIHdoZW4gMSBpdCBtYXkgc3RhcnQgdGhlcmUuIFRoaXNcbiAgICB3aWxsIGFsc28gZW50ZXIgW292ZXJsYWlkXSgjY29tbW9uLk1vdW50ZWRUcmVlLm92ZXJsYXkpXG4gICAgW21vdW50ZWRdKCNjb21tb24uTm9kZVByb3BebW91bnRlZCkgdHJlZXMgdW5sZXNzIGBvdmVybGF5c2AgaXNcbiAgICBzZXQgdG8gZmFsc2UuXG4gICAgKi9cbiAgICBlbnRlcihwb3MsIHNpZGUsIG1vZGUgPSB0aGlzLm1vZGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmJ1ZmZlcilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkKHRoaXMuX3RyZWUuZW50ZXIocG9zLCBzaWRlLCBtb2RlKSk7XG4gICAgICAgIHJldHVybiBtb2RlICYgSXRlck1vZGUuRXhjbHVkZUJ1ZmZlcnMgPyBmYWxzZSA6IHRoaXMuZW50ZXJDaGlsZCgxLCBwb3MsIHNpZGUpO1xuICAgIH1cbiAgICAvKipcbiAgICBNb3ZlIHRvIHRoZSBub2RlJ3MgcGFyZW50IG5vZGUsIGlmIHRoaXMgaXNuJ3QgdGhlIHRvcCBub2RlLlxuICAgICovXG4gICAgcGFyZW50KCkge1xuICAgICAgICBpZiAoIXRoaXMuYnVmZmVyKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMueWllbGROb2RlKCh0aGlzLm1vZGUgJiBJdGVyTW9kZS5JbmNsdWRlQW5vbnltb3VzKSA/IHRoaXMuX3RyZWUuX3BhcmVudCA6IHRoaXMuX3RyZWUucGFyZW50KTtcbiAgICAgICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMueWllbGRCdWYodGhpcy5zdGFjay5wb3AoKSk7XG4gICAgICAgIGxldCBwYXJlbnQgPSAodGhpcy5tb2RlICYgSXRlck1vZGUuSW5jbHVkZUFub255bW91cykgPyB0aGlzLmJ1ZmZlci5wYXJlbnQgOiB0aGlzLmJ1ZmZlci5wYXJlbnQubmV4dFNpZ25pZmljYW50UGFyZW50KCk7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXMueWllbGROb2RlKHBhcmVudCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc2libGluZyhkaXIpIHtcbiAgICAgICAgaWYgKCF0aGlzLmJ1ZmZlcilcbiAgICAgICAgICAgIHJldHVybiAhdGhpcy5fdHJlZS5fcGFyZW50ID8gZmFsc2VcbiAgICAgICAgICAgICAgICA6IHRoaXMueWllbGQodGhpcy5fdHJlZS5pbmRleCA8IDAgPyBudWxsXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5fdHJlZS5fcGFyZW50Lm5leHRDaGlsZCh0aGlzLl90cmVlLmluZGV4ICsgZGlyLCBkaXIsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLywgdGhpcy5tb2RlKSk7XG4gICAgICAgIGxldCB7IGJ1ZmZlciB9ID0gdGhpcy5idWZmZXIsIGQgPSB0aGlzLnN0YWNrLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChkaXIgPCAwKSB7XG4gICAgICAgICAgICBsZXQgcGFyZW50U3RhcnQgPSBkIDwgMCA/IDAgOiB0aGlzLnN0YWNrW2RdICsgNDtcbiAgICAgICAgICAgIGlmICh0aGlzLmluZGV4ICE9IHBhcmVudFN0YXJ0KVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkQnVmKGJ1ZmZlci5maW5kQ2hpbGQocGFyZW50U3RhcnQsIHRoaXMuaW5kZXgsIC0xLCAwLCA0IC8qIFNpZGUuRG9udENhcmUgKi8pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBhZnRlciA9IGJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDNdO1xuICAgICAgICAgICAgaWYgKGFmdGVyIDwgKGQgPCAwID8gYnVmZmVyLmJ1ZmZlci5sZW5ndGggOiBidWZmZXIuYnVmZmVyW3RoaXMuc3RhY2tbZF0gKyAzXSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMueWllbGRCdWYoYWZ0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkIDwgMCA/IHRoaXMueWllbGQodGhpcy5idWZmZXIucGFyZW50Lm5leHRDaGlsZCh0aGlzLmJ1ZmZlci5pbmRleCArIGRpciwgZGlyLCAwLCA0IC8qIFNpZGUuRG9udENhcmUgKi8sIHRoaXMubW9kZSkpIDogZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgIE1vdmUgdG8gdGhpcyBub2RlJ3MgbmV4dCBzaWJsaW5nLCBpZiBhbnkuXG4gICAgKi9cbiAgICBuZXh0U2libGluZygpIHsgcmV0dXJuIHRoaXMuc2libGluZygxKTsgfVxuICAgIC8qKlxuICAgIE1vdmUgdG8gdGhpcyBub2RlJ3MgcHJldmlvdXMgc2libGluZywgaWYgYW55LlxuICAgICovXG4gICAgcHJldlNpYmxpbmcoKSB7IHJldHVybiB0aGlzLnNpYmxpbmcoLTEpOyB9XG4gICAgYXRMYXN0Tm9kZShkaXIpIHtcbiAgICAgICAgbGV0IGluZGV4LCBwYXJlbnQsIHsgYnVmZmVyIH0gPSB0aGlzO1xuICAgICAgICBpZiAoYnVmZmVyKSB7XG4gICAgICAgICAgICBpZiAoZGlyID4gMCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmluZGV4IDwgYnVmZmVyLmJ1ZmZlci5idWZmZXIubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuaW5kZXg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJ1ZmZlci5idWZmZXIuYnVmZmVyW2kgKyAzXSA8IHRoaXMuaW5kZXgpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoeyBpbmRleCwgcGFyZW50IH0gPSBidWZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgKHsgaW5kZXgsIF9wYXJlbnQ6IHBhcmVudCB9ID0gdGhpcy5fdHJlZSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICg7IHBhcmVudDsgeyBpbmRleCwgX3BhcmVudDogcGFyZW50IH0gPSBwYXJlbnQpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBpbmRleCArIGRpciwgZSA9IGRpciA8IDAgPyAtMSA6IHBhcmVudC5fdHJlZS5jaGlsZHJlbi5sZW5ndGg7IGkgIT0gZTsgaSArPSBkaXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNoaWxkID0gcGFyZW50Ll90cmVlLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHRoaXMubW9kZSAmIEl0ZXJNb2RlLkluY2x1ZGVBbm9ueW1vdXMpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZCBpbnN0YW5jZW9mIFRyZWVCdWZmZXIgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICFjaGlsZC50eXBlLmlzQW5vbnltb3VzIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNDaGlsZChjaGlsZCkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBtb3ZlKGRpciwgZW50ZXIpIHtcbiAgICAgICAgaWYgKGVudGVyICYmIHRoaXMuZW50ZXJDaGlsZChkaXIsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLykpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2libGluZyhkaXIpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuYXRMYXN0Tm9kZShkaXIpIHx8ICF0aGlzLnBhcmVudCgpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBNb3ZlIHRvIHRoZSBuZXh0IG5vZGUgaW4gYVxuICAgIFtwcmUtb3JkZXJdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1RyZWVfdHJhdmVyc2FsI1ByZS1vcmRlcixfTkxSKVxuICAgIHRyYXZlcnNhbCwgZ29pbmcgZnJvbSBhIG5vZGUgdG8gaXRzIGZpcnN0IGNoaWxkIG9yLCBpZiB0aGVcbiAgICBjdXJyZW50IG5vZGUgaXMgZW1wdHkgb3IgYGVudGVyYCBpcyBmYWxzZSwgaXRzIG5leHQgc2libGluZyBvclxuICAgIHRoZSBuZXh0IHNpYmxpbmcgb2YgdGhlIGZpcnN0IHBhcmVudCBub2RlIHRoYXQgaGFzIG9uZS5cbiAgICAqL1xuICAgIG5leHQoZW50ZXIgPSB0cnVlKSB7IHJldHVybiB0aGlzLm1vdmUoMSwgZW50ZXIpOyB9XG4gICAgLyoqXG4gICAgTW92ZSB0byB0aGUgbmV4dCBub2RlIGluIGEgbGFzdC10by1maXJzdCBwcmUtb3JkZXIgdHJhdmVyYWwuIEFcbiAgICBub2RlIGlzIGZvbGxvd2VkIGJ5IGl0cyBsYXN0IGNoaWxkIG9yLCBpZiBpdCBoYXMgbm9uZSwgaXRzXG4gICAgcHJldmlvdXMgc2libGluZyBvciB0aGUgcHJldmlvdXMgc2libGluZyBvZiB0aGUgZmlyc3QgcGFyZW50XG4gICAgbm9kZSB0aGF0IGhhcyBvbmUuXG4gICAgKi9cbiAgICBwcmV2KGVudGVyID0gdHJ1ZSkgeyByZXR1cm4gdGhpcy5tb3ZlKC0xLCBlbnRlcik7IH1cbiAgICAvKipcbiAgICBNb3ZlIHRoZSBjdXJzb3IgdG8gdGhlIGlubmVybW9zdCBub2RlIHRoYXQgY292ZXJzIGBwb3NgLiBJZlxuICAgIGBzaWRlYCBpcyAtMSwgaXQgd2lsbCBlbnRlciBub2RlcyB0aGF0IGVuZCBhdCBgcG9zYC4gSWYgaXQgaXMgMSxcbiAgICBpdCB3aWxsIGVudGVyIG5vZGVzIHRoYXQgc3RhcnQgYXQgYHBvc2AuXG4gICAgKi9cbiAgICBtb3ZlVG8ocG9zLCBzaWRlID0gMCkge1xuICAgICAgICAvLyBNb3ZlIHVwIHRvIGEgbm9kZSB0aGF0IGFjdHVhbGx5IGhvbGRzIHRoZSBwb3NpdGlvbiwgaWYgcG9zc2libGVcbiAgICAgICAgd2hpbGUgKHRoaXMuZnJvbSA9PSB0aGlzLnRvIHx8XG4gICAgICAgICAgICAoc2lkZSA8IDEgPyB0aGlzLmZyb20gPj0gcG9zIDogdGhpcy5mcm9tID4gcG9zKSB8fFxuICAgICAgICAgICAgKHNpZGUgPiAtMSA/IHRoaXMudG8gPD0gcG9zIDogdGhpcy50byA8IHBvcykpXG4gICAgICAgICAgICBpZiAoIXRoaXMucGFyZW50KCkpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIFRoZW4gc2NhbiBkb3duIGludG8gY2hpbGQgbm9kZXMgYXMgZmFyIGFzIHBvc3NpYmxlXG4gICAgICAgIHdoaWxlICh0aGlzLmVudGVyQ2hpbGQoMSwgcG9zLCBzaWRlKSkgeyB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgYSBbc3ludGF4IG5vZGVdKCNjb21tb24uU3ludGF4Tm9kZSkgYXQgdGhlIGN1cnNvcidzIGN1cnJlbnRcbiAgICBwb3NpdGlvbi5cbiAgICAqL1xuICAgIGdldCBub2RlKCkge1xuICAgICAgICBpZiAoIXRoaXMuYnVmZmVyKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RyZWU7XG4gICAgICAgIGxldCBjYWNoZSA9IHRoaXMuYnVmZmVyTm9kZSwgcmVzdWx0ID0gbnVsbCwgZGVwdGggPSAwO1xuICAgICAgICBpZiAoY2FjaGUgJiYgY2FjaGUuY29udGV4dCA9PSB0aGlzLmJ1ZmZlcikge1xuICAgICAgICAgICAgc2NhbjogZm9yIChsZXQgaW5kZXggPSB0aGlzLmluZGV4LCBkID0gdGhpcy5zdGFjay5sZW5ndGg7IGQgPj0gMDspIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjID0gY2FjaGU7IGM7IGMgPSBjLl9wYXJlbnQpXG4gICAgICAgICAgICAgICAgICAgIGlmIChjLmluZGV4ID09IGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT0gdGhpcy5pbmRleClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGM7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXB0aCA9IGQgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgc2NhbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluZGV4ID0gdGhpcy5zdGFja1stLWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSBkZXB0aDsgaSA8IHRoaXMuc3RhY2subGVuZ3RoOyBpKyspXG4gICAgICAgICAgICByZXN1bHQgPSBuZXcgQnVmZmVyTm9kZSh0aGlzLmJ1ZmZlciwgcmVzdWx0LCB0aGlzLnN0YWNrW2ldKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyTm9kZSA9IG5ldyBCdWZmZXJOb2RlKHRoaXMuYnVmZmVyLCByZXN1bHQsIHRoaXMuaW5kZXgpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIFt0cmVlXSgjY29tbW9uLlRyZWUpIHRoYXQgcmVwcmVzZW50cyB0aGUgY3VycmVudCBub2RlLCBpZlxuICAgIGFueS4gV2lsbCByZXR1cm4gbnVsbCB3aGVuIHRoZSBub2RlIGlzIGluIGEgW3RyZWVcbiAgICBidWZmZXJdKCNjb21tb24uVHJlZUJ1ZmZlcikuXG4gICAgKi9cbiAgICBnZXQgdHJlZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyID8gbnVsbCA6IHRoaXMuX3RyZWUuX3RyZWU7XG4gICAgfVxuICAgIC8qKlxuICAgIEl0ZXJhdGUgb3ZlciB0aGUgY3VycmVudCBub2RlIGFuZCBhbGwgaXRzIGRlc2NlbmRhbnRzLCBjYWxsaW5nXG4gICAgYGVudGVyYCB3aGVuIGVudGVyaW5nIGEgbm9kZSBhbmQgYGxlYXZlYCwgaWYgZ2l2ZW4sIHdoZW4gbGVhdmluZ1xuICAgIG9uZS4gV2hlbiBgZW50ZXJgIHJldHVybnMgYGZhbHNlYCwgYW55IGNoaWxkcmVuIG9mIHRoYXQgbm9kZSBhcmVcbiAgICBza2lwcGVkLCBhbmQgYGxlYXZlYCBpc24ndCBjYWxsZWQgZm9yIGl0LlxuICAgICovXG4gICAgaXRlcmF0ZShlbnRlciwgbGVhdmUpIHtcbiAgICAgICAgZm9yIChsZXQgZGVwdGggPSAwOzspIHtcbiAgICAgICAgICAgIGxldCBtdXN0TGVhdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnR5cGUuaXNBbm9ueW1vdXMgfHwgZW50ZXIodGhpcykgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZmlyc3RDaGlsZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlcHRoKys7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMudHlwZS5pc0Fub255bW91cylcbiAgICAgICAgICAgICAgICAgICAgbXVzdExlYXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICBpZiAobXVzdExlYXZlICYmIGxlYXZlKVxuICAgICAgICAgICAgICAgICAgICBsZWF2ZSh0aGlzKTtcbiAgICAgICAgICAgICAgICBtdXN0TGVhdmUgPSB0aGlzLnR5cGUuaXNBbm9ueW1vdXM7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubmV4dFNpYmxpbmcoKSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgaWYgKCFkZXB0aClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50KCk7XG4gICAgICAgICAgICAgICAgZGVwdGgtLTtcbiAgICAgICAgICAgICAgICBtdXN0TGVhdmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIFRlc3Qgd2hldGhlciB0aGUgY3VycmVudCBub2RlIG1hdGNoZXMgYSBnaXZlbiBjb250ZXh04oCUYSBzZXF1ZW5jZVxuICAgIG9mIGRpcmVjdCBwYXJlbnQgbm9kZSBuYW1lcy4gRW1wdHkgc3RyaW5ncyBpbiB0aGUgY29udGV4dCBhcnJheVxuICAgIGFyZSB0cmVhdGVkIGFzIHdpbGRjYXJkcy5cbiAgICAqL1xuICAgIG1hdGNoQ29udGV4dChjb250ZXh0KSB7XG4gICAgICAgIGlmICghdGhpcy5idWZmZXIpXG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hOb2RlQ29udGV4dCh0aGlzLm5vZGUsIGNvbnRleHQpO1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuYnVmZmVyLCB7IHR5cGVzIH0gPSBidWZmZXIuc2V0O1xuICAgICAgICBmb3IgKGxldCBpID0gY29udGV4dC5sZW5ndGggLSAxLCBkID0gdGhpcy5zdGFjay5sZW5ndGggLSAxOyBpID49IDA7IGQtLSkge1xuICAgICAgICAgICAgaWYgKGQgPCAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaE5vZGVDb250ZXh0KHRoaXMubm9kZSwgY29udGV4dCwgaSk7XG4gICAgICAgICAgICBsZXQgdHlwZSA9IHR5cGVzW2J1ZmZlci5idWZmZXJbdGhpcy5zdGFja1tkXV1dO1xuICAgICAgICAgICAgaWYgKCF0eXBlLmlzQW5vbnltb3VzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRleHRbaV0gJiYgY29udGV4dFtpXSAhPSB0eXBlLm5hbWUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuZnVuY3Rpb24gaGFzQ2hpbGQodHJlZSkge1xuICAgIHJldHVybiB0cmVlLmNoaWxkcmVuLnNvbWUoY2ggPT4gY2ggaW5zdGFuY2VvZiBUcmVlQnVmZmVyIHx8ICFjaC50eXBlLmlzQW5vbnltb3VzIHx8IGhhc0NoaWxkKGNoKSk7XG59XG5mdW5jdGlvbiBidWlsZFRyZWUoZGF0YSkge1xuICAgIHZhciBfYTtcbiAgICBsZXQgeyBidWZmZXIsIG5vZGVTZXQsIG1heEJ1ZmZlckxlbmd0aCA9IERlZmF1bHRCdWZmZXJMZW5ndGgsIHJldXNlZCA9IFtdLCBtaW5SZXBlYXRUeXBlID0gbm9kZVNldC50eXBlcy5sZW5ndGggfSA9IGRhdGE7XG4gICAgbGV0IGN1cnNvciA9IEFycmF5LmlzQXJyYXkoYnVmZmVyKSA/IG5ldyBGbGF0QnVmZmVyQ3Vyc29yKGJ1ZmZlciwgYnVmZmVyLmxlbmd0aCkgOiBidWZmZXI7XG4gICAgbGV0IHR5cGVzID0gbm9kZVNldC50eXBlcztcbiAgICBsZXQgY29udGV4dEhhc2ggPSAwLCBsb29rQWhlYWQgPSAwO1xuICAgIGZ1bmN0aW9uIHRha2VOb2RlKHBhcmVudFN0YXJ0LCBtaW5Qb3MsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGluUmVwZWF0LCBkZXB0aCkge1xuICAgICAgICBsZXQgeyBpZCwgc3RhcnQsIGVuZCwgc2l6ZSB9ID0gY3Vyc29yO1xuICAgICAgICBsZXQgbG9va0FoZWFkQXRTdGFydCA9IGxvb2tBaGVhZDtcbiAgICAgICAgd2hpbGUgKHNpemUgPCAwKSB7XG4gICAgICAgICAgICBjdXJzb3IubmV4dCgpO1xuICAgICAgICAgICAgaWYgKHNpemUgPT0gLTEgLyogU3BlY2lhbFJlY29yZC5SZXVzZSAqLykge1xuICAgICAgICAgICAgICAgIGxldCBub2RlID0gcmV1c2VkW2lkXTtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgIHBvc2l0aW9ucy5wdXNoKHN0YXJ0IC0gcGFyZW50U3RhcnQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNpemUgPT0gLTMgLyogU3BlY2lhbFJlY29yZC5Db250ZXh0Q2hhbmdlICovKSB7IC8vIENvbnRleHQgY2hhbmdlXG4gICAgICAgICAgICAgICAgY29udGV4dEhhc2ggPSBpZDtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzaXplID09IC00IC8qIFNwZWNpYWxSZWNvcmQuTG9va0FoZWFkICovKSB7XG4gICAgICAgICAgICAgICAgbG9va0FoZWFkID0gaWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFVucmVjb2duaXplZCByZWNvcmQgc2l6ZTogJHtzaXplfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCB0eXBlID0gdHlwZXNbaWRdLCBub2RlLCBidWZmZXI7XG4gICAgICAgIGxldCBzdGFydFBvcyA9IHN0YXJ0IC0gcGFyZW50U3RhcnQ7XG4gICAgICAgIGlmIChlbmQgLSBzdGFydCA8PSBtYXhCdWZmZXJMZW5ndGggJiYgKGJ1ZmZlciA9IGZpbmRCdWZmZXJTaXplKGN1cnNvci5wb3MgLSBtaW5Qb3MsIGluUmVwZWF0KSkpIHtcbiAgICAgICAgICAgIC8vIFNtYWxsIGVub3VnaCBmb3IgYSBidWZmZXIsIGFuZCBubyByZXVzZWQgbm9kZXMgaW5zaWRlXG4gICAgICAgICAgICBsZXQgZGF0YSA9IG5ldyBVaW50MTZBcnJheShidWZmZXIuc2l6ZSAtIGJ1ZmZlci5za2lwKTtcbiAgICAgICAgICAgIGxldCBlbmRQb3MgPSBjdXJzb3IucG9zIC0gYnVmZmVyLnNpemUsIGluZGV4ID0gZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoY3Vyc29yLnBvcyA+IGVuZFBvcylcbiAgICAgICAgICAgICAgICBpbmRleCA9IGNvcHlUb0J1ZmZlcihidWZmZXIuc3RhcnQsIGRhdGEsIGluZGV4KTtcbiAgICAgICAgICAgIG5vZGUgPSBuZXcgVHJlZUJ1ZmZlcihkYXRhLCBlbmQgLSBidWZmZXIuc3RhcnQsIG5vZGVTZXQpO1xuICAgICAgICAgICAgc3RhcnRQb3MgPSBidWZmZXIuc3RhcnQgLSBwYXJlbnRTdGFydDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gTWFrZSBpdCBhIG5vZGVcbiAgICAgICAgICAgIGxldCBlbmRQb3MgPSBjdXJzb3IucG9zIC0gc2l6ZTtcbiAgICAgICAgICAgIGN1cnNvci5uZXh0KCk7XG4gICAgICAgICAgICBsZXQgbG9jYWxDaGlsZHJlbiA9IFtdLCBsb2NhbFBvc2l0aW9ucyA9IFtdO1xuICAgICAgICAgICAgbGV0IGxvY2FsSW5SZXBlYXQgPSBpZCA+PSBtaW5SZXBlYXRUeXBlID8gaWQgOiAtMTtcbiAgICAgICAgICAgIGxldCBsYXN0R3JvdXAgPSAwLCBsYXN0RW5kID0gZW5kO1xuICAgICAgICAgICAgd2hpbGUgKGN1cnNvci5wb3MgPiBlbmRQb3MpIHtcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxJblJlcGVhdCA+PSAwICYmIGN1cnNvci5pZCA9PSBsb2NhbEluUmVwZWF0ICYmIGN1cnNvci5zaXplID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnNvci5lbmQgPD0gbGFzdEVuZCAtIG1heEJ1ZmZlckxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFrZVJlcGVhdExlYWYobG9jYWxDaGlsZHJlbiwgbG9jYWxQb3NpdGlvbnMsIHN0YXJ0LCBsYXN0R3JvdXAsIGN1cnNvci5lbmQsIGxhc3RFbmQsIGxvY2FsSW5SZXBlYXQsIGxvb2tBaGVhZEF0U3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEdyb3VwID0gbG9jYWxDaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0RW5kID0gY3Vyc29yLmVuZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjdXJzb3IubmV4dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChkZXB0aCA+IDI1MDAgLyogQ3V0T2ZmLkRlcHRoICovKSB7XG4gICAgICAgICAgICAgICAgICAgIHRha2VGbGF0Tm9kZShzdGFydCwgZW5kUG9zLCBsb2NhbENoaWxkcmVuLCBsb2NhbFBvc2l0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0YWtlTm9kZShzdGFydCwgZW5kUG9zLCBsb2NhbENoaWxkcmVuLCBsb2NhbFBvc2l0aW9ucywgbG9jYWxJblJlcGVhdCwgZGVwdGggKyAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobG9jYWxJblJlcGVhdCA+PSAwICYmIGxhc3RHcm91cCA+IDAgJiYgbGFzdEdyb3VwIDwgbG9jYWxDaGlsZHJlbi5sZW5ndGgpXG4gICAgICAgICAgICAgICAgbWFrZVJlcGVhdExlYWYobG9jYWxDaGlsZHJlbiwgbG9jYWxQb3NpdGlvbnMsIHN0YXJ0LCBsYXN0R3JvdXAsIHN0YXJ0LCBsYXN0RW5kLCBsb2NhbEluUmVwZWF0LCBsb29rQWhlYWRBdFN0YXJ0KTtcbiAgICAgICAgICAgIGxvY2FsQ2hpbGRyZW4ucmV2ZXJzZSgpO1xuICAgICAgICAgICAgbG9jYWxQb3NpdGlvbnMucmV2ZXJzZSgpO1xuICAgICAgICAgICAgaWYgKGxvY2FsSW5SZXBlYXQgPiAtMSAmJiBsYXN0R3JvdXAgPiAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IG1ha2UgPSBtYWtlQmFsYW5jZWQodHlwZSk7XG4gICAgICAgICAgICAgICAgbm9kZSA9IGJhbGFuY2VSYW5nZSh0eXBlLCBsb2NhbENoaWxkcmVuLCBsb2NhbFBvc2l0aW9ucywgMCwgbG9jYWxDaGlsZHJlbi5sZW5ndGgsIDAsIGVuZCAtIHN0YXJ0LCBtYWtlLCBtYWtlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBtYWtlVHJlZSh0eXBlLCBsb2NhbENoaWxkcmVuLCBsb2NhbFBvc2l0aW9ucywgZW5kIC0gc3RhcnQsIGxvb2tBaGVhZEF0U3RhcnQgLSBlbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNoaWxkcmVuLnB1c2gobm9kZSk7XG4gICAgICAgIHBvc2l0aW9ucy5wdXNoKHN0YXJ0UG9zKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdGFrZUZsYXROb2RlKHBhcmVudFN0YXJ0LCBtaW5Qb3MsIGNoaWxkcmVuLCBwb3NpdGlvbnMpIHtcbiAgICAgICAgbGV0IG5vZGVzID0gW107IC8vIFRlbXBvcmFyeSwgaW52ZXJ0ZWQgYXJyYXkgb2YgbGVhZiBub2RlcyBmb3VuZCwgd2l0aCBhYnNvbHV0ZSBwb3NpdGlvbnNcbiAgICAgICAgbGV0IG5vZGVDb3VudCA9IDAsIHN0b3BBdCA9IC0xO1xuICAgICAgICB3aGlsZSAoY3Vyc29yLnBvcyA+IG1pblBvcykge1xuICAgICAgICAgICAgbGV0IHsgaWQsIHN0YXJ0LCBlbmQsIHNpemUgfSA9IGN1cnNvcjtcbiAgICAgICAgICAgIGlmIChzaXplID4gNCkgeyAvLyBOb3QgYSBsZWFmXG4gICAgICAgICAgICAgICAgY3Vyc29yLm5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHN0b3BBdCA+IC0xICYmIHN0YXJ0IDwgc3RvcEF0KSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RvcEF0IDwgMClcbiAgICAgICAgICAgICAgICAgICAgc3RvcEF0ID0gZW5kIC0gbWF4QnVmZmVyTGVuZ3RoO1xuICAgICAgICAgICAgICAgIG5vZGVzLnB1c2goaWQsIHN0YXJ0LCBlbmQpO1xuICAgICAgICAgICAgICAgIG5vZGVDb3VudCsrO1xuICAgICAgICAgICAgICAgIGN1cnNvci5uZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGVDb3VudCkge1xuICAgICAgICAgICAgbGV0IGJ1ZmZlciA9IG5ldyBVaW50MTZBcnJheShub2RlQ291bnQgKiA0KTtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IG5vZGVzW25vZGVzLmxlbmd0aCAtIDJdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IG5vZGVzLmxlbmd0aCAtIDMsIGogPSAwOyBpID49IDA7IGkgLT0gMykge1xuICAgICAgICAgICAgICAgIGJ1ZmZlcltqKytdID0gbm9kZXNbaV07XG4gICAgICAgICAgICAgICAgYnVmZmVyW2orK10gPSBub2Rlc1tpICsgMV0gLSBzdGFydDtcbiAgICAgICAgICAgICAgICBidWZmZXJbaisrXSA9IG5vZGVzW2kgKyAyXSAtIHN0YXJ0O1xuICAgICAgICAgICAgICAgIGJ1ZmZlcltqKytdID0gajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2gobmV3IFRyZWVCdWZmZXIoYnVmZmVyLCBub2Rlc1syXSAtIHN0YXJ0LCBub2RlU2V0KSk7XG4gICAgICAgICAgICBwb3NpdGlvbnMucHVzaChzdGFydCAtIHBhcmVudFN0YXJ0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBtYWtlQmFsYW5jZWQodHlwZSkge1xuICAgICAgICByZXR1cm4gKGNoaWxkcmVuLCBwb3NpdGlvbnMsIGxlbmd0aCkgPT4ge1xuICAgICAgICAgICAgbGV0IGxvb2tBaGVhZCA9IDAsIGxhc3RJID0gY2hpbGRyZW4ubGVuZ3RoIC0gMSwgbGFzdCwgbG9va0FoZWFkUHJvcDtcbiAgICAgICAgICAgIGlmIChsYXN0SSA+PSAwICYmIChsYXN0ID0gY2hpbGRyZW5bbGFzdEldKSBpbnN0YW5jZW9mIFRyZWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWxhc3RJICYmIGxhc3QudHlwZSA9PSB0eXBlICYmIGxhc3QubGVuZ3RoID09IGxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxhc3Q7XG4gICAgICAgICAgICAgICAgaWYgKGxvb2tBaGVhZFByb3AgPSBsYXN0LnByb3AoTm9kZVByb3AubG9va0FoZWFkKSlcbiAgICAgICAgICAgICAgICAgICAgbG9va0FoZWFkID0gcG9zaXRpb25zW2xhc3RJXSArIGxhc3QubGVuZ3RoICsgbG9va0FoZWFkUHJvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYWtlVHJlZSh0eXBlLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBsZW5ndGgsIGxvb2tBaGVhZCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1ha2VSZXBlYXRMZWFmKGNoaWxkcmVuLCBwb3NpdGlvbnMsIGJhc2UsIGksIGZyb20sIHRvLCB0eXBlLCBsb29rQWhlYWQpIHtcbiAgICAgICAgbGV0IGxvY2FsQ2hpbGRyZW4gPSBbXSwgbG9jYWxQb3NpdGlvbnMgPSBbXTtcbiAgICAgICAgd2hpbGUgKGNoaWxkcmVuLmxlbmd0aCA+IGkpIHtcbiAgICAgICAgICAgIGxvY2FsQ2hpbGRyZW4ucHVzaChjaGlsZHJlbi5wb3AoKSk7XG4gICAgICAgICAgICBsb2NhbFBvc2l0aW9ucy5wdXNoKHBvc2l0aW9ucy5wb3AoKSArIGJhc2UgLSBmcm9tKTtcbiAgICAgICAgfVxuICAgICAgICBjaGlsZHJlbi5wdXNoKG1ha2VUcmVlKG5vZGVTZXQudHlwZXNbdHlwZV0sIGxvY2FsQ2hpbGRyZW4sIGxvY2FsUG9zaXRpb25zLCB0byAtIGZyb20sIGxvb2tBaGVhZCAtIHRvKSk7XG4gICAgICAgIHBvc2l0aW9ucy5wdXNoKGZyb20gLSBiYXNlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFrZVRyZWUodHlwZSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgbGVuZ3RoLCBsb29rQWhlYWQgPSAwLCBwcm9wcykge1xuICAgICAgICBpZiAoY29udGV4dEhhc2gpIHtcbiAgICAgICAgICAgIGxldCBwYWlyID0gW05vZGVQcm9wLmNvbnRleHRIYXNoLCBjb250ZXh0SGFzaF07XG4gICAgICAgICAgICBwcm9wcyA9IHByb3BzID8gW3BhaXJdLmNvbmNhdChwcm9wcykgOiBbcGFpcl07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvb2tBaGVhZCA+IDI1KSB7XG4gICAgICAgICAgICBsZXQgcGFpciA9IFtOb2RlUHJvcC5sb29rQWhlYWQsIGxvb2tBaGVhZF07XG4gICAgICAgICAgICBwcm9wcyA9IHByb3BzID8gW3BhaXJdLmNvbmNhdChwcm9wcykgOiBbcGFpcl07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlKHR5cGUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGxlbmd0aCwgcHJvcHMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmaW5kQnVmZmVyU2l6ZShtYXhTaXplLCBpblJlcGVhdCkge1xuICAgICAgICAvLyBTY2FuIHRocm91Z2ggdGhlIGJ1ZmZlciB0byBmaW5kIHByZXZpb3VzIHNpYmxpbmdzIHRoYXQgZml0XG4gICAgICAgIC8vIHRvZ2V0aGVyIGluIGEgVHJlZUJ1ZmZlciwgYW5kIGRvbid0IGNvbnRhaW4gYW55IHJldXNlZCBub2Rlc1xuICAgICAgICAvLyAod2hpY2ggY2FuJ3QgYmUgc3RvcmVkIGluIGEgYnVmZmVyKS5cbiAgICAgICAgLy8gSWYgYGluUmVwZWF0YCBpcyA+IC0xLCBpZ25vcmUgbm9kZSBib3VuZGFyaWVzIG9mIHRoYXQgdHlwZSBmb3JcbiAgICAgICAgLy8gbmVzdGluZywgYnV0IG1ha2Ugc3VyZSB0aGUgZW5kIGZhbGxzIGVpdGhlciBhdCB0aGUgc3RhcnRcbiAgICAgICAgLy8gKGBtYXhTaXplYCkgb3IgYmVmb3JlIHN1Y2ggYSBub2RlLlxuICAgICAgICBsZXQgZm9yayA9IGN1cnNvci5mb3JrKCk7XG4gICAgICAgIGxldCBzaXplID0gMCwgc3RhcnQgPSAwLCBza2lwID0gMCwgbWluU3RhcnQgPSBmb3JrLmVuZCAtIG1heEJ1ZmZlckxlbmd0aDtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgc2l6ZTogMCwgc3RhcnQ6IDAsIHNraXA6IDAgfTtcbiAgICAgICAgc2NhbjogZm9yIChsZXQgbWluUG9zID0gZm9yay5wb3MgLSBtYXhTaXplOyBmb3JrLnBvcyA+IG1pblBvczspIHtcbiAgICAgICAgICAgIGxldCBub2RlU2l6ZSA9IGZvcmsuc2l6ZTtcbiAgICAgICAgICAgIC8vIFByZXRlbmQgbmVzdGVkIHJlcGVhdCBub2RlcyBvZiB0aGUgc2FtZSB0eXBlIGRvbid0IGV4aXN0XG4gICAgICAgICAgICBpZiAoZm9yay5pZCA9PSBpblJlcGVhdCAmJiBub2RlU2l6ZSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gRXhjZXB0IHRoYXQgd2Ugc3RvcmUgdGhlIGN1cnJlbnQgc3RhdGUgYXMgYSB2YWxpZCByZXR1cm5cbiAgICAgICAgICAgICAgICAvLyB2YWx1ZS5cbiAgICAgICAgICAgICAgICByZXN1bHQuc2l6ZSA9IHNpemU7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnNraXAgPSBza2lwO1xuICAgICAgICAgICAgICAgIHNraXAgKz0gNDtcbiAgICAgICAgICAgICAgICBzaXplICs9IDQ7XG4gICAgICAgICAgICAgICAgZm9yay5uZXh0KCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgc3RhcnRQb3MgPSBmb3JrLnBvcyAtIG5vZGVTaXplO1xuICAgICAgICAgICAgaWYgKG5vZGVTaXplIDwgMCB8fCBzdGFydFBvcyA8IG1pblBvcyB8fCBmb3JrLnN0YXJ0IDwgbWluU3RhcnQpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBsZXQgbG9jYWxTa2lwcGVkID0gZm9yay5pZCA+PSBtaW5SZXBlYXRUeXBlID8gNCA6IDA7XG4gICAgICAgICAgICBsZXQgbm9kZVN0YXJ0ID0gZm9yay5zdGFydDtcbiAgICAgICAgICAgIGZvcmsubmV4dCgpO1xuICAgICAgICAgICAgd2hpbGUgKGZvcmsucG9zID4gc3RhcnRQb3MpIHtcbiAgICAgICAgICAgICAgICBpZiAoZm9yay5zaXplIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZm9yay5zaXplID09IC0zIC8qIFNwZWNpYWxSZWNvcmQuQ29udGV4dENoYW5nZSAqLylcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsU2tpcHBlZCArPSA0O1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhayBzY2FuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmb3JrLmlkID49IG1pblJlcGVhdFR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxTa2lwcGVkICs9IDQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvcmsubmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhcnQgPSBub2RlU3RhcnQ7XG4gICAgICAgICAgICBzaXplICs9IG5vZGVTaXplO1xuICAgICAgICAgICAgc2tpcCArPSBsb2NhbFNraXBwZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluUmVwZWF0IDwgMCB8fCBzaXplID09IG1heFNpemUpIHtcbiAgICAgICAgICAgIHJlc3VsdC5zaXplID0gc2l6ZTtcbiAgICAgICAgICAgIHJlc3VsdC5zdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgcmVzdWx0LnNraXAgPSBza2lwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQuc2l6ZSA+IDQgPyByZXN1bHQgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvcHlUb0J1ZmZlcihidWZmZXJTdGFydCwgYnVmZmVyLCBpbmRleCkge1xuICAgICAgICBsZXQgeyBpZCwgc3RhcnQsIGVuZCwgc2l6ZSB9ID0gY3Vyc29yO1xuICAgICAgICBjdXJzb3IubmV4dCgpO1xuICAgICAgICBpZiAoc2l6ZSA+PSAwICYmIGlkIDwgbWluUmVwZWF0VHlwZSkge1xuICAgICAgICAgICAgbGV0IHN0YXJ0SW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgIGlmIChzaXplID4gNCkge1xuICAgICAgICAgICAgICAgIGxldCBlbmRQb3MgPSBjdXJzb3IucG9zIC0gKHNpemUgLSA0KTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoY3Vyc29yLnBvcyA+IGVuZFBvcylcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBjb3B5VG9CdWZmZXIoYnVmZmVyU3RhcnQsIGJ1ZmZlciwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVmZmVyWy0taW5kZXhdID0gc3RhcnRJbmRleDtcbiAgICAgICAgICAgIGJ1ZmZlclstLWluZGV4XSA9IGVuZCAtIGJ1ZmZlclN0YXJ0O1xuICAgICAgICAgICAgYnVmZmVyWy0taW5kZXhdID0gc3RhcnQgLSBidWZmZXJTdGFydDtcbiAgICAgICAgICAgIGJ1ZmZlclstLWluZGV4XSA9IGlkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNpemUgPT0gLTMgLyogU3BlY2lhbFJlY29yZC5Db250ZXh0Q2hhbmdlICovKSB7XG4gICAgICAgICAgICBjb250ZXh0SGFzaCA9IGlkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNpemUgPT0gLTQgLyogU3BlY2lhbFJlY29yZC5Mb29rQWhlYWQgKi8pIHtcbiAgICAgICAgICAgIGxvb2tBaGVhZCA9IGlkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gICAgbGV0IGNoaWxkcmVuID0gW10sIHBvc2l0aW9ucyA9IFtdO1xuICAgIHdoaWxlIChjdXJzb3IucG9zID4gMClcbiAgICAgICAgdGFrZU5vZGUoZGF0YS5zdGFydCB8fCAwLCBkYXRhLmJ1ZmZlclN0YXJ0IHx8IDAsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIC0xLCAwKTtcbiAgICBsZXQgbGVuZ3RoID0gKF9hID0gZGF0YS5sZW5ndGgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChjaGlsZHJlbi5sZW5ndGggPyBwb3NpdGlvbnNbMF0gKyBjaGlsZHJlblswXS5sZW5ndGggOiAwKTtcbiAgICByZXR1cm4gbmV3IFRyZWUodHlwZXNbZGF0YS50b3BJRF0sIGNoaWxkcmVuLnJldmVyc2UoKSwgcG9zaXRpb25zLnJldmVyc2UoKSwgbGVuZ3RoKTtcbn1cbmNvbnN0IG5vZGVTaXplQ2FjaGUgPSBuZXcgV2Vha01hcDtcbmZ1bmN0aW9uIG5vZGVTaXplKGJhbGFuY2VUeXBlLCBub2RlKSB7XG4gICAgaWYgKCFiYWxhbmNlVHlwZS5pc0Fub255bW91cyB8fCBub2RlIGluc3RhbmNlb2YgVHJlZUJ1ZmZlciB8fCBub2RlLnR5cGUgIT0gYmFsYW5jZVR5cGUpXG4gICAgICAgIHJldHVybiAxO1xuICAgIGxldCBzaXplID0gbm9kZVNpemVDYWNoZS5nZXQobm9kZSk7XG4gICAgaWYgKHNpemUgPT0gbnVsbCkge1xuICAgICAgICBzaXplID0gMTtcbiAgICAgICAgZm9yIChsZXQgY2hpbGQgb2Ygbm9kZS5jaGlsZHJlbikge1xuICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUgIT0gYmFsYW5jZVR5cGUgfHwgIShjaGlsZCBpbnN0YW5jZW9mIFRyZWUpKSB7XG4gICAgICAgICAgICAgICAgc2l6ZSA9IDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzaXplICs9IG5vZGVTaXplKGJhbGFuY2VUeXBlLCBjaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZVNpemVDYWNoZS5zZXQobm9kZSwgc2l6ZSk7XG4gICAgfVxuICAgIHJldHVybiBzaXplO1xufVxuZnVuY3Rpb24gYmFsYW5jZVJhbmdlKFxuLy8gVGhlIHR5cGUgdGhlIGJhbGFuY2VkIHRyZWUncyBpbm5lciBub2Rlcy5cbmJhbGFuY2VUeXBlLCBcbi8vIFRoZSBkaXJlY3QgY2hpbGRyZW4gYW5kIHRoZWlyIHBvc2l0aW9uc1xuY2hpbGRyZW4sIHBvc2l0aW9ucywgXG4vLyBUaGUgaW5kZXggcmFuZ2UgaW4gY2hpbGRyZW4vcG9zaXRpb25zIHRvIHVzZVxuZnJvbSwgdG8sIFxuLy8gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSBub2RlcywgcmVsYXRpdmUgdG8gdGhlaXIgcGFyZW50Llxuc3RhcnQsIFxuLy8gTGVuZ3RoIG9mIHRoZSBvdXRlciBub2RlXG5sZW5ndGgsIFxuLy8gRnVuY3Rpb24gdG8gYnVpbGQgdGhlIHRvcCBub2RlIG9mIHRoZSBiYWxhbmNlZCB0cmVlXG5ta1RvcCwgXG4vLyBGdW5jdGlvbiB0byBidWlsZCBpbnRlcm5hbCBub2RlcyBmb3IgdGhlIGJhbGFuY2VkIHRyZWVcbm1rVHJlZSkge1xuICAgIGxldCB0b3RhbCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IGZyb207IGkgPCB0bzsgaSsrKVxuICAgICAgICB0b3RhbCArPSBub2RlU2l6ZShiYWxhbmNlVHlwZSwgY2hpbGRyZW5baV0pO1xuICAgIGxldCBtYXhDaGlsZCA9IE1hdGguY2VpbCgodG90YWwgKiAxLjUpIC8gOCAvKiBCYWxhbmNlLkJyYW5jaEZhY3RvciAqLyk7XG4gICAgbGV0IGxvY2FsQ2hpbGRyZW4gPSBbXSwgbG9jYWxQb3NpdGlvbnMgPSBbXTtcbiAgICBmdW5jdGlvbiBkaXZpZGUoY2hpbGRyZW4sIHBvc2l0aW9ucywgZnJvbSwgdG8sIG9mZnNldCkge1xuICAgICAgICBmb3IgKGxldCBpID0gZnJvbTsgaSA8IHRvOykge1xuICAgICAgICAgICAgbGV0IGdyb3VwRnJvbSA9IGksIGdyb3VwU3RhcnQgPSBwb3NpdGlvbnNbaV0sIGdyb3VwU2l6ZSA9IG5vZGVTaXplKGJhbGFuY2VUeXBlLCBjaGlsZHJlbltpXSk7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBmb3IgKDsgaSA8IHRvOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dFNpemUgPSBub2RlU2l6ZShiYWxhbmNlVHlwZSwgY2hpbGRyZW5baV0pO1xuICAgICAgICAgICAgICAgIGlmIChncm91cFNpemUgKyBuZXh0U2l6ZSA+PSBtYXhDaGlsZClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZ3JvdXBTaXplICs9IG5leHRTaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgPT0gZ3JvdXBGcm9tICsgMSkge1xuICAgICAgICAgICAgICAgIGlmIChncm91cFNpemUgPiBtYXhDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgb25seSA9IGNoaWxkcmVuW2dyb3VwRnJvbV07IC8vIE9ubHkgdHJlZXMgY2FuIGhhdmUgYSBzaXplID4gMVxuICAgICAgICAgICAgICAgICAgICBkaXZpZGUob25seS5jaGlsZHJlbiwgb25seS5wb3NpdGlvbnMsIDAsIG9ubHkuY2hpbGRyZW4ubGVuZ3RoLCBwb3NpdGlvbnNbZ3JvdXBGcm9tXSArIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsb2NhbENoaWxkcmVuLnB1c2goY2hpbGRyZW5bZ3JvdXBGcm9tXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgbGVuZ3RoID0gcG9zaXRpb25zW2kgLSAxXSArIGNoaWxkcmVuW2kgLSAxXS5sZW5ndGggLSBncm91cFN0YXJ0O1xuICAgICAgICAgICAgICAgIGxvY2FsQ2hpbGRyZW4ucHVzaChiYWxhbmNlUmFuZ2UoYmFsYW5jZVR5cGUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGdyb3VwRnJvbSwgaSwgZ3JvdXBTdGFydCwgbGVuZ3RoLCBudWxsLCBta1RyZWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvY2FsUG9zaXRpb25zLnB1c2goZ3JvdXBTdGFydCArIG9mZnNldCAtIHN0YXJ0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkaXZpZGUoY2hpbGRyZW4sIHBvc2l0aW9ucywgZnJvbSwgdG8sIDApO1xuICAgIHJldHVybiAobWtUb3AgfHwgbWtUcmVlKShsb2NhbENoaWxkcmVuLCBsb2NhbFBvc2l0aW9ucywgbGVuZ3RoKTtcbn1cbi8qKlxuUHJvdmlkZXMgYSB3YXkgdG8gYXNzb2NpYXRlIHZhbHVlcyB3aXRoIHBpZWNlcyBvZiB0cmVlcy4gQXMgbG9uZ1xuYXMgdGhhdCBwYXJ0IG9mIHRoZSB0cmVlIGlzIHJldXNlZCwgdGhlIGFzc29jaWF0ZWQgdmFsdWVzIGNhbiBiZVxucmV0cmlldmVkIGZyb20gYW4gdXBkYXRlZCB0cmVlLlxuKi9cbmNsYXNzIE5vZGVXZWFrTWFwIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5tYXAgPSBuZXcgV2Vha01hcCgpO1xuICAgIH1cbiAgICBzZXRCdWZmZXIoYnVmZmVyLCBpbmRleCwgdmFsdWUpIHtcbiAgICAgICAgbGV0IGlubmVyID0gdGhpcy5tYXAuZ2V0KGJ1ZmZlcik7XG4gICAgICAgIGlmICghaW5uZXIpXG4gICAgICAgICAgICB0aGlzLm1hcC5zZXQoYnVmZmVyLCBpbm5lciA9IG5ldyBNYXApO1xuICAgICAgICBpbm5lci5zZXQoaW5kZXgsIHZhbHVlKTtcbiAgICB9XG4gICAgZ2V0QnVmZmVyKGJ1ZmZlciwgaW5kZXgpIHtcbiAgICAgICAgbGV0IGlubmVyID0gdGhpcy5tYXAuZ2V0KGJ1ZmZlcik7XG4gICAgICAgIHJldHVybiBpbm5lciAmJiBpbm5lci5nZXQoaW5kZXgpO1xuICAgIH1cbiAgICAvKipcbiAgICBTZXQgdGhlIHZhbHVlIGZvciB0aGlzIHN5bnRheCBub2RlLlxuICAgICovXG4gICAgc2V0KG5vZGUsIHZhbHVlKSB7XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQnVmZmVyTm9kZSlcbiAgICAgICAgICAgIHRoaXMuc2V0QnVmZmVyKG5vZGUuY29udGV4dC5idWZmZXIsIG5vZGUuaW5kZXgsIHZhbHVlKTtcbiAgICAgICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIFRyZWVOb2RlKVxuICAgICAgICAgICAgdGhpcy5tYXAuc2V0KG5vZGUudHJlZSwgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXRyaWV2ZSB2YWx1ZSBmb3IgdGhpcyBzeW50YXggbm9kZSwgaWYgaXQgZXhpc3RzIGluIHRoZSBtYXAuXG4gICAgKi9cbiAgICBnZXQobm9kZSkge1xuICAgICAgICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIEJ1ZmZlck5vZGUgPyB0aGlzLmdldEJ1ZmZlcihub2RlLmNvbnRleHQuYnVmZmVyLCBub2RlLmluZGV4KVxuICAgICAgICAgICAgOiBub2RlIGluc3RhbmNlb2YgVHJlZU5vZGUgPyB0aGlzLm1hcC5nZXQobm9kZS50cmVlKSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgU2V0IHRoZSB2YWx1ZSBmb3IgdGhlIG5vZGUgdGhhdCBhIGN1cnNvciBjdXJyZW50bHkgcG9pbnRzIHRvLlxuICAgICovXG4gICAgY3Vyc29yU2V0KGN1cnNvciwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGN1cnNvci5idWZmZXIpXG4gICAgICAgICAgICB0aGlzLnNldEJ1ZmZlcihjdXJzb3IuYnVmZmVyLmJ1ZmZlciwgY3Vyc29yLmluZGV4LCB2YWx1ZSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMubWFwLnNldChjdXJzb3IudHJlZSwgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXRyaWV2ZSB0aGUgdmFsdWUgZm9yIHRoZSBub2RlIHRoYXQgYSBjdXJzb3IgY3VycmVudGx5IHBvaW50c1xuICAgIHRvLlxuICAgICovXG4gICAgY3Vyc29yR2V0KGN1cnNvcikge1xuICAgICAgICByZXR1cm4gY3Vyc29yLmJ1ZmZlciA/IHRoaXMuZ2V0QnVmZmVyKGN1cnNvci5idWZmZXIuYnVmZmVyLCBjdXJzb3IuaW5kZXgpIDogdGhpcy5tYXAuZ2V0KGN1cnNvci50cmVlKTtcbiAgICB9XG59XG5cbi8qKlxuVHJlZSBmcmFnbWVudHMgYXJlIHVzZWQgZHVyaW5nIFtpbmNyZW1lbnRhbFxucGFyc2luZ10oI2NvbW1vbi5QYXJzZXIuc3RhcnRQYXJzZSkgdG8gdHJhY2sgcGFydHMgb2Ygb2xkIHRyZWVzXG50aGF0IGNhbiBiZSByZXVzZWQgaW4gYSBuZXcgcGFyc2UuIEFuIGFycmF5IG9mIGZyYWdtZW50cyBpcyB1c2VkXG50byB0cmFjayByZWdpb25zIG9mIGFuIG9sZCB0cmVlIHdob3NlIG5vZGVzIG1pZ2h0IGJlIHJldXNlZCBpbiBuZXdcbnBhcnNlcy4gVXNlIHRoZSBzdGF0aWNcbltgYXBwbHlDaGFuZ2VzYF0oI2NvbW1vbi5UcmVlRnJhZ21lbnReYXBwbHlDaGFuZ2VzKSBtZXRob2QgdG9cbnVwZGF0ZSBmcmFnbWVudHMgZm9yIGRvY3VtZW50IGNoYW5nZXMuXG4qL1xuY2xhc3MgVHJlZUZyYWdtZW50IHtcbiAgICAvKipcbiAgICBDb25zdHJ1Y3QgYSB0cmVlIGZyYWdtZW50LiBZb3UnbGwgdXN1YWxseSB3YW50IHRvIHVzZVxuICAgIFtgYWRkVHJlZWBdKCNjb21tb24uVHJlZUZyYWdtZW50XmFkZFRyZWUpIGFuZFxuICAgIFtgYXBwbHlDaGFuZ2VzYF0oI2NvbW1vbi5UcmVlRnJhZ21lbnReYXBwbHlDaGFuZ2VzKSBpbnN0ZWFkIG9mXG4gICAgY2FsbGluZyB0aGlzIGRpcmVjdGx5LlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHN0YXJ0IG9mIHRoZSB1bmNoYW5nZWQgcmFuZ2UgcG9pbnRlZCB0byBieSB0aGlzIGZyYWdtZW50LlxuICAgIFRoaXMgcmVmZXJzIHRvIGFuIG9mZnNldCBpbiB0aGUgX3VwZGF0ZWRfIGRvY3VtZW50IChhcyBvcHBvc2VkXG4gICAgdG8gdGhlIG9yaWdpbmFsIHRyZWUpLlxuICAgICovXG4gICAgZnJvbSwgXG4gICAgLyoqXG4gICAgVGhlIGVuZCBvZiB0aGUgdW5jaGFuZ2VkIHJhbmdlLlxuICAgICovXG4gICAgdG8sIFxuICAgIC8qKlxuICAgIFRoZSB0cmVlIHRoYXQgdGhpcyBmcmFnbWVudCBpcyBiYXNlZCBvbi5cbiAgICAqL1xuICAgIHRyZWUsIFxuICAgIC8qKlxuICAgIFRoZSBvZmZzZXQgYmV0d2VlbiB0aGUgZnJhZ21lbnQncyB0cmVlIGFuZCB0aGUgZG9jdW1lbnQgdGhhdFxuICAgIHRoaXMgZnJhZ21lbnQgY2FuIGJlIHVzZWQgYWdhaW5zdC4gQWRkIHRoaXMgd2hlbiBnb2luZyBmcm9tXG4gICAgZG9jdW1lbnQgdG8gdHJlZSBwb3NpdGlvbnMsIHN1YnRyYWN0IGl0IHRvIGdvIGZyb20gdHJlZSB0b1xuICAgIGRvY3VtZW50IHBvc2l0aW9ucy5cbiAgICAqL1xuICAgIG9mZnNldCwgb3BlblN0YXJ0ID0gZmFsc2UsIG9wZW5FbmQgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMudHJlZSA9IHRyZWU7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICB0aGlzLm9wZW4gPSAob3BlblN0YXJ0ID8gMSAvKiBPcGVuLlN0YXJ0ICovIDogMCkgfCAob3BlbkVuZCA/IDIgLyogT3Blbi5FbmQgKi8gOiAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgV2hldGhlciB0aGUgc3RhcnQgb2YgdGhlIGZyYWdtZW50IHJlcHJlc2VudHMgdGhlIHN0YXJ0IG9mIGFcbiAgICBwYXJzZSwgb3IgdGhlIGVuZCBvZiBhIGNoYW5nZS4gKEluIHRoZSBzZWNvbmQgY2FzZSwgaXQgbWF5IG5vdFxuICAgIGJlIHNhZmUgdG8gcmV1c2Ugc29tZSBub2RlcyBhdCB0aGUgc3RhcnQsIGRlcGVuZGluZyBvbiB0aGVcbiAgICBwYXJzaW5nIGFsZ29yaXRobS4pXG4gICAgKi9cbiAgICBnZXQgb3BlblN0YXJ0KCkgeyByZXR1cm4gKHRoaXMub3BlbiAmIDEgLyogT3Blbi5TdGFydCAqLykgPiAwOyB9XG4gICAgLyoqXG4gICAgV2hldGhlciB0aGUgZW5kIG9mIHRoZSBmcmFnbWVudCByZXByZXNlbnRzIHRoZSBlbmQgb2YgYVxuICAgIGZ1bGwtZG9jdW1lbnQgcGFyc2UsIG9yIHRoZSBzdGFydCBvZiBhIGNoYW5nZS5cbiAgICAqL1xuICAgIGdldCBvcGVuRW5kKCkgeyByZXR1cm4gKHRoaXMub3BlbiAmIDIgLyogT3Blbi5FbmQgKi8pID4gMDsgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHNldCBvZiBmcmFnbWVudHMgZnJvbSBhIGZyZXNobHkgcGFyc2VkIHRyZWUsIG9yIHVwZGF0ZVxuICAgIGFuIGV4aXN0aW5nIHNldCBvZiBmcmFnbWVudHMgYnkgcmVwbGFjaW5nIHRoZSBvbmVzIHRoYXQgb3ZlcmxhcFxuICAgIHdpdGggYSB0cmVlIHdpdGggY29udGVudCBmcm9tIHRoZSBuZXcgdHJlZS4gV2hlbiBgcGFydGlhbGAgaXNcbiAgICB0cnVlLCB0aGUgcGFyc2UgaXMgdHJlYXRlZCBhcyBpbmNvbXBsZXRlLCBhbmQgdGhlIHJlc3VsdGluZ1xuICAgIGZyYWdtZW50IGhhcyBbYG9wZW5FbmRgXSgjY29tbW9uLlRyZWVGcmFnbWVudC5vcGVuRW5kKSBzZXQgdG9cbiAgICB0cnVlLlxuICAgICovXG4gICAgc3RhdGljIGFkZFRyZWUodHJlZSwgZnJhZ21lbnRzID0gW10sIHBhcnRpYWwgPSBmYWxzZSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gW25ldyBUcmVlRnJhZ21lbnQoMCwgdHJlZS5sZW5ndGgsIHRyZWUsIDAsIGZhbHNlLCBwYXJ0aWFsKV07XG4gICAgICAgIGZvciAobGV0IGYgb2YgZnJhZ21lbnRzKVxuICAgICAgICAgICAgaWYgKGYudG8gPiB0cmVlLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChmKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgQXBwbHkgYSBzZXQgb2YgZWRpdHMgdG8gYW4gYXJyYXkgb2YgZnJhZ21lbnRzLCByZW1vdmluZyBvclxuICAgIHNwbGl0dGluZyBmcmFnbWVudHMgYXMgbmVjZXNzYXJ5IHRvIHJlbW92ZSBlZGl0ZWQgcmFuZ2VzLCBhbmRcbiAgICBhZGp1c3Rpbmcgb2Zmc2V0cyBmb3IgZnJhZ21lbnRzIHRoYXQgbW92ZWQuXG4gICAgKi9cbiAgICBzdGF0aWMgYXBwbHlDaGFuZ2VzKGZyYWdtZW50cywgY2hhbmdlcywgbWluR2FwID0gMTI4KSB7XG4gICAgICAgIGlmICghY2hhbmdlcy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZnJhZ21lbnRzO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGxldCBmSSA9IDEsIG5leHRGID0gZnJhZ21lbnRzLmxlbmd0aCA/IGZyYWdtZW50c1swXSA6IG51bGw7XG4gICAgICAgIGZvciAobGV0IGNJID0gMCwgcG9zID0gMCwgb2ZmID0gMDs7IGNJKyspIHtcbiAgICAgICAgICAgIGxldCBuZXh0QyA9IGNJIDwgY2hhbmdlcy5sZW5ndGggPyBjaGFuZ2VzW2NJXSA6IG51bGw7XG4gICAgICAgICAgICBsZXQgbmV4dFBvcyA9IG5leHRDID8gbmV4dEMuZnJvbUEgOiAxZTk7XG4gICAgICAgICAgICBpZiAobmV4dFBvcyAtIHBvcyA+PSBtaW5HYXApXG4gICAgICAgICAgICAgICAgd2hpbGUgKG5leHRGICYmIG5leHRGLmZyb20gPCBuZXh0UG9zKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjdXQgPSBuZXh0RjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcyA+PSBjdXQuZnJvbSB8fCBuZXh0UG9zIDw9IGN1dC50byB8fCBvZmYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmRnJvbSA9IE1hdGgubWF4KGN1dC5mcm9tLCBwb3MpIC0gb2ZmLCBmVG8gPSBNYXRoLm1pbihjdXQudG8sIG5leHRQb3MpIC0gb2ZmO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3V0ID0gZkZyb20gPj0gZlRvID8gbnVsbCA6IG5ldyBUcmVlRnJhZ21lbnQoZkZyb20sIGZUbywgY3V0LnRyZWUsIGN1dC5vZmZzZXQgKyBvZmYsIGNJID4gMCwgISFuZXh0Qyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1dClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGN1dCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0Ri50byA+IG5leHRQb3MpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgbmV4dEYgPSBmSSA8IGZyYWdtZW50cy5sZW5ndGggPyBmcmFnbWVudHNbZkkrK10gOiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbmV4dEMpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBwb3MgPSBuZXh0Qy50b0E7XG4gICAgICAgICAgICBvZmYgPSBuZXh0Qy50b0EgLSBuZXh0Qy50b0I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG4vKipcbkEgc3VwZXJjbGFzcyB0aGF0IHBhcnNlcnMgc2hvdWxkIGV4dGVuZC5cbiovXG5jbGFzcyBQYXJzZXIge1xuICAgIC8qKlxuICAgIFN0YXJ0IGEgcGFyc2UsIHJldHVybmluZyBhIFtwYXJ0aWFsIHBhcnNlXSgjY29tbW9uLlBhcnRpYWxQYXJzZSlcbiAgICBvYmplY3QuIFtgZnJhZ21lbnRzYF0oI2NvbW1vbi5UcmVlRnJhZ21lbnQpIGNhbiBiZSBwYXNzZWQgaW4gdG9cbiAgICBtYWtlIHRoZSBwYXJzZSBpbmNyZW1lbnRhbC5cbiAgICBcbiAgICBCeSBkZWZhdWx0LCB0aGUgZW50aXJlIGlucHV0IGlzIHBhcnNlZC4gWW91IGNhbiBwYXNzIGByYW5nZXNgLFxuICAgIHdoaWNoIHNob3VsZCBiZSBhIHNvcnRlZCBhcnJheSBvZiBub24tZW1wdHksIG5vbi1vdmVybGFwcGluZ1xuICAgIHJhbmdlcywgdG8gcGFyc2Ugb25seSB0aG9zZSByYW5nZXMuIFRoZSB0cmVlIHJldHVybmVkIGluIHRoYXRcbiAgICBjYXNlIHdpbGwgc3RhcnQgYXQgYHJhbmdlc1swXS5mcm9tYC5cbiAgICAqL1xuICAgIHN0YXJ0UGFyc2UoaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIGlucHV0ID0gbmV3IFN0cmluZ0lucHV0KGlucHV0KTtcbiAgICAgICAgcmFuZ2VzID0gIXJhbmdlcyA/IFtuZXcgUmFuZ2UoMCwgaW5wdXQubGVuZ3RoKV0gOiByYW5nZXMubGVuZ3RoID8gcmFuZ2VzLm1hcChyID0+IG5ldyBSYW5nZShyLmZyb20sIHIudG8pKSA6IFtuZXcgUmFuZ2UoMCwgMCldO1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVQYXJzZShpbnB1dCwgZnJhZ21lbnRzIHx8IFtdLCByYW5nZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICBSdW4gYSBmdWxsIHBhcnNlLCByZXR1cm5pbmcgdGhlIHJlc3VsdGluZyB0cmVlLlxuICAgICovXG4gICAgcGFyc2UoaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKSB7XG4gICAgICAgIGxldCBwYXJzZSA9IHRoaXMuc3RhcnRQYXJzZShpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgZG9uZSA9IHBhcnNlLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIGlmIChkb25lKVxuICAgICAgICAgICAgICAgIHJldHVybiBkb25lO1xuICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgU3RyaW5nSW5wdXQge1xuICAgIGNvbnN0cnVjdG9yKHN0cmluZykge1xuICAgICAgICB0aGlzLnN0cmluZyA9IHN0cmluZztcbiAgICB9XG4gICAgZ2V0IGxlbmd0aCgpIHsgcmV0dXJuIHRoaXMuc3RyaW5nLmxlbmd0aDsgfVxuICAgIGNodW5rKGZyb20pIHsgcmV0dXJuIHRoaXMuc3RyaW5nLnNsaWNlKGZyb20pOyB9XG4gICAgZ2V0IGxpbmVDaHVua3MoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIHJlYWQoZnJvbSwgdG8pIHsgcmV0dXJuIHRoaXMuc3RyaW5nLnNsaWNlKGZyb20sIHRvKTsgfVxufVxuXG4vKipcbkNyZWF0ZSBhIHBhcnNlIHdyYXBwZXIgdGhhdCwgYWZ0ZXIgdGhlIGlubmVyIHBhcnNlIGNvbXBsZXRlcyxcbnNjYW5zIGl0cyB0cmVlIGZvciBtaXhlZCBsYW5ndWFnZSByZWdpb25zIHdpdGggdGhlIGBuZXN0YFxuZnVuY3Rpb24sIHJ1bnMgdGhlIHJlc3VsdGluZyBbaW5uZXIgcGFyc2VzXSgjY29tbW9uLk5lc3RlZFBhcnNlKSxcbmFuZCB0aGVuIFttb3VudHNdKCNjb21tb24uTm9kZVByb3BebW91bnRlZCkgdGhlaXIgcmVzdWx0cyBvbnRvIHRoZVxudHJlZS5cbiovXG5mdW5jdGlvbiBwYXJzZU1peGVkKG5lc3QpIHtcbiAgICByZXR1cm4gKHBhcnNlLCBpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpID0+IG5ldyBNaXhlZFBhcnNlKHBhcnNlLCBuZXN0LCBpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpO1xufVxuY2xhc3MgSW5uZXJQYXJzZSB7XG4gICAgY29uc3RydWN0b3IocGFyc2VyLCBwYXJzZSwgb3ZlcmxheSwgdGFyZ2V0LCBmcm9tKSB7XG4gICAgICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgICAgICB0aGlzLnBhcnNlID0gcGFyc2U7XG4gICAgICAgIHRoaXMub3ZlcmxheSA9IG92ZXJsYXk7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNoZWNrUmFuZ2VzKHJhbmdlcykge1xuICAgIGlmICghcmFuZ2VzLmxlbmd0aCB8fCByYW5nZXMuc29tZShyID0+IHIuZnJvbSA+PSByLnRvKSlcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlubmVyIHBhcnNlIHJhbmdlcyBnaXZlbjogXCIgKyBKU09OLnN0cmluZ2lmeShyYW5nZXMpKTtcbn1cbmNsYXNzIEFjdGl2ZU92ZXJsYXkge1xuICAgIGNvbnN0cnVjdG9yKHBhcnNlciwgcHJlZGljYXRlLCBtb3VudHMsIGluZGV4LCBzdGFydCwgdGFyZ2V0LCBwcmV2KSB7XG4gICAgICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgICAgICB0aGlzLnByZWRpY2F0ZSA9IHByZWRpY2F0ZTtcbiAgICAgICAgdGhpcy5tb3VudHMgPSBtb3VudHM7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgdGhpcy5wcmV2ID0gcHJldjtcbiAgICAgICAgdGhpcy5kZXB0aCA9IDA7XG4gICAgICAgIHRoaXMucmFuZ2VzID0gW107XG4gICAgfVxufVxuY29uc3Qgc3RvcHBlZElubmVyID0gbmV3IE5vZGVQcm9wKHsgcGVyTm9kZTogdHJ1ZSB9KTtcbmNsYXNzIE1peGVkUGFyc2Uge1xuICAgIGNvbnN0cnVjdG9yKGJhc2UsIG5lc3QsIGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcykge1xuICAgICAgICB0aGlzLm5lc3QgPSBuZXN0O1xuICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRzID0gZnJhZ21lbnRzO1xuICAgICAgICB0aGlzLnJhbmdlcyA9IHJhbmdlcztcbiAgICAgICAgdGhpcy5pbm5lciA9IFtdO1xuICAgICAgICB0aGlzLmlubmVyRG9uZSA9IDA7XG4gICAgICAgIHRoaXMuYmFzZVRyZWUgPSBudWxsO1xuICAgICAgICB0aGlzLnN0b3BwZWRBdCA9IG51bGw7XG4gICAgICAgIHRoaXMuYmFzZVBhcnNlID0gYmFzZTtcbiAgICB9XG4gICAgYWR2YW5jZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuYmFzZVBhcnNlKSB7XG4gICAgICAgICAgICBsZXQgZG9uZSA9IHRoaXMuYmFzZVBhcnNlLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIGlmICghZG9uZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuYmFzZVBhcnNlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuYmFzZVRyZWUgPSBkb25lO1xuICAgICAgICAgICAgdGhpcy5zdGFydElubmVyKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5zdG9wcGVkQXQgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpbm5lciBvZiB0aGlzLmlubmVyKVxuICAgICAgICAgICAgICAgICAgICBpbm5lci5wYXJzZS5zdG9wQXQodGhpcy5zdG9wcGVkQXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlubmVyRG9uZSA9PSB0aGlzLmlubmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMuYmFzZVRyZWU7XG4gICAgICAgICAgICBpZiAodGhpcy5zdG9wcGVkQXQgIT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgVHJlZShyZXN1bHQudHlwZSwgcmVzdWx0LmNoaWxkcmVuLCByZXN1bHQucG9zaXRpb25zLCByZXN1bHQubGVuZ3RoLCByZXN1bHQucHJvcFZhbHVlcy5jb25jYXQoW1tzdG9wcGVkSW5uZXIsIHRoaXMuc3RvcHBlZEF0XV0pKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGlubmVyID0gdGhpcy5pbm5lclt0aGlzLmlubmVyRG9uZV0sIGRvbmUgPSBpbm5lci5wYXJzZS5hZHZhbmNlKCk7XG4gICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICB0aGlzLmlubmVyRG9uZSsrO1xuICAgICAgICAgICAgLy8gVGhpcyBpcyBhIHNvbWV3aGF0IGRvZGd5IGJ1dCBzdXBlciBoZWxwZnVsIGhhY2sgd2hlcmUgd2VcbiAgICAgICAgICAgIC8vIHBhdGNoIHVwIG5vZGVzIGNyZWF0ZWQgYnkgdGhlIGlubmVyIHBhcnNlIChhbmQgdGh1c1xuICAgICAgICAgICAgLy8gcHJlc3VtYWJseSBub3QgYWxpYXNlZCBhbnl3aGVyZSBlbHNlKSB0byBob2xkIHRoZSBpbmZvcm1hdGlvblxuICAgICAgICAgICAgLy8gYWJvdXQgdGhlIGlubmVyIHBhcnNlLlxuICAgICAgICAgICAgbGV0IHByb3BzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCBpbm5lci50YXJnZXQucHJvcHMpO1xuICAgICAgICAgICAgcHJvcHNbTm9kZVByb3AubW91bnRlZC5pZF0gPSBuZXcgTW91bnRlZFRyZWUoZG9uZSwgaW5uZXIub3ZlcmxheSwgaW5uZXIucGFyc2VyKTtcbiAgICAgICAgICAgIGlubmVyLnRhcmdldC5wcm9wcyA9IHByb3BzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBnZXQgcGFyc2VkUG9zKCkge1xuICAgICAgICBpZiAodGhpcy5iYXNlUGFyc2UpXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgbGV0IHBvcyA9IHRoaXMuaW5wdXQubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5pbm5lckRvbmU7IGkgPCB0aGlzLmlubmVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pbm5lcltpXS5mcm9tIDwgcG9zKVxuICAgICAgICAgICAgICAgIHBvcyA9IE1hdGgubWluKHBvcywgdGhpcy5pbm5lcltpXS5wYXJzZS5wYXJzZWRQb3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgfVxuICAgIHN0b3BBdChwb3MpIHtcbiAgICAgICAgdGhpcy5zdG9wcGVkQXQgPSBwb3M7XG4gICAgICAgIGlmICh0aGlzLmJhc2VQYXJzZSlcbiAgICAgICAgICAgIHRoaXMuYmFzZVBhcnNlLnN0b3BBdChwb3MpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5pbm5lckRvbmU7IGkgPCB0aGlzLmlubmVyLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIHRoaXMuaW5uZXJbaV0ucGFyc2Uuc3RvcEF0KHBvcyk7XG4gICAgfVxuICAgIHN0YXJ0SW5uZXIoKSB7XG4gICAgICAgIGxldCBmcmFnbWVudEN1cnNvciA9IG5ldyBGcmFnbWVudEN1cnNvcih0aGlzLmZyYWdtZW50cyk7XG4gICAgICAgIGxldCBvdmVybGF5ID0gbnVsbDtcbiAgICAgICAgbGV0IGNvdmVyZWQgPSBudWxsO1xuICAgICAgICBsZXQgY3Vyc29yID0gbmV3IFRyZWVDdXJzb3IobmV3IFRyZWVOb2RlKHRoaXMuYmFzZVRyZWUsIHRoaXMucmFuZ2VzWzBdLmZyb20sIDAsIG51bGwpLCBJdGVyTW9kZS5JbmNsdWRlQW5vbnltb3VzIHwgSXRlck1vZGUuSWdub3JlTW91bnRzKTtcbiAgICAgICAgc2NhbjogZm9yIChsZXQgbmVzdCwgaXNDb3ZlcmVkOzspIHtcbiAgICAgICAgICAgIGxldCBlbnRlciA9IHRydWUsIHJhbmdlO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RvcHBlZEF0ICE9IG51bGwgJiYgY3Vyc29yLmZyb20gPj0gdGhpcy5zdG9wcGVkQXQpIHtcbiAgICAgICAgICAgICAgICBlbnRlciA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZnJhZ21lbnRDdXJzb3IuaGFzTm9kZShjdXJzb3IpKSB7XG4gICAgICAgICAgICAgICAgaWYgKG92ZXJsYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1hdGNoID0gb3ZlcmxheS5tb3VudHMuZmluZChtID0+IG0uZnJhZy5mcm9tIDw9IGN1cnNvci5mcm9tICYmIG0uZnJhZy50byA+PSBjdXJzb3IudG8gJiYgbS5tb3VudC5vdmVybGF5KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoKVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgciBvZiBtYXRjaC5tb3VudC5vdmVybGF5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZyb20gPSByLmZyb20gKyBtYXRjaC5wb3MsIHRvID0gci50byArIG1hdGNoLnBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnJvbSA+PSBjdXJzb3IuZnJvbSAmJiB0byA8PSBjdXJzb3IudG8gJiYgIW92ZXJsYXkucmFuZ2VzLnNvbWUociA9PiByLmZyb20gPCB0byAmJiByLnRvID4gZnJvbSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJsYXkucmFuZ2VzLnB1c2goeyBmcm9tLCB0byB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZW50ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvdmVyZWQgJiYgKGlzQ292ZXJlZCA9IGNoZWNrQ292ZXIoY292ZXJlZC5yYW5nZXMsIGN1cnNvci5mcm9tLCBjdXJzb3IudG8pKSkge1xuICAgICAgICAgICAgICAgIGVudGVyID0gaXNDb3ZlcmVkICE9IDIgLyogQ292ZXIuRnVsbCAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFjdXJzb3IudHlwZS5pc0Fub255bW91cyAmJiAobmVzdCA9IHRoaXMubmVzdChjdXJzb3IsIHRoaXMuaW5wdXQpKSAmJlxuICAgICAgICAgICAgICAgIChjdXJzb3IuZnJvbSA8IGN1cnNvci50byB8fCAhbmVzdC5vdmVybGF5KSkge1xuICAgICAgICAgICAgICAgIGlmICghY3Vyc29yLnRyZWUpXG4gICAgICAgICAgICAgICAgICAgIG1hdGVyaWFsaXplKGN1cnNvcik7XG4gICAgICAgICAgICAgICAgbGV0IG9sZE1vdW50cyA9IGZyYWdtZW50Q3Vyc29yLmZpbmRNb3VudHMoY3Vyc29yLmZyb20sIG5lc3QucGFyc2VyKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG5lc3Qub3ZlcmxheSA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmxheSA9IG5ldyBBY3RpdmVPdmVybGF5KG5lc3QucGFyc2VyLCBuZXN0Lm92ZXJsYXksIG9sZE1vdW50cywgdGhpcy5pbm5lci5sZW5ndGgsIGN1cnNvci5mcm9tLCBjdXJzb3IudHJlZSwgb3ZlcmxheSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmFuZ2VzID0gcHVuY2hSYW5nZXModGhpcy5yYW5nZXMsIG5lc3Qub3ZlcmxheSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKGN1cnNvci5mcm9tIDwgY3Vyc29yLnRvID8gW25ldyBSYW5nZShjdXJzb3IuZnJvbSwgY3Vyc29yLnRvKV0gOiBbXSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmFuZ2VzLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrUmFuZ2VzKHJhbmdlcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyYW5nZXMubGVuZ3RoIHx8ICFuZXN0Lm92ZXJsYXkpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlubmVyLnB1c2gobmV3IElubmVyUGFyc2UobmVzdC5wYXJzZXIsIHJhbmdlcy5sZW5ndGggPyBuZXN0LnBhcnNlci5zdGFydFBhcnNlKHRoaXMuaW5wdXQsIGVudGVyRnJhZ21lbnRzKG9sZE1vdW50cywgcmFuZ2VzKSwgcmFuZ2VzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogbmVzdC5wYXJzZXIuc3RhcnRQYXJzZShcIlwiKSwgbmVzdC5vdmVybGF5ID8gbmVzdC5vdmVybGF5Lm1hcChyID0+IG5ldyBSYW5nZShyLmZyb20gLSBjdXJzb3IuZnJvbSwgci50byAtIGN1cnNvci5mcm9tKSkgOiBudWxsLCBjdXJzb3IudHJlZSwgcmFuZ2VzLmxlbmd0aCA/IHJhbmdlc1swXS5mcm9tIDogY3Vyc29yLmZyb20pKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXN0Lm92ZXJsYXkpXG4gICAgICAgICAgICAgICAgICAgICAgICBlbnRlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChyYW5nZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICAgICAgY292ZXJlZCA9IHsgcmFuZ2VzLCBkZXB0aDogMCwgcHJldjogY292ZXJlZCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG92ZXJsYXkgJiYgKHJhbmdlID0gb3ZlcmxheS5wcmVkaWNhdGUoY3Vyc29yKSkpIHtcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2UgPT09IHRydWUpXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlID0gbmV3IFJhbmdlKGN1cnNvci5mcm9tLCBjdXJzb3IudG8pO1xuICAgICAgICAgICAgICAgIGlmIChyYW5nZS5mcm9tIDwgcmFuZ2UudG8pXG4gICAgICAgICAgICAgICAgICAgIG92ZXJsYXkucmFuZ2VzLnB1c2gocmFuZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVudGVyICYmIGN1cnNvci5maXJzdENoaWxkKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAob3ZlcmxheSlcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmxheS5kZXB0aCsrO1xuICAgICAgICAgICAgICAgIGlmIChjb3ZlcmVkKVxuICAgICAgICAgICAgICAgICAgICBjb3ZlcmVkLmRlcHRoKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJzb3IubmV4dFNpYmxpbmcoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWN1cnNvci5wYXJlbnQoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIHNjYW47XG4gICAgICAgICAgICAgICAgICAgIGlmIChvdmVybGF5ICYmICEtLW92ZXJsYXkuZGVwdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByYW5nZXMgPSBwdW5jaFJhbmdlcyh0aGlzLnJhbmdlcywgb3ZlcmxheS5yYW5nZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGVja1JhbmdlcyhyYW5nZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5uZXIuc3BsaWNlKG92ZXJsYXkuaW5kZXgsIDAsIG5ldyBJbm5lclBhcnNlKG92ZXJsYXkucGFyc2VyLCBvdmVybGF5LnBhcnNlci5zdGFydFBhcnNlKHRoaXMuaW5wdXQsIGVudGVyRnJhZ21lbnRzKG92ZXJsYXkubW91bnRzLCByYW5nZXMpLCByYW5nZXMpLCBvdmVybGF5LnJhbmdlcy5tYXAociA9PiBuZXcgUmFuZ2Uoci5mcm9tIC0gb3ZlcmxheS5zdGFydCwgci50byAtIG92ZXJsYXkuc3RhcnQpKSwgb3ZlcmxheS50YXJnZXQsIHJhbmdlc1swXS5mcm9tKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBvdmVybGF5ID0gb3ZlcmxheS5wcmV2O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3ZlcmVkICYmICEtLWNvdmVyZWQuZGVwdGgpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3ZlcmVkID0gY292ZXJlZC5wcmV2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGNoZWNrQ292ZXIoY292ZXJlZCwgZnJvbSwgdG8pIHtcbiAgICBmb3IgKGxldCByYW5nZSBvZiBjb3ZlcmVkKSB7XG4gICAgICAgIGlmIChyYW5nZS5mcm9tID49IHRvKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGlmIChyYW5nZS50byA+IGZyb20pXG4gICAgICAgICAgICByZXR1cm4gcmFuZ2UuZnJvbSA8PSBmcm9tICYmIHJhbmdlLnRvID49IHRvID8gMiAvKiBDb3Zlci5GdWxsICovIDogMSAvKiBDb3Zlci5QYXJ0aWFsICovO1xuICAgIH1cbiAgICByZXR1cm4gMCAvKiBDb3Zlci5Ob25lICovO1xufVxuLy8gVGFrZSBhIHBpZWNlIG9mIGJ1ZmZlciBhbmQgY29udmVydCBpdCBpbnRvIGEgc3RhbmQtYWxvbmVcbi8vIFRyZWVCdWZmZXIuXG5mdW5jdGlvbiBzbGljZUJ1ZihidWYsIHN0YXJ0SSwgZW5kSSwgbm9kZXMsIHBvc2l0aW9ucywgb2ZmKSB7XG4gICAgaWYgKHN0YXJ0SSA8IGVuZEkpIHtcbiAgICAgICAgbGV0IGZyb20gPSBidWYuYnVmZmVyW3N0YXJ0SSArIDFdO1xuICAgICAgICBub2Rlcy5wdXNoKGJ1Zi5zbGljZShzdGFydEksIGVuZEksIGZyb20pKTtcbiAgICAgICAgcG9zaXRpb25zLnB1c2goZnJvbSAtIG9mZik7XG4gICAgfVxufVxuLy8gVGhpcyBmdW5jdGlvbiB0YWtlcyBhIG5vZGUgdGhhdCdzIGluIGEgYnVmZmVyLCBhbmQgY29udmVydHMgaXQsIGFuZFxuLy8gaXRzIHBhcmVudCBidWZmZXIgbm9kZXMsIGludG8gYSBUcmVlLiBUaGlzIGlzIGFnYWluIGFjdGluZyBvbiB0aGVcbi8vIGFzc3VtcHRpb24gdGhhdCB0aGUgdHJlZXMgYW5kIGJ1ZmZlcnMgaGF2ZSBiZWVuIGNvbnN0cnVjdGVkIGJ5IHRoZVxuLy8gcGFyc2UgdGhhdCB3YXMgcmFuIHZpYSB0aGUgbWl4IHBhcnNlciwgYW5kIHRodXMgYXJlbid0IHNoYXJlZCB3aXRoXG4vLyBhbnkgb3RoZXIgY29kZSwgbWFraW5nIHZpb2xhdGlvbnMgb2YgdGhlIGltbXV0YWJpbGl0eSBzYWZlLlxuZnVuY3Rpb24gbWF0ZXJpYWxpemUoY3Vyc29yKSB7XG4gICAgbGV0IHsgbm9kZSB9ID0gY3Vyc29yLCBzdGFjayA9IFtdO1xuICAgIC8vIFNjYW4gdXAgdG8gdGhlIG5lYXJlc3QgdHJlZVxuICAgIGRvIHtcbiAgICAgICAgc3RhY2sucHVzaChjdXJzb3IuaW5kZXgpO1xuICAgICAgICBjdXJzb3IucGFyZW50KCk7XG4gICAgfSB3aGlsZSAoIWN1cnNvci50cmVlKTtcbiAgICAvLyBGaW5kIHRoZSBpbmRleCBvZiB0aGUgYnVmZmVyIGluIHRoYXQgdHJlZVxuICAgIGxldCBpID0gMCwgYmFzZSA9IGN1cnNvci50cmVlLCBvZmYgPSAwO1xuICAgIGZvciAoOzsgaSsrKSB7XG4gICAgICAgIG9mZiA9IGJhc2UucG9zaXRpb25zW2ldICsgY3Vyc29yLmZyb207XG4gICAgICAgIGlmIChvZmYgPD0gbm9kZS5mcm9tICYmIG9mZiArIGJhc2UuY2hpbGRyZW5baV0ubGVuZ3RoID49IG5vZGUudG8pXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgbGV0IGJ1ZiA9IGJhc2UuY2hpbGRyZW5baV0sIGIgPSBidWYuYnVmZmVyLCBuZXdTdGFjayA9IFtpXTtcbiAgICAvLyBTcGxpdCBhIGxldmVsIGluIHRoZSBidWZmZXIsIHB1dHRpbmcgdGhlIG5vZGVzIGJlZm9yZSBhbmQgYWZ0ZXJcbiAgICAvLyB0aGUgY2hpbGQgdGhhdCBjb250YWlucyBgbm9kZWAgaW50byBuZXcgYnVmZmVycy5cbiAgICBmdW5jdGlvbiBzcGxpdChzdGFydEksIGVuZEksIHR5cGUsIGlubmVyT2Zmc2V0LCBsZW5ndGgsIHN0YWNrUG9zKSB7XG4gICAgICAgIGxldCB0YXJnZXRJID0gc3RhY2tbc3RhY2tQb3NdO1xuICAgICAgICBsZXQgY2hpbGRyZW4gPSBbXSwgcG9zaXRpb25zID0gW107XG4gICAgICAgIHNsaWNlQnVmKGJ1Ziwgc3RhcnRJLCB0YXJnZXRJLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBpbm5lck9mZnNldCk7XG4gICAgICAgIGxldCBmcm9tID0gYlt0YXJnZXRJICsgMV0sIHRvID0gYlt0YXJnZXRJICsgMl07XG4gICAgICAgIG5ld1N0YWNrLnB1c2goY2hpbGRyZW4ubGVuZ3RoKTtcbiAgICAgICAgbGV0IGNoaWxkID0gc3RhY2tQb3NcbiAgICAgICAgICAgID8gc3BsaXQodGFyZ2V0SSArIDQsIGJbdGFyZ2V0SSArIDNdLCBidWYuc2V0LnR5cGVzW2JbdGFyZ2V0SV1dLCBmcm9tLCB0byAtIGZyb20sIHN0YWNrUG9zIC0gMSlcbiAgICAgICAgICAgIDogbm9kZS50b1RyZWUoKTtcbiAgICAgICAgY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgICAgIHBvc2l0aW9ucy5wdXNoKGZyb20gLSBpbm5lck9mZnNldCk7XG4gICAgICAgIHNsaWNlQnVmKGJ1ZiwgYlt0YXJnZXRJICsgM10sIGVuZEksIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGlubmVyT2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlKHR5cGUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGxlbmd0aCk7XG4gICAgfVxuICAgIGJhc2UuY2hpbGRyZW5baV0gPSBzcGxpdCgwLCBiLmxlbmd0aCwgTm9kZVR5cGUubm9uZSwgMCwgYnVmLmxlbmd0aCwgc3RhY2subGVuZ3RoIC0gMSk7XG4gICAgLy8gTW92ZSB0aGUgY3Vyc29yIGJhY2sgdG8gdGhlIHRhcmdldCBub2RlXG4gICAgZm9yIChsZXQgaW5kZXggb2YgbmV3U3RhY2spIHtcbiAgICAgICAgbGV0IHRyZWUgPSBjdXJzb3IudHJlZS5jaGlsZHJlbltpbmRleF0sIHBvcyA9IGN1cnNvci50cmVlLnBvc2l0aW9uc1tpbmRleF07XG4gICAgICAgIGN1cnNvci55aWVsZChuZXcgVHJlZU5vZGUodHJlZSwgcG9zICsgY3Vyc29yLmZyb20sIGluZGV4LCBjdXJzb3IuX3RyZWUpKTtcbiAgICB9XG59XG5jbGFzcyBTdHJ1Y3R1cmVDdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKHJvb3QsIG9mZnNldCkge1xuICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY3Vyc29yID0gcm9vdC5jdXJzb3IoSXRlck1vZGUuSW5jbHVkZUFub255bW91cyB8IEl0ZXJNb2RlLklnbm9yZU1vdW50cyk7XG4gICAgfVxuICAgIC8vIE1vdmUgdG8gdGhlIGZpcnN0IG5vZGUgKGluIHByZS1vcmRlcikgdGhhdCBzdGFydHMgYXQgb3IgYWZ0ZXIgYHBvc2AuXG4gICAgbW92ZVRvKHBvcykge1xuICAgICAgICBsZXQgeyBjdXJzb3IgfSA9IHRoaXMsIHAgPSBwb3MgLSB0aGlzLm9mZnNldDtcbiAgICAgICAgd2hpbGUgKCF0aGlzLmRvbmUgJiYgY3Vyc29yLmZyb20gPCBwKSB7XG4gICAgICAgICAgICBpZiAoY3Vyc29yLnRvID49IHBvcyAmJiBjdXJzb3IuZW50ZXIocCwgMSwgSXRlck1vZGUuSWdub3JlT3ZlcmxheXMgfCBJdGVyTW9kZS5FeGNsdWRlQnVmZmVycykpIDtcbiAgICAgICAgICAgIGVsc2UgaWYgKCFjdXJzb3IubmV4dChmYWxzZSkpXG4gICAgICAgICAgICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYXNOb2RlKGN1cnNvcikge1xuICAgICAgICB0aGlzLm1vdmVUbyhjdXJzb3IuZnJvbSk7XG4gICAgICAgIGlmICghdGhpcy5kb25lICYmIHRoaXMuY3Vyc29yLmZyb20gKyB0aGlzLm9mZnNldCA9PSBjdXJzb3IuZnJvbSAmJiB0aGlzLmN1cnNvci50cmVlKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB0cmVlID0gdGhpcy5jdXJzb3IudHJlZTs7KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRyZWUgPT0gY3Vyc29yLnRyZWUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIGlmICh0cmVlLmNoaWxkcmVuLmxlbmd0aCAmJiB0cmVlLnBvc2l0aW9uc1swXSA9PSAwICYmIHRyZWUuY2hpbGRyZW5bMF0gaW5zdGFuY2VvZiBUcmVlKVxuICAgICAgICAgICAgICAgICAgICB0cmVlID0gdHJlZS5jaGlsZHJlblswXTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5jbGFzcyBGcmFnbWVudEN1cnNvciB7XG4gICAgY29uc3RydWN0b3IoZnJhZ21lbnRzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5mcmFnbWVudHMgPSBmcmFnbWVudHM7XG4gICAgICAgIHRoaXMuY3VyVG8gPSAwO1xuICAgICAgICB0aGlzLmZyYWdJID0gMDtcbiAgICAgICAgaWYgKGZyYWdtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBmaXJzdCA9IHRoaXMuY3VyRnJhZyA9IGZyYWdtZW50c1swXTtcbiAgICAgICAgICAgIHRoaXMuY3VyVG8gPSAoX2EgPSBmaXJzdC50cmVlLnByb3Aoc3RvcHBlZElubmVyKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmlyc3QudG87XG4gICAgICAgICAgICB0aGlzLmlubmVyID0gbmV3IFN0cnVjdHVyZUN1cnNvcihmaXJzdC50cmVlLCAtZmlyc3Qub2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY3VyRnJhZyA9IHRoaXMuaW5uZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhc05vZGUobm9kZSkge1xuICAgICAgICB3aGlsZSAodGhpcy5jdXJGcmFnICYmIG5vZGUuZnJvbSA+PSB0aGlzLmN1clRvKVxuICAgICAgICAgICAgdGhpcy5uZXh0RnJhZygpO1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJGcmFnICYmIHRoaXMuY3VyRnJhZy5mcm9tIDw9IG5vZGUuZnJvbSAmJiB0aGlzLmN1clRvID49IG5vZGUudG8gJiYgdGhpcy5pbm5lci5oYXNOb2RlKG5vZGUpO1xuICAgIH1cbiAgICBuZXh0RnJhZygpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLmZyYWdJKys7XG4gICAgICAgIGlmICh0aGlzLmZyYWdJID09IHRoaXMuZnJhZ21lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5jdXJGcmFnID0gdGhpcy5pbm5lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgZnJhZyA9IHRoaXMuY3VyRnJhZyA9IHRoaXMuZnJhZ21lbnRzW3RoaXMuZnJhZ0ldO1xuICAgICAgICAgICAgdGhpcy5jdXJUbyA9IChfYSA9IGZyYWcudHJlZS5wcm9wKHN0b3BwZWRJbm5lcikpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZyYWcudG87XG4gICAgICAgICAgICB0aGlzLmlubmVyID0gbmV3IFN0cnVjdHVyZUN1cnNvcihmcmFnLnRyZWUsIC1mcmFnLm9mZnNldCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmluZE1vdW50cyhwb3MsIHBhcnNlcikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMuaW5uZXIpIHtcbiAgICAgICAgICAgIHRoaXMuaW5uZXIuY3Vyc29yLm1vdmVUbyhwb3MsIDEpO1xuICAgICAgICAgICAgZm9yIChsZXQgcG9zID0gdGhpcy5pbm5lci5jdXJzb3Iubm9kZTsgcG9zOyBwb3MgPSBwb3MucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgbGV0IG1vdW50ID0gKF9hID0gcG9zLnRyZWUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wcm9wKE5vZGVQcm9wLm1vdW50ZWQpO1xuICAgICAgICAgICAgICAgIGlmIChtb3VudCAmJiBtb3VudC5wYXJzZXIgPT0gcGFyc2VyKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmZyYWdJOyBpIDwgdGhpcy5mcmFnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmcmFnID0gdGhpcy5mcmFnbWVudHNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnJhZy5mcm9tID49IHBvcy50bylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcmFnLnRyZWUgPT0gdGhpcy5jdXJGcmFnLnRyZWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3M6IHBvcy5mcm9tIC0gZnJhZy5vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vdW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5mdW5jdGlvbiBwdW5jaFJhbmdlcyhvdXRlciwgcmFuZ2VzKSB7XG4gICAgbGV0IGNvcHkgPSBudWxsLCBjdXJyZW50ID0gcmFuZ2VzO1xuICAgIGZvciAobGV0IGkgPSAxLCBqID0gMDsgaSA8IG91dGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBnYXBGcm9tID0gb3V0ZXJbaSAtIDFdLnRvLCBnYXBUbyA9IG91dGVyW2ldLmZyb207XG4gICAgICAgIGZvciAoOyBqIDwgY3VycmVudC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgbGV0IHIgPSBjdXJyZW50W2pdO1xuICAgICAgICAgICAgaWYgKHIuZnJvbSA+PSBnYXBUbylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGlmIChyLnRvIDw9IGdhcEZyb20pXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAoIWNvcHkpXG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGNvcHkgPSByYW5nZXMuc2xpY2UoKTtcbiAgICAgICAgICAgIGlmIChyLmZyb20gPCBnYXBGcm9tKSB7XG4gICAgICAgICAgICAgICAgY29weVtqXSA9IG5ldyBSYW5nZShyLmZyb20sIGdhcEZyb20pO1xuICAgICAgICAgICAgICAgIGlmIChyLnRvID4gZ2FwVG8pXG4gICAgICAgICAgICAgICAgICAgIGNvcHkuc3BsaWNlKGogKyAxLCAwLCBuZXcgUmFuZ2UoZ2FwVG8sIHIudG8pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHIudG8gPiBnYXBUbykge1xuICAgICAgICAgICAgICAgIGNvcHlbai0tXSA9IG5ldyBSYW5nZShnYXBUbywgci50byk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb3B5LnNwbGljZShqLS0sIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjdXJyZW50O1xufVxuZnVuY3Rpb24gZmluZENvdmVyQ2hhbmdlcyhhLCBiLCBmcm9tLCB0bykge1xuICAgIGxldCBpQSA9IDAsIGlCID0gMCwgaW5BID0gZmFsc2UsIGluQiA9IGZhbHNlLCBwb3MgPSAtMWU5O1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGxldCBuZXh0QSA9IGlBID09IGEubGVuZ3RoID8gMWU5IDogaW5BID8gYVtpQV0udG8gOiBhW2lBXS5mcm9tO1xuICAgICAgICBsZXQgbmV4dEIgPSBpQiA9PSBiLmxlbmd0aCA/IDFlOSA6IGluQiA/IGJbaUJdLnRvIDogYltpQl0uZnJvbTtcbiAgICAgICAgaWYgKGluQSAhPSBpbkIpIHtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IE1hdGgubWF4KHBvcywgZnJvbSksIGVuZCA9IE1hdGgubWluKG5leHRBLCBuZXh0QiwgdG8pO1xuICAgICAgICAgICAgaWYgKHN0YXJ0IDwgZW5kKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyBSYW5nZShzdGFydCwgZW5kKSk7XG4gICAgICAgIH1cbiAgICAgICAgcG9zID0gTWF0aC5taW4obmV4dEEsIG5leHRCKTtcbiAgICAgICAgaWYgKHBvcyA9PSAxZTkpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgaWYgKG5leHRBID09IHBvcykge1xuICAgICAgICAgICAgaWYgKCFpbkEpXG4gICAgICAgICAgICAgICAgaW5BID0gdHJ1ZTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGluQSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlBKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5leHRCID09IHBvcykge1xuICAgICAgICAgICAgaWYgKCFpbkIpXG4gICAgICAgICAgICAgICAgaW5CID0gdHJ1ZTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGluQiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlCKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vIEdpdmVuIGEgbnVtYmVyIG9mIGZyYWdtZW50cyBmb3IgdGhlIG91dGVyIHRyZWUsIGFuZCBhIHNldCBvZiByYW5nZXNcbi8vIHRvIHBhcnNlLCBmaW5kIGZyYWdtZW50cyBmb3IgaW5uZXIgdHJlZXMgbW91bnRlZCBhcm91bmQgdGhvc2Vcbi8vIHJhbmdlcywgaWYgYW55LlxuZnVuY3Rpb24gZW50ZXJGcmFnbWVudHMobW91bnRzLCByYW5nZXMpIHtcbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgZm9yIChsZXQgeyBwb3MsIG1vdW50LCBmcmFnIH0gb2YgbW91bnRzKSB7XG4gICAgICAgIGxldCBzdGFydFBvcyA9IHBvcyArIChtb3VudC5vdmVybGF5ID8gbW91bnQub3ZlcmxheVswXS5mcm9tIDogMCksIGVuZFBvcyA9IHN0YXJ0UG9zICsgbW91bnQudHJlZS5sZW5ndGg7XG4gICAgICAgIGxldCBmcm9tID0gTWF0aC5tYXgoZnJhZy5mcm9tLCBzdGFydFBvcyksIHRvID0gTWF0aC5taW4oZnJhZy50bywgZW5kUG9zKTtcbiAgICAgICAgaWYgKG1vdW50Lm92ZXJsYXkpIHtcbiAgICAgICAgICAgIGxldCBvdmVybGF5ID0gbW91bnQub3ZlcmxheS5tYXAociA9PiBuZXcgUmFuZ2Uoci5mcm9tICsgcG9zLCByLnRvICsgcG9zKSk7XG4gICAgICAgICAgICBsZXQgY2hhbmdlcyA9IGZpbmRDb3ZlckNoYW5nZXMocmFuZ2VzLCBvdmVybGF5LCBmcm9tLCB0byk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gZnJvbTs7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBsYXN0ID0gaSA9PSBjaGFuZ2VzLmxlbmd0aCwgZW5kID0gbGFzdCA/IHRvIDogY2hhbmdlc1tpXS5mcm9tO1xuICAgICAgICAgICAgICAgIGlmIChlbmQgPiBwb3MpXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyBUcmVlRnJhZ21lbnQocG9zLCBlbmQsIG1vdW50LnRyZWUsIC1zdGFydFBvcywgZnJhZy5mcm9tID49IHBvcyB8fCBmcmFnLm9wZW5TdGFydCwgZnJhZy50byA8PSBlbmQgfHwgZnJhZy5vcGVuRW5kKSk7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3QpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIHBvcyA9IGNoYW5nZXNbaV0udG87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChuZXcgVHJlZUZyYWdtZW50KGZyb20sIHRvLCBtb3VudC50cmVlLCAtc3RhcnRQb3MsIGZyYWcuZnJvbSA+PSBzdGFydFBvcyB8fCBmcmFnLm9wZW5TdGFydCwgZnJhZy50byA8PSBlbmRQb3MgfHwgZnJhZy5vcGVuRW5kKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IHsgRGVmYXVsdEJ1ZmZlckxlbmd0aCwgSXRlck1vZGUsIE1vdW50ZWRUcmVlLCBOb2RlUHJvcCwgTm9kZVNldCwgTm9kZVR5cGUsIE5vZGVXZWFrTWFwLCBQYXJzZXIsIFRyZWUsIFRyZWVCdWZmZXIsIFRyZWVDdXJzb3IsIFRyZWVGcmFnbWVudCwgcGFyc2VNaXhlZCB9O1xuIl0sIm5hbWVzIjpbIkRlZmF1bHRCdWZmZXJMZW5ndGgiLCJuZXh0UHJvcElEIiwiUmFuZ2UiLCJjb25zdHJ1Y3RvciIsImZyb20iLCJ0byIsIk5vZGVQcm9wIiwiY29uZmlnIiwiaWQiLCJwZXJOb2RlIiwiZGVzZXJpYWxpemUiLCJFcnJvciIsImFkZCIsIm1hdGNoIiwiUmFuZ2VFcnJvciIsIk5vZGVUeXBlIiwidHlwZSIsInJlc3VsdCIsInVuZGVmaW5lZCIsImNsb3NlZEJ5Iiwic3RyIiwic3BsaXQiLCJvcGVuZWRCeSIsImdyb3VwIiwiY29udGV4dEhhc2giLCJsb29rQWhlYWQiLCJtb3VudGVkIiwiTW91bnRlZFRyZWUiLCJ0cmVlIiwib3ZlcmxheSIsInBhcnNlciIsImdldCIsInByb3BzIiwibm9Qcm9wcyIsIk9iamVjdCIsImNyZWF0ZSIsIm5hbWUiLCJmbGFncyIsImRlZmluZSIsInNwZWMiLCJsZW5ndGgiLCJ0b3AiLCJza2lwcGVkIiwiZXJyb3IiLCJzcmMiLCJBcnJheSIsImlzQXJyYXkiLCJwcm9wIiwiaXNUb3AiLCJpc1NraXBwZWQiLCJpc0Vycm9yIiwiaXNBbm9ueW1vdXMiLCJpcyIsImluZGV4T2YiLCJtYXAiLCJkaXJlY3QiLCJub2RlIiwiZ3JvdXBzIiwiaSIsImZvdW5kIiwibm9uZSIsIk5vZGVTZXQiLCJ0eXBlcyIsImV4dGVuZCIsIm5ld1R5cGVzIiwibmV3UHJvcHMiLCJzb3VyY2UiLCJhc3NpZ24iLCJwdXNoIiwiQ2FjaGVkTm9kZSIsIldlYWtNYXAiLCJDYWNoZWRJbm5lck5vZGUiLCJJdGVyTW9kZSIsIlRyZWUiLCJjaGlsZHJlbiIsInBvc2l0aW9ucyIsInZhbHVlIiwidG9TdHJpbmciLCJjaCIsInRlc3QiLCJKU09OIiwic3RyaW5naWZ5IiwiY3Vyc29yIiwibW9kZSIsIlRyZWVDdXJzb3IiLCJ0b3BOb2RlIiwiY3Vyc29yQXQiLCJwb3MiLCJzaWRlIiwic2NvcGUiLCJtb3ZlVG8iLCJzZXQiLCJfdHJlZSIsIlRyZWVOb2RlIiwicmVzb2x2ZSIsInJlc29sdmVOb2RlIiwicmVzb2x2ZUlubmVyIiwicmVzb2x2ZVN0YWNrIiwic3RhY2tJdGVyYXRvciIsIml0ZXJhdGUiLCJlbnRlciIsImxlYXZlIiwiYW5vbiIsIkluY2x1ZGVBbm9ueW1vdXMiLCJjIiwiZW50ZXJlZCIsImZpcnN0Q2hpbGQiLCJuZXh0U2libGluZyIsInBhcmVudCIsInByb3BWYWx1ZXMiLCJiYWxhbmNlIiwiYmFsYW5jZVJhbmdlIiwibWFrZVRyZWUiLCJidWlsZCIsImRhdGEiLCJidWlsZFRyZWUiLCJlbXB0eSIsIkZsYXRCdWZmZXJDdXJzb3IiLCJidWZmZXIiLCJpbmRleCIsInN0YXJ0IiwiZW5kIiwic2l6ZSIsIm5leHQiLCJmb3JrIiwiVHJlZUJ1ZmZlciIsImNoaWxkU3RyaW5nIiwiam9pbiIsImVuZEluZGV4IiwiZmluZENoaWxkIiwic3RhcnRJbmRleCIsImRpciIsInBpY2siLCJjaGVja1NpZGUiLCJzbGljZSIsInN0YXJ0SSIsImVuZEkiLCJiIiwiY29weSIsIlVpbnQxNkFycmF5IiwibGVuIiwiaiIsIk1hdGgiLCJtYXgiLCJvdmVybGF5cyIsIl9hIiwiSWdub3JlT3ZlcmxheXMiLCJzY2FuIiwiaW5uZXIiLCJCYXNlTm9kZSIsImdldENoaWxkIiwiYmVmb3JlIiwiYWZ0ZXIiLCJyIiwiZ2V0Q2hpbGRyZW4iLCJtYXRjaENvbnRleHQiLCJjb250ZXh0IiwibWF0Y2hOb2RlQ29udGV4dCIsImVudGVyVW5maW5pc2hlZE5vZGVzQmVmb3JlIiwiY2hpbGRCZWZvcmUiLCJsYXN0IiwibGFzdENoaWxkIiwicHJldlNpYmxpbmciLCJfcGFyZW50IiwibmV4dENoaWxkIiwiZSIsIkV4Y2x1ZGVCdWZmZXJzIiwiQnVmZmVyTm9kZSIsIkJ1ZmZlckNvbnRleHQiLCJoYXNDaGlsZCIsIklnbm9yZU1vdW50cyIsImNoaWxkQWZ0ZXIiLCJyUG9zIiwibmV4dFNpZ25pZmljYW50UGFyZW50IiwidmFsIiwidG9UcmVlIiwiY3VyIiwicCIsImNoaWxkIiwiZXh0ZXJuYWxTaWJsaW5nIiwicGFyZW50U3RhcnQiLCJpdGVyU3RhY2siLCJoZWFkcyIsInBpY2tlZCIsIm5ld0hlYWRzIiwic3BsaWNlIiwiU3RhY2tJdGVyYXRvciIsImxheWVycyIsIm1vdW50Iiwicm9vdCIsInN0YWNrIiwiYnVmZmVyTm9kZSIsInlpZWxkTm9kZSIsIm4iLCJ1bnNoaWZ0IiwieWllbGRCdWYiLCJ5aWVsZCIsImVudGVyQ2hpbGQiLCJwb3AiLCJzaWJsaW5nIiwiZCIsImF0TGFzdE5vZGUiLCJtb3ZlIiwicHJldiIsImNhY2hlIiwiZGVwdGgiLCJtdXN0TGVhdmUiLCJzb21lIiwibm9kZVNldCIsIm1heEJ1ZmZlckxlbmd0aCIsInJldXNlZCIsIm1pblJlcGVhdFR5cGUiLCJ0YWtlTm9kZSIsIm1pblBvcyIsImluUmVwZWF0IiwibG9va0FoZWFkQXRTdGFydCIsInN0YXJ0UG9zIiwiZmluZEJ1ZmZlclNpemUiLCJza2lwIiwiZW5kUG9zIiwiY29weVRvQnVmZmVyIiwibG9jYWxDaGlsZHJlbiIsImxvY2FsUG9zaXRpb25zIiwibG9jYWxJblJlcGVhdCIsImxhc3RHcm91cCIsImxhc3RFbmQiLCJtYWtlUmVwZWF0TGVhZiIsInRha2VGbGF0Tm9kZSIsInJldmVyc2UiLCJtYWtlIiwibWFrZUJhbGFuY2VkIiwibm9kZXMiLCJub2RlQ291bnQiLCJzdG9wQXQiLCJsYXN0SSIsImxvb2tBaGVhZFByb3AiLCJiYXNlIiwicGFpciIsImNvbmNhdCIsIm1heFNpemUiLCJtaW5TdGFydCIsIm5vZGVTaXplIiwibG9jYWxTa2lwcGVkIiwibm9kZVN0YXJ0IiwiYnVmZmVyU3RhcnQiLCJ0b3BJRCIsIm5vZGVTaXplQ2FjaGUiLCJiYWxhbmNlVHlwZSIsIm1rVG9wIiwibWtUcmVlIiwidG90YWwiLCJtYXhDaGlsZCIsImNlaWwiLCJkaXZpZGUiLCJvZmZzZXQiLCJncm91cEZyb20iLCJncm91cFN0YXJ0IiwiZ3JvdXBTaXplIiwibmV4dFNpemUiLCJvbmx5IiwiTm9kZVdlYWtNYXAiLCJzZXRCdWZmZXIiLCJNYXAiLCJnZXRCdWZmZXIiLCJjdXJzb3JTZXQiLCJjdXJzb3JHZXQiLCJUcmVlRnJhZ21lbnQiLCJvcGVuU3RhcnQiLCJvcGVuRW5kIiwib3BlbiIsImFkZFRyZWUiLCJmcmFnbWVudHMiLCJwYXJ0aWFsIiwiZiIsImFwcGx5Q2hhbmdlcyIsImNoYW5nZXMiLCJtaW5HYXAiLCJmSSIsIm5leHRGIiwiY0kiLCJvZmYiLCJuZXh0QyIsIm5leHRQb3MiLCJmcm9tQSIsImN1dCIsImZGcm9tIiwiZlRvIiwibWluIiwidG9BIiwidG9CIiwiUGFyc2VyIiwic3RhcnRQYXJzZSIsImlucHV0IiwicmFuZ2VzIiwiU3RyaW5nSW5wdXQiLCJjcmVhdGVQYXJzZSIsInBhcnNlIiwiZG9uZSIsImFkdmFuY2UiLCJzdHJpbmciLCJjaHVuayIsImxpbmVDaHVua3MiLCJyZWFkIiwicGFyc2VNaXhlZCIsIm5lc3QiLCJNaXhlZFBhcnNlIiwiSW5uZXJQYXJzZSIsInRhcmdldCIsImNoZWNrUmFuZ2VzIiwiQWN0aXZlT3ZlcmxheSIsInByZWRpY2F0ZSIsIm1vdW50cyIsInN0b3BwZWRJbm5lciIsImlubmVyRG9uZSIsImJhc2VUcmVlIiwic3RvcHBlZEF0IiwiYmFzZVBhcnNlIiwic3RhcnRJbm5lciIsInBhcnNlZFBvcyIsImZyYWdtZW50Q3Vyc29yIiwiRnJhZ21lbnRDdXJzb3IiLCJjb3ZlcmVkIiwiaXNDb3ZlcmVkIiwicmFuZ2UiLCJoYXNOb2RlIiwiZmluZCIsIm0iLCJmcmFnIiwiY2hlY2tDb3ZlciIsIm1hdGVyaWFsaXplIiwib2xkTW91bnRzIiwiZmluZE1vdW50cyIsInB1bmNoUmFuZ2VzIiwiZW50ZXJGcmFnbWVudHMiLCJzbGljZUJ1ZiIsImJ1ZiIsIm5ld1N0YWNrIiwiaW5uZXJPZmZzZXQiLCJzdGFja1BvcyIsInRhcmdldEkiLCJTdHJ1Y3R1cmVDdXJzb3IiLCJjdXJUbyIsImZyYWdJIiwiZmlyc3QiLCJjdXJGcmFnIiwibmV4dEZyYWciLCJvdXRlciIsImN1cnJlbnQiLCJnYXBGcm9tIiwiZ2FwVG8iLCJmaW5kQ292ZXJDaGFuZ2VzIiwiYSIsImlBIiwiaUIiLCJpbkEiLCJpbkIiLCJuZXh0QSIsIm5leHRCIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lezer/common/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lezer/highlight/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@lezer/highlight/dist/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Tag: () => (/* binding */ Tag),\n/* harmony export */   classHighlighter: () => (/* binding */ classHighlighter),\n/* harmony export */   getStyleTags: () => (/* binding */ getStyleTags),\n/* harmony export */   highlightCode: () => (/* binding */ highlightCode),\n/* harmony export */   highlightTree: () => (/* binding */ highlightTree),\n/* harmony export */   styleTags: () => (/* binding */ styleTags),\n/* harmony export */   tagHighlighter: () => (/* binding */ tagHighlighter),\n/* harmony export */   tags: () => (/* binding */ tags)\n/* harmony export */ });\n/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/common */ \"(ssr)/./node_modules/@lezer/common/dist/index.js\");\n\nlet nextTagID = 0;\n/**\nHighlighting tags are markers that denote a highlighting category.\nThey are [associated](#highlight.styleTags) with parts of a syntax\ntree by a language mode, and then mapped to an actual CSS style by\na [highlighter](#highlight.Highlighter).\n\nBecause syntax tree node types and highlight styles have to be\nable to talk the same language, CodeMirror uses a mostly _closed_\n[vocabulary](#highlight.tags) of syntax tags (as opposed to\ntraditional open string-based systems, which make it hard for\nhighlighting themes to cover all the tokens produced by the\nvarious languages).\n\nIt _is_ possible to [define](#highlight.Tag^define) your own\nhighlighting tags for system-internal use (where you control both\nthe language package and the highlighter), but such tags will not\nbe picked up by regular highlighters (though you can derive them\nfrom standard tags to allow highlighters to fall back to those).\n*/ class Tag {\n    /**\n    @internal\n    */ constructor(/**\n    The set of this tag and all its parent tags, starting with\n    this one itself and sorted in order of decreasing specificity.\n    */ set, /**\n    The base unmodified tag that this one is based on, if it's\n    modified @internal\n    */ base, /**\n    The modifiers applied to this.base @internal\n    */ modified){\n        this.set = set;\n        this.base = base;\n        this.modified = modified;\n        /**\n        @internal\n        */ this.id = nextTagID++;\n    }\n    /**\n    Define a new tag. If `parent` is given, the tag is treated as a\n    sub-tag of that parent, and\n    [highlighters](#highlight.tagHighlighter) that don't mention\n    this tag will try to fall back to the parent tag (or grandparent\n    tag, etc).\n    */ static define(parent) {\n        if (parent === null || parent === void 0 ? void 0 : parent.base) throw new Error(\"Can not derive from a modified tag\");\n        let tag = new Tag([], null, []);\n        tag.set.push(tag);\n        if (parent) for (let t of parent.set)tag.set.push(t);\n        return tag;\n    }\n    /**\n    Define a tag _modifier_, which is a function that, given a tag,\n    will return a tag that is a subtag of the original. Applying the\n    same modifier to a twice tag will return the same value (`m1(t1)\n    == m1(t1)`) and applying multiple modifiers will, regardless or\n    order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).\n    \n    When multiple modifiers are applied to a given base tag, each\n    smaller set of modifiers is registered as a parent, so that for\n    example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,\n    `m1(m3(t1)`, and so on.\n    */ static defineModifier() {\n        let mod = new Modifier;\n        return (tag)=>{\n            if (tag.modified.indexOf(mod) > -1) return tag;\n            return Modifier.get(tag.base || tag, tag.modified.concat(mod).sort((a, b)=>a.id - b.id));\n        };\n    }\n}\nlet nextModifierID = 0;\nclass Modifier {\n    constructor(){\n        this.instances = [];\n        this.id = nextModifierID++;\n    }\n    static get(base, mods) {\n        if (!mods.length) return base;\n        let exists = mods[0].instances.find((t)=>t.base == base && sameArray(mods, t.modified));\n        if (exists) return exists;\n        let set = [], tag = new Tag(set, base, mods);\n        for (let m of mods)m.instances.push(tag);\n        let configs = powerSet(mods);\n        for (let parent of base.set)if (!parent.modified.length) for (let config of configs)set.push(Modifier.get(parent, config));\n        return tag;\n    }\n}\nfunction sameArray(a, b) {\n    return a.length == b.length && a.every((x, i)=>x == b[i]);\n}\nfunction powerSet(array) {\n    let sets = [\n        []\n    ];\n    for(let i = 0; i < array.length; i++){\n        for(let j = 0, e = sets.length; j < e; j++){\n            sets.push(sets[j].concat(array[i]));\n        }\n    }\n    return sets.sort((a, b)=>b.length - a.length);\n}\n/**\nThis function is used to add a set of tags to a language syntax\nvia [`NodeSet.extend`](#common.NodeSet.extend) or\n[`LRParser.configure`](#lr.LRParser.configure).\n\nThe argument object maps node selectors to [highlighting\ntags](#highlight.Tag) or arrays of tags.\n\nNode selectors may hold one or more (space-separated) node paths.\nSuch a path can be a [node name](#common.NodeType.name), or\nmultiple node names (or `*` wildcards) separated by slash\ncharacters, as in `\"Block/Declaration/VariableName\"`. Such a path\nmatches the final node but only if its direct parent nodes are the\nother nodes mentioned. A `*` in such a path matches any parent,\nbut only a single level—wildcards that match multiple parents\naren't supported, both for efficiency reasons and because Lezer\ntrees make it rather hard to reason about what they would match.)\n\nA path can be ended with `/...` to indicate that the tag assigned\nto the node should also apply to all child nodes, even if they\nmatch their own style (by default, only the innermost style is\nused).\n\nWhen a path ends in `!`, as in `Attribute!`, no further matching\nhappens for the node's child nodes, and the entire node gets the\ngiven style.\n\nIn this notation, node names that contain `/`, `!`, `*`, or `...`\nmust be quoted as JSON strings.\n\nFor example:\n\n```javascript\nparser.withProps(\n  styleTags({\n    // Style Number and BigNumber nodes\n    \"Number BigNumber\": tags.number,\n    // Style Escape nodes whose parent is String\n    \"String/Escape\": tags.escape,\n    // Style anything inside Attributes nodes\n    \"Attributes!\": tags.meta,\n    // Add a style to all content inside Italic nodes\n    \"Italic/...\": tags.emphasis,\n    // Style InvalidString nodes as both `string` and `invalid`\n    \"InvalidString\": [tags.string, tags.invalid],\n    // Style the node named \"/\" as punctuation\n    '\"/\"': tags.punctuation\n  })\n)\n```\n*/ function styleTags(spec) {\n    let byName = Object.create(null);\n    for(let prop in spec){\n        let tags = spec[prop];\n        if (!Array.isArray(tags)) tags = [\n            tags\n        ];\n        for (let part of prop.split(\" \"))if (part) {\n            let pieces = [], mode = 2 /* Mode.Normal */ , rest = part;\n            for(let pos = 0;;){\n                if (rest == \"...\" && pos > 0 && pos + 3 == part.length) {\n                    mode = 1 /* Mode.Inherit */ ;\n                    break;\n                }\n                let m = /^\"(?:[^\"\\\\]|\\\\.)*?\"|[^\\/!]+/.exec(rest);\n                if (!m) throw new RangeError(\"Invalid path: \" + part);\n                pieces.push(m[0] == \"*\" ? \"\" : m[0][0] == '\"' ? JSON.parse(m[0]) : m[0]);\n                pos += m[0].length;\n                if (pos == part.length) break;\n                let next = part[pos++];\n                if (pos == part.length && next == \"!\") {\n                    mode = 0 /* Mode.Opaque */ ;\n                    break;\n                }\n                if (next != \"/\") throw new RangeError(\"Invalid path: \" + part);\n                rest = part.slice(pos);\n            }\n            let last = pieces.length - 1, inner = pieces[last];\n            if (!inner) throw new RangeError(\"Invalid path: \" + part);\n            let rule = new Rule(tags, mode, last > 0 ? pieces.slice(0, last) : null);\n            byName[inner] = rule.sort(byName[inner]);\n        }\n    }\n    return ruleNodeProp.add(byName);\n}\nconst ruleNodeProp = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp();\nclass Rule {\n    constructor(tags, mode, context, next){\n        this.tags = tags;\n        this.mode = mode;\n        this.context = context;\n        this.next = next;\n    }\n    get opaque() {\n        return this.mode == 0 /* Mode.Opaque */ ;\n    }\n    get inherit() {\n        return this.mode == 1 /* Mode.Inherit */ ;\n    }\n    sort(other) {\n        if (!other || other.depth < this.depth) {\n            this.next = other;\n            return this;\n        }\n        other.next = this.sort(other.next);\n        return other;\n    }\n    get depth() {\n        return this.context ? this.context.length : 0;\n    }\n}\nRule.empty = new Rule([], 2 /* Mode.Normal */ , null);\n/**\nDefine a [highlighter](#highlight.Highlighter) from an array of\ntag/class pairs. Classes associated with more specific tags will\ntake precedence.\n*/ function tagHighlighter(tags, options) {\n    let map = Object.create(null);\n    for (let style of tags){\n        if (!Array.isArray(style.tag)) map[style.tag.id] = style.class;\n        else for (let tag of style.tag)map[tag.id] = style.class;\n    }\n    let { scope, all = null } = options || {};\n    return {\n        style: (tags)=>{\n            let cls = all;\n            for (let tag of tags){\n                for (let sub of tag.set){\n                    let tagClass = map[sub.id];\n                    if (tagClass) {\n                        cls = cls ? cls + \" \" + tagClass : tagClass;\n                        break;\n                    }\n                }\n            }\n            return cls;\n        },\n        scope\n    };\n}\nfunction highlightTags(highlighters, tags) {\n    let result = null;\n    for (let highlighter of highlighters){\n        let value = highlighter.style(tags);\n        if (value) result = result ? result + \" \" + value : value;\n    }\n    return result;\n}\n/**\nHighlight the given [tree](#common.Tree) with the given\n[highlighter](#highlight.Highlighter). Often, the higher-level\n[`highlightCode`](#highlight.highlightCode) function is easier to\nuse.\n*/ function highlightTree(tree, highlighter, /**\nAssign styling to a region of the text. Will be called, in order\nof position, for any ranges where more than zero classes apply.\n`classes` is a space separated string of CSS classes.\n*/ putStyle, /**\nThe start of the range to highlight.\n*/ from = 0, /**\nThe end of the range.\n*/ to = tree.length) {\n    let builder = new HighlightBuilder(from, Array.isArray(highlighter) ? highlighter : [\n        highlighter\n    ], putStyle);\n    builder.highlightRange(tree.cursor(), from, to, \"\", builder.highlighters);\n    builder.flush(to);\n}\n/**\nHighlight the given tree with the given highlighter, calling\n`putText` for every piece of text, either with a set of classes or\nwith the empty string when unstyled, and `putBreak` for every line\nbreak.\n*/ function highlightCode(code, tree, highlighter, putText, putBreak, from = 0, to = code.length) {\n    let pos = from;\n    function writeTo(p, classes) {\n        if (p <= pos) return;\n        for(let text = code.slice(pos, p), i = 0;;){\n            let nextBreak = text.indexOf(\"\\n\", i);\n            let upto = nextBreak < 0 ? text.length : nextBreak;\n            if (upto > i) putText(text.slice(i, upto), classes);\n            if (nextBreak < 0) break;\n            putBreak();\n            i = nextBreak + 1;\n        }\n        pos = p;\n    }\n    highlightTree(tree, highlighter, (from, to, classes)=>{\n        writeTo(from, \"\");\n        writeTo(to, classes);\n    }, from, to);\n    writeTo(to, \"\");\n}\nclass HighlightBuilder {\n    constructor(at, highlighters, span){\n        this.at = at;\n        this.highlighters = highlighters;\n        this.span = span;\n        this.class = \"\";\n    }\n    startSpan(at, cls) {\n        if (cls != this.class) {\n            this.flush(at);\n            if (at > this.at) this.at = at;\n            this.class = cls;\n        }\n    }\n    flush(to) {\n        if (to > this.at && this.class) this.span(this.at, to, this.class);\n    }\n    highlightRange(cursor, from, to, inheritedClass, highlighters) {\n        let { type, from: start, to: end } = cursor;\n        if (start >= to || end <= from) return;\n        if (type.isTop) highlighters = this.highlighters.filter((h)=>!h.scope || h.scope(type));\n        let cls = inheritedClass;\n        let rule = getStyleTags(cursor) || Rule.empty;\n        let tagCls = highlightTags(highlighters, rule.tags);\n        if (tagCls) {\n            if (cls) cls += \" \";\n            cls += tagCls;\n            if (rule.mode == 1 /* Mode.Inherit */ ) inheritedClass += (inheritedClass ? \" \" : \"\") + tagCls;\n        }\n        this.startSpan(Math.max(from, start), cls);\n        if (rule.opaque) return;\n        let mounted = cursor.tree && cursor.tree.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.mounted);\n        if (mounted && mounted.overlay) {\n            let inner = cursor.node.enter(mounted.overlay[0].from + start, 1);\n            let innerHighlighters = this.highlighters.filter((h)=>!h.scope || h.scope(mounted.tree.type));\n            let hasChild = cursor.firstChild();\n            for(let i = 0, pos = start;; i++){\n                let next = i < mounted.overlay.length ? mounted.overlay[i] : null;\n                let nextPos = next ? next.from + start : end;\n                let rangeFrom = Math.max(from, pos), rangeTo = Math.min(to, nextPos);\n                if (rangeFrom < rangeTo && hasChild) {\n                    while(cursor.from < rangeTo){\n                        this.highlightRange(cursor, rangeFrom, rangeTo, inheritedClass, highlighters);\n                        this.startSpan(Math.min(rangeTo, cursor.to), cls);\n                        if (cursor.to >= nextPos || !cursor.nextSibling()) break;\n                    }\n                }\n                if (!next || nextPos > to) break;\n                pos = next.to + start;\n                if (pos > from) {\n                    this.highlightRange(inner.cursor(), Math.max(from, next.from + start), Math.min(to, pos), \"\", innerHighlighters);\n                    this.startSpan(Math.min(to, pos), cls);\n                }\n            }\n            if (hasChild) cursor.parent();\n        } else if (cursor.firstChild()) {\n            if (mounted) inheritedClass = \"\";\n            do {\n                if (cursor.to <= from) continue;\n                if (cursor.from >= to) break;\n                this.highlightRange(cursor, from, to, inheritedClass, highlighters);\n                this.startSpan(Math.min(to, cursor.to), cls);\n            }while (cursor.nextSibling());\n            cursor.parent();\n        }\n    }\n}\n/**\nMatch a syntax node's [highlight rules](#highlight.styleTags). If\nthere's a match, return its set of tags, and whether it is\nopaque (uses a `!`) or applies to all child nodes (`/...`).\n*/ function getStyleTags(node) {\n    let rule = node.type.prop(ruleNodeProp);\n    while(rule && rule.context && !node.matchContext(rule.context))rule = rule.next;\n    return rule || null;\n}\nconst t = Tag.define;\nconst comment = t(), name = t(), typeName = t(name), propertyName = t(name), literal = t(), string = t(literal), number = t(literal), content = t(), heading = t(content), keyword = t(), operator = t(), punctuation = t(), bracket = t(punctuation), meta = t();\n/**\nThe default set of highlighting [tags](#highlight.Tag).\n\nThis collection is heavily biased towards programming languages,\nand necessarily incomplete. A full ontology of syntactic\nconstructs would fill a stack of books, and be impractical to\nwrite themes for. So try to make do with this set. If all else\nfails, [open an\nissue](https://github.com/codemirror/codemirror.next) to propose a\nnew tag, or [define](#highlight.Tag^define) a local custom tag for\nyour use case.\n\nNote that it is not obligatory to always attach the most specific\ntag possible to an element—if your grammar can't easily\ndistinguish a certain type of element (such as a local variable),\nit is okay to style it as its more general variant (a variable).\n\nFor tags that extend some parent tag, the documentation links to\nthe parent.\n*/ const tags = {\n    /**\n    A comment.\n    */ comment,\n    /**\n    A line [comment](#highlight.tags.comment).\n    */ lineComment: t(comment),\n    /**\n    A block [comment](#highlight.tags.comment).\n    */ blockComment: t(comment),\n    /**\n    A documentation [comment](#highlight.tags.comment).\n    */ docComment: t(comment),\n    /**\n    Any kind of identifier.\n    */ name,\n    /**\n    The [name](#highlight.tags.name) of a variable.\n    */ variableName: t(name),\n    /**\n    A type [name](#highlight.tags.name).\n    */ typeName: typeName,\n    /**\n    A tag name (subtag of [`typeName`](#highlight.tags.typeName)).\n    */ tagName: t(typeName),\n    /**\n    A property or field [name](#highlight.tags.name).\n    */ propertyName: propertyName,\n    /**\n    An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).\n    */ attributeName: t(propertyName),\n    /**\n    The [name](#highlight.tags.name) of a class.\n    */ className: t(name),\n    /**\n    A label [name](#highlight.tags.name).\n    */ labelName: t(name),\n    /**\n    A namespace [name](#highlight.tags.name).\n    */ namespace: t(name),\n    /**\n    The [name](#highlight.tags.name) of a macro.\n    */ macroName: t(name),\n    /**\n    A literal value.\n    */ literal,\n    /**\n    A string [literal](#highlight.tags.literal).\n    */ string,\n    /**\n    A documentation [string](#highlight.tags.string).\n    */ docString: t(string),\n    /**\n    A character literal (subtag of [string](#highlight.tags.string)).\n    */ character: t(string),\n    /**\n    An attribute value (subtag of [string](#highlight.tags.string)).\n    */ attributeValue: t(string),\n    /**\n    A number [literal](#highlight.tags.literal).\n    */ number,\n    /**\n    An integer [number](#highlight.tags.number) literal.\n    */ integer: t(number),\n    /**\n    A floating-point [number](#highlight.tags.number) literal.\n    */ float: t(number),\n    /**\n    A boolean [literal](#highlight.tags.literal).\n    */ bool: t(literal),\n    /**\n    Regular expression [literal](#highlight.tags.literal).\n    */ regexp: t(literal),\n    /**\n    An escape [literal](#highlight.tags.literal), for example a\n    backslash escape in a string.\n    */ escape: t(literal),\n    /**\n    A color [literal](#highlight.tags.literal).\n    */ color: t(literal),\n    /**\n    A URL [literal](#highlight.tags.literal).\n    */ url: t(literal),\n    /**\n    A language keyword.\n    */ keyword,\n    /**\n    The [keyword](#highlight.tags.keyword) for the self or this\n    object.\n    */ self: t(keyword),\n    /**\n    The [keyword](#highlight.tags.keyword) for null.\n    */ null: t(keyword),\n    /**\n    A [keyword](#highlight.tags.keyword) denoting some atomic value.\n    */ atom: t(keyword),\n    /**\n    A [keyword](#highlight.tags.keyword) that represents a unit.\n    */ unit: t(keyword),\n    /**\n    A modifier [keyword](#highlight.tags.keyword).\n    */ modifier: t(keyword),\n    /**\n    A [keyword](#highlight.tags.keyword) that acts as an operator.\n    */ operatorKeyword: t(keyword),\n    /**\n    A control-flow related [keyword](#highlight.tags.keyword).\n    */ controlKeyword: t(keyword),\n    /**\n    A [keyword](#highlight.tags.keyword) that defines something.\n    */ definitionKeyword: t(keyword),\n    /**\n    A [keyword](#highlight.tags.keyword) related to defining or\n    interfacing with modules.\n    */ moduleKeyword: t(keyword),\n    /**\n    An operator.\n    */ operator,\n    /**\n    An [operator](#highlight.tags.operator) that dereferences something.\n    */ derefOperator: t(operator),\n    /**\n    Arithmetic-related [operator](#highlight.tags.operator).\n    */ arithmeticOperator: t(operator),\n    /**\n    Logical [operator](#highlight.tags.operator).\n    */ logicOperator: t(operator),\n    /**\n    Bit [operator](#highlight.tags.operator).\n    */ bitwiseOperator: t(operator),\n    /**\n    Comparison [operator](#highlight.tags.operator).\n    */ compareOperator: t(operator),\n    /**\n    [Operator](#highlight.tags.operator) that updates its operand.\n    */ updateOperator: t(operator),\n    /**\n    [Operator](#highlight.tags.operator) that defines something.\n    */ definitionOperator: t(operator),\n    /**\n    Type-related [operator](#highlight.tags.operator).\n    */ typeOperator: t(operator),\n    /**\n    Control-flow [operator](#highlight.tags.operator).\n    */ controlOperator: t(operator),\n    /**\n    Program or markup punctuation.\n    */ punctuation,\n    /**\n    [Punctuation](#highlight.tags.punctuation) that separates\n    things.\n    */ separator: t(punctuation),\n    /**\n    Bracket-style [punctuation](#highlight.tags.punctuation).\n    */ bracket,\n    /**\n    Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`\n    tokens).\n    */ angleBracket: t(bracket),\n    /**\n    Square [brackets](#highlight.tags.bracket) (usually `[` and `]`\n    tokens).\n    */ squareBracket: t(bracket),\n    /**\n    Parentheses (usually `(` and `)` tokens). Subtag of\n    [bracket](#highlight.tags.bracket).\n    */ paren: t(bracket),\n    /**\n    Braces (usually `{` and `}` tokens). Subtag of\n    [bracket](#highlight.tags.bracket).\n    */ brace: t(bracket),\n    /**\n    Content, for example plain text in XML or markup documents.\n    */ content,\n    /**\n    [Content](#highlight.tags.content) that represents a heading.\n    */ heading,\n    /**\n    A level 1 [heading](#highlight.tags.heading).\n    */ heading1: t(heading),\n    /**\n    A level 2 [heading](#highlight.tags.heading).\n    */ heading2: t(heading),\n    /**\n    A level 3 [heading](#highlight.tags.heading).\n    */ heading3: t(heading),\n    /**\n    A level 4 [heading](#highlight.tags.heading).\n    */ heading4: t(heading),\n    /**\n    A level 5 [heading](#highlight.tags.heading).\n    */ heading5: t(heading),\n    /**\n    A level 6 [heading](#highlight.tags.heading).\n    */ heading6: t(heading),\n    /**\n    A prose separator (such as a horizontal rule).\n    */ contentSeparator: t(content),\n    /**\n    [Content](#highlight.tags.content) that represents a list.\n    */ list: t(content),\n    /**\n    [Content](#highlight.tags.content) that represents a quote.\n    */ quote: t(content),\n    /**\n    [Content](#highlight.tags.content) that is emphasized.\n    */ emphasis: t(content),\n    /**\n    [Content](#highlight.tags.content) that is styled strong.\n    */ strong: t(content),\n    /**\n    [Content](#highlight.tags.content) that is part of a link.\n    */ link: t(content),\n    /**\n    [Content](#highlight.tags.content) that is styled as code or\n    monospace.\n    */ monospace: t(content),\n    /**\n    [Content](#highlight.tags.content) that has a strike-through\n    style.\n    */ strikethrough: t(content),\n    /**\n    Inserted text in a change-tracking format.\n    */ inserted: t(),\n    /**\n    Deleted text.\n    */ deleted: t(),\n    /**\n    Changed text.\n    */ changed: t(),\n    /**\n    An invalid or unsyntactic element.\n    */ invalid: t(),\n    /**\n    Metadata or meta-instruction.\n    */ meta,\n    /**\n    [Metadata](#highlight.tags.meta) that applies to the entire\n    document.\n    */ documentMeta: t(meta),\n    /**\n    [Metadata](#highlight.tags.meta) that annotates or adds\n    attributes to a given syntactic element.\n    */ annotation: t(meta),\n    /**\n    Processing instruction or preprocessor directive. Subtag of\n    [meta](#highlight.tags.meta).\n    */ processingInstruction: t(meta),\n    /**\n    [Modifier](#highlight.Tag^defineModifier) that indicates that a\n    given element is being defined. Expected to be used with the\n    various [name](#highlight.tags.name) tags.\n    */ definition: Tag.defineModifier(),\n    /**\n    [Modifier](#highlight.Tag^defineModifier) that indicates that\n    something is constant. Mostly expected to be used with\n    [variable names](#highlight.tags.variableName).\n    */ constant: Tag.defineModifier(),\n    /**\n    [Modifier](#highlight.Tag^defineModifier) used to indicate that\n    a [variable](#highlight.tags.variableName) or [property\n    name](#highlight.tags.propertyName) is being called or defined\n    as a function.\n    */ function: Tag.defineModifier(),\n    /**\n    [Modifier](#highlight.Tag^defineModifier) that can be applied to\n    [names](#highlight.tags.name) to indicate that they belong to\n    the language's standard environment.\n    */ standard: Tag.defineModifier(),\n    /**\n    [Modifier](#highlight.Tag^defineModifier) that indicates a given\n    [names](#highlight.tags.name) is local to some scope.\n    */ local: Tag.defineModifier(),\n    /**\n    A generic variant [modifier](#highlight.Tag^defineModifier) that\n    can be used to tag language-specific alternative variants of\n    some common tag. It is recommended for themes to define special\n    forms of at least the [string](#highlight.tags.string) and\n    [variable name](#highlight.tags.variableName) tags, since those\n    come up a lot.\n    */ special: Tag.defineModifier()\n};\n/**\nThis is a highlighter that adds stable, predictable classes to\ntokens, for styling with external CSS.\n\nThe following tags are mapped to their name prefixed with `\"tok-\"`\n(for example `\"tok-comment\"`):\n\n* [`link`](#highlight.tags.link)\n* [`heading`](#highlight.tags.heading)\n* [`emphasis`](#highlight.tags.emphasis)\n* [`strong`](#highlight.tags.strong)\n* [`keyword`](#highlight.tags.keyword)\n* [`atom`](#highlight.tags.atom)\n* [`bool`](#highlight.tags.bool)\n* [`url`](#highlight.tags.url)\n* [`labelName`](#highlight.tags.labelName)\n* [`inserted`](#highlight.tags.inserted)\n* [`deleted`](#highlight.tags.deleted)\n* [`literal`](#highlight.tags.literal)\n* [`string`](#highlight.tags.string)\n* [`number`](#highlight.tags.number)\n* [`variableName`](#highlight.tags.variableName)\n* [`typeName`](#highlight.tags.typeName)\n* [`namespace`](#highlight.tags.namespace)\n* [`className`](#highlight.tags.className)\n* [`macroName`](#highlight.tags.macroName)\n* [`propertyName`](#highlight.tags.propertyName)\n* [`operator`](#highlight.tags.operator)\n* [`comment`](#highlight.tags.comment)\n* [`meta`](#highlight.tags.meta)\n* [`punctuation`](#highlight.tags.punctuation)\n* [`invalid`](#highlight.tags.invalid)\n\nIn addition, these mappings are provided:\n\n* [`regexp`](#highlight.tags.regexp),\n  [`escape`](#highlight.tags.escape), and\n  [`special`](#highlight.tags.special)[`(string)`](#highlight.tags.string)\n  are mapped to `\"tok-string2\"`\n* [`special`](#highlight.tags.special)[`(variableName)`](#highlight.tags.variableName)\n  to `\"tok-variableName2\"`\n* [`local`](#highlight.tags.local)[`(variableName)`](#highlight.tags.variableName)\n  to `\"tok-variableName tok-local\"`\n* [`definition`](#highlight.tags.definition)[`(variableName)`](#highlight.tags.variableName)\n  to `\"tok-variableName tok-definition\"`\n* [`definition`](#highlight.tags.definition)[`(propertyName)`](#highlight.tags.propertyName)\n  to `\"tok-propertyName tok-definition\"`\n*/ const classHighlighter = tagHighlighter([\n    {\n        tag: tags.link,\n        class: \"tok-link\"\n    },\n    {\n        tag: tags.heading,\n        class: \"tok-heading\"\n    },\n    {\n        tag: tags.emphasis,\n        class: \"tok-emphasis\"\n    },\n    {\n        tag: tags.strong,\n        class: \"tok-strong\"\n    },\n    {\n        tag: tags.keyword,\n        class: \"tok-keyword\"\n    },\n    {\n        tag: tags.atom,\n        class: \"tok-atom\"\n    },\n    {\n        tag: tags.bool,\n        class: \"tok-bool\"\n    },\n    {\n        tag: tags.url,\n        class: \"tok-url\"\n    },\n    {\n        tag: tags.labelName,\n        class: \"tok-labelName\"\n    },\n    {\n        tag: tags.inserted,\n        class: \"tok-inserted\"\n    },\n    {\n        tag: tags.deleted,\n        class: \"tok-deleted\"\n    },\n    {\n        tag: tags.literal,\n        class: \"tok-literal\"\n    },\n    {\n        tag: tags.string,\n        class: \"tok-string\"\n    },\n    {\n        tag: tags.number,\n        class: \"tok-number\"\n    },\n    {\n        tag: [\n            tags.regexp,\n            tags.escape,\n            tags.special(tags.string)\n        ],\n        class: \"tok-string2\"\n    },\n    {\n        tag: tags.variableName,\n        class: \"tok-variableName\"\n    },\n    {\n        tag: tags.local(tags.variableName),\n        class: \"tok-variableName tok-local\"\n    },\n    {\n        tag: tags.definition(tags.variableName),\n        class: \"tok-variableName tok-definition\"\n    },\n    {\n        tag: tags.special(tags.variableName),\n        class: \"tok-variableName2\"\n    },\n    {\n        tag: tags.definition(tags.propertyName),\n        class: \"tok-propertyName tok-definition\"\n    },\n    {\n        tag: tags.typeName,\n        class: \"tok-typeName\"\n    },\n    {\n        tag: tags.namespace,\n        class: \"tok-namespace\"\n    },\n    {\n        tag: tags.className,\n        class: \"tok-className\"\n    },\n    {\n        tag: tags.macroName,\n        class: \"tok-macroName\"\n    },\n    {\n        tag: tags.propertyName,\n        class: \"tok-propertyName\"\n    },\n    {\n        tag: tags.operator,\n        class: \"tok-operator\"\n    },\n    {\n        tag: tags.comment,\n        class: \"tok-comment\"\n    },\n    {\n        tag: tags.meta,\n        class: \"tok-meta\"\n    },\n    {\n        tag: tags.invalid,\n        class: \"tok-invalid\"\n    },\n    {\n        tag: tags.punctuation,\n        class: \"tok-punctuation\"\n    }\n]);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxlemVyL2hpZ2hsaWdodC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUF5QztBQUV6QyxJQUFJQyxZQUFZO0FBQ2hCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQkEsR0FDQSxNQUFNQztJQUNGOztJQUVBLEdBQ0FDLFlBQ0E7OztJQUdBLEdBQ0FDLEdBQUcsRUFDSDs7O0lBR0EsR0FDQUMsSUFBSSxFQUNKOztJQUVBLEdBQ0FDLFFBQVEsQ0FBRTtRQUNOLElBQUksQ0FBQ0YsR0FBRyxHQUFHQTtRQUNYLElBQUksQ0FBQ0MsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQ0MsUUFBUSxHQUFHQTtRQUNoQjs7UUFFQSxHQUNBLElBQUksQ0FBQ0MsRUFBRSxHQUFHTjtJQUNkO0lBQ0E7Ozs7OztJQU1BLEdBQ0EsT0FBT08sT0FBT0MsTUFBTSxFQUFFO1FBQ2xCLElBQUlBLFdBQVcsUUFBUUEsV0FBVyxLQUFLLElBQUksS0FBSyxJQUFJQSxPQUFPSixJQUFJLEVBQzNELE1BQU0sSUFBSUssTUFBTTtRQUNwQixJQUFJQyxNQUFNLElBQUlULElBQUksRUFBRSxFQUFFLE1BQU0sRUFBRTtRQUM5QlMsSUFBSVAsR0FBRyxDQUFDUSxJQUFJLENBQUNEO1FBQ2IsSUFBSUYsUUFDQSxLQUFLLElBQUlJLEtBQUtKLE9BQU9MLEdBQUcsQ0FDcEJPLElBQUlQLEdBQUcsQ0FBQ1EsSUFBSSxDQUFDQztRQUNyQixPQUFPRjtJQUNYO0lBQ0E7Ozs7Ozs7Ozs7O0lBV0EsR0FDQSxPQUFPRyxpQkFBaUI7UUFDcEIsSUFBSUMsTUFBTSxJQUFJQztRQUNkLE9BQU8sQ0FBQ0w7WUFDSixJQUFJQSxJQUFJTCxRQUFRLENBQUNXLE9BQU8sQ0FBQ0YsT0FBTyxDQUFDLEdBQzdCLE9BQU9KO1lBQ1gsT0FBT0ssU0FBU0UsR0FBRyxDQUFDUCxJQUFJTixJQUFJLElBQUlNLEtBQUtBLElBQUlMLFFBQVEsQ0FBQ2EsTUFBTSxDQUFDSixLQUFL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ZXplci9oaWdobGlnaHQvZGlzdC9pbmRleC5qcz9mMjlhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE5vZGVQcm9wIH0gZnJvbSAnQGxlemVyL2NvbW1vbic7XG5cbmxldCBuZXh0VGFnSUQgPSAwO1xuLyoqXG5IaWdobGlnaHRpbmcgdGFncyBhcmUgbWFya2VycyB0aGF0IGRlbm90ZSBhIGhpZ2hsaWdodGluZyBjYXRlZ29yeS5cblRoZXkgYXJlIFthc3NvY2lhdGVkXSgjaGlnaGxpZ2h0LnN0eWxlVGFncykgd2l0aCBwYXJ0cyBvZiBhIHN5bnRheFxudHJlZSBieSBhIGxhbmd1YWdlIG1vZGUsIGFuZCB0aGVuIG1hcHBlZCB0byBhbiBhY3R1YWwgQ1NTIHN0eWxlIGJ5XG5hIFtoaWdobGlnaHRlcl0oI2hpZ2hsaWdodC5IaWdobGlnaHRlcikuXG5cbkJlY2F1c2Ugc3ludGF4IHRyZWUgbm9kZSB0eXBlcyBhbmQgaGlnaGxpZ2h0IHN0eWxlcyBoYXZlIHRvIGJlXG5hYmxlIHRvIHRhbGsgdGhlIHNhbWUgbGFuZ3VhZ2UsIENvZGVNaXJyb3IgdXNlcyBhIG1vc3RseSBfY2xvc2VkX1xuW3ZvY2FidWxhcnldKCNoaWdobGlnaHQudGFncykgb2Ygc3ludGF4IHRhZ3MgKGFzIG9wcG9zZWQgdG9cbnRyYWRpdGlvbmFsIG9wZW4gc3RyaW5nLWJhc2VkIHN5c3RlbXMsIHdoaWNoIG1ha2UgaXQgaGFyZCBmb3JcbmhpZ2hsaWdodGluZyB0aGVtZXMgdG8gY292ZXIgYWxsIHRoZSB0b2tlbnMgcHJvZHVjZWQgYnkgdGhlXG52YXJpb3VzIGxhbmd1YWdlcykuXG5cbkl0IF9pc18gcG9zc2libGUgdG8gW2RlZmluZV0oI2hpZ2hsaWdodC5UYWdeZGVmaW5lKSB5b3VyIG93blxuaGlnaGxpZ2h0aW5nIHRhZ3MgZm9yIHN5c3RlbS1pbnRlcm5hbCB1c2UgKHdoZXJlIHlvdSBjb250cm9sIGJvdGhcbnRoZSBsYW5ndWFnZSBwYWNrYWdlIGFuZCB0aGUgaGlnaGxpZ2h0ZXIpLCBidXQgc3VjaCB0YWdzIHdpbGwgbm90XG5iZSBwaWNrZWQgdXAgYnkgcmVndWxhciBoaWdobGlnaHRlcnMgKHRob3VnaCB5b3UgY2FuIGRlcml2ZSB0aGVtXG5mcm9tIHN0YW5kYXJkIHRhZ3MgdG8gYWxsb3cgaGlnaGxpZ2h0ZXJzIHRvIGZhbGwgYmFjayB0byB0aG9zZSkuXG4qL1xuY2xhc3MgVGFnIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBzZXQgb2YgdGhpcyB0YWcgYW5kIGFsbCBpdHMgcGFyZW50IHRhZ3MsIHN0YXJ0aW5nIHdpdGhcbiAgICB0aGlzIG9uZSBpdHNlbGYgYW5kIHNvcnRlZCBpbiBvcmRlciBvZiBkZWNyZWFzaW5nIHNwZWNpZmljaXR5LlxuICAgICovXG4gICAgc2V0LCBcbiAgICAvKipcbiAgICBUaGUgYmFzZSB1bm1vZGlmaWVkIHRhZyB0aGF0IHRoaXMgb25lIGlzIGJhc2VkIG9uLCBpZiBpdCdzXG4gICAgbW9kaWZpZWQgQGludGVybmFsXG4gICAgKi9cbiAgICBiYXNlLCBcbiAgICAvKipcbiAgICBUaGUgbW9kaWZpZXJzIGFwcGxpZWQgdG8gdGhpcy5iYXNlIEBpbnRlcm5hbFxuICAgICovXG4gICAgbW9kaWZpZWQpIHtcbiAgICAgICAgdGhpcy5zZXQgPSBzZXQ7XG4gICAgICAgIHRoaXMuYmFzZSA9IGJhc2U7XG4gICAgICAgIHRoaXMubW9kaWZpZWQgPSBtb2RpZmllZDtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmlkID0gbmV4dFRhZ0lEKys7XG4gICAgfVxuICAgIC8qKlxuICAgIERlZmluZSBhIG5ldyB0YWcuIElmIGBwYXJlbnRgIGlzIGdpdmVuLCB0aGUgdGFnIGlzIHRyZWF0ZWQgYXMgYVxuICAgIHN1Yi10YWcgb2YgdGhhdCBwYXJlbnQsIGFuZFxuICAgIFtoaWdobGlnaHRlcnNdKCNoaWdobGlnaHQudGFnSGlnaGxpZ2h0ZXIpIHRoYXQgZG9uJ3QgbWVudGlvblxuICAgIHRoaXMgdGFnIHdpbGwgdHJ5IHRvIGZhbGwgYmFjayB0byB0aGUgcGFyZW50IHRhZyAob3IgZ3JhbmRwYXJlbnRcbiAgICB0YWcsIGV0YykuXG4gICAgKi9cbiAgICBzdGF0aWMgZGVmaW5lKHBhcmVudCkge1xuICAgICAgICBpZiAocGFyZW50ID09PSBudWxsIHx8IHBhcmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyZW50LmJhc2UpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IGRlcml2ZSBmcm9tIGEgbW9kaWZpZWQgdGFnXCIpO1xuICAgICAgICBsZXQgdGFnID0gbmV3IFRhZyhbXSwgbnVsbCwgW10pO1xuICAgICAgICB0YWcuc2V0LnB1c2godGFnKTtcbiAgICAgICAgaWYgKHBhcmVudClcbiAgICAgICAgICAgIGZvciAobGV0IHQgb2YgcGFyZW50LnNldClcbiAgICAgICAgICAgICAgICB0YWcuc2V0LnB1c2godCk7XG4gICAgICAgIHJldHVybiB0YWc7XG4gICAgfVxuICAgIC8qKlxuICAgIERlZmluZSBhIHRhZyBfbW9kaWZpZXJfLCB3aGljaCBpcyBhIGZ1bmN0aW9uIHRoYXQsIGdpdmVuIGEgdGFnLFxuICAgIHdpbGwgcmV0dXJuIGEgdGFnIHRoYXQgaXMgYSBzdWJ0YWcgb2YgdGhlIG9yaWdpbmFsLiBBcHBseWluZyB0aGVcbiAgICBzYW1lIG1vZGlmaWVyIHRvIGEgdHdpY2UgdGFnIHdpbGwgcmV0dXJuIHRoZSBzYW1lIHZhbHVlIChgbTEodDEpXG4gICAgPT0gbTEodDEpYCkgYW5kIGFwcGx5aW5nIG11bHRpcGxlIG1vZGlmaWVycyB3aWxsLCByZWdhcmRsZXNzIG9yXG4gICAgb3JkZXIsIHByb2R1Y2UgdGhlIHNhbWUgdGFnIChgbTEobTIodDEpKSA9PSBtMihtMSh0MSkpYCkuXG4gICAgXG4gICAgV2hlbiBtdWx0aXBsZSBtb2RpZmllcnMgYXJlIGFwcGxpZWQgdG8gYSBnaXZlbiBiYXNlIHRhZywgZWFjaFxuICAgIHNtYWxsZXIgc2V0IG9mIG1vZGlmaWVycyBpcyByZWdpc3RlcmVkIGFzIGEgcGFyZW50LCBzbyB0aGF0IGZvclxuICAgIGV4YW1wbGUgYG0xKG0yKG0zKHQxKSkpYCBpcyBhIHN1YnR5cGUgb2YgYG0xKG0yKHQxKSlgLFxuICAgIGBtMShtMyh0MSlgLCBhbmQgc28gb24uXG4gICAgKi9cbiAgICBzdGF0aWMgZGVmaW5lTW9kaWZpZXIoKSB7XG4gICAgICAgIGxldCBtb2QgPSBuZXcgTW9kaWZpZXI7XG4gICAgICAgIHJldHVybiAodGFnKSA9PiB7XG4gICAgICAgICAgICBpZiAodGFnLm1vZGlmaWVkLmluZGV4T2YobW9kKSA+IC0xKVxuICAgICAgICAgICAgICAgIHJldHVybiB0YWc7XG4gICAgICAgICAgICByZXR1cm4gTW9kaWZpZXIuZ2V0KHRhZy5iYXNlIHx8IHRhZywgdGFnLm1vZGlmaWVkLmNvbmNhdChtb2QpLnNvcnQoKGEsIGIpID0+IGEuaWQgLSBiLmlkKSk7XG4gICAgICAgIH07XG4gICAgfVxufVxubGV0IG5leHRNb2RpZmllcklEID0gMDtcbmNsYXNzIE1vZGlmaWVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5pbnN0YW5jZXMgPSBbXTtcbiAgICAgICAgdGhpcy5pZCA9IG5leHRNb2RpZmllcklEKys7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQoYmFzZSwgbW9kcykge1xuICAgICAgICBpZiAoIW1vZHMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgICAgIGxldCBleGlzdHMgPSBtb2RzWzBdLmluc3RhbmNlcy5maW5kKHQgPT4gdC5iYXNlID09IGJhc2UgJiYgc2FtZUFycmF5KG1vZHMsIHQubW9kaWZpZWQpKTtcbiAgICAgICAgaWYgKGV4aXN0cylcbiAgICAgICAgICAgIHJldHVybiBleGlzdHM7XG4gICAgICAgIGxldCBzZXQgPSBbXSwgdGFnID0gbmV3IFRhZyhzZXQsIGJhc2UsIG1vZHMpO1xuICAgICAgICBmb3IgKGxldCBtIG9mIG1vZHMpXG4gICAgICAgICAgICBtLmluc3RhbmNlcy5wdXNoKHRhZyk7XG4gICAgICAgIGxldCBjb25maWdzID0gcG93ZXJTZXQobW9kcyk7XG4gICAgICAgIGZvciAobGV0IHBhcmVudCBvZiBiYXNlLnNldClcbiAgICAgICAgICAgIGlmICghcGFyZW50Lm1vZGlmaWVkLmxlbmd0aClcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjb25maWcgb2YgY29uZmlncylcbiAgICAgICAgICAgICAgICAgICAgc2V0LnB1c2goTW9kaWZpZXIuZ2V0KHBhcmVudCwgY29uZmlnKSk7XG4gICAgICAgIHJldHVybiB0YWc7XG4gICAgfVxufVxuZnVuY3Rpb24gc2FtZUFycmF5KGEsIGIpIHtcbiAgICByZXR1cm4gYS5sZW5ndGggPT0gYi5sZW5ndGggJiYgYS5ldmVyeSgoeCwgaSkgPT4geCA9PSBiW2ldKTtcbn1cbmZ1bmN0aW9uIHBvd2VyU2V0KGFycmF5KSB7XG4gICAgbGV0IHNldHMgPSBbW11dO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZm9yIChsZXQgaiA9IDAsIGUgPSBzZXRzLmxlbmd0aDsgaiA8IGU7IGorKykge1xuICAgICAgICAgICAgc2V0cy5wdXNoKHNldHNbal0uY29uY2F0KGFycmF5W2ldKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNldHMuc29ydCgoYSwgYikgPT4gYi5sZW5ndGggLSBhLmxlbmd0aCk7XG59XG4vKipcblRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byBhZGQgYSBzZXQgb2YgdGFncyB0byBhIGxhbmd1YWdlIHN5bnRheFxudmlhIFtgTm9kZVNldC5leHRlbmRgXSgjY29tbW9uLk5vZGVTZXQuZXh0ZW5kKSBvclxuW2BMUlBhcnNlci5jb25maWd1cmVgXSgjbHIuTFJQYXJzZXIuY29uZmlndXJlKS5cblxuVGhlIGFyZ3VtZW50IG9iamVjdCBtYXBzIG5vZGUgc2VsZWN0b3JzIHRvIFtoaWdobGlnaHRpbmdcbnRhZ3NdKCNoaWdobGlnaHQuVGFnKSBvciBhcnJheXMgb2YgdGFncy5cblxuTm9kZSBzZWxlY3RvcnMgbWF5IGhvbGQgb25lIG9yIG1vcmUgKHNwYWNlLXNlcGFyYXRlZCkgbm9kZSBwYXRocy5cblN1Y2ggYSBwYXRoIGNhbiBiZSBhIFtub2RlIG5hbWVdKCNjb21tb24uTm9kZVR5cGUubmFtZSksIG9yXG5tdWx0aXBsZSBub2RlIG5hbWVzIChvciBgKmAgd2lsZGNhcmRzKSBzZXBhcmF0ZWQgYnkgc2xhc2hcbmNoYXJhY3RlcnMsIGFzIGluIGBcIkJsb2NrL0RlY2xhcmF0aW9uL1ZhcmlhYmxlTmFtZVwiYC4gU3VjaCBhIHBhdGhcbm1hdGNoZXMgdGhlIGZpbmFsIG5vZGUgYnV0IG9ubHkgaWYgaXRzIGRpcmVjdCBwYXJlbnQgbm9kZXMgYXJlIHRoZVxub3RoZXIgbm9kZXMgbWVudGlvbmVkLiBBIGAqYCBpbiBzdWNoIGEgcGF0aCBtYXRjaGVzIGFueSBwYXJlbnQsXG5idXQgb25seSBhIHNpbmdsZSBsZXZlbOKAlHdpbGRjYXJkcyB0aGF0IG1hdGNoIG11bHRpcGxlIHBhcmVudHNcbmFyZW4ndCBzdXBwb3J0ZWQsIGJvdGggZm9yIGVmZmljaWVuY3kgcmVhc29ucyBhbmQgYmVjYXVzZSBMZXplclxudHJlZXMgbWFrZSBpdCByYXRoZXIgaGFyZCB0byByZWFzb24gYWJvdXQgd2hhdCB0aGV5IHdvdWxkIG1hdGNoLilcblxuQSBwYXRoIGNhbiBiZSBlbmRlZCB3aXRoIGAvLi4uYCB0byBpbmRpY2F0ZSB0aGF0IHRoZSB0YWcgYXNzaWduZWRcbnRvIHRoZSBub2RlIHNob3VsZCBhbHNvIGFwcGx5IHRvIGFsbCBjaGlsZCBub2RlcywgZXZlbiBpZiB0aGV5XG5tYXRjaCB0aGVpciBvd24gc3R5bGUgKGJ5IGRlZmF1bHQsIG9ubHkgdGhlIGlubmVybW9zdCBzdHlsZSBpc1xudXNlZCkuXG5cbldoZW4gYSBwYXRoIGVuZHMgaW4gYCFgLCBhcyBpbiBgQXR0cmlidXRlIWAsIG5vIGZ1cnRoZXIgbWF0Y2hpbmdcbmhhcHBlbnMgZm9yIHRoZSBub2RlJ3MgY2hpbGQgbm9kZXMsIGFuZCB0aGUgZW50aXJlIG5vZGUgZ2V0cyB0aGVcbmdpdmVuIHN0eWxlLlxuXG5JbiB0aGlzIG5vdGF0aW9uLCBub2RlIG5hbWVzIHRoYXQgY29udGFpbiBgL2AsIGAhYCwgYCpgLCBvciBgLi4uYFxubXVzdCBiZSBxdW90ZWQgYXMgSlNPTiBzdHJpbmdzLlxuXG5Gb3IgZXhhbXBsZTpcblxuYGBgamF2YXNjcmlwdFxucGFyc2VyLndpdGhQcm9wcyhcbiAgc3R5bGVUYWdzKHtcbiAgICAvLyBTdHlsZSBOdW1iZXIgYW5kIEJpZ051bWJlciBub2Rlc1xuICAgIFwiTnVtYmVyIEJpZ051bWJlclwiOiB0YWdzLm51bWJlcixcbiAgICAvLyBTdHlsZSBFc2NhcGUgbm9kZXMgd2hvc2UgcGFyZW50IGlzIFN0cmluZ1xuICAgIFwiU3RyaW5nL0VzY2FwZVwiOiB0YWdzLmVzY2FwZSxcbiAgICAvLyBTdHlsZSBhbnl0aGluZyBpbnNpZGUgQXR0cmlidXRlcyBub2Rlc1xuICAgIFwiQXR0cmlidXRlcyFcIjogdGFncy5tZXRhLFxuICAgIC8vIEFkZCBhIHN0eWxlIHRvIGFsbCBjb250ZW50IGluc2lkZSBJdGFsaWMgbm9kZXNcbiAgICBcIkl0YWxpYy8uLi5cIjogdGFncy5lbXBoYXNpcyxcbiAgICAvLyBTdHlsZSBJbnZhbGlkU3RyaW5nIG5vZGVzIGFzIGJvdGggYHN0cmluZ2AgYW5kIGBpbnZhbGlkYFxuICAgIFwiSW52YWxpZFN0cmluZ1wiOiBbdGFncy5zdHJpbmcsIHRhZ3MuaW52YWxpZF0sXG4gICAgLy8gU3R5bGUgdGhlIG5vZGUgbmFtZWQgXCIvXCIgYXMgcHVuY3R1YXRpb25cbiAgICAnXCIvXCInOiB0YWdzLnB1bmN0dWF0aW9uXG4gIH0pXG4pXG5gYGBcbiovXG5mdW5jdGlvbiBzdHlsZVRhZ3Moc3BlYykge1xuICAgIGxldCBieU5hbWUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGZvciAobGV0IHByb3AgaW4gc3BlYykge1xuICAgICAgICBsZXQgdGFncyA9IHNwZWNbcHJvcF07XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh0YWdzKSlcbiAgICAgICAgICAgIHRhZ3MgPSBbdGFnc107XG4gICAgICAgIGZvciAobGV0IHBhcnQgb2YgcHJvcC5zcGxpdChcIiBcIikpXG4gICAgICAgICAgICBpZiAocGFydCkge1xuICAgICAgICAgICAgICAgIGxldCBwaWVjZXMgPSBbXSwgbW9kZSA9IDIgLyogTW9kZS5Ob3JtYWwgKi8sIHJlc3QgPSBwYXJ0O1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHBvcyA9IDA7Oykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdCA9PSBcIi4uLlwiICYmIHBvcyA+IDAgJiYgcG9zICsgMyA9PSBwYXJ0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZSA9IDEgLyogTW9kZS5Jbmhlcml0ICovO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGV0IG0gPSAvXlwiKD86W15cIlxcXFxdfFxcXFwuKSo/XCJ8W15cXC8hXSsvLmV4ZWMocmVzdCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBwYXRoOiBcIiArIHBhcnQpO1xuICAgICAgICAgICAgICAgICAgICBwaWVjZXMucHVzaChtWzBdID09IFwiKlwiID8gXCJcIiA6IG1bMF1bMF0gPT0gJ1wiJyA/IEpTT04ucGFyc2UobVswXSkgOiBtWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgcG9zICs9IG1bMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zID09IHBhcnQubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gcGFydFtwb3MrK107XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3MgPT0gcGFydC5sZW5ndGggJiYgbmV4dCA9PSBcIiFcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZSA9IDAgLyogTW9kZS5PcGFxdWUgKi87XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCAhPSBcIi9cIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBwYXRoOiBcIiArIHBhcnQpO1xuICAgICAgICAgICAgICAgICAgICByZXN0ID0gcGFydC5zbGljZShwb3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgbGFzdCA9IHBpZWNlcy5sZW5ndGggLSAxLCBpbm5lciA9IHBpZWNlc1tsYXN0XTtcbiAgICAgICAgICAgICAgICBpZiAoIWlubmVyKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgcGF0aDogXCIgKyBwYXJ0KTtcbiAgICAgICAgICAgICAgICBsZXQgcnVsZSA9IG5ldyBSdWxlKHRhZ3MsIG1vZGUsIGxhc3QgPiAwID8gcGllY2VzLnNsaWNlKDAsIGxhc3QpIDogbnVsbCk7XG4gICAgICAgICAgICAgICAgYnlOYW1lW2lubmVyXSA9IHJ1bGUuc29ydChieU5hbWVbaW5uZXJdKTtcbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJ1bGVOb2RlUHJvcC5hZGQoYnlOYW1lKTtcbn1cbmNvbnN0IHJ1bGVOb2RlUHJvcCA9IG5ldyBOb2RlUHJvcCgpO1xuY2xhc3MgUnVsZSB7XG4gICAgY29uc3RydWN0b3IodGFncywgbW9kZSwgY29udGV4dCwgbmV4dCkge1xuICAgICAgICB0aGlzLnRhZ3MgPSB0YWdzO1xuICAgICAgICB0aGlzLm1vZGUgPSBtb2RlO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLm5leHQgPSBuZXh0O1xuICAgIH1cbiAgICBnZXQgb3BhcXVlKCkgeyByZXR1cm4gdGhpcy5tb2RlID09IDAgLyogTW9kZS5PcGFxdWUgKi87IH1cbiAgICBnZXQgaW5oZXJpdCgpIHsgcmV0dXJuIHRoaXMubW9kZSA9PSAxIC8qIE1vZGUuSW5oZXJpdCAqLzsgfVxuICAgIHNvcnQob3RoZXIpIHtcbiAgICAgICAgaWYgKCFvdGhlciB8fCBvdGhlci5kZXB0aCA8IHRoaXMuZGVwdGgpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dCA9IG90aGVyO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgb3RoZXIubmV4dCA9IHRoaXMuc29ydChvdGhlci5uZXh0KTtcbiAgICAgICAgcmV0dXJuIG90aGVyO1xuICAgIH1cbiAgICBnZXQgZGVwdGgoKSB7IHJldHVybiB0aGlzLmNvbnRleHQgPyB0aGlzLmNvbnRleHQubGVuZ3RoIDogMDsgfVxufVxuUnVsZS5lbXB0eSA9IG5ldyBSdWxlKFtdLCAyIC8qIE1vZGUuTm9ybWFsICovLCBudWxsKTtcbi8qKlxuRGVmaW5lIGEgW2hpZ2hsaWdodGVyXSgjaGlnaGxpZ2h0LkhpZ2hsaWdodGVyKSBmcm9tIGFuIGFycmF5IG9mXG50YWcvY2xhc3MgcGFpcnMuIENsYXNzZXMgYXNzb2NpYXRlZCB3aXRoIG1vcmUgc3BlY2lmaWMgdGFncyB3aWxsXG50YWtlIHByZWNlZGVuY2UuXG4qL1xuZnVuY3Rpb24gdGFnSGlnaGxpZ2h0ZXIodGFncywgb3B0aW9ucykge1xuICAgIGxldCBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGZvciAobGV0IHN0eWxlIG9mIHRhZ3MpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHN0eWxlLnRhZykpXG4gICAgICAgICAgICBtYXBbc3R5bGUudGFnLmlkXSA9IHN0eWxlLmNsYXNzO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBmb3IgKGxldCB0YWcgb2Ygc3R5bGUudGFnKVxuICAgICAgICAgICAgICAgIG1hcFt0YWcuaWRdID0gc3R5bGUuY2xhc3M7XG4gICAgfVxuICAgIGxldCB7IHNjb3BlLCBhbGwgPSBudWxsIH0gPSBvcHRpb25zIHx8IHt9O1xuICAgIHJldHVybiB7XG4gICAgICAgIHN0eWxlOiAodGFncykgPT4ge1xuICAgICAgICAgICAgbGV0IGNscyA9IGFsbDtcbiAgICAgICAgICAgIGZvciAobGV0IHRhZyBvZiB0YWdzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgc3ViIG9mIHRhZy5zZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRhZ0NsYXNzID0gbWFwW3N1Yi5pZF07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWdDbGFzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xzID0gY2xzID8gY2xzICsgXCIgXCIgKyB0YWdDbGFzcyA6IHRhZ0NsYXNzO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2xzO1xuICAgICAgICB9LFxuICAgICAgICBzY29wZVxuICAgIH07XG59XG5mdW5jdGlvbiBoaWdobGlnaHRUYWdzKGhpZ2hsaWdodGVycywgdGFncykge1xuICAgIGxldCByZXN1bHQgPSBudWxsO1xuICAgIGZvciAobGV0IGhpZ2hsaWdodGVyIG9mIGhpZ2hsaWdodGVycykge1xuICAgICAgICBsZXQgdmFsdWUgPSBoaWdobGlnaHRlci5zdHlsZSh0YWdzKTtcbiAgICAgICAgaWYgKHZhbHVlKVxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0ID8gcmVzdWx0ICsgXCIgXCIgKyB2YWx1ZSA6IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG5IaWdobGlnaHQgdGhlIGdpdmVuIFt0cmVlXSgjY29tbW9uLlRyZWUpIHdpdGggdGhlIGdpdmVuXG5baGlnaGxpZ2h0ZXJdKCNoaWdobGlnaHQuSGlnaGxpZ2h0ZXIpLiBPZnRlbiwgdGhlIGhpZ2hlci1sZXZlbFxuW2BoaWdobGlnaHRDb2RlYF0oI2hpZ2hsaWdodC5oaWdobGlnaHRDb2RlKSBmdW5jdGlvbiBpcyBlYXNpZXIgdG9cbnVzZS5cbiovXG5mdW5jdGlvbiBoaWdobGlnaHRUcmVlKHRyZWUsIGhpZ2hsaWdodGVyLCBcbi8qKlxuQXNzaWduIHN0eWxpbmcgdG8gYSByZWdpb24gb2YgdGhlIHRleHQuIFdpbGwgYmUgY2FsbGVkLCBpbiBvcmRlclxub2YgcG9zaXRpb24sIGZvciBhbnkgcmFuZ2VzIHdoZXJlIG1vcmUgdGhhbiB6ZXJvIGNsYXNzZXMgYXBwbHkuXG5gY2xhc3Nlc2AgaXMgYSBzcGFjZSBzZXBhcmF0ZWQgc3RyaW5nIG9mIENTUyBjbGFzc2VzLlxuKi9cbnB1dFN0eWxlLCBcbi8qKlxuVGhlIHN0YXJ0IG9mIHRoZSByYW5nZSB0byBoaWdobGlnaHQuXG4qL1xuZnJvbSA9IDAsIFxuLyoqXG5UaGUgZW5kIG9mIHRoZSByYW5nZS5cbiovXG50byA9IHRyZWUubGVuZ3RoKSB7XG4gICAgbGV0IGJ1aWxkZXIgPSBuZXcgSGlnaGxpZ2h0QnVpbGRlcihmcm9tLCBBcnJheS5pc0FycmF5KGhpZ2hsaWdodGVyKSA/IGhpZ2hsaWdodGVyIDogW2hpZ2hsaWdodGVyXSwgcHV0U3R5bGUpO1xuICAgIGJ1aWxkZXIuaGlnaGxpZ2h0UmFuZ2UodHJlZS5jdXJzb3IoKSwgZnJvbSwgdG8sIFwiXCIsIGJ1aWxkZXIuaGlnaGxpZ2h0ZXJzKTtcbiAgICBidWlsZGVyLmZsdXNoKHRvKTtcbn1cbi8qKlxuSGlnaGxpZ2h0IHRoZSBnaXZlbiB0cmVlIHdpdGggdGhlIGdpdmVuIGhpZ2hsaWdodGVyLCBjYWxsaW5nXG5gcHV0VGV4dGAgZm9yIGV2ZXJ5IHBpZWNlIG9mIHRleHQsIGVpdGhlciB3aXRoIGEgc2V0IG9mIGNsYXNzZXMgb3JcbndpdGggdGhlIGVtcHR5IHN0cmluZyB3aGVuIHVuc3R5bGVkLCBhbmQgYHB1dEJyZWFrYCBmb3IgZXZlcnkgbGluZVxuYnJlYWsuXG4qL1xuZnVuY3Rpb24gaGlnaGxpZ2h0Q29kZShjb2RlLCB0cmVlLCBoaWdobGlnaHRlciwgcHV0VGV4dCwgcHV0QnJlYWssIGZyb20gPSAwLCB0byA9IGNvZGUubGVuZ3RoKSB7XG4gICAgbGV0IHBvcyA9IGZyb207XG4gICAgZnVuY3Rpb24gd3JpdGVUbyhwLCBjbGFzc2VzKSB7XG4gICAgICAgIGlmIChwIDw9IHBvcylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZm9yIChsZXQgdGV4dCA9IGNvZGUuc2xpY2UocG9zLCBwKSwgaSA9IDA7Oykge1xuICAgICAgICAgICAgbGV0IG5leHRCcmVhayA9IHRleHQuaW5kZXhPZihcIlxcblwiLCBpKTtcbiAgICAgICAgICAgIGxldCB1cHRvID0gbmV4dEJyZWFrIDwgMCA/IHRleHQubGVuZ3RoIDogbmV4dEJyZWFrO1xuICAgICAgICAgICAgaWYgKHVwdG8gPiBpKVxuICAgICAgICAgICAgICAgIHB1dFRleHQodGV4dC5zbGljZShpLCB1cHRvKSwgY2xhc3Nlcyk7XG4gICAgICAgICAgICBpZiAobmV4dEJyZWFrIDwgMClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHB1dEJyZWFrKCk7XG4gICAgICAgICAgICBpID0gbmV4dEJyZWFrICsgMTtcbiAgICAgICAgfVxuICAgICAgICBwb3MgPSBwO1xuICAgIH1cbiAgICBoaWdobGlnaHRUcmVlKHRyZWUsIGhpZ2hsaWdodGVyLCAoZnJvbSwgdG8sIGNsYXNzZXMpID0+IHtcbiAgICAgICAgd3JpdGVUbyhmcm9tLCBcIlwiKTtcbiAgICAgICAgd3JpdGVUbyh0bywgY2xhc3Nlcyk7XG4gICAgfSwgZnJvbSwgdG8pO1xuICAgIHdyaXRlVG8odG8sIFwiXCIpO1xufVxuY2xhc3MgSGlnaGxpZ2h0QnVpbGRlciB7XG4gICAgY29uc3RydWN0b3IoYXQsIGhpZ2hsaWdodGVycywgc3Bhbikge1xuICAgICAgICB0aGlzLmF0ID0gYXQ7XG4gICAgICAgIHRoaXMuaGlnaGxpZ2h0ZXJzID0gaGlnaGxpZ2h0ZXJzO1xuICAgICAgICB0aGlzLnNwYW4gPSBzcGFuO1xuICAgICAgICB0aGlzLmNsYXNzID0gXCJcIjtcbiAgICB9XG4gICAgc3RhcnRTcGFuKGF0LCBjbHMpIHtcbiAgICAgICAgaWYgKGNscyAhPSB0aGlzLmNsYXNzKSB7XG4gICAgICAgICAgICB0aGlzLmZsdXNoKGF0KTtcbiAgICAgICAgICAgIGlmIChhdCA+IHRoaXMuYXQpXG4gICAgICAgICAgICAgICAgdGhpcy5hdCA9IGF0O1xuICAgICAgICAgICAgdGhpcy5jbGFzcyA9IGNscztcbiAgICAgICAgfVxuICAgIH1cbiAgICBmbHVzaCh0bykge1xuICAgICAgICBpZiAodG8gPiB0aGlzLmF0ICYmIHRoaXMuY2xhc3MpXG4gICAgICAgICAgICB0aGlzLnNwYW4odGhpcy5hdCwgdG8sIHRoaXMuY2xhc3MpO1xuICAgIH1cbiAgICBoaWdobGlnaHRSYW5nZShjdXJzb3IsIGZyb20sIHRvLCBpbmhlcml0ZWRDbGFzcywgaGlnaGxpZ2h0ZXJzKSB7XG4gICAgICAgIGxldCB7IHR5cGUsIGZyb206IHN0YXJ0LCB0bzogZW5kIH0gPSBjdXJzb3I7XG4gICAgICAgIGlmIChzdGFydCA+PSB0byB8fCBlbmQgPD0gZnJvbSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHR5cGUuaXNUb3ApXG4gICAgICAgICAgICBoaWdobGlnaHRlcnMgPSB0aGlzLmhpZ2hsaWdodGVycy5maWx0ZXIoaCA9PiAhaC5zY29wZSB8fCBoLnNjb3BlKHR5cGUpKTtcbiAgICAgICAgbGV0IGNscyA9IGluaGVyaXRlZENsYXNzO1xuICAgICAgICBsZXQgcnVsZSA9IGdldFN0eWxlVGFncyhjdXJzb3IpIHx8IFJ1bGUuZW1wdHk7XG4gICAgICAgIGxldCB0YWdDbHMgPSBoaWdobGlnaHRUYWdzKGhpZ2hsaWdodGVycywgcnVsZS50YWdzKTtcbiAgICAgICAgaWYgKHRhZ0Nscykge1xuICAgICAgICAgICAgaWYgKGNscylcbiAgICAgICAgICAgICAgICBjbHMgKz0gXCIgXCI7XG4gICAgICAgICAgICBjbHMgKz0gdGFnQ2xzO1xuICAgICAgICAgICAgaWYgKHJ1bGUubW9kZSA9PSAxIC8qIE1vZGUuSW5oZXJpdCAqLylcbiAgICAgICAgICAgICAgICBpbmhlcml0ZWRDbGFzcyArPSAoaW5oZXJpdGVkQ2xhc3MgPyBcIiBcIiA6IFwiXCIpICsgdGFnQ2xzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhcnRTcGFuKE1hdGgubWF4KGZyb20sIHN0YXJ0KSwgY2xzKTtcbiAgICAgICAgaWYgKHJ1bGUub3BhcXVlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgbW91bnRlZCA9IGN1cnNvci50cmVlICYmIGN1cnNvci50cmVlLnByb3AoTm9kZVByb3AubW91bnRlZCk7XG4gICAgICAgIGlmIChtb3VudGVkICYmIG1vdW50ZWQub3ZlcmxheSkge1xuICAgICAgICAgICAgbGV0IGlubmVyID0gY3Vyc29yLm5vZGUuZW50ZXIobW91bnRlZC5vdmVybGF5WzBdLmZyb20gKyBzdGFydCwgMSk7XG4gICAgICAgICAgICBsZXQgaW5uZXJIaWdobGlnaHRlcnMgPSB0aGlzLmhpZ2hsaWdodGVycy5maWx0ZXIoaCA9PiAhaC5zY29wZSB8fCBoLnNjb3BlKG1vdW50ZWQudHJlZS50eXBlKSk7XG4gICAgICAgICAgICBsZXQgaGFzQ2hpbGQgPSBjdXJzb3IuZmlyc3RDaGlsZCgpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBvcyA9IHN0YXJ0OzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSBpIDwgbW91bnRlZC5vdmVybGF5Lmxlbmd0aCA/IG1vdW50ZWQub3ZlcmxheVtpXSA6IG51bGw7XG4gICAgICAgICAgICAgICAgbGV0IG5leHRQb3MgPSBuZXh0ID8gbmV4dC5mcm9tICsgc3RhcnQgOiBlbmQ7XG4gICAgICAgICAgICAgICAgbGV0IHJhbmdlRnJvbSA9IE1hdGgubWF4KGZyb20sIHBvcyksIHJhbmdlVG8gPSBNYXRoLm1pbih0bywgbmV4dFBvcyk7XG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlRnJvbSA8IHJhbmdlVG8gJiYgaGFzQ2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGN1cnNvci5mcm9tIDwgcmFuZ2VUbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRSYW5nZShjdXJzb3IsIHJhbmdlRnJvbSwgcmFuZ2VUbywgaW5oZXJpdGVkQ2xhc3MsIGhpZ2hsaWdodGVycyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0U3BhbihNYXRoLm1pbihyYW5nZVRvLCBjdXJzb3IudG8pLCBjbHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnNvci50byA+PSBuZXh0UG9zIHx8ICFjdXJzb3IubmV4dFNpYmxpbmcoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIW5leHQgfHwgbmV4dFBvcyA+IHRvKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBwb3MgPSBuZXh0LnRvICsgc3RhcnQ7XG4gICAgICAgICAgICAgICAgaWYgKHBvcyA+IGZyb20pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRSYW5nZShpbm5lci5jdXJzb3IoKSwgTWF0aC5tYXgoZnJvbSwgbmV4dC5mcm9tICsgc3RhcnQpLCBNYXRoLm1pbih0bywgcG9zKSwgXCJcIiwgaW5uZXJIaWdobGlnaHRlcnMpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0U3BhbihNYXRoLm1pbih0bywgcG9zKSwgY2xzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGFzQ2hpbGQpXG4gICAgICAgICAgICAgICAgY3Vyc29yLnBhcmVudCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGN1cnNvci5maXJzdENoaWxkKCkpIHtcbiAgICAgICAgICAgIGlmIChtb3VudGVkKVxuICAgICAgICAgICAgICAgIGluaGVyaXRlZENsYXNzID0gXCJcIjtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBpZiAoY3Vyc29yLnRvIDw9IGZyb20pXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGlmIChjdXJzb3IuZnJvbSA+PSB0bylcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRSYW5nZShjdXJzb3IsIGZyb20sIHRvLCBpbmhlcml0ZWRDbGFzcywgaGlnaGxpZ2h0ZXJzKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0U3BhbihNYXRoLm1pbih0bywgY3Vyc29yLnRvKSwgY2xzKTtcbiAgICAgICAgICAgIH0gd2hpbGUgKGN1cnNvci5uZXh0U2libGluZygpKTtcbiAgICAgICAgICAgIGN1cnNvci5wYXJlbnQoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuTWF0Y2ggYSBzeW50YXggbm9kZSdzIFtoaWdobGlnaHQgcnVsZXNdKCNoaWdobGlnaHQuc3R5bGVUYWdzKS4gSWZcbnRoZXJlJ3MgYSBtYXRjaCwgcmV0dXJuIGl0cyBzZXQgb2YgdGFncywgYW5kIHdoZXRoZXIgaXQgaXNcbm9wYXF1ZSAodXNlcyBhIGAhYCkgb3IgYXBwbGllcyB0byBhbGwgY2hpbGQgbm9kZXMgKGAvLi4uYCkuXG4qL1xuZnVuY3Rpb24gZ2V0U3R5bGVUYWdzKG5vZGUpIHtcbiAgICBsZXQgcnVsZSA9IG5vZGUudHlwZS5wcm9wKHJ1bGVOb2RlUHJvcCk7XG4gICAgd2hpbGUgKHJ1bGUgJiYgcnVsZS5jb250ZXh0ICYmICFub2RlLm1hdGNoQ29udGV4dChydWxlLmNvbnRleHQpKVxuICAgICAgICBydWxlID0gcnVsZS5uZXh0O1xuICAgIHJldHVybiBydWxlIHx8IG51bGw7XG59XG5jb25zdCB0ID0gVGFnLmRlZmluZTtcbmNvbnN0IGNvbW1lbnQgPSB0KCksIG5hbWUgPSB0KCksIHR5cGVOYW1lID0gdChuYW1lKSwgcHJvcGVydHlOYW1lID0gdChuYW1lKSwgbGl0ZXJhbCA9IHQoKSwgc3RyaW5nID0gdChsaXRlcmFsKSwgbnVtYmVyID0gdChsaXRlcmFsKSwgY29udGVudCA9IHQoKSwgaGVhZGluZyA9IHQoY29udGVudCksIGtleXdvcmQgPSB0KCksIG9wZXJhdG9yID0gdCgpLCBwdW5jdHVhdGlvbiA9IHQoKSwgYnJhY2tldCA9IHQocHVuY3R1YXRpb24pLCBtZXRhID0gdCgpO1xuLyoqXG5UaGUgZGVmYXVsdCBzZXQgb2YgaGlnaGxpZ2h0aW5nIFt0YWdzXSgjaGlnaGxpZ2h0LlRhZykuXG5cblRoaXMgY29sbGVjdGlvbiBpcyBoZWF2aWx5IGJpYXNlZCB0b3dhcmRzIHByb2dyYW1taW5nIGxhbmd1YWdlcyxcbmFuZCBuZWNlc3NhcmlseSBpbmNvbXBsZXRlLiBBIGZ1bGwgb250b2xvZ3kgb2Ygc3ludGFjdGljXG5jb25zdHJ1Y3RzIHdvdWxkIGZpbGwgYSBzdGFjayBvZiBib29rcywgYW5kIGJlIGltcHJhY3RpY2FsIHRvXG53cml0ZSB0aGVtZXMgZm9yLiBTbyB0cnkgdG8gbWFrZSBkbyB3aXRoIHRoaXMgc2V0LiBJZiBhbGwgZWxzZVxuZmFpbHMsIFtvcGVuIGFuXG5pc3N1ZV0oaHR0cHM6Ly9naXRodWIuY29tL2NvZGVtaXJyb3IvY29kZW1pcnJvci5uZXh0KSB0byBwcm9wb3NlIGFcbm5ldyB0YWcsIG9yIFtkZWZpbmVdKCNoaWdobGlnaHQuVGFnXmRlZmluZSkgYSBsb2NhbCBjdXN0b20gdGFnIGZvclxueW91ciB1c2UgY2FzZS5cblxuTm90ZSB0aGF0IGl0IGlzIG5vdCBvYmxpZ2F0b3J5IHRvIGFsd2F5cyBhdHRhY2ggdGhlIG1vc3Qgc3BlY2lmaWNcbnRhZyBwb3NzaWJsZSB0byBhbiBlbGVtZW504oCUaWYgeW91ciBncmFtbWFyIGNhbid0IGVhc2lseVxuZGlzdGluZ3Vpc2ggYSBjZXJ0YWluIHR5cGUgb2YgZWxlbWVudCAoc3VjaCBhcyBhIGxvY2FsIHZhcmlhYmxlKSxcbml0IGlzIG9rYXkgdG8gc3R5bGUgaXQgYXMgaXRzIG1vcmUgZ2VuZXJhbCB2YXJpYW50IChhIHZhcmlhYmxlKS5cblxuRm9yIHRhZ3MgdGhhdCBleHRlbmQgc29tZSBwYXJlbnQgdGFnLCB0aGUgZG9jdW1lbnRhdGlvbiBsaW5rcyB0b1xudGhlIHBhcmVudC5cbiovXG5jb25zdCB0YWdzID0ge1xuICAgIC8qKlxuICAgIEEgY29tbWVudC5cbiAgICAqL1xuICAgIGNvbW1lbnQsXG4gICAgLyoqXG4gICAgQSBsaW5lIFtjb21tZW50XSgjaGlnaGxpZ2h0LnRhZ3MuY29tbWVudCkuXG4gICAgKi9cbiAgICBsaW5lQ29tbWVudDogdChjb21tZW50KSxcbiAgICAvKipcbiAgICBBIGJsb2NrIFtjb21tZW50XSgjaGlnaGxpZ2h0LnRhZ3MuY29tbWVudCkuXG4gICAgKi9cbiAgICBibG9ja0NvbW1lbnQ6IHQoY29tbWVudCksXG4gICAgLyoqXG4gICAgQSBkb2N1bWVudGF0aW9uIFtjb21tZW50XSgjaGlnaGxpZ2h0LnRhZ3MuY29tbWVudCkuXG4gICAgKi9cbiAgICBkb2NDb21tZW50OiB0KGNvbW1lbnQpLFxuICAgIC8qKlxuICAgIEFueSBraW5kIG9mIGlkZW50aWZpZXIuXG4gICAgKi9cbiAgICBuYW1lLFxuICAgIC8qKlxuICAgIFRoZSBbbmFtZV0oI2hpZ2hsaWdodC50YWdzLm5hbWUpIG9mIGEgdmFyaWFibGUuXG4gICAgKi9cbiAgICB2YXJpYWJsZU5hbWU6IHQobmFtZSksXG4gICAgLyoqXG4gICAgQSB0eXBlIFtuYW1lXSgjaGlnaGxpZ2h0LnRhZ3MubmFtZSkuXG4gICAgKi9cbiAgICB0eXBlTmFtZTogdHlwZU5hbWUsXG4gICAgLyoqXG4gICAgQSB0YWcgbmFtZSAoc3VidGFnIG9mIFtgdHlwZU5hbWVgXSgjaGlnaGxpZ2h0LnRhZ3MudHlwZU5hbWUpKS5cbiAgICAqL1xuICAgIHRhZ05hbWU6IHQodHlwZU5hbWUpLFxuICAgIC8qKlxuICAgIEEgcHJvcGVydHkgb3IgZmllbGQgW25hbWVdKCNoaWdobGlnaHQudGFncy5uYW1lKS5cbiAgICAqL1xuICAgIHByb3BlcnR5TmFtZTogcHJvcGVydHlOYW1lLFxuICAgIC8qKlxuICAgIEFuIGF0dHJpYnV0ZSBuYW1lIChzdWJ0YWcgb2YgW2Bwcm9wZXJ0eU5hbWVgXSgjaGlnaGxpZ2h0LnRhZ3MucHJvcGVydHlOYW1lKSkuXG4gICAgKi9cbiAgICBhdHRyaWJ1dGVOYW1lOiB0KHByb3BlcnR5TmFtZSksXG4gICAgLyoqXG4gICAgVGhlIFtuYW1lXSgjaGlnaGxpZ2h0LnRhZ3MubmFtZSkgb2YgYSBjbGFzcy5cbiAgICAqL1xuICAgIGNsYXNzTmFtZTogdChuYW1lKSxcbiAgICAvKipcbiAgICBBIGxhYmVsIFtuYW1lXSgjaGlnaGxpZ2h0LnRhZ3MubmFtZSkuXG4gICAgKi9cbiAgICBsYWJlbE5hbWU6IHQobmFtZSksXG4gICAgLyoqXG4gICAgQSBuYW1lc3BhY2UgW25hbWVdKCNoaWdobGlnaHQudGFncy5uYW1lKS5cbiAgICAqL1xuICAgIG5hbWVzcGFjZTogdChuYW1lKSxcbiAgICAvKipcbiAgICBUaGUgW25hbWVdKCNoaWdobGlnaHQudGFncy5uYW1lKSBvZiBhIG1hY3JvLlxuICAgICovXG4gICAgbWFjcm9OYW1lOiB0KG5hbWUpLFxuICAgIC8qKlxuICAgIEEgbGl0ZXJhbCB2YWx1ZS5cbiAgICAqL1xuICAgIGxpdGVyYWwsXG4gICAgLyoqXG4gICAgQSBzdHJpbmcgW2xpdGVyYWxdKCNoaWdobGlnaHQudGFncy5saXRlcmFsKS5cbiAgICAqL1xuICAgIHN0cmluZyxcbiAgICAvKipcbiAgICBBIGRvY3VtZW50YXRpb24gW3N0cmluZ10oI2hpZ2hsaWdodC50YWdzLnN0cmluZykuXG4gICAgKi9cbiAgICBkb2NTdHJpbmc6IHQoc3RyaW5nKSxcbiAgICAvKipcbiAgICBBIGNoYXJhY3RlciBsaXRlcmFsIChzdWJ0YWcgb2YgW3N0cmluZ10oI2hpZ2hsaWdodC50YWdzLnN0cmluZykpLlxuICAgICovXG4gICAgY2hhcmFjdGVyOiB0KHN0cmluZyksXG4gICAgLyoqXG4gICAgQW4gYXR0cmlidXRlIHZhbHVlIChzdWJ0YWcgb2YgW3N0cmluZ10oI2hpZ2hsaWdodC50YWdzLnN0cmluZykpLlxuICAgICovXG4gICAgYXR0cmlidXRlVmFsdWU6IHQoc3RyaW5nKSxcbiAgICAvKipcbiAgICBBIG51bWJlciBbbGl0ZXJhbF0oI2hpZ2hsaWdodC50YWdzLmxpdGVyYWwpLlxuICAgICovXG4gICAgbnVtYmVyLFxuICAgIC8qKlxuICAgIEFuIGludGVnZXIgW251bWJlcl0oI2hpZ2hsaWdodC50YWdzLm51bWJlcikgbGl0ZXJhbC5cbiAgICAqL1xuICAgIGludGVnZXI6IHQobnVtYmVyKSxcbiAgICAvKipcbiAgICBBIGZsb2F0aW5nLXBvaW50IFtudW1iZXJdKCNoaWdobGlnaHQudGFncy5udW1iZXIpIGxpdGVyYWwuXG4gICAgKi9cbiAgICBmbG9hdDogdChudW1iZXIpLFxuICAgIC8qKlxuICAgIEEgYm9vbGVhbiBbbGl0ZXJhbF0oI2hpZ2hsaWdodC50YWdzLmxpdGVyYWwpLlxuICAgICovXG4gICAgYm9vbDogdChsaXRlcmFsKSxcbiAgICAvKipcbiAgICBSZWd1bGFyIGV4cHJlc3Npb24gW2xpdGVyYWxdKCNoaWdobGlnaHQudGFncy5saXRlcmFsKS5cbiAgICAqL1xuICAgIHJlZ2V4cDogdChsaXRlcmFsKSxcbiAgICAvKipcbiAgICBBbiBlc2NhcGUgW2xpdGVyYWxdKCNoaWdobGlnaHQudGFncy5saXRlcmFsKSwgZm9yIGV4YW1wbGUgYVxuICAgIGJhY2tzbGFzaCBlc2NhcGUgaW4gYSBzdHJpbmcuXG4gICAgKi9cbiAgICBlc2NhcGU6IHQobGl0ZXJhbCksXG4gICAgLyoqXG4gICAgQSBjb2xvciBbbGl0ZXJhbF0oI2hpZ2hsaWdodC50YWdzLmxpdGVyYWwpLlxuICAgICovXG4gICAgY29sb3I6IHQobGl0ZXJhbCksXG4gICAgLyoqXG4gICAgQSBVUkwgW2xpdGVyYWxdKCNoaWdobGlnaHQudGFncy5saXRlcmFsKS5cbiAgICAqL1xuICAgIHVybDogdChsaXRlcmFsKSxcbiAgICAvKipcbiAgICBBIGxhbmd1YWdlIGtleXdvcmQuXG4gICAgKi9cbiAgICBrZXl3b3JkLFxuICAgIC8qKlxuICAgIFRoZSBba2V5d29yZF0oI2hpZ2hsaWdodC50YWdzLmtleXdvcmQpIGZvciB0aGUgc2VsZiBvciB0aGlzXG4gICAgb2JqZWN0LlxuICAgICovXG4gICAgc2VsZjogdChrZXl3b3JkKSxcbiAgICAvKipcbiAgICBUaGUgW2tleXdvcmRdKCNoaWdobGlnaHQudGFncy5rZXl3b3JkKSBmb3IgbnVsbC5cbiAgICAqL1xuICAgIG51bGw6IHQoa2V5d29yZCksXG4gICAgLyoqXG4gICAgQSBba2V5d29yZF0oI2hpZ2hsaWdodC50YWdzLmtleXdvcmQpIGRlbm90aW5nIHNvbWUgYXRvbWljIHZhbHVlLlxuICAgICovXG4gICAgYXRvbTogdChrZXl3b3JkKSxcbiAgICAvKipcbiAgICBBIFtrZXl3b3JkXSgjaGlnaGxpZ2h0LnRhZ3Mua2V5d29yZCkgdGhhdCByZXByZXNlbnRzIGEgdW5pdC5cbiAgICAqL1xuICAgIHVuaXQ6IHQoa2V5d29yZCksXG4gICAgLyoqXG4gICAgQSBtb2RpZmllciBba2V5d29yZF0oI2hpZ2hsaWdodC50YWdzLmtleXdvcmQpLlxuICAgICovXG4gICAgbW9kaWZpZXI6IHQoa2V5d29yZCksXG4gICAgLyoqXG4gICAgQSBba2V5d29yZF0oI2hpZ2hsaWdodC50YWdzLmtleXdvcmQpIHRoYXQgYWN0cyBhcyBhbiBvcGVyYXRvci5cbiAgICAqL1xuICAgIG9wZXJhdG9yS2V5d29yZDogdChrZXl3b3JkKSxcbiAgICAvKipcbiAgICBBIGNvbnRyb2wtZmxvdyByZWxhdGVkIFtrZXl3b3JkXSgjaGlnaGxpZ2h0LnRhZ3Mua2V5d29yZCkuXG4gICAgKi9cbiAgICBjb250cm9sS2V5d29yZDogdChrZXl3b3JkKSxcbiAgICAvKipcbiAgICBBIFtrZXl3b3JkXSgjaGlnaGxpZ2h0LnRhZ3Mua2V5d29yZCkgdGhhdCBkZWZpbmVzIHNvbWV0aGluZy5cbiAgICAqL1xuICAgIGRlZmluaXRpb25LZXl3b3JkOiB0KGtleXdvcmQpLFxuICAgIC8qKlxuICAgIEEgW2tleXdvcmRdKCNoaWdobGlnaHQudGFncy5rZXl3b3JkKSByZWxhdGVkIHRvIGRlZmluaW5nIG9yXG4gICAgaW50ZXJmYWNpbmcgd2l0aCBtb2R1bGVzLlxuICAgICovXG4gICAgbW9kdWxlS2V5d29yZDogdChrZXl3b3JkKSxcbiAgICAvKipcbiAgICBBbiBvcGVyYXRvci5cbiAgICAqL1xuICAgIG9wZXJhdG9yLFxuICAgIC8qKlxuICAgIEFuIFtvcGVyYXRvcl0oI2hpZ2hsaWdodC50YWdzLm9wZXJhdG9yKSB0aGF0IGRlcmVmZXJlbmNlcyBzb21ldGhpbmcuXG4gICAgKi9cbiAgICBkZXJlZk9wZXJhdG9yOiB0KG9wZXJhdG9yKSxcbiAgICAvKipcbiAgICBBcml0aG1ldGljLXJlbGF0ZWQgW29wZXJhdG9yXSgjaGlnaGxpZ2h0LnRhZ3Mub3BlcmF0b3IpLlxuICAgICovXG4gICAgYXJpdGhtZXRpY09wZXJhdG9yOiB0KG9wZXJhdG9yKSxcbiAgICAvKipcbiAgICBMb2dpY2FsIFtvcGVyYXRvcl0oI2hpZ2hsaWdodC50YWdzLm9wZXJhdG9yKS5cbiAgICAqL1xuICAgIGxvZ2ljT3BlcmF0b3I6IHQob3BlcmF0b3IpLFxuICAgIC8qKlxuICAgIEJpdCBbb3BlcmF0b3JdKCNoaWdobGlnaHQudGFncy5vcGVyYXRvcikuXG4gICAgKi9cbiAgICBiaXR3aXNlT3BlcmF0b3I6IHQob3BlcmF0b3IpLFxuICAgIC8qKlxuICAgIENvbXBhcmlzb24gW29wZXJhdG9yXSgjaGlnaGxpZ2h0LnRhZ3Mub3BlcmF0b3IpLlxuICAgICovXG4gICAgY29tcGFyZU9wZXJhdG9yOiB0KG9wZXJhdG9yKSxcbiAgICAvKipcbiAgICBbT3BlcmF0b3JdKCNoaWdobGlnaHQudGFncy5vcGVyYXRvcikgdGhhdCB1cGRhdGVzIGl0cyBvcGVyYW5kLlxuICAgICovXG4gICAgdXBkYXRlT3BlcmF0b3I6IHQob3BlcmF0b3IpLFxuICAgIC8qKlxuICAgIFtPcGVyYXRvcl0oI2hpZ2hsaWdodC50YWdzLm9wZXJhdG9yKSB0aGF0IGRlZmluZXMgc29tZXRoaW5nLlxuICAgICovXG4gICAgZGVmaW5pdGlvbk9wZXJhdG9yOiB0KG9wZXJhdG9yKSxcbiAgICAvKipcbiAgICBUeXBlLXJlbGF0ZWQgW29wZXJhdG9yXSgjaGlnaGxpZ2h0LnRhZ3Mub3BlcmF0b3IpLlxuICAgICovXG4gICAgdHlwZU9wZXJhdG9yOiB0KG9wZXJhdG9yKSxcbiAgICAvKipcbiAgICBDb250cm9sLWZsb3cgW29wZXJhdG9yXSgjaGlnaGxpZ2h0LnRhZ3Mub3BlcmF0b3IpLlxuICAgICovXG4gICAgY29udHJvbE9wZXJhdG9yOiB0KG9wZXJhdG9yKSxcbiAgICAvKipcbiAgICBQcm9ncmFtIG9yIG1hcmt1cCBwdW5jdHVhdGlvbi5cbiAgICAqL1xuICAgIHB1bmN0dWF0aW9uLFxuICAgIC8qKlxuICAgIFtQdW5jdHVhdGlvbl0oI2hpZ2hsaWdodC50YWdzLnB1bmN0dWF0aW9uKSB0aGF0IHNlcGFyYXRlc1xuICAgIHRoaW5ncy5cbiAgICAqL1xuICAgIHNlcGFyYXRvcjogdChwdW5jdHVhdGlvbiksXG4gICAgLyoqXG4gICAgQnJhY2tldC1zdHlsZSBbcHVuY3R1YXRpb25dKCNoaWdobGlnaHQudGFncy5wdW5jdHVhdGlvbikuXG4gICAgKi9cbiAgICBicmFja2V0LFxuICAgIC8qKlxuICAgIEFuZ2xlIFticmFja2V0c10oI2hpZ2hsaWdodC50YWdzLmJyYWNrZXQpICh1c3VhbGx5IGA8YCBhbmQgYD5gXG4gICAgdG9rZW5zKS5cbiAgICAqL1xuICAgIGFuZ2xlQnJhY2tldDogdChicmFja2V0KSxcbiAgICAvKipcbiAgICBTcXVhcmUgW2JyYWNrZXRzXSgjaGlnaGxpZ2h0LnRhZ3MuYnJhY2tldCkgKHVzdWFsbHkgYFtgIGFuZCBgXWBcbiAgICB0b2tlbnMpLlxuICAgICovXG4gICAgc3F1YXJlQnJhY2tldDogdChicmFja2V0KSxcbiAgICAvKipcbiAgICBQYXJlbnRoZXNlcyAodXN1YWxseSBgKGAgYW5kIGApYCB0b2tlbnMpLiBTdWJ0YWcgb2ZcbiAgICBbYnJhY2tldF0oI2hpZ2hsaWdodC50YWdzLmJyYWNrZXQpLlxuICAgICovXG4gICAgcGFyZW46IHQoYnJhY2tldCksXG4gICAgLyoqXG4gICAgQnJhY2VzICh1c3VhbGx5IGB7YCBhbmQgYH1gIHRva2VucykuIFN1YnRhZyBvZlxuICAgIFticmFja2V0XSgjaGlnaGxpZ2h0LnRhZ3MuYnJhY2tldCkuXG4gICAgKi9cbiAgICBicmFjZTogdChicmFja2V0KSxcbiAgICAvKipcbiAgICBDb250ZW50LCBmb3IgZXhhbXBsZSBwbGFpbiB0ZXh0IGluIFhNTCBvciBtYXJrdXAgZG9jdW1lbnRzLlxuICAgICovXG4gICAgY29udGVudCxcbiAgICAvKipcbiAgICBbQ29udGVudF0oI2hpZ2hsaWdodC50YWdzLmNvbnRlbnQpIHRoYXQgcmVwcmVzZW50cyBhIGhlYWRpbmcuXG4gICAgKi9cbiAgICBoZWFkaW5nLFxuICAgIC8qKlxuICAgIEEgbGV2ZWwgMSBbaGVhZGluZ10oI2hpZ2hsaWdodC50YWdzLmhlYWRpbmcpLlxuICAgICovXG4gICAgaGVhZGluZzE6IHQoaGVhZGluZyksXG4gICAgLyoqXG4gICAgQSBsZXZlbCAyIFtoZWFkaW5nXSgjaGlnaGxpZ2h0LnRhZ3MuaGVhZGluZykuXG4gICAgKi9cbiAgICBoZWFkaW5nMjogdChoZWFkaW5nKSxcbiAgICAvKipcbiAgICBBIGxldmVsIDMgW2hlYWRpbmddKCNoaWdobGlnaHQudGFncy5oZWFkaW5nKS5cbiAgICAqL1xuICAgIGhlYWRpbmczOiB0KGhlYWRpbmcpLFxuICAgIC8qKlxuICAgIEEgbGV2ZWwgNCBbaGVhZGluZ10oI2hpZ2hsaWdodC50YWdzLmhlYWRpbmcpLlxuICAgICovXG4gICAgaGVhZGluZzQ6IHQoaGVhZGluZyksXG4gICAgLyoqXG4gICAgQSBsZXZlbCA1IFtoZWFkaW5nXSgjaGlnaGxpZ2h0LnRhZ3MuaGVhZGluZykuXG4gICAgKi9cbiAgICBoZWFkaW5nNTogdChoZWFkaW5nKSxcbiAgICAvKipcbiAgICBBIGxldmVsIDYgW2hlYWRpbmddKCNoaWdobGlnaHQudGFncy5oZWFkaW5nKS5cbiAgICAqL1xuICAgIGhlYWRpbmc2OiB0KGhlYWRpbmcpLFxuICAgIC8qKlxuICAgIEEgcHJvc2Ugc2VwYXJhdG9yIChzdWNoIGFzIGEgaG9yaXpvbnRhbCBydWxlKS5cbiAgICAqL1xuICAgIGNvbnRlbnRTZXBhcmF0b3I6IHQoY29udGVudCksXG4gICAgLyoqXG4gICAgW0NvbnRlbnRdKCNoaWdobGlnaHQudGFncy5jb250ZW50KSB0aGF0IHJlcHJlc2VudHMgYSBsaXN0LlxuICAgICovXG4gICAgbGlzdDogdChjb250ZW50KSxcbiAgICAvKipcbiAgICBbQ29udGVudF0oI2hpZ2hsaWdodC50YWdzLmNvbnRlbnQpIHRoYXQgcmVwcmVzZW50cyBhIHF1b3RlLlxuICAgICovXG4gICAgcXVvdGU6IHQoY29udGVudCksXG4gICAgLyoqXG4gICAgW0NvbnRlbnRdKCNoaWdobGlnaHQudGFncy5jb250ZW50KSB0aGF0IGlzIGVtcGhhc2l6ZWQuXG4gICAgKi9cbiAgICBlbXBoYXNpczogdChjb250ZW50KSxcbiAgICAvKipcbiAgICBbQ29udGVudF0oI2hpZ2hsaWdodC50YWdzLmNvbnRlbnQpIHRoYXQgaXMgc3R5bGVkIHN0cm9uZy5cbiAgICAqL1xuICAgIHN0cm9uZzogdChjb250ZW50KSxcbiAgICAvKipcbiAgICBbQ29udGVudF0oI2hpZ2hsaWdodC50YWdzLmNvbnRlbnQpIHRoYXQgaXMgcGFydCBvZiBhIGxpbmsuXG4gICAgKi9cbiAgICBsaW5rOiB0KGNvbnRlbnQpLFxuICAgIC8qKlxuICAgIFtDb250ZW50XSgjaGlnaGxpZ2h0LnRhZ3MuY29udGVudCkgdGhhdCBpcyBzdHlsZWQgYXMgY29kZSBvclxuICAgIG1vbm9zcGFjZS5cbiAgICAqL1xuICAgIG1vbm9zcGFjZTogdChjb250ZW50KSxcbiAgICAvKipcbiAgICBbQ29udGVudF0oI2hpZ2hsaWdodC50YWdzLmNvbnRlbnQpIHRoYXQgaGFzIGEgc3RyaWtlLXRocm91Z2hcbiAgICBzdHlsZS5cbiAgICAqL1xuICAgIHN0cmlrZXRocm91Z2g6IHQoY29udGVudCksXG4gICAgLyoqXG4gICAgSW5zZXJ0ZWQgdGV4dCBpbiBhIGNoYW5nZS10cmFja2luZyBmb3JtYXQuXG4gICAgKi9cbiAgICBpbnNlcnRlZDogdCgpLFxuICAgIC8qKlxuICAgIERlbGV0ZWQgdGV4dC5cbiAgICAqL1xuICAgIGRlbGV0ZWQ6IHQoKSxcbiAgICAvKipcbiAgICBDaGFuZ2VkIHRleHQuXG4gICAgKi9cbiAgICBjaGFuZ2VkOiB0KCksXG4gICAgLyoqXG4gICAgQW4gaW52YWxpZCBvciB1bnN5bnRhY3RpYyBlbGVtZW50LlxuICAgICovXG4gICAgaW52YWxpZDogdCgpLFxuICAgIC8qKlxuICAgIE1ldGFkYXRhIG9yIG1ldGEtaW5zdHJ1Y3Rpb24uXG4gICAgKi9cbiAgICBtZXRhLFxuICAgIC8qKlxuICAgIFtNZXRhZGF0YV0oI2hpZ2hsaWdodC50YWdzLm1ldGEpIHRoYXQgYXBwbGllcyB0byB0aGUgZW50aXJlXG4gICAgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBkb2N1bWVudE1ldGE6IHQobWV0YSksXG4gICAgLyoqXG4gICAgW01ldGFkYXRhXSgjaGlnaGxpZ2h0LnRhZ3MubWV0YSkgdGhhdCBhbm5vdGF0ZXMgb3IgYWRkc1xuICAgIGF0dHJpYnV0ZXMgdG8gYSBnaXZlbiBzeW50YWN0aWMgZWxlbWVudC5cbiAgICAqL1xuICAgIGFubm90YXRpb246IHQobWV0YSksXG4gICAgLyoqXG4gICAgUHJvY2Vzc2luZyBpbnN0cnVjdGlvbiBvciBwcmVwcm9jZXNzb3IgZGlyZWN0aXZlLiBTdWJ0YWcgb2ZcbiAgICBbbWV0YV0oI2hpZ2hsaWdodC50YWdzLm1ldGEpLlxuICAgICovXG4gICAgcHJvY2Vzc2luZ0luc3RydWN0aW9uOiB0KG1ldGEpLFxuICAgIC8qKlxuICAgIFtNb2RpZmllcl0oI2hpZ2hsaWdodC5UYWdeZGVmaW5lTW9kaWZpZXIpIHRoYXQgaW5kaWNhdGVzIHRoYXQgYVxuICAgIGdpdmVuIGVsZW1lbnQgaXMgYmVpbmcgZGVmaW5lZC4gRXhwZWN0ZWQgdG8gYmUgdXNlZCB3aXRoIHRoZVxuICAgIHZhcmlvdXMgW25hbWVdKCNoaWdobGlnaHQudGFncy5uYW1lKSB0YWdzLlxuICAgICovXG4gICAgZGVmaW5pdGlvbjogVGFnLmRlZmluZU1vZGlmaWVyKCksXG4gICAgLyoqXG4gICAgW01vZGlmaWVyXSgjaGlnaGxpZ2h0LlRhZ15kZWZpbmVNb2RpZmllcikgdGhhdCBpbmRpY2F0ZXMgdGhhdFxuICAgIHNvbWV0aGluZyBpcyBjb25zdGFudC4gTW9zdGx5IGV4cGVjdGVkIHRvIGJlIHVzZWQgd2l0aFxuICAgIFt2YXJpYWJsZSBuYW1lc10oI2hpZ2hsaWdodC50YWdzLnZhcmlhYmxlTmFtZSkuXG4gICAgKi9cbiAgICBjb25zdGFudDogVGFnLmRlZmluZU1vZGlmaWVyKCksXG4gICAgLyoqXG4gICAgW01vZGlmaWVyXSgjaGlnaGxpZ2h0LlRhZ15kZWZpbmVNb2RpZmllcikgdXNlZCB0byBpbmRpY2F0ZSB0aGF0XG4gICAgYSBbdmFyaWFibGVdKCNoaWdobGlnaHQudGFncy52YXJpYWJsZU5hbWUpIG9yIFtwcm9wZXJ0eVxuICAgIG5hbWVdKCNoaWdobGlnaHQudGFncy5wcm9wZXJ0eU5hbWUpIGlzIGJlaW5nIGNhbGxlZCBvciBkZWZpbmVkXG4gICAgYXMgYSBmdW5jdGlvbi5cbiAgICAqL1xuICAgIGZ1bmN0aW9uOiBUYWcuZGVmaW5lTW9kaWZpZXIoKSxcbiAgICAvKipcbiAgICBbTW9kaWZpZXJdKCNoaWdobGlnaHQuVGFnXmRlZmluZU1vZGlmaWVyKSB0aGF0IGNhbiBiZSBhcHBsaWVkIHRvXG4gICAgW25hbWVzXSgjaGlnaGxpZ2h0LnRhZ3MubmFtZSkgdG8gaW5kaWNhdGUgdGhhdCB0aGV5IGJlbG9uZyB0b1xuICAgIHRoZSBsYW5ndWFnZSdzIHN0YW5kYXJkIGVudmlyb25tZW50LlxuICAgICovXG4gICAgc3RhbmRhcmQ6IFRhZy5kZWZpbmVNb2RpZmllcigpLFxuICAgIC8qKlxuICAgIFtNb2RpZmllcl0oI2hpZ2hsaWdodC5UYWdeZGVmaW5lTW9kaWZpZXIpIHRoYXQgaW5kaWNhdGVzIGEgZ2l2ZW5cbiAgICBbbmFtZXNdKCNoaWdobGlnaHQudGFncy5uYW1lKSBpcyBsb2NhbCB0byBzb21lIHNjb3BlLlxuICAgICovXG4gICAgbG9jYWw6IFRhZy5kZWZpbmVNb2RpZmllcigpLFxuICAgIC8qKlxuICAgIEEgZ2VuZXJpYyB2YXJpYW50IFttb2RpZmllcl0oI2hpZ2hsaWdodC5UYWdeZGVmaW5lTW9kaWZpZXIpIHRoYXRcbiAgICBjYW4gYmUgdXNlZCB0byB0YWcgbGFuZ3VhZ2Utc3BlY2lmaWMgYWx0ZXJuYXRpdmUgdmFyaWFudHMgb2ZcbiAgICBzb21lIGNvbW1vbiB0YWcuIEl0IGlzIHJlY29tbWVuZGVkIGZvciB0aGVtZXMgdG8gZGVmaW5lIHNwZWNpYWxcbiAgICBmb3JtcyBvZiBhdCBsZWFzdCB0aGUgW3N0cmluZ10oI2hpZ2hsaWdodC50YWdzLnN0cmluZykgYW5kXG4gICAgW3ZhcmlhYmxlIG5hbWVdKCNoaWdobGlnaHQudGFncy52YXJpYWJsZU5hbWUpIHRhZ3MsIHNpbmNlIHRob3NlXG4gICAgY29tZSB1cCBhIGxvdC5cbiAgICAqL1xuICAgIHNwZWNpYWw6IFRhZy5kZWZpbmVNb2RpZmllcigpXG59O1xuLyoqXG5UaGlzIGlzIGEgaGlnaGxpZ2h0ZXIgdGhhdCBhZGRzIHN0YWJsZSwgcHJlZGljdGFibGUgY2xhc3NlcyB0b1xudG9rZW5zLCBmb3Igc3R5bGluZyB3aXRoIGV4dGVybmFsIENTUy5cblxuVGhlIGZvbGxvd2luZyB0YWdzIGFyZSBtYXBwZWQgdG8gdGhlaXIgbmFtZSBwcmVmaXhlZCB3aXRoIGBcInRvay1cImBcbihmb3IgZXhhbXBsZSBgXCJ0b2stY29tbWVudFwiYCk6XG5cbiogW2BsaW5rYF0oI2hpZ2hsaWdodC50YWdzLmxpbmspXG4qIFtgaGVhZGluZ2BdKCNoaWdobGlnaHQudGFncy5oZWFkaW5nKVxuKiBbYGVtcGhhc2lzYF0oI2hpZ2hsaWdodC50YWdzLmVtcGhhc2lzKVxuKiBbYHN0cm9uZ2BdKCNoaWdobGlnaHQudGFncy5zdHJvbmcpXG4qIFtga2V5d29yZGBdKCNoaWdobGlnaHQudGFncy5rZXl3b3JkKVxuKiBbYGF0b21gXSgjaGlnaGxpZ2h0LnRhZ3MuYXRvbSlcbiogW2Bib29sYF0oI2hpZ2hsaWdodC50YWdzLmJvb2wpXG4qIFtgdXJsYF0oI2hpZ2hsaWdodC50YWdzLnVybClcbiogW2BsYWJlbE5hbWVgXSgjaGlnaGxpZ2h0LnRhZ3MubGFiZWxOYW1lKVxuKiBbYGluc2VydGVkYF0oI2hpZ2hsaWdodC50YWdzLmluc2VydGVkKVxuKiBbYGRlbGV0ZWRgXSgjaGlnaGxpZ2h0LnRhZ3MuZGVsZXRlZClcbiogW2BsaXRlcmFsYF0oI2hpZ2hsaWdodC50YWdzLmxpdGVyYWwpXG4qIFtgc3RyaW5nYF0oI2hpZ2hsaWdodC50YWdzLnN0cmluZylcbiogW2BudW1iZXJgXSgjaGlnaGxpZ2h0LnRhZ3MubnVtYmVyKVxuKiBbYHZhcmlhYmxlTmFtZWBdKCNoaWdobGlnaHQudGFncy52YXJpYWJsZU5hbWUpXG4qIFtgdHlwZU5hbWVgXSgjaGlnaGxpZ2h0LnRhZ3MudHlwZU5hbWUpXG4qIFtgbmFtZXNwYWNlYF0oI2hpZ2hsaWdodC50YWdzLm5hbWVzcGFjZSlcbiogW2BjbGFzc05hbWVgXSgjaGlnaGxpZ2h0LnRhZ3MuY2xhc3NOYW1lKVxuKiBbYG1hY3JvTmFtZWBdKCNoaWdobGlnaHQudGFncy5tYWNyb05hbWUpXG4qIFtgcHJvcGVydHlOYW1lYF0oI2hpZ2hsaWdodC50YWdzLnByb3BlcnR5TmFtZSlcbiogW2BvcGVyYXRvcmBdKCNoaWdobGlnaHQudGFncy5vcGVyYXRvcilcbiogW2Bjb21tZW50YF0oI2hpZ2hsaWdodC50YWdzLmNvbW1lbnQpXG4qIFtgbWV0YWBdKCNoaWdobGlnaHQudGFncy5tZXRhKVxuKiBbYHB1bmN0dWF0aW9uYF0oI2hpZ2hsaWdodC50YWdzLnB1bmN0dWF0aW9uKVxuKiBbYGludmFsaWRgXSgjaGlnaGxpZ2h0LnRhZ3MuaW52YWxpZClcblxuSW4gYWRkaXRpb24sIHRoZXNlIG1hcHBpbmdzIGFyZSBwcm92aWRlZDpcblxuKiBbYHJlZ2V4cGBdKCNoaWdobGlnaHQudGFncy5yZWdleHApLFxuICBbYGVzY2FwZWBdKCNoaWdobGlnaHQudGFncy5lc2NhcGUpLCBhbmRcbiAgW2BzcGVjaWFsYF0oI2hpZ2hsaWdodC50YWdzLnNwZWNpYWwpW2Aoc3RyaW5nKWBdKCNoaWdobGlnaHQudGFncy5zdHJpbmcpXG4gIGFyZSBtYXBwZWQgdG8gYFwidG9rLXN0cmluZzJcImBcbiogW2BzcGVjaWFsYF0oI2hpZ2hsaWdodC50YWdzLnNwZWNpYWwpW2AodmFyaWFibGVOYW1lKWBdKCNoaWdobGlnaHQudGFncy52YXJpYWJsZU5hbWUpXG4gIHRvIGBcInRvay12YXJpYWJsZU5hbWUyXCJgXG4qIFtgbG9jYWxgXSgjaGlnaGxpZ2h0LnRhZ3MubG9jYWwpW2AodmFyaWFibGVOYW1lKWBdKCNoaWdobGlnaHQudGFncy52YXJpYWJsZU5hbWUpXG4gIHRvIGBcInRvay12YXJpYWJsZU5hbWUgdG9rLWxvY2FsXCJgXG4qIFtgZGVmaW5pdGlvbmBdKCNoaWdobGlnaHQudGFncy5kZWZpbml0aW9uKVtgKHZhcmlhYmxlTmFtZSlgXSgjaGlnaGxpZ2h0LnRhZ3MudmFyaWFibGVOYW1lKVxuICB0byBgXCJ0b2stdmFyaWFibGVOYW1lIHRvay1kZWZpbml0aW9uXCJgXG4qIFtgZGVmaW5pdGlvbmBdKCNoaWdobGlnaHQudGFncy5kZWZpbml0aW9uKVtgKHByb3BlcnR5TmFtZSlgXSgjaGlnaGxpZ2h0LnRhZ3MucHJvcGVydHlOYW1lKVxuICB0byBgXCJ0b2stcHJvcGVydHlOYW1lIHRvay1kZWZpbml0aW9uXCJgXG4qL1xuY29uc3QgY2xhc3NIaWdobGlnaHRlciA9IHRhZ0hpZ2hsaWdodGVyKFtcbiAgICB7IHRhZzogdGFncy5saW5rLCBjbGFzczogXCJ0b2stbGlua1wiIH0sXG4gICAgeyB0YWc6IHRhZ3MuaGVhZGluZywgY2xhc3M6IFwidG9rLWhlYWRpbmdcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmVtcGhhc2lzLCBjbGFzczogXCJ0b2stZW1waGFzaXNcIiB9LFxuICAgIHsgdGFnOiB0YWdzLnN0cm9uZywgY2xhc3M6IFwidG9rLXN0cm9uZ1wiIH0sXG4gICAgeyB0YWc6IHRhZ3Mua2V5d29yZCwgY2xhc3M6IFwidG9rLWtleXdvcmRcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmF0b20sIGNsYXNzOiBcInRvay1hdG9tXCIgfSxcbiAgICB7IHRhZzogdGFncy5ib29sLCBjbGFzczogXCJ0b2stYm9vbFwiIH0sXG4gICAgeyB0YWc6IHRhZ3MudXJsLCBjbGFzczogXCJ0b2stdXJsXCIgfSxcbiAgICB7IHRhZzogdGFncy5sYWJlbE5hbWUsIGNsYXNzOiBcInRvay1sYWJlbE5hbWVcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmluc2VydGVkLCBjbGFzczogXCJ0b2staW5zZXJ0ZWRcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmRlbGV0ZWQsIGNsYXNzOiBcInRvay1kZWxldGVkXCIgfSxcbiAgICB7IHRhZzogdGFncy5saXRlcmFsLCBjbGFzczogXCJ0b2stbGl0ZXJhbFwiIH0sXG4gICAgeyB0YWc6IHRhZ3Muc3RyaW5nLCBjbGFzczogXCJ0b2stc3RyaW5nXCIgfSxcbiAgICB7IHRhZzogdGFncy5udW1iZXIsIGNsYXNzOiBcInRvay1udW1iZXJcIiB9LFxuICAgIHsgdGFnOiBbdGFncy5yZWdleHAsIHRhZ3MuZXNjYXBlLCB0YWdzLnNwZWNpYWwodGFncy5zdHJpbmcpXSwgY2xhc3M6IFwidG9rLXN0cmluZzJcIiB9LFxuICAgIHsgdGFnOiB0YWdzLnZhcmlhYmxlTmFtZSwgY2xhc3M6IFwidG9rLXZhcmlhYmxlTmFtZVwiIH0sXG4gICAgeyB0YWc6IHRhZ3MubG9jYWwodGFncy52YXJpYWJsZU5hbWUpLCBjbGFzczogXCJ0b2stdmFyaWFibGVOYW1lIHRvay1sb2NhbFwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuZGVmaW5pdGlvbih0YWdzLnZhcmlhYmxlTmFtZSksIGNsYXNzOiBcInRvay12YXJpYWJsZU5hbWUgdG9rLWRlZmluaXRpb25cIiB9LFxuICAgIHsgdGFnOiB0YWdzLnNwZWNpYWwodGFncy52YXJpYWJsZU5hbWUpLCBjbGFzczogXCJ0b2stdmFyaWFibGVOYW1lMlwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuZGVmaW5pdGlvbih0YWdzLnByb3BlcnR5TmFtZSksIGNsYXNzOiBcInRvay1wcm9wZXJ0eU5hbWUgdG9rLWRlZmluaXRpb25cIiB9LFxuICAgIHsgdGFnOiB0YWdzLnR5cGVOYW1lLCBjbGFzczogXCJ0b2stdHlwZU5hbWVcIiB9LFxuICAgIHsgdGFnOiB0YWdzLm5hbWVzcGFjZSwgY2xhc3M6IFwidG9rLW5hbWVzcGFjZVwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuY2xhc3NOYW1lLCBjbGFzczogXCJ0b2stY2xhc3NOYW1lXCIgfSxcbiAgICB7IHRhZzogdGFncy5tYWNyb05hbWUsIGNsYXNzOiBcInRvay1tYWNyb05hbWVcIiB9LFxuICAgIHsgdGFnOiB0YWdzLnByb3BlcnR5TmFtZSwgY2xhc3M6IFwidG9rLXByb3BlcnR5TmFtZVwiIH0sXG4gICAgeyB0YWc6IHRhZ3Mub3BlcmF0b3IsIGNsYXNzOiBcInRvay1vcGVyYXRvclwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuY29tbWVudCwgY2xhc3M6IFwidG9rLWNvbW1lbnRcIiB9LFxuICAgIHsgdGFnOiB0YWdzLm1ldGEsIGNsYXNzOiBcInRvay1tZXRhXCIgfSxcbiAgICB7IHRhZzogdGFncy5pbnZhbGlkLCBjbGFzczogXCJ0b2staW52YWxpZFwiIH0sXG4gICAgeyB0YWc6IHRhZ3MucHVuY3R1YXRpb24sIGNsYXNzOiBcInRvay1wdW5jdHVhdGlvblwiIH1cbl0pO1xuXG5leHBvcnQgeyBUYWcsIGNsYXNzSGlnaGxpZ2h0ZXIsIGdldFN0eWxlVGFncywgaGlnaGxpZ2h0Q29kZSwgaGlnaGxpZ2h0VHJlZSwgc3R5bGVUYWdzLCB0YWdIaWdobGlnaHRlciwgdGFncyB9O1xuIl0sIm5hbWVzIjpbIk5vZGVQcm9wIiwibmV4dFRhZ0lEIiwiVGFnIiwiY29uc3RydWN0b3IiLCJzZXQiLCJiYXNlIiwibW9kaWZpZWQiLCJpZCIsImRlZmluZSIsInBhcmVudCIsIkVycm9yIiwidGFnIiwicHVzaCIsInQiLCJkZWZpbmVNb2RpZmllciIsIm1vZCIsIk1vZGlmaWVyIiwiaW5kZXhPZiIsImdldCIsImNvbmNhdCIsInNvcnQiLCJhIiwiYiIsIm5leHRNb2RpZmllcklEIiwiaW5zdGFuY2VzIiwibW9kcyIsImxlbmd0aCIsImV4aXN0cyIsImZpbmQiLCJzYW1lQXJyYXkiLCJtIiwiY29uZmlncyIsInBvd2VyU2V0IiwiY29uZmlnIiwiZXZlcnkiLCJ4IiwiaSIsImFycmF5Iiwic2V0cyIsImoiLCJlIiwic3R5bGVUYWdzIiwic3BlYyIsImJ5TmFtZSIsIk9iamVjdCIsImNyZWF0ZSIsInByb3AiLCJ0YWdzIiwiQXJyYXkiLCJpc0FycmF5IiwicGFydCIsInNwbGl0IiwicGllY2VzIiwibW9kZSIsInJlc3QiLCJwb3MiLCJleGVjIiwiUmFuZ2VFcnJvciIsIkpTT04iLCJwYXJzZSIsIm5leHQiLCJzbGljZSIsImxhc3QiLCJpbm5lciIsInJ1bGUiLCJSdWxlIiwicnVsZU5vZGVQcm9wIiwiYWRkIiwiY29udGV4dCIsIm9wYXF1ZSIsImluaGVyaXQiLCJvdGhlciIsImRlcHRoIiwiZW1wdHkiLCJ0YWdIaWdobGlnaHRlciIsIm9wdGlvbnMiLCJtYXAiLCJzdHlsZSIsImNsYXNzIiwic2NvcGUiLCJhbGwiLCJjbHMiLCJzdWIiLCJ0YWdDbGFzcyIsImhpZ2hsaWdodFRhZ3MiLCJoaWdobGlnaHRlcnMiLCJyZXN1bHQiLCJoaWdobGlnaHRlciIsInZhbHVlIiwiaGlnaGxpZ2h0VHJlZSIsInRyZWUiLCJwdXRTdHlsZSIsImZyb20iLCJ0byIsImJ1aWxkZXIiLCJIaWdobGlnaHRCdWlsZGVyIiwiaGlnaGxpZ2h0UmFuZ2UiLCJjdXJzb3IiLCJmbHVzaCIsImhpZ2hsaWdodENvZGUiLCJjb2RlIiwicHV0VGV4dCIsInB1dEJyZWFrIiwid3JpdGVUbyIsInAiLCJjbGFzc2VzIiwidGV4dCIsIm5leHRCcmVhayIsInVwdG8iLCJhdCIsInNwYW4iLCJzdGFydFNwYW4iLCJpbmhlcml0ZWRDbGFzcyIsInR5cGUiLCJzdGFydCIsImVuZCIsImlzVG9wIiwiZmlsdGVyIiwiaCIsImdldFN0eWxlVGFncyIsInRhZ0NscyIsIk1hdGgiLCJtYXgiLCJtb3VudGVkIiwib3ZlcmxheSIsIm5vZGUiLCJlbnRlciIsImlubmVySGlnaGxpZ2h0ZXJzIiwiaGFzQ2hpbGQiLCJmaXJzdENoaWxkIiwibmV4dFBvcyIsInJhbmdlRnJvbSIsInJhbmdlVG8iLCJtaW4iLCJuZXh0U2libGluZyIsIm1hdGNoQ29udGV4dCIsImNvbW1lbnQiLCJuYW1lIiwidHlwZU5hbWUiLCJwcm9wZXJ0eU5hbWUiLCJsaXRlcmFsIiwic3RyaW5nIiwibnVtYmVyIiwiY29udGVudCIsImhlYWRpbmciLCJrZXl3b3JkIiwib3BlcmF0b3IiLCJwdW5jdHVhdGlvbiIsImJyYWNrZXQiLCJtZXRhIiwibGluZUNvbW1lbnQiLCJibG9ja0NvbW1lbnQiLCJkb2NDb21tZW50IiwidmFyaWFibGVOYW1lIiwidGFnTmFtZSIsImF0dHJpYnV0ZU5hbWUiLCJjbGFzc05hbWUiLCJsYWJlbE5hbWUiLCJuYW1lc3BhY2UiLCJtYWNyb05hbWUiLCJkb2NTdHJpbmciLCJjaGFyYWN0ZXIiLCJhdHRyaWJ1dGVWYWx1ZSIsImludGVnZXIiLCJmbG9hdCIsImJvb2wiLCJyZWdleHAiLCJlc2NhcGUiLCJjb2xvciIsInVybCIsInNlbGYiLCJudWxsIiwiYXRvbSIsInVuaXQiLCJtb2RpZmllciIsIm9wZXJhdG9yS2V5d29yZCIsImNvbnRyb2xLZXl3b3JkIiwiZGVmaW5pdGlvbktleXdvcmQiLCJtb2R1bGVLZXl3b3JkIiwiZGVyZWZPcGVyYXRvciIsImFyaXRobWV0aWNPcGVyYXRvciIsImxvZ2ljT3BlcmF0b3IiLCJiaXR3aXNlT3BlcmF0b3IiLCJjb21wYXJlT3BlcmF0b3IiLCJ1cGRhdGVPcGVyYXRvciIsImRlZmluaXRpb25PcGVyYXRvciIsInR5cGVPcGVyYXRvciIsImNvbnRyb2xPcGVyYXRvciIsInNlcGFyYXRvciIsImFuZ2xlQnJhY2tldCIsInNxdWFyZUJyYWNrZXQiLCJwYXJlbiIsImJyYWNlIiwiaGVhZGluZzEiLCJoZWFkaW5nMiIsImhlYWRpbmczIiwiaGVhZGluZzQiLCJoZWFkaW5nNSIsImhlYWRpbmc2IiwiY29udGVudFNlcGFyYXRvciIsImxpc3QiLCJxdW90ZSIsImVtcGhhc2lzIiwic3Ryb25nIiwibGluayIsIm1vbm9zcGFjZSIsInN0cmlrZXRocm91Z2giLCJpbnNlcnRlZCIsImRlbGV0ZWQiLCJjaGFuZ2VkIiwiaW52YWxpZCIsImRvY3VtZW50TWV0YSIsImFubm90YXRpb24iLCJwcm9jZXNzaW5nSW5zdHJ1Y3Rpb24iLCJkZWZpbml0aW9uIiwiY29uc3RhbnQiLCJmdW5jdGlvbiIsInN0YW5kYXJkIiwibG9jYWwiLCJzcGVjaWFsIiwiY2xhc3NIaWdobGlnaHRlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lezer/highlight/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lezer/lr/dist/index.js":
/*!**********************************************!*\
  !*** ./node_modules/@lezer/lr/dist/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ContextTracker: () => (/* binding */ ContextTracker),\n/* harmony export */   ExternalTokenizer: () => (/* binding */ ExternalTokenizer),\n/* harmony export */   InputStream: () => (/* binding */ InputStream),\n/* harmony export */   LRParser: () => (/* binding */ LRParser),\n/* harmony export */   LocalTokenGroup: () => (/* binding */ LocalTokenGroup),\n/* harmony export */   Stack: () => (/* binding */ Stack)\n/* harmony export */ });\n/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/common */ \"(ssr)/./node_modules/@lezer/common/dist/index.js\");\n\n/**\nA parse stack. These are used internally by the parser to track\nparsing progress. They also provide some properties and methods\nthat external code such as a tokenizer can use to get information\nabout the parse state.\n*/ class Stack {\n    /**\n    @internal\n    */ constructor(/**\n    The parse that this stack is part of @internal\n    */ p, /**\n    Holds state, input pos, buffer index triplets for all but the\n    top state @internal\n    */ stack, /**\n    The current parse state @internal\n    */ state, // The position at which the next reduce should take place. This\n    // can be less than `this.pos` when skipped expressions have been\n    // added to the stack (which should be moved outside of the next\n    // reduction)\n    /**\n    @internal\n    */ reducePos, /**\n    The input position up to which this stack has parsed.\n    */ pos, /**\n    The dynamic score of the stack, including dynamic precedence\n    and error-recovery penalties\n    @internal\n    */ score, // The output buffer. Holds (type, start, end, size) quads\n    // representing nodes created by the parser, where `size` is\n    // amount of buffer array entries covered by this node.\n    /**\n    @internal\n    */ buffer, // The base offset of the buffer. When stacks are split, the split\n    // instance shared the buffer history with its parent up to\n    // `bufferBase`, which is the absolute offset (including the\n    // offset of previous splits) into the buffer at which this stack\n    // starts writing.\n    /**\n    @internal\n    */ bufferBase, /**\n    @internal\n    */ curContext, /**\n    @internal\n    */ lookAhead = 0, // A parent stack from which this was split off, if any. This is\n    // set up so that it always points to a stack that has some\n    // additional buffer content, never to a stack with an equal\n    // `bufferBase`.\n    /**\n    @internal\n    */ parent){\n        this.p = p;\n        this.stack = stack;\n        this.state = state;\n        this.reducePos = reducePos;\n        this.pos = pos;\n        this.score = score;\n        this.buffer = buffer;\n        this.bufferBase = bufferBase;\n        this.curContext = curContext;\n        this.lookAhead = lookAhead;\n        this.parent = parent;\n    }\n    /**\n    @internal\n    */ toString() {\n        return `[${this.stack.filter((_, i)=>i % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? \"!\" + this.score : \"\"}`;\n    }\n    // Start an empty stack\n    /**\n    @internal\n    */ static start(p, state, pos = 0) {\n        let cx = p.parser.context;\n        return new Stack(p, [], state, pos, pos, 0, [], 0, cx ? new StackContext(cx, cx.start) : null, 0, null);\n    }\n    /**\n    The stack's current [context](#lr.ContextTracker) value, if\n    any. Its type will depend on the context tracker's type\n    parameter, or it will be `null` if there is no context\n    tracker.\n    */ get context() {\n        return this.curContext ? this.curContext.context : null;\n    }\n    // Push a state onto the stack, tracking its start position as well\n    // as the buffer base at that point.\n    /**\n    @internal\n    */ pushState(state, start) {\n        this.stack.push(this.state, start, this.bufferBase + this.buffer.length);\n        this.state = state;\n    }\n    // Apply a reduce action\n    /**\n    @internal\n    */ reduce(action) {\n        var _a;\n        let depth = action >> 19 /* Action.ReduceDepthShift */ , type = action & 65535 /* Action.ValueMask */ ;\n        let { parser } = this.p;\n        let dPrec = parser.dynamicPrecedence(type);\n        if (dPrec) this.score += dPrec;\n        if (depth == 0) {\n            this.pushState(parser.getGoto(this.state, type, true), this.reducePos);\n            // Zero-depth reductions are a special case—they add stuff to\n            // the stack without popping anything off.\n            if (type < parser.minRepeatTerm) this.storeNode(type, this.reducePos, this.reducePos, 4, true);\n            this.reduceContext(type, this.reducePos);\n            return;\n        }\n        // Find the base index into `this.stack`, content after which will\n        // be dropped. Note that with `StayFlag` reductions we need to\n        // consume two extra frames (the dummy parent node for the skipped\n        // expression and the state that we'll be staying in, which should\n        // be moved to `this.state`).\n        let base = this.stack.length - (depth - 1) * 3 - (action & 262144 /* Action.StayFlag */  ? 6 : 0);\n        let start = base ? this.stack[base - 2] : this.p.ranges[0].from, size = this.reducePos - start;\n        // This is a kludge to try and detect overly deep left-associative\n        // trees, which will not increase the parse stack depth and thus\n        // won't be caught by the regular stack-depth limit check.\n        if (size >= 2000 /* Recover.MinBigReduction */  && !((_a = this.p.parser.nodeSet.types[type]) === null || _a === void 0 ? void 0 : _a.isAnonymous)) {\n            if (start == this.p.lastBigReductionStart) {\n                this.p.bigReductionCount++;\n                this.p.lastBigReductionSize = size;\n            } else if (this.p.lastBigReductionSize < size) {\n                this.p.bigReductionCount = 1;\n                this.p.lastBigReductionStart = start;\n                this.p.lastBigReductionSize = size;\n            }\n        }\n        let bufferBase = base ? this.stack[base - 1] : 0, count = this.bufferBase + this.buffer.length - bufferBase;\n        // Store normal terms or `R -> R R` repeat reductions\n        if (type < parser.minRepeatTerm || action & 131072 /* Action.RepeatFlag */ ) {\n            let pos = parser.stateFlag(this.state, 1 /* StateFlag.Skipped */ ) ? this.pos : this.reducePos;\n            this.storeNode(type, start, pos, count + 4, true);\n        }\n        if (action & 262144 /* Action.StayFlag */ ) {\n            this.state = this.stack[base];\n        } else {\n            let baseStateID = this.stack[base - 3];\n            this.state = parser.getGoto(baseStateID, type, true);\n        }\n        while(this.stack.length > base)this.stack.pop();\n        this.reduceContext(type, start);\n    }\n    // Shift a value into the buffer\n    /**\n    @internal\n    */ storeNode(term, start, end, size = 4, isReduce = false) {\n        if (term == 0 /* Term.Err */  && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {\n            // Try to omit/merge adjacent error nodes\n            let cur = this, top = this.buffer.length;\n            if (top == 0 && cur.parent) {\n                top = cur.bufferBase - cur.parent.bufferBase;\n                cur = cur.parent;\n            }\n            if (top > 0 && cur.buffer[top - 4] == 0 /* Term.Err */  && cur.buffer[top - 1] > -1) {\n                if (start == end) return;\n                if (cur.buffer[top - 2] >= start) {\n                    cur.buffer[top - 2] = end;\n                    return;\n                }\n            }\n        }\n        if (!isReduce || this.pos == end) {\n            this.buffer.push(term, start, end, size);\n        } else {\n            let index = this.buffer.length;\n            if (index > 0 && this.buffer[index - 4] != 0 /* Term.Err */ ) while(index > 0 && this.buffer[index - 2] > end){\n                // Move this record forward\n                this.buffer[index] = this.buffer[index - 4];\n                this.buffer[index + 1] = this.buffer[index - 3];\n                this.buffer[index + 2] = this.buffer[index - 2];\n                this.buffer[index + 3] = this.buffer[index - 1];\n                index -= 4;\n                if (size > 4) size -= 4;\n            }\n            this.buffer[index] = term;\n            this.buffer[index + 1] = start;\n            this.buffer[index + 2] = end;\n            this.buffer[index + 3] = size;\n        }\n    }\n    // Apply a shift action\n    /**\n    @internal\n    */ shift(action, type, start, end) {\n        if (action & 131072 /* Action.GotoFlag */ ) {\n            this.pushState(action & 65535 /* Action.ValueMask */ , this.pos);\n        } else if ((action & 262144 /* Action.StayFlag */ ) == 0) {\n            let nextState = action, { parser } = this.p;\n            if (end > this.pos || type <= parser.maxNode) {\n                this.pos = end;\n                if (!parser.stateFlag(nextState, 1 /* StateFlag.Skipped */ )) this.reducePos = end;\n            }\n            this.pushState(nextState, start);\n            this.shiftContext(type, start);\n            if (type <= parser.maxNode) this.buffer.push(type, start, end, 4);\n        } else {\n            this.pos = end;\n            this.shiftContext(type, start);\n            if (type <= this.p.parser.maxNode) this.buffer.push(type, start, end, 4);\n        }\n    }\n    // Apply an action\n    /**\n    @internal\n    */ apply(action, next, nextStart, nextEnd) {\n        if (action & 65536 /* Action.ReduceFlag */ ) this.reduce(action);\n        else this.shift(action, next, nextStart, nextEnd);\n    }\n    // Add a prebuilt (reused) node into the buffer.\n    /**\n    @internal\n    */ useNode(value, next) {\n        let index = this.p.reused.length - 1;\n        if (index < 0 || this.p.reused[index] != value) {\n            this.p.reused.push(value);\n            index++;\n        }\n        let start = this.pos;\n        this.reducePos = this.pos = start + value.length;\n        this.pushState(next, start);\n        this.buffer.push(index, start, this.reducePos, -1 /* size == -1 means this is a reused value */ );\n        if (this.curContext) this.updateContext(this.curContext.tracker.reuse(this.curContext.context, value, this, this.p.stream.reset(this.pos - value.length)));\n    }\n    // Split the stack. Due to the buffer sharing and the fact\n    // that `this.stack` tends to stay quite shallow, this isn't very\n    // expensive.\n    /**\n    @internal\n    */ split() {\n        let parent = this;\n        let off = parent.buffer.length;\n        // Because the top of the buffer (after this.pos) may be mutated\n        // to reorder reductions and skipped tokens, and shared buffers\n        // should be immutable, this copies any outstanding skipped tokens\n        // to the new buffer, and puts the base pointer before them.\n        while(off > 0 && parent.buffer[off - 2] > parent.reducePos)off -= 4;\n        let buffer = parent.buffer.slice(off), base = parent.bufferBase + off;\n        // Make sure parent points to an actual parent with content, if there is such a parent.\n        while(parent && base == parent.bufferBase)parent = parent.parent;\n        return new Stack(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, buffer, base, this.curContext, this.lookAhead, parent);\n    }\n    // Try to recover from an error by 'deleting' (ignoring) one token.\n    /**\n    @internal\n    */ recoverByDelete(next, nextEnd) {\n        let isNode = next <= this.p.parser.maxNode;\n        if (isNode) this.storeNode(next, this.pos, nextEnd, 4);\n        this.storeNode(0 /* Term.Err */ , this.pos, nextEnd, isNode ? 8 : 4);\n        this.pos = this.reducePos = nextEnd;\n        this.score -= 190 /* Recover.Delete */ ;\n    }\n    /**\n    Check if the given term would be able to be shifted (optionally\n    after some reductions) on this stack. This can be useful for\n    external tokenizers that want to make sure they only provide a\n    given token when it applies.\n    */ canShift(term) {\n        for(let sim = new SimulatedStack(this);;){\n            let action = this.p.parser.stateSlot(sim.state, 4 /* ParseState.DefaultReduce */ ) || this.p.parser.hasAction(sim.state, term);\n            if (action == 0) return false;\n            if ((action & 65536 /* Action.ReduceFlag */ ) == 0) return true;\n            sim.reduce(action);\n        }\n    }\n    // Apply up to Recover.MaxNext recovery actions that conceptually\n    // inserts some missing token or rule.\n    /**\n    @internal\n    */ recoverByInsert(next) {\n        if (this.stack.length >= 300 /* Recover.MaxInsertStackDepth */ ) return [];\n        let nextStates = this.p.parser.nextStates(this.state);\n        if (nextStates.length > 4 /* Recover.MaxNext */  << 1 || this.stack.length >= 120 /* Recover.DampenInsertStackDepth */ ) {\n            let best = [];\n            for(let i = 0, s; i < nextStates.length; i += 2){\n                if ((s = nextStates[i + 1]) != this.state && this.p.parser.hasAction(s, next)) best.push(nextStates[i], s);\n            }\n            if (this.stack.length < 120 /* Recover.DampenInsertStackDepth */ ) for(let i = 0; best.length < 4 /* Recover.MaxNext */  << 1 && i < nextStates.length; i += 2){\n                let s = nextStates[i + 1];\n                if (!best.some((v, i)=>i & 1 && v == s)) best.push(nextStates[i], s);\n            }\n            nextStates = best;\n        }\n        let result = [];\n        for(let i = 0; i < nextStates.length && result.length < 4 /* Recover.MaxNext */ ; i += 2){\n            let s = nextStates[i + 1];\n            if (s == this.state) continue;\n            let stack = this.split();\n            stack.pushState(s, this.pos);\n            stack.storeNode(0 /* Term.Err */ , stack.pos, stack.pos, 4, true);\n            stack.shiftContext(nextStates[i], this.pos);\n            stack.reducePos = this.pos;\n            stack.score -= 200 /* Recover.Insert */ ;\n            result.push(stack);\n        }\n        return result;\n    }\n    // Force a reduce, if possible. Return false if that can't\n    // be done.\n    /**\n    @internal\n    */ forceReduce() {\n        let { parser } = this.p;\n        let reduce = parser.stateSlot(this.state, 5 /* ParseState.ForcedReduce */ );\n        if ((reduce & 65536 /* Action.ReduceFlag */ ) == 0) return false;\n        if (!parser.validAction(this.state, reduce)) {\n            let depth = reduce >> 19 /* Action.ReduceDepthShift */ , term = reduce & 65535 /* Action.ValueMask */ ;\n            let target = this.stack.length - depth * 3;\n            if (target < 0 || parser.getGoto(this.stack[target], term, false) < 0) {\n                let backup = this.findForcedReduction();\n                if (backup == null) return false;\n                reduce = backup;\n            }\n            this.storeNode(0 /* Term.Err */ , this.pos, this.pos, 4, true);\n            this.score -= 100 /* Recover.Reduce */ ;\n        }\n        this.reducePos = this.pos;\n        this.reduce(reduce);\n        return true;\n    }\n    /**\n    Try to scan through the automaton to find some kind of reduction\n    that can be applied. Used when the regular ForcedReduce field\n    isn't a valid action. @internal\n    */ findForcedReduction() {\n        let { parser } = this.p, seen = [];\n        let explore = (state, depth)=>{\n            if (seen.includes(state)) return;\n            seen.push(state);\n            return parser.allActions(state, (action)=>{\n                if (action & (262144 /* Action.StayFlag */  | 131072 /* Action.GotoFlag */ )) ;\n                else if (action & 65536 /* Action.ReduceFlag */ ) {\n                    let rDepth = (action >> 19 /* Action.ReduceDepthShift */ ) - depth;\n                    if (rDepth > 1) {\n                        let term = action & 65535 /* Action.ValueMask */ , target = this.stack.length - rDepth * 3;\n                        if (target >= 0 && parser.getGoto(this.stack[target], term, false) >= 0) return rDepth << 19 /* Action.ReduceDepthShift */  | 65536 /* Action.ReduceFlag */  | term;\n                    }\n                } else {\n                    let found = explore(action, depth + 1);\n                    if (found != null) return found;\n                }\n            });\n        };\n        return explore(this.state, 0);\n    }\n    /**\n    @internal\n    */ forceAll() {\n        while(!this.p.parser.stateFlag(this.state, 2 /* StateFlag.Accepting */ )){\n            if (!this.forceReduce()) {\n                this.storeNode(0 /* Term.Err */ , this.pos, this.pos, 4, true);\n                break;\n            }\n        }\n        return this;\n    }\n    /**\n    Check whether this state has no further actions (assumed to be a direct descendant of the\n    top state, since any other states must be able to continue\n    somehow). @internal\n    */ get deadEnd() {\n        if (this.stack.length != 3) return false;\n        let { parser } = this.p;\n        return parser.data[parser.stateSlot(this.state, 1 /* ParseState.Actions */ )] == 65535 /* Seq.End */  && !parser.stateSlot(this.state, 4 /* ParseState.DefaultReduce */ );\n    }\n    /**\n    Restart the stack (put it back in its start state). Only safe\n    when this.stack.length == 3 (state is directly below the top\n    state). @internal\n    */ restart() {\n        this.storeNode(0 /* Term.Err */ , this.pos, this.pos, 4, true);\n        this.state = this.stack[0];\n        this.stack.length = 0;\n    }\n    /**\n    @internal\n    */ sameState(other) {\n        if (this.state != other.state || this.stack.length != other.stack.length) return false;\n        for(let i = 0; i < this.stack.length; i += 3)if (this.stack[i] != other.stack[i]) return false;\n        return true;\n    }\n    /**\n    Get the parser used by this stack.\n    */ get parser() {\n        return this.p.parser;\n    }\n    /**\n    Test whether a given dialect (by numeric ID, as exported from\n    the terms file) is enabled.\n    */ dialectEnabled(dialectID) {\n        return this.p.parser.dialect.flags[dialectID];\n    }\n    shiftContext(term, start) {\n        if (this.curContext) this.updateContext(this.curContext.tracker.shift(this.curContext.context, term, this, this.p.stream.reset(start)));\n    }\n    reduceContext(term, start) {\n        if (this.curContext) this.updateContext(this.curContext.tracker.reduce(this.curContext.context, term, this, this.p.stream.reset(start)));\n    }\n    /**\n    @internal\n    */ emitContext() {\n        let last = this.buffer.length - 1;\n        if (last < 0 || this.buffer[last] != -3) this.buffer.push(this.curContext.hash, this.pos, this.pos, -3);\n    }\n    /**\n    @internal\n    */ emitLookAhead() {\n        let last = this.buffer.length - 1;\n        if (last < 0 || this.buffer[last] != -4) this.buffer.push(this.lookAhead, this.pos, this.pos, -4);\n    }\n    updateContext(context) {\n        if (context != this.curContext.context) {\n            let newCx = new StackContext(this.curContext.tracker, context);\n            if (newCx.hash != this.curContext.hash) this.emitContext();\n            this.curContext = newCx;\n        }\n    }\n    /**\n    @internal\n    */ setLookAhead(lookAhead) {\n        if (lookAhead > this.lookAhead) {\n            this.emitLookAhead();\n            this.lookAhead = lookAhead;\n        }\n    }\n    /**\n    @internal\n    */ close() {\n        if (this.curContext && this.curContext.tracker.strict) this.emitContext();\n        if (this.lookAhead > 0) this.emitLookAhead();\n    }\n}\nclass StackContext {\n    constructor(tracker, context){\n        this.tracker = tracker;\n        this.context = context;\n        this.hash = tracker.strict ? tracker.hash(context) : 0;\n    }\n}\n// Used to cheaply run some reductions to scan ahead without mutating\n// an entire stack\nclass SimulatedStack {\n    constructor(start){\n        this.start = start;\n        this.state = start.state;\n        this.stack = start.stack;\n        this.base = this.stack.length;\n    }\n    reduce(action) {\n        let term = action & 65535 /* Action.ValueMask */ , depth = action >> 19 /* Action.ReduceDepthShift */ ;\n        if (depth == 0) {\n            if (this.stack == this.start.stack) this.stack = this.stack.slice();\n            this.stack.push(this.state, 0, 0);\n            this.base += 3;\n        } else {\n            this.base -= (depth - 1) * 3;\n        }\n        let goto = this.start.p.parser.getGoto(this.stack[this.base - 3], term, true);\n        this.state = goto;\n    }\n}\n// This is given to `Tree.build` to build a buffer, and encapsulates\n// the parent-stack-walking necessary to read the nodes.\nclass StackBufferCursor {\n    constructor(stack, pos, index){\n        this.stack = stack;\n        this.pos = pos;\n        this.index = index;\n        this.buffer = stack.buffer;\n        if (this.index == 0) this.maybeNext();\n    }\n    static create(stack, pos = stack.bufferBase + stack.buffer.length) {\n        return new StackBufferCursor(stack, pos, pos - stack.bufferBase);\n    }\n    maybeNext() {\n        let next = this.stack.parent;\n        if (next != null) {\n            this.index = this.stack.bufferBase - next.bufferBase;\n            this.stack = next;\n            this.buffer = next.buffer;\n        }\n    }\n    get id() {\n        return this.buffer[this.index - 4];\n    }\n    get start() {\n        return this.buffer[this.index - 3];\n    }\n    get end() {\n        return this.buffer[this.index - 2];\n    }\n    get size() {\n        return this.buffer[this.index - 1];\n    }\n    next() {\n        this.index -= 4;\n        this.pos -= 4;\n        if (this.index == 0) this.maybeNext();\n    }\n    fork() {\n        return new StackBufferCursor(this.stack, this.pos, this.index);\n    }\n}\n// See lezer-generator/src/encode.ts for comments about the encoding\n// used here\nfunction decodeArray(input, Type = Uint16Array) {\n    if (typeof input != \"string\") return input;\n    let array = null;\n    for(let pos = 0, out = 0; pos < input.length;){\n        let value = 0;\n        for(;;){\n            let next = input.charCodeAt(pos++), stop = false;\n            if (next == 126 /* Encode.BigValCode */ ) {\n                value = 65535 /* Encode.BigVal */ ;\n                break;\n            }\n            if (next >= 92 /* Encode.Gap2 */ ) next--;\n            if (next >= 34 /* Encode.Gap1 */ ) next--;\n            let digit = next - 32 /* Encode.Start */ ;\n            if (digit >= 46 /* Encode.Base */ ) {\n                digit -= 46 /* Encode.Base */ ;\n                stop = true;\n            }\n            value += digit;\n            if (stop) break;\n            value *= 46 /* Encode.Base */ ;\n        }\n        if (array) array[out++] = value;\n        else array = new Type(value);\n    }\n    return array;\n}\nclass CachedToken {\n    constructor(){\n        this.start = -1;\n        this.value = -1;\n        this.end = -1;\n        this.extended = -1;\n        this.lookAhead = 0;\n        this.mask = 0;\n        this.context = 0;\n    }\n}\nconst nullToken = new CachedToken;\n/**\n[Tokenizers](#lr.ExternalTokenizer) interact with the input\nthrough this interface. It presents the input as a stream of\ncharacters, tracking lookahead and hiding the complexity of\n[ranges](#common.Parser.parse^ranges) from tokenizer code.\n*/ class InputStream {\n    /**\n    @internal\n    */ constructor(/**\n    @internal\n    */ input, /**\n    @internal\n    */ ranges){\n        this.input = input;\n        this.ranges = ranges;\n        /**\n        @internal\n        */ this.chunk = \"\";\n        /**\n        @internal\n        */ this.chunkOff = 0;\n        /**\n        Backup chunk\n        */ this.chunk2 = \"\";\n        this.chunk2Pos = 0;\n        /**\n        The character code of the next code unit in the input, or -1\n        when the stream is at the end of the input.\n        */ this.next = -1;\n        /**\n        @internal\n        */ this.token = nullToken;\n        this.rangeIndex = 0;\n        this.pos = this.chunkPos = ranges[0].from;\n        this.range = ranges[0];\n        this.end = ranges[ranges.length - 1].to;\n        this.readNext();\n    }\n    /**\n    @internal\n    */ resolveOffset(offset, assoc) {\n        let range = this.range, index = this.rangeIndex;\n        let pos = this.pos + offset;\n        while(pos < range.from){\n            if (!index) return null;\n            let next = this.ranges[--index];\n            pos -= range.from - next.to;\n            range = next;\n        }\n        while(assoc < 0 ? pos > range.to : pos >= range.to){\n            if (index == this.ranges.length - 1) return null;\n            let next = this.ranges[++index];\n            pos += next.from - range.to;\n            range = next;\n        }\n        return pos;\n    }\n    /**\n    @internal\n    */ clipPos(pos) {\n        if (pos >= this.range.from && pos < this.range.to) return pos;\n        for (let range of this.ranges)if (range.to > pos) return Math.max(pos, range.from);\n        return this.end;\n    }\n    /**\n    Look at a code unit near the stream position. `.peek(0)` equals\n    `.next`, `.peek(-1)` gives you the previous character, and so\n    on.\n    \n    Note that looking around during tokenizing creates dependencies\n    on potentially far-away content, which may reduce the\n    effectiveness incremental parsing—when looking forward—or even\n    cause invalid reparses when looking backward more than 25 code\n    units, since the library does not track lookbehind.\n    */ peek(offset) {\n        let idx = this.chunkOff + offset, pos, result;\n        if (idx >= 0 && idx < this.chunk.length) {\n            pos = this.pos + offset;\n            result = this.chunk.charCodeAt(idx);\n        } else {\n            let resolved = this.resolveOffset(offset, 1);\n            if (resolved == null) return -1;\n            pos = resolved;\n            if (pos >= this.chunk2Pos && pos < this.chunk2Pos + this.chunk2.length) {\n                result = this.chunk2.charCodeAt(pos - this.chunk2Pos);\n            } else {\n                let i = this.rangeIndex, range = this.range;\n                while(range.to <= pos)range = this.ranges[++i];\n                this.chunk2 = this.input.chunk(this.chunk2Pos = pos);\n                if (pos + this.chunk2.length > range.to) this.chunk2 = this.chunk2.slice(0, range.to - pos);\n                result = this.chunk2.charCodeAt(0);\n            }\n        }\n        if (pos >= this.token.lookAhead) this.token.lookAhead = pos + 1;\n        return result;\n    }\n    /**\n    Accept a token. By default, the end of the token is set to the\n    current stream position, but you can pass an offset (relative to\n    the stream position) to change that.\n    */ acceptToken(token, endOffset = 0) {\n        let end = endOffset ? this.resolveOffset(endOffset, -1) : this.pos;\n        if (end == null || end < this.token.start) throw new RangeError(\"Token end out of bounds\");\n        this.token.value = token;\n        this.token.end = end;\n    }\n    getChunk() {\n        if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {\n            let { chunk, chunkPos } = this;\n            this.chunk = this.chunk2;\n            this.chunkPos = this.chunk2Pos;\n            this.chunk2 = chunk;\n            this.chunk2Pos = chunkPos;\n            this.chunkOff = this.pos - this.chunkPos;\n        } else {\n            this.chunk2 = this.chunk;\n            this.chunk2Pos = this.chunkPos;\n            let nextChunk = this.input.chunk(this.pos);\n            let end = this.pos + nextChunk.length;\n            this.chunk = end > this.range.to ? nextChunk.slice(0, this.range.to - this.pos) : nextChunk;\n            this.chunkPos = this.pos;\n            this.chunkOff = 0;\n        }\n    }\n    readNext() {\n        if (this.chunkOff >= this.chunk.length) {\n            this.getChunk();\n            if (this.chunkOff == this.chunk.length) return this.next = -1;\n        }\n        return this.next = this.chunk.charCodeAt(this.chunkOff);\n    }\n    /**\n    Move the stream forward N (defaults to 1) code units. Returns\n    the new value of [`next`](#lr.InputStream.next).\n    */ advance(n = 1) {\n        this.chunkOff += n;\n        while(this.pos + n >= this.range.to){\n            if (this.rangeIndex == this.ranges.length - 1) return this.setDone();\n            n -= this.range.to - this.pos;\n            this.range = this.ranges[++this.rangeIndex];\n            this.pos = this.range.from;\n        }\n        this.pos += n;\n        if (this.pos >= this.token.lookAhead) this.token.lookAhead = this.pos + 1;\n        return this.readNext();\n    }\n    setDone() {\n        this.pos = this.chunkPos = this.end;\n        this.range = this.ranges[this.rangeIndex = this.ranges.length - 1];\n        this.chunk = \"\";\n        return this.next = -1;\n    }\n    /**\n    @internal\n    */ reset(pos, token) {\n        if (token) {\n            this.token = token;\n            token.start = pos;\n            token.lookAhead = pos + 1;\n            token.value = token.extended = -1;\n        } else {\n            this.token = nullToken;\n        }\n        if (this.pos != pos) {\n            this.pos = pos;\n            if (pos == this.end) {\n                this.setDone();\n                return this;\n            }\n            while(pos < this.range.from)this.range = this.ranges[--this.rangeIndex];\n            while(pos >= this.range.to)this.range = this.ranges[++this.rangeIndex];\n            if (pos >= this.chunkPos && pos < this.chunkPos + this.chunk.length) {\n                this.chunkOff = pos - this.chunkPos;\n            } else {\n                this.chunk = \"\";\n                this.chunkOff = 0;\n            }\n            this.readNext();\n        }\n        return this;\n    }\n    /**\n    @internal\n    */ read(from, to) {\n        if (from >= this.chunkPos && to <= this.chunkPos + this.chunk.length) return this.chunk.slice(from - this.chunkPos, to - this.chunkPos);\n        if (from >= this.chunk2Pos && to <= this.chunk2Pos + this.chunk2.length) return this.chunk2.slice(from - this.chunk2Pos, to - this.chunk2Pos);\n        if (from >= this.range.from && to <= this.range.to) return this.input.read(from, to);\n        let result = \"\";\n        for (let r of this.ranges){\n            if (r.from >= to) break;\n            if (r.to > from) result += this.input.read(Math.max(r.from, from), Math.min(r.to, to));\n        }\n        return result;\n    }\n}\n/**\n@internal\n*/ class TokenGroup {\n    constructor(data, id){\n        this.data = data;\n        this.id = id;\n    }\n    token(input, stack) {\n        let { parser } = stack.p;\n        readToken(this.data, input, stack, this.id, parser.data, parser.tokenPrecTable);\n    }\n}\nTokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;\n/**\n@hide\n*/ class LocalTokenGroup {\n    constructor(data, precTable, elseToken){\n        this.precTable = precTable;\n        this.elseToken = elseToken;\n        this.data = typeof data == \"string\" ? decodeArray(data) : data;\n    }\n    token(input, stack) {\n        let start = input.pos, skipped = 0;\n        for(;;){\n            let atEof = input.next < 0, nextPos = input.resolveOffset(1, 1);\n            readToken(this.data, input, stack, 0, this.data, this.precTable);\n            if (input.token.value > -1) break;\n            if (this.elseToken == null) return;\n            if (!atEof) skipped++;\n            if (nextPos == null) break;\n            input.reset(nextPos, input.token);\n        }\n        if (skipped) {\n            input.reset(start, input.token);\n            input.acceptToken(this.elseToken, skipped);\n        }\n    }\n}\nLocalTokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;\n/**\n`@external tokens` declarations in the grammar should resolve to\nan instance of this class.\n*/ class ExternalTokenizer {\n    /**\n    Create a tokenizer. The first argument is the function that,\n    given an input stream, scans for the types of tokens it\n    recognizes at the stream's position, and calls\n    [`acceptToken`](#lr.InputStream.acceptToken) when it finds\n    one.\n    */ constructor(/**\n    @internal\n    */ token, options = {}){\n        this.token = token;\n        this.contextual = !!options.contextual;\n        this.fallback = !!options.fallback;\n        this.extend = !!options.extend;\n    }\n}\n// Tokenizer data is stored a big uint16 array containing, for each\n// state:\n//\n//  - A group bitmask, indicating what token groups are reachable from\n//    this state, so that paths that can only lead to tokens not in\n//    any of the current groups can be cut off early.\n//\n//  - The position of the end of the state's sequence of accepting\n//    tokens\n//\n//  - The number of outgoing edges for the state\n//\n//  - The accepting tokens, as (token id, group mask) pairs\n//\n//  - The outgoing edges, as (start character, end character, state\n//    index) triples, with end character being exclusive\n//\n// This function interprets that data, running through a stream as\n// long as new states with the a matching group mask can be reached,\n// and updating `input.token` when it matches a token.\nfunction readToken(data, input, stack, group, precTable, precOffset) {\n    let state = 0, groupMask = 1 << group, { dialect } = stack.p.parser;\n    scan: for(;;){\n        if ((groupMask & data[state]) == 0) break;\n        let accEnd = data[state + 1];\n        // Check whether this state can lead to a token in the current group\n        // Accept tokens in this state, possibly overwriting\n        // lower-precedence / shorter tokens\n        for(let i = state + 3; i < accEnd; i += 2)if ((data[i + 1] & groupMask) > 0) {\n            let term = data[i];\n            if (dialect.allows(term) && (input.token.value == -1 || input.token.value == term || overrides(term, input.token.value, precTable, precOffset))) {\n                input.acceptToken(term);\n                break;\n            }\n        }\n        let next = input.next, low = 0, high = data[state + 2];\n        // Special case for EOF\n        if (input.next < 0 && high > low && data[accEnd + high * 3 - 3] == 65535 /* Seq.End */ ) {\n            state = data[accEnd + high * 3 - 1];\n            continue scan;\n        }\n        // Do a binary search on the state's edges\n        for(; low < high;){\n            let mid = low + high >> 1;\n            let index = accEnd + mid + (mid << 1);\n            let from = data[index], to = data[index + 1] || 0x10000;\n            if (next < from) high = mid;\n            else if (next >= to) low = mid + 1;\n            else {\n                state = data[index + 2];\n                input.advance();\n                continue scan;\n            }\n        }\n        break;\n    }\n}\nfunction findOffset(data, start, term) {\n    for(let i = start, next; (next = data[i]) != 65535 /* Seq.End */ ; i++)if (next == term) return i - start;\n    return -1;\n}\nfunction overrides(token, prev, tableData, tableOffset) {\n    let iPrev = findOffset(tableData, tableOffset, prev);\n    return iPrev < 0 || findOffset(tableData, tableOffset, token) < iPrev;\n}\n// Environment variable used to control console output\nconst verbose = typeof process != \"undefined\" && process.env && /\\bparse\\b/.test(process.env.LOG);\nlet stackIDs = null;\nfunction cutAt(tree, pos, side) {\n    let cursor = tree.cursor(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.IterMode.IncludeAnonymous);\n    cursor.moveTo(pos);\n    for(;;){\n        if (!(side < 0 ? cursor.childBefore(pos) : cursor.childAfter(pos))) for(;;){\n            if ((side < 0 ? cursor.to < pos : cursor.from > pos) && !cursor.type.isError) return side < 0 ? Math.max(0, Math.min(cursor.to - 1, pos - 25 /* Safety.Margin */ )) : Math.min(tree.length, Math.max(cursor.from + 1, pos + 25 /* Safety.Margin */ ));\n            if (side < 0 ? cursor.prevSibling() : cursor.nextSibling()) break;\n            if (!cursor.parent()) return side < 0 ? 0 : tree.length;\n        }\n    }\n}\nclass FragmentCursor {\n    constructor(fragments, nodeSet){\n        this.fragments = fragments;\n        this.nodeSet = nodeSet;\n        this.i = 0;\n        this.fragment = null;\n        this.safeFrom = -1;\n        this.safeTo = -1;\n        this.trees = [];\n        this.start = [];\n        this.index = [];\n        this.nextFragment();\n    }\n    nextFragment() {\n        let fr = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];\n        if (fr) {\n            this.safeFrom = fr.openStart ? cutAt(fr.tree, fr.from + fr.offset, 1) - fr.offset : fr.from;\n            this.safeTo = fr.openEnd ? cutAt(fr.tree, fr.to + fr.offset, -1) - fr.offset : fr.to;\n            while(this.trees.length){\n                this.trees.pop();\n                this.start.pop();\n                this.index.pop();\n            }\n            this.trees.push(fr.tree);\n            this.start.push(-fr.offset);\n            this.index.push(0);\n            this.nextStart = this.safeFrom;\n        } else {\n            this.nextStart = 1e9;\n        }\n    }\n    // `pos` must be >= any previously given `pos` for this cursor\n    nodeAt(pos) {\n        if (pos < this.nextStart) return null;\n        while(this.fragment && this.safeTo <= pos)this.nextFragment();\n        if (!this.fragment) return null;\n        for(;;){\n            let last = this.trees.length - 1;\n            if (last < 0) {\n                this.nextFragment();\n                return null;\n            }\n            let top = this.trees[last], index = this.index[last];\n            if (index == top.children.length) {\n                this.trees.pop();\n                this.start.pop();\n                this.index.pop();\n                continue;\n            }\n            let next = top.children[index];\n            let start = this.start[last] + top.positions[index];\n            if (start > pos) {\n                this.nextStart = start;\n                return null;\n            }\n            if (next instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree) {\n                if (start == pos) {\n                    if (start < this.safeFrom) return null;\n                    let end = start + next.length;\n                    if (end <= this.safeTo) {\n                        let lookAhead = next.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.lookAhead);\n                        if (!lookAhead || end + lookAhead < this.fragment.to) return next;\n                    }\n                }\n                this.index[last]++;\n                if (start + next.length >= Math.max(this.safeFrom, pos)) {\n                    this.trees.push(next);\n                    this.start.push(start);\n                    this.index.push(0);\n                }\n            } else {\n                this.index[last]++;\n                this.nextStart = start + next.length;\n            }\n        }\n    }\n}\nclass TokenCache {\n    constructor(parser, stream){\n        this.stream = stream;\n        this.tokens = [];\n        this.mainToken = null;\n        this.actions = [];\n        this.tokens = parser.tokenizers.map((_)=>new CachedToken);\n    }\n    getActions(stack) {\n        let actionIndex = 0;\n        let main = null;\n        let { parser } = stack.p, { tokenizers } = parser;\n        let mask = parser.stateSlot(stack.state, 3 /* ParseState.TokenizerMask */ );\n        let context = stack.curContext ? stack.curContext.hash : 0;\n        let lookAhead = 0;\n        for(let i = 0; i < tokenizers.length; i++){\n            if ((1 << i & mask) == 0) continue;\n            let tokenizer = tokenizers[i], token = this.tokens[i];\n            if (main && !tokenizer.fallback) continue;\n            if (tokenizer.contextual || token.start != stack.pos || token.mask != mask || token.context != context) {\n                this.updateCachedToken(token, tokenizer, stack);\n                token.mask = mask;\n                token.context = context;\n            }\n            if (token.lookAhead > token.end + 25 /* Safety.Margin */ ) lookAhead = Math.max(token.lookAhead, lookAhead);\n            if (token.value != 0 /* Term.Err */ ) {\n                let startIndex = actionIndex;\n                if (token.extended > -1) actionIndex = this.addActions(stack, token.extended, token.end, actionIndex);\n                actionIndex = this.addActions(stack, token.value, token.end, actionIndex);\n                if (!tokenizer.extend) {\n                    main = token;\n                    if (actionIndex > startIndex) break;\n                }\n            }\n        }\n        while(this.actions.length > actionIndex)this.actions.pop();\n        if (lookAhead) stack.setLookAhead(lookAhead);\n        if (!main && stack.pos == this.stream.end) {\n            main = new CachedToken;\n            main.value = stack.p.parser.eofTerm;\n            main.start = main.end = stack.pos;\n            actionIndex = this.addActions(stack, main.value, main.end, actionIndex);\n        }\n        this.mainToken = main;\n        return this.actions;\n    }\n    getMainToken(stack) {\n        if (this.mainToken) return this.mainToken;\n        let main = new CachedToken, { pos, p } = stack;\n        main.start = pos;\n        main.end = Math.min(pos + 1, p.stream.end);\n        main.value = pos == p.stream.end ? p.parser.eofTerm : 0 /* Term.Err */ ;\n        return main;\n    }\n    updateCachedToken(token, tokenizer, stack) {\n        let start = this.stream.clipPos(stack.pos);\n        tokenizer.token(this.stream.reset(start, token), stack);\n        if (token.value > -1) {\n            let { parser } = stack.p;\n            for(let i = 0; i < parser.specialized.length; i++)if (parser.specialized[i] == token.value) {\n                let result = parser.specializers[i](this.stream.read(token.start, token.end), stack);\n                if (result >= 0 && stack.p.parser.dialect.allows(result >> 1)) {\n                    if ((result & 1) == 0 /* Specialize.Specialize */ ) token.value = result >> 1;\n                    else token.extended = result >> 1;\n                    break;\n                }\n            }\n        } else {\n            token.value = 0 /* Term.Err */ ;\n            token.end = this.stream.clipPos(start + 1);\n        }\n    }\n    putAction(action, token, end, index) {\n        // Don't add duplicate actions\n        for(let i = 0; i < index; i += 3)if (this.actions[i] == action) return index;\n        this.actions[index++] = action;\n        this.actions[index++] = token;\n        this.actions[index++] = end;\n        return index;\n    }\n    addActions(stack, token, end, index) {\n        let { state } = stack, { parser } = stack.p, { data } = parser;\n        for(let set = 0; set < 2; set++){\n            for(let i = parser.stateSlot(state, set ? 2 /* ParseState.Skip */  : 1 /* ParseState.Actions */ );; i += 3){\n                if (data[i] == 65535 /* Seq.End */ ) {\n                    if (data[i + 1] == 1 /* Seq.Next */ ) {\n                        i = pair(data, i + 2);\n                    } else {\n                        if (index == 0 && data[i + 1] == 2 /* Seq.Other */ ) index = this.putAction(pair(data, i + 2), token, end, index);\n                        break;\n                    }\n                }\n                if (data[i] == token) index = this.putAction(pair(data, i + 1), token, end, index);\n            }\n        }\n        return index;\n    }\n}\nclass Parse {\n    constructor(parser, input, fragments, ranges){\n        this.parser = parser;\n        this.input = input;\n        this.ranges = ranges;\n        this.recovering = 0;\n        this.nextStackID = 0x2654; // ♔, ♕, ♖, ♗, ♘, ♙, ♠, ♡, ♢, ♣, ♤, ♥, ♦, ♧\n        this.minStackPos = 0;\n        this.reused = [];\n        this.stoppedAt = null;\n        this.lastBigReductionStart = -1;\n        this.lastBigReductionSize = 0;\n        this.bigReductionCount = 0;\n        this.stream = new InputStream(input, ranges);\n        this.tokens = new TokenCache(parser, this.stream);\n        this.topTerm = parser.top[1];\n        let { from } = ranges[0];\n        this.stacks = [\n            Stack.start(this, parser.top[0], from)\n        ];\n        this.fragments = fragments.length && this.stream.end - from > parser.bufferLength * 4 ? new FragmentCursor(fragments, parser.nodeSet) : null;\n    }\n    get parsedPos() {\n        return this.minStackPos;\n    }\n    // Move the parser forward. This will process all parse stacks at\n    // `this.pos` and try to advance them to a further position. If no\n    // stack for such a position is found, it'll start error-recovery.\n    //\n    // When the parse is finished, this will return a syntax tree. When\n    // not, it returns `null`.\n    advance() {\n        let stacks = this.stacks, pos = this.minStackPos;\n        // This will hold stacks beyond `pos`.\n        let newStacks = this.stacks = [];\n        let stopped, stoppedTokens;\n        // If a large amount of reductions happened with the same start\n        // position, force the stack out of that production in order to\n        // avoid creating a tree too deep to recurse through.\n        // (This is an ugly kludge, because unfortunately there is no\n        // straightforward, cheap way to check for this happening, due to\n        // the history of reductions only being available in an\n        // expensive-to-access format in the stack buffers.)\n        if (this.bigReductionCount > 300 /* Rec.MaxLeftAssociativeReductionCount */  && stacks.length == 1) {\n            let [s] = stacks;\n            while(s.forceReduce() && s.stack.length && s.stack[s.stack.length - 2] >= this.lastBigReductionStart){}\n            this.bigReductionCount = this.lastBigReductionSize = 0;\n        }\n        // Keep advancing any stacks at `pos` until they either move\n        // forward or can't be advanced. Gather stacks that can't be\n        // advanced further in `stopped`.\n        for(let i = 0; i < stacks.length; i++){\n            let stack = stacks[i];\n            for(;;){\n                this.tokens.mainToken = null;\n                if (stack.pos > pos) {\n                    newStacks.push(stack);\n                } else if (this.advanceStack(stack, newStacks, stacks)) {\n                    continue;\n                } else {\n                    if (!stopped) {\n                        stopped = [];\n                        stoppedTokens = [];\n                    }\n                    stopped.push(stack);\n                    let tok = this.tokens.getMainToken(stack);\n                    stoppedTokens.push(tok.value, tok.end);\n                }\n                break;\n            }\n        }\n        if (!newStacks.length) {\n            let finished = stopped && findFinished(stopped);\n            if (finished) {\n                if (verbose) console.log(\"Finish with \" + this.stackID(finished));\n                return this.stackToTree(finished);\n            }\n            if (this.parser.strict) {\n                if (verbose && stopped) console.log(\"Stuck with token \" + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : \"none\"));\n                throw new SyntaxError(\"No parse at \" + pos);\n            }\n            if (!this.recovering) this.recovering = 5 /* Rec.Distance */ ;\n        }\n        if (this.recovering && stopped) {\n            let finished = this.stoppedAt != null && stopped[0].pos > this.stoppedAt ? stopped[0] : this.runRecovery(stopped, stoppedTokens, newStacks);\n            if (finished) {\n                if (verbose) console.log(\"Force-finish \" + this.stackID(finished));\n                return this.stackToTree(finished.forceAll());\n            }\n        }\n        if (this.recovering) {\n            let maxRemaining = this.recovering == 1 ? 1 : this.recovering * 3 /* Rec.MaxRemainingPerStep */ ;\n            if (newStacks.length > maxRemaining) {\n                newStacks.sort((a, b)=>b.score - a.score);\n                while(newStacks.length > maxRemaining)newStacks.pop();\n            }\n            if (newStacks.some((s)=>s.reducePos > pos)) this.recovering--;\n        } else if (newStacks.length > 1) {\n            // Prune stacks that are in the same state, or that have been\n            // running without splitting for a while, to avoid getting stuck\n            // with multiple successful stacks running endlessly on.\n            outer: for(let i = 0; i < newStacks.length - 1; i++){\n                let stack = newStacks[i];\n                for(let j = i + 1; j < newStacks.length; j++){\n                    let other = newStacks[j];\n                    if (stack.sameState(other) || stack.buffer.length > 500 /* Rec.MinBufferLengthPrune */  && other.buffer.length > 500 /* Rec.MinBufferLengthPrune */ ) {\n                        if ((stack.score - other.score || stack.buffer.length - other.buffer.length) > 0) {\n                            newStacks.splice(j--, 1);\n                        } else {\n                            newStacks.splice(i--, 1);\n                            continue outer;\n                        }\n                    }\n                }\n            }\n            if (newStacks.length > 12 /* Rec.MaxStackCount */ ) newStacks.splice(12 /* Rec.MaxStackCount */ , newStacks.length - 12 /* Rec.MaxStackCount */ );\n        }\n        this.minStackPos = newStacks[0].pos;\n        for(let i = 1; i < newStacks.length; i++)if (newStacks[i].pos < this.minStackPos) this.minStackPos = newStacks[i].pos;\n        return null;\n    }\n    stopAt(pos) {\n        if (this.stoppedAt != null && this.stoppedAt < pos) throw new RangeError(\"Can't move stoppedAt forward\");\n        this.stoppedAt = pos;\n    }\n    // Returns an updated version of the given stack, or null if the\n    // stack can't advance normally. When `split` and `stacks` are\n    // given, stacks split off by ambiguous operations will be pushed to\n    // `split`, or added to `stacks` if they move `pos` forward.\n    advanceStack(stack, stacks, split) {\n        let start = stack.pos, { parser } = this;\n        let base = verbose ? this.stackID(stack) + \" -> \" : \"\";\n        if (this.stoppedAt != null && start > this.stoppedAt) return stack.forceReduce() ? stack : null;\n        if (this.fragments) {\n            let strictCx = stack.curContext && stack.curContext.tracker.strict, cxHash = strictCx ? stack.curContext.hash : 0;\n            for(let cached = this.fragments.nodeAt(start); cached;){\n                let match = this.parser.nodeSet.types[cached.type.id] == cached.type ? parser.getGoto(stack.state, cached.type.id) : -1;\n                if (match > -1 && cached.length && (!strictCx || (cached.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.contextHash) || 0) == cxHash)) {\n                    stack.useNode(cached, match);\n                    if (verbose) console.log(base + this.stackID(stack) + ` (via reuse of ${parser.getName(cached.type.id)})`);\n                    return true;\n                }\n                if (!(cached instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree) || cached.children.length == 0 || cached.positions[0] > 0) break;\n                let inner = cached.children[0];\n                if (inner instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree && cached.positions[0] == 0) cached = inner;\n                else break;\n            }\n        }\n        let defaultReduce = parser.stateSlot(stack.state, 4 /* ParseState.DefaultReduce */ );\n        if (defaultReduce > 0) {\n            stack.reduce(defaultReduce);\n            if (verbose) console.log(base + this.stackID(stack) + ` (via always-reduce ${parser.getName(defaultReduce & 65535 /* Action.ValueMask */ )})`);\n            return true;\n        }\n        if (stack.stack.length >= 8400 /* Rec.CutDepth */ ) {\n            while(stack.stack.length > 6000 /* Rec.CutTo */  && stack.forceReduce()){}\n        }\n        let actions = this.tokens.getActions(stack);\n        for(let i = 0; i < actions.length;){\n            let action = actions[i++], term = actions[i++], end = actions[i++];\n            let last = i == actions.length || !split;\n            let localStack = last ? stack : stack.split();\n            let main = this.tokens.mainToken;\n            localStack.apply(action, term, main ? main.start : localStack.pos, end);\n            if (verbose) console.log(base + this.stackID(localStack) + ` (via ${(action & 65536 /* Action.ReduceFlag */ ) == 0 ? \"shift\" : `reduce of ${parser.getName(action & 65535 /* Action.ValueMask */ )}`} for ${parser.getName(term)} @ ${start}${localStack == stack ? \"\" : \", split\"})`);\n            if (last) return true;\n            else if (localStack.pos > start) stacks.push(localStack);\n            else split.push(localStack);\n        }\n        return false;\n    }\n    // Advance a given stack forward as far as it will go. Returns the\n    // (possibly updated) stack if it got stuck, or null if it moved\n    // forward and was given to `pushStackDedup`.\n    advanceFully(stack, newStacks) {\n        let pos = stack.pos;\n        for(;;){\n            if (!this.advanceStack(stack, null, null)) return false;\n            if (stack.pos > pos) {\n                pushStackDedup(stack, newStacks);\n                return true;\n            }\n        }\n    }\n    runRecovery(stacks, tokens, newStacks) {\n        let finished = null, restarted = false;\n        for(let i = 0; i < stacks.length; i++){\n            let stack = stacks[i], token = tokens[i << 1], tokenEnd = tokens[(i << 1) + 1];\n            let base = verbose ? this.stackID(stack) + \" -> \" : \"\";\n            if (stack.deadEnd) {\n                if (restarted) continue;\n                restarted = true;\n                stack.restart();\n                if (verbose) console.log(base + this.stackID(stack) + \" (restarted)\");\n                let done = this.advanceFully(stack, newStacks);\n                if (done) continue;\n            }\n            let force = stack.split(), forceBase = base;\n            for(let j = 0; force.forceReduce() && j < 10 /* Rec.ForceReduceLimit */ ; j++){\n                if (verbose) console.log(forceBase + this.stackID(force) + \" (via force-reduce)\");\n                let done = this.advanceFully(force, newStacks);\n                if (done) break;\n                if (verbose) forceBase = this.stackID(force) + \" -> \";\n            }\n            for (let insert of stack.recoverByInsert(token)){\n                if (verbose) console.log(base + this.stackID(insert) + \" (via recover-insert)\");\n                this.advanceFully(insert, newStacks);\n            }\n            if (this.stream.end > stack.pos) {\n                if (tokenEnd == stack.pos) {\n                    tokenEnd++;\n                    token = 0 /* Term.Err */ ;\n                }\n                stack.recoverByDelete(token, tokenEnd);\n                if (verbose) console.log(base + this.stackID(stack) + ` (via recover-delete ${this.parser.getName(token)})`);\n                pushStackDedup(stack, newStacks);\n            } else if (!finished || finished.score < stack.score) {\n                finished = stack;\n            }\n        }\n        return finished;\n    }\n    // Convert the stack's buffer to a syntax tree.\n    stackToTree(stack) {\n        stack.close();\n        return _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.build({\n            buffer: StackBufferCursor.create(stack),\n            nodeSet: this.parser.nodeSet,\n            topID: this.topTerm,\n            maxBufferLength: this.parser.bufferLength,\n            reused: this.reused,\n            start: this.ranges[0].from,\n            length: stack.pos - this.ranges[0].from,\n            minRepeatType: this.parser.minRepeatTerm\n        });\n    }\n    stackID(stack) {\n        let id = (stackIDs || (stackIDs = new WeakMap)).get(stack);\n        if (!id) stackIDs.set(stack, id = String.fromCodePoint(this.nextStackID++));\n        return id + stack;\n    }\n}\nfunction pushStackDedup(stack, newStacks) {\n    for(let i = 0; i < newStacks.length; i++){\n        let other = newStacks[i];\n        if (other.pos == stack.pos && other.sameState(stack)) {\n            if (newStacks[i].score < stack.score) newStacks[i] = stack;\n            return;\n        }\n    }\n    newStacks.push(stack);\n}\nclass Dialect {\n    constructor(source, flags, disabled){\n        this.source = source;\n        this.flags = flags;\n        this.disabled = disabled;\n    }\n    allows(term) {\n        return !this.disabled || this.disabled[term] == 0;\n    }\n}\nconst id = (x)=>x;\n/**\nContext trackers are used to track stateful context (such as\nindentation in the Python grammar, or parent elements in the XML\ngrammar) needed by external tokenizers. You declare them in a\ngrammar file as `@context exportName from \"module\"`.\n\nContext values should be immutable, and can be updated (replaced)\non shift or reduce actions.\n\nThe export used in a `@context` declaration should be of this\ntype.\n*/ class ContextTracker {\n    /**\n    Define a context tracker.\n    */ constructor(spec){\n        this.start = spec.start;\n        this.shift = spec.shift || id;\n        this.reduce = spec.reduce || id;\n        this.reuse = spec.reuse || id;\n        this.hash = spec.hash || (()=>0);\n        this.strict = spec.strict !== false;\n    }\n}\n/**\nHolds the parse tables for a given grammar, as generated by\n`lezer-generator`, and provides [methods](#common.Parser) to parse\ncontent with.\n*/ class LRParser extends _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Parser {\n    /**\n    @internal\n    */ constructor(spec){\n        super();\n        /**\n        @internal\n        */ this.wrappers = [];\n        if (spec.version != 14 /* File.Version */ ) throw new RangeError(`Parser version (${spec.version}) doesn't match runtime version (${14 /* File.Version */ })`);\n        let nodeNames = spec.nodeNames.split(\" \");\n        this.minRepeatTerm = nodeNames.length;\n        for(let i = 0; i < spec.repeatNodeCount; i++)nodeNames.push(\"\");\n        let topTerms = Object.keys(spec.topRules).map((r)=>spec.topRules[r][1]);\n        let nodeProps = [];\n        for(let i = 0; i < nodeNames.length; i++)nodeProps.push([]);\n        function setProp(nodeID, prop, value) {\n            nodeProps[nodeID].push([\n                prop,\n                prop.deserialize(String(value))\n            ]);\n        }\n        if (spec.nodeProps) for (let propSpec of spec.nodeProps){\n            let prop = propSpec[0];\n            if (typeof prop == \"string\") prop = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp[prop];\n            for(let i = 1; i < propSpec.length;){\n                let next = propSpec[i++];\n                if (next >= 0) {\n                    setProp(next, prop, propSpec[i++]);\n                } else {\n                    let value = propSpec[i + -next];\n                    for(let j = -next; j > 0; j--)setProp(propSpec[i++], prop, value);\n                    i++;\n                }\n            }\n        }\n        this.nodeSet = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeSet(nodeNames.map((name, i)=>_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeType.define({\n                name: i >= this.minRepeatTerm ? undefined : name,\n                id: i,\n                props: nodeProps[i],\n                top: topTerms.indexOf(i) > -1,\n                error: i == 0,\n                skipped: spec.skippedNodes && spec.skippedNodes.indexOf(i) > -1\n            })));\n        if (spec.propSources) this.nodeSet = this.nodeSet.extend(...spec.propSources);\n        this.strict = false;\n        this.bufferLength = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.DefaultBufferLength;\n        let tokenArray = decodeArray(spec.tokenData);\n        this.context = spec.context;\n        this.specializerSpecs = spec.specialized || [];\n        this.specialized = new Uint16Array(this.specializerSpecs.length);\n        for(let i = 0; i < this.specializerSpecs.length; i++)this.specialized[i] = this.specializerSpecs[i].term;\n        this.specializers = this.specializerSpecs.map(getSpecializer);\n        this.states = decodeArray(spec.states, Uint32Array);\n        this.data = decodeArray(spec.stateData);\n        this.goto = decodeArray(spec.goto);\n        this.maxTerm = spec.maxTerm;\n        this.tokenizers = spec.tokenizers.map((value)=>typeof value == \"number\" ? new TokenGroup(tokenArray, value) : value);\n        this.topRules = spec.topRules;\n        this.dialects = spec.dialects || {};\n        this.dynamicPrecedences = spec.dynamicPrecedences || null;\n        this.tokenPrecTable = spec.tokenPrec;\n        this.termNames = spec.termNames || null;\n        this.maxNode = this.nodeSet.types.length - 1;\n        this.dialect = this.parseDialect();\n        this.top = this.topRules[Object.keys(this.topRules)[0]];\n    }\n    createParse(input, fragments, ranges) {\n        let parse = new Parse(this, input, fragments, ranges);\n        for (let w of this.wrappers)parse = w(parse, input, fragments, ranges);\n        return parse;\n    }\n    /**\n    Get a goto table entry @internal\n    */ getGoto(state, term, loose = false) {\n        let table = this.goto;\n        if (term >= table[0]) return -1;\n        for(let pos = table[term + 1];;){\n            let groupTag = table[pos++], last = groupTag & 1;\n            let target = table[pos++];\n            if (last && loose) return target;\n            for(let end = pos + (groupTag >> 1); pos < end; pos++)if (table[pos] == state) return target;\n            if (last) return -1;\n        }\n    }\n    /**\n    Check if this state has an action for a given terminal @internal\n    */ hasAction(state, terminal) {\n        let data = this.data;\n        for(let set = 0; set < 2; set++){\n            for(let i = this.stateSlot(state, set ? 2 /* ParseState.Skip */  : 1 /* ParseState.Actions */ ), next;; i += 3){\n                if ((next = data[i]) == 65535 /* Seq.End */ ) {\n                    if (data[i + 1] == 1 /* Seq.Next */ ) next = data[i = pair(data, i + 2)];\n                    else if (data[i + 1] == 2 /* Seq.Other */ ) return pair(data, i + 2);\n                    else break;\n                }\n                if (next == terminal || next == 0 /* Term.Err */ ) return pair(data, i + 1);\n            }\n        }\n        return 0;\n    }\n    /**\n    @internal\n    */ stateSlot(state, slot) {\n        return this.states[state * 6 /* ParseState.Size */  + slot];\n    }\n    /**\n    @internal\n    */ stateFlag(state, flag) {\n        return (this.stateSlot(state, 0 /* ParseState.Flags */ ) & flag) > 0;\n    }\n    /**\n    @internal\n    */ validAction(state, action) {\n        return !!this.allActions(state, (a)=>a == action ? true : null);\n    }\n    /**\n    @internal\n    */ allActions(state, action) {\n        let deflt = this.stateSlot(state, 4 /* ParseState.DefaultReduce */ );\n        let result = deflt ? action(deflt) : undefined;\n        for(let i = this.stateSlot(state, 1 /* ParseState.Actions */ ); result == null; i += 3){\n            if (this.data[i] == 65535 /* Seq.End */ ) {\n                if (this.data[i + 1] == 1 /* Seq.Next */ ) i = pair(this.data, i + 2);\n                else break;\n            }\n            result = action(pair(this.data, i + 1));\n        }\n        return result;\n    }\n    /**\n    Get the states that can follow this one through shift actions or\n    goto jumps. @internal\n    */ nextStates(state) {\n        let result = [];\n        for(let i = this.stateSlot(state, 1 /* ParseState.Actions */ );; i += 3){\n            if (this.data[i] == 65535 /* Seq.End */ ) {\n                if (this.data[i + 1] == 1 /* Seq.Next */ ) i = pair(this.data, i + 2);\n                else break;\n            }\n            if ((this.data[i + 2] & 65536 /* Action.ReduceFlag */  >> 16) == 0) {\n                let value = this.data[i + 1];\n                if (!result.some((v, i)=>i & 1 && v == value)) result.push(this.data[i], value);\n            }\n        }\n        return result;\n    }\n    /**\n    Configure the parser. Returns a new parser instance that has the\n    given settings modified. Settings not provided in `config` are\n    kept from the original parser.\n    */ configure(config) {\n        // Hideous reflection-based kludge to make it easy to create a\n        // slightly modified copy of a parser.\n        let copy = Object.assign(Object.create(LRParser.prototype), this);\n        if (config.props) copy.nodeSet = this.nodeSet.extend(...config.props);\n        if (config.top) {\n            let info = this.topRules[config.top];\n            if (!info) throw new RangeError(`Invalid top rule name ${config.top}`);\n            copy.top = info;\n        }\n        if (config.tokenizers) copy.tokenizers = this.tokenizers.map((t)=>{\n            let found = config.tokenizers.find((r)=>r.from == t);\n            return found ? found.to : t;\n        });\n        if (config.specializers) {\n            copy.specializers = this.specializers.slice();\n            copy.specializerSpecs = this.specializerSpecs.map((s, i)=>{\n                let found = config.specializers.find((r)=>r.from == s.external);\n                if (!found) return s;\n                let spec = Object.assign(Object.assign({}, s), {\n                    external: found.to\n                });\n                copy.specializers[i] = getSpecializer(spec);\n                return spec;\n            });\n        }\n        if (config.contextTracker) copy.context = config.contextTracker;\n        if (config.dialect) copy.dialect = this.parseDialect(config.dialect);\n        if (config.strict != null) copy.strict = config.strict;\n        if (config.wrap) copy.wrappers = copy.wrappers.concat(config.wrap);\n        if (config.bufferLength != null) copy.bufferLength = config.bufferLength;\n        return copy;\n    }\n    /**\n    Tells you whether any [parse wrappers](#lr.ParserConfig.wrap)\n    are registered for this parser.\n    */ hasWrappers() {\n        return this.wrappers.length > 0;\n    }\n    /**\n    Returns the name associated with a given term. This will only\n    work for all terms when the parser was generated with the\n    `--names` option. By default, only the names of tagged terms are\n    stored.\n    */ getName(term) {\n        return this.termNames ? this.termNames[term] : String(term <= this.maxNode && this.nodeSet.types[term].name || term);\n    }\n    /**\n    The eof term id is always allocated directly after the node\n    types. @internal\n    */ get eofTerm() {\n        return this.maxNode + 1;\n    }\n    /**\n    The type of top node produced by the parser.\n    */ get topNode() {\n        return this.nodeSet.types[this.top[1]];\n    }\n    /**\n    @internal\n    */ dynamicPrecedence(term) {\n        let prec = this.dynamicPrecedences;\n        return prec == null ? 0 : prec[term] || 0;\n    }\n    /**\n    @internal\n    */ parseDialect(dialect) {\n        let values = Object.keys(this.dialects), flags = values.map(()=>false);\n        if (dialect) for (let part of dialect.split(\" \")){\n            let id = values.indexOf(part);\n            if (id >= 0) flags[id] = true;\n        }\n        let disabled = null;\n        for(let i = 0; i < values.length; i++)if (!flags[i]) {\n            for(let j = this.dialects[values[i]], id; (id = this.data[j++]) != 65535 /* Seq.End */ ;)(disabled || (disabled = new Uint8Array(this.maxTerm + 1)))[id] = 1;\n        }\n        return new Dialect(dialect, flags, disabled);\n    }\n    /**\n    Used by the output of the parser generator. Not available to\n    user code. @hide\n    */ static deserialize(spec) {\n        return new LRParser(spec);\n    }\n}\nfunction pair(data, off) {\n    return data[off] | data[off + 1] << 16;\n}\nfunction findFinished(stacks) {\n    let best = null;\n    for (let stack of stacks){\n        let stopped = stack.p.stoppedAt;\n        if ((stack.pos == stack.p.stream.end || stopped != null && stack.pos > stopped) && stack.p.parser.stateFlag(stack.state, 2 /* StateFlag.Accepting */ ) && (!best || best.score < stack.score)) best = stack;\n    }\n    return best;\n}\nfunction getSpecializer(spec) {\n    if (spec.external) {\n        let mask = spec.extend ? 1 /* Specialize.Extend */  : 0 /* Specialize.Specialize */ ;\n        return (value, stack)=>spec.external(value, stack) << 1 | mask;\n    }\n    return spec.get;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxlemVyL2xyL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUF5RztBQUV6Rzs7Ozs7QUFLQSxHQUNBLE1BQU1PO0lBQ0Y7O0lBRUEsR0FDQUMsWUFDQTs7SUFFQSxHQUNBQyxDQUFDLEVBQ0Q7OztJQUdBLEdBQ0FDLEtBQUssRUFDTDs7SUFFQSxHQUNBQyxLQUFLLEVBQ0wsZ0VBQWdFO0lBQ2hFLGlFQUFpRTtJQUNqRSxnRUFBZ0U7SUFDaEUsYUFBYTtJQUNiOztJQUVBLEdBQ0FDLFNBQVMsRUFDVDs7SUFFQSxHQUNBQyxHQUFHLEVBQ0g7Ozs7SUFJQSxHQUNBQyxLQUFLLEVBQ0wsMERBQTBEO0lBQzFELDREQUE0RDtJQUM1RCx1REFBdUQ7SUFDdkQ7O0lBRUEsR0FDQUMsTUFBTSxFQUNOLGtFQUFrRTtJQUNsRSwyREFBMkQ7SUFDM0QsNERBQTREO0lBQzVELGlFQUFpRTtJQUNqRSxrQkFBa0I7SUFDbEI7O0lBRUEsR0FDQUMsVUFBVSxFQUNWOztJQUVBLEdBQ0FDLFVBQVUsRUFDVjs7SUFFQSxHQUNBQyxZQUFZLENBQUMsRUFDYixnRUFBZ0U7SUFDaEUsMkRBQTJEO0lBQzNELDREQUE0RDtJQUM1RCxnQkFBZ0I7SUFDaEI7O0lBRUEsR0FDQUMsTUFBTSxDQUFFO1FBQ0osSUFBSSxDQUFDVixDQUFDLEdBQUdBO1FBQ1QsSUFBSSxDQUFDQyxLQUFLLEdBQUdBO1FBQ2IsSUFBSSxDQUFDQyxLQUFLLEdBQUdBO1FBQ2IsSUFBSSxDQUFDQyxTQUFTLEdBQUdBO1FBQ2pCLElBQUksQ0FBQ0MsR0FBRyxHQUFHQTtRQUNYLElBQUksQ0FBQ0MsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQ0MsTUFBTSxHQUFHQTtRQUNkLElBQUksQ0FBQ0MsVUFBVSxHQUFHQTtRQUNsQixJQUFJLENBQUNDLFVBQVUsR0FBR0E7UUFDbEIsSUFBSSxDQUFDQyxTQUFTLEdBQUdBO1FBQ2pCLElBQUksQ0FBQ0MsTUFBTSxHQUFHQTtJ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bEY7SUFDZjtJQUNBLE9BQU9rRjtBQUNYO0FBQ0EsU0FBUzJQLGVBQWUxQixJQUFJO0lBQ3hCLElBQUlBLEtBQUtxRCxRQUFRLEVBQUU7UUFDZixJQUFJbk8sT0FBTzhLLEtBQUt2SSxNQUFNLEdBQUcsRUFBRSxxQkFBcUIsTUFBSyxFQUFFLHlCQUF5QjtRQUNoRixPQUFPLENBQUM3RyxPQUFPL0QsUUFBVSxLQUFNd1csUUFBUSxDQUFDelMsT0FBTy9ELFVBQVUsSUFBS3FJO0lBQ2xFO0lBQ0EsT0FBTzhLLEtBQUtSLEdBQUc7QUFDbkI7QUFFNEYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9weXRob24tb25saW5lLWVkaXRvci8uL25vZGVfbW9kdWxlcy9AbGV6ZXIvbHIvZGlzdC9pbmRleC5qcz9kZDBiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFBhcnNlciwgTm9kZVByb3AsIE5vZGVTZXQsIE5vZGVUeXBlLCBEZWZhdWx0QnVmZmVyTGVuZ3RoLCBUcmVlLCBJdGVyTW9kZSB9IGZyb20gJ0BsZXplci9jb21tb24nO1xuXG4vKipcbkEgcGFyc2Ugc3RhY2suIFRoZXNlIGFyZSB1c2VkIGludGVybmFsbHkgYnkgdGhlIHBhcnNlciB0byB0cmFja1xucGFyc2luZyBwcm9ncmVzcy4gVGhleSBhbHNvIHByb3ZpZGUgc29tZSBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzXG50aGF0IGV4dGVybmFsIGNvZGUgc3VjaCBhcyBhIHRva2VuaXplciBjYW4gdXNlIHRvIGdldCBpbmZvcm1hdGlvblxuYWJvdXQgdGhlIHBhcnNlIHN0YXRlLlxuKi9cbmNsYXNzIFN0YWNrIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBwYXJzZSB0aGF0IHRoaXMgc3RhY2sgaXMgcGFydCBvZiBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHAsIFxuICAgIC8qKlxuICAgIEhvbGRzIHN0YXRlLCBpbnB1dCBwb3MsIGJ1ZmZlciBpbmRleCB0cmlwbGV0cyBmb3IgYWxsIGJ1dCB0aGVcbiAgICB0b3Agc3RhdGUgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGFjaywgXG4gICAgLyoqXG4gICAgVGhlIGN1cnJlbnQgcGFyc2Ugc3RhdGUgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0ZSwgXG4gICAgLy8gVGhlIHBvc2l0aW9uIGF0IHdoaWNoIHRoZSBuZXh0IHJlZHVjZSBzaG91bGQgdGFrZSBwbGFjZS4gVGhpc1xuICAgIC8vIGNhbiBiZSBsZXNzIHRoYW4gYHRoaXMucG9zYCB3aGVuIHNraXBwZWQgZXhwcmVzc2lvbnMgaGF2ZSBiZWVuXG4gICAgLy8gYWRkZWQgdG8gdGhlIHN0YWNrICh3aGljaCBzaG91bGQgYmUgbW92ZWQgb3V0c2lkZSBvZiB0aGUgbmV4dFxuICAgIC8vIHJlZHVjdGlvbilcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHJlZHVjZVBvcywgXG4gICAgLyoqXG4gICAgVGhlIGlucHV0IHBvc2l0aW9uIHVwIHRvIHdoaWNoIHRoaXMgc3RhY2sgaGFzIHBhcnNlZC5cbiAgICAqL1xuICAgIHBvcywgXG4gICAgLyoqXG4gICAgVGhlIGR5bmFtaWMgc2NvcmUgb2YgdGhlIHN0YWNrLCBpbmNsdWRpbmcgZHluYW1pYyBwcmVjZWRlbmNlXG4gICAgYW5kIGVycm9yLXJlY292ZXJ5IHBlbmFsdGllc1xuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc2NvcmUsIFxuICAgIC8vIFRoZSBvdXRwdXQgYnVmZmVyLiBIb2xkcyAodHlwZSwgc3RhcnQsIGVuZCwgc2l6ZSkgcXVhZHNcbiAgICAvLyByZXByZXNlbnRpbmcgbm9kZXMgY3JlYXRlZCBieSB0aGUgcGFyc2VyLCB3aGVyZSBgc2l6ZWAgaXNcbiAgICAvLyBhbW91bnQgb2YgYnVmZmVyIGFycmF5IGVudHJpZXMgY292ZXJlZCBieSB0aGlzIG5vZGUuXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBidWZmZXIsIFxuICAgIC8vIFRoZSBiYXNlIG9mZnNldCBvZiB0aGUgYnVmZmVyLiBXaGVuIHN0YWNrcyBhcmUgc3BsaXQsIHRoZSBzcGxpdFxuICAgIC8vIGluc3RhbmNlIHNoYXJlZCB0aGUgYnVmZmVyIGhpc3Rvcnkgd2l0aCBpdHMgcGFyZW50IHVwIHRvXG4gICAgLy8gYGJ1ZmZlckJhc2VgLCB3aGljaCBpcyB0aGUgYWJzb2x1dGUgb2Zmc2V0IChpbmNsdWRpbmcgdGhlXG4gICAgLy8gb2Zmc2V0IG9mIHByZXZpb3VzIHNwbGl0cykgaW50byB0aGUgYnVmZmVyIGF0IHdoaWNoIHRoaXMgc3RhY2tcbiAgICAvLyBzdGFydHMgd3JpdGluZy5cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGJ1ZmZlckJhc2UsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY3VyQ29udGV4dCwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBsb29rQWhlYWQgPSAwLCBcbiAgICAvLyBBIHBhcmVudCBzdGFjayBmcm9tIHdoaWNoIHRoaXMgd2FzIHNwbGl0IG9mZiwgaWYgYW55LiBUaGlzIGlzXG4gICAgLy8gc2V0IHVwIHNvIHRoYXQgaXQgYWx3YXlzIHBvaW50cyB0byBhIHN0YWNrIHRoYXQgaGFzIHNvbWVcbiAgICAvLyBhZGRpdGlvbmFsIGJ1ZmZlciBjb250ZW50LCBuZXZlciB0byBhIHN0YWNrIHdpdGggYW4gZXF1YWxcbiAgICAvLyBgYnVmZmVyQmFzZWAuXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBwYXJlbnQpIHtcbiAgICAgICAgdGhpcy5wID0gcDtcbiAgICAgICAgdGhpcy5zdGFjayA9IHN0YWNrO1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIHRoaXMucmVkdWNlUG9zID0gcmVkdWNlUG9zO1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgdGhpcy5zY29yZSA9IHNjb3JlO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgICAgdGhpcy5idWZmZXJCYXNlID0gYnVmZmVyQmFzZTtcbiAgICAgICAgdGhpcy5jdXJDb250ZXh0ID0gY3VyQ29udGV4dDtcbiAgICAgICAgdGhpcy5sb29rQWhlYWQgPSBsb29rQWhlYWQ7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gYFske3RoaXMuc3RhY2suZmlsdGVyKChfLCBpKSA9PiBpICUgMyA9PSAwKS5jb25jYXQodGhpcy5zdGF0ZSl9XUAke3RoaXMucG9zfSR7dGhpcy5zY29yZSA/IFwiIVwiICsgdGhpcy5zY29yZSA6IFwiXCJ9YDtcbiAgICB9XG4gICAgLy8gU3RhcnQgYW4gZW1wdHkgc3RhY2tcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBzdGFydChwLCBzdGF0ZSwgcG9zID0gMCkge1xuICAgICAgICBsZXQgY3ggPSBwLnBhcnNlci5jb250ZXh0O1xuICAgICAgICByZXR1cm4gbmV3IFN0YWNrKHAsIFtdLCBzdGF0ZSwgcG9zLCBwb3MsIDAsIFtdLCAwLCBjeCA/IG5ldyBTdGFja0NvbnRleHQoY3gsIGN4LnN0YXJ0KSA6IG51bGwsIDAsIG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgc3RhY2sncyBjdXJyZW50IFtjb250ZXh0XSgjbHIuQ29udGV4dFRyYWNrZXIpIHZhbHVlLCBpZlxuICAgIGFueS4gSXRzIHR5cGUgd2lsbCBkZXBlbmQgb24gdGhlIGNvbnRleHQgdHJhY2tlcidzIHR5cGVcbiAgICBwYXJhbWV0ZXIsIG9yIGl0IHdpbGwgYmUgYG51bGxgIGlmIHRoZXJlIGlzIG5vIGNvbnRleHRcbiAgICB0cmFja2VyLlxuICAgICovXG4gICAgZ2V0IGNvbnRleHQoKSB7IHJldHVybiB0aGlzLmN1ckNvbnRleHQgPyB0aGlzLmN1ckNvbnRleHQuY29udGV4dCA6IG51bGw7IH1cbiAgICAvLyBQdXNoIGEgc3RhdGUgb250byB0aGUgc3RhY2ssIHRyYWNraW5nIGl0cyBzdGFydCBwb3NpdGlvbiBhcyB3ZWxsXG4gICAgLy8gYXMgdGhlIGJ1ZmZlciBiYXNlIGF0IHRoYXQgcG9pbnQuXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBwdXNoU3RhdGUoc3RhdGUsIHN0YXJ0KSB7XG4gICAgICAgIHRoaXMuc3RhY2sucHVzaCh0aGlzLnN0YXRlLCBzdGFydCwgdGhpcy5idWZmZXJCYXNlICsgdGhpcy5idWZmZXIubGVuZ3RoKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgIH1cbiAgICAvLyBBcHBseSBhIHJlZHVjZSBhY3Rpb25cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHJlZHVjZShhY3Rpb24pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgZGVwdGggPSBhY3Rpb24gPj4gMTkgLyogQWN0aW9uLlJlZHVjZURlcHRoU2hpZnQgKi8sIHR5cGUgPSBhY3Rpb24gJiA2NTUzNSAvKiBBY3Rpb24uVmFsdWVNYXNrICovO1xuICAgICAgICBsZXQgeyBwYXJzZXIgfSA9IHRoaXMucDtcbiAgICAgICAgbGV0IGRQcmVjID0gcGFyc2VyLmR5bmFtaWNQcmVjZWRlbmNlKHR5cGUpO1xuICAgICAgICBpZiAoZFByZWMpXG4gICAgICAgICAgICB0aGlzLnNjb3JlICs9IGRQcmVjO1xuICAgICAgICBpZiAoZGVwdGggPT0gMCkge1xuICAgICAgICAgICAgdGhpcy5wdXNoU3RhdGUocGFyc2VyLmdldEdvdG8odGhpcy5zdGF0ZSwgdHlwZSwgdHJ1ZSksIHRoaXMucmVkdWNlUG9zKTtcbiAgICAgICAgICAgIC8vIFplcm8tZGVwdGggcmVkdWN0aW9ucyBhcmUgYSBzcGVjaWFsIGNhc2XigJR0aGV5IGFkZCBzdHVmZiB0b1xuICAgICAgICAgICAgLy8gdGhlIHN0YWNrIHdpdGhvdXQgcG9wcGluZyBhbnl0aGluZyBvZmYuXG4gICAgICAgICAgICBpZiAodHlwZSA8IHBhcnNlci5taW5SZXBlYXRUZXJtKVxuICAgICAgICAgICAgICAgIHRoaXMuc3RvcmVOb2RlKHR5cGUsIHRoaXMucmVkdWNlUG9zLCB0aGlzLnJlZHVjZVBvcywgNCwgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLnJlZHVjZUNvbnRleHQodHlwZSwgdGhpcy5yZWR1Y2VQb3MpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZpbmQgdGhlIGJhc2UgaW5kZXggaW50byBgdGhpcy5zdGFja2AsIGNvbnRlbnQgYWZ0ZXIgd2hpY2ggd2lsbFxuICAgICAgICAvLyBiZSBkcm9wcGVkLiBOb3RlIHRoYXQgd2l0aCBgU3RheUZsYWdgIHJlZHVjdGlvbnMgd2UgbmVlZCB0b1xuICAgICAgICAvLyBjb25zdW1lIHR3byBleHRyYSBmcmFtZXMgKHRoZSBkdW1teSBwYXJlbnQgbm9kZSBmb3IgdGhlIHNraXBwZWRcbiAgICAgICAgLy8gZXhwcmVzc2lvbiBhbmQgdGhlIHN0YXRlIHRoYXQgd2UnbGwgYmUgc3RheWluZyBpbiwgd2hpY2ggc2hvdWxkXG4gICAgICAgIC8vIGJlIG1vdmVkIHRvIGB0aGlzLnN0YXRlYCkuXG4gICAgICAgIGxldCBiYXNlID0gdGhpcy5zdGFjay5sZW5ndGggLSAoKGRlcHRoIC0gMSkgKiAzKSAtIChhY3Rpb24gJiAyNjIxNDQgLyogQWN0aW9uLlN0YXlGbGFnICovID8gNiA6IDApO1xuICAgICAgICBsZXQgc3RhcnQgPSBiYXNlID8gdGhpcy5zdGFja1tiYXNlIC0gMl0gOiB0aGlzLnAucmFuZ2VzWzBdLmZyb20sIHNpemUgPSB0aGlzLnJlZHVjZVBvcyAtIHN0YXJ0O1xuICAgICAgICAvLyBUaGlzIGlzIGEga2x1ZGdlIHRvIHRyeSBhbmQgZGV0ZWN0IG92ZXJseSBkZWVwIGxlZnQtYXNzb2NpYXRpdmVcbiAgICAgICAgLy8gdHJlZXMsIHdoaWNoIHdpbGwgbm90IGluY3JlYXNlIHRoZSBwYXJzZSBzdGFjayBkZXB0aCBhbmQgdGh1c1xuICAgICAgICAvLyB3b24ndCBiZSBjYXVnaHQgYnkgdGhlIHJlZ3VsYXIgc3RhY2stZGVwdGggbGltaXQgY2hlY2suXG4gICAgICAgIGlmIChzaXplID49IDIwMDAgLyogUmVjb3Zlci5NaW5CaWdSZWR1Y3Rpb24gKi8gJiYgISgoX2EgPSB0aGlzLnAucGFyc2VyLm5vZGVTZXQudHlwZXNbdHlwZV0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pc0Fub255bW91cykpIHtcbiAgICAgICAgICAgIGlmIChzdGFydCA9PSB0aGlzLnAubGFzdEJpZ1JlZHVjdGlvblN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wLmJpZ1JlZHVjdGlvbkNvdW50Kys7XG4gICAgICAgICAgICAgICAgdGhpcy5wLmxhc3RCaWdSZWR1Y3Rpb25TaXplID0gc2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMucC5sYXN0QmlnUmVkdWN0aW9uU2l6ZSA8IHNpemUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnAuYmlnUmVkdWN0aW9uQ291bnQgPSAxO1xuICAgICAgICAgICAgICAgIHRoaXMucC5sYXN0QmlnUmVkdWN0aW9uU3RhcnQgPSBzdGFydDtcbiAgICAgICAgICAgICAgICB0aGlzLnAubGFzdEJpZ1JlZHVjdGlvblNpemUgPSBzaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBidWZmZXJCYXNlID0gYmFzZSA/IHRoaXMuc3RhY2tbYmFzZSAtIDFdIDogMCwgY291bnQgPSB0aGlzLmJ1ZmZlckJhc2UgKyB0aGlzLmJ1ZmZlci5sZW5ndGggLSBidWZmZXJCYXNlO1xuICAgICAgICAvLyBTdG9yZSBub3JtYWwgdGVybXMgb3IgYFIgLT4gUiBSYCByZXBlYXQgcmVkdWN0aW9uc1xuICAgICAgICBpZiAodHlwZSA8IHBhcnNlci5taW5SZXBlYXRUZXJtIHx8IChhY3Rpb24gJiAxMzEwNzIgLyogQWN0aW9uLlJlcGVhdEZsYWcgKi8pKSB7XG4gICAgICAgICAgICBsZXQgcG9zID0gcGFyc2VyLnN0YXRlRmxhZyh0aGlzLnN0YXRlLCAxIC8qIFN0YXRlRmxhZy5Ta2lwcGVkICovKSA/IHRoaXMucG9zIDogdGhpcy5yZWR1Y2VQb3M7XG4gICAgICAgICAgICB0aGlzLnN0b3JlTm9kZSh0eXBlLCBzdGFydCwgcG9zLCBjb3VudCArIDQsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhY3Rpb24gJiAyNjIxNDQgLyogQWN0aW9uLlN0YXlGbGFnICovKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gdGhpcy5zdGFja1tiYXNlXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBiYXNlU3RhdGVJRCA9IHRoaXMuc3RhY2tbYmFzZSAtIDNdO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHBhcnNlci5nZXRHb3RvKGJhc2VTdGF0ZUlELCB0eXBlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAodGhpcy5zdGFjay5sZW5ndGggPiBiYXNlKVxuICAgICAgICAgICAgdGhpcy5zdGFjay5wb3AoKTtcbiAgICAgICAgdGhpcy5yZWR1Y2VDb250ZXh0KHR5cGUsIHN0YXJ0KTtcbiAgICB9XG4gICAgLy8gU2hpZnQgYSB2YWx1ZSBpbnRvIHRoZSBidWZmZXJcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0b3JlTm9kZSh0ZXJtLCBzdGFydCwgZW5kLCBzaXplID0gNCwgaXNSZWR1Y2UgPSBmYWxzZSkge1xuICAgICAgICBpZiAodGVybSA9PSAwIC8qIFRlcm0uRXJyICovICYmXG4gICAgICAgICAgICAoIXRoaXMuc3RhY2subGVuZ3RoIHx8IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXSA8IHRoaXMuYnVmZmVyLmxlbmd0aCArIHRoaXMuYnVmZmVyQmFzZSkpIHtcbiAgICAgICAgICAgIC8vIFRyeSB0byBvbWl0L21lcmdlIGFkamFjZW50IGVycm9yIG5vZGVzXG4gICAgICAgICAgICBsZXQgY3VyID0gdGhpcywgdG9wID0gdGhpcy5idWZmZXIubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHRvcCA9PSAwICYmIGN1ci5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICB0b3AgPSBjdXIuYnVmZmVyQmFzZSAtIGN1ci5wYXJlbnQuYnVmZmVyQmFzZTtcbiAgICAgICAgICAgICAgICBjdXIgPSBjdXIucGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRvcCA+IDAgJiYgY3VyLmJ1ZmZlclt0b3AgLSA0XSA9PSAwIC8qIFRlcm0uRXJyICovICYmIGN1ci5idWZmZXJbdG9wIC0gMV0gPiAtMSkge1xuICAgICAgICAgICAgICAgIGlmIChzdGFydCA9PSBlbmQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAoY3VyLmJ1ZmZlclt0b3AgLSAyXSA+PSBzdGFydCkge1xuICAgICAgICAgICAgICAgICAgICBjdXIuYnVmZmVyW3RvcCAtIDJdID0gZW5kO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghaXNSZWR1Y2UgfHwgdGhpcy5wb3MgPT0gZW5kKSB7IC8vIFNpbXBsZSBjYXNlLCBqdXN0IGFwcGVuZFxuICAgICAgICAgICAgdGhpcy5idWZmZXIucHVzaCh0ZXJtLCBzdGFydCwgZW5kLCBzaXplKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gVGhlcmUgbWF5IGJlIHNraXBwZWQgbm9kZXMgdGhhdCBoYXZlIHRvIGJlIG1vdmVkIGZvcndhcmRcbiAgICAgICAgICAgIGxldCBpbmRleCA9IHRoaXMuYnVmZmVyLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChpbmRleCA+IDAgJiYgdGhpcy5idWZmZXJbaW5kZXggLSA0XSAhPSAwIC8qIFRlcm0uRXJyICovKVxuICAgICAgICAgICAgICAgIHdoaWxlIChpbmRleCA+IDAgJiYgdGhpcy5idWZmZXJbaW5kZXggLSAyXSA+IGVuZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBNb3ZlIHRoaXMgcmVjb3JkIGZvcndhcmRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWZmZXJbaW5kZXhdID0gdGhpcy5idWZmZXJbaW5kZXggLSA0XTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWZmZXJbaW5kZXggKyAxXSA9IHRoaXMuYnVmZmVyW2luZGV4IC0gM107XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyW2luZGV4ICsgMl0gPSB0aGlzLmJ1ZmZlcltpbmRleCAtIDJdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlcltpbmRleCArIDNdID0gdGhpcy5idWZmZXJbaW5kZXggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggLT0gNDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpemUgPiA0KVxuICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZSAtPSA0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYnVmZmVyW2luZGV4XSA9IHRlcm07XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlcltpbmRleCArIDFdID0gc3RhcnQ7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlcltpbmRleCArIDJdID0gZW5kO1xuICAgICAgICAgICAgdGhpcy5idWZmZXJbaW5kZXggKyAzXSA9IHNpemU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQXBwbHkgYSBzaGlmdCBhY3Rpb25cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHNoaWZ0KGFjdGlvbiwgdHlwZSwgc3RhcnQsIGVuZCkge1xuICAgICAgICBpZiAoYWN0aW9uICYgMTMxMDcyIC8qIEFjdGlvbi5Hb3RvRmxhZyAqLykge1xuICAgICAgICAgICAgdGhpcy5wdXNoU3RhdGUoYWN0aW9uICYgNjU1MzUgLyogQWN0aW9uLlZhbHVlTWFzayAqLywgdGhpcy5wb3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChhY3Rpb24gJiAyNjIxNDQgLyogQWN0aW9uLlN0YXlGbGFnICovKSA9PSAwKSB7IC8vIFJlZ3VsYXIgc2hpZnRcbiAgICAgICAgICAgIGxldCBuZXh0U3RhdGUgPSBhY3Rpb24sIHsgcGFyc2VyIH0gPSB0aGlzLnA7XG4gICAgICAgICAgICBpZiAoZW5kID4gdGhpcy5wb3MgfHwgdHlwZSA8PSBwYXJzZXIubWF4Tm9kZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucG9zID0gZW5kO1xuICAgICAgICAgICAgICAgIGlmICghcGFyc2VyLnN0YXRlRmxhZyhuZXh0U3RhdGUsIDEgLyogU3RhdGVGbGFnLlNraXBwZWQgKi8pKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZHVjZVBvcyA9IGVuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucHVzaFN0YXRlKG5leHRTdGF0ZSwgc3RhcnQpO1xuICAgICAgICAgICAgdGhpcy5zaGlmdENvbnRleHQodHlwZSwgc3RhcnQpO1xuICAgICAgICAgICAgaWYgKHR5cGUgPD0gcGFyc2VyLm1heE5vZGUpXG4gICAgICAgICAgICAgICAgdGhpcy5idWZmZXIucHVzaCh0eXBlLCBzdGFydCwgZW5kLCA0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gU2hpZnQtYW5kLXN0YXksIHdoaWNoIG1lYW5zIHRoaXMgaXMgYSBza2lwcGVkIHRva2VuXG4gICAgICAgICAgICB0aGlzLnBvcyA9IGVuZDtcbiAgICAgICAgICAgIHRoaXMuc2hpZnRDb250ZXh0KHR5cGUsIHN0YXJ0KTtcbiAgICAgICAgICAgIGlmICh0eXBlIDw9IHRoaXMucC5wYXJzZXIubWF4Tm9kZSlcbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKHR5cGUsIHN0YXJ0LCBlbmQsIDQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEFwcGx5IGFuIGFjdGlvblxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgYXBwbHkoYWN0aW9uLCBuZXh0LCBuZXh0U3RhcnQsIG5leHRFbmQpIHtcbiAgICAgICAgaWYgKGFjdGlvbiAmIDY1NTM2IC8qIEFjdGlvbi5SZWR1Y2VGbGFnICovKVxuICAgICAgICAgICAgdGhpcy5yZWR1Y2UoYWN0aW9uKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5zaGlmdChhY3Rpb24sIG5leHQsIG5leHRTdGFydCwgbmV4dEVuZCk7XG4gICAgfVxuICAgIC8vIEFkZCBhIHByZWJ1aWx0IChyZXVzZWQpIG5vZGUgaW50byB0aGUgYnVmZmVyLlxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdXNlTm9kZSh2YWx1ZSwgbmV4dCkge1xuICAgICAgICBsZXQgaW5kZXggPSB0aGlzLnAucmV1c2VkLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChpbmRleCA8IDAgfHwgdGhpcy5wLnJldXNlZFtpbmRleF0gIT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMucC5yZXVzZWQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdGFydCA9IHRoaXMucG9zO1xuICAgICAgICB0aGlzLnJlZHVjZVBvcyA9IHRoaXMucG9zID0gc3RhcnQgKyB2YWx1ZS5sZW5ndGg7XG4gICAgICAgIHRoaXMucHVzaFN0YXRlKG5leHQsIHN0YXJ0KTtcbiAgICAgICAgdGhpcy5idWZmZXIucHVzaChpbmRleCwgc3RhcnQsIHRoaXMucmVkdWNlUG9zLCAtMSAvKiBzaXplID09IC0xIG1lYW5zIHRoaXMgaXMgYSByZXVzZWQgdmFsdWUgKi8pO1xuICAgICAgICBpZiAodGhpcy5jdXJDb250ZXh0KVxuICAgICAgICAgICAgdGhpcy51cGRhdGVDb250ZXh0KHRoaXMuY3VyQ29udGV4dC50cmFja2VyLnJldXNlKHRoaXMuY3VyQ29udGV4dC5jb250ZXh0LCB2YWx1ZSwgdGhpcywgdGhpcy5wLnN0cmVhbS5yZXNldCh0aGlzLnBvcyAtIHZhbHVlLmxlbmd0aCkpKTtcbiAgICB9XG4gICAgLy8gU3BsaXQgdGhlIHN0YWNrLiBEdWUgdG8gdGhlIGJ1ZmZlciBzaGFyaW5nIGFuZCB0aGUgZmFjdFxuICAgIC8vIHRoYXQgYHRoaXMuc3RhY2tgIHRlbmRzIHRvIHN0YXkgcXVpdGUgc2hhbGxvdywgdGhpcyBpc24ndCB2ZXJ5XG4gICAgLy8gZXhwZW5zaXZlLlxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3BsaXQoKSB7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0aGlzO1xuICAgICAgICBsZXQgb2ZmID0gcGFyZW50LmJ1ZmZlci5sZW5ndGg7XG4gICAgICAgIC8vIEJlY2F1c2UgdGhlIHRvcCBvZiB0aGUgYnVmZmVyIChhZnRlciB0aGlzLnBvcykgbWF5IGJlIG11dGF0ZWRcbiAgICAgICAgLy8gdG8gcmVvcmRlciByZWR1Y3Rpb25zIGFuZCBza2lwcGVkIHRva2VucywgYW5kIHNoYXJlZCBidWZmZXJzXG4gICAgICAgIC8vIHNob3VsZCBiZSBpbW11dGFibGUsIHRoaXMgY29waWVzIGFueSBvdXRzdGFuZGluZyBza2lwcGVkIHRva2Vuc1xuICAgICAgICAvLyB0byB0aGUgbmV3IGJ1ZmZlciwgYW5kIHB1dHMgdGhlIGJhc2UgcG9pbnRlciBiZWZvcmUgdGhlbS5cbiAgICAgICAgd2hpbGUgKG9mZiA+IDAgJiYgcGFyZW50LmJ1ZmZlcltvZmYgLSAyXSA+IHBhcmVudC5yZWR1Y2VQb3MpXG4gICAgICAgICAgICBvZmYgLT0gNDtcbiAgICAgICAgbGV0IGJ1ZmZlciA9IHBhcmVudC5idWZmZXIuc2xpY2Uob2ZmKSwgYmFzZSA9IHBhcmVudC5idWZmZXJCYXNlICsgb2ZmO1xuICAgICAgICAvLyBNYWtlIHN1cmUgcGFyZW50IHBvaW50cyB0byBhbiBhY3R1YWwgcGFyZW50IHdpdGggY29udGVudCwgaWYgdGhlcmUgaXMgc3VjaCBhIHBhcmVudC5cbiAgICAgICAgd2hpbGUgKHBhcmVudCAmJiBiYXNlID09IHBhcmVudC5idWZmZXJCYXNlKVxuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICAgICAgcmV0dXJuIG5ldyBTdGFjayh0aGlzLnAsIHRoaXMuc3RhY2suc2xpY2UoKSwgdGhpcy5zdGF0ZSwgdGhpcy5yZWR1Y2VQb3MsIHRoaXMucG9zLCB0aGlzLnNjb3JlLCBidWZmZXIsIGJhc2UsIHRoaXMuY3VyQ29udGV4dCwgdGhpcy5sb29rQWhlYWQsIHBhcmVudCk7XG4gICAgfVxuICAgIC8vIFRyeSB0byByZWNvdmVyIGZyb20gYW4gZXJyb3IgYnkgJ2RlbGV0aW5nJyAoaWdub3JpbmcpIG9uZSB0b2tlbi5cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHJlY292ZXJCeURlbGV0ZShuZXh0LCBuZXh0RW5kKSB7XG4gICAgICAgIGxldCBpc05vZGUgPSBuZXh0IDw9IHRoaXMucC5wYXJzZXIubWF4Tm9kZTtcbiAgICAgICAgaWYgKGlzTm9kZSlcbiAgICAgICAgICAgIHRoaXMuc3RvcmVOb2RlKG5leHQsIHRoaXMucG9zLCBuZXh0RW5kLCA0KTtcbiAgICAgICAgdGhpcy5zdG9yZU5vZGUoMCAvKiBUZXJtLkVyciAqLywgdGhpcy5wb3MsIG5leHRFbmQsIGlzTm9kZSA/IDggOiA0KTtcbiAgICAgICAgdGhpcy5wb3MgPSB0aGlzLnJlZHVjZVBvcyA9IG5leHRFbmQ7XG4gICAgICAgIHRoaXMuc2NvcmUgLT0gMTkwIC8qIFJlY292ZXIuRGVsZXRlICovO1xuICAgIH1cbiAgICAvKipcbiAgICBDaGVjayBpZiB0aGUgZ2l2ZW4gdGVybSB3b3VsZCBiZSBhYmxlIHRvIGJlIHNoaWZ0ZWQgKG9wdGlvbmFsbHlcbiAgICBhZnRlciBzb21lIHJlZHVjdGlvbnMpIG9uIHRoaXMgc3RhY2suIFRoaXMgY2FuIGJlIHVzZWZ1bCBmb3JcbiAgICBleHRlcm5hbCB0b2tlbml6ZXJzIHRoYXQgd2FudCB0byBtYWtlIHN1cmUgdGhleSBvbmx5IHByb3ZpZGUgYVxuICAgIGdpdmVuIHRva2VuIHdoZW4gaXQgYXBwbGllcy5cbiAgICAqL1xuICAgIGNhblNoaWZ0KHRlcm0pIHtcbiAgICAgICAgZm9yIChsZXQgc2ltID0gbmV3IFNpbXVsYXRlZFN0YWNrKHRoaXMpOzspIHtcbiAgICAgICAgICAgIGxldCBhY3Rpb24gPSB0aGlzLnAucGFyc2VyLnN0YXRlU2xvdChzaW0uc3RhdGUsIDQgLyogUGFyc2VTdGF0ZS5EZWZhdWx0UmVkdWNlICovKSB8fCB0aGlzLnAucGFyc2VyLmhhc0FjdGlvbihzaW0uc3RhdGUsIHRlcm0pO1xuICAgICAgICAgICAgaWYgKGFjdGlvbiA9PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmICgoYWN0aW9uICYgNjU1MzYgLyogQWN0aW9uLlJlZHVjZUZsYWcgKi8pID09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBzaW0ucmVkdWNlKGFjdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQXBwbHkgdXAgdG8gUmVjb3Zlci5NYXhOZXh0IHJlY292ZXJ5IGFjdGlvbnMgdGhhdCBjb25jZXB0dWFsbHlcbiAgICAvLyBpbnNlcnRzIHNvbWUgbWlzc2luZyB0b2tlbiBvciBydWxlLlxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgcmVjb3ZlckJ5SW5zZXJ0KG5leHQpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoID49IDMwMCAvKiBSZWNvdmVyLk1heEluc2VydFN0YWNrRGVwdGggKi8pXG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIGxldCBuZXh0U3RhdGVzID0gdGhpcy5wLnBhcnNlci5uZXh0U3RhdGVzKHRoaXMuc3RhdGUpO1xuICAgICAgICBpZiAobmV4dFN0YXRlcy5sZW5ndGggPiA0IC8qIFJlY292ZXIuTWF4TmV4dCAqLyA8PCAxIHx8IHRoaXMuc3RhY2subGVuZ3RoID49IDEyMCAvKiBSZWNvdmVyLkRhbXBlbkluc2VydFN0YWNrRGVwdGggKi8pIHtcbiAgICAgICAgICAgIGxldCBiZXN0ID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgczsgaSA8IG5leHRTdGF0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICBpZiAoKHMgPSBuZXh0U3RhdGVzW2kgKyAxXSkgIT0gdGhpcy5zdGF0ZSAmJiB0aGlzLnAucGFyc2VyLmhhc0FjdGlvbihzLCBuZXh0KSlcbiAgICAgICAgICAgICAgICAgICAgYmVzdC5wdXNoKG5leHRTdGF0ZXNbaV0sIHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoIDwgMTIwIC8qIFJlY292ZXIuRGFtcGVuSW5zZXJ0U3RhY2tEZXB0aCAqLylcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgYmVzdC5sZW5ndGggPCA0IC8qIFJlY292ZXIuTWF4TmV4dCAqLyA8PCAxICYmIGkgPCBuZXh0U3RhdGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzID0gbmV4dFN0YXRlc1tpICsgMV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghYmVzdC5zb21lKCh2LCBpKSA9PiAoaSAmIDEpICYmIHYgPT0gcykpXG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0LnB1c2gobmV4dFN0YXRlc1tpXSwgcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV4dFN0YXRlcyA9IGJlc3Q7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5leHRTdGF0ZXMubGVuZ3RoICYmIHJlc3VsdC5sZW5ndGggPCA0IC8qIFJlY292ZXIuTWF4TmV4dCAqLzsgaSArPSAyKSB7XG4gICAgICAgICAgICBsZXQgcyA9IG5leHRTdGF0ZXNbaSArIDFdO1xuICAgICAgICAgICAgaWYgKHMgPT0gdGhpcy5zdGF0ZSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGxldCBzdGFjayA9IHRoaXMuc3BsaXQoKTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2hTdGF0ZShzLCB0aGlzLnBvcyk7XG4gICAgICAgICAgICBzdGFjay5zdG9yZU5vZGUoMCAvKiBUZXJtLkVyciAqLywgc3RhY2sucG9zLCBzdGFjay5wb3MsIDQsIHRydWUpO1xuICAgICAgICAgICAgc3RhY2suc2hpZnRDb250ZXh0KG5leHRTdGF0ZXNbaV0sIHRoaXMucG9zKTtcbiAgICAgICAgICAgIHN0YWNrLnJlZHVjZVBvcyA9IHRoaXMucG9zO1xuICAgICAgICAgICAgc3RhY2suc2NvcmUgLT0gMjAwIC8qIFJlY292ZXIuSW5zZXJ0ICovO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goc3RhY2spO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vIEZvcmNlIGEgcmVkdWNlLCBpZiBwb3NzaWJsZS4gUmV0dXJuIGZhbHNlIGlmIHRoYXQgY2FuJ3RcbiAgICAvLyBiZSBkb25lLlxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZm9yY2VSZWR1Y2UoKSB7XG4gICAgICAgIGxldCB7IHBhcnNlciB9ID0gdGhpcy5wO1xuICAgICAgICBsZXQgcmVkdWNlID0gcGFyc2VyLnN0YXRlU2xvdCh0aGlzLnN0YXRlLCA1IC8qIFBhcnNlU3RhdGUuRm9yY2VkUmVkdWNlICovKTtcbiAgICAgICAgaWYgKChyZWR1Y2UgJiA2NTUzNiAvKiBBY3Rpb24uUmVkdWNlRmxhZyAqLykgPT0gMClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKCFwYXJzZXIudmFsaWRBY3Rpb24odGhpcy5zdGF0ZSwgcmVkdWNlKSkge1xuICAgICAgICAgICAgbGV0IGRlcHRoID0gcmVkdWNlID4+IDE5IC8qIEFjdGlvbi5SZWR1Y2VEZXB0aFNoaWZ0ICovLCB0ZXJtID0gcmVkdWNlICYgNjU1MzUgLyogQWN0aW9uLlZhbHVlTWFzayAqLztcbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSB0aGlzLnN0YWNrLmxlbmd0aCAtIGRlcHRoICogMztcbiAgICAgICAgICAgIGlmICh0YXJnZXQgPCAwIHx8IHBhcnNlci5nZXRHb3RvKHRoaXMuc3RhY2tbdGFyZ2V0XSwgdGVybSwgZmFsc2UpIDwgMCkge1xuICAgICAgICAgICAgICAgIGxldCBiYWNrdXAgPSB0aGlzLmZpbmRGb3JjZWRSZWR1Y3Rpb24oKTtcbiAgICAgICAgICAgICAgICBpZiAoYmFja3VwID09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICByZWR1Y2UgPSBiYWNrdXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnN0b3JlTm9kZSgwIC8qIFRlcm0uRXJyICovLCB0aGlzLnBvcywgdGhpcy5wb3MsIDQsIHRydWUpO1xuICAgICAgICAgICAgdGhpcy5zY29yZSAtPSAxMDAgLyogUmVjb3Zlci5SZWR1Y2UgKi87XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZWR1Y2VQb3MgPSB0aGlzLnBvcztcbiAgICAgICAgdGhpcy5yZWR1Y2UocmVkdWNlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgIFRyeSB0byBzY2FuIHRocm91Z2ggdGhlIGF1dG9tYXRvbiB0byBmaW5kIHNvbWUga2luZCBvZiByZWR1Y3Rpb25cbiAgICB0aGF0IGNhbiBiZSBhcHBsaWVkLiBVc2VkIHdoZW4gdGhlIHJlZ3VsYXIgRm9yY2VkUmVkdWNlIGZpZWxkXG4gICAgaXNuJ3QgYSB2YWxpZCBhY3Rpb24uIEBpbnRlcm5hbFxuICAgICovXG4gICAgZmluZEZvcmNlZFJlZHVjdGlvbigpIHtcbiAgICAgICAgbGV0IHsgcGFyc2VyIH0gPSB0aGlzLnAsIHNlZW4gPSBbXTtcbiAgICAgICAgbGV0IGV4cGxvcmUgPSAoc3RhdGUsIGRlcHRoKSA9PiB7XG4gICAgICAgICAgICBpZiAoc2Vlbi5pbmNsdWRlcyhzdGF0ZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgc2Vlbi5wdXNoKHN0YXRlKTtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZXIuYWxsQWN0aW9ucyhzdGF0ZSwgKGFjdGlvbikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChhY3Rpb24gJiAoMjYyMTQ0IC8qIEFjdGlvbi5TdGF5RmxhZyAqLyB8IDEzMTA3MiAvKiBBY3Rpb24uR290b0ZsYWcgKi8pKSA7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYWN0aW9uICYgNjU1MzYgLyogQWN0aW9uLlJlZHVjZUZsYWcgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJEZXB0aCA9IChhY3Rpb24gPj4gMTkgLyogQWN0aW9uLlJlZHVjZURlcHRoU2hpZnQgKi8pIC0gZGVwdGg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyRGVwdGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdGVybSA9IGFjdGlvbiAmIDY1NTM1IC8qIEFjdGlvbi5WYWx1ZU1hc2sgKi8sIHRhcmdldCA9IHRoaXMuc3RhY2subGVuZ3RoIC0gckRlcHRoICogMztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXQgPj0gMCAmJiBwYXJzZXIuZ2V0R290byh0aGlzLnN0YWNrW3RhcmdldF0sIHRlcm0sIGZhbHNlKSA+PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAockRlcHRoIDw8IDE5IC8qIEFjdGlvbi5SZWR1Y2VEZXB0aFNoaWZ0ICovKSB8IDY1NTM2IC8qIEFjdGlvbi5SZWR1Y2VGbGFnICovIHwgdGVybTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZvdW5kID0gZXhwbG9yZShhY3Rpb24sIGRlcHRoICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmb3VuZCAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZXhwbG9yZSh0aGlzLnN0YXRlLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBmb3JjZUFsbCgpIHtcbiAgICAgICAgd2hpbGUgKCF0aGlzLnAucGFyc2VyLnN0YXRlRmxhZyh0aGlzLnN0YXRlLCAyIC8qIFN0YXRlRmxhZy5BY2NlcHRpbmcgKi8pKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZm9yY2VSZWR1Y2UoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RvcmVOb2RlKDAgLyogVGVybS5FcnIgKi8sIHRoaXMucG9zLCB0aGlzLnBvcywgNCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIENoZWNrIHdoZXRoZXIgdGhpcyBzdGF0ZSBoYXMgbm8gZnVydGhlciBhY3Rpb25zIChhc3N1bWVkIHRvIGJlIGEgZGlyZWN0IGRlc2NlbmRhbnQgb2YgdGhlXG4gICAgdG9wIHN0YXRlLCBzaW5jZSBhbnkgb3RoZXIgc3RhdGVzIG11c3QgYmUgYWJsZSB0byBjb250aW51ZVxuICAgIHNvbWVob3cpLiBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGdldCBkZWFkRW5kKCkge1xuICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGggIT0gMylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IHsgcGFyc2VyIH0gPSB0aGlzLnA7XG4gICAgICAgIHJldHVybiBwYXJzZXIuZGF0YVtwYXJzZXIuc3RhdGVTbG90KHRoaXMuc3RhdGUsIDEgLyogUGFyc2VTdGF0ZS5BY3Rpb25zICovKV0gPT0gNjU1MzUgLyogU2VxLkVuZCAqLyAmJlxuICAgICAgICAgICAgIXBhcnNlci5zdGF0ZVNsb3QodGhpcy5zdGF0ZSwgNCAvKiBQYXJzZVN0YXRlLkRlZmF1bHRSZWR1Y2UgKi8pO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXN0YXJ0IHRoZSBzdGFjayAocHV0IGl0IGJhY2sgaW4gaXRzIHN0YXJ0IHN0YXRlKS4gT25seSBzYWZlXG4gICAgd2hlbiB0aGlzLnN0YWNrLmxlbmd0aCA9PSAzIChzdGF0ZSBpcyBkaXJlY3RseSBiZWxvdyB0aGUgdG9wXG4gICAgc3RhdGUpLiBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHJlc3RhcnQoKSB7XG4gICAgICAgIHRoaXMuc3RvcmVOb2RlKDAgLyogVGVybS5FcnIgKi8sIHRoaXMucG9zLCB0aGlzLnBvcywgNCwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLnN0YWNrWzBdO1xuICAgICAgICB0aGlzLnN0YWNrLmxlbmd0aCA9IDA7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc2FtZVN0YXRlKG90aGVyKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlICE9IG90aGVyLnN0YXRlIHx8IHRoaXMuc3RhY2subGVuZ3RoICE9IG90aGVyLnN0YWNrLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN0YWNrLmxlbmd0aDsgaSArPSAzKVxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhY2tbaV0gIT0gb3RoZXIuc3RhY2tbaV0pXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBwYXJzZXIgdXNlZCBieSB0aGlzIHN0YWNrLlxuICAgICovXG4gICAgZ2V0IHBhcnNlcigpIHsgcmV0dXJuIHRoaXMucC5wYXJzZXI7IH1cbiAgICAvKipcbiAgICBUZXN0IHdoZXRoZXIgYSBnaXZlbiBkaWFsZWN0IChieSBudW1lcmljIElELCBhcyBleHBvcnRlZCBmcm9tXG4gICAgdGhlIHRlcm1zIGZpbGUpIGlzIGVuYWJsZWQuXG4gICAgKi9cbiAgICBkaWFsZWN0RW5hYmxlZChkaWFsZWN0SUQpIHsgcmV0dXJuIHRoaXMucC5wYXJzZXIuZGlhbGVjdC5mbGFnc1tkaWFsZWN0SURdOyB9XG4gICAgc2hpZnRDb250ZXh0KHRlcm0sIHN0YXJ0KSB7XG4gICAgICAgIGlmICh0aGlzLmN1ckNvbnRleHQpXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUNvbnRleHQodGhpcy5jdXJDb250ZXh0LnRyYWNrZXIuc2hpZnQodGhpcy5jdXJDb250ZXh0LmNvbnRleHQsIHRlcm0sIHRoaXMsIHRoaXMucC5zdHJlYW0ucmVzZXQoc3RhcnQpKSk7XG4gICAgfVxuICAgIHJlZHVjZUNvbnRleHQodGVybSwgc3RhcnQpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VyQ29udGV4dClcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQ29udGV4dCh0aGlzLmN1ckNvbnRleHQudHJhY2tlci5yZWR1Y2UodGhpcy5jdXJDb250ZXh0LmNvbnRleHQsIHRlcm0sIHRoaXMsIHRoaXMucC5zdHJlYW0ucmVzZXQoc3RhcnQpKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZW1pdENvbnRleHQoKSB7XG4gICAgICAgIGxldCBsYXN0ID0gdGhpcy5idWZmZXIubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKGxhc3QgPCAwIHx8IHRoaXMuYnVmZmVyW2xhc3RdICE9IC0zKVxuICAgICAgICAgICAgdGhpcy5idWZmZXIucHVzaCh0aGlzLmN1ckNvbnRleHQuaGFzaCwgdGhpcy5wb3MsIHRoaXMucG9zLCAtMyk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZW1pdExvb2tBaGVhZCgpIHtcbiAgICAgICAgbGV0IGxhc3QgPSB0aGlzLmJ1ZmZlci5sZW5ndGggLSAxO1xuICAgICAgICBpZiAobGFzdCA8IDAgfHwgdGhpcy5idWZmZXJbbGFzdF0gIT0gLTQpXG4gICAgICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKHRoaXMubG9va0FoZWFkLCB0aGlzLnBvcywgdGhpcy5wb3MsIC00KTtcbiAgICB9XG4gICAgdXBkYXRlQ29udGV4dChjb250ZXh0KSB7XG4gICAgICAgIGlmIChjb250ZXh0ICE9IHRoaXMuY3VyQ29udGV4dC5jb250ZXh0KSB7XG4gICAgICAgICAgICBsZXQgbmV3Q3ggPSBuZXcgU3RhY2tDb250ZXh0KHRoaXMuY3VyQ29udGV4dC50cmFja2VyLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGlmIChuZXdDeC5oYXNoICE9IHRoaXMuY3VyQ29udGV4dC5oYXNoKVxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdENvbnRleHQoKTtcbiAgICAgICAgICAgIHRoaXMuY3VyQ29udGV4dCA9IG5ld0N4O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc2V0TG9va0FoZWFkKGxvb2tBaGVhZCkge1xuICAgICAgICBpZiAobG9va0FoZWFkID4gdGhpcy5sb29rQWhlYWQpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdExvb2tBaGVhZCgpO1xuICAgICAgICAgICAgdGhpcy5sb29rQWhlYWQgPSBsb29rQWhlYWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VyQ29udGV4dCAmJiB0aGlzLmN1ckNvbnRleHQudHJhY2tlci5zdHJpY3QpXG4gICAgICAgICAgICB0aGlzLmVtaXRDb250ZXh0KCk7XG4gICAgICAgIGlmICh0aGlzLmxvb2tBaGVhZCA+IDApXG4gICAgICAgICAgICB0aGlzLmVtaXRMb29rQWhlYWQoKTtcbiAgICB9XG59XG5jbGFzcyBTdGFja0NvbnRleHQge1xuICAgIGNvbnN0cnVjdG9yKHRyYWNrZXIsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy50cmFja2VyID0gdHJhY2tlcjtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5oYXNoID0gdHJhY2tlci5zdHJpY3QgPyB0cmFja2VyLmhhc2goY29udGV4dCkgOiAwO1xuICAgIH1cbn1cbi8vIFVzZWQgdG8gY2hlYXBseSBydW4gc29tZSByZWR1Y3Rpb25zIHRvIHNjYW4gYWhlYWQgd2l0aG91dCBtdXRhdGluZ1xuLy8gYW4gZW50aXJlIHN0YWNrXG5jbGFzcyBTaW11bGF0ZWRTdGFjayB7XG4gICAgY29uc3RydWN0b3Ioc3RhcnQpIHtcbiAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhcnQuc3RhdGU7XG4gICAgICAgIHRoaXMuc3RhY2sgPSBzdGFydC5zdGFjaztcbiAgICAgICAgdGhpcy5iYXNlID0gdGhpcy5zdGFjay5sZW5ndGg7XG4gICAgfVxuICAgIHJlZHVjZShhY3Rpb24pIHtcbiAgICAgICAgbGV0IHRlcm0gPSBhY3Rpb24gJiA2NTUzNSAvKiBBY3Rpb24uVmFsdWVNYXNrICovLCBkZXB0aCA9IGFjdGlvbiA+PiAxOSAvKiBBY3Rpb24uUmVkdWNlRGVwdGhTaGlmdCAqLztcbiAgICAgICAgaWYgKGRlcHRoID09IDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YWNrID09IHRoaXMuc3RhcnQuc3RhY2spXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFjayA9IHRoaXMuc3RhY2suc2xpY2UoKTtcbiAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaCh0aGlzLnN0YXRlLCAwLCAwKTtcbiAgICAgICAgICAgIHRoaXMuYmFzZSArPSAzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5iYXNlIC09IChkZXB0aCAtIDEpICogMztcbiAgICAgICAgfVxuICAgICAgICBsZXQgZ290byA9IHRoaXMuc3RhcnQucC5wYXJzZXIuZ2V0R290byh0aGlzLnN0YWNrW3RoaXMuYmFzZSAtIDNdLCB0ZXJtLCB0cnVlKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IGdvdG87XG4gICAgfVxufVxuLy8gVGhpcyBpcyBnaXZlbiB0byBgVHJlZS5idWlsZGAgdG8gYnVpbGQgYSBidWZmZXIsIGFuZCBlbmNhcHN1bGF0ZXNcbi8vIHRoZSBwYXJlbnQtc3RhY2std2Fsa2luZyBuZWNlc3NhcnkgdG8gcmVhZCB0aGUgbm9kZXMuXG5jbGFzcyBTdGFja0J1ZmZlckN1cnNvciB7XG4gICAgY29uc3RydWN0b3Ioc3RhY2ssIHBvcywgaW5kZXgpIHtcbiAgICAgICAgdGhpcy5zdGFjayA9IHN0YWNrO1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IHN0YWNrLmJ1ZmZlcjtcbiAgICAgICAgaWYgKHRoaXMuaW5kZXggPT0gMClcbiAgICAgICAgICAgIHRoaXMubWF5YmVOZXh0KCk7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGUoc3RhY2ssIHBvcyA9IHN0YWNrLmJ1ZmZlckJhc2UgKyBzdGFjay5idWZmZXIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RhY2tCdWZmZXJDdXJzb3Ioc3RhY2ssIHBvcywgcG9zIC0gc3RhY2suYnVmZmVyQmFzZSk7XG4gICAgfVxuICAgIG1heWJlTmV4dCgpIHtcbiAgICAgICAgbGV0IG5leHQgPSB0aGlzLnN0YWNrLnBhcmVudDtcbiAgICAgICAgaWYgKG5leHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5pbmRleCA9IHRoaXMuc3RhY2suYnVmZmVyQmFzZSAtIG5leHQuYnVmZmVyQmFzZTtcbiAgICAgICAgICAgIHRoaXMuc3RhY2sgPSBuZXh0O1xuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBuZXh0LmJ1ZmZlcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgaWQoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gNF07IH1cbiAgICBnZXQgc3RhcnQoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gM107IH1cbiAgICBnZXQgZW5kKCkgeyByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCAtIDJdOyB9XG4gICAgZ2V0IHNpemUoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gMV07IH1cbiAgICBuZXh0KCkge1xuICAgICAgICB0aGlzLmluZGV4IC09IDQ7XG4gICAgICAgIHRoaXMucG9zIC09IDQ7XG4gICAgICAgIGlmICh0aGlzLmluZGV4ID09IDApXG4gICAgICAgICAgICB0aGlzLm1heWJlTmV4dCgpO1xuICAgIH1cbiAgICBmb3JrKCkge1xuICAgICAgICByZXR1cm4gbmV3IFN0YWNrQnVmZmVyQ3Vyc29yKHRoaXMuc3RhY2ssIHRoaXMucG9zLCB0aGlzLmluZGV4KTtcbiAgICB9XG59XG5cbi8vIFNlZSBsZXplci1nZW5lcmF0b3Ivc3JjL2VuY29kZS50cyBmb3IgY29tbWVudHMgYWJvdXQgdGhlIGVuY29kaW5nXG4vLyB1c2VkIGhlcmVcbmZ1bmN0aW9uIGRlY29kZUFycmF5KGlucHV0LCBUeXBlID0gVWludDE2QXJyYXkpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ICE9IFwic3RyaW5nXCIpXG4gICAgICAgIHJldHVybiBpbnB1dDtcbiAgICBsZXQgYXJyYXkgPSBudWxsO1xuICAgIGZvciAobGV0IHBvcyA9IDAsIG91dCA9IDA7IHBvcyA8IGlucHV0Lmxlbmd0aDspIHtcbiAgICAgICAgbGV0IHZhbHVlID0gMDtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IG5leHQgPSBpbnB1dC5jaGFyQ29kZUF0KHBvcysrKSwgc3RvcCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKG5leHQgPT0gMTI2IC8qIEVuY29kZS5CaWdWYWxDb2RlICovKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSA2NTUzNSAvKiBFbmNvZGUuQmlnVmFsICovO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5leHQgPj0gOTIgLyogRW5jb2RlLkdhcDIgKi8pXG4gICAgICAgICAgICAgICAgbmV4dC0tO1xuICAgICAgICAgICAgaWYgKG5leHQgPj0gMzQgLyogRW5jb2RlLkdhcDEgKi8pXG4gICAgICAgICAgICAgICAgbmV4dC0tO1xuICAgICAgICAgICAgbGV0IGRpZ2l0ID0gbmV4dCAtIDMyIC8qIEVuY29kZS5TdGFydCAqLztcbiAgICAgICAgICAgIGlmIChkaWdpdCA+PSA0NiAvKiBFbmNvZGUuQmFzZSAqLykge1xuICAgICAgICAgICAgICAgIGRpZ2l0IC09IDQ2IC8qIEVuY29kZS5CYXNlICovO1xuICAgICAgICAgICAgICAgIHN0b3AgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWUgKz0gZGlnaXQ7XG4gICAgICAgICAgICBpZiAoc3RvcClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHZhbHVlICo9IDQ2IC8qIEVuY29kZS5CYXNlICovO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcnJheSlcbiAgICAgICAgICAgIGFycmF5W291dCsrXSA9IHZhbHVlO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBhcnJheSA9IG5ldyBUeXBlKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufVxuXG5jbGFzcyBDYWNoZWRUb2tlbiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuc3RhcnQgPSAtMTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IC0xO1xuICAgICAgICB0aGlzLmVuZCA9IC0xO1xuICAgICAgICB0aGlzLmV4dGVuZGVkID0gLTE7XG4gICAgICAgIHRoaXMubG9va0FoZWFkID0gMDtcbiAgICAgICAgdGhpcy5tYXNrID0gMDtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gMDtcbiAgICB9XG59XG5jb25zdCBudWxsVG9rZW4gPSBuZXcgQ2FjaGVkVG9rZW47XG4vKipcbltUb2tlbml6ZXJzXSgjbHIuRXh0ZXJuYWxUb2tlbml6ZXIpIGludGVyYWN0IHdpdGggdGhlIGlucHV0XG50aHJvdWdoIHRoaXMgaW50ZXJmYWNlLiBJdCBwcmVzZW50cyB0aGUgaW5wdXQgYXMgYSBzdHJlYW0gb2ZcbmNoYXJhY3RlcnMsIHRyYWNraW5nIGxvb2thaGVhZCBhbmQgaGlkaW5nIHRoZSBjb21wbGV4aXR5IG9mXG5bcmFuZ2VzXSgjY29tbW9uLlBhcnNlci5wYXJzZV5yYW5nZXMpIGZyb20gdG9rZW5pemVyIGNvZGUuXG4qL1xuY2xhc3MgSW5wdXRTdHJlYW0ge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBpbnB1dCwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICByYW5nZXMpIHtcbiAgICAgICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgICAgICB0aGlzLnJhbmdlcyA9IHJhbmdlcztcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmNodW5rID0gXCJcIjtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmNodW5rT2ZmID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgIEJhY2t1cCBjaHVua1xuICAgICAgICAqL1xuICAgICAgICB0aGlzLmNodW5rMiA9IFwiXCI7XG4gICAgICAgIHRoaXMuY2h1bmsyUG9zID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgIFRoZSBjaGFyYWN0ZXIgY29kZSBvZiB0aGUgbmV4dCBjb2RlIHVuaXQgaW4gdGhlIGlucHV0LCBvciAtMVxuICAgICAgICB3aGVuIHRoZSBzdHJlYW0gaXMgYXQgdGhlIGVuZCBvZiB0aGUgaW5wdXQuXG4gICAgICAgICovXG4gICAgICAgIHRoaXMubmV4dCA9IC0xO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMudG9rZW4gPSBudWxsVG9rZW47XG4gICAgICAgIHRoaXMucmFuZ2VJbmRleCA9IDA7XG4gICAgICAgIHRoaXMucG9zID0gdGhpcy5jaHVua1BvcyA9IHJhbmdlc1swXS5mcm9tO1xuICAgICAgICB0aGlzLnJhbmdlID0gcmFuZ2VzWzBdO1xuICAgICAgICB0aGlzLmVuZCA9IHJhbmdlc1tyYW5nZXMubGVuZ3RoIC0gMV0udG87XG4gICAgICAgIHRoaXMucmVhZE5leHQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICByZXNvbHZlT2Zmc2V0KG9mZnNldCwgYXNzb2MpIHtcbiAgICAgICAgbGV0IHJhbmdlID0gdGhpcy5yYW5nZSwgaW5kZXggPSB0aGlzLnJhbmdlSW5kZXg7XG4gICAgICAgIGxldCBwb3MgPSB0aGlzLnBvcyArIG9mZnNldDtcbiAgICAgICAgd2hpbGUgKHBvcyA8IHJhbmdlLmZyb20pIHtcbiAgICAgICAgICAgIGlmICghaW5kZXgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IHRoaXMucmFuZ2VzWy0taW5kZXhdO1xuICAgICAgICAgICAgcG9zIC09IHJhbmdlLmZyb20gLSBuZXh0LnRvO1xuICAgICAgICAgICAgcmFuZ2UgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChhc3NvYyA8IDAgPyBwb3MgPiByYW5nZS50byA6IHBvcyA+PSByYW5nZS50bykge1xuICAgICAgICAgICAgaWYgKGluZGV4ID09IHRoaXMucmFuZ2VzLmxlbmd0aCAtIDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IHRoaXMucmFuZ2VzWysraW5kZXhdO1xuICAgICAgICAgICAgcG9zICs9IG5leHQuZnJvbSAtIHJhbmdlLnRvO1xuICAgICAgICAgICAgcmFuZ2UgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY2xpcFBvcyhwb3MpIHtcbiAgICAgICAgaWYgKHBvcyA+PSB0aGlzLnJhbmdlLmZyb20gJiYgcG9zIDwgdGhpcy5yYW5nZS50bylcbiAgICAgICAgICAgIHJldHVybiBwb3M7XG4gICAgICAgIGZvciAobGV0IHJhbmdlIG9mIHRoaXMucmFuZ2VzKVxuICAgICAgICAgICAgaWYgKHJhbmdlLnRvID4gcG9zKVxuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLm1heChwb3MsIHJhbmdlLmZyb20pO1xuICAgICAgICByZXR1cm4gdGhpcy5lbmQ7XG4gICAgfVxuICAgIC8qKlxuICAgIExvb2sgYXQgYSBjb2RlIHVuaXQgbmVhciB0aGUgc3RyZWFtIHBvc2l0aW9uLiBgLnBlZWsoMClgIGVxdWFsc1xuICAgIGAubmV4dGAsIGAucGVlaygtMSlgIGdpdmVzIHlvdSB0aGUgcHJldmlvdXMgY2hhcmFjdGVyLCBhbmQgc29cbiAgICBvbi5cbiAgICBcbiAgICBOb3RlIHRoYXQgbG9va2luZyBhcm91bmQgZHVyaW5nIHRva2VuaXppbmcgY3JlYXRlcyBkZXBlbmRlbmNpZXNcbiAgICBvbiBwb3RlbnRpYWxseSBmYXItYXdheSBjb250ZW50LCB3aGljaCBtYXkgcmVkdWNlIHRoZVxuICAgIGVmZmVjdGl2ZW5lc3MgaW5jcmVtZW50YWwgcGFyc2luZ+KAlHdoZW4gbG9va2luZyBmb3J3YXJk4oCUb3IgZXZlblxuICAgIGNhdXNlIGludmFsaWQgcmVwYXJzZXMgd2hlbiBsb29raW5nIGJhY2t3YXJkIG1vcmUgdGhhbiAyNSBjb2RlXG4gICAgdW5pdHMsIHNpbmNlIHRoZSBsaWJyYXJ5IGRvZXMgbm90IHRyYWNrIGxvb2tiZWhpbmQuXG4gICAgKi9cbiAgICBwZWVrKG9mZnNldCkge1xuICAgICAgICBsZXQgaWR4ID0gdGhpcy5jaHVua09mZiArIG9mZnNldCwgcG9zLCByZXN1bHQ7XG4gICAgICAgIGlmIChpZHggPj0gMCAmJiBpZHggPCB0aGlzLmNodW5rLmxlbmd0aCkge1xuICAgICAgICAgICAgcG9zID0gdGhpcy5wb3MgKyBvZmZzZXQ7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLmNodW5rLmNoYXJDb2RlQXQoaWR4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCByZXNvbHZlZCA9IHRoaXMucmVzb2x2ZU9mZnNldChvZmZzZXQsIDEpO1xuICAgICAgICAgICAgaWYgKHJlc29sdmVkID09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgcG9zID0gcmVzb2x2ZWQ7XG4gICAgICAgICAgICBpZiAocG9zID49IHRoaXMuY2h1bmsyUG9zICYmIHBvcyA8IHRoaXMuY2h1bmsyUG9zICsgdGhpcy5jaHVuazIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5jaHVuazIuY2hhckNvZGVBdChwb3MgLSB0aGlzLmNodW5rMlBvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgaSA9IHRoaXMucmFuZ2VJbmRleCwgcmFuZ2UgPSB0aGlzLnJhbmdlO1xuICAgICAgICAgICAgICAgIHdoaWxlIChyYW5nZS50byA8PSBwb3MpXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlID0gdGhpcy5yYW5nZXNbKytpXTtcbiAgICAgICAgICAgICAgICB0aGlzLmNodW5rMiA9IHRoaXMuaW5wdXQuY2h1bmsodGhpcy5jaHVuazJQb3MgPSBwb3MpO1xuICAgICAgICAgICAgICAgIGlmIChwb3MgKyB0aGlzLmNodW5rMi5sZW5ndGggPiByYW5nZS50bylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaHVuazIgPSB0aGlzLmNodW5rMi5zbGljZSgwLCByYW5nZS50byAtIHBvcyk7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5jaHVuazIuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zID49IHRoaXMudG9rZW4ubG9va0FoZWFkKVxuICAgICAgICAgICAgdGhpcy50b2tlbi5sb29rQWhlYWQgPSBwb3MgKyAxO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICBBY2NlcHQgYSB0b2tlbi4gQnkgZGVmYXVsdCwgdGhlIGVuZCBvZiB0aGUgdG9rZW4gaXMgc2V0IHRvIHRoZVxuICAgIGN1cnJlbnQgc3RyZWFtIHBvc2l0aW9uLCBidXQgeW91IGNhbiBwYXNzIGFuIG9mZnNldCAocmVsYXRpdmUgdG9cbiAgICB0aGUgc3RyZWFtIHBvc2l0aW9uKSB0byBjaGFuZ2UgdGhhdC5cbiAgICAqL1xuICAgIGFjY2VwdFRva2VuKHRva2VuLCBlbmRPZmZzZXQgPSAwKSB7XG4gICAgICAgIGxldCBlbmQgPSBlbmRPZmZzZXQgPyB0aGlzLnJlc29sdmVPZmZzZXQoZW5kT2Zmc2V0LCAtMSkgOiB0aGlzLnBvcztcbiAgICAgICAgaWYgKGVuZCA9PSBudWxsIHx8IGVuZCA8IHRoaXMudG9rZW4uc3RhcnQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRva2VuIGVuZCBvdXQgb2YgYm91bmRzXCIpO1xuICAgICAgICB0aGlzLnRva2VuLnZhbHVlID0gdG9rZW47XG4gICAgICAgIHRoaXMudG9rZW4uZW5kID0gZW5kO1xuICAgIH1cbiAgICBnZXRDaHVuaygpIHtcbiAgICAgICAgaWYgKHRoaXMucG9zID49IHRoaXMuY2h1bmsyUG9zICYmIHRoaXMucG9zIDwgdGhpcy5jaHVuazJQb3MgKyB0aGlzLmNodW5rMi5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCB7IGNodW5rLCBjaHVua1BvcyB9ID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuY2h1bmsgPSB0aGlzLmNodW5rMjtcbiAgICAgICAgICAgIHRoaXMuY2h1bmtQb3MgPSB0aGlzLmNodW5rMlBvcztcbiAgICAgICAgICAgIHRoaXMuY2h1bmsyID0gY2h1bms7XG4gICAgICAgICAgICB0aGlzLmNodW5rMlBvcyA9IGNodW5rUG9zO1xuICAgICAgICAgICAgdGhpcy5jaHVua09mZiA9IHRoaXMucG9zIC0gdGhpcy5jaHVua1BvcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2h1bmsyID0gdGhpcy5jaHVuaztcbiAgICAgICAgICAgIHRoaXMuY2h1bmsyUG9zID0gdGhpcy5jaHVua1BvcztcbiAgICAgICAgICAgIGxldCBuZXh0Q2h1bmsgPSB0aGlzLmlucHV0LmNodW5rKHRoaXMucG9zKTtcbiAgICAgICAgICAgIGxldCBlbmQgPSB0aGlzLnBvcyArIG5leHRDaHVuay5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLmNodW5rID0gZW5kID4gdGhpcy5yYW5nZS50byA/IG5leHRDaHVuay5zbGljZSgwLCB0aGlzLnJhbmdlLnRvIC0gdGhpcy5wb3MpIDogbmV4dENodW5rO1xuICAgICAgICAgICAgdGhpcy5jaHVua1BvcyA9IHRoaXMucG9zO1xuICAgICAgICAgICAgdGhpcy5jaHVua09mZiA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVhZE5leHQoKSB7XG4gICAgICAgIGlmICh0aGlzLmNodW5rT2ZmID49IHRoaXMuY2h1bmsubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmdldENodW5rKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5jaHVua09mZiA9PSB0aGlzLmNodW5rLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5uZXh0ID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dCA9IHRoaXMuY2h1bmsuY2hhckNvZGVBdCh0aGlzLmNodW5rT2ZmKTtcbiAgICB9XG4gICAgLyoqXG4gICAgTW92ZSB0aGUgc3RyZWFtIGZvcndhcmQgTiAoZGVmYXVsdHMgdG8gMSkgY29kZSB1bml0cy4gUmV0dXJuc1xuICAgIHRoZSBuZXcgdmFsdWUgb2YgW2BuZXh0YF0oI2xyLklucHV0U3RyZWFtLm5leHQpLlxuICAgICovXG4gICAgYWR2YW5jZShuID0gMSkge1xuICAgICAgICB0aGlzLmNodW5rT2ZmICs9IG47XG4gICAgICAgIHdoaWxlICh0aGlzLnBvcyArIG4gPj0gdGhpcy5yYW5nZS50bykge1xuICAgICAgICAgICAgaWYgKHRoaXMucmFuZ2VJbmRleCA9PSB0aGlzLnJhbmdlcy5sZW5ndGggLSAxKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNldERvbmUoKTtcbiAgICAgICAgICAgIG4gLT0gdGhpcy5yYW5nZS50byAtIHRoaXMucG9zO1xuICAgICAgICAgICAgdGhpcy5yYW5nZSA9IHRoaXMucmFuZ2VzWysrdGhpcy5yYW5nZUluZGV4XTtcbiAgICAgICAgICAgIHRoaXMucG9zID0gdGhpcy5yYW5nZS5mcm9tO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucG9zICs9IG47XG4gICAgICAgIGlmICh0aGlzLnBvcyA+PSB0aGlzLnRva2VuLmxvb2tBaGVhZClcbiAgICAgICAgICAgIHRoaXMudG9rZW4ubG9va0FoZWFkID0gdGhpcy5wb3MgKyAxO1xuICAgICAgICByZXR1cm4gdGhpcy5yZWFkTmV4dCgpO1xuICAgIH1cbiAgICBzZXREb25lKCkge1xuICAgICAgICB0aGlzLnBvcyA9IHRoaXMuY2h1bmtQb3MgPSB0aGlzLmVuZDtcbiAgICAgICAgdGhpcy5yYW5nZSA9IHRoaXMucmFuZ2VzW3RoaXMucmFuZ2VJbmRleCA9IHRoaXMucmFuZ2VzLmxlbmd0aCAtIDFdO1xuICAgICAgICB0aGlzLmNodW5rID0gXCJcIjtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dCA9IC0xO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHJlc2V0KHBvcywgdG9rZW4pIHtcbiAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gICAgICAgICAgICB0b2tlbi5zdGFydCA9IHBvcztcbiAgICAgICAgICAgIHRva2VuLmxvb2tBaGVhZCA9IHBvcyArIDE7XG4gICAgICAgICAgICB0b2tlbi52YWx1ZSA9IHRva2VuLmV4dGVuZGVkID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnRva2VuID0gbnVsbFRva2VuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBvcyAhPSBwb3MpIHtcbiAgICAgICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICAgICAgaWYgKHBvcyA9PSB0aGlzLmVuZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0RG9uZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKHBvcyA8IHRoaXMucmFuZ2UuZnJvbSlcbiAgICAgICAgICAgICAgICB0aGlzLnJhbmdlID0gdGhpcy5yYW5nZXNbLS10aGlzLnJhbmdlSW5kZXhdO1xuICAgICAgICAgICAgd2hpbGUgKHBvcyA+PSB0aGlzLnJhbmdlLnRvKVxuICAgICAgICAgICAgICAgIHRoaXMucmFuZ2UgPSB0aGlzLnJhbmdlc1srK3RoaXMucmFuZ2VJbmRleF07XG4gICAgICAgICAgICBpZiAocG9zID49IHRoaXMuY2h1bmtQb3MgJiYgcG9zIDwgdGhpcy5jaHVua1BvcyArIHRoaXMuY2h1bmsubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaHVua09mZiA9IHBvcyAtIHRoaXMuY2h1bmtQb3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNodW5rID0gXCJcIjtcbiAgICAgICAgICAgICAgICB0aGlzLmNodW5rT2ZmID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVhZE5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICByZWFkKGZyb20sIHRvKSB7XG4gICAgICAgIGlmIChmcm9tID49IHRoaXMuY2h1bmtQb3MgJiYgdG8gPD0gdGhpcy5jaHVua1BvcyArIHRoaXMuY2h1bmsubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2h1bmsuc2xpY2UoZnJvbSAtIHRoaXMuY2h1bmtQb3MsIHRvIC0gdGhpcy5jaHVua1Bvcyk7XG4gICAgICAgIGlmIChmcm9tID49IHRoaXMuY2h1bmsyUG9zICYmIHRvIDw9IHRoaXMuY2h1bmsyUG9zICsgdGhpcy5jaHVuazIubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2h1bmsyLnNsaWNlKGZyb20gLSB0aGlzLmNodW5rMlBvcywgdG8gLSB0aGlzLmNodW5rMlBvcyk7XG4gICAgICAgIGlmIChmcm9tID49IHRoaXMucmFuZ2UuZnJvbSAmJiB0byA8PSB0aGlzLnJhbmdlLnRvKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5wdXQucmVhZChmcm9tLCB0byk7XG4gICAgICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgICAgICBmb3IgKGxldCByIG9mIHRoaXMucmFuZ2VzKSB7XG4gICAgICAgICAgICBpZiAoci5mcm9tID49IHRvKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgaWYgKHIudG8gPiBmcm9tKVxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSB0aGlzLmlucHV0LnJlYWQoTWF0aC5tYXgoci5mcm9tLCBmcm9tKSwgTWF0aC5taW4oci50bywgdG8pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbi8qKlxuQGludGVybmFsXG4qL1xuY2xhc3MgVG9rZW5Hcm91cCB7XG4gICAgY29uc3RydWN0b3IoZGF0YSwgaWQpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgIH1cbiAgICB0b2tlbihpbnB1dCwgc3RhY2spIHtcbiAgICAgICAgbGV0IHsgcGFyc2VyIH0gPSBzdGFjay5wO1xuICAgICAgICByZWFkVG9rZW4odGhpcy5kYXRhLCBpbnB1dCwgc3RhY2ssIHRoaXMuaWQsIHBhcnNlci5kYXRhLCBwYXJzZXIudG9rZW5QcmVjVGFibGUpO1xuICAgIH1cbn1cblRva2VuR3JvdXAucHJvdG90eXBlLmNvbnRleHR1YWwgPSBUb2tlbkdyb3VwLnByb3RvdHlwZS5mYWxsYmFjayA9IFRva2VuR3JvdXAucHJvdG90eXBlLmV4dGVuZCA9IGZhbHNlO1xuLyoqXG5AaGlkZVxuKi9cbmNsYXNzIExvY2FsVG9rZW5Hcm91cCB7XG4gICAgY29uc3RydWN0b3IoZGF0YSwgcHJlY1RhYmxlLCBlbHNlVG9rZW4pIHtcbiAgICAgICAgdGhpcy5wcmVjVGFibGUgPSBwcmVjVGFibGU7XG4gICAgICAgIHRoaXMuZWxzZVRva2VuID0gZWxzZVRva2VuO1xuICAgICAgICB0aGlzLmRhdGEgPSB0eXBlb2YgZGF0YSA9PSBcInN0cmluZ1wiID8gZGVjb2RlQXJyYXkoZGF0YSkgOiBkYXRhO1xuICAgIH1cbiAgICB0b2tlbihpbnB1dCwgc3RhY2spIHtcbiAgICAgICAgbGV0IHN0YXJ0ID0gaW5wdXQucG9zLCBza2lwcGVkID0gMDtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IGF0RW9mID0gaW5wdXQubmV4dCA8IDAsIG5leHRQb3MgPSBpbnB1dC5yZXNvbHZlT2Zmc2V0KDEsIDEpO1xuICAgICAgICAgICAgcmVhZFRva2VuKHRoaXMuZGF0YSwgaW5wdXQsIHN0YWNrLCAwLCB0aGlzLmRhdGEsIHRoaXMucHJlY1RhYmxlKTtcbiAgICAgICAgICAgIGlmIChpbnB1dC50b2tlbi52YWx1ZSA+IC0xKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgaWYgKHRoaXMuZWxzZVRva2VuID09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKCFhdEVvZilcbiAgICAgICAgICAgICAgICBza2lwcGVkKys7XG4gICAgICAgICAgICBpZiAobmV4dFBvcyA9PSBudWxsKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgaW5wdXQucmVzZXQobmV4dFBvcywgaW5wdXQudG9rZW4pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChza2lwcGVkKSB7XG4gICAgICAgICAgICBpbnB1dC5yZXNldChzdGFydCwgaW5wdXQudG9rZW4pO1xuICAgICAgICAgICAgaW5wdXQuYWNjZXB0VG9rZW4odGhpcy5lbHNlVG9rZW4sIHNraXBwZWQpO1xuICAgICAgICB9XG4gICAgfVxufVxuTG9jYWxUb2tlbkdyb3VwLnByb3RvdHlwZS5jb250ZXh0dWFsID0gVG9rZW5Hcm91cC5wcm90b3R5cGUuZmFsbGJhY2sgPSBUb2tlbkdyb3VwLnByb3RvdHlwZS5leHRlbmQgPSBmYWxzZTtcbi8qKlxuYEBleHRlcm5hbCB0b2tlbnNgIGRlY2xhcmF0aW9ucyBpbiB0aGUgZ3JhbW1hciBzaG91bGQgcmVzb2x2ZSB0b1xuYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiovXG5jbGFzcyBFeHRlcm5hbFRva2VuaXplciB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgdG9rZW5pemVyLiBUaGUgZmlyc3QgYXJndW1lbnQgaXMgdGhlIGZ1bmN0aW9uIHRoYXQsXG4gICAgZ2l2ZW4gYW4gaW5wdXQgc3RyZWFtLCBzY2FucyBmb3IgdGhlIHR5cGVzIG9mIHRva2VucyBpdFxuICAgIHJlY29nbml6ZXMgYXQgdGhlIHN0cmVhbSdzIHBvc2l0aW9uLCBhbmQgY2FsbHNcbiAgICBbYGFjY2VwdFRva2VuYF0oI2xyLklucHV0U3RyZWFtLmFjY2VwdFRva2VuKSB3aGVuIGl0IGZpbmRzXG4gICAgb25lLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0b2tlbiwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICAgICAgdGhpcy5jb250ZXh0dWFsID0gISFvcHRpb25zLmNvbnRleHR1YWw7XG4gICAgICAgIHRoaXMuZmFsbGJhY2sgPSAhIW9wdGlvbnMuZmFsbGJhY2s7XG4gICAgICAgIHRoaXMuZXh0ZW5kID0gISFvcHRpb25zLmV4dGVuZDtcbiAgICB9XG59XG4vLyBUb2tlbml6ZXIgZGF0YSBpcyBzdG9yZWQgYSBiaWcgdWludDE2IGFycmF5IGNvbnRhaW5pbmcsIGZvciBlYWNoXG4vLyBzdGF0ZTpcbi8vXG4vLyAgLSBBIGdyb3VwIGJpdG1hc2ssIGluZGljYXRpbmcgd2hhdCB0b2tlbiBncm91cHMgYXJlIHJlYWNoYWJsZSBmcm9tXG4vLyAgICB0aGlzIHN0YXRlLCBzbyB0aGF0IHBhdGhzIHRoYXQgY2FuIG9ubHkgbGVhZCB0byB0b2tlbnMgbm90IGluXG4vLyAgICBhbnkgb2YgdGhlIGN1cnJlbnQgZ3JvdXBzIGNhbiBiZSBjdXQgb2ZmIGVhcmx5LlxuLy9cbi8vICAtIFRoZSBwb3NpdGlvbiBvZiB0aGUgZW5kIG9mIHRoZSBzdGF0ZSdzIHNlcXVlbmNlIG9mIGFjY2VwdGluZ1xuLy8gICAgdG9rZW5zXG4vL1xuLy8gIC0gVGhlIG51bWJlciBvZiBvdXRnb2luZyBlZGdlcyBmb3IgdGhlIHN0YXRlXG4vL1xuLy8gIC0gVGhlIGFjY2VwdGluZyB0b2tlbnMsIGFzICh0b2tlbiBpZCwgZ3JvdXAgbWFzaykgcGFpcnNcbi8vXG4vLyAgLSBUaGUgb3V0Z29pbmcgZWRnZXMsIGFzIChzdGFydCBjaGFyYWN0ZXIsIGVuZCBjaGFyYWN0ZXIsIHN0YXRlXG4vLyAgICBpbmRleCkgdHJpcGxlcywgd2l0aCBlbmQgY2hhcmFjdGVyIGJlaW5nIGV4Y2x1c2l2ZVxuLy9cbi8vIFRoaXMgZnVuY3Rpb24gaW50ZXJwcmV0cyB0aGF0IGRhdGEsIHJ1bm5pbmcgdGhyb3VnaCBhIHN0cmVhbSBhc1xuLy8gbG9uZyBhcyBuZXcgc3RhdGVzIHdpdGggdGhlIGEgbWF0Y2hpbmcgZ3JvdXAgbWFzayBjYW4gYmUgcmVhY2hlZCxcbi8vIGFuZCB1cGRhdGluZyBgaW5wdXQudG9rZW5gIHdoZW4gaXQgbWF0Y2hlcyBhIHRva2VuLlxuZnVuY3Rpb24gcmVhZFRva2VuKGRhdGEsIGlucHV0LCBzdGFjaywgZ3JvdXAsIHByZWNUYWJsZSwgcHJlY09mZnNldCkge1xuICAgIGxldCBzdGF0ZSA9IDAsIGdyb3VwTWFzayA9IDEgPDwgZ3JvdXAsIHsgZGlhbGVjdCB9ID0gc3RhY2sucC5wYXJzZXI7XG4gICAgc2NhbjogZm9yICg7Oykge1xuICAgICAgICBpZiAoKGdyb3VwTWFzayAmIGRhdGFbc3RhdGVdKSA9PSAwKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGxldCBhY2NFbmQgPSBkYXRhW3N0YXRlICsgMV07XG4gICAgICAgIC8vIENoZWNrIHdoZXRoZXIgdGhpcyBzdGF0ZSBjYW4gbGVhZCB0byBhIHRva2VuIGluIHRoZSBjdXJyZW50IGdyb3VwXG4gICAgICAgIC8vIEFjY2VwdCB0b2tlbnMgaW4gdGhpcyBzdGF0ZSwgcG9zc2libHkgb3ZlcndyaXRpbmdcbiAgICAgICAgLy8gbG93ZXItcHJlY2VkZW5jZSAvIHNob3J0ZXIgdG9rZW5zXG4gICAgICAgIGZvciAobGV0IGkgPSBzdGF0ZSArIDM7IGkgPCBhY2NFbmQ7IGkgKz0gMilcbiAgICAgICAgICAgIGlmICgoZGF0YVtpICsgMV0gJiBncm91cE1hc2spID4gMCkge1xuICAgICAgICAgICAgICAgIGxldCB0ZXJtID0gZGF0YVtpXTtcbiAgICAgICAgICAgICAgICBpZiAoZGlhbGVjdC5hbGxvd3ModGVybSkgJiZcbiAgICAgICAgICAgICAgICAgICAgKGlucHV0LnRva2VuLnZhbHVlID09IC0xIHx8IGlucHV0LnRva2VuLnZhbHVlID09IHRlcm0gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJyaWRlcyh0ZXJtLCBpbnB1dC50b2tlbi52YWx1ZSwgcHJlY1RhYmxlLCBwcmVjT2Zmc2V0KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQuYWNjZXB0VG9rZW4odGVybSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgbGV0IG5leHQgPSBpbnB1dC5uZXh0LCBsb3cgPSAwLCBoaWdoID0gZGF0YVtzdGF0ZSArIDJdO1xuICAgICAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIEVPRlxuICAgICAgICBpZiAoaW5wdXQubmV4dCA8IDAgJiYgaGlnaCA+IGxvdyAmJiBkYXRhW2FjY0VuZCArIGhpZ2ggKiAzIC0gM10gPT0gNjU1MzUgLyogU2VxLkVuZCAqLykge1xuICAgICAgICAgICAgc3RhdGUgPSBkYXRhW2FjY0VuZCArIGhpZ2ggKiAzIC0gMV07XG4gICAgICAgICAgICBjb250aW51ZSBzY2FuO1xuICAgICAgICB9XG4gICAgICAgIC8vIERvIGEgYmluYXJ5IHNlYXJjaCBvbiB0aGUgc3RhdGUncyBlZGdlc1xuICAgICAgICBmb3IgKDsgbG93IDwgaGlnaDspIHtcbiAgICAgICAgICAgIGxldCBtaWQgPSAobG93ICsgaGlnaCkgPj4gMTtcbiAgICAgICAgICAgIGxldCBpbmRleCA9IGFjY0VuZCArIG1pZCArIChtaWQgPDwgMSk7XG4gICAgICAgICAgICBsZXQgZnJvbSA9IGRhdGFbaW5kZXhdLCB0byA9IGRhdGFbaW5kZXggKyAxXSB8fCAweDEwMDAwO1xuICAgICAgICAgICAgaWYgKG5leHQgPCBmcm9tKVxuICAgICAgICAgICAgICAgIGhpZ2ggPSBtaWQ7XG4gICAgICAgICAgICBlbHNlIGlmIChuZXh0ID49IHRvKVxuICAgICAgICAgICAgICAgIGxvdyA9IG1pZCArIDE7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IGRhdGFbaW5kZXggKyAyXTtcbiAgICAgICAgICAgICAgICBpbnB1dC5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgY29udGludWUgc2NhbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG59XG5mdW5jdGlvbiBmaW5kT2Zmc2V0KGRhdGEsIHN0YXJ0LCB0ZXJtKSB7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0LCBuZXh0OyAobmV4dCA9IGRhdGFbaV0pICE9IDY1NTM1IC8qIFNlcS5FbmQgKi87IGkrKylcbiAgICAgICAgaWYgKG5leHQgPT0gdGVybSlcbiAgICAgICAgICAgIHJldHVybiBpIC0gc3RhcnQ7XG4gICAgcmV0dXJuIC0xO1xufVxuZnVuY3Rpb24gb3ZlcnJpZGVzKHRva2VuLCBwcmV2LCB0YWJsZURhdGEsIHRhYmxlT2Zmc2V0KSB7XG4gICAgbGV0IGlQcmV2ID0gZmluZE9mZnNldCh0YWJsZURhdGEsIHRhYmxlT2Zmc2V0LCBwcmV2KTtcbiAgICByZXR1cm4gaVByZXYgPCAwIHx8IGZpbmRPZmZzZXQodGFibGVEYXRhLCB0YWJsZU9mZnNldCwgdG9rZW4pIDwgaVByZXY7XG59XG5cbi8vIEVudmlyb25tZW50IHZhcmlhYmxlIHVzZWQgdG8gY29udHJvbCBjb25zb2xlIG91dHB1dFxuY29uc3QgdmVyYm9zZSA9IHR5cGVvZiBwcm9jZXNzICE9IFwidW5kZWZpbmVkXCIgJiYgcHJvY2Vzcy5lbnYgJiYgL1xcYnBhcnNlXFxiLy50ZXN0KHByb2Nlc3MuZW52LkxPRyk7XG5sZXQgc3RhY2tJRHMgPSBudWxsO1xuZnVuY3Rpb24gY3V0QXQodHJlZSwgcG9zLCBzaWRlKSB7XG4gICAgbGV0IGN1cnNvciA9IHRyZWUuY3Vyc29yKEl0ZXJNb2RlLkluY2x1ZGVBbm9ueW1vdXMpO1xuICAgIGN1cnNvci5tb3ZlVG8ocG9zKTtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGlmICghKHNpZGUgPCAwID8gY3Vyc29yLmNoaWxkQmVmb3JlKHBvcykgOiBjdXJzb3IuY2hpbGRBZnRlcihwb3MpKSlcbiAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICBpZiAoKHNpZGUgPCAwID8gY3Vyc29yLnRvIDwgcG9zIDogY3Vyc29yLmZyb20gPiBwb3MpICYmICFjdXJzb3IudHlwZS5pc0Vycm9yKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2lkZSA8IDAgPyBNYXRoLm1heCgwLCBNYXRoLm1pbihjdXJzb3IudG8gLSAxLCBwb3MgLSAyNSAvKiBTYWZldHkuTWFyZ2luICovKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogTWF0aC5taW4odHJlZS5sZW5ndGgsIE1hdGgubWF4KGN1cnNvci5mcm9tICsgMSwgcG9zICsgMjUgLyogU2FmZXR5Lk1hcmdpbiAqLykpO1xuICAgICAgICAgICAgICAgIGlmIChzaWRlIDwgMCA/IGN1cnNvci5wcmV2U2libGluZygpIDogY3Vyc29yLm5leHRTaWJsaW5nKCkpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGlmICghY3Vyc29yLnBhcmVudCgpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2lkZSA8IDAgPyAwIDogdHJlZS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgRnJhZ21lbnRDdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKGZyYWdtZW50cywgbm9kZVNldCkge1xuICAgICAgICB0aGlzLmZyYWdtZW50cyA9IGZyYWdtZW50cztcbiAgICAgICAgdGhpcy5ub2RlU2V0ID0gbm9kZVNldDtcbiAgICAgICAgdGhpcy5pID0gMDtcbiAgICAgICAgdGhpcy5mcmFnbWVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuc2FmZUZyb20gPSAtMTtcbiAgICAgICAgdGhpcy5zYWZlVG8gPSAtMTtcbiAgICAgICAgdGhpcy50cmVlcyA9IFtdO1xuICAgICAgICB0aGlzLnN0YXJ0ID0gW107XG4gICAgICAgIHRoaXMuaW5kZXggPSBbXTtcbiAgICAgICAgdGhpcy5uZXh0RnJhZ21lbnQoKTtcbiAgICB9XG4gICAgbmV4dEZyYWdtZW50KCkge1xuICAgICAgICBsZXQgZnIgPSB0aGlzLmZyYWdtZW50ID0gdGhpcy5pID09IHRoaXMuZnJhZ21lbnRzLmxlbmd0aCA/IG51bGwgOiB0aGlzLmZyYWdtZW50c1t0aGlzLmkrK107XG4gICAgICAgIGlmIChmcikge1xuICAgICAgICAgICAgdGhpcy5zYWZlRnJvbSA9IGZyLm9wZW5TdGFydCA/IGN1dEF0KGZyLnRyZWUsIGZyLmZyb20gKyBmci5vZmZzZXQsIDEpIC0gZnIub2Zmc2V0IDogZnIuZnJvbTtcbiAgICAgICAgICAgIHRoaXMuc2FmZVRvID0gZnIub3BlbkVuZCA/IGN1dEF0KGZyLnRyZWUsIGZyLnRvICsgZnIub2Zmc2V0LCAtMSkgLSBmci5vZmZzZXQgOiBmci50bztcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLnRyZWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMudHJlZXMucG9wKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydC5wb3AoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4LnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy50cmVlcy5wdXNoKGZyLnRyZWUpO1xuICAgICAgICAgICAgdGhpcy5zdGFydC5wdXNoKC1mci5vZmZzZXQpO1xuICAgICAgICAgICAgdGhpcy5pbmRleC5wdXNoKDApO1xuICAgICAgICAgICAgdGhpcy5uZXh0U3RhcnQgPSB0aGlzLnNhZmVGcm9tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5uZXh0U3RhcnQgPSAxZTk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gYHBvc2AgbXVzdCBiZSA+PSBhbnkgcHJldmlvdXNseSBnaXZlbiBgcG9zYCBmb3IgdGhpcyBjdXJzb3JcbiAgICBub2RlQXQocG9zKSB7XG4gICAgICAgIGlmIChwb3MgPCB0aGlzLm5leHRTdGFydClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB3aGlsZSAodGhpcy5mcmFnbWVudCAmJiB0aGlzLnNhZmVUbyA8PSBwb3MpXG4gICAgICAgICAgICB0aGlzLm5leHRGcmFnbWVudCgpO1xuICAgICAgICBpZiAoIXRoaXMuZnJhZ21lbnQpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IGxhc3QgPSB0aGlzLnRyZWVzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICBpZiAobGFzdCA8IDApIHsgLy8gRW5kIG9mIHRyZWVcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRGcmFnbWVudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHRvcCA9IHRoaXMudHJlZXNbbGFzdF0sIGluZGV4ID0gdGhpcy5pbmRleFtsYXN0XTtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PSB0b3AuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmVlcy5wb3AoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0LnBvcCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXgucG9wKCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbmV4dCA9IHRvcC5jaGlsZHJlbltpbmRleF07XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLnN0YXJ0W2xhc3RdICsgdG9wLnBvc2l0aW9uc1tpbmRleF07XG4gICAgICAgICAgICBpZiAoc3RhcnQgPiBwb3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRTdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5leHQgaW5zdGFuY2VvZiBUcmVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0ID09IHBvcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnQgPCB0aGlzLnNhZmVGcm9tKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGxldCBlbmQgPSBzdGFydCArIG5leHQubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW5kIDw9IHRoaXMuc2FmZVRvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbG9va0FoZWFkID0gbmV4dC5wcm9wKE5vZGVQcm9wLmxvb2tBaGVhZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWxvb2tBaGVhZCB8fCBlbmQgKyBsb29rQWhlYWQgPCB0aGlzLmZyYWdtZW50LnRvKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhbbGFzdF0rKztcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnQgKyBuZXh0Lmxlbmd0aCA+PSBNYXRoLm1heCh0aGlzLnNhZmVGcm9tLCBwb3MpKSB7IC8vIEVudGVyIHRoaXMgbm9kZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyZWVzLnB1c2gobmV4dCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnQucHVzaChzdGFydCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXgucHVzaCgwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4W2xhc3RdKys7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0U3RhcnQgPSBzdGFydCArIG5leHQubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgVG9rZW5DYWNoZSB7XG4gICAgY29uc3RydWN0b3IocGFyc2VyLCBzdHJlYW0pIHtcbiAgICAgICAgdGhpcy5zdHJlYW0gPSBzdHJlYW07XG4gICAgICAgIHRoaXMudG9rZW5zID0gW107XG4gICAgICAgIHRoaXMubWFpblRva2VuID0gbnVsbDtcbiAgICAgICAgdGhpcy5hY3Rpb25zID0gW107XG4gICAgICAgIHRoaXMudG9rZW5zID0gcGFyc2VyLnRva2VuaXplcnMubWFwKF8gPT4gbmV3IENhY2hlZFRva2VuKTtcbiAgICB9XG4gICAgZ2V0QWN0aW9ucyhzdGFjaykge1xuICAgICAgICBsZXQgYWN0aW9uSW5kZXggPSAwO1xuICAgICAgICBsZXQgbWFpbiA9IG51bGw7XG4gICAgICAgIGxldCB7IHBhcnNlciB9ID0gc3RhY2sucCwgeyB0b2tlbml6ZXJzIH0gPSBwYXJzZXI7XG4gICAgICAgIGxldCBtYXNrID0gcGFyc2VyLnN0YXRlU2xvdChzdGFjay5zdGF0ZSwgMyAvKiBQYXJzZVN0YXRlLlRva2VuaXplck1hc2sgKi8pO1xuICAgICAgICBsZXQgY29udGV4dCA9IHN0YWNrLmN1ckNvbnRleHQgPyBzdGFjay5jdXJDb250ZXh0Lmhhc2ggOiAwO1xuICAgICAgICBsZXQgbG9va0FoZWFkID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b2tlbml6ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoKCgxIDw8IGkpICYgbWFzaykgPT0gMClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGxldCB0b2tlbml6ZXIgPSB0b2tlbml6ZXJzW2ldLCB0b2tlbiA9IHRoaXMudG9rZW5zW2ldO1xuICAgICAgICAgICAgaWYgKG1haW4gJiYgIXRva2VuaXplci5mYWxsYmFjaylcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmICh0b2tlbml6ZXIuY29udGV4dHVhbCB8fCB0b2tlbi5zdGFydCAhPSBzdGFjay5wb3MgfHwgdG9rZW4ubWFzayAhPSBtYXNrIHx8IHRva2VuLmNvbnRleHQgIT0gY29udGV4dCkge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlQ2FjaGVkVG9rZW4odG9rZW4sIHRva2VuaXplciwgc3RhY2spO1xuICAgICAgICAgICAgICAgIHRva2VuLm1hc2sgPSBtYXNrO1xuICAgICAgICAgICAgICAgIHRva2VuLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRva2VuLmxvb2tBaGVhZCA+IHRva2VuLmVuZCArIDI1IC8qIFNhZmV0eS5NYXJnaW4gKi8pXG4gICAgICAgICAgICAgICAgbG9va0FoZWFkID0gTWF0aC5tYXgodG9rZW4ubG9va0FoZWFkLCBsb29rQWhlYWQpO1xuICAgICAgICAgICAgaWYgKHRva2VuLnZhbHVlICE9IDAgLyogVGVybS5FcnIgKi8pIHtcbiAgICAgICAgICAgICAgICBsZXQgc3RhcnRJbmRleCA9IGFjdGlvbkluZGV4O1xuICAgICAgICAgICAgICAgIGlmICh0b2tlbi5leHRlbmRlZCA+IC0xKVxuICAgICAgICAgICAgICAgICAgICBhY3Rpb25JbmRleCA9IHRoaXMuYWRkQWN0aW9ucyhzdGFjaywgdG9rZW4uZXh0ZW5kZWQsIHRva2VuLmVuZCwgYWN0aW9uSW5kZXgpO1xuICAgICAgICAgICAgICAgIGFjdGlvbkluZGV4ID0gdGhpcy5hZGRBY3Rpb25zKHN0YWNrLCB0b2tlbi52YWx1ZSwgdG9rZW4uZW5kLCBhY3Rpb25JbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKCF0b2tlbml6ZXIuZXh0ZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIG1haW4gPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGlvbkluZGV4ID4gc3RhcnRJbmRleClcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAodGhpcy5hY3Rpb25zLmxlbmd0aCA+IGFjdGlvbkluZGV4KVxuICAgICAgICAgICAgdGhpcy5hY3Rpb25zLnBvcCgpO1xuICAgICAgICBpZiAobG9va0FoZWFkKVxuICAgICAgICAgICAgc3RhY2suc2V0TG9va0FoZWFkKGxvb2tBaGVhZCk7XG4gICAgICAgIGlmICghbWFpbiAmJiBzdGFjay5wb3MgPT0gdGhpcy5zdHJlYW0uZW5kKSB7XG4gICAgICAgICAgICBtYWluID0gbmV3IENhY2hlZFRva2VuO1xuICAgICAgICAgICAgbWFpbi52YWx1ZSA9IHN0YWNrLnAucGFyc2VyLmVvZlRlcm07XG4gICAgICAgICAgICBtYWluLnN0YXJ0ID0gbWFpbi5lbmQgPSBzdGFjay5wb3M7XG4gICAgICAgICAgICBhY3Rpb25JbmRleCA9IHRoaXMuYWRkQWN0aW9ucyhzdGFjaywgbWFpbi52YWx1ZSwgbWFpbi5lbmQsIGFjdGlvbkluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1haW5Ub2tlbiA9IG1haW47XG4gICAgICAgIHJldHVybiB0aGlzLmFjdGlvbnM7XG4gICAgfVxuICAgIGdldE1haW5Ub2tlbihzdGFjaykge1xuICAgICAgICBpZiAodGhpcy5tYWluVG9rZW4pXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYWluVG9rZW47XG4gICAgICAgIGxldCBtYWluID0gbmV3IENhY2hlZFRva2VuLCB7IHBvcywgcCB9ID0gc3RhY2s7XG4gICAgICAgIG1haW4uc3RhcnQgPSBwb3M7XG4gICAgICAgIG1haW4uZW5kID0gTWF0aC5taW4ocG9zICsgMSwgcC5zdHJlYW0uZW5kKTtcbiAgICAgICAgbWFpbi52YWx1ZSA9IHBvcyA9PSBwLnN0cmVhbS5lbmQgPyBwLnBhcnNlci5lb2ZUZXJtIDogMCAvKiBUZXJtLkVyciAqLztcbiAgICAgICAgcmV0dXJuIG1haW47XG4gICAgfVxuICAgIHVwZGF0ZUNhY2hlZFRva2VuKHRva2VuLCB0b2tlbml6ZXIsIHN0YWNrKSB7XG4gICAgICAgIGxldCBzdGFydCA9IHRoaXMuc3RyZWFtLmNsaXBQb3Moc3RhY2sucG9zKTtcbiAgICAgICAgdG9rZW5pemVyLnRva2VuKHRoaXMuc3RyZWFtLnJlc2V0KHN0YXJ0LCB0b2tlbiksIHN0YWNrKTtcbiAgICAgICAgaWYgKHRva2VuLnZhbHVlID4gLTEpIHtcbiAgICAgICAgICAgIGxldCB7IHBhcnNlciB9ID0gc3RhY2sucDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyc2VyLnNwZWNpYWxpemVkLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIGlmIChwYXJzZXIuc3BlY2lhbGl6ZWRbaV0gPT0gdG9rZW4udmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHBhcnNlci5zcGVjaWFsaXplcnNbaV0odGhpcy5zdHJlYW0ucmVhZCh0b2tlbi5zdGFydCwgdG9rZW4uZW5kKSwgc3RhY2spO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0ID49IDAgJiYgc3RhY2sucC5wYXJzZXIuZGlhbGVjdC5hbGxvd3MocmVzdWx0ID4+IDEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHJlc3VsdCAmIDEpID09IDAgLyogU3BlY2lhbGl6ZS5TcGVjaWFsaXplICovKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuLnZhbHVlID0gcmVzdWx0ID4+IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4uZXh0ZW5kZWQgPSByZXN1bHQgPj4gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdG9rZW4udmFsdWUgPSAwIC8qIFRlcm0uRXJyICovO1xuICAgICAgICAgICAgdG9rZW4uZW5kID0gdGhpcy5zdHJlYW0uY2xpcFBvcyhzdGFydCArIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHB1dEFjdGlvbihhY3Rpb24sIHRva2VuLCBlbmQsIGluZGV4KSB7XG4gICAgICAgIC8vIERvbid0IGFkZCBkdXBsaWNhdGUgYWN0aW9uc1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluZGV4OyBpICs9IDMpXG4gICAgICAgICAgICBpZiAodGhpcy5hY3Rpb25zW2ldID09IGFjdGlvbilcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgIHRoaXMuYWN0aW9uc1tpbmRleCsrXSA9IGFjdGlvbjtcbiAgICAgICAgdGhpcy5hY3Rpb25zW2luZGV4KytdID0gdG9rZW47XG4gICAgICAgIHRoaXMuYWN0aW9uc1tpbmRleCsrXSA9IGVuZDtcbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbiAgICBhZGRBY3Rpb25zKHN0YWNrLCB0b2tlbiwgZW5kLCBpbmRleCkge1xuICAgICAgICBsZXQgeyBzdGF0ZSB9ID0gc3RhY2ssIHsgcGFyc2VyIH0gPSBzdGFjay5wLCB7IGRhdGEgfSA9IHBhcnNlcjtcbiAgICAgICAgZm9yIChsZXQgc2V0ID0gMDsgc2V0IDwgMjsgc2V0KyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBwYXJzZXIuc3RhdGVTbG90KHN0YXRlLCBzZXQgPyAyIC8qIFBhcnNlU3RhdGUuU2tpcCAqLyA6IDEgLyogUGFyc2VTdGF0ZS5BY3Rpb25zICovKTs7IGkgKz0gMykge1xuICAgICAgICAgICAgICAgIGlmIChkYXRhW2ldID09IDY1NTM1IC8qIFNlcS5FbmQgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFbaSArIDFdID09IDEgLyogU2VxLk5leHQgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBwYWlyKGRhdGEsIGkgKyAyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PSAwICYmIGRhdGFbaSArIDFdID09IDIgLyogU2VxLk90aGVyICovKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gdGhpcy5wdXRBY3Rpb24ocGFpcihkYXRhLCBpICsgMiksIHRva2VuLCBlbmQsIGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkYXRhW2ldID09IHRva2VuKVxuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHRoaXMucHV0QWN0aW9uKHBhaXIoZGF0YSwgaSArIDEpLCB0b2tlbiwgZW5kLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbn1cbmNsYXNzIFBhcnNlIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJzZXIsIGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcykge1xuICAgICAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICAgICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgICAgICB0aGlzLnJhbmdlcyA9IHJhbmdlcztcbiAgICAgICAgdGhpcy5yZWNvdmVyaW5nID0gMDtcbiAgICAgICAgdGhpcy5uZXh0U3RhY2tJRCA9IDB4MjY1NDsgLy8g4pmULCDimZUsIOKZliwg4pmXLCDimZgsIOKZmSwg4pmgLCDimaEsIOKZoiwg4pmjLCDimaQsIOKZpSwg4pmmLCDimadcbiAgICAgICAgdGhpcy5taW5TdGFja1BvcyA9IDA7XG4gICAgICAgIHRoaXMucmV1c2VkID0gW107XG4gICAgICAgIHRoaXMuc3RvcHBlZEF0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0QmlnUmVkdWN0aW9uU3RhcnQgPSAtMTtcbiAgICAgICAgdGhpcy5sYXN0QmlnUmVkdWN0aW9uU2l6ZSA9IDA7XG4gICAgICAgIHRoaXMuYmlnUmVkdWN0aW9uQ291bnQgPSAwO1xuICAgICAgICB0aGlzLnN0cmVhbSA9IG5ldyBJbnB1dFN0cmVhbShpbnB1dCwgcmFuZ2VzKTtcbiAgICAgICAgdGhpcy50b2tlbnMgPSBuZXcgVG9rZW5DYWNoZShwYXJzZXIsIHRoaXMuc3RyZWFtKTtcbiAgICAgICAgdGhpcy50b3BUZXJtID0gcGFyc2VyLnRvcFsxXTtcbiAgICAgICAgbGV0IHsgZnJvbSB9ID0gcmFuZ2VzWzBdO1xuICAgICAgICB0aGlzLnN0YWNrcyA9IFtTdGFjay5zdGFydCh0aGlzLCBwYXJzZXIudG9wWzBdLCBmcm9tKV07XG4gICAgICAgIHRoaXMuZnJhZ21lbnRzID0gZnJhZ21lbnRzLmxlbmd0aCAmJiB0aGlzLnN0cmVhbS5lbmQgLSBmcm9tID4gcGFyc2VyLmJ1ZmZlckxlbmd0aCAqIDRcbiAgICAgICAgICAgID8gbmV3IEZyYWdtZW50Q3Vyc29yKGZyYWdtZW50cywgcGFyc2VyLm5vZGVTZXQpIDogbnVsbDtcbiAgICB9XG4gICAgZ2V0IHBhcnNlZFBvcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWluU3RhY2tQb3M7XG4gICAgfVxuICAgIC8vIE1vdmUgdGhlIHBhcnNlciBmb3J3YXJkLiBUaGlzIHdpbGwgcHJvY2VzcyBhbGwgcGFyc2Ugc3RhY2tzIGF0XG4gICAgLy8gYHRoaXMucG9zYCBhbmQgdHJ5IHRvIGFkdmFuY2UgdGhlbSB0byBhIGZ1cnRoZXIgcG9zaXRpb24uIElmIG5vXG4gICAgLy8gc3RhY2sgZm9yIHN1Y2ggYSBwb3NpdGlvbiBpcyBmb3VuZCwgaXQnbGwgc3RhcnQgZXJyb3ItcmVjb3ZlcnkuXG4gICAgLy9cbiAgICAvLyBXaGVuIHRoZSBwYXJzZSBpcyBmaW5pc2hlZCwgdGhpcyB3aWxsIHJldHVybiBhIHN5bnRheCB0cmVlLiBXaGVuXG4gICAgLy8gbm90LCBpdCByZXR1cm5zIGBudWxsYC5cbiAgICBhZHZhbmNlKCkge1xuICAgICAgICBsZXQgc3RhY2tzID0gdGhpcy5zdGFja3MsIHBvcyA9IHRoaXMubWluU3RhY2tQb3M7XG4gICAgICAgIC8vIFRoaXMgd2lsbCBob2xkIHN0YWNrcyBiZXlvbmQgYHBvc2AuXG4gICAgICAgIGxldCBuZXdTdGFja3MgPSB0aGlzLnN0YWNrcyA9IFtdO1xuICAgICAgICBsZXQgc3RvcHBlZCwgc3RvcHBlZFRva2VucztcbiAgICAgICAgLy8gSWYgYSBsYXJnZSBhbW91bnQgb2YgcmVkdWN0aW9ucyBoYXBwZW5lZCB3aXRoIHRoZSBzYW1lIHN0YXJ0XG4gICAgICAgIC8vIHBvc2l0aW9uLCBmb3JjZSB0aGUgc3RhY2sgb3V0IG9mIHRoYXQgcHJvZHVjdGlvbiBpbiBvcmRlciB0b1xuICAgICAgICAvLyBhdm9pZCBjcmVhdGluZyBhIHRyZWUgdG9vIGRlZXAgdG8gcmVjdXJzZSB0aHJvdWdoLlxuICAgICAgICAvLyAoVGhpcyBpcyBhbiB1Z2x5IGtsdWRnZSwgYmVjYXVzZSB1bmZvcnR1bmF0ZWx5IHRoZXJlIGlzIG5vXG4gICAgICAgIC8vIHN0cmFpZ2h0Zm9yd2FyZCwgY2hlYXAgd2F5IHRvIGNoZWNrIGZvciB0aGlzIGhhcHBlbmluZywgZHVlIHRvXG4gICAgICAgIC8vIHRoZSBoaXN0b3J5IG9mIHJlZHVjdGlvbnMgb25seSBiZWluZyBhdmFpbGFibGUgaW4gYW5cbiAgICAgICAgLy8gZXhwZW5zaXZlLXRvLWFjY2VzcyBmb3JtYXQgaW4gdGhlIHN0YWNrIGJ1ZmZlcnMuKVxuICAgICAgICBpZiAodGhpcy5iaWdSZWR1Y3Rpb25Db3VudCA+IDMwMCAvKiBSZWMuTWF4TGVmdEFzc29jaWF0aXZlUmVkdWN0aW9uQ291bnQgKi8gJiYgc3RhY2tzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICBsZXQgW3NdID0gc3RhY2tzO1xuICAgICAgICAgICAgd2hpbGUgKHMuZm9yY2VSZWR1Y2UoKSAmJiBzLnN0YWNrLmxlbmd0aCAmJiBzLnN0YWNrW3Muc3RhY2subGVuZ3RoIC0gMl0gPj0gdGhpcy5sYXN0QmlnUmVkdWN0aW9uU3RhcnQpIHsgfVxuICAgICAgICAgICAgdGhpcy5iaWdSZWR1Y3Rpb25Db3VudCA9IHRoaXMubGFzdEJpZ1JlZHVjdGlvblNpemUgPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIEtlZXAgYWR2YW5jaW5nIGFueSBzdGFja3MgYXQgYHBvc2AgdW50aWwgdGhleSBlaXRoZXIgbW92ZVxuICAgICAgICAvLyBmb3J3YXJkIG9yIGNhbid0IGJlIGFkdmFuY2VkLiBHYXRoZXIgc3RhY2tzIHRoYXQgY2FuJ3QgYmVcbiAgICAgICAgLy8gYWR2YW5jZWQgZnVydGhlciBpbiBgc3RvcHBlZGAuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgc3RhY2sgPSBzdGFja3NbaV07XG4gICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgdGhpcy50b2tlbnMubWFpblRva2VuID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoc3RhY2sucG9zID4gcG9zKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1N0YWNrcy5wdXNoKHN0YWNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5hZHZhbmNlU3RhY2soc3RhY2ssIG5ld1N0YWNrcywgc3RhY2tzKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc3RvcHBlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcHBlZCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcHBlZFRva2VucyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN0b3BwZWQucHVzaChzdGFjayk7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0b2sgPSB0aGlzLnRva2Vucy5nZXRNYWluVG9rZW4oc3RhY2spO1xuICAgICAgICAgICAgICAgICAgICBzdG9wcGVkVG9rZW5zLnB1c2godG9rLnZhbHVlLCB0b2suZW5kKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFuZXdTdGFja3MubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgZmluaXNoZWQgPSBzdG9wcGVkICYmIGZpbmRGaW5pc2hlZChzdG9wcGVkKTtcbiAgICAgICAgICAgIGlmIChmaW5pc2hlZCkge1xuICAgICAgICAgICAgICAgIGlmICh2ZXJib3NlKVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkZpbmlzaCB3aXRoIFwiICsgdGhpcy5zdGFja0lEKGZpbmlzaGVkKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhY2tUb1RyZWUoZmluaXNoZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMucGFyc2VyLnN0cmljdCkge1xuICAgICAgICAgICAgICAgIGlmICh2ZXJib3NlICYmIHN0b3BwZWQpXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiU3R1Y2sgd2l0aCB0b2tlbiBcIiArICh0aGlzLnRva2Vucy5tYWluVG9rZW4gPyB0aGlzLnBhcnNlci5nZXROYW1lKHRoaXMudG9rZW5zLm1haW5Ub2tlbi52YWx1ZSkgOiBcIm5vbmVcIikpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIk5vIHBhcnNlIGF0IFwiICsgcG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5yZWNvdmVyaW5nKVxuICAgICAgICAgICAgICAgIHRoaXMucmVjb3ZlcmluZyA9IDUgLyogUmVjLkRpc3RhbmNlICovO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJlY292ZXJpbmcgJiYgc3RvcHBlZCkge1xuICAgICAgICAgICAgbGV0IGZpbmlzaGVkID0gdGhpcy5zdG9wcGVkQXQgIT0gbnVsbCAmJiBzdG9wcGVkWzBdLnBvcyA+IHRoaXMuc3RvcHBlZEF0ID8gc3RvcHBlZFswXVxuICAgICAgICAgICAgICAgIDogdGhpcy5ydW5SZWNvdmVyeShzdG9wcGVkLCBzdG9wcGVkVG9rZW5zLCBuZXdTdGFja3MpO1xuICAgICAgICAgICAgaWYgKGZpbmlzaGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRm9yY2UtZmluaXNoIFwiICsgdGhpcy5zdGFja0lEKGZpbmlzaGVkKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhY2tUb1RyZWUoZmluaXNoZWQuZm9yY2VBbGwoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmVjb3ZlcmluZykge1xuICAgICAgICAgICAgbGV0IG1heFJlbWFpbmluZyA9IHRoaXMucmVjb3ZlcmluZyA9PSAxID8gMSA6IHRoaXMucmVjb3ZlcmluZyAqIDMgLyogUmVjLk1heFJlbWFpbmluZ1BlclN0ZXAgKi87XG4gICAgICAgICAgICBpZiAobmV3U3RhY2tzLmxlbmd0aCA+IG1heFJlbWFpbmluZykge1xuICAgICAgICAgICAgICAgIG5ld1N0YWNrcy5zb3J0KChhLCBiKSA9PiBiLnNjb3JlIC0gYS5zY29yZSk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKG5ld1N0YWNrcy5sZW5ndGggPiBtYXhSZW1haW5pbmcpXG4gICAgICAgICAgICAgICAgICAgIG5ld1N0YWNrcy5wb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXdTdGFja3Muc29tZShzID0+IHMucmVkdWNlUG9zID4gcG9zKSlcbiAgICAgICAgICAgICAgICB0aGlzLnJlY292ZXJpbmctLTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuZXdTdGFja3MubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgLy8gUHJ1bmUgc3RhY2tzIHRoYXQgYXJlIGluIHRoZSBzYW1lIHN0YXRlLCBvciB0aGF0IGhhdmUgYmVlblxuICAgICAgICAgICAgLy8gcnVubmluZyB3aXRob3V0IHNwbGl0dGluZyBmb3IgYSB3aGlsZSwgdG8gYXZvaWQgZ2V0dGluZyBzdHVja1xuICAgICAgICAgICAgLy8gd2l0aCBtdWx0aXBsZSBzdWNjZXNzZnVsIHN0YWNrcyBydW5uaW5nIGVuZGxlc3NseSBvbi5cbiAgICAgICAgICAgIG91dGVyOiBmb3IgKGxldCBpID0gMDsgaSA8IG5ld1N0YWNrcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgc3RhY2sgPSBuZXdTdGFja3NbaV07XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IGkgKyAxOyBqIDwgbmV3U3RhY2tzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBvdGhlciA9IG5ld1N0YWNrc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YWNrLnNhbWVTdGF0ZShvdGhlcikgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLmJ1ZmZlci5sZW5ndGggPiA1MDAgLyogUmVjLk1pbkJ1ZmZlckxlbmd0aFBydW5lICovICYmIG90aGVyLmJ1ZmZlci5sZW5ndGggPiA1MDAgLyogUmVjLk1pbkJ1ZmZlckxlbmd0aFBydW5lICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKChzdGFjay5zY29yZSAtIG90aGVyLnNjb3JlKSB8fCAoc3RhY2suYnVmZmVyLmxlbmd0aCAtIG90aGVyLmJ1ZmZlci5sZW5ndGgpKSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdTdGFja3Muc3BsaWNlKGotLSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdTdGFja3Muc3BsaWNlKGktLSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV3U3RhY2tzLmxlbmd0aCA+IDEyIC8qIFJlYy5NYXhTdGFja0NvdW50ICovKVxuICAgICAgICAgICAgICAgIG5ld1N0YWNrcy5zcGxpY2UoMTIgLyogUmVjLk1heFN0YWNrQ291bnQgKi8sIG5ld1N0YWNrcy5sZW5ndGggLSAxMiAvKiBSZWMuTWF4U3RhY2tDb3VudCAqLyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5taW5TdGFja1BvcyA9IG5ld1N0YWNrc1swXS5wb3M7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbmV3U3RhY2tzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKG5ld1N0YWNrc1tpXS5wb3MgPCB0aGlzLm1pblN0YWNrUG9zKVxuICAgICAgICAgICAgICAgIHRoaXMubWluU3RhY2tQb3MgPSBuZXdTdGFja3NbaV0ucG9zO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgc3RvcEF0KHBvcykge1xuICAgICAgICBpZiAodGhpcy5zdG9wcGVkQXQgIT0gbnVsbCAmJiB0aGlzLnN0b3BwZWRBdCA8IHBvcylcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQ2FuJ3QgbW92ZSBzdG9wcGVkQXQgZm9yd2FyZFwiKTtcbiAgICAgICAgdGhpcy5zdG9wcGVkQXQgPSBwb3M7XG4gICAgfVxuICAgIC8vIFJldHVybnMgYW4gdXBkYXRlZCB2ZXJzaW9uIG9mIHRoZSBnaXZlbiBzdGFjaywgb3IgbnVsbCBpZiB0aGVcbiAgICAvLyBzdGFjayBjYW4ndCBhZHZhbmNlIG5vcm1hbGx5LiBXaGVuIGBzcGxpdGAgYW5kIGBzdGFja3NgIGFyZVxuICAgIC8vIGdpdmVuLCBzdGFja3Mgc3BsaXQgb2ZmIGJ5IGFtYmlndW91cyBvcGVyYXRpb25zIHdpbGwgYmUgcHVzaGVkIHRvXG4gICAgLy8gYHNwbGl0YCwgb3IgYWRkZWQgdG8gYHN0YWNrc2AgaWYgdGhleSBtb3ZlIGBwb3NgIGZvcndhcmQuXG4gICAgYWR2YW5jZVN0YWNrKHN0YWNrLCBzdGFja3MsIHNwbGl0KSB7XG4gICAgICAgIGxldCBzdGFydCA9IHN0YWNrLnBvcywgeyBwYXJzZXIgfSA9IHRoaXM7XG4gICAgICAgIGxldCBiYXNlID0gdmVyYm9zZSA/IHRoaXMuc3RhY2tJRChzdGFjaykgKyBcIiAtPiBcIiA6IFwiXCI7XG4gICAgICAgIGlmICh0aGlzLnN0b3BwZWRBdCAhPSBudWxsICYmIHN0YXJ0ID4gdGhpcy5zdG9wcGVkQXQpXG4gICAgICAgICAgICByZXR1cm4gc3RhY2suZm9yY2VSZWR1Y2UoKSA/IHN0YWNrIDogbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuZnJhZ21lbnRzKSB7XG4gICAgICAgICAgICBsZXQgc3RyaWN0Q3ggPSBzdGFjay5jdXJDb250ZXh0ICYmIHN0YWNrLmN1ckNvbnRleHQudHJhY2tlci5zdHJpY3QsIGN4SGFzaCA9IHN0cmljdEN4ID8gc3RhY2suY3VyQ29udGV4dC5oYXNoIDogMDtcbiAgICAgICAgICAgIGZvciAobGV0IGNhY2hlZCA9IHRoaXMuZnJhZ21lbnRzLm5vZGVBdChzdGFydCk7IGNhY2hlZDspIHtcbiAgICAgICAgICAgICAgICBsZXQgbWF0Y2ggPSB0aGlzLnBhcnNlci5ub2RlU2V0LnR5cGVzW2NhY2hlZC50eXBlLmlkXSA9PSBjYWNoZWQudHlwZSA/IHBhcnNlci5nZXRHb3RvKHN0YWNrLnN0YXRlLCBjYWNoZWQudHlwZS5pZCkgOiAtMTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2ggPiAtMSAmJiBjYWNoZWQubGVuZ3RoICYmICghc3RyaWN0Q3ggfHwgKGNhY2hlZC5wcm9wKE5vZGVQcm9wLmNvbnRleHRIYXNoKSB8fCAwKSA9PSBjeEhhc2gpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLnVzZU5vZGUoY2FjaGVkLCBtYXRjaCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2ZXJib3NlKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYmFzZSArIHRoaXMuc3RhY2tJRChzdGFjaykgKyBgICh2aWEgcmV1c2Ugb2YgJHtwYXJzZXIuZ2V0TmFtZShjYWNoZWQudHlwZS5pZCl9KWApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCEoY2FjaGVkIGluc3RhbmNlb2YgVHJlZSkgfHwgY2FjaGVkLmNoaWxkcmVuLmxlbmd0aCA9PSAwIHx8IGNhY2hlZC5wb3NpdGlvbnNbMF0gPiAwKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBsZXQgaW5uZXIgPSBjYWNoZWQuY2hpbGRyZW5bMF07XG4gICAgICAgICAgICAgICAgaWYgKGlubmVyIGluc3RhbmNlb2YgVHJlZSAmJiBjYWNoZWQucG9zaXRpb25zWzBdID09IDApXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlZCA9IGlubmVyO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRlZmF1bHRSZWR1Y2UgPSBwYXJzZXIuc3RhdGVTbG90KHN0YWNrLnN0YXRlLCA0IC8qIFBhcnNlU3RhdGUuRGVmYXVsdFJlZHVjZSAqLyk7XG4gICAgICAgIGlmIChkZWZhdWx0UmVkdWNlID4gMCkge1xuICAgICAgICAgICAgc3RhY2sucmVkdWNlKGRlZmF1bHRSZWR1Y2UpO1xuICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYmFzZSArIHRoaXMuc3RhY2tJRChzdGFjaykgKyBgICh2aWEgYWx3YXlzLXJlZHVjZSAke3BhcnNlci5nZXROYW1lKGRlZmF1bHRSZWR1Y2UgJiA2NTUzNSAvKiBBY3Rpb24uVmFsdWVNYXNrICovKX0pYCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhY2suc3RhY2subGVuZ3RoID49IDg0MDAgLyogUmVjLkN1dERlcHRoICovKSB7XG4gICAgICAgICAgICB3aGlsZSAoc3RhY2suc3RhY2subGVuZ3RoID4gNjAwMCAvKiBSZWMuQ3V0VG8gKi8gJiYgc3RhY2suZm9yY2VSZWR1Y2UoKSkgeyB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGFjdGlvbnMgPSB0aGlzLnRva2Vucy5nZXRBY3Rpb25zKHN0YWNrKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhY3Rpb25zLmxlbmd0aDspIHtcbiAgICAgICAgICAgIGxldCBhY3Rpb24gPSBhY3Rpb25zW2krK10sIHRlcm0gPSBhY3Rpb25zW2krK10sIGVuZCA9IGFjdGlvbnNbaSsrXTtcbiAgICAgICAgICAgIGxldCBsYXN0ID0gaSA9PSBhY3Rpb25zLmxlbmd0aCB8fCAhc3BsaXQ7XG4gICAgICAgICAgICBsZXQgbG9jYWxTdGFjayA9IGxhc3QgPyBzdGFjayA6IHN0YWNrLnNwbGl0KCk7XG4gICAgICAgICAgICBsZXQgbWFpbiA9IHRoaXMudG9rZW5zLm1haW5Ub2tlbjtcbiAgICAgICAgICAgIGxvY2FsU3RhY2suYXBwbHkoYWN0aW9uLCB0ZXJtLCBtYWluID8gbWFpbi5zdGFydCA6IGxvY2FsU3RhY2sucG9zLCBlbmQpO1xuICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYmFzZSArIHRoaXMuc3RhY2tJRChsb2NhbFN0YWNrKSArIGAgKHZpYSAkeyhhY3Rpb24gJiA2NTUzNiAvKiBBY3Rpb24uUmVkdWNlRmxhZyAqLykgPT0gMCA/IFwic2hpZnRcIlxuICAgICAgICAgICAgICAgICAgICA6IGByZWR1Y2Ugb2YgJHtwYXJzZXIuZ2V0TmFtZShhY3Rpb24gJiA2NTUzNSAvKiBBY3Rpb24uVmFsdWVNYXNrICovKX1gfSBmb3IgJHtwYXJzZXIuZ2V0TmFtZSh0ZXJtKX0gQCAke3N0YXJ0fSR7bG9jYWxTdGFjayA9PSBzdGFjayA/IFwiXCIgOiBcIiwgc3BsaXRcIn0pYCk7XG4gICAgICAgICAgICBpZiAobGFzdClcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGxvY2FsU3RhY2sucG9zID4gc3RhcnQpXG4gICAgICAgICAgICAgICAgc3RhY2tzLnB1c2gobG9jYWxTdGFjayk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgc3BsaXQucHVzaChsb2NhbFN0YWNrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIEFkdmFuY2UgYSBnaXZlbiBzdGFjayBmb3J3YXJkIGFzIGZhciBhcyBpdCB3aWxsIGdvLiBSZXR1cm5zIHRoZVxuICAgIC8vIChwb3NzaWJseSB1cGRhdGVkKSBzdGFjayBpZiBpdCBnb3Qgc3R1Y2ssIG9yIG51bGwgaWYgaXQgbW92ZWRcbiAgICAvLyBmb3J3YXJkIGFuZCB3YXMgZ2l2ZW4gdG8gYHB1c2hTdGFja0RlZHVwYC5cbiAgICBhZHZhbmNlRnVsbHkoc3RhY2ssIG5ld1N0YWNrcykge1xuICAgICAgICBsZXQgcG9zID0gc3RhY2sucG9zO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuYWR2YW5jZVN0YWNrKHN0YWNrLCBudWxsLCBudWxsKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAoc3RhY2sucG9zID4gcG9zKSB7XG4gICAgICAgICAgICAgICAgcHVzaFN0YWNrRGVkdXAoc3RhY2ssIG5ld1N0YWNrcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcnVuUmVjb3Zlcnkoc3RhY2tzLCB0b2tlbnMsIG5ld1N0YWNrcykge1xuICAgICAgICBsZXQgZmluaXNoZWQgPSBudWxsLCByZXN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBzdGFjayA9IHN0YWNrc1tpXSwgdG9rZW4gPSB0b2tlbnNbaSA8PCAxXSwgdG9rZW5FbmQgPSB0b2tlbnNbKGkgPDwgMSkgKyAxXTtcbiAgICAgICAgICAgIGxldCBiYXNlID0gdmVyYm9zZSA/IHRoaXMuc3RhY2tJRChzdGFjaykgKyBcIiAtPiBcIiA6IFwiXCI7XG4gICAgICAgICAgICBpZiAoc3RhY2suZGVhZEVuZCkge1xuICAgICAgICAgICAgICAgIGlmIChyZXN0YXJ0ZWQpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIHJlc3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgc3RhY2sucmVzdGFydCgpO1xuICAgICAgICAgICAgICAgIGlmICh2ZXJib3NlKVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhiYXNlICsgdGhpcy5zdGFja0lEKHN0YWNrKSArIFwiIChyZXN0YXJ0ZWQpXCIpO1xuICAgICAgICAgICAgICAgIGxldCBkb25lID0gdGhpcy5hZHZhbmNlRnVsbHkoc3RhY2ssIG5ld1N0YWNrcyk7XG4gICAgICAgICAgICAgICAgaWYgKGRvbmUpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGZvcmNlID0gc3RhY2suc3BsaXQoKSwgZm9yY2VCYXNlID0gYmFzZTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBmb3JjZS5mb3JjZVJlZHVjZSgpICYmIGogPCAxMCAvKiBSZWMuRm9yY2VSZWR1Y2VMaW1pdCAqLzsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGZvcmNlQmFzZSArIHRoaXMuc3RhY2tJRChmb3JjZSkgKyBcIiAodmlhIGZvcmNlLXJlZHVjZSlcIik7XG4gICAgICAgICAgICAgICAgbGV0IGRvbmUgPSB0aGlzLmFkdmFuY2VGdWxseShmb3JjZSwgbmV3U3RhY2tzKTtcbiAgICAgICAgICAgICAgICBpZiAoZG9uZSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgICAgIGZvcmNlQmFzZSA9IHRoaXMuc3RhY2tJRChmb3JjZSkgKyBcIiAtPiBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGluc2VydCBvZiBzdGFjay5yZWNvdmVyQnlJbnNlcnQodG9rZW4pKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGJhc2UgKyB0aGlzLnN0YWNrSUQoaW5zZXJ0KSArIFwiICh2aWEgcmVjb3Zlci1pbnNlcnQpXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZUZ1bGx5KGluc2VydCwgbmV3U3RhY2tzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnN0cmVhbS5lbmQgPiBzdGFjay5wb3MpIHtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW5FbmQgPT0gc3RhY2sucG9zKSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuRW5kKys7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gMCAvKiBUZXJtLkVyciAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhY2sucmVjb3ZlckJ5RGVsZXRlKHRva2VuLCB0b2tlbkVuZCk7XG4gICAgICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGJhc2UgKyB0aGlzLnN0YWNrSUQoc3RhY2spICsgYCAodmlhIHJlY292ZXItZGVsZXRlICR7dGhpcy5wYXJzZXIuZ2V0TmFtZSh0b2tlbil9KWApO1xuICAgICAgICAgICAgICAgIHB1c2hTdGFja0RlZHVwKHN0YWNrLCBuZXdTdGFja3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWZpbmlzaGVkIHx8IGZpbmlzaGVkLnNjb3JlIDwgc3RhY2suc2NvcmUpIHtcbiAgICAgICAgICAgICAgICBmaW5pc2hlZCA9IHN0YWNrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaW5pc2hlZDtcbiAgICB9XG4gICAgLy8gQ29udmVydCB0aGUgc3RhY2sncyBidWZmZXIgdG8gYSBzeW50YXggdHJlZS5cbiAgICBzdGFja1RvVHJlZShzdGFjaykge1xuICAgICAgICBzdGFjay5jbG9zZSgpO1xuICAgICAgICByZXR1cm4gVHJlZS5idWlsZCh7IGJ1ZmZlcjogU3RhY2tCdWZmZXJDdXJzb3IuY3JlYXRlKHN0YWNrKSxcbiAgICAgICAgICAgIG5vZGVTZXQ6IHRoaXMucGFyc2VyLm5vZGVTZXQsXG4gICAgICAgICAgICB0b3BJRDogdGhpcy50b3BUZXJtLFxuICAgICAgICAgICAgbWF4QnVmZmVyTGVuZ3RoOiB0aGlzLnBhcnNlci5idWZmZXJMZW5ndGgsXG4gICAgICAgICAgICByZXVzZWQ6IHRoaXMucmV1c2VkLFxuICAgICAgICAgICAgc3RhcnQ6IHRoaXMucmFuZ2VzWzBdLmZyb20sXG4gICAgICAgICAgICBsZW5ndGg6IHN0YWNrLnBvcyAtIHRoaXMucmFuZ2VzWzBdLmZyb20sXG4gICAgICAgICAgICBtaW5SZXBlYXRUeXBlOiB0aGlzLnBhcnNlci5taW5SZXBlYXRUZXJtIH0pO1xuICAgIH1cbiAgICBzdGFja0lEKHN0YWNrKSB7XG4gICAgICAgIGxldCBpZCA9IChzdGFja0lEcyB8fCAoc3RhY2tJRHMgPSBuZXcgV2Vha01hcCkpLmdldChzdGFjayk7XG4gICAgICAgIGlmICghaWQpXG4gICAgICAgICAgICBzdGFja0lEcy5zZXQoc3RhY2ssIGlkID0gU3RyaW5nLmZyb21Db2RlUG9pbnQodGhpcy5uZXh0U3RhY2tJRCsrKSk7XG4gICAgICAgIHJldHVybiBpZCArIHN0YWNrO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHB1c2hTdGFja0RlZHVwKHN0YWNrLCBuZXdTdGFja3MpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5ld1N0YWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgb3RoZXIgPSBuZXdTdGFja3NbaV07XG4gICAgICAgIGlmIChvdGhlci5wb3MgPT0gc3RhY2sucG9zICYmIG90aGVyLnNhbWVTdGF0ZShzdGFjaykpIHtcbiAgICAgICAgICAgIGlmIChuZXdTdGFja3NbaV0uc2NvcmUgPCBzdGFjay5zY29yZSlcbiAgICAgICAgICAgICAgICBuZXdTdGFja3NbaV0gPSBzdGFjaztcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZXdTdGFja3MucHVzaChzdGFjayk7XG59XG5jbGFzcyBEaWFsZWN0IHtcbiAgICBjb25zdHJ1Y3Rvcihzb3VyY2UsIGZsYWdzLCBkaXNhYmxlZCkge1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgdGhpcy5mbGFncyA9IGZsYWdzO1xuICAgICAgICB0aGlzLmRpc2FibGVkID0gZGlzYWJsZWQ7XG4gICAgfVxuICAgIGFsbG93cyh0ZXJtKSB7IHJldHVybiAhdGhpcy5kaXNhYmxlZCB8fCB0aGlzLmRpc2FibGVkW3Rlcm1dID09IDA7IH1cbn1cbmNvbnN0IGlkID0geCA9PiB4O1xuLyoqXG5Db250ZXh0IHRyYWNrZXJzIGFyZSB1c2VkIHRvIHRyYWNrIHN0YXRlZnVsIGNvbnRleHQgKHN1Y2ggYXNcbmluZGVudGF0aW9uIGluIHRoZSBQeXRob24gZ3JhbW1hciwgb3IgcGFyZW50IGVsZW1lbnRzIGluIHRoZSBYTUxcbmdyYW1tYXIpIG5lZWRlZCBieSBleHRlcm5hbCB0b2tlbml6ZXJzLiBZb3UgZGVjbGFyZSB0aGVtIGluIGFcbmdyYW1tYXIgZmlsZSBhcyBgQGNvbnRleHQgZXhwb3J0TmFtZSBmcm9tIFwibW9kdWxlXCJgLlxuXG5Db250ZXh0IHZhbHVlcyBzaG91bGQgYmUgaW1tdXRhYmxlLCBhbmQgY2FuIGJlIHVwZGF0ZWQgKHJlcGxhY2VkKVxub24gc2hpZnQgb3IgcmVkdWNlIGFjdGlvbnMuXG5cblRoZSBleHBvcnQgdXNlZCBpbiBhIGBAY29udGV4dGAgZGVjbGFyYXRpb24gc2hvdWxkIGJlIG9mIHRoaXNcbnR5cGUuXG4qL1xuY2xhc3MgQ29udGV4dFRyYWNrZXIge1xuICAgIC8qKlxuICAgIERlZmluZSBhIGNvbnRleHQgdHJhY2tlci5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHNwZWMpIHtcbiAgICAgICAgdGhpcy5zdGFydCA9IHNwZWMuc3RhcnQ7XG4gICAgICAgIHRoaXMuc2hpZnQgPSBzcGVjLnNoaWZ0IHx8IGlkO1xuICAgICAgICB0aGlzLnJlZHVjZSA9IHNwZWMucmVkdWNlIHx8IGlkO1xuICAgICAgICB0aGlzLnJldXNlID0gc3BlYy5yZXVzZSB8fCBpZDtcbiAgICAgICAgdGhpcy5oYXNoID0gc3BlYy5oYXNoIHx8ICgoKSA9PiAwKTtcbiAgICAgICAgdGhpcy5zdHJpY3QgPSBzcGVjLnN0cmljdCAhPT0gZmFsc2U7XG4gICAgfVxufVxuLyoqXG5Ib2xkcyB0aGUgcGFyc2UgdGFibGVzIGZvciBhIGdpdmVuIGdyYW1tYXIsIGFzIGdlbmVyYXRlZCBieVxuYGxlemVyLWdlbmVyYXRvcmAsIGFuZCBwcm92aWRlcyBbbWV0aG9kc10oI2NvbW1vbi5QYXJzZXIpIHRvIHBhcnNlXG5jb250ZW50IHdpdGguXG4qL1xuY2xhc3MgTFJQYXJzZXIgZXh0ZW5kcyBQYXJzZXIge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3Ioc3BlYykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMud3JhcHBlcnMgPSBbXTtcbiAgICAgICAgaWYgKHNwZWMudmVyc2lvbiAhPSAxNCAvKiBGaWxlLlZlcnNpb24gKi8pXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgUGFyc2VyIHZlcnNpb24gKCR7c3BlYy52ZXJzaW9ufSkgZG9lc24ndCBtYXRjaCBydW50aW1lIHZlcnNpb24gKCR7MTQgLyogRmlsZS5WZXJzaW9uICovfSlgKTtcbiAgICAgICAgbGV0IG5vZGVOYW1lcyA9IHNwZWMubm9kZU5hbWVzLnNwbGl0KFwiIFwiKTtcbiAgICAgICAgdGhpcy5taW5SZXBlYXRUZXJtID0gbm9kZU5hbWVzLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzcGVjLnJlcGVhdE5vZGVDb3VudDsgaSsrKVxuICAgICAgICAgICAgbm9kZU5hbWVzLnB1c2goXCJcIik7XG4gICAgICAgIGxldCB0b3BUZXJtcyA9IE9iamVjdC5rZXlzKHNwZWMudG9wUnVsZXMpLm1hcChyID0+IHNwZWMudG9wUnVsZXNbcl1bMV0pO1xuICAgICAgICBsZXQgbm9kZVByb3BzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZU5hbWVzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgbm9kZVByb3BzLnB1c2goW10pO1xuICAgICAgICBmdW5jdGlvbiBzZXRQcm9wKG5vZGVJRCwgcHJvcCwgdmFsdWUpIHtcbiAgICAgICAgICAgIG5vZGVQcm9wc1tub2RlSURdLnB1c2goW3Byb3AsIHByb3AuZGVzZXJpYWxpemUoU3RyaW5nKHZhbHVlKSldKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3BlYy5ub2RlUHJvcHMpXG4gICAgICAgICAgICBmb3IgKGxldCBwcm9wU3BlYyBvZiBzcGVjLm5vZGVQcm9wcykge1xuICAgICAgICAgICAgICAgIGxldCBwcm9wID0gcHJvcFNwZWNbMF07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgICAgIHByb3AgPSBOb2RlUHJvcFtwcm9wXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHByb3BTcGVjLmxlbmd0aDspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5leHQgPSBwcm9wU3BlY1tpKytdO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRQcm9wKG5leHQsIHByb3AsIHByb3BTcGVjW2krK10pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gcHJvcFNwZWNbaSArIC1uZXh0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAtbmV4dDsgaiA+IDA7IGotLSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRQcm9wKHByb3BTcGVjW2krK10sIHByb3AsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgdGhpcy5ub2RlU2V0ID0gbmV3IE5vZGVTZXQobm9kZU5hbWVzLm1hcCgobmFtZSwgaSkgPT4gTm9kZVR5cGUuZGVmaW5lKHtcbiAgICAgICAgICAgIG5hbWU6IGkgPj0gdGhpcy5taW5SZXBlYXRUZXJtID8gdW5kZWZpbmVkIDogbmFtZSxcbiAgICAgICAgICAgIGlkOiBpLFxuICAgICAgICAgICAgcHJvcHM6IG5vZGVQcm9wc1tpXSxcbiAgICAgICAgICAgIHRvcDogdG9wVGVybXMuaW5kZXhPZihpKSA+IC0xLFxuICAgICAgICAgICAgZXJyb3I6IGkgPT0gMCxcbiAgICAgICAgICAgIHNraXBwZWQ6IHNwZWMuc2tpcHBlZE5vZGVzICYmIHNwZWMuc2tpcHBlZE5vZGVzLmluZGV4T2YoaSkgPiAtMVxuICAgICAgICB9KSkpO1xuICAgICAgICBpZiAoc3BlYy5wcm9wU291cmNlcylcbiAgICAgICAgICAgIHRoaXMubm9kZVNldCA9IHRoaXMubm9kZVNldC5leHRlbmQoLi4uc3BlYy5wcm9wU291cmNlcyk7XG4gICAgICAgIHRoaXMuc3RyaWN0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYnVmZmVyTGVuZ3RoID0gRGVmYXVsdEJ1ZmZlckxlbmd0aDtcbiAgICAgICAgbGV0IHRva2VuQXJyYXkgPSBkZWNvZGVBcnJheShzcGVjLnRva2VuRGF0YSk7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IHNwZWMuY29udGV4dDtcbiAgICAgICAgdGhpcy5zcGVjaWFsaXplclNwZWNzID0gc3BlYy5zcGVjaWFsaXplZCB8fCBbXTtcbiAgICAgICAgdGhpcy5zcGVjaWFsaXplZCA9IG5ldyBVaW50MTZBcnJheSh0aGlzLnNwZWNpYWxpemVyU3BlY3MubGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNwZWNpYWxpemVyU3BlY3MubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB0aGlzLnNwZWNpYWxpemVkW2ldID0gdGhpcy5zcGVjaWFsaXplclNwZWNzW2ldLnRlcm07XG4gICAgICAgIHRoaXMuc3BlY2lhbGl6ZXJzID0gdGhpcy5zcGVjaWFsaXplclNwZWNzLm1hcChnZXRTcGVjaWFsaXplcik7XG4gICAgICAgIHRoaXMuc3RhdGVzID0gZGVjb2RlQXJyYXkoc3BlYy5zdGF0ZXMsIFVpbnQzMkFycmF5KTtcbiAgICAgICAgdGhpcy5kYXRhID0gZGVjb2RlQXJyYXkoc3BlYy5zdGF0ZURhdGEpO1xuICAgICAgICB0aGlzLmdvdG8gPSBkZWNvZGVBcnJheShzcGVjLmdvdG8pO1xuICAgICAgICB0aGlzLm1heFRlcm0gPSBzcGVjLm1heFRlcm07XG4gICAgICAgIHRoaXMudG9rZW5pemVycyA9IHNwZWMudG9rZW5pemVycy5tYXAodmFsdWUgPT4gdHlwZW9mIHZhbHVlID09IFwibnVtYmVyXCIgPyBuZXcgVG9rZW5Hcm91cCh0b2tlbkFycmF5LCB2YWx1ZSkgOiB2YWx1ZSk7XG4gICAgICAgIHRoaXMudG9wUnVsZXMgPSBzcGVjLnRvcFJ1bGVzO1xuICAgICAgICB0aGlzLmRpYWxlY3RzID0gc3BlYy5kaWFsZWN0cyB8fCB7fTtcbiAgICAgICAgdGhpcy5keW5hbWljUHJlY2VkZW5jZXMgPSBzcGVjLmR5bmFtaWNQcmVjZWRlbmNlcyB8fCBudWxsO1xuICAgICAgICB0aGlzLnRva2VuUHJlY1RhYmxlID0gc3BlYy50b2tlblByZWM7XG4gICAgICAgIHRoaXMudGVybU5hbWVzID0gc3BlYy50ZXJtTmFtZXMgfHwgbnVsbDtcbiAgICAgICAgdGhpcy5tYXhOb2RlID0gdGhpcy5ub2RlU2V0LnR5cGVzLmxlbmd0aCAtIDE7XG4gICAgICAgIHRoaXMuZGlhbGVjdCA9IHRoaXMucGFyc2VEaWFsZWN0KCk7XG4gICAgICAgIHRoaXMudG9wID0gdGhpcy50b3BSdWxlc1tPYmplY3Qua2V5cyh0aGlzLnRvcFJ1bGVzKVswXV07XG4gICAgfVxuICAgIGNyZWF0ZVBhcnNlKGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcykge1xuICAgICAgICBsZXQgcGFyc2UgPSBuZXcgUGFyc2UodGhpcywgaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKTtcbiAgICAgICAgZm9yIChsZXQgdyBvZiB0aGlzLndyYXBwZXJzKVxuICAgICAgICAgICAgcGFyc2UgPSB3KHBhcnNlLCBpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpO1xuICAgICAgICByZXR1cm4gcGFyc2U7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCBhIGdvdG8gdGFibGUgZW50cnkgQGludGVybmFsXG4gICAgKi9cbiAgICBnZXRHb3RvKHN0YXRlLCB0ZXJtLCBsb29zZSA9IGZhbHNlKSB7XG4gICAgICAgIGxldCB0YWJsZSA9IHRoaXMuZ290bztcbiAgICAgICAgaWYgKHRlcm0gPj0gdGFibGVbMF0pXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IHRhYmxlW3Rlcm0gKyAxXTs7KSB7XG4gICAgICAgICAgICBsZXQgZ3JvdXBUYWcgPSB0YWJsZVtwb3MrK10sIGxhc3QgPSBncm91cFRhZyAmIDE7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gdGFibGVbcG9zKytdO1xuICAgICAgICAgICAgaWYgKGxhc3QgJiYgbG9vc2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgICAgIGZvciAobGV0IGVuZCA9IHBvcyArIChncm91cFRhZyA+PiAxKTsgcG9zIDwgZW5kOyBwb3MrKylcbiAgICAgICAgICAgICAgICBpZiAodGFibGVbcG9zXSA9PSBzdGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgICAgIGlmIChsYXN0KVxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBDaGVjayBpZiB0aGlzIHN0YXRlIGhhcyBhbiBhY3Rpb24gZm9yIGEgZ2l2ZW4gdGVybWluYWwgQGludGVybmFsXG4gICAgKi9cbiAgICBoYXNBY3Rpb24oc3RhdGUsIHRlcm1pbmFsKSB7XG4gICAgICAgIGxldCBkYXRhID0gdGhpcy5kYXRhO1xuICAgICAgICBmb3IgKGxldCBzZXQgPSAwOyBzZXQgPCAyOyBzZXQrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuc3RhdGVTbG90KHN0YXRlLCBzZXQgPyAyIC8qIFBhcnNlU3RhdGUuU2tpcCAqLyA6IDEgLyogUGFyc2VTdGF0ZS5BY3Rpb25zICovKSwgbmV4dDs7IGkgKz0gMykge1xuICAgICAgICAgICAgICAgIGlmICgobmV4dCA9IGRhdGFbaV0pID09IDY1NTM1IC8qIFNlcS5FbmQgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFbaSArIDFdID09IDEgLyogU2VxLk5leHQgKi8pXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0ID0gZGF0YVtpID0gcGFpcihkYXRhLCBpICsgMildO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChkYXRhW2kgKyAxXSA9PSAyIC8qIFNlcS5PdGhlciAqLylcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYWlyKGRhdGEsIGkgKyAyKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChuZXh0ID09IHRlcm1pbmFsIHx8IG5leHQgPT0gMCAvKiBUZXJtLkVyciAqLylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhaXIoZGF0YSwgaSArIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRlU2xvdChzdGF0ZSwgc2xvdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZXNbKHN0YXRlICogNiAvKiBQYXJzZVN0YXRlLlNpemUgKi8pICsgc2xvdF07XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGVGbGFnKHN0YXRlLCBmbGFnKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5zdGF0ZVNsb3Qoc3RhdGUsIDAgLyogUGFyc2VTdGF0ZS5GbGFncyAqLykgJiBmbGFnKSA+IDA7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdmFsaWRBY3Rpb24oc3RhdGUsIGFjdGlvbikge1xuICAgICAgICByZXR1cm4gISF0aGlzLmFsbEFjdGlvbnMoc3RhdGUsIGEgPT4gYSA9PSBhY3Rpb24gPyB0cnVlIDogbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgYWxsQWN0aW9ucyhzdGF0ZSwgYWN0aW9uKSB7XG4gICAgICAgIGxldCBkZWZsdCA9IHRoaXMuc3RhdGVTbG90KHN0YXRlLCA0IC8qIFBhcnNlU3RhdGUuRGVmYXVsdFJlZHVjZSAqLyk7XG4gICAgICAgIGxldCByZXN1bHQgPSBkZWZsdCA/IGFjdGlvbihkZWZsdCkgOiB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLnN0YXRlU2xvdChzdGF0ZSwgMSAvKiBQYXJzZVN0YXRlLkFjdGlvbnMgKi8pOyByZXN1bHQgPT0gbnVsbDsgaSArPSAzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kYXRhW2ldID09IDY1NTM1IC8qIFNlcS5FbmQgKi8pIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kYXRhW2kgKyAxXSA9PSAxIC8qIFNlcS5OZXh0ICovKVxuICAgICAgICAgICAgICAgICAgICBpID0gcGFpcih0aGlzLmRhdGEsIGkgKyAyKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0ID0gYWN0aW9uKHBhaXIodGhpcy5kYXRhLCBpICsgMSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgc3RhdGVzIHRoYXQgY2FuIGZvbGxvdyB0aGlzIG9uZSB0aHJvdWdoIHNoaWZ0IGFjdGlvbnMgb3JcbiAgICBnb3RvIGp1bXBzLiBAaW50ZXJuYWxcbiAgICAqL1xuICAgIG5leHRTdGF0ZXMoc3RhdGUpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5zdGF0ZVNsb3Qoc3RhdGUsIDEgLyogUGFyc2VTdGF0ZS5BY3Rpb25zICovKTs7IGkgKz0gMykge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGF0YVtpXSA9PSA2NTUzNSAvKiBTZXEuRW5kICovKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGF0YVtpICsgMV0gPT0gMSAvKiBTZXEuTmV4dCAqLylcbiAgICAgICAgICAgICAgICAgICAgaSA9IHBhaXIodGhpcy5kYXRhLCBpICsgMik7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgodGhpcy5kYXRhW2kgKyAyXSAmICg2NTUzNiAvKiBBY3Rpb24uUmVkdWNlRmxhZyAqLyA+PiAxNikpID09IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSB0aGlzLmRhdGFbaSArIDFdO1xuICAgICAgICAgICAgICAgIGlmICghcmVzdWx0LnNvbWUoKHYsIGkpID0+IChpICYgMSkgJiYgdiA9PSB2YWx1ZSkpXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuZGF0YVtpXSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbmZpZ3VyZSB0aGUgcGFyc2VyLiBSZXR1cm5zIGEgbmV3IHBhcnNlciBpbnN0YW5jZSB0aGF0IGhhcyB0aGVcbiAgICBnaXZlbiBzZXR0aW5ncyBtb2RpZmllZC4gU2V0dGluZ3Mgbm90IHByb3ZpZGVkIGluIGBjb25maWdgIGFyZVxuICAgIGtlcHQgZnJvbSB0aGUgb3JpZ2luYWwgcGFyc2VyLlxuICAgICovXG4gICAgY29uZmlndXJlKGNvbmZpZykge1xuICAgICAgICAvLyBIaWRlb3VzIHJlZmxlY3Rpb24tYmFzZWQga2x1ZGdlIHRvIG1ha2UgaXQgZWFzeSB0byBjcmVhdGUgYVxuICAgICAgICAvLyBzbGlnaHRseSBtb2RpZmllZCBjb3B5IG9mIGEgcGFyc2VyLlxuICAgICAgICBsZXQgY29weSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShMUlBhcnNlci5wcm90b3R5cGUpLCB0aGlzKTtcbiAgICAgICAgaWYgKGNvbmZpZy5wcm9wcylcbiAgICAgICAgICAgIGNvcHkubm9kZVNldCA9IHRoaXMubm9kZVNldC5leHRlbmQoLi4uY29uZmlnLnByb3BzKTtcbiAgICAgICAgaWYgKGNvbmZpZy50b3ApIHtcbiAgICAgICAgICAgIGxldCBpbmZvID0gdGhpcy50b3BSdWxlc1tjb25maWcudG9wXTtcbiAgICAgICAgICAgIGlmICghaW5mbylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgSW52YWxpZCB0b3AgcnVsZSBuYW1lICR7Y29uZmlnLnRvcH1gKTtcbiAgICAgICAgICAgIGNvcHkudG9wID0gaW5mbztcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZmlnLnRva2VuaXplcnMpXG4gICAgICAgICAgICBjb3B5LnRva2VuaXplcnMgPSB0aGlzLnRva2VuaXplcnMubWFwKHQgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBmb3VuZCA9IGNvbmZpZy50b2tlbml6ZXJzLmZpbmQociA9PiByLmZyb20gPT0gdCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvdW5kID8gZm91bmQudG8gOiB0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIGlmIChjb25maWcuc3BlY2lhbGl6ZXJzKSB7XG4gICAgICAgICAgICBjb3B5LnNwZWNpYWxpemVycyA9IHRoaXMuc3BlY2lhbGl6ZXJzLnNsaWNlKCk7XG4gICAgICAgICAgICBjb3B5LnNwZWNpYWxpemVyU3BlY3MgPSB0aGlzLnNwZWNpYWxpemVyU3BlY3MubWFwKChzLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGZvdW5kID0gY29uZmlnLnNwZWNpYWxpemVycy5maW5kKHIgPT4gci5mcm9tID09IHMuZXh0ZXJuYWwpO1xuICAgICAgICAgICAgICAgIGlmICghZm91bmQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICAgICAgICAgIGxldCBzcGVjID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzKSwgeyBleHRlcm5hbDogZm91bmQudG8gfSk7XG4gICAgICAgICAgICAgICAgY29weS5zcGVjaWFsaXplcnNbaV0gPSBnZXRTcGVjaWFsaXplcihzcGVjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3BlYztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25maWcuY29udGV4dFRyYWNrZXIpXG4gICAgICAgICAgICBjb3B5LmNvbnRleHQgPSBjb25maWcuY29udGV4dFRyYWNrZXI7XG4gICAgICAgIGlmIChjb25maWcuZGlhbGVjdClcbiAgICAgICAgICAgIGNvcHkuZGlhbGVjdCA9IHRoaXMucGFyc2VEaWFsZWN0KGNvbmZpZy5kaWFsZWN0KTtcbiAgICAgICAgaWYgKGNvbmZpZy5zdHJpY3QgIT0gbnVsbClcbiAgICAgICAgICAgIGNvcHkuc3RyaWN0ID0gY29uZmlnLnN0cmljdDtcbiAgICAgICAgaWYgKGNvbmZpZy53cmFwKVxuICAgICAgICAgICAgY29weS53cmFwcGVycyA9IGNvcHkud3JhcHBlcnMuY29uY2F0KGNvbmZpZy53cmFwKTtcbiAgICAgICAgaWYgKGNvbmZpZy5idWZmZXJMZW5ndGggIT0gbnVsbClcbiAgICAgICAgICAgIGNvcHkuYnVmZmVyTGVuZ3RoID0gY29uZmlnLmJ1ZmZlckxlbmd0aDtcbiAgICAgICAgcmV0dXJuIGNvcHk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRlbGxzIHlvdSB3aGV0aGVyIGFueSBbcGFyc2Ugd3JhcHBlcnNdKCNsci5QYXJzZXJDb25maWcud3JhcClcbiAgICBhcmUgcmVnaXN0ZXJlZCBmb3IgdGhpcyBwYXJzZXIuXG4gICAgKi9cbiAgICBoYXNXcmFwcGVycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud3JhcHBlcnMubGVuZ3RoID4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJucyB0aGUgbmFtZSBhc3NvY2lhdGVkIHdpdGggYSBnaXZlbiB0ZXJtLiBUaGlzIHdpbGwgb25seVxuICAgIHdvcmsgZm9yIGFsbCB0ZXJtcyB3aGVuIHRoZSBwYXJzZXIgd2FzIGdlbmVyYXRlZCB3aXRoIHRoZVxuICAgIGAtLW5hbWVzYCBvcHRpb24uIEJ5IGRlZmF1bHQsIG9ubHkgdGhlIG5hbWVzIG9mIHRhZ2dlZCB0ZXJtcyBhcmVcbiAgICBzdG9yZWQuXG4gICAgKi9cbiAgICBnZXROYW1lKHRlcm0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGVybU5hbWVzID8gdGhpcy50ZXJtTmFtZXNbdGVybV0gOiBTdHJpbmcodGVybSA8PSB0aGlzLm1heE5vZGUgJiYgdGhpcy5ub2RlU2V0LnR5cGVzW3Rlcm1dLm5hbWUgfHwgdGVybSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBlb2YgdGVybSBpZCBpcyBhbHdheXMgYWxsb2NhdGVkIGRpcmVjdGx5IGFmdGVyIHRoZSBub2RlXG4gICAgdHlwZXMuIEBpbnRlcm5hbFxuICAgICovXG4gICAgZ2V0IGVvZlRlcm0oKSB7IHJldHVybiB0aGlzLm1heE5vZGUgKyAxOyB9XG4gICAgLyoqXG4gICAgVGhlIHR5cGUgb2YgdG9wIG5vZGUgcHJvZHVjZWQgYnkgdGhlIHBhcnNlci5cbiAgICAqL1xuICAgIGdldCB0b3BOb2RlKCkgeyByZXR1cm4gdGhpcy5ub2RlU2V0LnR5cGVzW3RoaXMudG9wWzFdXTsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZHluYW1pY1ByZWNlZGVuY2UodGVybSkge1xuICAgICAgICBsZXQgcHJlYyA9IHRoaXMuZHluYW1pY1ByZWNlZGVuY2VzO1xuICAgICAgICByZXR1cm4gcHJlYyA9PSBudWxsID8gMCA6IHByZWNbdGVybV0gfHwgMDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBwYXJzZURpYWxlY3QoZGlhbGVjdCkge1xuICAgICAgICBsZXQgdmFsdWVzID0gT2JqZWN0LmtleXModGhpcy5kaWFsZWN0cyksIGZsYWdzID0gdmFsdWVzLm1hcCgoKSA9PiBmYWxzZSk7XG4gICAgICAgIGlmIChkaWFsZWN0KVxuICAgICAgICAgICAgZm9yIChsZXQgcGFydCBvZiBkaWFsZWN0LnNwbGl0KFwiIFwiKSkge1xuICAgICAgICAgICAgICAgIGxldCBpZCA9IHZhbHVlcy5pbmRleE9mKHBhcnQpO1xuICAgICAgICAgICAgICAgIGlmIChpZCA+PSAwKVxuICAgICAgICAgICAgICAgICAgICBmbGFnc1tpZF0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICBsZXQgZGlzYWJsZWQgPSBudWxsO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmICghZmxhZ3NbaV0pIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gdGhpcy5kaWFsZWN0c1t2YWx1ZXNbaV1dLCBpZDsgKGlkID0gdGhpcy5kYXRhW2orK10pICE9IDY1NTM1IC8qIFNlcS5FbmQgKi87KVxuICAgICAgICAgICAgICAgICAgICAoZGlzYWJsZWQgfHwgKGRpc2FibGVkID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5tYXhUZXJtICsgMSkpKVtpZF0gPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IERpYWxlY3QoZGlhbGVjdCwgZmxhZ3MsIGRpc2FibGVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVXNlZCBieSB0aGUgb3V0cHV0IG9mIHRoZSBwYXJzZXIgZ2VuZXJhdG9yLiBOb3QgYXZhaWxhYmxlIHRvXG4gICAgdXNlciBjb2RlLiBAaGlkZVxuICAgICovXG4gICAgc3RhdGljIGRlc2VyaWFsaXplKHNwZWMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMUlBhcnNlcihzcGVjKTtcbiAgICB9XG59XG5mdW5jdGlvbiBwYWlyKGRhdGEsIG9mZikgeyByZXR1cm4gZGF0YVtvZmZdIHwgKGRhdGFbb2ZmICsgMV0gPDwgMTYpOyB9XG5mdW5jdGlvbiBmaW5kRmluaXNoZWQoc3RhY2tzKSB7XG4gICAgbGV0IGJlc3QgPSBudWxsO1xuICAgIGZvciAobGV0IHN0YWNrIG9mIHN0YWNrcykge1xuICAgICAgICBsZXQgc3RvcHBlZCA9IHN0YWNrLnAuc3RvcHBlZEF0O1xuICAgICAgICBpZiAoKHN0YWNrLnBvcyA9PSBzdGFjay5wLnN0cmVhbS5lbmQgfHwgc3RvcHBlZCAhPSBudWxsICYmIHN0YWNrLnBvcyA+IHN0b3BwZWQpICYmXG4gICAgICAgICAgICBzdGFjay5wLnBhcnNlci5zdGF0ZUZsYWcoc3RhY2suc3RhdGUsIDIgLyogU3RhdGVGbGFnLkFjY2VwdGluZyAqLykgJiZcbiAgICAgICAgICAgICghYmVzdCB8fCBiZXN0LnNjb3JlIDwgc3RhY2suc2NvcmUpKVxuICAgICAgICAgICAgYmVzdCA9IHN0YWNrO1xuICAgIH1cbiAgICByZXR1cm4gYmVzdDtcbn1cbmZ1bmN0aW9uIGdldFNwZWNpYWxpemVyKHNwZWMpIHtcbiAgICBpZiAoc3BlYy5leHRlcm5hbCkge1xuICAgICAgICBsZXQgbWFzayA9IHNwZWMuZXh0ZW5kID8gMSAvKiBTcGVjaWFsaXplLkV4dGVuZCAqLyA6IDAgLyogU3BlY2lhbGl6ZS5TcGVjaWFsaXplICovO1xuICAgICAgICByZXR1cm4gKHZhbHVlLCBzdGFjaykgPT4gKHNwZWMuZXh0ZXJuYWwodmFsdWUsIHN0YWNrKSA8PCAxKSB8IG1hc2s7XG4gICAgfVxuICAgIHJldHVybiBzcGVjLmdldDtcbn1cblxuZXhwb3J0IHsgQ29udGV4dFRyYWNrZXIsIEV4dGVybmFsVG9rZW5pemVyLCBJbnB1dFN0cmVhbSwgTFJQYXJzZXIsIExvY2FsVG9rZW5Hcm91cCwgU3RhY2sgfTtcbiJdLCJuYW1lcyI6WyJQYXJzZXIiLCJOb2RlUHJvcCIsIk5vZGVTZXQiLCJOb2RlVHlwZSIsIkRlZmF1bHRCdWZmZXJMZW5ndGgiLCJUcmVlIiwiSXRlck1vZGUiLCJTdGFjayIsImNvbnN0cnVjdG9yIiwicCIsInN0YWNrIiwic3RhdGUiLCJyZWR1Y2VQb3MiLCJwb3MiLCJzY29yZSIsImJ1ZmZlciIsImJ1ZmZlckJhc2UiLCJjdXJDb250ZXh0IiwibG9va0FoZWFkIiwicGFyZW50IiwidG9TdHJpbmciLCJmaWx0ZXIiLCJfIiwiaSIsImNvbmNhdCIsInN0YXJ0IiwiY3giLCJwYXJzZXIiLCJjb250ZXh0IiwiU3RhY2tDb250ZXh0IiwicHVzaFN0YXRlIiwicHVzaCIsImxlbmd0aCIsInJlZHVjZSIsImFjdGlvbiIsIl9hIiwiZGVwdGgiLCJ0eXBlIiwiZFByZWMiLCJkeW5hbWljUHJlY2VkZW5jZSIsImdldEdvdG8iLCJtaW5SZXBlYXRUZXJtIiwic3RvcmVOb2RlIiwicmVkdWNlQ29udGV4dCIsImJhc2UiLCJyYW5nZXMiLCJmcm9tIiwic2l6ZSIsIm5vZGVTZXQiLCJ0eXBlcyIsImlzQW5vbnltb3VzIiwibGFzdEJpZ1JlZHVjdGlvblN0YXJ0IiwiYmlnUmVkdWN0aW9uQ291bnQiLCJsYXN0QmlnUmVkdWN0aW9uU2l6ZSIsImNvdW50Iiwic3RhdGVGbGFnIiwiYmFzZVN0YXRlSUQiLCJwb3AiLCJ0ZXJtIiwiZW5kIiwiaXNSZWR1Y2UiLCJjdXIiLCJ0b3AiLCJpbmRleCIsInNoaWZ0IiwibmV4dFN0YXRlIiwibWF4Tm9kZSIsInNoaWZ0Q29udGV4dCIsImFwcGx5IiwibmV4dCIsIm5leHRTdGFydCIsIm5leHRFbmQiLCJ1c2VOb2RlIiwidmFsdWUiLCJyZXVzZWQiLCJ1cGRhdGVDb250ZXh0IiwidHJhY2tlciIsInJldXNlIiwic3RyZWFtIiwicmVzZXQiLCJzcGxpdCIsIm9mZiIsInNsaWNlIiwicmVjb3ZlckJ5RGVsZXRlIiwiaXNOb2RlIiwiY2FuU2hpZnQiLCJzaW0iLCJTaW11bGF0ZWRTdGFjayIsInN0YXRlU2xvdCIsImhhc0FjdGlvbiIsInJlY292ZXJCeUluc2VydCIsIm5leHRTdGF0ZXMiLCJiZXN0IiwicyIsInNvbWUiLCJ2IiwicmVzdWx0IiwiZm9yY2VSZWR1Y2UiLCJ2YWxpZEFjdGlvbiIsInRhcmdldCIsImJhY2t1cCIsImZpbmRGb3JjZWRSZWR1Y3Rpb24iLCJzZWVuIiwiZXhwbG9yZSIsImluY2x1ZGVzIiwiYWxsQWN0aW9ucyIsInJEZXB0aCIsImZvdW5kIiwiZm9yY2VBbGwiLCJkZWFkRW5kIiwiZGF0YSIsInJlc3RhcnQiLCJzYW1lU3RhdGUiLCJvdGhlciIsImRpYWxlY3RFbmFibGVkIiwiZGlhbGVjdElEIiwiZGlhbGVjdCIsImZsYWdzIiwiZW1pdENvbnRleHQiLCJsYXN0IiwiaGFzaCIsImVtaXRMb29rQWhlYWQiLCJuZXdDeCIsInNldExvb2tBaGVhZCIsImNsb3NlIiwic3RyaWN0IiwiZ290byIsIlN0YWNrQnVmZmVyQ3Vyc29yIiwibWF5YmVOZXh0IiwiY3JlYXRlIiwiaWQiLCJmb3JrIiwiZGVjb2RlQXJyYXkiLCJpbnB1dCIsIlR5cGUiLCJVaW50MTZBcnJheSIsImFycmF5Iiwib3V0IiwiY2hhckNvZGVBdCIsInN0b3AiLCJkaWdpdCIsIkNhY2hlZFRva2VuIiwiZXh0ZW5kZWQiLCJtYXNrIiwibnVsbFRva2VuIiwiSW5wdXRTdHJlYW0iLCJjaHVuayIsImNodW5rT2ZmIiwiY2h1bmsyIiwiY2h1bmsyUG9zIiwidG9rZW4iLCJyYW5nZUluZGV4IiwiY2h1bmtQb3MiLCJyYW5nZSIsInRvIiwicmVhZE5leHQiLCJyZXNvbHZlT2Zmc2V0Iiwib2Zmc2V0IiwiYXNzb2MiLCJjbGlwUG9zIiwiTWF0aCIsIm1heCIsInBlZWsiLCJpZHgiLCJyZXNvbHZlZCIsImFjY2VwdFRva2VuIiwiZW5kT2Zmc2V0IiwiUmFuZ2VFcnJvciIsImdldENodW5rIiwibmV4dENodW5rIiwiYWR2YW5jZSIsIm4iLCJzZXREb25lIiwicmVhZCIsInIiLCJtaW4iLCJUb2tlbkdyb3VwIiwicmVhZFRva2VuIiwidG9rZW5QcmVjVGFibGUiLCJwcm90b3R5cGUiLCJjb250ZXh0dWFsIiwiZmFsbGJhY2siLCJleHRlbmQiLCJMb2NhbFRva2VuR3JvdXAiLCJwcmVjVGFibGUiLCJlbHNlVG9rZW4iLCJza2lwcGVkIiwiYXRFb2YiLCJuZXh0UG9zIiwiRXh0ZXJuYWxUb2tlbml6ZXIiLCJvcHRpb25zIiwiZ3JvdXAiLCJwcmVjT2Zmc2V0IiwiZ3JvdXBNYXNrIiwic2NhbiIsImFjY0VuZCIsImFsbG93cyIsIm92ZXJyaWRlcyIsImxvdyIsImhpZ2giLCJtaWQiLCJmaW5kT2Zmc2V0IiwicHJldiIsInRhYmxlRGF0YSIsInRhYmxlT2Zmc2V0IiwiaVByZXYiLCJ2ZXJib3NlIiwicHJvY2VzcyIsImVudiIsInRlc3QiLCJMT0ciLCJzdGFja0lEcyIsImN1dEF0IiwidHJlZSIsInNpZGUiLCJjdXJzb3IiLCJJbmNsdWRlQW5vbnltb3VzIiwibW92ZVRvIiwiY2hpbGRCZWZvcmUiLCJjaGlsZEFmdGVyIiwiaXNFcnJvciIsInByZXZTaWJsaW5nIiwibmV4dFNpYmxpbmciLCJGcmFnbWVudEN1cnNvciIsImZyYWdtZW50cyIsImZyYWdtZW50Iiwic2FmZUZyb20iLCJzYWZlVG8iLCJ0cmVlcyIsIm5leHRGcmFnbWVudCIsImZyIiwib3BlblN0YXJ0Iiwib3BlbkVuZCIsIm5vZGVBdCIsImNoaWxkcmVuIiwicG9zaXRpb25zIiwicHJvcCIsIlRva2VuQ2FjaGUiLCJ0b2tlbnMiLCJtYWluVG9rZW4iLCJhY3Rpb25zIiwidG9rZW5pemVycyIsIm1hcCIsImdldEFjdGlvbnMiLCJhY3Rpb25JbmRleCIsIm1haW4iLCJ0b2tlbml6ZXIiLCJ1cGRhdGVDYWNoZWRUb2tlbiIsInN0YXJ0SW5kZXgiLCJhZGRBY3Rpb25zIiwiZW9mVGVybSIsImdldE1haW5Ub2tlbiIsInNwZWNpYWxpemVkIiwic3BlY2lhbGl6ZXJzIiwicHV0QWN0aW9uIiwic2V0IiwicGFpciIsIlBhcnNlIiwicmVjb3ZlcmluZyIsIm5leHRTdGFja0lEIiwibWluU3RhY2tQb3MiLCJzdG9wcGVkQXQiLCJ0b3BUZXJtIiwic3RhY2tzIiwiYnVmZmVyTGVuZ3RoIiwicGFyc2VkUG9zIiwibmV3U3RhY2tzIiwic3RvcHBlZCIsInN0b3BwZWRUb2tlbnMiLCJhZHZhbmNlU3RhY2siLCJ0b2siLCJmaW5pc2hlZCIsImZpbmRGaW5pc2hlZCIsImNvbnNvbGUiLCJsb2ciLCJzdGFja0lEIiwic3RhY2tUb1RyZWUiLCJnZXROYW1lIiwiU3ludGF4RXJyb3IiLCJydW5SZWNvdmVyeSIsIm1heFJlbWFpbmluZyIsInNvcnQiLCJhIiwiYiIsIm91dGVyIiwiaiIsInNwbGljZSIsInN0b3BBdCIsInN0cmljdEN4IiwiY3hIYXNoIiwiY2FjaGVkIiwibWF0Y2giLCJjb250ZXh0SGFzaCIsImlubmVyIiwiZGVmYXVsdFJlZHVjZSIsImxvY2FsU3RhY2siLCJhZHZhbmNlRnVsbHkiLCJwdXNoU3RhY2tEZWR1cCIsInJlc3RhcnRlZCIsInRva2VuRW5kIiwiZG9uZSIsImZvcmNlIiwiZm9yY2VCYXNlIiwiaW5zZXJ0IiwiYnVpbGQiLCJ0b3BJRCIsIm1heEJ1ZmZlckxlbmd0aCIsIm1pblJlcGVhdFR5cGUiLCJXZWFrTWFwIiwiZ2V0IiwiU3RyaW5nIiwiZnJvbUNvZGVQb2ludCIsIkRpYWxlY3QiLCJzb3VyY2UiLCJkaXNhYmxlZCIsIngiLCJDb250ZXh0VHJhY2tlciIsInNwZWMiLCJMUlBhcnNlciIsIndyYXBwZXJzIiwidmVyc2lvbiIsIm5vZGVOYW1lcyIsInJlcGVhdE5vZGVDb3VudCIsInRvcFRlcm1zIiwiT2JqZWN0Iiwia2V5cyIsInRvcFJ1bGVzIiwibm9kZVByb3BzIiwic2V0UHJvcCIsIm5vZGVJRCIsImRlc2VyaWFsaXplIiwicHJvcFNwZWMiLCJuYW1lIiwiZGVmaW5lIiwidW5kZWZpbmVkIiwicHJvcHMiLCJpbmRleE9mIiwiZXJyb3IiLCJza2lwcGVkTm9kZXMiLCJwcm9wU291cmNlcyIsInRva2VuQXJyYXkiLCJ0b2tlbkRhdGEiLCJzcGVjaWFsaXplclNwZWNzIiwiZ2V0U3BlY2lhbGl6ZXIiLCJzdGF0ZXMiLCJVaW50MzJBcnJheSIsInN0YXRlRGF0YSIsIm1heFRlcm0iLCJkaWFsZWN0cyIsImR5bmFtaWNQcmVjZWRlbmNlcyIsInRva2VuUHJlYyIsInRlcm1OYW1lcyIsInBhcnNlRGlhbGVjdCIsImNyZWF0ZVBhcnNlIiwicGFyc2UiLCJ3IiwibG9vc2UiLCJ0YWJsZSIsImdyb3VwVGFnIiwidGVybWluYWwiLCJzbG90IiwiZmxhZyIsImRlZmx0IiwiY29uZmlndXJlIiwiY29uZmlnIiwiY29weSIsImFzc2lnbiIsImluZm8iLCJ0IiwiZmluZCIsImV4dGVybmFsIiwiY29udGV4dFRyYWNrZXIiLCJ3cmFwIiwiaGFzV3JhcHBlcnMiLCJ0b3BOb2RlIiwicHJlYyIsInZhbHVlcyIsInBhcnQiLCJVaW50OEFycmF5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lezer/lr/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lezer/python/dist/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@lezer/python/dist/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parser: () => (/* binding */ parser)\n/* harmony export */ });\n/* harmony import */ var _lezer_lr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/lr */ \"(ssr)/./node_modules/@lezer/lr/dist/index.js\");\n/* harmony import */ var _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lezer/highlight */ \"(ssr)/./node_modules/@lezer/highlight/dist/index.js\");\n\n\n// This file was generated by lezer-generator. You probably shouldn't edit it.\nconst printKeyword = 1, indent = 201, dedent = 202, newline$1 = 203, blankLineStart = 204, newlineBracketed = 205, eof = 206, formatString1Content = 207, formatString1Brace = 2, formatString1End = 208, formatString2Content = 209, formatString2Brace = 3, formatString2End = 210, formatString1lContent = 211, formatString1lBrace = 4, formatString1lEnd = 212, formatString2lContent = 213, formatString2lBrace = 5, formatString2lEnd = 214, ParenL = 26, ParenthesizedExpression = 27, TupleExpression = 51, ComprehensionExpression = 52, BracketL = 57, ArrayExpression = 58, ArrayComprehensionExpression = 59, BraceL = 61, DictionaryExpression = 62, DictionaryComprehensionExpression = 63, SetExpression = 64, SetComprehensionExpression = 65, ArgList = 67, subscript = 251, FormatString = 74, importList = 270, TypeParamList = 115, ParamList = 133, SequencePattern = 154, MappingPattern = 155, PatternArgList = 158;\nconst newline = 10, carriageReturn = 13, space = 32, tab = 9, hash = 35, parenOpen = 40, dot = 46, braceOpen = 123, singleQuote = 39, doubleQuote = 34, backslash = 92;\nconst bracketed = new Set([\n    ParenthesizedExpression,\n    TupleExpression,\n    ComprehensionExpression,\n    importList,\n    ArgList,\n    ParamList,\n    ArrayExpression,\n    ArrayComprehensionExpression,\n    subscript,\n    SetExpression,\n    SetComprehensionExpression,\n    FormatString,\n    DictionaryExpression,\n    DictionaryComprehensionExpression,\n    SequencePattern,\n    MappingPattern,\n    PatternArgList,\n    TypeParamList\n]);\nfunction isLineBreak(ch) {\n    return ch == newline || ch == carriageReturn;\n}\nconst newlines = new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.ExternalTokenizer((input, stack)=>{\n    let prev;\n    if (input.next < 0) {\n        input.acceptToken(eof);\n    } else if (stack.context.depth < 0) {\n        if (isLineBreak(input.next)) input.acceptToken(newlineBracketed, 1);\n    } else if (((prev = input.peek(-1)) < 0 || isLineBreak(prev)) && stack.canShift(blankLineStart)) {\n        let spaces = 0;\n        while(input.next == space || input.next == tab){\n            input.advance();\n            spaces++;\n        }\n        if (input.next == newline || input.next == carriageReturn || input.next == hash) input.acceptToken(blankLineStart, -spaces);\n    } else if (isLineBreak(input.next)) {\n        input.acceptToken(newline$1, 1);\n    }\n}, {\n    contextual: true\n});\nconst indentation = new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.ExternalTokenizer((input, stack)=>{\n    let cDepth = stack.context.depth;\n    if (cDepth < 0) return;\n    let prev = input.peek(-1);\n    if (prev == newline || prev == carriageReturn) {\n        let depth = 0, chars = 0;\n        for(;;){\n            if (input.next == space) depth++;\n            else if (input.next == tab) depth += 8 - depth % 8;\n            else break;\n            input.advance();\n            chars++;\n        }\n        if (depth != cDepth && input.next != newline && input.next != carriageReturn && input.next != hash) {\n            if (depth < cDepth) input.acceptToken(dedent, -chars);\n            else input.acceptToken(indent);\n        }\n    }\n});\nfunction IndentLevel(parent, depth) {\n    this.parent = parent;\n    // -1 means this is not an actual indent level but a set of brackets\n    this.depth = depth;\n    this.hash = (parent ? parent.hash + parent.hash << 8 : 0) + depth + (depth << 4);\n}\nconst topIndent = new IndentLevel(null, 0);\nfunction countIndent(space) {\n    let depth = 0;\n    for(let i = 0; i < space.length; i++)depth += space.charCodeAt(i) == tab ? 8 - depth % 8 : 1;\n    return depth;\n}\nconst trackIndent = new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.ContextTracker({\n    start: topIndent,\n    reduce (context, term) {\n        return context.depth < 0 && bracketed.has(term) ? context.parent : context;\n    },\n    shift (context, term, stack, input) {\n        if (term == indent) return new IndentLevel(context, countIndent(input.read(input.pos, stack.pos)));\n        if (term == dedent) return context.parent;\n        if (term == ParenL || term == BracketL || term == BraceL) return new IndentLevel(context, -1);\n        return context;\n    },\n    hash (context) {\n        return context.hash;\n    }\n});\nconst legacyPrint = new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.ExternalTokenizer((input)=>{\n    for(let i = 0; i < 5; i++){\n        if (input.next != \"print\".charCodeAt(i)) return;\n        input.advance();\n    }\n    if (/\\w/.test(String.fromCharCode(input.next))) return;\n    for(let off = 0;; off++){\n        let next = input.peek(off);\n        if (next == space || next == tab) continue;\n        if (next != parenOpen && next != dot && next != newline && next != carriageReturn && next != hash) input.acceptToken(printKeyword);\n        return;\n    }\n});\nfunction formatString(quote, len, content, brace, end) {\n    return new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.ExternalTokenizer((input)=>{\n        let start = input.pos;\n        for(;;){\n            if (input.next < 0) {\n                break;\n            } else if (input.next == braceOpen) {\n                if (input.peek(1) == braceOpen) {\n                    input.advance(2);\n                } else {\n                    if (input.pos == start) {\n                        input.acceptToken(brace, 1);\n                        return;\n                    }\n                    break;\n                }\n            } else if (input.next == backslash) {\n                input.advance();\n                if (input.next >= 0) input.advance();\n            } else if (input.next == quote && (len == 1 || input.peek(1) == quote && input.peek(2) == quote)) {\n                if (input.pos == start) {\n                    input.acceptToken(end, len);\n                    return;\n                }\n                break;\n            } else {\n                input.advance();\n            }\n        }\n        if (input.pos > start) input.acceptToken(content);\n    });\n}\nconst formatString1 = formatString(singleQuote, 1, formatString1Content, formatString1Brace, formatString1End);\nconst formatString2 = formatString(doubleQuote, 1, formatString2Content, formatString2Brace, formatString2End);\nconst formatString1l = formatString(singleQuote, 3, formatString1lContent, formatString1lBrace, formatString1lEnd);\nconst formatString2l = formatString(doubleQuote, 3, formatString2lContent, formatString2lBrace, formatString2lEnd);\nconst pythonHighlighting = (0,_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.styleTags)({\n    'async \"*\" \"**\" FormatConversion FormatSpec': _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.modifier,\n    \"for while if elif else try except finally return raise break continue with pass assert await yield match case\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.controlKeyword,\n    \"in not and or is del\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.operatorKeyword,\n    \"from def class global nonlocal lambda\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definitionKeyword,\n    import: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.moduleKeyword,\n    \"with as print\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.keyword,\n    Boolean: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.bool,\n    None: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.null,\n    VariableName: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.variableName,\n    \"CallExpression/VariableName\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.function(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.variableName),\n    \"FunctionDefinition/VariableName\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.function(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definition(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.variableName)),\n    \"ClassDefinition/VariableName\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definition(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.className),\n    PropertyName: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.propertyName,\n    \"CallExpression/MemberExpression/PropertyName\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.function(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.propertyName),\n    Comment: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.lineComment,\n    Number: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.number,\n    String: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.string,\n    FormatString: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.special(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.string),\n    UpdateOp: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.updateOperator,\n    \"ArithOp!\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.arithmeticOperator,\n    BitOp: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.bitwiseOperator,\n    CompareOp: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.compareOperator,\n    AssignOp: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definitionOperator,\n    Ellipsis: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.punctuation,\n    At: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.meta,\n    \"( )\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.paren,\n    \"[ ]\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.squareBracket,\n    \"{ }\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.brace,\n    \".\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.derefOperator,\n    \", ;\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.separator\n});\n// This file was generated by lezer-generator. You probably shouldn't edit it.\nconst spec_identifier = {\n    __proto__: null,\n    await: 48,\n    or: 58,\n    and: 60,\n    in: 64,\n    not: 66,\n    is: 68,\n    if: 74,\n    else: 76,\n    lambda: 80,\n    yield: 98,\n    from: 100,\n    async: 106,\n    for: 108,\n    None: 168,\n    True: 170,\n    False: 170,\n    del: 184,\n    pass: 188,\n    break: 192,\n    continue: 196,\n    return: 200,\n    raise: 208,\n    import: 212,\n    as: 214,\n    global: 218,\n    nonlocal: 220,\n    assert: 224,\n    type: 229,\n    elif: 242,\n    while: 246,\n    try: 252,\n    except: 254,\n    finally: 256,\n    with: 260,\n    def: 264,\n    class: 274,\n    match: 285,\n    case: 291\n};\nconst parser = _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.LRParser.deserialize({\n    version: 14,\n    states: \"#&jO`Q#yOOP$bOSOOO%kQ&nO'#HcOOQS'#Cq'#CqOOQS'#Cr'#CrO'ZQ#xO'#CpO(|Q&nO'#HbOOQS'#Hc'#HcOOQS'#DW'#DWOOQS'#Hb'#HbO)jQ#xO'#DaO)}Q#xO'#DhO*_Q#xO'#DlOOQS'#Dw'#DwO*rO,UO'#DwO*zO7[O'#DwO+SOWO'#DxO+_O`O'#DxO+jOpO'#DxO+uO!bO'#DxO-wQ&nO'#HSOOQS'#HS'#HSO'ZQ#xO'#HRO/ZQ&nO'#HROOQS'#Ee'#EeO/rQ#xO'#EfOOQS'#HQ'#HQO/|Q#xO'#HPOOQV'#HP'#HPO0XQ#xO'#F]OOQS'#Ge'#GeO0^Q#xO'#F[OOQV'#IY'#IYOOQV'#HO'#HOOOQV'#Ft'#FtQ`Q#yOOO'ZQ#xO'#CsO0lQ#xO'#DPO0sQ#xO'#DTO1RQ#xO'#HgO1cQ&nO'#EYO'ZQ#xO'#EZOOQS'#E]'#E]OOQS'#E_'#E_OOQS'#Ea'#EaO1wQ#xO'#EcO2_Q#xO'#EgO0XQ#xO'#EiO2rQ&nO'#EiO0XQ#xO'#ElO/rQ#xO'#EoO0XQ#xO'#EqO/rQ#xO'#EwO/rQ#xO'#EzO2}Q#xO'#E|O3UQ#xO'#FRO3aQ#xO'#E}O/rQ#xO'#FRO0XQ#xO'#FTO0XQ#xO'#FYO3fQ#xO'#F_P3mO#xO'#G}POOO)CBq)CBqOOQS'#Cg'#CgOOQS'#Ch'#ChOOQS'#Ci'#CiOOQS'#Cj'#CjOOQS'#Ck'#CkOOQS'#Cl'#ClOOQS'#Cn'#CnO'ZQ#xO,59QO'ZQ#xO,59QO'ZQ#xO,59QO'ZQ#xO,59QO'ZQ#xO,59QO'ZQ#xO,59QO3xQ#xO'#DqOOQS,5:[,5:[O4]Q#xO'#HqOOQS,5:_,5:_O4jQMlO,5:_O4oQ&nO,59[O0lQ#xO,59dO0lQ#xO,59dO0lQ#xO,59dO7_Q#xO,59dO7dQ#xO,59dO7kQ#xO,59lO7rQ#xO'#HbO8xQ#xO'#HaOOQS'#Ha'#HaOOQS'#D^'#D^O9aQ#xO,59cO'ZQ#xO,59cO9oQ#xO,59cOOQS,59{,59{O9tQ#xO,5:TO'ZQ#xO,5:TOOQS,5:S,5:SO:SQ#xO,5:SO:XQ#xO,5:ZO'ZQ#xO,5:ZO'ZQ#xO,5:XOOQS,5:W,5:WO:jQ#xO,5:WO:oQ#xO,5:YOOOO'#F|'#F|O:tO,UO,5:cOOQS,5:c,5:cOOOO'#F}'#F}O:|O7[O,5:cO;UQ#xO'#DyOOOW'#GO'#GOO;fOWO,5:dOOQS,5:d,5:dO;UQ#xO'#D}OOO`'#GR'#GRO;qO`O,5:dO;UQ#xO'#EOOOOp'#GS'#GSO;|OpO,5:dO;UQ#xO'#EPOOO!b'#GT'#GTO<XO!bO,5:dOOQS'#GU'#GUO<dQ&nO,5:lO?UQ&nO,5=mO?oQ!LUO,5=mO@`Q&nO,5=mOOQS,5;Q,5;QO@wQ#yO'#G_OBZQ#xO,5;aOOQV,5=k,5=kOBfQ&nO'#ITOB}Q#xO,5;wOOQS-E:c-E:cOOQV,5;v,5;vO3[Q#xO'#FTOOQV-E9r-E9rOCVQ&nO,59_OE^Q&nO,59kOEwQ#xO'#HdOFSQ#xO'#HdO0XQ#xO'#HdOF_Q#xO'#DVOFgQ#xO,59oOFlQ#xO'#HhO'ZQ#xO'#HhO/rQ#xO,5>ROOQS,5>R,5>RO/rQ#xO'#EUOOQS'#EV'#EVOGZQ#xO'#GWOGkQ#xO,59OOGkQ#xO,59OO)pQ#xO,5:rOGyQ&nO'#HjOOQS,5:u,5:uOOQS,5:},5:}OH^Q#xO,5;ROHoQ#xO,5;TOOQS'#GZ'#GZOH}Q&nO,5;TOI]Q#xO,5;TOIbQ#xO'#IWOOQS,5;W,5;WOIpQ#xO'#ISOOQS,5;Z,5;ZOJRQ#xO,5;]O3aQ#xO,5;cO3aQ#xO,5;fOJZQ&nO'#IZO'ZQ#xO'#IZOJeQ#xO,5;hO2}Q#xO,5;hO/rQ#xO,5;mO0XQ#xO,5;oOJjQ#yO'#ExOKvQ#{O,5;iO! [Q#xO'#I[O3aQ#xO,5;mO! gQ#xO,5;oO! oQ#xO,5;tO! zQ&nO,5;yO'ZQ#xO,5;yPOOO,5=i,5=iP!!ROSO,5=iP!!WO#xO,5=iO!${Q&nO1G.lO!%SQ&nO1G.lO!'sQ&nO1G.lO!'}Q&nO1G.lO!*hQ&nO1G.lO!*{Q&nO1G.lO!+`Q#xO'#HpO!+nQ&nO'#HSO/rQ#xO'#HpO!+xQ#xO'#HoOOQS,5:],5:]O!,QQ#xO,5:]O!,VQ#xO'#HrO!,bQ#xO'#HrO!,uQ#xO,5>]OOQS'#Du'#DuOOQS1G/y1G/yOOQS1G/O1G/OO!-uQ&nO1G/OO!-|Q&nO1G/OO0lQ#xO1G/OO!.iQ#xO1G/WOOQS'#D]'#D]O/rQ#xO,59vOOQS1G.}1G.}O!.pQ#xO1G/gO!/QQ#xO1G/gO!/YQ#xO1G/hO'ZQ#xO'#HiO!/_Q#xO'#HiO!/dQ&nO1G.}O!/tQ#xO,59kO!0zQ#xO,5>XO!1[Q#xO,5>XO!1dQ#xO1G/oO!1iQ&nO1G/oOOQS1G/n1G/nO!1yQ#xO,5>SO!2pQ#xO,5>SO/rQ#xO1G/sO!3_Q#xO1G/uO!3dQ&nO1G/uO!3tQ&nO1G/sOOQS1G/r1G/rOOQS1G/t1G/tOOOO-E9z-E9zOOQS1G/}1G/}OOOO-E9{-E9{O!4UQ#xO'#H|O/rQ#xO'#H|O!4dQ#xO,5:eOOOW-E9|-E9|OOQS1G0O1G0OO!4oQ#xO,5:iOOO`-E:P-E:PO!4zQ#xO,5:jOOOp-E:Q-E:QO!5VQ#xO,5:kOOO!b-E:R-E:ROOQS-E:S-E:SO!5bQ!LUO1G3XO!6RQ&nO1G3XO'ZQ#xO,5<qOOQS,5<q,5<qOOQS-E:T-E:TOOQS,5<y,5<yOOQS-E:]-E:]OOQV1G0{1G0{O0XQ#xO'#GYO!6jQ&nO,5>oOOQS1G1c1G1cO!7RQ#xO1G1cOOQS'#DX'#DXO/rQ#xO,5>OOOQS,5>O,5>OO!7WQ#xO'#FuO!7cQ#xO,59qO!7kQ#xO1G/ZO!7uQ&nO,5>SOOQS1G3m1G3mOOQS,5:p,5:pO!8fQ#xO'#HROOQS,5<r,5<rOOQS-E:U-E:UO!8wQ#xO1G.jOOQS1G0^1G0^O!9VQ#xO,5>UO!9gQ#xO,5>UO/rQ#xO1G0mO/rQ#xO1G0mO0XQ#xO1G0oOOQS-E:X-E:XO!9xQ#xO1G0oO!:TQ#xO1G0oO!:YQ#xO,5>rO!:hQ#xO,5>rO!:vQ#xO,5>nO!;^Q#xO,5>nO!;oQ#xO'#EsO/rQ#xO1G0wO!;zQ#xO1G0wO!<PQ#{O1G0}O!?bQ#{O1G1QO!BpQ#xO,5>uO!BzQ#xO,5>uO!CSQ&nO,5>uO/rQ#xO1G1SO!C^Q#xO1G1SO3aQ#xO1G1XO! gQ#xO1G1ZOOQV,5;d,5;dO!CcQ#zO,5;dO!ChQ#{O1G1TO!F|Q#xO'#GbO3aQ#xO1G1TO3aQ#xO1G1TO!G^Q#xO,5>vO!GkQ#xO,5>vO0XQ#xO,5>vOOQV1G1X1G1XO!GsQ#xO'#FVO!HUQMlO1G1ZO!H^Q#xO1G1ZOOQV1G1`1G1`O3aQ#xO1G1`O!HcQ#xO1G1`O!HkQ#xO'#FaOOQV1G1e1G1eO! zQ&nO1G1ePOOO1G3T1G3TP!HpOSO1G3TOOQS,5>[,5>[OOQS'#Dr'#DrO/rQ#xO,5>[O!HuQ#xO,5>ZO!IYQ#xO,5>ZOOQS1G/w1G/wO!IbQ#xO,5>^O!IrQ#xO,5>^O!IzQ#xO,5>^O!J_Q#xO,5>^O!JoQ#xO,5>^OOQS1G3w1G3wOOQS7+$j7+$jO!7kQ#xO7+$rO!LbQ#xO1G/OO!LiQ#xO1G/OOOQS1G/b1G/bOOQS,5<c,5<cO'ZQ#xO,5<cOOQS7+%R7+%RO!LpQ#xO7+%ROOQS-E9u-E9uOOQS7+%S7+%SO!MQQ#xO,5>TO'ZQ#xO,5>TOOQS7+$i7+$iO!MVQ#xO7+%RO!M_Q#xO7+%SO!MdQ#xO1G3sOOQS7+%Z7+%ZO!MtQ#xO1G3sO!M|Q#xO7+%ZOOQS,5<b,5<bO'ZQ#xO,5<bO!NRQ#xO1G3nOOQS-E9t-E9tO!NxQ#xO7+%_OOQS7+%a7+%aO# WQ#xO1G3nO# uQ#xO7+%aO# zQ#xO1G3tO#![Q#xO1G3tO#!dQ#xO7+%_O#!iQ#xO,5>hO##PQ#xO,5>hO##PQ#xO,5>hO##_O$ISO'#D{O##jO#tO'#H}OOOW1G0P1G0PO##oQ#xO1G0POOO`1G0T1G0TO##wQ#xO1G0TOOOp1G0U1G0UO#$PQ#xO1G0UOOO!b1G0V1G0VO#$XQ#xO1G0VO#$aQ!LUO7+(sO#%QQ&nO1G2]P#%kQ#xO'#GVOOQS,5<t,5<tOOQS-E:W-E:WOOQS7+&}7+&}OOQS1G3j1G3jOOQS,5<a,5<aOOQS-E9s-E9sOOQS7+$u7+$uO#%xQ#xO,5=mO#&cQ#xO,5=mO#&tQ&nO,5<dO#'XQ#xO1G3pOOQS-E9v-E9vOOQS7+&X7+&XO#'iQ#xO7+&XOOQS7+&Z7+&ZO#'wQ#xO'#IVO0XQ#xO'#IUO#(]Q#xO7+&ZOOQS,5<w,5<wO#(hQ#xO1G4^OOQS-E:Z-E:ZOOQS,5<s,5<sO#(vQ#xO1G4YOOQS-E:V-E:VO0XQ#xO'#EtO#)^Q#xO'#EtO#)iQ#xO'#IXO#)qQ#xO,5;_OOQS7+&c7+&cO/rQ#xO7+&cO#)vQ#{O7+&iO!GPQ#xO'#G`O3aQ#xO7+&iO3aQ#xO7+&lO#-XQ&nO,5<{O'ZQ#xO,5<{O#-cQ#xO1G4aOOQS-E:_-E:_O#-mQ#xO1G4aO3aQ#xO7+&nO/rQ#xO7+&nOOQV7+&s7+&sO!HUQMlO7+&uO!H^Q#xO7+&uO`Q#yO1G1OOOQV-E:`-E:`O3aQ#xO7+&oO3aQ#xO7+&oOOQV,5<|,5<|O#-uQ#xO,5<|O!GPQ#xO,5<|OOQV7+&o7+&oO#.QQ#{O7+&oO#1`Q#xO,5<}O#1kQ#xO1G4bOOQS-E:a-E:aO#1xQ#xO1G4bO#2QQ#xO'#I^O#2`Q#xO'#I^O0XQ#xO'#I^OOQS'#I^'#I^O#2kQ#xO'#I]OOQS,5;q,5;qO#2sQ#xO,5;qO/rQ#xO'#FXOOQV7+&u7+&uO3aQ#xO7+&uOOQV7+&z7+&zO3aQ#xO7+&zO#2xQ#zO,5;{OOQV7+'P7+'PPOOO7+(o7+(oO#2}Q#xO1G3vOOQS,5<f,5<fO#3]Q#xO1G3uOOQS-E9x-E9xO#3pQ#xO,5<gO#3{Q#xO,5<gO#4`Q#xO1G3xOOQS-E9y-E9yO#4pQ#xO1G3xO#4xQ#xO1G3xO#5YQ#xO1G3xO#4pQ#xO1G3xOOQS<<H^<<H^O#5eQ&nO1G1}OOQS<<Hm<<HmP#5rQ#xO'#FwO7kQ#xO1G3oO#6PQ#xO1G3oO#6UQ#xO<<HmOOQS<<Hn<<HnO#6fQ#xO7+)_OOQS<<Hu<<HuO#6vQ&nO1G1|P#7gQ#xO'#FvO#7tQ#xO7+)`O#8UQ#xO7+)`O#8^Q#xO<<HyO#8cQ#xO7+)YOOQS<<H{<<H{O#9YQ#xO,5<eO'ZQ#xO,5<eOOQS-E9w-E9wOOQS<<Hy<<HyOOQS,5<k,5<kO/rQ#xO,5<kO#9_Q#xO1G4SOOQS-E9}-E9}O#9uQ#xO1G4SO;UQ#xO'#D|OOOO'#GQ'#GQO#:TO$ISO,5:gOOO#l,5>i,5>iOOOW7+%k7+%kOOO`7+%o7+%oOOOp7+%p7+%pOOO!b7+%q7+%qO#:`Q#xO1G3XO#:yQ#xO1G3XP'ZQ#xO'#FxO/rQ#xO<<IsO#;[Q#xO,5>qO#;mQ#xO,5>qO0XQ#xO,5>qO#<OQ#xO,5>pOOQS<<Iu<<IuP0XQ#xO'#G]P/rQ#xO'#GXOOQS,5;`,5;`O#<TQ#xO,5>sO#<cQ#xO,5>sOOQS1G0y1G0yOOQS<<I}<<I}OOQV-E:^-E:^O3aQ#xO<<JTOOQV,5<z,5<zO3aQ#xO,5<zOOQV<<JT<<JTOOQV<<JW<<JWO#<kQ&nO1G2gP#<uQ#xO'#GaO#<|Q#xO7+){O#=WQ#{O<<JYO3aQ#xO<<JYOOQV<<Ja<<JaO3aQ#xO<<JaO!HUQMlO<<JaO#@fQ#{O7+&jOOQV<<JZ<<JZO#@pQ#{O<<JZOOQV1G2h1G2hO0XQ#xO1G2hO#DOQ#xO1G2hO3aQ#xO<<JZO0XQ#xO1G2iP/rQ#xO'#GcO#DZQ#xO7+)|O#DhQ#xO7+)|OOQS'#FW'#FWO/rQ#xO,5>xO#DpQ#xO,5>xOOQS,5>x,5>xO#D{Q#xO,5>wO#E^Q#xO,5>wOOQS1G1]1G1]OOQS,5;s,5;sOOQV<<Jf<<JfO#EfQ#xO1G1gOOQS7+)b7+)bP#EkQ#xO'#FzO#E{Q#xO1G2RO#F`Q#xO1G2RO#FpQ#xO1G2RP#F{Q#xO'#F{O#GYQ#xO7+)dO#GjQ#xO7+)dO#GjQ#xO7+)dO#GrQ#xO7+)dO#HSQ#xO7+)ZO7kQ#xO7+)ZOOQSAN>XAN>XO#HmQ#xO<<LzOOQSAN>eAN>eO/rQ#xO1G2PO#H}Q&nO1G2PP#IXQ#xO'#FyOOQS1G2V1G2VP#IfQ#xO'#GPO#IsQ#xO7+)nO#JZQ#xO,5:hOOOO-E:O-E:OO#JfQ#xO7+(sOOQSAN?_AN?_O#KPQ#xO,5<vO#KeQ#xO1G4]OOQS-E:Y-E:YO#KvQ#xO1G4]OOQS1G4[1G4[OOQS,5<x,5<xO#LXQ#xO1G4_OOQS-E:[-E:[OOQVAN?oAN?oOOQV1G2f1G2fO3aQ#xOAN?tO#LgQ#{OAN?tOOQVAN?{AN?{O3aQ#xOAN?{OOQV<<JU<<JUO3aQ#xOAN?uO3aQ#xO7+(SOOQV7+(S7+(SO0XQ#xO7+(SOOQVAN?uAN?uOOQS7+(T7+(TO$ uQ#xO<<MhOOQS1G4d1G4dO/rQ#xO1G4dOOQS,5=O,5=OO$!SQ#xO1G4cOOQS-E:b-E:bOOQU'#Gf'#GfO$!eQ#zO7+'RO$!pQ#xO'#FbO$#hQ#xO7+'mO$#xQ#xO7+'mOOQS7+'m7+'mO$$TQ#xO<<MOO$$eQ#xO<<MOO$$eQ#xO<<MOO$$mQ#xO'#HkOOQS<<Lu<<LuO$$wQ#xO<<LuOOQS7+'k7+'kOOOO1G0S1G0SO$%bQ#xO1G0SO0XQ#xO1G2bP0XQ#xO'#G[O$%jQ#xO7+)wO$%{Q#xO7+)wP!;oQ#xO'#G^OOQVG25`G25`O3aQ#xOG25`OOQVG25gG25gOOQVG25aG25aOOQV<<Kn<<KnO3aQ#xO<<KnOOQS7+*O7+*OP$&^Q#xO'#GdOOQU-E:d-E:dOOQV<<Jm<<JmO$'QQ&nO'#FdOOQS'#Ff'#FfO$'bQ#xO'#FeO$(SQ#xO'#FeOOQS'#Fe'#FeO$(XQ#xO'#I`O$!pQ#xO'#FlO$!pQ#xO'#FlO$(pQ#xO'#FmO$!pQ#xO'#FnO$(wQ#xO'#IaOOQS'#Ia'#IaO$)fQ#xO,5;|OOQS<<KX<<KXO$)nQ#xO<<KXO$*OQ#xOANBjO$*`Q#xOANBjO$*hQ#xO'#HlOOQS'#Hl'#HlO0sQ#xO'#DeO$+RQ#xO,5>VOOQSANBaANBaOOOO7+%n7+%nOOQS7+'|7+'|O$+jQ#xO<<McOOQVLD*zLD*zOOQVANAYANAYO4jQMlO'#GhO$+{Q&nO,5<VO$!pQ#xO'#FpOOQS,5<Z,5<ZOOQS'#Fg'#FgO$,mQ#xO,5<PO$,rQ#xO,5<POOQS'#Fj'#FjO$!pQ#xO'#GgO$-dQ#xO,5<TO$.OQ#xO,5>zO$.`Q#xO,5>zO0XQ#xO,5<SO$.qQ#xO,5<WO$.vQ#xO,5<WO$!pQ#xO'#IbO$.{Q#xO'#IbO$/QQ#xO,5<XOOQS,5<Y,5<YO'ZQ#xO'#FsOOQU1G1h1G1hO3aQ#xO1G1hOOQSAN@sAN@sO$/VQ#xOG28UO$/gQ#xO,5:POOQS1G3q1G3qOOQS,5=S,5=SOOQS-E:f-E:fO$/lQ&nO'#FdO$/sQ#xO'#IcO$0RQ#xO'#IcO$0ZQ#xO,5<[OOQS1G1k1G1kO$0`Q#xO1G1kO$0eQ#xO,5=ROOQS-E:e-E:eO$1PQ#xO,5=VO$1hQ#xO1G4fOOQS-E:i-E:iOOQS1G1n1G1nOOQS1G1r1G1rO$1xQ#xO,5>|O$!pQ#xO,5>|OOQS1G1s1G1sO$2WQ&nO,5<_OOQU7+'S7+'SO$$mQ#xO1G/kO$!pQ#xO,5<]O$2_Q#xO,5>}O$2fQ#xO,5>}OOQS1G1v1G1vOOQS7+'V7+'VP$!pQ#xO'#GkO$2nQ#xO1G4hO$2xQ#xO1G4hO$3QQ#xO1G4hOOQS7+%V7+%VO$3`Q#xO1G1wO$3nQ&nO'#FdO$3uQ#xO,5=UOOQS,5=U,5=UO$4TQ#xO1G4iOOQS-E:h-E:hO$!pQ#xO,5=TO$4[Q#xO,5=TO$4aQ#xO7+*SOOQS-E:g-E:gO$4kQ#xO7+*SO$!pQ#xO,5<^P$!pQ#xO'#GjO$4sQ#xO1G2oO$!pQ#xO1G2oP$5RQ#xO'#GiO$5YQ#xO<<MnO$5dQ#xO1G1xO$5rQ#xO7+(ZO7kQ#xO'#DPO7kQ#xO,59dO7kQ#xO,59dO7kQ#xO,59dO$6QQ&nO,5=mO7kQ#xO1G/OO/rQ#xO1G/ZO/rQ#xO7+$rP$6eQ#xO'#GVO'ZQ#xO'#HRO$6rQ#xO,59dO$6wQ#xO,59dO$7OQ#xO,59oO$7TQ#xO1G/WO0sQ#xO'#DTO7kQ#xO,59l\",\n    stateData: \"$7f~O%pOS%eOSUOS%dPQ~OPiOXfOhtOjYOquOu!UOxvO!RwO!S!QO!V!XO!W!WO!ZZO!_[O!jeO!ueO!veO!weO#OyO#QzO#S{O#U|O#W}O#[!OO#^!PO#a!RO#b!RO#d!SO#f!TO#o!VO#r!YO#v!ZO#x![O#}!]O$QmO$S!^O%|RO%}RO&RSO&SWO&h]O&i^O&l_O&o`O&saO&tbO&ucO~O%d!_O~OX!fOa!fOc!gOj!nO!Z!pO!h!rO%w!aO%x!bO%y!cO%z!dO%{!dO%|!eO%}!eO&O!fO&P!fO&Q!fO~Om&VXn&VXo&VXp&VXq&VXr&VXu&VX|&VX}&VX!{&VX#j&VX%c&VX%f&VX&X&VXi&VX!V&VX!W&VX&Y&VX!Y&VX!^&VX!S&VX#_&VXv&VX!n&VX~P$gOhtOjYO!ZZO!_[O!jeO!ueO!veO!weO%|RO%}RO&RSO&SWO&h]O&i^O&l_O&o`O&saO&tbO&ucO~O|&UX}&UX#j&UX%c&UX%f&UX&X&UX~Om!uOn!vOo!tOp!tOq!wOr!xOu!yO!{&UX~P(hOX#POi#ROq0zOx1YO!RwO~P'ZOX#TOq0zOx1YO!Y#UO~P'ZOX#XOc#YOq0zOx1YO!^#ZO~P'ZO&j#^O&k#`O~O&m#aO&n#`O~OQ#cO%g#dO%h#fO~OR#gO%i#hO%j#fO~OS#jO%k#kO%l#fO~OT#mO%m#nO%n#fO~OX%vXa%vXc%vXj%vXm%vXn%vXo%vXp%vXq%vXr%vXu%vX|%vX!Z%vX!h%vX%w%vX%x%vX%y%vX%z%vX%{%vX%|%vX%}%vX&O%vX&P%vX&Q%vXi%vX!V%vX!W%vX~O&h]O&i^O&l_O&o`O&saO&tbO&ucO}%vX!{%vX#j%vX%c%vX%f%vX&X%vX&Y%vX!Y%vX!^%vX!S%vX#_%vXv%vX!n%vX~P,QO|#sO}%uX!{%uX#j%uX%c%uX%f%uX&X%uX~Oq0zOx1YO~P'ZO#j#vO%c#xO%f#xO~O&SWO~O!V#}O#x![O#}!]O$QmO~OquO~P'ZOX$SOc$TO&SWO}yP~OX$XOq0zOx1YO!S$YO~P'ZO}$[O!{$aO&X$]O#j!|X%c!|X%f!|X~OX$XOq0zOx1YO#j#VX%c#VX%f#VX~P'ZOq0zOx1YO#j#ZX%c#ZX%f#ZX~P'ZO!h$gO!u$gO&SWO~OX$rO~P'ZO!W$tO#v$uO#x$vO~O}$wO~OX%OO~P'ZOU%QO%c%PO%p%RO~OX%[Oc%[Oi%^Oq0zOx1YO~P'ZOq0zOx1YO}%aO~P'ZO&g%cO~Oc!gOj!nO!Z!pO!h!rOXdaadamdandaodapdaqdardauda|da}da!{da#jda%cda%fda%wda%xda%yda%zda%{da%|da%}da&Oda&Pda&Qda&Xdaida!Vda!Wda&Yda!Yda!^da!Sda#_davda!nda~Op%hO~Oq%hO~P'ZOq0zO~P'ZOm0|On0}Oo0{Op0{Oq1UOr1VOu1ZOi&UX!V&UX!W&UX&Y&UX!Y&UX!^&UX!S&UX#_&UX!n&UX~P(hO&Y%jOi&TX|&TX!V&TX!W&TX!Y&TX}&TX~Oi%lO|%mO!V%qO!W%pO~Oi%lO~O|%tO!V%qO!W%pO!Y&aX~O!Y%xO~O|%yO}%{O!V%qO!W%pO!^&[X~O!^&PO~O!^&QO~O&j#^O&k&SO~O&m#aO&n&SO~OX&VOq0zOx1YO!RwO~P'ZOQ#cO%g#dO%h&YO~OR#gO%i#hO%j&YO~OS#jO%k#kO%l&YO~OT#mO%m#nO%n&YO~OX!taa!tac!taj!tam!tan!tao!tap!taq!tar!tau!ta|!ta}!ta!Z!ta!h!ta!{!ta#j!ta%c!ta%f!ta%w!ta%x!ta%y!ta%z!ta%{!ta%|!ta%}!ta&O!ta&P!ta&Q!ta&X!tai!ta!V!ta!W!ta&Y!ta!Y!ta!^!ta!S!ta#_!tav!ta!n!ta~P#yO|&bO}%ua!{%ua#j%ua%c%ua%f%ua&X%ua~P$gOX&dOquOxvO}%ua!{%ua#j%ua%c%ua%f%ua&X%ua~P'ZO|&bO}%ua!{%ua#j%ua%c%ua%f%ua&X%ua~OPiOXfOquOxvO!RwO!S!QO#OyO#QzO#S{O#U|O#W}O#[!OO#^!PO#a!RO#b!RO#d!SO#f!TO#j%RX%c%RX%f%RX~P'ZO#j#vO%c&iO%f&iO~O!h&jOj&wX%c&wX#_&wX#j&wX%f&wX#^&wX~Oj!nO%c&lO~Omgangaogapgaqgargauga|ga}ga!{ga#jga%cga%fga&Xgaiga!Vga!Wga&Yga!Yga!^ga!Sga#_gavga!nga~P$gOusa|sa}sa#jsa%csa%fsa&Xsa~Om!uOn!vOo!tOp!tOq!wOr!xO!{sa~PDuO&X&nO|&WX}&WX~O&SWO|&WX}&WX~O|&qO}yX~O}&sO~O|%yO#j&[X%c&[X%f&[Xi&[X}&[X!^&[X!n&[X&X&[X~OX1TOq0zOx1YO!RwO~P'ZO&X$]O#jWa%cWa%fWa~O|&|O#j&^X%c&^X%f&^Xp&^X~P$gO|'PO!S'OO#j#Za%c#Za%f#Za~O#_'QO#j#]a%c#]a%f#]a~O!h$gO!u$gO#^'SO&SWO~O#^'SO~O|'UO#j&zX%c&zX%f&zX~O|'WO#j&vX%c&vX%f&vX}&vX~O!Z'YO&X'ZO~O|'_Op&}X~P$gOp'bO~OPiOXfOquOxvO!RwO!S!QO#OyO#QzO#S{O#U|O#W}O#[!OO#^!PO#a!RO#b!RO#d!SO#f!TO%c'gO~P'ZOv'kO#s'iO#t'jOP#qaX#qah#qaj#qaq#qau#qax#qa!R#qa!S#qa!V#qa!W#qa!Z#qa!_#qa!j#qa!u#qa!v#qa!w#qa#O#qa#Q#qa#S#qa#U#qa#W#qa#[#qa#^#qa#a#qa#b#qa#d#qa#f#qa#o#qa#r#qa#v#qa#x#qa#}#qa$Q#qa$S#qa%`#qa%|#qa%}#qa&R#qa&S#qa&h#qa&i#qa&l#qa&o#qa&s#qa&t#qa&u#qa%b#qa%f#qa~O|'lO#_'nO}'OX~Oj'pO!Z'YO~Oj!nO}$wO!Z'YO~O}'vO~P$gO%c'yO~OU'zO%c'yO~OX!fOa!fOc!gOj!nO!Z!pO!h!rO%y!cO%z!dO%{!dO%|!eO%}!eO&O!fO&P!fO&Q!fOmYinYioYipYiqYirYiuYi|Yi}Yi!{Yi#jYi%cYi%fYi%wYi&XYiiYi!VYi!WYi&YYi!YYi!^Yi!SYi#_YivYi!nYi~O%x!bO~P!!`O%xYi~P!!`OX!fOa!fOc!gOj!nO!Z!pO!h!rO%|!eO%}!eO&O!fO&P!fO&Q!fOmYinYioYipYiqYirYiuYi|Yi}Yi!{Yi#jYi%cYi%fYi%wYi%xYi%yYi&XYiiYi!VYi!WYi&YYi!YYi!^Yi!SYi#_YivYi!nYi~O%z!dO%{!dO~P!%ZO%zYi%{Yi~P!%ZOc!gOj!nO!Z!pO!h!rOmYinYioYipYiqYirYiuYi|Yi}Yi!{Yi#jYi%cYi%fYi%wYi%xYi%yYi%zYi%{Yi%|Yi%}Yi&XYiiYi!VYi!WYi&YYi!YYi!^Yi!SYi#_YivYi!nYi~OX!fOa!fO&O!fO&P!fO&Q!fO~P!(XOXYiaYi&OYi&PYi&QYi~P!(XO!V%qO!W%pOi&dX|&dX~O&X'|O&Y'|O~P,QO|(OOi&cX~Oi(QO~O|(RO}(TO!Y&fX~Oq0zOx1YO|(RO}(UO!Y&fX~P'ZO!Y(WO~Oo!tOp!tOq!wOr!xOmliuli|li}li!{li#jli%cli%fli&Xli~On!vO~P!,zOnli~P!,zOm0|On0}Oo0{Op0{Oq1UOr1VO~Ov(YO~P!.TOX(_Oi(`Oq0zOx1YO~P'ZOi(`O|(aO~Oi(cO~O!W(eO~Oi(fO|(aO!V%qO!W%pO~P$gOm0|On0}Oo0{Op0{Oq1UOr1VOisa!Vsa!Wsa&Ysa!Ysa!^sa!Ssa#_savsa!nsa~PDuOX(_Oq0zOx1YO!Y&aa~P'ZO|(iO!Y&aa~O!Y(jO~O|(iO!V%qO!W%pO!Y&aa~P$gOX(nOq0zOx1YO!^&[a#j&[a%c&[a%f&[ai&[a}&[a!n&[a&X&[a~P'ZO|(oO!^&[a#j&[a%c&[a%f&[ai&[a}&[a!n&[a&X&[a~O!^(rO~O|(oO!V%qO!W%pO!^&[a~P$gO|(uO!V%qO!W%pO!^&ba~P$gO|(xO}&pX!^&pX!n&pX~O}({O!^(}O!n)OO~O}({O!^)PO!n)QO~O}({O!^)RO!n)SO~O}({O!^)TO!n)UO~OX&dOquOxvO}%ui!{%ui#j%ui%c%ui%f%ui&X%ui~P'ZO|)VO}%ui!{%ui#j%ui%c%ui%f%ui&X%ui~O!h&jOj&wa%c&wa#_&wa#j&wa%f&wa#^&wa~O%c)[O~OX$SOc$TO&SWO~O|&qO}ya~OquOxvO~P'ZO|(oO#j&[a%c&[a%f&[ai&[a}&[a!^&[a!n&[a&X&[a~P$gO|)aO#j%uX%c%uX%f%uX&X%uX~O&X$]O#jWi%cWi%fWi~O#j&^a%c&^a%f&^ap&^a~P'ZO|)dO#j&^a%c&^a%f&^ap&^a~OX)hOj)jO&SWO~O#^)kO~O&SWO#j&za%c&za%f&za~O|)mO#j&za%c&za%f&za~Oq0zOx1YO#j&va%c&va%f&va}&va~P'ZO|)pO#j&va%c&va%f&va}&va~OX)rOc)rO&SWO~O&X)wO~Ov)zO#m)yOP#kiX#kih#kij#kiq#kiu#kix#ki!R#ki!S#ki!V#ki!W#ki!Z#ki!_#ki!j#ki!u#ki!v#ki!w#ki#O#ki#Q#ki#S#ki#U#ki#W#ki#[#ki#^#ki#a#ki#b#ki#d#ki#f#ki#o#ki#r#ki#v#ki#x#ki#}#ki$Q#ki$S#ki%`#ki%|#ki%}#ki&R#ki&S#ki&h#ki&i#ki&l#ki&o#ki&s#ki&t#ki&u#ki%b#ki%f#ki~Ov){OP#niX#nih#nij#niq#niu#nix#ni!R#ni!S#ni!V#ni!W#ni!Z#ni!_#ni!j#ni!u#ni!v#ni!w#ni#O#ni#Q#ni#S#ni#U#ni#W#ni#[#ni#^#ni#a#ni#b#ni#d#ni#f#ni#o#ni#r#ni#v#ni#x#ni#}#ni$Q#ni$S#ni%`#ni%|#ni%}#ni&R#ni&S#ni&h#ni&i#ni&l#ni&o#ni&s#ni&t#ni&u#ni%b#ni%f#ni~OX)}Op&}a~P'ZO|*OOp&}a~O|*OOp&}a~P$gOp*SO~O%a*WO~Ov*ZO#s'iO#t*YOP#qiX#qih#qij#qiq#qiu#qix#qi!R#qi!S#qi!V#qi!W#qi!Z#qi!_#qi!j#qi!u#qi!v#qi!w#qi#O#qi#Q#qi#S#qi#U#qi#W#qi#[#qi#^#qi#a#qi#b#qi#d#qi#f#qi#o#qi#r#qi#v#qi#x#qi#}#qi$Q#qi$S#qi%`#qi%|#qi%}#qi&R#qi&S#qi&h#qi&i#qi&l#qi&o#qi&s#qi&t#qi&u#qi%b#qi%f#qi~OX*^Oq0zOx1YO}$wO~P'ZOq0zOx1YO}'Oa~P'ZO|*bO}'Oa~OX*fOc*gOi*jO&O*hO&SWO~O}$wO'R*lO~Oj'pO~Oj!nO}$wO~O%c*qO~O%c*sO~OX%[Oc%[Oq0zOx1YOi&ca~P'ZO|*vOi&ca~Oq0zOx1YO}*yO!Y&fa~P'ZO|*zO!Y&fa~Oq0zOx1YO|*zO}*}O!Y&fa~P'ZOq0zOx1YO|*zO!Y&fa~P'ZO|*zO}*}O!Y&fa~Oo0{Op0{Oq1UOr1VOilimliuli|li!Vli!Wli&Yli!Yli}li!^li#jli%cli%fli!Sli#_livli!nli&Xli~On0}O~P!JzOnli~P!JzOX(_Oi+SOq0zOx1YO~P'ZOp+UO~Oi+SO|+WO~Oi+XO~OX(_Oq0zOx1YO!Y&ai~P'ZO|+YO!Y&ai~O!Y+ZO~OX(nOq0zOx1YO!^&[i#j&[i%c&[i%f&[ii&[i}&[i!n&[i&X&[i~P'ZO|+^O!V%qO!W%pO!^&bi~O|+aO!^&[i#j&[i%c&[i%f&[ii&[i}&[i!n&[i&X&[i~O!^+bO~Oc+dOq0zOx1YO!^&bi~P'ZO|+^O!^&bi~O!^+fO~OX+hOq0zOx1YO}&pa!^&pa!n&pa~P'ZO|+iO}&pa!^&pa!n&pa~O!_+lO&r+mO!^!oX~O!^+oO~O}({O!^+pO~O}({O!^+qO~O}({O!^+rO~O}({O!^+sO~OX&dOquOxvO}%uq!{%uq#j%uq%c%uq%f%uq&X%uq~P'ZO|$yi}$yi!{$yi#j$yi%c$yi%f$yi&X$yi~P$gOX&dOquOxvO~P'ZOX&dOq0zOx1YO#j%ua%c%ua%f%ua&X%ua~P'ZO|+tO#j%ua%c%ua%f%ua&X%ua~O|$la#j$la%c$la%f$lap$la~P$gO#j&^i%c&^i%f&^ip&^i~P'ZO|+wO#j#Zq%c#Zq%f#Zq~O|+xO#_+zO#j&yX%c&yX%f&yXi&yX~OX+|Oj)jO&SWO~O&SWO#j&zi%c&zi%f&zi~Oq0zOx1YO#j&vi%c&vi%f&vi}&vi~P'ZO}$[O|#hX!Y#hX~O|,QO!Y&{X~O!Y,SO~Ov,VO#m)yOP#kqX#kqh#kqj#kqq#kqu#kqx#kq!R#kq!S#kq!V#kq!W#kq!Z#kq!_#kq!j#kq!u#kq!v#kq!w#kq#O#kq#Q#kq#S#kq#U#kq#W#kq#[#kq#^#kq#a#kq#b#kq#d#kq#f#kq#o#kq#r#kq#v#kq#x#kq#}#kq$Q#kq$S#kq%`#kq%|#kq%}#kq&R#kq&S#kq&h#kq&i#kq&l#kq&o#kq&s#kq&t#kq&u#kq%b#kq%f#kq~Op%Ta|%Ta~P$gOX)}Op&}i~P'ZO|,^Op&}i~O|,hO}$wO#_,hO~O#t,jOP#qqX#qqh#qqj#qqq#qqu#qqx#qq!R#qq!S#qq!V#qq!W#qq!Z#qq!_#qq!j#qq!u#qq!v#qq!w#qq#O#qq#Q#qq#S#qq#U#qq#W#qq#[#qq#^#qq#a#qq#b#qq#d#qq#f#qq#o#qq#r#qq#v#qq#x#qq#}#qq$Q#qq$S#qq%`#qq%|#qq%}#qq&R#qq&S#qq&h#qq&i#qq&l#qq&o#qq&s#qq&t#qq&u#qq%b#qq%f#qq~O#_,kO|%Va}%Va~Oq0zOx1YO}'Oi~P'ZO|,mO}'Oi~O}$[O&X,oOi'QX|'QX~O&SWOi'QX|'QX~O|,sOi'PX~Oi,uO~O%a,xO~O!V%qO!W%pOi&di|&di~OX%[Oc%[Oq0zOx1YOi&ci~P'ZO},{O|$oa!Y$oa~Oq0zOx1YO},|O|$oa!Y$oa~P'ZOq0zOx1YO}*yO!Y&fi~P'ZO|-PO!Y&fi~Oq0zOx1YO|-PO!Y&fi~P'ZO|-PO}-SO!Y&fi~Oi$ki|$ki!Y$ki~P$gOX(_Oq0zOx1YO~P'ZOp-UO~OX(_Oi-VOq0zOx1YO~P'ZOX(_Oq0zOx1YO!Y&aq~P'ZO|$ji!^$ji#j$ji%c$ji%f$jii$ji}$ji!n$ji&X$ji~P$gOX(nOq0zOx1YO~P'ZOc+dOq0zOx1YO!^&bq~P'ZO|-WO!^&bq~O!^-XO~OX(nOq0zOx1YO!^&[q#j&[q%c&[q%f&[qi&[q}&[q!n&[q&X&[q~P'ZO}-YO~OX+hOq0zOx1YO}&pi!^&pi!n&pi~P'ZO|-_O}&pi!^&pi!n&pi~O!_+lO&r+mO!^!oa~OX&dOq0zOx1YO#j%ui%c%ui%f%ui&X%ui~P'ZO|-bO#j%ui%c%ui%f%ui&X%ui~O&SWO#j&ya%c&ya%f&yai&ya~O|-eO#j&ya%c&ya%f&yai&ya~Oi-hO~OX)rOc)rO&SWO!Y&{a~O|-jO!Y&{a~Op%Ti|%Ti~P$gOX)}O~P'ZOX)}Op&}q~P'ZOv-nOP#pyX#pyh#pyj#pyq#pyu#pyx#py!R#py!S#py!V#py!W#py!Z#py!_#py!j#py!u#py!v#py!w#py#O#py#Q#py#S#py#U#py#W#py#[#py#^#py#a#py#b#py#d#py#f#py#o#py#r#py#v#py#x#py#}#py$Q#py$S#py%`#py%|#py%}#py&R#py&S#py&h#py&i#py&l#py&o#py&s#py&t#py&u#py%b#py%f#py~O%b-rO%f-rO~P`O#t-sOP#qyX#qyh#qyj#qyq#qyu#qyx#qy!R#qy!S#qy!V#qy!W#qy!Z#qy!_#qy!j#qy!u#qy!v#qy!w#qy#O#qy#Q#qy#S#qy#U#qy#W#qy#[#qy#^#qy#a#qy#b#qy#d#qy#f#qy#o#qy#r#qy#v#qy#x#qy#}#qy$Q#qy$S#qy%`#qy%|#qy%}#qy&R#qy&S#qy&h#qy&i#qy&l#qy&o#qy&s#qy&t#qy&u#qy%b#qy%f#qy~O|-vO}$wO#_-vO~Oq0zOx1YO}'Oq~P'ZO|-yO}'Oq~O&X,oOi'Qa|'Qa~OX*fOc*gO&O*hO&SWOi'Pa~O|-}Oi'Pa~O$V.RO~OX%[Oc%[Oq0zOx1YO~P'ZOq0zOx1YO}.SO|$oi!Y$oi~P'ZOq0zOx1YO|$oi!Y$oi~P'ZO}.SO|$oi!Y$oi~Oq0zOx1YO}*yO~P'ZOq0zOx1YO}*yO!Y&fq~P'ZO|.VO!Y&fq~Oq0zOx1YO|.VO!Y&fq~P'ZOu.YO!V%qO!W%pOi&]q!Y&]q!^&]q|&]q~P!.TOc+dOq0zOx1YO!^&by~P'ZO|$mi!^$mi~P$gOc+dOq0zOx1YO~P'ZOX+hOq0zOx1YO~P'ZOX+hOq0zOx1YO}&pq!^&pq!n&pq~P'ZO}({O!^.^O!n._O~OX&dOq0zOx1YO#j%uq%c%uq%f%uq&X%uq~P'ZO#_.`O|%Oa#j%Oa%c%Oa%f%Oai%Oa~O&SWO#j&yi%c&yi%f&yii&yi~O|.bO#j&yi%c&yi%f&yii&yi~OX)rOc)rO&SWO!Y&{i~Ov.fOP#p!RX#p!Rh#p!Rj#p!Rq#p!Ru#p!Rx#p!R!R#p!R!S#p!R!V#p!R!W#p!R!Z#p!R!_#p!R!j#p!R!u#p!R!v#p!R!w#p!R#O#p!R#Q#p!R#S#p!R#U#p!R#W#p!R#[#p!R#^#p!R#a#p!R#b#p!R#d#p!R#f#p!R#o#p!R#r#p!R#v#p!R#x#p!R#}#p!R$Q#p!R$S#p!R%`#p!R%|#p!R%}#p!R&R#p!R&S#p!R&h#p!R&i#p!R&l#p!R&o#p!R&s#p!R&t#p!R&u#p!R%b#p!R%f#p!R~Oq0zOx1YO}'Oy~P'ZOX*fOc*gO&O*hO&SWOi'Pi~O$V.RO%b.nO%f.nO~OX.xOj.vO!Z.uO!_.wO!j.qO!v.sO!w.sO%}.pO&SWO&h]O&i^O&l_O~Oq0zOx1YO|$oq!Y$oq~P'ZO}.}O|$oq!Y$oq~Oq0zOx1YO}*yO!Y&fy~P'ZO|/OO!Y&fy~Oq0zOx/SO~P'ZOu.YO!V%qO!W%pOi&]y!Y&]y!^&]y|&]y~P!.TO}({O!^/VO~O&SWO#j&yq%c&yq%f&yqi&yq~O|/XO#j&yq%c&yq%f&yqi&yq~OX*fOc*gO&O*hO&SWO~Oj/^O!h/[O|$WX#_$WX%w$WXi$WX~Ou$WX}$WX!Y$WX!^$WX~P$&lO%|/`O%}/`Ou$XX|$XX}$XX#_$XX%w$XX!Y$XXi$XX!^$XX~O!j/bO~O|/fO#_/hO%w/cOu'SX}'SX!Y'SXi'SX~Oc/kO~P$!|Oj/^Ou'TX|'TX}'TX#_'TX%w'TX!Y'TXi'TX!^'TX~Ou/oO}$wO~Oq0zOx1YO|$oy!Y$oy~P'ZOq0zOx1YO}*yO!Y&f!R~P'ZO|/sO!Y&f!R~Oi&`Xu&`X!V&`X!W&`X!Y&`X!^&`X|&`X~P!.TOu.YO!V%qO!W%pOi&_a!Y&_a!^&_a|&_a~O&SWO#j&yy%c&yy%f&yyi&yy~O!h/[Oj$_au$_a|$_a}$_a#_$_a%w$_a!Y$_ai$_a!^$_a~O!j/|O~O%|/`O%}/`Ou$Xa|$Xa}$Xa#_$Xa%w$Xa!Y$Xai$Xa!^$Xa~O%w/cOu$]a|$]a}$]a#_$]a!Y$]ai$]a!^$]a~Ou'Sa}'Sa!Y'Sai'Sa~P$!pO|0ROu'Sa}'Sa!Y'Sai'Sa~O!Y0UO~Oi0UO~O}0WO~O!^0XO~Oq0zOx1YO}*yO!Y&f!Z~P'ZO}0[O~O&X0]O~P$&lO|0^O#_/hO%w/cOi'VX~O|0^Oi'VX~Oi0`O~O!j0aO~O#_/hOu%Za|%Za}%Za%w%Za!Y%Zai%Za!^%Za~O#_/hO%w/cOu%_a|%_a}%_a!Y%_ai%_a~Ou'Si}'Si!Y'Sii'Si~P$!pO|0cO#_/hO%w/cO!^'Ua~O}$ga~P$gOi'Va~P$!pO|0kOi'Va~Oc0mO!^'Ui~P$!|O|0oO!^'Ui~O|0oO#_/hO%w/cO!^'Ui~O#_/hO%w/cOi$ei|$ei~O&X0rO~P$&lO#_/hO%w/cOi%^a|%^a~Oi'Vi~P$!pO}0uO~Oc0mO!^'Uq~P$!|O|0wO!^'Uq~O#_/hO%w/cO|%]i!^%]i~Oc0mO~P$!|Oc0mO!^'Uy~P$!|O#_/hO%w/cOi$fi|$fi~O#_/hO%w/cO|%]q!^%]q~O|+tO#j%ua%c%ua%f%ua&X%ua~P$gOX&dOq0zOx1YO~P'ZOp1PO~Oq1PO~P'ZO}1QO~Ov1RO~P!.TO&i&l&t&u&h&o&s&S&h~\",\n    goto: \"!?b'WPPPPPPPP'XP'a*|+f,P,k-W-tP.cP'a/S/S'aPPP'a2oPPPPPP2o5fPP5fP7y8S>fPP>i?Z?^PP'a'aPP?vPP'a'aPP'a'a'a'a'a?z@t'aP@wP@}EXHxPH|IYI^IbIf'aPPPIjIs'XP'X'XP'XP'XP'XP'XP'X'X'XP'XPP'XPP'XP'XPIyJVJ_PJfJlPJfPJfJfPPPJfPLzPMTM_MeLzPJfMnPJfPMuM{PNPNe! S! mNPNP! s!!QNPNPNPNP!!f!!l!!o!!t!!w!#R!#X!#e!#w!#}!$X!$_!${!%R!%X!%_!%i!%o!%u!%{!&R!&X!&k!&u!&{!'R!'X!'c!'i!'o!'u!'{!(V!(]!(g!(m!(v!(|!)]!)e!)o!)vPPPPPPPPPPPPPPPPP!)|!*P!*V!*`!*j!*uPPPPPPPPPPPP!/l!1Q!5T!8hPP!8p!9S!9]!:U!9{!:_!:e!:h!:k!:n!:v!;gPPPPPPPPP!;j!;yPPPP!<i!<u!=R!=X!=b!=e!=h!=n!=t!=z!=}P!>V!>`!?[!?_]jOs#v$w*W,d(TeOTYZ[fistuwy}!O!S!U!V!W!Z!^!h!i!j!k!l!m!n!p!t!u!v!x!y#P#T#X#Y#c#g#j#m#s#v$X$Y$[$^$a$r$t$u$w%O%[%a%h%k%m%p%t%y%{&V&b&d&o&s&|'O'P'W'Z'_'b'i'l'}(O(R(T(U(Y(_(a(e(i(n(o(u(x)V)X)a)d)p)w)y)}*O*S*W*^*b*l*v*y*z*}+T+U+W+Y+]+^+a+d+h+i+l+t+v+w,O,],^,d,l,m,p,z,{,|-O-P-S-U-W-Y-[-^-_-b-y-{.S.V.Y.}/O/o/s0[0z0{0|0}1P1Q1R1S1T1V1Z}!hQ#r$P$b$q$}%r%w%}&O&t'a'x)W)c)|+R+[,[-Z0Y1O!P!iQ#r$P$b$q$}%S%r%w%}&O&t'a'x)W)c)|+R+[,[-Z0Y1O!R!jQ#r$P$b$q$}%S%T%r%w%}&O&t'a'x)W)c)|+R+[,[-Z0Y1O!T!kQ#r$P$b$q$}%S%T%U%r%w%}&O&t'a'x)W)c)|+R+[,[-Z0Y1O!V!lQ#r$P$b$q$}%S%T%U%V%r%w%}&O&t'a'x)W)c)|+R+[,[-Z0Y1O!X!mQ#r$P$b$q$}%S%T%U%V%W%r%w%}&O&t'a'x)W)c)|+R+[,[-Z0Y1O!]!mQ!s#r$P$b$q$}%S%T%U%V%W%X%r%w%}&O&t'a'x)W)c)|+R+[,[-Z0Y1O(TTOTYZ[fistuwy}!O!S!U!V!W!Z!^!h!i!j!k!l!m!n!p!t!u!v!x!y#P#T#X#Y#c#g#j#m#s#v$X$Y$[$^$a$r$t$u$w%O%[%a%h%k%m%p%t%y%{&V&b&d&o&s&|'O'P'W'Z'_'b'i'l'}(O(R(T(U(Y(_(a(e(i(n(o(u(x)V)X)a)d)p)w)y)}*O*S*W*^*b*l*v*y*z*}+T+U+W+Y+]+^+a+d+h+i+l+t+v+w,O,],^,d,l,m,p,z,{,|-O-P-S-U-W-Y-[-^-_-b-y-{.S.V.Y.}/O/o/s0[0z0{0|0}1P1Q1R1S1T1V1Z&iVOYZ[isuw}!O!S!U!V!Z!n!p!t!u!v!x!y#c#g#j#m#s#v$Y$[$^$a$u$w%[%a%h%k%m%t%y%{&V&b&o&s'O'P'W'Z'b'i'l'}(O(R(T(U(Y(a(i(o(u(x)V)X)a)p)w)y*S*W*^*b*l*v*y*z*}+T+U+W+Y+]+^+a+h+i+l+t+w,O,d,l,m,p,z,{,|-O-P-S-U-W-Y-[-^-_-b-y-{.S.V.Y.}/O/s0[0z0{0|0}1P1Q1R1S1V1Z%sXOYZ[isw}!O!S!U!V!Z!n!p#c#g#j#m#s#v$Y$[$^$a$u$w%[%a%k%m%t%y%{&V&b&o&s'O'P'W'Z'b'i'l'}(O(R(T(U(Y(a(i(o(u(x)V)X)a)p)w)y*S*W*^*b*l*v*y*z*}+T+W+Y+]+^+a+h+i+l+t+w,O,d,l,m,p,z,{,|-O-P-S-W-Y-[-^-_-b-y-{.S.V.}/O/s1Q1R1SQ$VvQ/t/SR1W1Y'zeOTYZ[fistuwy}!O!S!U!V!W!Z!^!h!i!j!k!l!m!p!t!u!v!x!y#P#T#X#Y#c#g#j#m#s#v$X$Y$[$^$a$r$t$u$w%O%[%a%h%k%m%p%t%y%{&V&b&d&o&s&|'O'P'W'Z'_'b'i'l'}(R(T(U(Y(_(a(e(i(n(o(u(x)V)X)a)d)p)w)y)}*O*S*W*^*b*l*y*z*}+T+U+W+Y+]+^+a+d+h+i+l+t+v+w,O,],^,d,l,m,p,{,|-O-P-S-U-W-Y-[-^-_-b-y-{.S.V.Y.}/O/o/s0[0z0{0|0}1P1Q1R1S1T1V1ZW#ym!P!Q$hW$Rv&q/S1YQ$j!RQ$n!TQ${![Q$|!]W%Z!n(O*v,zS&p$S$TQ'e$vQ)Y&jQ)h'QU)i'S)j)kU)l'U)m+}W)s'Y,Q-j.dQ*d'nW*e'p,s-}.lQ,P)rS,r*f*gY-d+x-e.a.b/XQ-g+zQ-t,hQ-x,kQ.j-vl.o.R.u.v.x/d/f/k0R0W0]0b0m0r0uQ/W.`Q/l.wQ/x/^Q0T/hU0h0^0k0sX0n0c0o0v0wR&o$R!_!|YZ!U!V!p%a%m%t(R(T(U(a(i)y*y*z*}+T+W+Y,{,|-O-P-S.S.V.}/O/sR%k!{Q#QYQ&W#cQ&Z#gQ&]#jQ&_#mQ&x$^Q&{$aR-`+lT/R.Y0[![!oQ!s#r$P$b$q$}%S%T%U%V%W%X%r%w%}&O&t'a'x)W)c)|+R+[,[-Z0Y1OQ&m#zQ't$|R*p'uR'}%ZQ%d!rR/v/[(SdOTYZ[fistuwy}!O!S!U!V!W!Z!^!h!i!j!k!l!m!n!p!t!u!v!x!y#P#T#X#Y#c#g#j#m#s#v$X$Y$[$^$a$r$t$u$w%O%[%a%h%k%m%p%t%y%{&V&b&d&o&s&|'O'P'W'Z'_'b'i'l'}(O(R(T(U(Y(_(a(e(i(n(o(u(x)V)X)a)d)p)w)y)}*O*S*W*^*b*l*v*y*z*}+T+U+W+Y+]+^+a+d+h+i+l+t+v+w,O,],^,d,l,m,p,z,{,|-O-P-S-U-W-Y-[-^-_-b-y-{.S.V.Y.}/O/o/s0[0z0{0|0}1P1Q1R1S1T1V1ZS#pd#q!P.s.R.u.v.w.x/^/d/f/k0R0W0]0^0b0c0k0m0o0r0s0u0v0w(SdOTYZ[fistuwy}!O!S!U!V!W!Z!^!h!i!j!k!l!m!n!p!t!u!v!x!y#P#T#X#Y#c#g#j#m#s#v$X$Y$[$^$a$r$t$u$w%O%[%a%h%k%m%p%t%y%{&V&b&d&o&s&|'O'P'W'Z'_'b'i'l'}(O(R(T(U(Y(_(a(e(i(n(o(u(x)V)X)a)d)p)w)y)}*O*S*W*^*b*l*v*y*z*}+T+U+W+Y+]+^+a+d+h+i+l+t+v+w,O,],^,d,l,m,p,z,{,|-O-P-S-U-W-Y-[-^-_-b-y-{.S.V.Y.}/O/o/s0[0z0{0|0}1P1Q1R1S1T1V1ZT#pd#qT#d`#ee(|&W&Z&]&_)O)Q)S)U-`._T+m({+nT#ha#iT#kb#lT#nc#oQ$`xQ,P)sR,q*eX$^x$_$`&zQ'[$nQ'r${Q'u$|R*V'eQ)t'YV-i,Q-j.dZlOs$w*W,dXpOs*W,dQ$x!YQ']$oQ'^$pQ'o$zQ's$|Q*T'dQ*['iQ*_'jQ*`'kQ*m'qS*o't'uQ,W)yQ,Y)zQ,Z){Q,_*RS,a*U*nQ,e*YQ,f*ZS,g*]*^Q,w*pQ-l,VQ-m,XQ-o,`S-p,b,cQ-u,iQ-w,jQ.e-nQ.g-qQ.h-sQ.i-tQ/Y.fQ/Z.jQ/p.{R0Z/qWpOs*W,dR#|oQ'q${S*U'e'rR,c*VQ,p*eR-{,qQ*n'qQ,b*UR-q,cZnOos*W,dQ'w$}R*r'xT.P,x.Qu.z.R.u.v.x/^/d/f/k0R0W0]0^0b0k0m0r0s0ut.z.R.u.v.x/^/d/f/k0R0W0]0^0b0k0m0r0s0uQ/l.wX0n0c0o0v0w!P.r.R.u.v.w.x/^/d/f/k0R0W0]0^0b0c0k0m0o0r0s0u0v0wQ/a.qR/}/bg/d.t/e/y0Q0V0e0g0i0t0x0yu.y.R.u.v.x/^/d/f/k0R0W0]0^0b0k0m0r0s0uX/_.o.y/x0hR/z/^V0j0^0k0sR/q.{QsOS$Os,dR,d*WQ&r$UR)_&rS%z#W$WS(p%z(sT(s%}&tQ%n#OQ%u#SW(b%n%u(g(kQ(g%rR(k%wQ&}$bR)e&}Q(v&OQ+_(qT+e(v+_Q(P%]R*w(PS(S%`%aY*{(S*|-Q.W/PU*|(T(U(VU-Q*}+O+PS.W-R-SR/P.XQ#_^R&R#_Q#b_R&T#bQ#e`R&X#eQ(y&US+j(y+kR+k(zQ+n({R-a+nQ#iaR&[#iQ#lbR&^#lQ#ocR&`#oQ#qdR&a#qQ#tgQ&c#rW&f#t&c)b+uQ)b&wR+u1OQ$_xS&y$_&zR&z$`Q'X$lR)q'XQ&k#yR)Z&kQ$h!QR'R$hQ+y)iS-f+y.cR.c-gQ'V$jR)n'VQ,R)tR-k,RQ#wkR&h#wQ)x']R,U)xQ'`$qS*P'`*QR*Q'aQ'h$xR*X'hQ'm$yS*c'm,nR,n*dQ,t*iR.O,tWoOs*W,dR#{oQ.Q,xR.m.Qd/e.t/y0Q0V0e0g0i0t0x0yR0P/eU/].o/x0hR/w/]Q0d0VS0p0d0qR0q0eS0_/y/zR0l0_Q/g.tR0S/gR!`PXrOs*W,dWqOs*W,dR'f$wYkOs$w*W,dR&g#v[xOs#v$w*W,dR&x$^&hQOYZ[isuw}!O!S!U!V!Z!n!p!t!u!v!x!y#c#g#j#m#s#v$Y$[$^$a$u$w%[%a%h%k%m%t%y%{&V&b&o&s'O'P'W'Z'b'i'l'}(O(R(T(U(Y(a(i(o(u(x)V)X)a)p)w)y*S*W*^*b*l*v*y*z*}+T+U+W+Y+]+^+a+h+i+l+t+w,O,d,l,m,p,z,{,|-O-P-S-U-W-Y-[-^-_-b-y-{.S.V.Y.}/O/s0[0z0{0|0}1P1Q1R1S1V1ZQ!sTQ#rfQ$PtU$by%p(eS$q!W$tQ$}!^Q%S!hQ%T!iQ%U!jQ%V!kQ%W!lQ%X!mQ%r#PQ%w#TQ%}#XQ&O#YQ&t$XQ'a$rQ'x%OQ)W&dU)c&|)d+vW)|'_*O,],^Q+R(_Q+[(nQ,[)}Q-Z+dQ0Y/oR1O1TQ#OYQ#SZQ$o!UQ$p!VQ%`!pQ(V%a^(^%m%t(a(i+T+W+Y^*x(R*z-O-P.V/O/sQ+O(TQ+P(UQ,X)yQ,}*yQ-R*}Q.T,{Q.U,|Q.X-SQ.|.SR/r.}[gOs#v$w*W,d!^!{YZ!U!V!p%a%m%t(R(T(U(a(i)y*y*z*}+T+W+Y,{,|-O-P-S.S.V.}/O/sQ#W[Q#uiS$Ww}Q$e!OW$l!S$a'b*SS$y!Z$uW%Y!n(O*v,zY&U#c#g#j#m+l`&e#s&b)V)X)a+t-b1SQ&u$YQ&v$[Q&w$^Q'{%[Q(]%kW(m%y(o+]+aQ(q%{Q(z&VQ)]&oS)`&s1QQ)f'OQ)g'PU)o'W)p,OQ)v'ZQ*]'iY*a'l*b,l,m-yQ*t'}S+Q(Y1RW+c(u+^-W-[W+g(x+i-^-_Q,T)wQ,i*^Q,v*lQ-]+hQ-c+wQ-z,pQ.]-YR.k-{hUOs#s#v$w&b&s(Y)V)X*W,d%Y!zYZ[iw}!O!S!U!V!Z!n!p#c#g#j#m$Y$[$^$a$u%[%a%k%m%t%y%{&V&o'O'P'W'Z'b'i'l'}(O(R(T(U(a(i(o(u(x)a)p)w)y*S*^*b*l*v*y*z*}+T+W+Y+]+^+a+h+i+l+t+w,O,l,m,p,z,{,|-O-P-S-W-Y-[-^-_-b-y-{.S.V.}/O/s1Q1R1SQ$QuW%e!t!x0{1VQ%f!uQ%g!vQ%i!yQ%s0zS(X%h1PQ(Z0|Q([0}Q-T+UQ.[-US/Q.Y0[R1X1ZU$Uv/S1YR)^&q[hOs#v$w*W,da!}Y#c#g#j#m$^$a+lQ#][Q$ZwR$d}Q%o#OQ%v#SQ%|#WQ'{%YQ(h%rQ(l%wQ(t%}Q(w&OQ+`(qQ,y*tQ.Z-TQ/U.[R/u/TQ$cyQ(d%pR+V(eQ/T.YR0f0[R#VZR#[[R%_!nQ%]!nV*u(O*v,z!]!qQ!s#r$P$b$q$}%S%T%U%V%W%X%r%w%}&O&t'a'x)W)c)|+R+[,[-Z0Y1OR%b!pQ&W#cQ&Z#gQ&]#jQ&_#mR-`+lQ(}&WQ)P&ZQ)R&]Q)T&_Q+p)OQ+q)QQ+r)SQ+s)UQ.^-`R/V._Q$m!SQ&{$aQ*R'bR,`*SQ#zmQ$f!PQ$i!QR'T$hQ)h'SR+|)kQ)h'SQ+{)jR+|)kR$k!RR)u'YXqOs*W,dQ$s!WR'c$tQ$z!ZR'd$uR*k'pQ*i'pV-|,s-}.lQ.{.RQ/i.uR/j.vU.t.R.u.vQ/n.xQ/y/^Q0O/dU0Q/f0R0bQ0V/kQ0e0WQ0g0]U0i0^0k0sQ0t0mQ0x0rR0y0uR/m.wR/{/^\",\n    nodeNames: \"⚠ print { { { { Comment Script AssignStatement * BinaryExpression BitOp BitOp BitOp BitOp ArithOp ArithOp @ ArithOp ** UnaryExpression ArithOp BitOp AwaitExpression await ) ( ParenthesizedExpression BinaryExpression or and CompareOp in not is UnaryExpression ConditionalExpression if else LambdaExpression lambda ParamList VariableName AssignOp , : NamedExpression AssignOp YieldExpression yield from TupleExpression ComprehensionExpression async for LambdaExpression ] [ ArrayExpression ArrayComprehensionExpression } { DictionaryExpression DictionaryComprehensionExpression SetExpression SetComprehensionExpression CallExpression ArgList AssignOp MemberExpression . PropertyName Number String FormatString FormatReplacement FormatConversion FormatSpec FormatReplacement FormatReplacement FormatReplacement FormatReplacement ContinuedString Ellipsis None Boolean TypeDef AssignOp UpdateStatement UpdateOp ExpressionStatement DeleteStatement del PassStatement pass BreakStatement break ContinueStatement continue ReturnStatement return YieldStatement PrintStatement RaiseStatement raise ImportStatement import as ScopeStatement global nonlocal AssertStatement assert TypeDefinition type TypeParamList TypeParam StatementGroup ; IfStatement Body elif WhileStatement while ForStatement TryStatement try except finally WithStatement with FunctionDefinition def ParamList AssignOp TypeDef ClassDefinition class DecoratedStatement Decorator At MatchStatement match MatchBody MatchClause case CapturePattern LiteralPattern ArithOp ArithOp AsPattern OrPattern LogicOp AttributePattern SequencePattern MappingPattern StarPattern ClassPattern PatternArgList KeywordPattern KeywordPattern Guard\",\n    maxTerm: 283,\n    context: trackIndent,\n    nodeProps: [\n        [\n            \"group\",\n            -15,\n            8,\n            88,\n            90,\n            91,\n            93,\n            95,\n            97,\n            99,\n            101,\n            102,\n            103,\n            105,\n            108,\n            111,\n            113,\n            \"Statement Statement\",\n            -22,\n            10,\n            20,\n            23,\n            27,\n            42,\n            51,\n            52,\n            58,\n            59,\n            62,\n            63,\n            64,\n            65,\n            66,\n            69,\n            72,\n            73,\n            74,\n            82,\n            83,\n            84,\n            85,\n            \"Expression\",\n            -10,\n            117,\n            119,\n            122,\n            124,\n            125,\n            129,\n            131,\n            136,\n            138,\n            141,\n            \"Statement\",\n            -9,\n            146,\n            147,\n            150,\n            151,\n            153,\n            154,\n            155,\n            156,\n            157,\n            \"Pattern\"\n        ],\n        [\n            \"openedBy\",\n            25,\n            \"(\",\n            56,\n            \"[\",\n            60,\n            \"{\"\n        ],\n        [\n            \"closedBy\",\n            26,\n            \")\",\n            57,\n            \"]\",\n            61,\n            \"}\"\n        ]\n    ],\n    propSources: [\n        pythonHighlighting\n    ],\n    skippedNodes: [\n        0,\n        6\n    ],\n    repeatNodeCount: 38,\n    tokenData: \"%-W#sR!`OX%TXY=|Y[%T[]=|]p%Tpq=|qr@_rsDOst!+|tu%Tuv!Nnvw#!|wx#$Wxy#:Uyz#;Yz{#<^{|#>x|}#@S}!O#AW!O!P#Ci!P!Q#N_!Q!R$!y!R![$&w![!]$1e!]!^$3s!^!_$4w!_!`$7c!`!a$8m!a!b%T!b!c$;U!c!d$<b!d!e$>W!e!h$<b!h!i$H[!i!t$<b!t!u%#r!u!w$<b!w!x$Fl!x!}$<b!}#O%%z#O#P?d#P#Q%'O#Q#R%(S#R#S$<b#S#T%T#T#U$<b#U#V$>W#V#Y$<b#Y#Z$H[#Z#f$<b#f#g%#r#g#i$<b#i#j$Fl#j#o$<b#o#p%)^#p#q%*S#q#r%+^#r#s%,S#s$g%T$g;'S$<b;'S;=`$>Q<%lO$<b!n%^]&r!b&jS&mWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T!n&^]&r!b&jSOr%Trs'Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T!n'^]&r!b&jSOr%Trs(Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T!f(^Z&r!b&jSOw(Vwx)Px#O(V#O#P+Z#P#o(V#o#p+x#p#q(V#q#r+x#r;'S(V;'S;=`/R<%lO(V!f)UZ&r!bOw(Vwx)wx#O(V#O#P+Z#P#o(V#o#p+x#p#q(V#q#r+x#r;'S(V;'S;=`/R<%lO(V!f)|Z&r!bOw(Vwx*ox#O(V#O#P+Z#P#o(V#o#p+x#p#q(V#q#r+x#r;'S(V;'S;=`/R<%lO(V!b*tT&r!bO#o*o#p#q*o#r;'S*o;'S;=`+T<%lO*o!b+WP;=`<%l*o!f+`W&r!bO#o(V#o#p+x#p#q(V#q#r+x#r;'S(V;'S;=`.d;=`<%l+x<%lO(VS+}V&jSOw+xwx,dx#O+x#O#P-c#P;'S+x;'S;=`.^<%lO+xS,gVOw+xwx,|x#O+x#O#P-c#P;'S+x;'S;=`.^<%lO+xS-PUOw+xx#O+x#O#P-c#P;'S+x;'S;=`.^<%lO+xS-fRO;'S+x;'S;=`-o;=`O+xS-tW&jSOw+xwx,dx#O+x#O#P-c#P;'S+x;'S;=`.^;=`<%l+x<%lO+xS.aP;=`<%l+x!f.iW&jSOw+xwx,dx#O+x#O#P-c#P;'S+x;'S;=`.^;=`<%l(V<%lO+x!f/UP;=`<%l(V!n/`]&r!b&mWOr%Trs&Vsw%Twx0Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T!n0`]&r!b&mWOr%Trs&Vsw%Twx1Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T!j1`Z&r!b&mWOr1Xrs2Rs#O1X#O#P3q#P#o1X#o#p4`#p#q1X#q#r4`#r;'S1X;'S;=`7i<%lO1X!j2WZ&r!bOr1Xrs2ys#O1X#O#P3q#P#o1X#o#p4`#p#q1X#q#r4`#r;'S1X;'S;=`7i<%lO1X!j3OZ&r!bOr1Xrs*os#O1X#O#P3q#P#o1X#o#p4`#p#q1X#q#r4`#r;'S1X;'S;=`7i<%lO1X!j3vW&r!bO#o1X#o#p4`#p#q1X#q#r4`#r;'S1X;'S;=`6z;=`<%l4`<%lO1XW4eV&mWOr4`rs4zs#O4`#O#P5y#P;'S4`;'S;=`6t<%lO4`W4}VOr4`rs5ds#O4`#O#P5y#P;'S4`;'S;=`6t<%lO4`W5gUOr4`s#O4`#O#P5y#P;'S4`;'S;=`6t<%lO4`W5|RO;'S4`;'S;=`6V;=`O4`W6[W&mWOr4`rs4zs#O4`#O#P5y#P;'S4`;'S;=`6t;=`<%l4`<%lO4`W6wP;=`<%l4`!j7PW&mWOr4`rs4zs#O4`#O#P5y#P;'S4`;'S;=`6t;=`<%l1X<%lO4`!j7lP;=`<%l1X!n7tW&r!bO#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=P;=`<%l8^<%lO%T[8eX&jS&mWOr8^rs9Qsw8^wx:dx#O8^#O#P;v#P;'S8^;'S;=`<y<%lO8^[9VX&jSOr8^rs9rsw8^wx:dx#O8^#O#P;v#P;'S8^;'S;=`<y<%lO8^[9wX&jSOr8^rs+xsw8^wx:dx#O8^#O#P;v#P;'S8^;'S;=`<y<%lO8^[:iX&mWOr8^rs9Qsw8^wx;Ux#O8^#O#P;v#P;'S8^;'S;=`<y<%lO8^[;ZX&mWOr8^rs9Qsw8^wx4`x#O8^#O#P;v#P;'S8^;'S;=`<y<%lO8^[;yRO;'S8^;'S;=`<S;=`O8^[<ZY&jS&mWOr8^rs9Qsw8^wx:dx#O8^#O#P;v#P;'S8^;'S;=`<y;=`<%l8^<%lO8^[<|P;=`<%l8^!n=WY&jS&mWOr8^rs9Qsw8^wx:dx#O8^#O#P;v#P;'S8^;'S;=`<y;=`<%l%T<%lO8^!n=yP;=`<%l%T#s>Xc&r!b&jS&mW%p!TOX%TXY=|Y[%T[]=|]p%Tpq=|qr%Trs&Vsw%Twx/Xx#O%T#O#P?d#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#s?i[&r!bOY%TYZ=|Z]%T]^=|^#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=P;=`<%l8^<%lO%T!q@hd&r!b&jS&mWOr%Trs&Vsw%Twx/Xx!_%T!_!`Av!`#O%T#O#P7o#P#T%T#T#UBz#U#f%T#f#gBz#g#hBz#h#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T!qBR]oR&r!b&jS&mWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T!qCV]!nR&r!b&jS&mWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#cDXa&r!b&jS&hsOYE^YZ%TZ]E^]^%T^rE^rs!)|swE^wxGpx#OE^#O#P!!u#P#oE^#o#p!#d#p#qE^#q#r!#d#r;'SE^;'S;=`!)v<%lOE^#cEia&r!b&jS&mW&hsOYE^YZ%TZ]E^]^%T^rE^rsFnswE^wxGpx#OE^#O#P!!u#P#oE^#o#p!#d#p#qE^#q#r!#d#r;'SE^;'S;=`!)v<%lOE^#cFw]&r!b&jS&hsOr%Trs'Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#cGya&r!b&mW&hsOYE^YZ%TZ]E^]^%T^rE^rsFnswE^wxIOx#OE^#O#P!!u#P#oE^#o#p!#d#p#qE^#q#r!#d#r;'SE^;'S;=`!)v<%lOE^#cIXa&r!b&mW&hsOYE^YZ%TZ]E^]^%T^rE^rsFnswE^wxJ^x#OE^#O#P!!u#P#oE^#o#p!#d#p#qE^#q#r!#d#r;'SE^;'S;=`!)v<%lOE^#_Jg_&r!b&mW&hsOYJ^YZ1XZ]J^]^1X^rJ^rsKfs#OJ^#O#PL`#P#oJ^#o#pL}#p#qJ^#q#rL}#r;'SJ^;'S;=`!!o<%lOJ^#_KmZ&r!b&hsOr1Xrs2ys#O1X#O#P3q#P#o1X#o#p4`#p#q1X#q#r4`#r;'S1X;'S;=`7i<%lO1X#_LeW&r!bO#oJ^#o#pL}#p#qJ^#q#rL}#r;'SJ^;'S;=`! r;=`<%lL}<%lOJ^{MUZ&mW&hsOYL}YZ4`Z]L}]^4`^rL}rsMws#OL}#O#PNc#P;'SL};'S;=`! l<%lOL}{M|V&hsOr4`rs5ds#O4`#O#P5y#P;'S4`;'S;=`6t<%lO4`{NfRO;'SL};'S;=`No;=`OL}{Nv[&mW&hsOYL}YZ4`Z]L}]^4`^rL}rsMws#OL}#O#PNc#P;'SL};'S;=`! l;=`<%lL}<%lOL}{! oP;=`<%lL}#_! y[&mW&hsOYL}YZ4`Z]L}]^4`^rL}rsMws#OL}#O#PNc#P;'SL};'S;=`! l;=`<%lJ^<%lOL}#_!!rP;=`<%lJ^#c!!zW&r!bO#oE^#o#p!#d#p#qE^#q#r!#d#r;'SE^;'S;=`!(q;=`<%l!#d<%lOE^!P!#m]&jS&mW&hsOY!#dYZ8^Z]!#d]^8^^r!#drs!$fsw!#dwx!%Yx#O!#d#O#P!'Y#P;'S!#d;'S;=`!(k<%lO!#d!P!$mX&jS&hsOr8^rs9rsw8^wx:dx#O8^#O#P;v#P;'S8^;'S;=`<y<%lO8^!P!%a]&mW&hsOY!#dYZ8^Z]!#d]^8^^r!#drs!$fsw!#dwx!&Yx#O!#d#O#P!'Y#P;'S!#d;'S;=`!(k<%lO!#d!P!&a]&mW&hsOY!#dYZ8^Z]!#d]^8^^r!#drs!$fsw!#dwxL}x#O!#d#O#P!'Y#P;'S!#d;'S;=`!(k<%lO!#d!P!']RO;'S!#d;'S;=`!'f;=`O!#d!P!'o^&jS&mW&hsOY!#dYZ8^Z]!#d]^8^^r!#drs!$fsw!#dwx!%Yx#O!#d#O#P!'Y#P;'S!#d;'S;=`!(k;=`<%l!#d<%lO!#d!P!(nP;=`<%l!#d#c!(z^&jS&mW&hsOY!#dYZ8^Z]!#d]^8^^r!#drs!$fsw!#dwx!%Yx#O!#d#O#P!'Y#P;'S!#d;'S;=`!(k;=`<%lE^<%lO!#d#c!)yP;=`<%lE^#c!*V]&r!b&jS&hsOr%Trs!+Osw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c!+ZZ&nW&r!b&jS&lsOw(Vwx)Px#O(V#O#P+Z#P#o(V#o#p+x#p#q(V#q#r+x#r;'S(V;'S;=`/R<%lO(V#s!,XaU!T&r!b&jS&mWOY!+|YZ%TZ]!+|]^%T^r!+|rs!-^sw!+|wx!:hx#O!+|#O#P!FW#P#o!+|#o#p!GT#p#q!+|#q#r!GT#r;'S!+|;'S;=`!Nh<%lO!+|#s!-gaU!T&r!b&jSOY!+|YZ%TZ]!+|]^%T^r!+|rs!.lsw!+|wx!:hx#O!+|#O#P!FW#P#o!+|#o#p!GT#p#q!+|#q#r!GT#r;'S!+|;'S;=`!Nh<%lO!+|#s!.uaU!T&r!b&jSOY!+|YZ%TZ]!+|]^%T^r!+|rs!/zsw!+|wx!:hx#O!+|#O#P!FW#P#o!+|#o#p!GT#p#q!+|#q#r!GT#r;'S!+|;'S;=`!Nh<%lO!+|#k!0T_U!T&r!b&jSOY!/zYZ(VZ]!/z]^(V^w!/zwx!1Sx#O!/z#O#P!4z#P#o!/z#o#p!5w#p#q!/z#q#r!5w#r;'S!/z;'S;=`!:b<%lO!/z#k!1Z_U!T&r!bOY!/zYZ(VZ]!/z]^(V^w!/zwx!2Yx#O!/z#O#P!4z#P#o!/z#o#p!5w#p#q!/z#q#r!5w#r;'S!/z;'S;=`!:b<%lO!/z#k!2a_U!T&r!bOY!/zYZ(VZ]!/z]^(V^w!/zwx!3`x#O!/z#O#P!4z#P#o!/z#o#p!5w#p#q!/z#q#r!5w#r;'S!/z;'S;=`!:b<%lO!/z#g!3gZU!T&r!bOY!3`YZ*oZ]!3`]^*o^#o!3`#o#p!4Y#p#q!3`#q#r!4Y#r;'S!3`;'S;=`!4t<%lO!3`!T!4_TU!TOY!4YZ]!4Y^;'S!4Y;'S;=`!4n<%lO!4Y!T!4qP;=`<%l!4Y#g!4wP;=`<%l!3`#k!5R[U!T&r!bOY!/zYZ(VZ]!/z]^(V^#o!/z#o#p!5w#p#q!/z#q#r!5w#r;'S!/z;'S;=`!9s;=`<%l+x<%lO!/z!X!6OZU!T&jSOY!5wYZ+xZ]!5w]^+x^w!5wwx!6qx#O!5w#O#P!8a#P;'S!5w;'S;=`!9m<%lO!5w!X!6vZU!TOY!5wYZ+xZ]!5w]^+x^w!5wwx!7ix#O!5w#O#P!8a#P;'S!5w;'S;=`!9m<%lO!5w!X!7nZU!TOY!5wYZ+xZ]!5w]^+x^w!5wwx!4Yx#O!5w#O#P!8a#P;'S!5w;'S;=`!9m<%lO!5w!X!8fWU!TOY!5wYZ+xZ]!5w]^+x^;'S!5w;'S;=`!9O;=`<%l+x<%lO!5w!X!9TW&jSOw+xwx,dx#O+x#O#P-c#P;'S+x;'S;=`.^;=`<%l!5w<%lO+x!X!9pP;=`<%l!5w#k!9xW&jSOw+xwx,dx#O+x#O#P-c#P;'S+x;'S;=`.^;=`<%l!/z<%lO+x#k!:eP;=`<%l!/z#s!:qaU!T&r!b&mWOY!+|YZ%TZ]!+|]^%T^r!+|rs!-^sw!+|wx!;vx#O!+|#O#P!FW#P#o!+|#o#p!GT#p#q!+|#q#r!GT#r;'S!+|;'S;=`!Nh<%lO!+|#s!<PaU!T&r!b&mWOY!+|YZ%TZ]!+|]^%T^r!+|rs!-^sw!+|wx!=Ux#O!+|#O#P!FW#P#o!+|#o#p!GT#p#q!+|#q#r!GT#r;'S!+|;'S;=`!Nh<%lO!+|#o!=__U!T&r!b&mWOY!=UYZ1XZ]!=U]^1X^r!=Urs!>^s#O!=U#O#P!@j#P#o!=U#o#p!Ag#p#q!=U#q#r!Ag#r;'S!=U;'S;=`!FQ<%lO!=U#o!>e_U!T&r!bOY!=UYZ1XZ]!=U]^1X^r!=Urs!?ds#O!=U#O#P!@j#P#o!=U#o#p!Ag#p#q!=U#q#r!Ag#r;'S!=U;'S;=`!FQ<%lO!=U#o!?k_U!T&r!bOY!=UYZ1XZ]!=U]^1X^r!=Urs!3`s#O!=U#O#P!@j#P#o!=U#o#p!Ag#p#q!=U#q#r!Ag#r;'S!=U;'S;=`!FQ<%lO!=U#o!@q[U!T&r!bOY!=UYZ1XZ]!=U]^1X^#o!=U#o#p!Ag#p#q!=U#q#r!Ag#r;'S!=U;'S;=`!Ec;=`<%l4`<%lO!=U!]!AnZU!T&mWOY!AgYZ4`Z]!Ag]^4`^r!Agrs!Bas#O!Ag#O#P!DP#P;'S!Ag;'S;=`!E]<%lO!Ag!]!BfZU!TOY!AgYZ4`Z]!Ag]^4`^r!Agrs!CXs#O!Ag#O#P!DP#P;'S!Ag;'S;=`!E]<%lO!Ag!]!C^ZU!TOY!AgYZ4`Z]!Ag]^4`^r!Agrs!4Ys#O!Ag#O#P!DP#P;'S!Ag;'S;=`!E]<%lO!Ag!]!DUWU!TOY!AgYZ4`Z]!Ag]^4`^;'S!Ag;'S;=`!Dn;=`<%l4`<%lO!Ag!]!DsW&mWOr4`rs4zs#O4`#O#P5y#P;'S4`;'S;=`6t;=`<%l!Ag<%lO4`!]!E`P;=`<%l!Ag#o!EhW&mWOr4`rs4zs#O4`#O#P5y#P;'S4`;'S;=`6t;=`<%l!=U<%lO4`#o!FTP;=`<%l!=U#s!F_[U!T&r!bOY!+|YZ%TZ]!+|]^%T^#o!+|#o#p!GT#p#q!+|#q#r!GT#r;'S!+|;'S;=`!Mq;=`<%l8^<%lO!+|!a!G^]U!T&jS&mWOY!GTYZ8^Z]!GT]^8^^r!GTrs!HVsw!GTwx!JVx#O!GT#O#P!LV#P;'S!GT;'S;=`!Mk<%lO!GT!a!H^]U!T&jSOY!GTYZ8^Z]!GT]^8^^r!GTrs!IVsw!GTwx!JVx#O!GT#O#P!LV#P;'S!GT;'S;=`!Mk<%lO!GT!a!I^]U!T&jSOY!GTYZ8^Z]!GT]^8^^r!GTrs!5wsw!GTwx!JVx#O!GT#O#P!LV#P;'S!GT;'S;=`!Mk<%lO!GT!a!J^]U!T&mWOY!GTYZ8^Z]!GT]^8^^r!GTrs!HVsw!GTwx!KVx#O!GT#O#P!LV#P;'S!GT;'S;=`!Mk<%lO!GT!a!K^]U!T&mWOY!GTYZ8^Z]!GT]^8^^r!GTrs!HVsw!GTwx!Agx#O!GT#O#P!LV#P;'S!GT;'S;=`!Mk<%lO!GT!a!L[WU!TOY!GTYZ8^Z]!GT]^8^^;'S!GT;'S;=`!Lt;=`<%l8^<%lO!GT!a!L{Y&jS&mWOr8^rs9Qsw8^wx:dx#O8^#O#P;v#P;'S8^;'S;=`<y;=`<%l!GT<%lO8^!a!MnP;=`<%l!GT#s!MxY&jS&mWOr8^rs9Qsw8^wx:dx#O8^#O#P;v#P;'S8^;'S;=`<y;=`<%l!+|<%lO8^#s!NkP;=`<%l!+|#b!Ny_&PQ&r!b&jS&mWOr%Trs&Vsw%Twx/Xx!_%T!_!`# x!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#b#!T]!{r&r!b&jS&mWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#b##X_%yQ&r!b&jS&mWOr%Trs&Vsw%Twx/Xx!_%T!_!`# x!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c#$aa&r!b&mW&hsOY#%fYZ%TZ]#%f]^%T^r#%frs#&vsw#%fwx#8Ux#O#%f#O#P#0}#P#o#%f#o#p#1l#p#q#%f#q#r#1l#r;'S#%f;'S;=`#8O<%lO#%f#c#%qa&r!b&jS&mW&hsOY#%fYZ%TZ]#%f]^%T^r#%frs#&vsw#%fwx#/{x#O#%f#O#P#0}#P#o#%f#o#p#1l#p#q#%f#q#r#1l#r;'S#%f;'S;=`#8O<%lO#%f#c#'Pa&r!b&jS&hsOY#%fYZ%TZ]#%f]^%T^r#%frs#(Usw#%fwx#/{x#O#%f#O#P#0}#P#o#%f#o#p#1l#p#q#%f#q#r#1l#r;'S#%f;'S;=`#8O<%lO#%f#c#(_a&r!b&jS&hsOY#%fYZ%TZ]#%f]^%T^r#%frs#)dsw#%fwx#/{x#O#%f#O#P#0}#P#o#%f#o#p#1l#p#q#%f#q#r#1l#r;'S#%f;'S;=`#8O<%lO#%f#Z#)m_&r!b&jS&hsOY#)dYZ(VZ]#)d]^(V^w#)dwx#*lx#O#)d#O#P#+f#P#o#)d#o#p#,T#p#q#)d#q#r#,T#r;'S#)d;'S;=`#/u<%lO#)d#Z#*sZ&r!b&hsOw(Vwx)wx#O(V#O#P+Z#P#o(V#o#p+x#p#q(V#q#r+x#r;'S(V;'S;=`/R<%lO(V#Z#+kW&r!bO#o#)d#o#p#,T#p#q#)d#q#r#,T#r;'S#)d;'S;=`#.x;=`<%l#,T<%lO#)dw#,[Z&jS&hsOY#,TYZ+xZ]#,T]^+x^w#,Twx#,}x#O#,T#O#P#-i#P;'S#,T;'S;=`#.r<%lO#,Tw#-SV&hsOw+xwx,|x#O+x#O#P-c#P;'S+x;'S;=`.^<%lO+xw#-lRO;'S#,T;'S;=`#-u;=`O#,Tw#-|[&jS&hsOY#,TYZ+xZ]#,T]^+x^w#,Twx#,}x#O#,T#O#P#-i#P;'S#,T;'S;=`#.r;=`<%l#,T<%lO#,Tw#.uP;=`<%l#,T#Z#/P[&jS&hsOY#,TYZ+xZ]#,T]^+x^w#,Twx#,}x#O#,T#O#P#-i#P;'S#,T;'S;=`#.r;=`<%l#)d<%lO#,T#Z#/xP;=`<%l#)d#c#0U]&r!b&mW&hsOr%Trs&Vsw%Twx0Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c#1SW&r!bO#o#%f#o#p#1l#p#q#%f#q#r#1l#r;'S#%f;'S;=`#6y;=`<%l#1l<%lO#%f!P#1u]&jS&mW&hsOY#1lYZ8^Z]#1l]^8^^r#1lrs#2nsw#1lwx#4nx#O#1l#O#P#5b#P;'S#1l;'S;=`#6s<%lO#1l!P#2u]&jS&hsOY#1lYZ8^Z]#1l]^8^^r#1lrs#3nsw#1lwx#4nx#O#1l#O#P#5b#P;'S#1l;'S;=`#6s<%lO#1l!P#3u]&jS&hsOY#1lYZ8^Z]#1l]^8^^r#1lrs#,Tsw#1lwx#4nx#O#1l#O#P#5b#P;'S#1l;'S;=`#6s<%lO#1l!P#4uX&mW&hsOr8^rs9Qsw8^wx;Ux#O8^#O#P;v#P;'S8^;'S;=`<y<%lO8^!P#5eRO;'S#1l;'S;=`#5n;=`O#1l!P#5w^&jS&mW&hsOY#1lYZ8^Z]#1l]^8^^r#1lrs#2nsw#1lwx#4nx#O#1l#O#P#5b#P;'S#1l;'S;=`#6s;=`<%l#1l<%lO#1l!P#6vP;=`<%l#1l#c#7S^&jS&mW&hsOY#1lYZ8^Z]#1l]^8^^r#1lrs#2nsw#1lwx#4nx#O#1l#O#P#5b#P;'S#1l;'S;=`#6s;=`<%l#%f<%lO#1l#c#8RP;=`<%l#%f#c#8_]&r!b&mW&hsOr%Trs&Vsw%Twx#9Wx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c#9cZ&kS&r!b&mW&isOr1Xrs2Rs#O1X#O#P3q#P#o1X#o#p4`#p#q1X#q#r4`#r;'S1X;'S;=`7i<%lO1X#c#:a]js&r!b&jS&mWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T!q#;e]iR&r!b&jS&mWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c#<iaXs&r!b&jS&mWOr%Trs&Vsw%Twx/Xxz%Tz{#=n{!_%T!_!`# x!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c#=y_cR&r!b&jS&mWOr%Trs&Vsw%Twx/Xx!_%T!_!`# x!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c#?T_%|s&r!b&jS&mWOr%Trs&Vsw%Twx/Xx!_%T!_!`# x!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T!q#@_]|R&r!b&jS&mWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#s#Ac`%}s&r!b&jS&mWOr%Trs&Vsw%Twx/Xx!_%T!_!`# x!`!a#Be!a#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#O#Bp]'R`&r!b&jS&mWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c#Cta!hQ&r!b&jS&mWOr%Trs&Vsw%Twx/Xx!O%T!O!P#Dy!P!Q%T!Q![#GV![#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c#ES_&r!b&jS&mWOr%Trs&Vsw%Twx/Xx!O%T!O!P#FR!P#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c#F^]!us&r!b&jS&mWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a#Gbi!jq&r!b&jS&mWOr%Trs&Vsw%Twx/Xx!Q%T!Q![#GV![!g%T!g!h#IP!h!l%T!l!m#MZ!m#O%T#O#P7o#P#R%T#R#S#GV#S#X%T#X#Y#IP#Y#^%T#^#_#MZ#_#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a#IYc&r!b&jS&mWOr%Trs&Vsw%Twx/Xx{%T{|#Je|}%T}!O#Je!O!Q%T!Q![#Km![#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a#Jn_&r!b&jS&mWOr%Trs&Vsw%Twx/Xx!Q%T!Q![#Km![#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a#Kxe!jq&r!b&jS&mWOr%Trs&Vsw%Twx/Xx!Q%T!Q![#Km![!l%T!l!m#MZ!m#O%T#O#P7o#P#R%T#R#S#Km#S#^%T#^#_#MZ#_#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a#Mf]!jq&r!b&jS&mWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c#Nja&OR&r!b&jS&mWOr%Trs&Vsw%Twx/Xx!P%T!P!Q$ o!Q!_%T!_!`# x!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#b$ z_&QQ&r!b&jS&mWOr%Trs&Vsw%Twx/Xx!_%T!_!`# x!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a$#Uw!jq&r!b&jS&mWOr%Trs&Vsw%Twx/Xx!O%T!O!P$%o!P!Q%T!Q![$&w![!d%T!d!e$(w!e!g%T!g!h#IP!h!l%T!l!m#MZ!m!q%T!q!r$+m!r!z%T!z!{$.]!{#O%T#O#P7o#P#R%T#R#S$&w#S#U%T#U#V$(w#V#X%T#X#Y#IP#Y#^%T#^#_#MZ#_#c%T#c#d$+m#d#l%T#l#m$.]#m#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a$%x_&r!b&jS&mWOr%Trs&Vsw%Twx/Xx!Q%T!Q![#GV![#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a$'Sk!jq&r!b&jS&mWOr%Trs&Vsw%Twx/Xx!O%T!O!P$%o!P!Q%T!Q![$&w![!g%T!g!h#IP!h!l%T!l!m#MZ!m#O%T#O#P7o#P#R%T#R#S$&w#S#X%T#X#Y#IP#Y#^%T#^#_#MZ#_#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a$)Qb&r!b&jS&mWOr%Trs&Vsw%Twx/Xx!Q%T!Q!R$*Y!R!S$*Y!S#O%T#O#P7o#P#R%T#R#S$*Y#S#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a$*eb!jq&r!b&jS&mWOr%Trs&Vsw%Twx/Xx!Q%T!Q!R$*Y!R!S$*Y!S#O%T#O#P7o#P#R%T#R#S$*Y#S#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a$+va&r!b&jS&mWOr%Trs&Vsw%Twx/Xx!Q%T!Q!Y$,{!Y#O%T#O#P7o#P#R%T#R#S$,{#S#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a$-Wa!jq&r!b&jS&mWOr%Trs&Vsw%Twx/Xx!Q%T!Q!Y$,{!Y#O%T#O#P7o#P#R%T#R#S$,{#S#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a$.fe&r!b&jS&mWOr%Trs&Vsw%Twx/Xx!Q%T!Q![$/w![!c%T!c!i$/w!i#O%T#O#P7o#P#R%T#R#S$/w#S#T%T#T#Z$/w#Z#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a$0Se!jq&r!b&jS&mWOr%Trs&Vsw%Twx/Xx!Q%T!Q![$/w![!c%T!c!i$/w!i#O%T#O#P7o#P#R%T#R#S$/w#S#T%T#T#Z$/w#Z#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#s$1p_}!T&r!b&jS&mWOr%Trs&Vsw%Twx/Xx!_%T!_!`$2o!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T!q$2z]&YR&r!b&jS&mWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c$4O]#js&r!b&jS&mWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c$5SaoR&r!b&jS&mWOr%Trs&Vsw%Twx/Xx!^%T!^!_$6X!_!`Av!`!aAv!a#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#b$6d_%zQ&r!b&jS&mWOr%Trs&Vsw%Twx/Xx!_%T!_!`# x!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c$7n_&Xs&r!b&jS&mWOr%Trs&Vsw%Twx/Xx!_%T!_!`Av!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c$8x`oR&r!b&jS&mWOr%Trs&Vsw%Twx/Xx!_%T!_!`Av!`!a$9z!a#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#b$:V_%{Q&r!b&jS&mWOr%Trs&Vsw%Twx/Xx!_%T!_!`# x!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c$;c_aQ$QP&r!b&jS&mWOr%Trs&Vsw%Twx/Xx!_%T!_!`# x!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#s$<oe&r!b&jS&mW&g`&SsOr%Trs&Vsw%Twx/Xx!Q%T!Q![$<b![!c%T!c!}$<b!}#O%T#O#P7o#P#R%T#R#S$<b#S#T%T#T#o$<b#o#p8^#p#q%T#q#r8^#r$g%T$g;'S$<b;'S;=`$>Q<%lO$<b#s$>TP;=`<%l$<b#s$>ei&r!b&jS&mW&g`&SsOr%Trs$@Ssw%Twx$C`x!Q%T!Q![$<b![!c%T!c!t$<b!t!u$Fl!u!}$<b!}#O%T#O#P7o#P#R%T#R#S$<b#S#T%T#T#f$<b#f#g$Fl#g#o$<b#o#p8^#p#q%T#q#r8^#r$g%T$g;'S$<b;'S;=`$>Q<%lO$<b#c$@]a&r!b&jS&hsOYE^YZ%TZ]E^]^%T^rE^rs$AbswE^wxGpx#OE^#O#P!!u#P#oE^#o#p!#d#p#qE^#q#r!#d#r;'SE^;'S;=`!)v<%lOE^#c$Ak]&r!b&jS&hsOr%Trs$Bdsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#Z$BmZ&r!b&jS&lsOw(Vwx)Px#O(V#O#P+Z#P#o(V#o#p+x#p#q(V#q#r+x#r;'S(V;'S;=`/R<%lO(V#c$Cia&r!b&mW&hsOY#%fYZ%TZ]#%f]^%T^r#%frs#&vsw#%fwx$Dnx#O#%f#O#P#0}#P#o#%f#o#p#1l#p#q#%f#q#r#1l#r;'S#%f;'S;=`#8O<%lO#%f#c$Dw]&r!b&mW&hsOr%Trs&Vsw%Twx$Epx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#_$EyZ&r!b&mW&isOr1Xrs2Rs#O1X#O#P3q#P#o1X#o#p4`#p#q1X#q#r4`#r;'S1X;'S;=`7i<%lO1X#s$Fye&r!b&jS&mW&g`&SsOr%Trs$@Ssw%Twx$C`x!Q%T!Q![$<b![!c%T!c!}$<b!}#O%T#O#P7o#P#R%T#R#S$<b#S#T%T#T#o$<b#o#p8^#p#q%T#q#r8^#r$g%T$g;'S$<b;'S;=`$>Q<%lO$<b#s$Hii&r!b&jS&mW&g`&SsOr%Trs$JWsw%Twx$MUx!Q%T!Q![$<b![!c%T!c!t$<b!t!u%!S!u!}$<b!}#O%T#O#P7o#P#R%T#R#S$<b#S#T%T#T#f$<b#f#g%!S#g#o$<b#o#p8^#p#q%T#q#r8^#r$g%T$g;'S$<b;'S;=`$>Q<%lO$<b#c$Ja]&r!b&jS&ssOr%Trs$KYsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c$Ka]&r!b&jSOr%Trs$LYsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#Z$LcZ&r!b&jS&usOw(Vwx)Px#O(V#O#P+Z#P#o(V#o#p+x#p#q(V#q#r+x#r;'S(V;'S;=`/R<%lO(V#c$M_]&r!b&mW&osOr%Trs&Vsw%Twx$NWx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c$N_]&r!b&mWOr%Trs&Vsw%Twx% Wx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#_% aZ&r!b&mW&tsOr1Xrs2Rs#O1X#O#P3q#P#o1X#o#p4`#p#q1X#q#r4`#r;'S1X;'S;=`7i<%lO1X#s%!ae&r!b&jS&mW&g`&SsOr%Trs$JWsw%Twx$MUx!Q%T!Q![$<b![!c%T!c!}$<b!}#O%T#O#P7o#P#R%T#R#S$<b#S#T%T#T#o$<b#o#p8^#p#q%T#q#r8^#r$g%T$g;'S$<b;'S;=`$>Q<%lO$<b#s%$Pm&r!b&jS&mW&g`&SsOr%Trs$@Ssw%Twx$C`x!Q%T!Q![$<b![!c%T!c!h$<b!h!i%!S!i!t$<b!t!u$Fl!u!}$<b!}#O%T#O#P7o#P#R%T#R#S$<b#S#T%T#T#U$<b#U#V$Fl#V#Y$<b#Y#Z%!S#Z#o$<b#o#p8^#p#q%T#q#r8^#r$g%T$g;'S$<b;'S;=`$>Q<%lO$<b#c%&V]!Zs&r!b&jS&mWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T!q%'Z]!YR&r!b&jS&mWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#b%(__%xQ&r!b&jS&mWOr%Trs&Vsw%Twx/Xx!_%T!_!`# x!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a%)gX!_#T&jS&mWOr8^rs9Qsw8^wx:dx#O8^#O#P;v#P;'S8^;'S;=`<y<%lO8^#c%*__%wR&r!b&jS&mWOr%Trs&Vsw%Twx/Xx!_%T!_!`# x!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T!q%+gX!^!e&jS&mWOr8^rs9Qsw8^wx:dx#O8^#O#P;v#P;'S8^;'S;=`<y<%lO8^#a%,_]&Rq&r!b&jS&mWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T\",\n    tokenizers: [\n        legacyPrint,\n        indentation,\n        newlines,\n        formatString1,\n        formatString2,\n        formatString1l,\n        formatString2l,\n        0,\n        1,\n        2,\n        3,\n        4,\n        5,\n        6\n    ],\n    topRules: {\n        \"Script\": [\n            0,\n            7\n        ]\n    },\n    specialized: [\n        {\n            term: 234,\n            get: (value)=>spec_identifier[value] || -1\n        }\n    ],\n    tokenPrec: 7372\n});\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxlemVyL3B5dGhvbi9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUF3RTtBQUNyQjtBQUVuRCw4RUFBOEU7QUFDOUUsTUFBTUssZUFBZSxHQUNuQkMsU0FBUyxLQUNUQyxTQUFTLEtBQ1RDLFlBQVksS0FDWkMsaUJBQWlCLEtBQ2pCQyxtQkFBbUIsS0FDbkJDLE1BQU0sS0FDTkMsdUJBQXVCLEtBQ3ZCQyxxQkFBcUIsR0FDckJDLG1CQUFtQixLQUNuQkMsdUJBQXVCLEtBQ3ZCQyxxQkFBcUIsR0FDckJDLG1CQUFtQixLQUNuQkMsd0JBQXdCLEtBQ3hCQyxzQkFBc0IsR0FDdEJDLG9CQUFvQixLQUNwQkMsd0JBQXdCLEtBQ3hCQyxzQkFBc0IsR0FDdEJDLG9CQUFvQixLQUNwQkMsU0FBUyxJQUNUQywwQkFBMEIsSUFDMUJDLGtCQUFrQixJQUNsQkMsMEJBQTBCLElBQzFCQyxXQUFXLElBQ1hDLGtCQUFrQixJQUNsQkMsK0JBQStCLElBQy9CQyxTQUFTLElBQ1RDLHVCQUF1QixJQUN2QkMsb0NBQW9DLElBQ3BDQyxnQkFBZ0IsSUFDaEJDLDZCQUE2QixJQUM3QkMsVUFBVSxJQUNWQyxZQUFZLEtBQ1pDLGVBQWUsSUFDZkMsYUFBYSxLQUNiQyxnQkFBZ0IsS0FDaEJDLFlBQVksS0FDWkMsa0JBQWtCLEtBQ2xCQyxpQkFBaUIsS0FDakJDLGlCQUFpQjtBQUVuQixNQUFNQyxVQUFVLElBQUlDLGlCQUFpQixJQUFJQyxRQUFRLElBQUlDLE1BQU0sR0FBR0MsT0FBTyxJQUFJQyxZQUFZLElBQUlDLE1BQU0sSUFDekZDLFlBQVksS0FBS0MsY0FBYyxJQUFJQyxjQUFjLElBQUlDLFlBQVk7QUFFdkUsTUFBTUMsWUFBWSxJQUFJQyxJQUFJO0lBQ3hCaEM7SUFBeUJDO0lBQWlCQztJQUF5Qlk7SUFBWUg7SUFBU0s7SUFDeEZaO0lBQWlCQztJQUE4Qk87SUFDL0NIO0lBQWVDO0lBQTRCRztJQUMzQ047SUFBc0JDO0lBQ3RC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QUNiO0FBRWtCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHl0aG9uLW9ubGluZS1lZGl0b3IvLi9ub2RlX21vZHVsZXMvQGxlemVyL3B5dGhvbi9kaXN0L2luZGV4LmpzPzBjYmYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRXh0ZXJuYWxUb2tlbml6ZXIsIENvbnRleHRUcmFja2VyLCBMUlBhcnNlciB9IGZyb20gJ0BsZXplci9scic7XG5pbXBvcnQgeyBzdHlsZVRhZ3MsIHRhZ3MgfSBmcm9tICdAbGV6ZXIvaGlnaGxpZ2h0JztcblxuLy8gVGhpcyBmaWxlIHdhcyBnZW5lcmF0ZWQgYnkgbGV6ZXItZ2VuZXJhdG9yLiBZb3UgcHJvYmFibHkgc2hvdWxkbid0IGVkaXQgaXQuXG5jb25zdCBwcmludEtleXdvcmQgPSAxLFxuICBpbmRlbnQgPSAyMDEsXG4gIGRlZGVudCA9IDIwMixcbiAgbmV3bGluZSQxID0gMjAzLFxuICBibGFua0xpbmVTdGFydCA9IDIwNCxcbiAgbmV3bGluZUJyYWNrZXRlZCA9IDIwNSxcbiAgZW9mID0gMjA2LFxuICBmb3JtYXRTdHJpbmcxQ29udGVudCA9IDIwNyxcbiAgZm9ybWF0U3RyaW5nMUJyYWNlID0gMixcbiAgZm9ybWF0U3RyaW5nMUVuZCA9IDIwOCxcbiAgZm9ybWF0U3RyaW5nMkNvbnRlbnQgPSAyMDksXG4gIGZvcm1hdFN0cmluZzJCcmFjZSA9IDMsXG4gIGZvcm1hdFN0cmluZzJFbmQgPSAyMTAsXG4gIGZvcm1hdFN0cmluZzFsQ29udGVudCA9IDIxMSxcbiAgZm9ybWF0U3RyaW5nMWxCcmFjZSA9IDQsXG4gIGZvcm1hdFN0cmluZzFsRW5kID0gMjEyLFxuICBmb3JtYXRTdHJpbmcybENvbnRlbnQgPSAyMTMsXG4gIGZvcm1hdFN0cmluZzJsQnJhY2UgPSA1LFxuICBmb3JtYXRTdHJpbmcybEVuZCA9IDIxNCxcbiAgUGFyZW5MID0gMjYsXG4gIFBhcmVudGhlc2l6ZWRFeHByZXNzaW9uID0gMjcsXG4gIFR1cGxlRXhwcmVzc2lvbiA9IDUxLFxuICBDb21wcmVoZW5zaW9uRXhwcmVzc2lvbiA9IDUyLFxuICBCcmFja2V0TCA9IDU3LFxuICBBcnJheUV4cHJlc3Npb24gPSA1OCxcbiAgQXJyYXlDb21wcmVoZW5zaW9uRXhwcmVzc2lvbiA9IDU5LFxuICBCcmFjZUwgPSA2MSxcbiAgRGljdGlvbmFyeUV4cHJlc3Npb24gPSA2MixcbiAgRGljdGlvbmFyeUNvbXByZWhlbnNpb25FeHByZXNzaW9uID0gNjMsXG4gIFNldEV4cHJlc3Npb24gPSA2NCxcbiAgU2V0Q29tcHJlaGVuc2lvbkV4cHJlc3Npb24gPSA2NSxcbiAgQXJnTGlzdCA9IDY3LFxuICBzdWJzY3JpcHQgPSAyNTEsXG4gIEZvcm1hdFN0cmluZyA9IDc0LFxuICBpbXBvcnRMaXN0ID0gMjcwLFxuICBUeXBlUGFyYW1MaXN0ID0gMTE1LFxuICBQYXJhbUxpc3QgPSAxMzMsXG4gIFNlcXVlbmNlUGF0dGVybiA9IDE1NCxcbiAgTWFwcGluZ1BhdHRlcm4gPSAxNTUsXG4gIFBhdHRlcm5BcmdMaXN0ID0gMTU4O1xuXG5jb25zdCBuZXdsaW5lID0gMTAsIGNhcnJpYWdlUmV0dXJuID0gMTMsIHNwYWNlID0gMzIsIHRhYiA9IDksIGhhc2ggPSAzNSwgcGFyZW5PcGVuID0gNDAsIGRvdCA9IDQ2LFxuICAgICAgYnJhY2VPcGVuID0gMTIzLCBzaW5nbGVRdW90ZSA9IDM5LCBkb3VibGVRdW90ZSA9IDM0LCBiYWNrc2xhc2ggPSA5MjtcblxuY29uc3QgYnJhY2tldGVkID0gbmV3IFNldChbXG4gIFBhcmVudGhlc2l6ZWRFeHByZXNzaW9uLCBUdXBsZUV4cHJlc3Npb24sIENvbXByZWhlbnNpb25FeHByZXNzaW9uLCBpbXBvcnRMaXN0LCBBcmdMaXN0LCBQYXJhbUxpc3QsXG4gIEFycmF5RXhwcmVzc2lvbiwgQXJyYXlDb21wcmVoZW5zaW9uRXhwcmVzc2lvbiwgc3Vic2NyaXB0LFxuICBTZXRFeHByZXNzaW9uLCBTZXRDb21wcmVoZW5zaW9uRXhwcmVzc2lvbiwgRm9ybWF0U3RyaW5nLFxuICBEaWN0aW9uYXJ5RXhwcmVzc2lvbiwgRGljdGlvbmFyeUNvbXByZWhlbnNpb25FeHByZXNzaW9uLFxuICBTZXF1ZW5jZVBhdHRlcm4sIE1hcHBpbmdQYXR0ZXJuLCBQYXR0ZXJuQXJnTGlzdCwgVHlwZVBhcmFtTGlzdFxuXSk7XG5cbmZ1bmN0aW9uIGlzTGluZUJyZWFrKGNoKSB7XG4gIHJldHVybiBjaCA9PSBuZXdsaW5lIHx8IGNoID09IGNhcnJpYWdlUmV0dXJuXG59XG5cbmNvbnN0IG5ld2xpbmVzID0gbmV3IEV4dGVybmFsVG9rZW5pemVyKChpbnB1dCwgc3RhY2spID0+IHtcbiAgbGV0IHByZXY7XG4gIGlmIChpbnB1dC5uZXh0IDwgMCkge1xuICAgIGlucHV0LmFjY2VwdFRva2VuKGVvZik7XG4gIH0gZWxzZSBpZiAoc3RhY2suY29udGV4dC5kZXB0aCA8IDApIHtcbiAgICBpZiAoaXNMaW5lQnJlYWsoaW5wdXQubmV4dCkpIGlucHV0LmFjY2VwdFRva2VuKG5ld2xpbmVCcmFja2V0ZWQsIDEpO1xuICB9IGVsc2UgaWYgKCgocHJldiA9IGlucHV0LnBlZWsoLTEpKSA8IDAgfHwgaXNMaW5lQnJlYWsocHJldikpICYmXG4gICAgICAgICAgICAgc3RhY2suY2FuU2hpZnQoYmxhbmtMaW5lU3RhcnQpKSB7XG4gICAgbGV0IHNwYWNlcyA9IDA7XG4gICAgd2hpbGUgKGlucHV0Lm5leHQgPT0gc3BhY2UgfHwgaW5wdXQubmV4dCA9PSB0YWIpIHsgaW5wdXQuYWR2YW5jZSgpOyBzcGFjZXMrKzsgfVxuICAgIGlmIChpbnB1dC5uZXh0ID09IG5ld2xpbmUgfHwgaW5wdXQubmV4dCA9PSBjYXJyaWFnZVJldHVybiB8fCBpbnB1dC5uZXh0ID09IGhhc2gpXG4gICAgICBpbnB1dC5hY2NlcHRUb2tlbihibGFua0xpbmVTdGFydCwgLXNwYWNlcyk7XG4gIH0gZWxzZSBpZiAoaXNMaW5lQnJlYWsoaW5wdXQubmV4dCkpIHtcbiAgICBpbnB1dC5hY2NlcHRUb2tlbihuZXdsaW5lJDEsIDEpO1xuICB9XG59LCB7Y29udGV4dHVhbDogdHJ1ZX0pO1xuXG5jb25zdCBpbmRlbnRhdGlvbiA9IG5ldyBFeHRlcm5hbFRva2VuaXplcigoaW5wdXQsIHN0YWNrKSA9PiB7XG4gIGxldCBjRGVwdGggPSBzdGFjay5jb250ZXh0LmRlcHRoO1xuICBpZiAoY0RlcHRoIDwgMCkgcmV0dXJuXG4gIGxldCBwcmV2ID0gaW5wdXQucGVlaygtMSk7XG4gIGlmIChwcmV2ID09IG5ld2xpbmUgfHwgcHJldiA9PSBjYXJyaWFnZVJldHVybikge1xuICAgIGxldCBkZXB0aCA9IDAsIGNoYXJzID0gMDtcbiAgICBmb3IgKDs7KSB7XG4gICAgICBpZiAoaW5wdXQubmV4dCA9PSBzcGFjZSkgZGVwdGgrKztcbiAgICAgIGVsc2UgaWYgKGlucHV0Lm5leHQgPT0gdGFiKSBkZXB0aCArPSA4IC0gKGRlcHRoICUgOCk7XG4gICAgICBlbHNlIGJyZWFrXG4gICAgICBpbnB1dC5hZHZhbmNlKCk7XG4gICAgICBjaGFycysrO1xuICAgIH1cbiAgICBpZiAoZGVwdGggIT0gY0RlcHRoICYmXG4gICAgICAgIGlucHV0Lm5leHQgIT0gbmV3bGluZSAmJiBpbnB1dC5uZXh0ICE9IGNhcnJpYWdlUmV0dXJuICYmIGlucHV0Lm5leHQgIT0gaGFzaCkge1xuICAgICAgaWYgKGRlcHRoIDwgY0RlcHRoKSBpbnB1dC5hY2NlcHRUb2tlbihkZWRlbnQsIC1jaGFycyk7XG4gICAgICBlbHNlIGlucHV0LmFjY2VwdFRva2VuKGluZGVudCk7XG4gICAgfVxuICB9XG59KTtcblxuZnVuY3Rpb24gSW5kZW50TGV2ZWwocGFyZW50LCBkZXB0aCkge1xuICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgLy8gLTEgbWVhbnMgdGhpcyBpcyBub3QgYW4gYWN0dWFsIGluZGVudCBsZXZlbCBidXQgYSBzZXQgb2YgYnJhY2tldHNcbiAgdGhpcy5kZXB0aCA9IGRlcHRoO1xuICB0aGlzLmhhc2ggPSAocGFyZW50ID8gcGFyZW50Lmhhc2ggKyBwYXJlbnQuaGFzaCA8PCA4IDogMCkgKyBkZXB0aCArIChkZXB0aCA8PCA0KTtcbn1cblxuY29uc3QgdG9wSW5kZW50ID0gbmV3IEluZGVudExldmVsKG51bGwsIDApO1xuXG5mdW5jdGlvbiBjb3VudEluZGVudChzcGFjZSkge1xuICBsZXQgZGVwdGggPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNwYWNlLmxlbmd0aDsgaSsrKVxuICAgIGRlcHRoICs9IHNwYWNlLmNoYXJDb2RlQXQoaSkgPT0gdGFiID8gOCAtIChkZXB0aCAlIDgpIDogMTtcbiAgcmV0dXJuIGRlcHRoXG59XG5cbmNvbnN0IHRyYWNrSW5kZW50ID0gbmV3IENvbnRleHRUcmFja2VyKHtcbiAgc3RhcnQ6IHRvcEluZGVudCxcbiAgcmVkdWNlKGNvbnRleHQsIHRlcm0pIHtcbiAgICByZXR1cm4gY29udGV4dC5kZXB0aCA8IDAgJiYgYnJhY2tldGVkLmhhcyh0ZXJtKSA/IGNvbnRleHQucGFyZW50IDogY29udGV4dFxuICB9LFxuICBzaGlmdChjb250ZXh0LCB0ZXJtLCBzdGFjaywgaW5wdXQpIHtcbiAgICBpZiAodGVybSA9PSBpbmRlbnQpIHJldHVybiBuZXcgSW5kZW50TGV2ZWwoY29udGV4dCwgY291bnRJbmRlbnQoaW5wdXQucmVhZChpbnB1dC5wb3MsIHN0YWNrLnBvcykpKVxuICAgIGlmICh0ZXJtID09IGRlZGVudCkgcmV0dXJuIGNvbnRleHQucGFyZW50XG4gICAgaWYgKHRlcm0gPT0gUGFyZW5MIHx8IHRlcm0gPT0gQnJhY2tldEwgfHwgdGVybSA9PSBCcmFjZUwpIHJldHVybiBuZXcgSW5kZW50TGV2ZWwoY29udGV4dCwgLTEpXG4gICAgcmV0dXJuIGNvbnRleHRcbiAgfSxcbiAgaGFzaChjb250ZXh0KSB7IHJldHVybiBjb250ZXh0Lmhhc2ggfVxufSk7XG5cbmNvbnN0IGxlZ2FjeVByaW50ID0gbmV3IEV4dGVybmFsVG9rZW5pemVyKGlucHV0ID0+IHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCA1OyBpKyspIHtcbiAgICBpZiAoaW5wdXQubmV4dCAhPSBcInByaW50XCIuY2hhckNvZGVBdChpKSkgcmV0dXJuXG4gICAgaW5wdXQuYWR2YW5jZSgpO1xuICB9XG4gIGlmICgvXFx3Ly50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoaW5wdXQubmV4dCkpKSByZXR1cm5cbiAgZm9yIChsZXQgb2ZmID0gMDs7IG9mZisrKSB7XG4gICAgbGV0IG5leHQgPSBpbnB1dC5wZWVrKG9mZik7XG4gICAgaWYgKG5leHQgPT0gc3BhY2UgfHwgbmV4dCA9PSB0YWIpIGNvbnRpbnVlXG4gICAgaWYgKG5leHQgIT0gcGFyZW5PcGVuICYmIG5leHQgIT0gZG90ICYmIG5leHQgIT0gbmV3bGluZSAmJiBuZXh0ICE9IGNhcnJpYWdlUmV0dXJuICYmIG5leHQgIT0gaGFzaClcbiAgICAgIGlucHV0LmFjY2VwdFRva2VuKHByaW50S2V5d29yZCk7XG4gICAgcmV0dXJuXG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBmb3JtYXRTdHJpbmcocXVvdGUsIGxlbiwgY29udGVudCwgYnJhY2UsIGVuZCkge1xuICByZXR1cm4gbmV3IEV4dGVybmFsVG9rZW5pemVyKGlucHV0ID0+IHtcbiAgICBsZXQgc3RhcnQgPSBpbnB1dC5wb3M7XG4gICAgZm9yICg7Oykge1xuICAgICAgaWYgKGlucHV0Lm5leHQgPCAwKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9IGVsc2UgaWYgKGlucHV0Lm5leHQgPT0gYnJhY2VPcGVuKSB7XG4gICAgICAgIGlmIChpbnB1dC5wZWVrKDEpID09IGJyYWNlT3Blbikge1xuICAgICAgICAgIGlucHV0LmFkdmFuY2UoMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGlucHV0LnBvcyA9PSBzdGFydCkge1xuICAgICAgICAgICAgaW5wdXQuYWNjZXB0VG9rZW4oYnJhY2UsIDEpO1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaW5wdXQubmV4dCA9PSBiYWNrc2xhc2gpIHtcbiAgICAgICAgaW5wdXQuYWR2YW5jZSgpO1xuICAgICAgICBpZiAoaW5wdXQubmV4dCA+PSAwKSBpbnB1dC5hZHZhbmNlKCk7XG4gICAgICB9IGVsc2UgaWYgKGlucHV0Lm5leHQgPT0gcXVvdGUgJiYgKGxlbiA9PSAxIHx8IGlucHV0LnBlZWsoMSkgPT0gcXVvdGUgJiYgaW5wdXQucGVlaygyKSA9PSBxdW90ZSkpIHtcbiAgICAgICAgaWYgKGlucHV0LnBvcyA9PSBzdGFydCkge1xuICAgICAgICAgIGlucHV0LmFjY2VwdFRva2VuKGVuZCwgbGVuKTtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBicmVha1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5wdXQuYWR2YW5jZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaW5wdXQucG9zID4gc3RhcnQpIGlucHV0LmFjY2VwdFRva2VuKGNvbnRlbnQpO1xuICB9KVxufVxuXG5jb25zdCBmb3JtYXRTdHJpbmcxID0gZm9ybWF0U3RyaW5nKHNpbmdsZVF1b3RlLCAxLCBmb3JtYXRTdHJpbmcxQ29udGVudCwgZm9ybWF0U3RyaW5nMUJyYWNlLCBmb3JtYXRTdHJpbmcxRW5kKTtcbmNvbnN0IGZvcm1hdFN0cmluZzIgPSBmb3JtYXRTdHJpbmcoZG91YmxlUXVvdGUsIDEsIGZvcm1hdFN0cmluZzJDb250ZW50LCBmb3JtYXRTdHJpbmcyQnJhY2UsIGZvcm1hdFN0cmluZzJFbmQpO1xuY29uc3QgZm9ybWF0U3RyaW5nMWwgPSBmb3JtYXRTdHJpbmcoc2luZ2xlUXVvdGUsIDMsIGZvcm1hdFN0cmluZzFsQ29udGVudCwgZm9ybWF0U3RyaW5nMWxCcmFjZSwgZm9ybWF0U3RyaW5nMWxFbmQpO1xuY29uc3QgZm9ybWF0U3RyaW5nMmwgPSBmb3JtYXRTdHJpbmcoZG91YmxlUXVvdGUsIDMsIGZvcm1hdFN0cmluZzJsQ29udGVudCwgZm9ybWF0U3RyaW5nMmxCcmFjZSwgZm9ybWF0U3RyaW5nMmxFbmQpO1xuXG5jb25zdCBweXRob25IaWdobGlnaHRpbmcgPSBzdHlsZVRhZ3Moe1xuICBcImFzeW5jIFxcXCIqXFxcIiBcXFwiKipcXFwiIEZvcm1hdENvbnZlcnNpb24gRm9ybWF0U3BlY1wiOiB0YWdzLm1vZGlmaWVyLFxuICBcImZvciB3aGlsZSBpZiBlbGlmIGVsc2UgdHJ5IGV4Y2VwdCBmaW5hbGx5IHJldHVybiByYWlzZSBicmVhayBjb250aW51ZSB3aXRoIHBhc3MgYXNzZXJ0IGF3YWl0IHlpZWxkIG1hdGNoIGNhc2VcIjogdGFncy5jb250cm9sS2V5d29yZCxcbiAgXCJpbiBub3QgYW5kIG9yIGlzIGRlbFwiOiB0YWdzLm9wZXJhdG9yS2V5d29yZCxcbiAgXCJmcm9tIGRlZiBjbGFzcyBnbG9iYWwgbm9ubG9jYWwgbGFtYmRhXCI6IHRhZ3MuZGVmaW5pdGlvbktleXdvcmQsXG4gIGltcG9ydDogdGFncy5tb2R1bGVLZXl3b3JkLFxuICBcIndpdGggYXMgcHJpbnRcIjogdGFncy5rZXl3b3JkLFxuICBCb29sZWFuOiB0YWdzLmJvb2wsXG4gIE5vbmU6IHRhZ3MubnVsbCxcbiAgVmFyaWFibGVOYW1lOiB0YWdzLnZhcmlhYmxlTmFtZSxcbiAgXCJDYWxsRXhwcmVzc2lvbi9WYXJpYWJsZU5hbWVcIjogdGFncy5mdW5jdGlvbih0YWdzLnZhcmlhYmxlTmFtZSksXG4gIFwiRnVuY3Rpb25EZWZpbml0aW9uL1ZhcmlhYmxlTmFtZVwiOiB0YWdzLmZ1bmN0aW9uKHRhZ3MuZGVmaW5pdGlvbih0YWdzLnZhcmlhYmxlTmFtZSkpLFxuICBcIkNsYXNzRGVmaW5pdGlvbi9WYXJpYWJsZU5hbWVcIjogdGFncy5kZWZpbml0aW9uKHRhZ3MuY2xhc3NOYW1lKSxcbiAgUHJvcGVydHlOYW1lOiB0YWdzLnByb3BlcnR5TmFtZSxcbiAgXCJDYWxsRXhwcmVzc2lvbi9NZW1iZXJFeHByZXNzaW9uL1Byb3BlcnR5TmFtZVwiOiB0YWdzLmZ1bmN0aW9uKHRhZ3MucHJvcGVydHlOYW1lKSxcbiAgQ29tbWVudDogdGFncy5saW5lQ29tbWVudCxcbiAgTnVtYmVyOiB0YWdzLm51bWJlcixcbiAgU3RyaW5nOiB0YWdzLnN0cmluZyxcbiAgRm9ybWF0U3RyaW5nOiB0YWdzLnNwZWNpYWwodGFncy5zdHJpbmcpLFxuICBVcGRhdGVPcDogdGFncy51cGRhdGVPcGVyYXRvcixcbiAgXCJBcml0aE9wIVwiOiB0YWdzLmFyaXRobWV0aWNPcGVyYXRvcixcbiAgQml0T3A6IHRhZ3MuYml0d2lzZU9wZXJhdG9yLFxuICBDb21wYXJlT3A6IHRhZ3MuY29tcGFyZU9wZXJhdG9yLFxuICBBc3NpZ25PcDogdGFncy5kZWZpbml0aW9uT3BlcmF0b3IsXG4gIEVsbGlwc2lzOiB0YWdzLnB1bmN0dWF0aW9uLFxuICBBdDogdGFncy5tZXRhLFxuICBcIiggKVwiOiB0YWdzLnBhcmVuLFxuICBcIlsgXVwiOiB0YWdzLnNxdWFyZUJyYWNrZXQsXG4gIFwieyB9XCI6IHRhZ3MuYnJhY2UsXG4gIFwiLlwiOiB0YWdzLmRlcmVmT3BlcmF0b3IsXG4gIFwiLCA7XCI6IHRhZ3Muc2VwYXJhdG9yXG59KTtcblxuLy8gVGhpcyBmaWxlIHdhcyBnZW5lcmF0ZWQgYnkgbGV6ZXItZ2VuZXJhdG9yLiBZb3UgcHJvYmFibHkgc2hvdWxkbid0IGVkaXQgaXQuXG5jb25zdCBzcGVjX2lkZW50aWZpZXIgPSB7X19wcm90b19fOm51bGwsYXdhaXQ6NDgsIG9yOjU4LCBhbmQ6NjAsIGluOjY0LCBub3Q6NjYsIGlzOjY4LCBpZjo3NCwgZWxzZTo3NiwgbGFtYmRhOjgwLCB5aWVsZDo5OCwgZnJvbToxMDAsIGFzeW5jOjEwNiwgZm9yOjEwOCwgTm9uZToxNjgsIFRydWU6MTcwLCBGYWxzZToxNzAsIGRlbDoxODQsIHBhc3M6MTg4LCBicmVhazoxOTIsIGNvbnRpbnVlOjE5NiwgcmV0dXJuOjIwMCwgcmFpc2U6MjA4LCBpbXBvcnQ6MjEyLCBhczoyMTQsIGdsb2JhbDoyMTgsIG5vbmxvY2FsOjIyMCwgYXNzZXJ0OjIyNCwgdHlwZToyMjksIGVsaWY6MjQyLCB3aGlsZToyNDYsIHRyeToyNTIsIGV4Y2VwdDoyNTQsIGZpbmFsbHk6MjU2LCB3aXRoOjI2MCwgZGVmOjI2NCwgY2xhc3M6Mjc0LCBtYXRjaDoyODUsIGNhc2U6MjkxfTtcbmNvbnN0IHBhcnNlciA9IExSUGFyc2VyLmRlc2VyaWFsaXplKHtcbiAgdmVyc2lvbjogMTQsXG4gIHN0YXRlczogXCIjJmpPYFEjeU9PUCRiT1NPT08la1Embk8nI0hjT09RUycjQ3EnI0NxT09RUycjQ3InI0NyTydaUSN4TycjQ3BPKHxRJm5PJyNIYk9PUVMnI0hjJyNIY09PUVMnI0RXJyNEV09PUVMnI0hiJyNIYk8palEjeE8nI0RhTyl9USN4TycjRGhPKl9RI3hPJyNEbE9PUVMnI0R3JyNEd08qck8sVU8nI0R3Typ6TzdbTycjRHdPK1NPV08nI0R4TytfT2BPJyNEeE8rak9wTycjRHhPK3VPIWJPJyNEeE8td1Embk8nI0hTT09RUycjSFMnI0hTTydaUSN4TycjSFJPL1pRJm5PJyNIUk9PUVMnI0VlJyNFZU8vclEjeE8nI0VmT09RUycjSFEnI0hRTy98USN4TycjSFBPT1FWJyNIUCcjSFBPMFhRI3hPJyNGXU9PUVMnI0dlJyNHZU8wXlEjeE8nI0ZbT09RVicjSVknI0lZT09RVicjSE8nI0hPT09RVicjRnQnI0Z0UWBRI3lPT08nWlEjeE8nI0NzTzBsUSN4TycjRFBPMHNRI3hPJyNEVE8xUlEjeE8nI0hnTzFjUSZuTycjRVlPJ1pRI3hPJyNFWk9PUVMnI0VdJyNFXU9PUVMnI0VfJyNFX09PUVMnI0VhJyNFYU8xd1EjeE8nI0VjTzJfUSN4TycjRWdPMFhRI3hPJyNFaU8yclEmbk8nI0VpTzBYUSN4TycjRWxPL3JRI3hPJyNFb08wWFEjeE8nI0VxTy9yUSN4TycjRXdPL3JRI3hPJyNFek8yfVEjeE8nI0V8TzNVUSN4TycjRlJPM2FRI3hPJyNFfU8vclEjeE8nI0ZSTzBYUSN4TycjRlRPMFhRI3hPJyNGWU8zZlEjeE8nI0ZfUDNtTyN4TycjR31QT09PKUNCcSlDQnFPT1FTJyNDZycjQ2dPT1FTJyNDaCcjQ2hPT1FTJyNDaScjQ2lPT1FTJyNDaicjQ2pPT1FTJyNDaycjQ2tPT1FTJyNDbCcjQ2xPT1FTJyNDbicjQ25PJ1pRI3hPLDU5UU8nWlEjeE8sNTlRTydaUSN4Tyw1OVFPJ1pRI3hPLDU5UU8nWlEjeE8sNTlRTydaUSN4Tyw1OVFPM3hRI3hPJyNEcU9PUVMsNTpbLDU6W080XVEjeE8nI0hxT09RUyw1Ol8sNTpfTzRqUU1sTyw1Ol9PNG9RJm5PLDU5W08wbFEjeE8sNTlkTzBsUSN4Tyw1OWRPMGxRI3hPLDU5ZE83X1EjeE8sNTlkTzdkUSN4Tyw1OWRPN2tRI3hPLDU5bE83clEjeE8nI0hiTzh4USN4TycjSGFPT1FTJyNIYScjSGFPT1FTJyNEXicjRF5POWFRI3hPLDU5Y08nWlEjeE8sNTljTzlvUSN4Tyw1OWNPT1FTLDU5eyw1OXtPOXRRI3hPLDU6VE8nWlEjeE8sNTpUT09RUyw1OlMsNTpTTzpTUSN4Tyw1OlNPOlhRI3hPLDU6Wk8nWlEjeE8sNTpaTydaUSN4Tyw1OlhPT1FTLDU6Vyw1OldPOmpRI3hPLDU6V086b1EjeE8sNTpZT09PTycjRnwnI0Z8Tzp0TyxVTyw1OmNPT1FTLDU6Yyw1OmNPT09PJyNGfScjRn1POnxPN1tPLDU6Y087VVEjeE8nI0R5T09PVycjR08nI0dPTztmT1dPLDU6ZE9PUVMsNTpkLDU6ZE87VVEjeE8nI0R9T09PYCcjR1InI0dSTztxT2BPLDU6ZE87VVEjeE8nI0VPT09PcCcjR1MnI0dTTzt8T3BPLDU6ZE87VVEjeE8nI0VQT09PIWInI0dUJyNHVE88WE8hYk8sNTpkT09RUycjR1UnI0dVTzxkUSZuTyw1OmxPP1VRJm5PLDU9bU8/b1EhTFVPLDU9bU9AYFEmbk8sNT1tT09RUyw1O1EsNTtRT0B3USN5TycjR19PQlpRI3hPLDU7YU9PUVYsNT1rLDU9a09CZlEmbk8nI0lUT0J9USN4Tyw1O3dPT1FTLUU6Yy1FOmNPT1FWLDU7diw1O3ZPM1tRI3hPJyNGVE9PUVYtRTlyLUU5ck9DVlEmbk8sNTlfT0VeUSZuTyw1OWtPRXdRI3hPJyNIZE9GU1EjeE8nI0hkTzBYUSN4TycjSGRPRl9RI3hPJyNEVk9GZ1EjeE8sNTlvT0ZsUSN4TycjSGhPJ1pRI3hPJyNIaE8vclEjeE8sNT5ST09RUyw1PlIsNT5STy9yUSN4TycjRVVPT1FTJyNFVicjRVZPR1pRI3hPJyNHV09Ha1EjeE8sNTlPT0drUSN4Tyw1OU9PKXBRI3hPLDU6ck9HeVEmbk8nI0hqT09RUyw1OnUsNTp1T09RUyw1On0sNTp9T0heUSN4Tyw1O1JPSG9RI3hPLDU7VE9PUVMnI0daJyNHWk9IfVEmbk8sNTtUT0ldUSN4Tyw1O1RPSWJRI3hPJyNJV09PUVMsNTtXLDU7V09JcFEjeE8nI0lTT09RUyw1O1osNTtaT0pSUSN4Tyw1O11PM2FRI3hPLDU7Y08zYVEjeE8sNTtmT0paUSZuTycjSVpPJ1pRI3hPJyNJWk9KZVEjeE8sNTtoTzJ9USN4Tyw1O2hPL3JRI3hPLDU7bU8wWFEjeE8sNTtvT0pqUSN5TycjRXhPS3ZRI3tPLDU7aU8hIFtRI3hPJyNJW08zYVEjeE8sNTttTyEgZ1EjeE8sNTtvTyEgb1EjeE8sNTt0TyEgelEmbk8sNTt5TydaUSN4Tyw1O3lQT09PLDU9aSw1PWlQISFST1NPLDU9aVAhIVdPI3hPLDU9aU8hJHtRJm5PMUcubE8hJVNRJm5PMUcubE8hJ3NRJm5PMUcubE8hJ31RJm5PMUcubE8hKmhRJm5PMUcubE8hKntRJm5PMUcubE8hK2BRI3hPJyNIcE8hK25RJm5PJyNIU08vclEjeE8nI0hwTyEreFEjeE8nI0hvT09RUyw1Ol0sNTpdTyEsUVEjeE8sNTpdTyEsVlEjeE8nI0hyTyEsYlEjeE8nI0hyTyEsdVEjeE8sNT5dT09RUycjRHUnI0R1T09RUzFHL3kxRy95T09RUzFHL08xRy9PTyEtdVEmbk8xRy9PTyEtfFEmbk8xRy9PTzBsUSN4TzFHL09PIS5pUSN4TzFHL1dPT1FTJyNEXScjRF1PL3JRI3hPLDU5dk9PUVMxRy59MUcufU8hLnBRI3hPMUcvZ08hL1FRI3hPMUcvZ08hL1lRI3hPMUcvaE8nWlEjeE8nI0hpTyEvX1EjeE8nI0hpTyEvZFEmbk8xRy59TyEvdFEjeE8sNTlrTyEwelEjeE8sNT5YTyExW1EjeE8sNT5YTyExZFEjeE8xRy9vTyExaVEmbk8xRy9vT09RUzFHL24xRy9uTyExeVEjeE8sNT5TTyEycFEjeE8sNT5TTy9yUSN4TzFHL3NPITNfUSN4TzFHL3VPITNkUSZuTzFHL3VPITN0USZuTzFHL3NPT1FTMUcvcjFHL3JPT1FTMUcvdDFHL3RPT09PLUU5ei1FOXpPT1FTMUcvfTFHL31PT09PLUU5ey1FOXtPITRVUSN4TycjSHxPL3JRI3hPJyNIfE8hNGRRI3hPLDU6ZU9PT1ctRTl8LUU5fE9PUVMxRzBPMUcwT08hNG9RI3hPLDU6aU9PT2AtRTpQLUU6UE8hNHpRI3hPLDU6ak9PT3AtRTpRLUU6UU8hNVZRI3hPLDU6a09PTyFiLUU6Ui1FOlJPT1FTLUU6Uy1FOlNPITViUSFMVU8xRzNYTyE2UlEmbk8xRzNYTydaUSN4Tyw1PHFPT1FTLDU8cSw1PHFPT1FTLUU6VC1FOlRPT1FTLDU8eSw1PHlPT1FTLUU6XS1FOl1PT1FWMUcwezFHMHtPMFhRI3hPJyNHWU8hNmpRJm5PLDU+b09PUVMxRzFjMUcxY08hN1JRI3hPMUcxY09PUVMnI0RYJyNEWE8vclEjeE8sNT5PT09RUyw1Pk8sNT5PTyE3V1EjeE8nI0Z1TyE3Y1EjeE8sNTlxTyE3a1EjeE8xRy9aTyE3dVEmbk8sNT5TT09RUzFHM20xRzNtT09RUyw1OnAsNTpwTyE4ZlEjeE8nI0hST09RUyw1PHIsNTxyT09RUy1FOlUtRTpVTyE4d1EjeE8xRy5qT09RUzFHMF4xRzBeTyE5VlEjeE8sNT5VTyE5Z1EjeE8sNT5VTy9yUSN4TzFHMG1PL3JRI3hPMUcwbU8wWFEjeE8xRzBvT09RUy1FOlgtRTpYTyE5eFEjeE8xRzBvTyE6VFEjeE8xRzBvTyE6WVEjeE8sNT5yTyE6aFEjeE8sNT5yTyE6dlEjeE8sNT5uTyE7XlEjeE8sNT5uTyE7b1EjeE8nI0VzTy9yUSN4TzFHMHdPITt6USN4TzFHMHdPITxQUSN7TzFHMH1PIT9iUSN7TzFHMVFPIUJwUSN4Tyw1PnVPIUJ6USN4Tyw1PnVPIUNTUSZuTyw1PnVPL3JRI3hPMUcxU08hQ15RI3hPMUcxU08zYVEjeE8xRzFYTyEgZ1EjeE8xRzFaT09RViw1O2QsNTtkTyFDY1Ejek8sNTtkTyFDaFEje08xRzFUTyFGfFEjeE8nI0diTzNhUSN4TzFHMVRPM2FRI3hPMUcxVE8hR15RI3hPLDU+dk8hR2tRI3hPLDU+dk8wWFEjeE8sNT52T09RVjFHMVgxRzFYTyFHc1EjeE8nI0ZWTyFIVVFNbE8xRzFaTyFIXlEjeE8xRzFaT09RVjFHMWAxRzFgTzNhUSN4TzFHMWBPIUhjUSN4TzFHMWBPIUhrUSN4TycjRmFPT1FWMUcxZTFHMWVPISB6USZuTzFHMWVQT09PMUczVDFHM1RQIUhwT1NPMUczVE9PUVMsNT5bLDU+W09PUVMnI0RyJyNEck8vclEjeE8sNT5bTyFIdVEjeE8sNT5aTyFJWVEjeE8sNT5aT09RUzFHL3cxRy93TyFJYlEjeE8sNT5eTyFJclEjeE8sNT5eTyFJelEjeE8sNT5eTyFKX1EjeE8sNT5eTyFKb1EjeE8sNT5eT09RUzFHM3cxRzN3T09RUzcrJGo3KyRqTyE3a1EjeE83KyRyTyFMYlEjeE8xRy9PTyFMaVEjeE8xRy9PT09RUzFHL2IxRy9iT09RUyw1PGMsNTxjTydaUSN4Tyw1PGNPT1FTNyslUjcrJVJPIUxwUSN4TzcrJVJPT1FTLUU5dS1FOXVPT1FTNyslUzcrJVNPIU1RUSN4Tyw1PlRPJ1pRI3hPLDU+VE9PUVM3KyRpNyskaU8hTVZRI3hPNyslUk8hTV9RI3hPNyslU08hTWRRI3hPMUczc09PUVM3KyVaNyslWk8hTXRRI3hPMUczc08hTXxRI3hPNyslWk9PUVMsNTxiLDU8Yk8nWlEjeE8sNTxiTyFOUlEjeE8xRzNuT09RUy1FOXQtRTl0TyFOeFEjeE83KyVfT09RUzcrJWE3KyVhTyMgV1EjeE8xRzNuTyMgdVEjeE83KyVhTyMgelEjeE8xRzN0TyMhW1EjeE8xRzN0TyMhZFEjeE83KyVfTyMhaVEjeE8sNT5oTyMjUFEjeE8sNT5oTyMjUFEjeE8sNT5oTyMjX08kSVNPJyNEe08jI2pPI3RPJyNIfU9PT1cxRzBQMUcwUE8jI29RI3hPMUcwUE9PT2AxRzBUMUcwVE8jI3dRI3hPMUcwVE9PT3AxRzBVMUcwVU8jJFBRI3hPMUcwVU9PTyFiMUcwVjFHMFZPIyRYUSN4TzFHMFZPIyRhUSFMVU83KyhzTyMlUVEmbk8xRzJdUCMla1EjeE8nI0dWT09RUyw1PHQsNTx0T09RUy1FOlctRTpXT09RUzcrJn03KyZ9T09RUzFHM2oxRzNqT09RUyw1PGEsNTxhT09RUy1FOXMtRTlzT09RUzcrJHU3KyR1TyMleFEjeE8sNT1tTyMmY1EjeE8sNT1tTyMmdFEmbk8sNTxkTyMnWFEjeE8xRzNwT09RUy1FOXYtRTl2T09RUzcrJlg3KyZYTyMnaVEjeE83KyZYT09RUzcrJlo3KyZaTyMnd1EjeE8nI0lWTzBYUSN4TycjSVVPIyhdUSN4TzcrJlpPT1FTLDU8dyw1PHdPIyhoUSN4TzFHNF5PT1FTLUU6Wi1FOlpPT1FTLDU8cyw1PHNPIyh2USN4TzFHNFlPT1FTLUU6Vi1FOlZPMFhRI3hPJyNFdE8jKV5RI3hPJyNFdE8jKWlRI3hPJyNJWE8jKXFRI3hPLDU7X09PUVM3KyZjNysmY08vclEjeE83KyZjTyMpdlEje083KyZpTyFHUFEjeE8nI0dgTzNhUSN4TzcrJmlPM2FRI3hPNysmbE8jLVhRJm5PLDU8e08nWlEjeE8sNTx7TyMtY1EjeE8xRzRhT09RUy1FOl8tRTpfTyMtbVEjeE8xRzRhTzNhUSN4TzcrJm5PL3JRI3hPNysmbk9PUVY3KyZzNysmc08hSFVRTWxPNysmdU8hSF5RI3hPNysmdU9gUSN5TzFHMU9PT1FWLUU6YC1FOmBPM2FRI3hPNysmb08zYVEjeE83KyZvT09RViw1PHwsNTx8TyMtdVEjeE8sNTx8TyFHUFEjeE8sNTx8T09RVjcrJm83KyZvTyMuUVEje083KyZvTyMxYFEjeE8sNTx9TyMxa1EjeE8xRzRiT09RUy1FOmEtRTphTyMxeFEjeE8xRzRiTyMyUVEjeE8nI0leTyMyYFEjeE8nI0leTzBYUSN4TycjSV5PT1FTJyNJXicjSV5PIzJrUSN4TycjSV1PT1FTLDU7cSw1O3FPIzJzUSN4Tyw1O3FPL3JRI3hPJyNGWE9PUVY3KyZ1NysmdU8zYVEjeE83KyZ1T09RVjcrJno3KyZ6TzNhUSN4TzcrJnpPIzJ4USN6Tyw1O3tPT1FWNysnUDcrJ1BQT09PNysobzcrKG9PIzJ9USN4TzFHM3ZPT1FTLDU8Ziw1PGZPIzNdUSN4TzFHM3VPT1FTLUU5eC1FOXhPIzNwUSN4Tyw1PGdPIzN7USN4Tyw1PGdPIzRgUSN4TzFHM3hPT1FTLUU5eS1FOXlPIzRwUSN4TzFHM3hPIzR4USN4TzFHM3hPIzVZUSN4TzFHM3hPIzRwUSN4TzFHM3hPT1FTPDxIXjw8SF5PIzVlUSZuTzFHMX1PT1FTPDxIbTw8SG1QIzVyUSN4TycjRndPN2tRI3hPMUczb08jNlBRI3hPMUczb08jNlVRI3hPPDxIbU9PUVM8PEhuPDxIbk8jNmZRI3hPNyspX09PUVM8PEh1PDxIdU8jNnZRJm5PMUcxfFAjN2dRI3hPJyNGdk8jN3RRI3hPNyspYE8jOFVRI3hPNyspYE8jOF5RI3hPPDxIeU8jOGNRI3hPNyspWU9PUVM8PEh7PDxIe08jOVlRI3hPLDU8ZU8nWlEjeE8sNTxlT09RUy1FOXctRTl3T09RUzw8SHk8PEh5T09RUyw1PGssNTxrTy9yUSN4Tyw1PGtPIzlfUSN4TzFHNFNPT1FTLUU5fS1FOX1PIzl1USN4TzFHNFNPO1VRI3hPJyNEfE9PT08nI0dRJyNHUU8jOlRPJElTTyw1OmdPT08jbCw1PmksNT5pT09PVzcrJWs3KyVrT09PYDcrJW83KyVvT09PcDcrJXA3KyVwT09PIWI3KyVxNyslcU8jOmBRI3hPMUczWE8jOnlRI3hPMUczWFAnWlEjeE8nI0Z4Ty9yUSN4Tzw8SXNPIztbUSN4Tyw1PnFPIzttUSN4Tyw1PnFPMFhRI3hPLDU+cU8jPE9RI3hPLDU+cE9PUVM8PEl1PDxJdVAwWFEjeE8nI0ddUC9yUSN4TycjR1hPT1FTLDU7YCw1O2BPIzxUUSN4Tyw1PnNPIzxjUSN4Tyw1PnNPT1FTMUcweTFHMHlPT1FTPDxJfTw8SX1PT1FWLUU6Xi1FOl5PM2FRI3hPPDxKVE9PUVYsNTx6LDU8ek8zYVEjeE8sNTx6T09RVjw8SlQ8PEpUT09RVjw8Slc8PEpXTyM8a1Embk8xRzJnUCM8dVEjeE8nI0dhTyM8fFEjeE83Kyl7TyM9V1Eje088PEpZTzNhUSN4Tzw8SllPT1FWPDxKYTw8SmFPM2FRI3hPPDxKYU8hSFVRTWxPPDxKYU8jQGZRI3tPNysmak9PUVY8PEpaPDxKWk8jQHBRI3tPPDxKWk9PUVYxRzJoMUcyaE8wWFEjeE8xRzJoTyNET1EjeE8xRzJoTzNhUSN4Tzw8SlpPMFhRI3hPMUcyaVAvclEjeE8nI0djTyNEWlEjeE83Kyl8TyNEaFEjeE83Kyl8T09RUycjRlcnI0ZXTy9yUSN4Tyw1PnhPI0RwUSN4Tyw1PnhPT1FTLDU+eCw1PnhPI0R7USN4Tyw1PndPI0VeUSN4Tyw1PndPT1FTMUcxXTFHMV1PT1FTLDU7cyw1O3NPT1FWPDxKZjw8SmZPI0VmUSN4TzFHMWdPT1FTNyspYjcrKWJQI0VrUSN4TycjRnpPI0V7USN4TzFHMlJPI0ZgUSN4TzFHMlJPI0ZwUSN4TzFHMlJQI0Z7USN4TycjRntPI0dZUSN4TzcrKWRPI0dqUSN4TzcrKWRPI0dqUSN4TzcrKWRPI0dyUSN4TzcrKWRPI0hTUSN4TzcrKVpPN2tRI3hPNyspWk9PUVNBTj5YQU4+WE8jSG1RI3hPPDxMek9PUVNBTj5lQU4+ZU8vclEjeE8xRzJQTyNIfVEmbk8xRzJQUCNJWFEjeE8nI0Z5T09RUzFHMlYxRzJWUCNJZlEjeE8nI0dQTyNJc1EjeE83KyluTyNKWlEjeE8sNTpoT09PTy1FOk8tRTpPTyNKZlEjeE83KyhzT09RU0FOP19BTj9fTyNLUFEjeE8sNTx2TyNLZVEjeE8xRzRdT09RUy1FOlktRTpZTyNLdlEjeE8xRzRdT09RUzFHNFsxRzRbT09RUyw1PHgsNTx4TyNMWFEjeE8xRzRfT09RUy1FOlstRTpbT09RVkFOP29BTj9vT09RVjFHMmYxRzJmTzNhUSN4T0FOP3RPI0xnUSN7T0FOP3RPT1FWQU4/e0FOP3tPM2FRI3hPQU4/e09PUVY8PEpVPDxKVU8zYVEjeE9BTj91TzNhUSN4TzcrKFNPT1FWNysoUzcrKFNPMFhRI3hPNysoU09PUVZBTj91QU4/dU9PUVM3KyhUNysoVE8kIHVRI3hPPDxNaE9PUVMxRzRkMUc0ZE8vclEjeE8xRzRkT09RUyw1PU8sNT1PTyQhU1EjeE8xRzRjT09RUy1FOmItRTpiT09RVScjR2YnI0dmTyQhZVEjek83KydSTyQhcFEjeE8nI0ZiTyQjaFEjeE83KydtTyQjeFEjeE83KydtT09RUzcrJ203KydtTyQkVFEjeE88PE1PTyQkZVEjeE88PE1PTyQkZVEjeE88PE1PTyQkbVEjeE8nI0hrT09RUzw8THU8PEx1TyQkd1EjeE88PEx1T09RUzcrJ2s3KydrT09PTzFHMFMxRzBTTyQlYlEjeE8xRzBTTzBYUSN4TzFHMmJQMFhRI3hPJyNHW08kJWpRI3hPNyspd08kJXtRI3hPNyspd1AhO29RI3hPJyNHXk9PUVZHMjVgRzI1YE8zYVEjeE9HMjVgT09RVkcyNWdHMjVnT09RVkcyNWFHMjVhT09RVjw8S248PEtuTzNhUSN4Tzw8S25PT1FTNysqTzcrKk9QJCZeUSN4TycjR2RPT1FVLUU6ZC1FOmRPT1FWPDxKbTw8Sm1PJCdRUSZuTycjRmRPT1FTJyNGZicjRmZPJCdiUSN4TycjRmVPJChTUSN4TycjRmVPT1FTJyNGZScjRmVPJChYUSN4TycjSWBPJCFwUSN4TycjRmxPJCFwUSN4TycjRmxPJChwUSN4TycjRm1PJCFwUSN4TycjRm5PJCh3USN4TycjSWFPT1FTJyNJYScjSWFPJClmUSN4Tyw1O3xPT1FTPDxLWDw8S1hPJCluUSN4Tzw8S1hPJCpPUSN4T0FOQmpPJCpgUSN4T0FOQmpPJCpoUSN4TycjSGxPT1FTJyNIbCcjSGxPMHNRI3hPJyNEZU8kK1JRI3hPLDU+Vk9PUVNBTkJhQU5CYU9PT083KyVuNyslbk9PUVM3Kyd8NysnfE8kK2pRI3hPPDxNY09PUVZMRCp6TEQqek9PUVZBTkFZQU5BWU80alFNbE8nI0doTyQre1Embk8sNTxWTyQhcFEjeE8nI0ZwT09RUyw1PFosNTxaT09RUycjRmcnI0ZnTyQsbVEjeE8sNTxQTyQsclEjeE8sNTxQT09RUycjRmonI0ZqTyQhcFEjeE8nI0dnTyQtZFEjeE8sNTxUTyQuT1EjeE8sNT56TyQuYFEjeE8sNT56TzBYUSN4Tyw1PFNPJC5xUSN4Tyw1PFdPJC52USN4Tyw1PFdPJCFwUSN4TycjSWJPJC57USN4TycjSWJPJC9RUSN4Tyw1PFhPT1FTLDU8WSw1PFlPJ1pRI3hPJyNGc09PUVUxRzFoMUcxaE8zYVEjeE8xRzFoT09RU0FOQHNBTkBzTyQvVlEjeE9HMjhVTyQvZ1EjeE8sNTpQT09RUzFHM3ExRzNxT09RUyw1PVMsNT1TT09RUy1FOmYtRTpmTyQvbFEmbk8nI0ZkTyQvc1EjeE8nI0ljTyQwUlEjeE8nI0ljTyQwWlEjeE8sNTxbT09RUzFHMWsxRzFrTyQwYFEjeE8xRzFrTyQwZVEjeE8sNT1ST09RUy1FOmUtRTplTyQxUFEjeE8sNT1WTyQxaFEjeE8xRzRmT09RUy1FOmktRTppT09RUzFHMW4xRzFuT09RUzFHMXIxRzFyTyQxeFEjeE8sNT58TyQhcFEjeE8sNT58T09RUzFHMXMxRzFzTyQyV1Embk8sNTxfT09RVTcrJ1M3KydTTyQkbVEjeE8xRy9rTyQhcFEjeE8sNTxdTyQyX1EjeE8sNT59TyQyZlEjeE8sNT59T09RUzFHMXYxRzF2T09RUzcrJ1Y3KydWUCQhcFEjeE8nI0drTyQyblEjeE8xRzRoTyQyeFEjeE8xRzRoTyQzUVEjeE8xRzRoT09RUzcrJVY3KyVWTyQzYFEjeE8xRzF3TyQzblEmbk8nI0ZkTyQzdVEjeE8sNT1VT09RUyw1PVUsNT1VTyQ0VFEjeE8xRzRpT09RUy1FOmgtRTpoTyQhcFEjeE8sNT1UTyQ0W1EjeE8sNT1UTyQ0YVEjeE83KypTT09RUy1FOmctRTpnTyQ0a1EjeE83KypTTyQhcFEjeE8sNTxeUCQhcFEjeE8nI0dqTyQ0c1EjeE8xRzJvTyQhcFEjeE8xRzJvUCQ1UlEjeE8nI0dpTyQ1WVEjeE88PE1uTyQ1ZFEjeE8xRzF4TyQ1clEjeE83KyhaTzdrUSN4TycjRFBPN2tRI3hPLDU5ZE83a1EjeE8sNTlkTzdrUSN4Tyw1OWRPJDZRUSZuTyw1PW1PN2tRI3hPMUcvT08vclEjeE8xRy9aTy9yUSN4TzcrJHJQJDZlUSN4TycjR1ZPJ1pRI3hPJyNIUk8kNnJRI3hPLDU5ZE8kNndRI3hPLDU5ZE8kN09RI3hPLDU5b08kN1RRI3hPMUcvV08wc1EjeE8nI0RUTzdrUSN4Tyw1OWxcIixcbiAgc3RhdGVEYXRhOiBcIiQ3Zn5PJXBPUyVlT1NVT1MlZFBRfk9QaU9YZk9odE9qWU9xdU91IVVPeHZPIVJ3TyFTIVFPIVYhWE8hVyFXTyFaWk8hX1tPIWplTyF1ZU8hdmVPIXdlTyNPeU8jUXpPI1N7TyNVfE8jV31PI1shT08jXiFQTyNhIVJPI2IhUk8jZCFTTyNmIVRPI28hVk8jciFZTyN2IVpPI3ghW08jfSFdTyRRbU8kUyFeTyV8Uk8lfVJPJlJTTyZTV08maF1PJmleTyZsX08mb2BPJnNhTyZ0Yk8mdWNPfk8lZCFfT35PWCFmT2EhZk9jIWdPaiFuTyFaIXBPIWghck8ldyFhTyV4IWJPJXkhY08leiFkTyV7IWRPJXwhZU8lfSFlTyZPIWZPJlAhZk8mUSFmT35PbSZWWG4mVlhvJlZYcCZWWHEmVlhyJlZYdSZWWHwmVlh9JlZYIXsmVlgjaiZWWCVjJlZYJWYmVlgmWCZWWGkmVlghViZWWCFXJlZYJlkmVlghWSZWWCFeJlZYIVMmVlgjXyZWWHYmVlghbiZWWH5QJGdPaHRPallPIVpaTyFfW08hamVPIXVlTyF2ZU8hd2VPJXxSTyV9Uk8mUlNPJlNXTyZoXU8maV5PJmxfTyZvYE8mc2FPJnRiTyZ1Y09+T3wmVVh9JlVYI2omVVglYyZVWCVmJlVYJlgmVVh+T20hdU9uIXZPbyF0T3AhdE9xIXdPciF4T3UheU8heyZVWH5QKGhPWCNQT2kjUk9xMHpPeDFZTyFSd09+UCdaT1gjVE9xMHpPeDFZTyFZI1VPflAnWk9YI1hPYyNZT3Ewek94MVlPIV4jWk9+UCdaTyZqI15PJmsjYE9+TyZtI2FPJm4jYE9+T1EjY08lZyNkTyVoI2ZPfk9SI2dPJWkjaE8laiNmT35PUyNqTyVrI2tPJWwjZk9+T1QjbU8lbSNuTyVuI2ZPfk9YJXZYYSV2WGMldlhqJXZYbSV2WG4ldlhvJXZYcCV2WHEldlhyJXZYdSV2WHwldlghWiV2WCFoJXZYJXcldlgleCV2WCV5JXZYJXoldlgleyV2WCV8JXZYJX0ldlgmTyV2WCZQJXZYJlEldlhpJXZYIVYldlghVyV2WH5PJmhdTyZpXk8mbF9PJm9gTyZzYU8mdGJPJnVjT30ldlgheyV2WCNqJXZYJWMldlglZiV2WCZYJXZYJlkldlghWSV2WCFeJXZYIVMldlgjXyV2WHYldlghbiV2WH5QLFFPfCNzT30ldVgheyV1WCNqJXVYJWMldVglZiV1WCZYJXVYfk9xMHpPeDFZT35QJ1pPI2ojdk8lYyN4TyVmI3hPfk8mU1dPfk8hViN9TyN4IVtPI30hXU8kUW1Pfk9xdU9+UCdaT1gkU09jJFRPJlNXT315UH5PWCRYT3Ewek94MVlPIVMkWU9+UCdaT30kW08heyRhTyZYJF1PI2ohfFglYyF8WCVmIXxYfk9YJFhPcTB6T3gxWU8jaiNWWCVjI1ZYJWYjVlh+UCdaT3Ewek94MVlPI2ojWlglYyNaWCVmI1pYflAnWk8haCRnTyF1JGdPJlNXT35PWCRyT35QJ1pPIVckdE8jdiR1TyN4JHZPfk99JHdPfk9YJU9PflAnWk9VJVFPJWMlUE8lcCVST35PWCVbT2MlW09pJV5PcTB6T3gxWU9+UCdaT3Ewek94MVlPfSVhT35QJ1pPJmclY09+T2MhZ09qIW5PIVohcE8haCFyT1hkYWFkYW1kYW5kYW9kYXBkYXFkYXJkYXVkYXxkYX1kYSF7ZGEjamRhJWNkYSVmZGEld2RhJXhkYSV5ZGElemRhJXtkYSV8ZGElfWRhJk9kYSZQZGEmUWRhJlhkYWlkYSFWZGEhV2RhJllkYSFZZGEhXmRhIVNkYSNfZGF2ZGEhbmRhfk9wJWhPfk9xJWhPflAnWk9xMHpPflAnWk9tMHxPbjB9T28we09wMHtPcTFVT3IxVk91MVpPaSZVWCFWJlVYIVcmVVgmWSZVWCFZJlVYIV4mVVghUyZVWCNfJlVYIW4mVVh+UChoTyZZJWpPaSZUWHwmVFghViZUWCFXJlRYIVkmVFh9JlRYfk9pJWxPfCVtTyFWJXFPIVclcE9+T2klbE9+T3wldE8hViVxTyFXJXBPIVkmYVh+TyFZJXhPfk98JXlPfSV7TyFWJXFPIVclcE8hXiZbWH5PIV4mUE9+TyFeJlFPfk8maiNeTyZrJlNPfk8mbSNhTyZuJlNPfk9YJlZPcTB6T3gxWU8hUndPflAnWk9RI2NPJWcjZE8laCZZT35PUiNnTyVpI2hPJWomWU9+T1Mjak8layNrTyVsJllPfk9UI21PJW0jbk8lbiZZT35PWCF0YWEhdGFjIXRhaiF0YW0hdGFuIXRhbyF0YXAhdGFxIXRhciF0YXUhdGF8IXRhfSF0YSFaIXRhIWghdGEheyF0YSNqIXRhJWMhdGElZiF0YSV3IXRhJXghdGEleSF0YSV6IXRhJXshdGElfCF0YSV9IXRhJk8hdGEmUCF0YSZRIXRhJlghdGFpIXRhIVYhdGEhVyF0YSZZIXRhIVkhdGEhXiF0YSFTIXRhI18hdGF2IXRhIW4hdGF+UCN5T3wmYk99JXVhIXsldWEjaiV1YSVjJXVhJWYldWEmWCV1YX5QJGdPWCZkT3F1T3h2T30ldWEheyV1YSNqJXVhJWMldWElZiV1YSZYJXVhflAnWk98JmJPfSV1YSF7JXVhI2oldWElYyV1YSVmJXVhJlgldWF+T1BpT1hmT3F1T3h2TyFSd08hUyFRTyNPeU8jUXpPI1N7TyNVfE8jV31PI1shT08jXiFQTyNhIVJPI2IhUk8jZCFTTyNmIVRPI2olUlglYyVSWCVmJVJYflAnWk8jaiN2TyVjJmlPJWYmaU9+TyFoJmpPaiZ3WCVjJndYI18md1gjaiZ3WCVmJndYI14md1h+T2ohbk8lYyZsT35PbWdhbmdhb2dhcGdhcWdhcmdhdWdhfGdhfWdhIXtnYSNqZ2ElY2dhJWZnYSZYZ2FpZ2EhVmdhIVdnYSZZZ2EhWWdhIV5nYSFTZ2EjX2dhdmdhIW5nYX5QJGdPdXNhfHNhfXNhI2pzYSVjc2ElZnNhJlhzYX5PbSF1T24hdk9vIXRPcCF0T3Ehd09yIXhPIXtzYX5QRHVPJlgmbk98JldYfSZXWH5PJlNXT3wmV1h9JldYfk98JnFPfXlYfk99JnNPfk98JXlPI2omW1glYyZbWCVmJltYaSZbWH0mW1ghXiZbWCFuJltYJlgmW1h+T1gxVE9xMHpPeDFZTyFSd09+UCdaTyZYJF1PI2pXYSVjV2ElZldhfk98JnxPI2omXlglYyZeWCVmJl5YcCZeWH5QJGdPfCdQTyFTJ09PI2ojWmElYyNaYSVmI1phfk8jXydRTyNqI11hJWMjXWElZiNdYX5PIWgkZ08hdSRnTyNeJ1NPJlNXT35PI14nU09+T3wnVU8jaiZ6WCVjJnpYJWYmelh+T3wnV08jaiZ2WCVjJnZYJWYmdlh9JnZYfk8hWidZTyZYJ1pPfk98J19PcCZ9WH5QJGdPcCdiT35PUGlPWGZPcXVPeHZPIVJ3TyFTIVFPI095TyNRek8jU3tPI1V8TyNXfU8jWyFPTyNeIVBPI2EhUk8jYiFSTyNkIVNPI2YhVE8lYydnT35QJ1pPdidrTyNzJ2lPI3Qnak9QI3FhWCNxYWgjcWFqI3FhcSNxYXUjcWF4I3FhIVIjcWEhUyNxYSFWI3FhIVcjcWEhWiNxYSFfI3FhIWojcWEhdSNxYSF2I3FhIXcjcWEjTyNxYSNRI3FhI1MjcWEjVSNxYSNXI3FhI1sjcWEjXiNxYSNhI3FhI2IjcWEjZCNxYSNmI3FhI28jcWEjciNxYSN2I3FhI3gjcWEjfSNxYSRRI3FhJFMjcWElYCNxYSV8I3FhJX0jcWEmUiNxYSZTI3FhJmgjcWEmaSNxYSZsI3FhJm8jcWEmcyNxYSZ0I3FhJnUjcWElYiNxYSVmI3Fhfk98J2xPI18nbk99J09Yfk9qJ3BPIVonWU9+T2ohbk99JHdPIVonWU9+T30ndk9+UCRnTyVjJ3lPfk9VJ3pPJWMneU9+T1ghZk9hIWZPYyFnT2ohbk8hWiFwTyFoIXJPJXkhY08leiFkTyV7IWRPJXwhZU8lfSFlTyZPIWZPJlAhZk8mUSFmT21ZaW5ZaW9ZaXBZaXFZaXJZaXVZaXxZaX1ZaSF7WWkjallpJWNZaSVmWWkld1lpJlhZaWlZaSFWWWkhV1lpJllZaSFZWWkhXllpIVNZaSNfWWl2WWkhbllpfk8leCFiT35QISFgTyV4WWl+UCEhYE9YIWZPYSFmT2MhZ09qIW5PIVohcE8haCFyTyV8IWVPJX0hZU8mTyFmTyZQIWZPJlEhZk9tWWluWWlvWWlwWWlxWWlyWWl1WWl8WWl9WWkhe1lpI2pZaSVjWWklZllpJXdZaSV4WWkleVlpJlhZaWlZaSFWWWkhV1lpJllZaSFZWWkhXllpIVNZaSNfWWl2WWkhbllpfk8leiFkTyV7IWRPflAhJVpPJXpZaSV7WWl+UCElWk9jIWdPaiFuTyFaIXBPIWghck9tWWluWWlvWWlwWWlxWWlyWWl1WWl8WWl9WWkhe1lpI2pZaSVjWWklZllpJXdZaSV4WWkleVlpJXpZaSV7WWklfFlpJX1ZaSZYWWlpWWkhVllpIVdZaSZZWWkhWVlpIV5ZaSFTWWkjX1lpdllpIW5ZaX5PWCFmT2EhZk8mTyFmTyZQIWZPJlEhZk9+UCEoWE9YWWlhWWkmT1lpJlBZaSZRWWl+UCEoWE8hViVxTyFXJXBPaSZkWHwmZFh+TyZYJ3xPJlknfE9+UCxRT3woT09pJmNYfk9pKFFPfk98KFJPfShUTyFZJmZYfk9xMHpPeDFZT3woUk99KFVPIVkmZlh+UCdaTyFZKFdPfk9vIXRPcCF0T3Ehd09yIXhPbWxpdWxpfGxpfWxpIXtsaSNqbGklY2xpJWZsaSZYbGl+T24hdk9+UCEsek9ubGl+UCEsek9tMHxPbjB9T28we09wMHtPcTFVT3IxVk9+T3YoWU9+UCEuVE9YKF9PaShgT3Ewek94MVlPflAnWk9pKGBPfChhT35PaShjT35PIVcoZU9+T2koZk98KGFPIVYlcU8hVyVwT35QJGdPbTB8T24wfU9vMHtPcDB7T3ExVU9yMVZPaXNhIVZzYSFXc2EmWXNhIVlzYSFec2EhU3NhI19zYXZzYSFuc2F+UER1T1goX09xMHpPeDFZTyFZJmFhflAnWk98KGlPIVkmYWF+TyFZKGpPfk98KGlPIVYlcU8hVyVwTyFZJmFhflAkZ09YKG5PcTB6T3gxWU8hXiZbYSNqJlthJWMmW2ElZiZbYWkmW2F9JlthIW4mW2EmWCZbYX5QJ1pPfChvTyFeJlthI2omW2ElYyZbYSVmJlthaSZbYX0mW2EhbiZbYSZYJlthfk8hXihyT35PfChvTyFWJXFPIVclcE8hXiZbYX5QJGdPfCh1TyFWJXFPIVclcE8hXiZiYX5QJGdPfCh4T30mcFghXiZwWCFuJnBYfk99KHtPIV4ofU8hbilPT35PfSh7TyFeKVBPIW4pUU9+T30oe08hXilSTyFuKVNPfk99KHtPIV4pVE8hbilVT35PWCZkT3F1T3h2T30ldWkheyV1aSNqJXVpJWMldWklZiV1aSZYJXVpflAnWk98KVZPfSV1aSF7JXVpI2oldWklYyV1aSVmJXVpJlgldWl+TyFoJmpPaiZ3YSVjJndhI18md2EjaiZ3YSVmJndhI14md2F+TyVjKVtPfk9YJFNPYyRUTyZTV09+T3wmcU99eWF+T3F1T3h2T35QJ1pPfChvTyNqJlthJWMmW2ElZiZbYWkmW2F9JlthIV4mW2EhbiZbYSZYJlthflAkZ098KWFPI2oldVglYyV1WCVmJXVYJlgldVh+TyZYJF1PI2pXaSVjV2klZldpfk8jaiZeYSVjJl5hJWYmXmFwJl5hflAnWk98KWRPI2omXmElYyZeYSVmJl5hcCZeYX5PWCloT2opak8mU1dPfk8jXilrT35PJlNXTyNqJnphJWMmemElZiZ6YX5PfCltTyNqJnphJWMmemElZiZ6YX5PcTB6T3gxWU8jaiZ2YSVjJnZhJWYmdmF9JnZhflAnWk98KXBPI2omdmElYyZ2YSVmJnZhfSZ2YX5PWClyT2Mpck8mU1dPfk8mWCl3T35Pdil6TyNtKXlPUCNraVgja2loI2tpaiNraXEja2l1I2tpeCNraSFSI2tpIVMja2khViNraSFXI2tpIVoja2khXyNraSFqI2tpIXUja2khdiNraSF3I2tpI08ja2kjUSNraSNTI2tpI1Uja2kjVyNraSNbI2tpI14ja2kjYSNraSNiI2tpI2Qja2kjZiNraSNvI2tpI3Ija2kjdiNraSN4I2tpI30ja2kkUSNraSRTI2tpJWAja2klfCNraSV9I2tpJlIja2kmUyNraSZoI2tpJmkja2kmbCNraSZvI2tpJnMja2kmdCNraSZ1I2tpJWIja2klZiNraX5Pdil7T1AjbmlYI25paCNuaWojbmlxI25pdSNuaXgjbmkhUiNuaSFTI25pIVYjbmkhVyNuaSFaI25pIV8jbmkhaiNuaSF1I25pIXYjbmkhdyNuaSNPI25pI1EjbmkjUyNuaSNVI25pI1cjbmkjWyNuaSNeI25pI2EjbmkjYiNuaSNkI25pI2YjbmkjbyNuaSNyI25pI3YjbmkjeCNuaSN9I25pJFEjbmkkUyNuaSVgI25pJXwjbmklfSNuaSZSI25pJlMjbmkmaCNuaSZpI25pJmwjbmkmbyNuaSZzI25pJnQjbmkmdSNuaSViI25pJWYjbml+T1gpfU9wJn1hflAnWk98Kk9PcCZ9YX5PfCpPT3AmfWF+UCRnT3AqU09+TyVhKldPfk92KlpPI3MnaU8jdCpZT1AjcWlYI3FpaCNxaWojcWlxI3FpdSNxaXgjcWkhUiNxaSFTI3FpIVYjcWkhVyNxaSFaI3FpIV8jcWkhaiNxaSF1I3FpIXYjcWkhdyNxaSNPI3FpI1EjcWkjUyNxaSNVI3FpI1cjcWkjWyNxaSNeI3FpI2EjcWkjYiNxaSNkI3FpI2YjcWkjbyNxaSNyI3FpI3YjcWkjeCNxaSN9I3FpJFEjcWkkUyNxaSVgI3FpJXwjcWklfSNxaSZSI3FpJlMjcWkmaCNxaSZpI3FpJmwjcWkmbyNxaSZzI3FpJnQjcWkmdSNxaSViI3FpJWYjcWl+T1gqXk9xMHpPeDFZT30kd09+UCdaT3Ewek94MVlPfSdPYX5QJ1pPfCpiT30nT2F+T1gqZk9jKmdPaSpqTyZPKmhPJlNXT35PfSR3TydSKmxPfk9qJ3BPfk9qIW5PfSR3T35PJWMqcU9+TyVjKnNPfk9YJVtPYyVbT3Ewek94MVlPaSZjYX5QJ1pPfCp2T2kmY2F+T3Ewek94MVlPfSp5TyFZJmZhflAnWk98KnpPIVkmZmF+T3Ewek94MVlPfCp6T30qfU8hWSZmYX5QJ1pPcTB6T3gxWU98KnpPIVkmZmF+UCdaT3wqek99Kn1PIVkmZmF+T28we09wMHtPcTFVT3IxVk9pbGltbGl1bGl8bGkhVmxpIVdsaSZZbGkhWWxpfWxpIV5saSNqbGklY2xpJWZsaSFTbGkjX2xpdmxpIW5saSZYbGl+T24wfU9+UCFKek9ubGl+UCFKek9YKF9PaStTT3Ewek94MVlPflAnWk9wK1VPfk9pK1NPfCtXT35PaStYT35PWChfT3Ewek94MVlPIVkmYWl+UCdaT3wrWU8hWSZhaX5PIVkrWk9+T1gobk9xMHpPeDFZTyFeJltpI2omW2klYyZbaSVmJltpaSZbaX0mW2khbiZbaSZYJltpflAnWk98K15PIVYlcU8hVyVwTyFeJmJpfk98K2FPIV4mW2kjaiZbaSVjJltpJWYmW2lpJltpfSZbaSFuJltpJlgmW2l+TyFeK2JPfk9jK2RPcTB6T3gxWU8hXiZiaX5QJ1pPfCteTyFeJmJpfk8hXitmT35PWCtoT3Ewek94MVlPfSZwYSFeJnBhIW4mcGF+UCdaT3wraU99JnBhIV4mcGEhbiZwYX5PIV8rbE8mcittTyFeIW9Yfk8hXitvT35PfSh7TyFeK3BPfk99KHtPIV4rcU9+T30oe08hXityT35PfSh7TyFeK3NPfk9YJmRPcXVPeHZPfSV1cSF7JXVxI2oldXElYyV1cSVmJXVxJlgldXF+UCdaT3wkeWl9JHlpIXskeWkjaiR5aSVjJHlpJWYkeWkmWCR5aX5QJGdPWCZkT3F1T3h2T35QJ1pPWCZkT3Ewek94MVlPI2oldWElYyV1YSVmJXVhJlgldWF+UCdaT3wrdE8jaiV1YSVjJXVhJWYldWEmWCV1YX5PfCRsYSNqJGxhJWMkbGElZiRsYXAkbGF+UCRnTyNqJl5pJWMmXmklZiZeaXAmXml+UCdaT3wrd08jaiNacSVjI1pxJWYjWnF+T3wreE8jXyt6TyNqJnlYJWMmeVglZiZ5WGkmeVh+T1grfE9qKWpPJlNXT35PJlNXTyNqJnppJWMmemklZiZ6aX5PcTB6T3gxWU8jaiZ2aSVjJnZpJWYmdml9JnZpflAnWk99JFtPfCNoWCFZI2hYfk98LFFPIVkme1h+TyFZLFNPfk92LFZPI20peU9QI2txWCNrcWgja3FqI2txcSNrcXUja3F4I2txIVIja3EhUyNrcSFWI2txIVcja3EhWiNrcSFfI2txIWoja3EhdSNrcSF2I2txIXcja3EjTyNrcSNRI2txI1Mja3EjVSNrcSNXI2txI1sja3EjXiNrcSNhI2txI2Ija3EjZCNrcSNmI2txI28ja3EjciNrcSN2I2txI3gja3EjfSNrcSRRI2txJFMja3ElYCNrcSV8I2txJX0ja3EmUiNrcSZTI2txJmgja3EmaSNrcSZsI2txJm8ja3EmcyNrcSZ0I2txJnUja3ElYiNrcSVmI2txfk9wJVRhfCVUYX5QJGdPWCl9T3AmfWl+UCdaT3wsXk9wJn1pfk98LGhPfSR3TyNfLGhPfk8jdCxqT1AjcXFYI3FxaCNxcWojcXFxI3FxdSNxcXgjcXEhUiNxcSFTI3FxIVYjcXEhVyNxcSFaI3FxIV8jcXEhaiNxcSF1I3FxIXYjcXEhdyNxcSNPI3FxI1EjcXEjUyNxcSNVI3FxI1cjcXEjWyNxcSNeI3FxI2EjcXEjYiNxcSNkI3FxI2YjcXEjbyNxcSNyI3FxI3YjcXEjeCNxcSN9I3FxJFEjcXEkUyNxcSVgI3FxJXwjcXElfSNxcSZSI3FxJlMjcXEmaCNxcSZpI3FxJmwjcXEmbyNxcSZzI3FxJnQjcXEmdSNxcSViI3FxJWYjcXF+TyNfLGtPfCVWYX0lVmF+T3Ewek94MVlPfSdPaX5QJ1pPfCxtT30nT2l+T30kW08mWCxvT2knUVh8J1FYfk8mU1dPaSdRWHwnUVh+T3wsc09pJ1BYfk9pLHVPfk8lYSx4T35PIVYlcU8hVyVwT2kmZGl8JmRpfk9YJVtPYyVbT3Ewek94MVlPaSZjaX5QJ1pPfSx7T3wkb2EhWSRvYX5PcTB6T3gxWU99LHxPfCRvYSFZJG9hflAnWk9xMHpPeDFZT30qeU8hWSZmaX5QJ1pPfC1QTyFZJmZpfk9xMHpPeDFZT3wtUE8hWSZmaX5QJ1pPfC1QT30tU08hWSZmaX5PaSRraXwka2khWSRraX5QJGdPWChfT3Ewek94MVlPflAnWk9wLVVPfk9YKF9PaS1WT3Ewek94MVlPflAnWk9YKF9PcTB6T3gxWU8hWSZhcX5QJ1pPfCRqaSFeJGppI2okamklYyRqaSVmJGppaSRqaX0kamkhbiRqaSZYJGppflAkZ09YKG5PcTB6T3gxWU9+UCdaT2MrZE9xMHpPeDFZTyFeJmJxflAnWk98LVdPIV4mYnF+TyFeLVhPfk9YKG5PcTB6T3gxWU8hXiZbcSNqJltxJWMmW3ElZiZbcWkmW3F9JltxIW4mW3EmWCZbcX5QJ1pPfS1ZT35PWCtoT3Ewek94MVlPfSZwaSFeJnBpIW4mcGl+UCdaT3wtX099JnBpIV4mcGkhbiZwaX5PIV8rbE8mcittTyFeIW9hfk9YJmRPcTB6T3gxWU8jaiV1aSVjJXVpJWYldWkmWCV1aX5QJ1pPfC1iTyNqJXVpJWMldWklZiV1aSZYJXVpfk8mU1dPI2omeWElYyZ5YSVmJnlhaSZ5YX5PfC1lTyNqJnlhJWMmeWElZiZ5YWkmeWF+T2ktaE9+T1gpck9jKXJPJlNXTyFZJnthfk98LWpPIVkme2F+T3AlVGl8JVRpflAkZ09YKX1PflAnWk9YKX1PcCZ9cX5QJ1pPdi1uT1AjcHlYI3B5aCNweWojcHlxI3B5dSNweXgjcHkhUiNweSFTI3B5IVYjcHkhVyNweSFaI3B5IV8jcHkhaiNweSF1I3B5IXYjcHkhdyNweSNPI3B5I1EjcHkjUyNweSNVI3B5I1cjcHkjWyNweSNeI3B5I2EjcHkjYiNweSNkI3B5I2YjcHkjbyNweSNyI3B5I3YjcHkjeCNweSN9I3B5JFEjcHkkUyNweSVgI3B5JXwjcHklfSNweSZSI3B5JlMjcHkmaCNweSZpI3B5JmwjcHkmbyNweSZzI3B5JnQjcHkmdSNweSViI3B5JWYjcHl+TyViLXJPJWYtck9+UGBPI3Qtc09QI3F5WCNxeWgjcXlqI3F5cSNxeXUjcXl4I3F5IVIjcXkhUyNxeSFWI3F5IVcjcXkhWiNxeSFfI3F5IWojcXkhdSNxeSF2I3F5IXcjcXkjTyNxeSNRI3F5I1MjcXkjVSNxeSNXI3F5I1sjcXkjXiNxeSNhI3F5I2IjcXkjZCNxeSNmI3F5I28jcXkjciNxeSN2I3F5I3gjcXkjfSNxeSRRI3F5JFMjcXklYCNxeSV8I3F5JX0jcXkmUiNxeSZTI3F5JmgjcXkmaSNxeSZsI3F5Jm8jcXkmcyNxeSZ0I3F5JnUjcXklYiNxeSVmI3F5fk98LXZPfSR3TyNfLXZPfk9xMHpPeDFZT30nT3F+UCdaT3wteU99J09xfk8mWCxvT2knUWF8J1Fhfk9YKmZPYypnTyZPKmhPJlNXT2knUGF+T3wtfU9pJ1Bhfk8kVi5ST35PWCVbT2MlW09xMHpPeDFZT35QJ1pPcTB6T3gxWU99LlNPfCRvaSFZJG9pflAnWk9xMHpPeDFZT3wkb2khWSRvaX5QJ1pPfS5TT3wkb2khWSRvaX5PcTB6T3gxWU99KnlPflAnWk9xMHpPeDFZT30qeU8hWSZmcX5QJ1pPfC5WTyFZJmZxfk9xMHpPeDFZT3wuVk8hWSZmcX5QJ1pPdS5ZTyFWJXFPIVclcE9pJl1xIVkmXXEhXiZdcXwmXXF+UCEuVE9jK2RPcTB6T3gxWU8hXiZieX5QJ1pPfCRtaSFeJG1pflAkZ09jK2RPcTB6T3gxWU9+UCdaT1graE9xMHpPeDFZT35QJ1pPWCtoT3Ewek94MVlPfSZwcSFeJnBxIW4mcHF+UCdaT30oe08hXi5eTyFuLl9Pfk9YJmRPcTB6T3gxWU8jaiV1cSVjJXVxJWYldXEmWCV1cX5QJ1pPI18uYE98JU9hI2olT2ElYyVPYSVmJU9haSVPYX5PJlNXTyNqJnlpJWMmeWklZiZ5aWkmeWl+T3wuYk8jaiZ5aSVjJnlpJWYmeWlpJnlpfk9YKXJPYylyTyZTV08hWSZ7aX5Pdi5mT1AjcCFSWCNwIVJoI3AhUmojcCFScSNwIVJ1I3AhUngjcCFSIVIjcCFSIVMjcCFSIVYjcCFSIVcjcCFSIVojcCFSIV8jcCFSIWojcCFSIXUjcCFSIXYjcCFSIXcjcCFSI08jcCFSI1EjcCFSI1MjcCFSI1UjcCFSI1cjcCFSI1sjcCFSI14jcCFSI2EjcCFSI2IjcCFSI2QjcCFSI2YjcCFSI28jcCFSI3IjcCFSI3YjcCFSI3gjcCFSI30jcCFSJFEjcCFSJFMjcCFSJWAjcCFSJXwjcCFSJX0jcCFSJlIjcCFSJlMjcCFSJmgjcCFSJmkjcCFSJmwjcCFSJm8jcCFSJnMjcCFSJnQjcCFSJnUjcCFSJWIjcCFSJWYjcCFSfk9xMHpPeDFZT30nT3l+UCdaT1gqZk9jKmdPJk8qaE8mU1dPaSdQaX5PJFYuUk8lYi5uTyVmLm5Pfk9YLnhPai52TyFaLnVPIV8ud08hai5xTyF2LnNPIXcuc08lfS5wTyZTV08maF1PJmleTyZsX09+T3Ewek94MVlPfCRvcSFZJG9xflAnWk99Ln1PfCRvcSFZJG9xfk9xMHpPeDFZT30qeU8hWSZmeX5QJ1pPfC9PTyFZJmZ5fk9xMHpPeC9TT35QJ1pPdS5ZTyFWJXFPIVclcE9pJl15IVkmXXkhXiZdeXwmXXl+UCEuVE99KHtPIV4vVk9+TyZTV08jaiZ5cSVjJnlxJWYmeXFpJnlxfk98L1hPI2omeXElYyZ5cSVmJnlxaSZ5cX5PWCpmT2MqZ08mTypoTyZTV09+T2ovXk8haC9bT3wkV1gjXyRXWCV3JFdYaSRXWH5PdSRXWH0kV1ghWSRXWCFeJFdYflAkJmxPJXwvYE8lfS9gT3UkWFh8JFhYfSRYWCNfJFhYJXckWFghWSRYWGkkWFghXiRYWH5PIWovYk9+T3wvZk8jXy9oTyV3L2NPdSdTWH0nU1ghWSdTWGknU1h+T2Mva09+UCQhfE9qL15PdSdUWHwnVFh9J1RYI18nVFgldydUWCFZJ1RYaSdUWCFeJ1RYfk91L29PfSR3T35PcTB6T3gxWU98JG95IVkkb3l+UCdaT3Ewek94MVlPfSp5TyFZJmYhUn5QJ1pPfC9zTyFZJmYhUn5PaSZgWHUmYFghViZgWCFXJmBYIVkmYFghXiZgWHwmYFh+UCEuVE91LllPIVYlcU8hVyVwT2kmX2EhWSZfYSFeJl9hfCZfYX5PJlNXTyNqJnl5JWMmeXklZiZ5eWkmeXl+TyFoL1tPaiRfYXUkX2F8JF9hfSRfYSNfJF9hJXckX2EhWSRfYWkkX2EhXiRfYX5PIWovfE9+TyV8L2BPJX0vYE91JFhhfCRYYX0kWGEjXyRYYSV3JFhhIVkkWGFpJFhhIV4kWGF+TyV3L2NPdSRdYXwkXWF9JF1hI18kXWEhWSRdYWkkXWEhXiRdYX5PdSdTYX0nU2EhWSdTYWknU2F+UCQhcE98MFJPdSdTYX0nU2EhWSdTYWknU2F+TyFZMFVPfk9pMFVPfk99MFdPfk8hXjBYT35PcTB6T3gxWU99KnlPIVkmZiFaflAnWk99MFtPfk8mWDBdT35QJCZsT3wwXk8jXy9oTyV3L2NPaSdWWH5PfDBeT2knVlh+T2kwYE9+TyFqMGFPfk8jXy9oT3UlWmF8JVphfSVaYSV3JVphIVklWmFpJVphIV4lWmF+TyNfL2hPJXcvY091JV9hfCVfYX0lX2EhWSVfYWklX2F+T3UnU2l9J1NpIVknU2lpJ1NpflAkIXBPfDBjTyNfL2hPJXcvY08hXidVYX5PfSRnYX5QJGdPaSdWYX5QJCFwT3wwa09pJ1Zhfk9jMG1PIV4nVWl+UCQhfE98MG9PIV4nVWl+T3wwb08jXy9oTyV3L2NPIV4nVWl+TyNfL2hPJXcvY09pJGVpfCRlaX5PJlgwck9+UCQmbE8jXy9oTyV3L2NPaSVeYXwlXmF+T2knVml+UCQhcE99MHVPfk9jMG1PIV4nVXF+UCQhfE98MHdPIV4nVXF+TyNfL2hPJXcvY098JV1pIV4lXWl+T2MwbU9+UCQhfE9jMG1PIV4nVXl+UCQhfE8jXy9oTyV3L2NPaSRmaXwkZml+TyNfL2hPJXcvY098JV1xIV4lXXF+T3wrdE8jaiV1YSVjJXVhJWYldWEmWCV1YX5QJGdPWCZkT3Ewek94MVlPflAnWk9wMVBPfk9xMVBPflAnWk99MVFPfk92MVJPflAhLlRPJmkmbCZ0JnUmaCZvJnMmUyZoflwiLFxuICBnb3RvOiBcIiE/YidXUFBQUFBQUFAnWFAnYSp8K2YsUCxrLVctdFAuY1AnYS9TL1MnYVBQUCdhMm9QUFBQUFAybzVmUFA1ZlA3eThTPmZQUD5pP1o/XlBQJ2EnYVBQP3ZQUCdhJ2FQUCdhJ2EnYSdhJ2E/ekB0J2FQQHdQQH1FWEh4UEh8SVlJXkliSWYnYVBQUElqSXMnWFAnWCdYUCdYUCdYUCdYUCdYUCdYJ1gnWFAnWFBQJ1hQUCdYUCdYUEl5SlZKX1BKZkpsUEpmUEpmSmZQUFBKZlBMelBNVE1fTWVMelBKZk1uUEpmUE11TXtQTlBOZSEgUyEgbU5QTlAhIHMhIVFOUE5QTlBOUCEhZiEhbCEhbyEhdCEhdyEjUiEjWCEjZSEjdyEjfSEkWCEkXyEkeyElUiElWCElXyElaSElbyEldSEleyEmUiEmWCEmayEmdSEmeyEnUiEnWCEnYyEnaSEnbyEndSEneyEoViEoXSEoZyEobSEodiEofCEpXSEpZSEpbyEpdlBQUFBQUFBQUFBQUFBQUFBQISl8ISpQISpWISpgISpqISp1UFBQUFBQUFBQUFBQIS9sITFRITVUIThoUFAhOHAhOVMhOV0hOlUhOXshOl8hOmUhOmghOmshOm4hOnYhO2dQUFBQUFBQUFAhO2ohO3lQUFBQITxpITx1IT1SIT1YIT1iIT1lIT1oIT1uIT10IT16IT19UCE+ViE+YCE/WyE/X11qT3MjdiR3KlcsZChUZU9UWVpbZmlzdHV3eX0hTyFTIVUhViFXIVohXiFoIWkhaiFrIWwhbSFuIXAhdCF1IXYheCF5I1AjVCNYI1kjYyNnI2ojbSNzI3YkWCRZJFskXiRhJHIkdCR1JHclTyVbJWElaCVrJW0lcCV0JXkleyZWJmImZCZvJnMmfCdPJ1AnVydaJ18nYidpJ2wnfShPKFIoVChVKFkoXyhhKGUoaShuKG8odSh4KVYpWClhKWQpcCl3KXkpfSpPKlMqVypeKmIqbCp2Knkqeip9K1QrVStXK1krXSteK2ErZCtoK2krbCt0K3YrdyxPLF0sXixkLGwsbSxwLHoseyx8LU8tUC1TLVUtVy1ZLVstXi1fLWIteS17LlMuVi5ZLn0vTy9vL3MwWzB6MHswfDB9MVAxUTFSMVMxVDFWMVp9IWhRI3IkUCRiJHEkfSVyJXclfSZPJnQnYSd4KVcpYyl8K1IrWyxbLVowWTFPIVAhaVEjciRQJGIkcSR9JVMlciV3JX0mTyZ0J2EneClXKWMpfCtSK1ssWy1aMFkxTyFSIWpRI3IkUCRiJHEkfSVTJVQlciV3JX0mTyZ0J2EneClXKWMpfCtSK1ssWy1aMFkxTyFUIWtRI3IkUCRiJHEkfSVTJVQlVSVyJXclfSZPJnQnYSd4KVcpYyl8K1IrWyxbLVowWTFPIVYhbFEjciRQJGIkcSR9JVMlVCVVJVYlciV3JX0mTyZ0J2EneClXKWMpfCtSK1ssWy1aMFkxTyFYIW1RI3IkUCRiJHEkfSVTJVQlVSVWJVclciV3JX0mTyZ0J2EneClXKWMpfCtSK1ssWy1aMFkxTyFdIW1RIXMjciRQJGIkcSR9JVMlVCVVJVYlVyVYJXIldyV9Jk8mdCdhJ3gpVyljKXwrUitbLFstWjBZMU8oVFRPVFlaW2Zpc3R1d3l9IU8hUyFVIVYhVyFaIV4haCFpIWohayFsIW0hbiFwIXQhdSF2IXgheSNQI1QjWCNZI2MjZyNqI20jcyN2JFgkWSRbJF4kYSRyJHQkdSR3JU8lWyVhJWglayVtJXAldCV5JXsmViZiJmQmbyZzJnwnTydQJ1cnWidfJ2InaSdsJ30oTyhSKFQoVShZKF8oYShlKGkobihvKHUoeClWKVgpYSlkKXApdyl5KX0qTypTKlcqXipiKmwqdip5KnoqfStUK1UrVytZK10rXithK2QraCtpK2wrdCt2K3csTyxdLF4sZCxsLG0scCx6LHssfC1PLVAtUy1VLVctWS1bLV4tXy1iLXktey5TLlYuWS59L08vby9zMFswejB7MHwwfTFQMVExUjFTMVQxVjFaJmlWT1laW2lzdXd9IU8hUyFVIVYhWiFuIXAhdCF1IXYheCF5I2MjZyNqI20jcyN2JFkkWyReJGEkdSR3JVslYSVoJWslbSV0JXkleyZWJmImbyZzJ08nUCdXJ1onYidpJ2wnfShPKFIoVChVKFkoYShpKG8odSh4KVYpWClhKXApdyl5KlMqVypeKmIqbCp2Knkqeip9K1QrVStXK1krXSteK2EraCtpK2wrdCt3LE8sZCxsLG0scCx6LHssfC1PLVAtUy1VLVctWS1bLV4tXy1iLXktey5TLlYuWS59L08vczBbMHowezB8MH0xUDFRMVIxUzFWMVolc1hPWVpbaXN3fSFPIVMhVSFWIVohbiFwI2MjZyNqI20jcyN2JFkkWyReJGEkdSR3JVslYSVrJW0ldCV5JXsmViZiJm8mcydPJ1AnVydaJ2InaSdsJ30oTyhSKFQoVShZKGEoaShvKHUoeClWKVgpYSlwKXcpeSpTKlcqXipiKmwqdip5KnoqfStUK1crWStdK14rYStoK2krbCt0K3csTyxkLGwsbSxwLHoseyx8LU8tUC1TLVctWS1bLV4tXy1iLXktey5TLlYufS9PL3MxUTFSMVNRJFZ2US90L1NSMVcxWSd6ZU9UWVpbZmlzdHV3eX0hTyFTIVUhViFXIVohXiFoIWkhaiFrIWwhbSFwIXQhdSF2IXgheSNQI1QjWCNZI2MjZyNqI20jcyN2JFgkWSRbJF4kYSRyJHQkdSR3JU8lWyVhJWglayVtJXAldCV5JXsmViZiJmQmbyZzJnwnTydQJ1cnWidfJ2InaSdsJ30oUihUKFUoWShfKGEoZShpKG4obyh1KHgpVilYKWEpZClwKXcpeSl9Kk8qUypXKl4qYipsKnkqeip9K1QrVStXK1krXSteK2ErZCtoK2krbCt0K3YrdyxPLF0sXixkLGwsbSxwLHssfC1PLVAtUy1VLVctWS1bLV4tXy1iLXktey5TLlYuWS59L08vby9zMFswejB7MHwwfTFQMVExUjFTMVQxVjFaVyN5bSFQIVEkaFckUnYmcS9TMVlRJGohUlEkbiFUUSR7IVtRJHwhXVclWiFuKE8qdix6UyZwJFMkVFEnZSR2USlZJmpRKWgnUVUpaSdTKWopa1UpbCdVKW0rfVcpcydZLFEtai5kUSpkJ25XKmUncCxzLX0ubFEsUClyUyxyKmYqZ1ktZCt4LWUuYS5iL1hRLWcrelEtdCxoUS14LGtRLmotdmwuby5SLnUudi54L2QvZi9rMFIwVzBdMGIwbTByMHVRL1cuYFEvbC53US94L15RMFQvaFUwaDBeMGswc1gwbjBjMG8wdjB3UiZvJFIhXyF8WVohVSFWIXAlYSVtJXQoUihUKFUoYShpKXkqeSp6Kn0rVCtXK1kseyx8LU8tUC1TLlMuVi59L08vc1IlayF7USNRWVEmVyNjUSZaI2dRJl0jalEmXyNtUSZ4JF5RJnskYVItYCtsVC9SLlkwWyFbIW9RIXMjciRQJGIkcSR9JVMlVCVVJVYlVyVYJXIldyV9Jk8mdCdhJ3gpVyljKXwrUitbLFstWjBZMU9RJm0jelEndCR8UipwJ3VSJ30lWlElZCFyUi92L1soU2RPVFlaW2Zpc3R1d3l9IU8hUyFVIVYhVyFaIV4haCFpIWohayFsIW0hbiFwIXQhdSF2IXgheSNQI1QjWCNZI2MjZyNqI20jcyN2JFgkWSRbJF4kYSRyJHQkdSR3JU8lWyVhJWglayVtJXAldCV5JXsmViZiJmQmbyZzJnwnTydQJ1cnWidfJ2InaSdsJ30oTyhSKFQoVShZKF8oYShlKGkobihvKHUoeClWKVgpYSlkKXApdyl5KX0qTypTKlcqXipiKmwqdip5KnoqfStUK1UrVytZK10rXithK2QraCtpK2wrdCt2K3csTyxdLF4sZCxsLG0scCx6LHssfC1PLVAtUy1VLVctWS1bLV4tXy1iLXktey5TLlYuWS59L08vby9zMFswejB7MHwwfTFQMVExUjFTMVQxVjFaUyNwZCNxIVAucy5SLnUudi53LngvXi9kL2YvazBSMFcwXTBeMGIwYzBrMG0wbzByMHMwdTB2MHcoU2RPVFlaW2Zpc3R1d3l9IU8hUyFVIVYhVyFaIV4haCFpIWohayFsIW0hbiFwIXQhdSF2IXgheSNQI1QjWCNZI2MjZyNqI20jcyN2JFgkWSRbJF4kYSRyJHQkdSR3JU8lWyVhJWglayVtJXAldCV5JXsmViZiJmQmbyZzJnwnTydQJ1cnWidfJ2InaSdsJ30oTyhSKFQoVShZKF8oYShlKGkobihvKHUoeClWKVgpYSlkKXApdyl5KX0qTypTKlcqXipiKmwqdip5KnoqfStUK1UrVytZK10rXithK2QraCtpK2wrdCt2K3csTyxdLF4sZCxsLG0scCx6LHssfC1PLVAtUy1VLVctWS1bLV4tXy1iLXktey5TLlYuWS59L08vby9zMFswejB7MHwwfTFQMVExUjFTMVQxVjFaVCNwZCNxVCNkYCNlZSh8JlcmWiZdJl8pTylRKVMpVS1gLl9UK20oeytuVCNoYSNpVCNrYiNsVCNuYyNvUSRgeFEsUClzUixxKmVYJF54JF8kYCZ6USdbJG5RJ3Ike1EndSR8UipWJ2VRKXQnWVYtaSxRLWouZFpsT3MkdypXLGRYcE9zKlcsZFEkeCFZUSddJG9RJ14kcFEnbyR6USdzJHxRKlQnZFEqWydpUSpfJ2pRKmAna1EqbSdxUypvJ3QndVEsVyl5USxZKXpRLFope1EsXypSUyxhKlUqblEsZSpZUSxmKlpTLGcqXSpeUSx3KnBRLWwsVlEtbSxYUS1vLGBTLXAsYixjUS11LGlRLXcsalEuZS1uUS5nLXFRLmgtc1EuaS10US9ZLmZRL1oualEvcC57UjBaL3FXcE9zKlcsZFIjfG9RJ3Eke1MqVSdlJ3JSLGMqVlEscCplUi17LHFRKm4ncVEsYipVUi1xLGNabk9vcypXLGRRJ3ckfVIqcid4VC5QLHguUXUuei5SLnUudi54L14vZC9mL2swUjBXMF0wXjBiMGswbTByMHMwdXQuei5SLnUudi54L14vZC9mL2swUjBXMF0wXjBiMGswbTByMHMwdVEvbC53WDBuMGMwbzB2MHchUC5yLlIudS52LncueC9eL2QvZi9rMFIwVzBdMF4wYjBjMGswbTBvMHIwczB1MHYwd1EvYS5xUi99L2JnL2QudC9lL3kwUTBWMGUwZzBpMHQweDB5dS55LlIudS52LngvXi9kL2YvazBSMFcwXTBeMGIwazBtMHIwczB1WC9fLm8ueS94MGhSL3ovXlYwajBeMGswc1IvcS57UXNPUyRPcyxkUixkKldRJnIkVVIpXyZyUyV6I1ckV1MocCV6KHNUKHMlfSZ0USVuI09RJXUjU1coYiVuJXUoZyhrUShnJXJSKGsld1EmfSRiUillJn1RKHYmT1ErXyhxVCtlKHYrX1EoUCVdUip3KFBTKFMlYCVhWSp7KFMqfC1RLlcvUFUqfChUKFUoVlUtUSp9K08rUFMuVy1SLVNSL1AuWFEjX15SJlIjX1EjYl9SJlQjYlEjZWBSJlgjZVEoeSZVUytqKHkra1Irayh6UStuKHtSLWErblEjaWFSJlsjaVEjbGJSJl4jbFEjb2NSJmAjb1EjcWRSJmEjcVEjdGdRJmMjclcmZiN0JmMpYit1USliJndSK3UxT1EkX3hTJnkkXyZ6UiZ6JGBRJ1gkbFIpcSdYUSZrI3lSKVoma1EkaCFRUidSJGhRK3kpaVMtZit5LmNSLmMtZ1EnViRqUiluJ1ZRLFIpdFItayxSUSN3a1ImaCN3USl4J11SLFUpeFEnYCRxUypQJ2AqUVIqUSdhUSdoJHhSKlgnaFEnbSR5UypjJ20sblIsbipkUSx0KmlSLk8sdFdvT3MqVyxkUiN7b1EuUSx4Ui5tLlFkL2UudC95MFEwVjBlMGcwaTB0MHgweVIwUC9lVS9dLm8veDBoUi93L11RMGQwVlMwcDBkMHFSMHEwZVMwXy95L3pSMGwwX1EvZy50UjBTL2dSIWBQWHJPcypXLGRXcU9zKlcsZFInZiR3WWtPcyR3KlcsZFImZyN2W3hPcyN2JHcqVyxkUiZ4JF4maFFPWVpbaXN1d30hTyFTIVUhViFaIW4hcCF0IXUhdiF4IXkjYyNnI2ojbSNzI3YkWSRbJF4kYSR1JHclWyVhJWglayVtJXQleSV7JlYmYiZvJnMnTydQJ1cnWidiJ2knbCd9KE8oUihUKFUoWShhKGkobyh1KHgpVilYKWEpcCl3KXkqUypXKl4qYipsKnYqeSp6Kn0rVCtVK1crWStdK14rYStoK2krbCt0K3csTyxkLGwsbSxwLHoseyx8LU8tUC1TLVUtVy1ZLVstXi1fLWIteS17LlMuVi5ZLn0vTy9zMFswejB7MHwwfTFQMVExUjFTMVYxWlEhc1RRI3JmUSRQdFUkYnklcChlUyRxIVckdFEkfSFeUSVTIWhRJVQhaVElVSFqUSVWIWtRJVchbFElWCFtUSVyI1BRJXcjVFElfSNYUSZPI1lRJnQkWFEnYSRyUSd4JU9RKVcmZFUpYyZ8KWQrdlcpfCdfKk8sXSxeUStSKF9RK1soblEsWyl9US1aK2RRMFkvb1IxTzFUUSNPWVEjU1pRJG8hVVEkcCFWUSVgIXBRKFYlYV4oXiVtJXQoYShpK1QrVytZXip4KFIqei1PLVAuVi9PL3NRK08oVFErUChVUSxYKXlRLH0qeVEtUip9US5ULHtRLlUsfFEuWC1TUS58LlNSL3IufVtnT3MjdiR3KlcsZCFeIXtZWiFVIVYhcCVhJW0ldChSKFQoVShhKGkpeSp5KnoqfStUK1crWSx7LHwtTy1QLVMuUy5WLn0vTy9zUSNXW1EjdWlTJFd3fVEkZSFPVyRsIVMkYSdiKlNTJHkhWiR1VyVZIW4oTyp2LHpZJlUjYyNnI2ojbStsYCZlI3MmYilWKVgpYSt0LWIxU1EmdSRZUSZ2JFtRJnckXlEneyVbUShdJWtXKG0leShvK10rYVEocSV7USh6JlZRKV0mb1MpYCZzMVFRKWYnT1EpZydQVSlvJ1cpcCxPUSl2J1pRKl0naVkqYSdsKmIsbCxtLXlRKnQnfVMrUShZMVJXK2ModSteLVctW1crZyh4K2ktXi1fUSxUKXdRLGkqXlEsdipsUS1dK2hRLWMrd1EteixwUS5dLVlSLmste2hVT3MjcyN2JHcmYiZzKFkpVilYKlcsZCVZIXpZWltpd30hTyFTIVUhViFaIW4hcCNjI2cjaiNtJFkkWyReJGEkdSVbJWElayVtJXQleSV7JlYmbydPJ1AnVydaJ2InaSdsJ30oTyhSKFQoVShhKGkobyh1KHgpYSlwKXcpeSpTKl4qYipsKnYqeSp6Kn0rVCtXK1krXSteK2EraCtpK2wrdCt3LE8sbCxtLHAseix7LHwtTy1QLVMtVy1ZLVstXi1fLWIteS17LlMuVi59L08vczFRMVIxU1EkUXVXJWUhdCF4MHsxVlElZiF1USVnIXZRJWkheVElczB6UyhYJWgxUFEoWjB8UShbMH1RLVQrVVEuWy1VUy9RLlkwW1IxWDFaVSRVdi9TMVlSKV4mcVtoT3MjdiR3KlcsZGEhfVkjYyNnI2ojbSReJGErbFEjXVtRJFp3UiRkfVElbyNPUSV2I1NRJXwjV1EneyVZUShoJXJRKGwld1EodCV9USh3Jk9RK2AocVEseSp0US5aLVRRL1UuW1IvdS9UUSRjeVEoZCVwUitWKGVRL1QuWVIwZjBbUiNWWlIjW1tSJV8hblElXSFuVip1KE8qdix6IV0hcVEhcyNyJFAkYiRxJH0lUyVUJVUlViVXJVglciV3JX0mTyZ0J2EneClXKWMpfCtSK1ssWy1aMFkxT1IlYiFwUSZXI2NRJlojZ1EmXSNqUSZfI21SLWArbFEofSZXUSlQJlpRKVImXVEpVCZfUStwKU9RK3EpUVErcilTUStzKVVRLl4tYFIvVi5fUSRtIVNRJnskYVEqUidiUixgKlNRI3ptUSRmIVBRJGkhUVInVCRoUSloJ1NSK3wpa1EpaCdTUSt7KWpSK3wpa1IkayFSUil1J1lYcU9zKlcsZFEkcyFXUidjJHRRJHohWlInZCR1UiprJ3BRKmkncFYtfCxzLX0ubFEuey5SUS9pLnVSL2oudlUudC5SLnUudlEvbi54US95L15RME8vZFUwUS9mMFIwYlEwVi9rUTBlMFdRMGcwXVUwaTBeMGswc1EwdDBtUTB4MHJSMHkwdVIvbS53Ui97L15cIixcbiAgbm9kZU5hbWVzOiBcIuKaoCBwcmludCB7IHsgeyB7IENvbW1lbnQgU2NyaXB0IEFzc2lnblN0YXRlbWVudCAqIEJpbmFyeUV4cHJlc3Npb24gQml0T3AgQml0T3AgQml0T3AgQml0T3AgQXJpdGhPcCBBcml0aE9wIEAgQXJpdGhPcCAqKiBVbmFyeUV4cHJlc3Npb24gQXJpdGhPcCBCaXRPcCBBd2FpdEV4cHJlc3Npb24gYXdhaXQgKSAoIFBhcmVudGhlc2l6ZWRFeHByZXNzaW9uIEJpbmFyeUV4cHJlc3Npb24gb3IgYW5kIENvbXBhcmVPcCBpbiBub3QgaXMgVW5hcnlFeHByZXNzaW9uIENvbmRpdGlvbmFsRXhwcmVzc2lvbiBpZiBlbHNlIExhbWJkYUV4cHJlc3Npb24gbGFtYmRhIFBhcmFtTGlzdCBWYXJpYWJsZU5hbWUgQXNzaWduT3AgLCA6IE5hbWVkRXhwcmVzc2lvbiBBc3NpZ25PcCBZaWVsZEV4cHJlc3Npb24geWllbGQgZnJvbSBUdXBsZUV4cHJlc3Npb24gQ29tcHJlaGVuc2lvbkV4cHJlc3Npb24gYXN5bmMgZm9yIExhbWJkYUV4cHJlc3Npb24gXSBbIEFycmF5RXhwcmVzc2lvbiBBcnJheUNvbXByZWhlbnNpb25FeHByZXNzaW9uIH0geyBEaWN0aW9uYXJ5RXhwcmVzc2lvbiBEaWN0aW9uYXJ5Q29tcHJlaGVuc2lvbkV4cHJlc3Npb24gU2V0RXhwcmVzc2lvbiBTZXRDb21wcmVoZW5zaW9uRXhwcmVzc2lvbiBDYWxsRXhwcmVzc2lvbiBBcmdMaXN0IEFzc2lnbk9wIE1lbWJlckV4cHJlc3Npb24gLiBQcm9wZXJ0eU5hbWUgTnVtYmVyIFN0cmluZyBGb3JtYXRTdHJpbmcgRm9ybWF0UmVwbGFjZW1lbnQgRm9ybWF0Q29udmVyc2lvbiBGb3JtYXRTcGVjIEZvcm1hdFJlcGxhY2VtZW50IEZvcm1hdFJlcGxhY2VtZW50IEZvcm1hdFJlcGxhY2VtZW50IEZvcm1hdFJlcGxhY2VtZW50IENvbnRpbnVlZFN0cmluZyBFbGxpcHNpcyBOb25lIEJvb2xlYW4gVHlwZURlZiBBc3NpZ25PcCBVcGRhdGVTdGF0ZW1lbnQgVXBkYXRlT3AgRXhwcmVzc2lvblN0YXRlbWVudCBEZWxldGVTdGF0ZW1lbnQgZGVsIFBhc3NTdGF0ZW1lbnQgcGFzcyBCcmVha1N0YXRlbWVudCBicmVhayBDb250aW51ZVN0YXRlbWVudCBjb250aW51ZSBSZXR1cm5TdGF0ZW1lbnQgcmV0dXJuIFlpZWxkU3RhdGVtZW50IFByaW50U3RhdGVtZW50IFJhaXNlU3RhdGVtZW50IHJhaXNlIEltcG9ydFN0YXRlbWVudCBpbXBvcnQgYXMgU2NvcGVTdGF0ZW1lbnQgZ2xvYmFsIG5vbmxvY2FsIEFzc2VydFN0YXRlbWVudCBhc3NlcnQgVHlwZURlZmluaXRpb24gdHlwZSBUeXBlUGFyYW1MaXN0IFR5cGVQYXJhbSBTdGF0ZW1lbnRHcm91cCA7IElmU3RhdGVtZW50IEJvZHkgZWxpZiBXaGlsZVN0YXRlbWVudCB3aGlsZSBGb3JTdGF0ZW1lbnQgVHJ5U3RhdGVtZW50IHRyeSBleGNlcHQgZmluYWxseSBXaXRoU3RhdGVtZW50IHdpdGggRnVuY3Rpb25EZWZpbml0aW9uIGRlZiBQYXJhbUxpc3QgQXNzaWduT3AgVHlwZURlZiBDbGFzc0RlZmluaXRpb24gY2xhc3MgRGVjb3JhdGVkU3RhdGVtZW50IERlY29yYXRvciBBdCBNYXRjaFN0YXRlbWVudCBtYXRjaCBNYXRjaEJvZHkgTWF0Y2hDbGF1c2UgY2FzZSBDYXB0dXJlUGF0dGVybiBMaXRlcmFsUGF0dGVybiBBcml0aE9wIEFyaXRoT3AgQXNQYXR0ZXJuIE9yUGF0dGVybiBMb2dpY09wIEF0dHJpYnV0ZVBhdHRlcm4gU2VxdWVuY2VQYXR0ZXJuIE1hcHBpbmdQYXR0ZXJuIFN0YXJQYXR0ZXJuIENsYXNzUGF0dGVybiBQYXR0ZXJuQXJnTGlzdCBLZXl3b3JkUGF0dGVybiBLZXl3b3JkUGF0dGVybiBHdWFyZFwiLFxuICBtYXhUZXJtOiAyODMsXG4gIGNvbnRleHQ6IHRyYWNrSW5kZW50LFxuICBub2RlUHJvcHM6IFtcbiAgICBbXCJncm91cFwiLCAtMTUsOCw4OCw5MCw5MSw5Myw5NSw5Nyw5OSwxMDEsMTAyLDEwMywxMDUsMTA4LDExMSwxMTMsXCJTdGF0ZW1lbnQgU3RhdGVtZW50XCIsLTIyLDEwLDIwLDIzLDI3LDQyLDUxLDUyLDU4LDU5LDYyLDYzLDY0LDY1LDY2LDY5LDcyLDczLDc0LDgyLDgzLDg0LDg1LFwiRXhwcmVzc2lvblwiLC0xMCwxMTcsMTE5LDEyMiwxMjQsMTI1LDEyOSwxMzEsMTM2LDEzOCwxNDEsXCJTdGF0ZW1lbnRcIiwtOSwxNDYsMTQ3LDE1MCwxNTEsMTUzLDE1NCwxNTUsMTU2LDE1NyxcIlBhdHRlcm5cIl0sXG4gICAgW1wib3BlbmVkQnlcIiwgMjUsXCIoXCIsNTYsXCJbXCIsNjAsXCJ7XCJdLFxuICAgIFtcImNsb3NlZEJ5XCIsIDI2LFwiKVwiLDU3LFwiXVwiLDYxLFwifVwiXVxuICBdLFxuICBwcm9wU291cmNlczogW3B5dGhvbkhpZ2hsaWdodGluZ10sXG4gIHNraXBwZWROb2RlczogWzAsNl0sXG4gIHJlcGVhdE5vZGVDb3VudDogMzgsXG4gIHRva2VuRGF0YTogXCIlLVcjc1IhYE9YJVRYWT18WVslVFtdPXxdcCVUcHE9fHFyQF9yc0RPc3QhK3x0dSVUdXYhTm52dyMhfHd4IyRXeHkjOlV5eiM7WXp7Izxee3wjPnh8fSNAU30hTyNBVyFPIVAjQ2khUCFRI05fIVEhUiQheSFSIVskJnchWyFdJDFlIV0hXiQzcyFeIV8kNHchXyFgJDdjIWAhYSQ4bSFhIWIlVCFiIWMkO1UhYyFkJDxiIWQhZSQ+VyFlIWgkPGIhaCFpJEhbIWkhdCQ8YiF0IXUlI3IhdSF3JDxiIXcheCRGbCF4IX0kPGIhfSNPJSV6I08jUD9kI1AjUSUnTyNRI1IlKFMjUiNTJDxiI1MjVCVUI1QjVSQ8YiNVI1YkPlcjViNZJDxiI1kjWiRIWyNaI2YkPGIjZiNnJSNyI2cjaSQ8YiNpI2okRmwjaiNvJDxiI28jcCUpXiNwI3ElKlMjcSNyJSteI3IjcyUsUyNzJGclVCRnOydTJDxiOydTOz1gJD5RPCVsTyQ8YiFuJV5dJnIhYiZqUyZtV09yJVRycyZWc3clVHd4L1h4I08lVCNPI1A3byNQI28lVCNvI3A4XiNwI3ElVCNxI3I4XiNyOydTJVQ7J1M7PWA9djwlbE8lVCFuJl5dJnIhYiZqU09yJVRycydWc3clVHd4L1h4I08lVCNPI1A3byNQI28lVCNvI3A4XiNwI3ElVCNxI3I4XiNyOydTJVQ7J1M7PWA9djwlbE8lVCFuJ15dJnIhYiZqU09yJVRycyhWc3clVHd4L1h4I08lVCNPI1A3byNQI28lVCNvI3A4XiNwI3ElVCNxI3I4XiNyOydTJVQ7J1M7PWA9djwlbE8lVCFmKF5aJnIhYiZqU093KFZ3eClQeCNPKFYjTyNQK1ojUCNvKFYjbyNwK3gjcCNxKFYjcSNyK3gjcjsnUyhWOydTOz1gL1I8JWxPKFYhZilVWiZyIWJPdyhWd3gpd3gjTyhWI08jUCtaI1AjbyhWI28jcCt4I3AjcShWI3Ejcit4I3I7J1MoVjsnUzs9YC9SPCVsTyhWIWYpfFomciFiT3coVnd4Km94I08oViNPI1ArWiNQI28oViNvI3AreCNwI3EoViNxI3IreCNyOydTKFY7J1M7PWAvUjwlbE8oViFiKnRUJnIhYk8jbypvI3AjcSpvI3I7J1MqbzsnUzs9YCtUPCVsTypvIWIrV1A7PWA8JWwqbyFmK2BXJnIhYk8jbyhWI28jcCt4I3AjcShWI3Ejcit4I3I7J1MoVjsnUzs9YC5kOz1gPCVsK3g8JWxPKFZTK31WJmpTT3creHd4LGR4I08reCNPI1AtYyNQOydTK3g7J1M7PWAuXjwlbE8reFMsZ1ZPdyt4d3gsfHgjTyt4I08jUC1jI1A7J1MreDsnUzs9YC5ePCVsTyt4Uy1QVU93K3h4I08reCNPI1AtYyNQOydTK3g7J1M7PWAuXjwlbE8reFMtZlJPOydTK3g7J1M7PWAtbzs9YE8reFMtdFcmalNPdyt4d3gsZHgjTyt4I08jUC1jI1A7J1MreDsnUzs9YC5eOz1gPCVsK3g8JWxPK3hTLmFQOz1gPCVsK3ghZi5pVyZqU093K3h3eCxkeCNPK3gjTyNQLWMjUDsnUyt4OydTOz1gLl47PWA8JWwoVjwlbE8reCFmL1VQOz1gPCVsKFYhbi9gXSZyIWImbVdPciVUcnMmVnN3JVR3eDBYeCNPJVQjTyNQN28jUCNvJVQjbyNwOF4jcCNxJVQjcSNyOF4jcjsnUyVUOydTOz1gPXY8JWxPJVQhbjBgXSZyIWImbVdPciVUcnMmVnN3JVR3eDFYeCNPJVQjTyNQN28jUCNvJVQjbyNwOF4jcCNxJVQjcSNyOF4jcjsnUyVUOydTOz1gPXY8JWxPJVQhajFgWiZyIWImbVdPcjFYcnMyUnMjTzFYI08jUDNxI1AjbzFYI28jcDRgI3AjcTFYI3EjcjRgI3I7J1MxWDsnUzs9YDdpPCVsTzFYIWoyV1omciFiT3IxWHJzMnlzI08xWCNPI1AzcSNQI28xWCNvI3A0YCNwI3ExWCNxI3I0YCNyOydTMVg7J1M7PWA3aTwlbE8xWCFqM09aJnIhYk9yMVhycypvcyNPMVgjTyNQM3EjUCNvMVgjbyNwNGAjcCNxMVgjcSNyNGAjcjsnUzFYOydTOz1gN2k8JWxPMVghajN2VyZyIWJPI28xWCNvI3A0YCNwI3ExWCNxI3I0YCNyOydTMVg7J1M7PWA2ejs9YDwlbDRgPCVsTzFYVzRlViZtV09yNGByczR6cyNPNGAjTyNQNXkjUDsnUzRgOydTOz1gNnQ8JWxPNGBXNH1WT3I0YHJzNWRzI080YCNPI1A1eSNQOydTNGA7J1M7PWA2dDwlbE80YFc1Z1VPcjRgcyNPNGAjTyNQNXkjUDsnUzRgOydTOz1gNnQ8JWxPNGBXNXxSTzsnUzRgOydTOz1gNlY7PWBPNGBXNltXJm1XT3I0YHJzNHpzI080YCNPI1A1eSNQOydTNGA7J1M7PWA2dDs9YDwlbDRgPCVsTzRgVzZ3UDs9YDwlbDRgIWo3UFcmbVdPcjRgcnM0enMjTzRgI08jUDV5I1A7J1M0YDsnUzs9YDZ0Oz1gPCVsMVg8JWxPNGAhajdsUDs9YDwlbDFYIW43dFcmciFiTyNvJVQjbyNwOF4jcCNxJVQjcSNyOF4jcjsnUyVUOydTOz1gPVA7PWA8JWw4XjwlbE8lVFs4ZVgmalMmbVdPcjhecnM5UXN3OF53eDpkeCNPOF4jTyNQO3YjUDsnUzheOydTOz1gPHk8JWxPOF5bOVZYJmpTT3I4XnJzOXJzdzhed3g6ZHgjTzheI08jUDt2I1A7J1M4XjsnUzs9YDx5PCVsTzheWzl3WCZqU09yOF5ycyt4c3c4Xnd4OmR4I084XiNPI1A7diNQOydTOF47J1M7PWA8eTwlbE84Xls6aVgmbVdPcjhecnM5UXN3OF53eDtVeCNPOF4jTyNQO3YjUDsnUzheOydTOz1gPHk8JWxPOF5bO1pYJm1XT3I4XnJzOVFzdzhed3g0YHgjTzheI08jUDt2I1A7J1M4XjsnUzs9YDx5PCVsTzheWzt5Uk87J1M4XjsnUzs9YDxTOz1gTzheWzxaWSZqUyZtV09yOF5yczlRc3c4Xnd4OmR4I084XiNPI1A7diNQOydTOF47J1M7PWA8eTs9YDwlbDhePCVsTzheWzx8UDs9YDwlbDheIW49V1kmalMmbVdPcjhecnM5UXN3OF53eDpkeCNPOF4jTyNQO3YjUDsnUzheOydTOz1gPHk7PWA8JWwlVDwlbE84XiFuPXlQOz1gPCVsJVQjcz5YYyZyIWImalMmbVclcCFUT1glVFhZPXxZWyVUW109fF1wJVRwcT18cXIlVHJzJlZzdyVUd3gvWHgjTyVUI08jUD9kI1AjbyVUI28jcDheI3AjcSVUI3EjcjheI3I7J1MlVDsnUzs9YD12PCVsTyVUI3M/aVsmciFiT1klVFlaPXxaXSVUXV49fF4jbyVUI28jcDheI3AjcSVUI3EjcjheI3I7J1MlVDsnUzs9YD1QOz1gPCVsOF48JWxPJVQhcUBoZCZyIWImalMmbVdPciVUcnMmVnN3JVR3eC9YeCFfJVQhXyFgQXYhYCNPJVQjTyNQN28jUCNUJVQjVCNVQnojVSNmJVQjZiNnQnojZyNoQnojaCNvJVQjbyNwOF4jcCNxJVQjcSNyOF4jcjsnUyVUOydTOz1gPXY8JWxPJVQhcUJSXW9SJnIhYiZqUyZtV09yJVRycyZWc3clVHd4L1h4I08lVCNPI1A3byNQI28lVCNvI3A4XiNwI3ElVCNxI3I4XiNyOydTJVQ7J1M7PWA9djwlbE8lVCFxQ1ZdIW5SJnIhYiZqUyZtV09yJVRycyZWc3clVHd4L1h4I08lVCNPI1A3byNQI28lVCNvI3A4XiNwI3ElVCNxI3I4XiNyOydTJVQ7J1M7PWA9djwlbE8lVCNjRFhhJnIhYiZqUyZoc09ZRV5ZWiVUWl1FXl1eJVReckVecnMhKXxzd0Ved3hHcHgjT0VeI08jUCEhdSNQI29FXiNvI3AhI2QjcCNxRV4jcSNyISNkI3I7J1NFXjsnUzs9YCEpdjwlbE9FXiNjRWlhJnIhYiZqUyZtVyZoc09ZRV5ZWiVUWl1FXl1eJVReckVecnNGbnN3RV53eEdweCNPRV4jTyNQISF1I1Ajb0VeI28jcCEjZCNwI3FFXiNxI3IhI2QjcjsnU0VeOydTOz1gISl2PCVsT0VeI2NGd10mciFiJmpTJmhzT3IlVHJzJ1ZzdyVUd3gvWHgjTyVUI08jUDdvI1AjbyVUI28jcDheI3AjcSVUI3EjcjheI3I7J1MlVDsnUzs9YD12PCVsTyVUI2NHeWEmciFiJm1XJmhzT1lFXllaJVRaXUVeXV4lVF5yRV5yc0Zuc3dFXnd4SU94I09FXiNPI1AhIXUjUCNvRV4jbyNwISNkI3AjcUVeI3EjciEjZCNyOydTRV47J1M7PWAhKXY8JWxPRV4jY0lYYSZyIWImbVcmaHNPWUVeWVolVFpdRV5dXiVUXnJFXnJzRm5zd0Ved3hKXngjT0VeI08jUCEhdSNQI29FXiNvI3AhI2QjcCNxRV4jcSNyISNkI3I7J1NFXjsnUzs9YCEpdjwlbE9FXiNfSmdfJnIhYiZtVyZoc09ZSl5ZWjFYWl1KXl1eMVheckpecnNLZnMjT0peI08jUExgI1Ajb0peI28jcEx9I3AjcUpeI3Ejckx9I3I7J1NKXjsnUzs9YCEhbzwlbE9KXiNfS21aJnIhYiZoc09yMVhyczJ5cyNPMVgjTyNQM3EjUCNvMVgjbyNwNGAjcCNxMVgjcSNyNGAjcjsnUzFYOydTOz1gN2k8JWxPMVgjX0xlVyZyIWJPI29KXiNvI3BMfSNwI3FKXiNxI3JMfSNyOydTSl47J1M7PWAhIHI7PWA8JWxMfTwlbE9KXntNVVombVcmaHNPWUx9WVo0YFpdTH1dXjRgXnJMfXJzTXdzI09MfSNPI1BOYyNQOydTTH07J1M7PWAhIGw8JWxPTH17TXxWJmhzT3I0YHJzNWRzI080YCNPI1A1eSNQOydTNGA7J1M7PWA2dDwlbE80YHtOZlJPOydTTH07J1M7PWBObzs9YE9MfXtOdlsmbVcmaHNPWUx9WVo0YFpdTH1dXjRgXnJMfXJzTXdzI09MfSNPI1BOYyNQOydTTH07J1M7PWAhIGw7PWA8JWxMfTwlbE9MfXshIG9QOz1gPCVsTH0jXyEgeVsmbVcmaHNPWUx9WVo0YFpdTH1dXjRgXnJMfXJzTXdzI09MfSNPI1BOYyNQOydTTH07J1M7PWAhIGw7PWA8JWxKXjwlbE9MfSNfISFyUDs9YDwlbEpeI2MhIXpXJnIhYk8jb0VeI28jcCEjZCNwI3FFXiNxI3IhI2QjcjsnU0VeOydTOz1gIShxOz1gPCVsISNkPCVsT0VeIVAhI21dJmpTJm1XJmhzT1khI2RZWjheWl0hI2RdXjheXnIhI2RycyEkZnN3ISNkd3ghJVl4I08hI2QjTyNQISdZI1A7J1MhI2Q7J1M7PWAhKGs8JWxPISNkIVAhJG1YJmpTJmhzT3I4XnJzOXJzdzhed3g6ZHgjTzheI08jUDt2I1A7J1M4XjsnUzs9YDx5PCVsTzheIVAhJWFdJm1XJmhzT1khI2RZWjheWl0hI2RdXjheXnIhI2RycyEkZnN3ISNkd3ghJll4I08hI2QjTyNQISdZI1A7J1MhI2Q7J1M7PWAhKGs8JWxPISNkIVAhJmFdJm1XJmhzT1khI2RZWjheWl0hI2RdXjheXnIhI2RycyEkZnN3ISNkd3hMfXgjTyEjZCNPI1AhJ1kjUDsnUyEjZDsnUzs9YCEoazwlbE8hI2QhUCEnXVJPOydTISNkOydTOz1gISdmOz1gTyEjZCFQISdvXiZqUyZtVyZoc09ZISNkWVo4XlpdISNkXV44Xl5yISNkcnMhJGZzdyEjZHd4ISVZeCNPISNkI08jUCEnWSNQOydTISNkOydTOz1gIShrOz1gPCVsISNkPCVsTyEjZCFQIShuUDs9YDwlbCEjZCNjISh6XiZqUyZtVyZoc09ZISNkWVo4XlpdISNkXV44Xl5yISNkcnMhJGZzdyEjZHd4ISVZeCNPISNkI08jUCEnWSNQOydTISNkOydTOz1gIShrOz1gPCVsRV48JWxPISNkI2MhKXlQOz1gPCVsRV4jYyEqVl0mciFiJmpTJmhzT3IlVHJzIStPc3clVHd4L1h4I08lVCNPI1A3byNQI28lVCNvI3A4XiNwI3ElVCNxI3I4XiNyOydTJVQ7J1M7PWA9djwlbE8lVCNjIStaWiZuVyZyIWImalMmbHNPdyhWd3gpUHgjTyhWI08jUCtaI1AjbyhWI28jcCt4I3AjcShWI3Ejcit4I3I7J1MoVjsnUzs9YC9SPCVsTyhWI3MhLFhhVSFUJnIhYiZqUyZtV09ZISt8WVolVFpdISt8XV4lVF5yISt8cnMhLV5zdyErfHd4ITpoeCNPISt8I08jUCFGVyNQI28hK3wjbyNwIUdUI3AjcSErfCNxI3IhR1QjcjsnUyErfDsnUzs9YCFOaDwlbE8hK3wjcyEtZ2FVIVQmciFiJmpTT1khK3xZWiVUWl0hK3xdXiVUXnIhK3xycyEubHN3ISt8d3ghOmh4I08hK3wjTyNQIUZXI1AjbyErfCNvI3AhR1QjcCNxISt8I3EjciFHVCNyOydTISt8OydTOz1gIU5oPCVsTyErfCNzIS51YVUhVCZyIWImalNPWSErfFlaJVRaXSErfF1eJVReciErfHJzIS96c3chK3x3eCE6aHgjTyErfCNPI1AhRlcjUCNvISt8I28jcCFHVCNwI3EhK3wjcSNyIUdUI3I7J1MhK3w7J1M7PWAhTmg8JWxPISt8I2shMFRfVSFUJnIhYiZqU09ZIS96WVooVlpdIS96XV4oVl53IS96d3ghMVN4I08hL3ojTyNQITR6I1AjbyEveiNvI3AhNXcjcCNxIS96I3EjciE1dyNyOydTIS96OydTOz1gITpiPCVsTyEveiNrITFaX1UhVCZyIWJPWSEvellaKFZaXSEvel1eKFZedyEvend4ITJZeCNPIS96I08jUCE0eiNQI28hL3ojbyNwITV3I3AjcSEveiNxI3IhNXcjcjsnUyEvejsnUzs9YCE6YjwlbE8hL3ojayEyYV9VIVQmciFiT1khL3pZWihWWl0hL3pdXihWXnchL3p3eCEzYHgjTyEveiNPI1AhNHojUCNvIS96I28jcCE1dyNwI3EhL3ojcSNyITV3I3I7J1MhL3o7J1M7PWAhOmI8JWxPIS96I2chM2daVSFUJnIhYk9ZITNgWVoqb1pdITNgXV4qb14jbyEzYCNvI3AhNFkjcCNxITNgI3EjciE0WSNyOydTITNgOydTOz1gITR0PCVsTyEzYCFUITRfVFUhVE9ZITRZWl0hNFleOydTITRZOydTOz1gITRuPCVsTyE0WSFUITRxUDs9YDwlbCE0WSNnITR3UDs9YDwlbCEzYCNrITVSW1UhVCZyIWJPWSEvellaKFZaXSEvel1eKFZeI28hL3ojbyNwITV3I3AjcSEveiNxI3IhNXcjcjsnUyEvejsnUzs9YCE5czs9YDwlbCt4PCVsTyEveiFYITZPWlUhVCZqU09ZITV3WVoreFpdITV3XV4reF53ITV3d3ghNnF4I08hNXcjTyNQIThhI1A7J1MhNXc7J1M7PWAhOW08JWxPITV3IVghNnZaVSFUT1khNXdZWit4Wl0hNXddXit4XnchNXd3eCE3aXgjTyE1dyNPI1AhOGEjUDsnUyE1dzsnUzs9YCE5bTwlbE8hNXchWCE3blpVIVRPWSE1d1laK3haXSE1d11eK3hedyE1d3d4ITRZeCNPITV3I08jUCE4YSNQOydTITV3OydTOz1gITltPCVsTyE1dyFYIThmV1UhVE9ZITV3WVoreFpdITV3XV4reF47J1MhNXc7J1M7PWAhOU87PWA8JWwreDwlbE8hNXchWCE5VFcmalNPdyt4d3gsZHgjTyt4I08jUC1jI1A7J1MreDsnUzs9YC5eOz1gPCVsITV3PCVsTyt4IVghOXBQOz1gPCVsITV3I2shOXhXJmpTT3creHd4LGR4I08reCNPI1AtYyNQOydTK3g7J1M7PWAuXjs9YDwlbCEvejwlbE8reCNrITplUDs9YDwlbCEveiNzITpxYVUhVCZyIWImbVdPWSErfFlaJVRaXSErfF1eJVReciErfHJzIS1ec3chK3x3eCE7dngjTyErfCNPI1AhRlcjUCNvISt8I28jcCFHVCNwI3EhK3wjcSNyIUdUI3I7J1MhK3w7J1M7PWAhTmg8JWxPISt8I3MhPFBhVSFUJnIhYiZtV09ZISt8WVolVFpdISt8XV4lVF5yISt8cnMhLV5zdyErfHd4IT1VeCNPISt8I08jUCFGVyNQI28hK3wjbyNwIUdUI3AjcSErfCNxI3IhR1QjcjsnUyErfDsnUzs9YCFOaDwlbE8hK3wjbyE9X19VIVQmciFiJm1XT1khPVVZWjFYWl0hPVVdXjFYXnIhPVVycyE+XnMjTyE9VSNPI1AhQGojUCNvIT1VI28jcCFBZyNwI3EhPVUjcSNyIUFnI3I7J1MhPVU7J1M7PWAhRlE8JWxPIT1VI28hPmVfVSFUJnIhYk9ZIT1VWVoxWFpdIT1VXV4xWF5yIT1VcnMhP2RzI08hPVUjTyNQIUBqI1AjbyE9VSNvI3AhQWcjcCNxIT1VI3EjciFBZyNyOydTIT1VOydTOz1gIUZRPCVsTyE9VSNvIT9rX1UhVCZyIWJPWSE9VVlaMVhaXSE9VV1eMVheciE9VXJzITNgcyNPIT1VI08jUCFAaiNQI28hPVUjbyNwIUFnI3AjcSE9VSNxI3IhQWcjcjsnUyE9VTsnUzs9YCFGUTwlbE8hPVUjbyFAcVtVIVQmciFiT1khPVVZWjFYWl0hPVVdXjFYXiNvIT1VI28jcCFBZyNwI3EhPVUjcSNyIUFnI3I7J1MhPVU7J1M7PWAhRWM7PWA8JWw0YDwlbE8hPVUhXSFBblpVIVQmbVdPWSFBZ1laNGBaXSFBZ11eNGBeciFBZ3JzIUJhcyNPIUFnI08jUCFEUCNQOydTIUFnOydTOz1gIUVdPCVsTyFBZyFdIUJmWlUhVE9ZIUFnWVo0YFpdIUFnXV40YF5yIUFncnMhQ1hzI08hQWcjTyNQIURQI1A7J1MhQWc7J1M7PWAhRV08JWxPIUFnIV0hQ15aVSFUT1khQWdZWjRgWl0hQWddXjRgXnIhQWdycyE0WXMjTyFBZyNPI1AhRFAjUDsnUyFBZzsnUzs9YCFFXTwlbE8hQWchXSFEVVdVIVRPWSFBZ1laNGBaXSFBZ11eNGBeOydTIUFnOydTOz1gIURuOz1gPCVsNGA8JWxPIUFnIV0hRHNXJm1XT3I0YHJzNHpzI080YCNPI1A1eSNQOydTNGA7J1M7PWA2dDs9YDwlbCFBZzwlbE80YCFdIUVgUDs9YDwlbCFBZyNvIUVoVyZtV09yNGByczR6cyNPNGAjTyNQNXkjUDsnUzRgOydTOz1gNnQ7PWA8JWwhPVU8JWxPNGAjbyFGVFA7PWA8JWwhPVUjcyFGX1tVIVQmciFiT1khK3xZWiVUWl0hK3xdXiVUXiNvISt8I28jcCFHVCNwI3EhK3wjcSNyIUdUI3I7J1MhK3w7J1M7PWAhTXE7PWA8JWw4XjwlbE8hK3whYSFHXl1VIVQmalMmbVdPWSFHVFlaOF5aXSFHVF1eOF5eciFHVHJzIUhWc3chR1R3eCFKVngjTyFHVCNPI1AhTFYjUDsnUyFHVDsnUzs9YCFNazwlbE8hR1QhYSFIXl1VIVQmalNPWSFHVFlaOF5aXSFHVF1eOF5eciFHVHJzIUlWc3chR1R3eCFKVngjTyFHVCNPI1AhTFYjUDsnUyFHVDsnUzs9YCFNazwlbE8hR1QhYSFJXl1VIVQmalNPWSFHVFlaOF5aXSFHVF1eOF5eciFHVHJzITV3c3chR1R3eCFKVngjTyFHVCNPI1AhTFYjUDsnUyFHVDsnUzs9YCFNazwlbE8hR1QhYSFKXl1VIVQmbVdPWSFHVFlaOF5aXSFHVF1eOF5eciFHVHJzIUhWc3chR1R3eCFLVngjTyFHVCNPI1AhTFYjUDsnUyFHVDsnUzs9YCFNazwlbE8hR1QhYSFLXl1VIVQmbVdPWSFHVFlaOF5aXSFHVF1eOF5eciFHVHJzIUhWc3chR1R3eCFBZ3gjTyFHVCNPI1AhTFYjUDsnUyFHVDsnUzs9YCFNazwlbE8hR1QhYSFMW1dVIVRPWSFHVFlaOF5aXSFHVF1eOF5eOydTIUdUOydTOz1gIUx0Oz1gPCVsOF48JWxPIUdUIWEhTHtZJmpTJm1XT3I4XnJzOVFzdzhed3g6ZHgjTzheI08jUDt2I1A7J1M4XjsnUzs9YDx5Oz1gPCVsIUdUPCVsTzheIWEhTW5QOz1gPCVsIUdUI3MhTXhZJmpTJm1XT3I4XnJzOVFzdzhed3g6ZHgjTzheI08jUDt2I1A7J1M4XjsnUzs9YDx5Oz1gPCVsISt8PCVsTzheI3MhTmtQOz1gPCVsISt8I2IhTnlfJlBRJnIhYiZqUyZtV09yJVRycyZWc3clVHd4L1h4IV8lVCFfIWAjIHghYCNPJVQjTyNQN28jUCNvJVQjbyNwOF4jcCNxJVQjcSNyOF4jcjsnUyVUOydTOz1gPXY8JWxPJVQjYiMhVF0he3ImciFiJmpTJm1XT3IlVHJzJlZzdyVUd3gvWHgjTyVUI08jUDdvI1AjbyVUI28jcDheI3AjcSVUI3EjcjheI3I7J1MlVDsnUzs9YD12PCVsTyVUI2IjI1hfJXlRJnIhYiZqUyZtV09yJVRycyZWc3clVHd4L1h4IV8lVCFfIWAjIHghYCNPJVQjTyNQN28jUCNvJVQjbyNwOF4jcCNxJVQjcSNyOF4jcjsnUyVUOydTOz1gPXY8JWxPJVQjYyMkYWEmciFiJm1XJmhzT1kjJWZZWiVUWl0jJWZdXiVUXnIjJWZycyMmdnN3IyVmd3gjOFV4I08jJWYjTyNQIzB9I1AjbyMlZiNvI3AjMWwjcCNxIyVmI3EjciMxbCNyOydTIyVmOydTOz1gIzhPPCVsTyMlZiNjIyVxYSZyIWImalMmbVcmaHNPWSMlZllaJVRaXSMlZl1eJVReciMlZnJzIyZ2c3cjJWZ3eCMve3gjTyMlZiNPI1AjMH0jUCNvIyVmI28jcCMxbCNwI3EjJWYjcSNyIzFsI3I7J1MjJWY7J1M7PWAjOE88JWxPIyVmI2MjJ1BhJnIhYiZqUyZoc09ZIyVmWVolVFpdIyVmXV4lVF5yIyVmcnMjKFVzdyMlZnd4Iy97eCNPIyVmI08jUCMwfSNQI28jJWYjbyNwIzFsI3AjcSMlZiNxI3IjMWwjcjsnUyMlZjsnUzs9YCM4TzwlbE8jJWYjYyMoX2EmciFiJmpTJmhzT1kjJWZZWiVUWl0jJWZdXiVUXnIjJWZycyMpZHN3IyVmd3gjL3t4I08jJWYjTyNQIzB9I1AjbyMlZiNvI3AjMWwjcCNxIyVmI3EjciMxbCNyOydTIyVmOydTOz1gIzhPPCVsTyMlZiNaIyltXyZyIWImalMmaHNPWSMpZFlaKFZaXSMpZF1eKFZedyMpZHd4IypseCNPIylkI08jUCMrZiNQI28jKWQjbyNwIyxUI3AjcSMpZCNxI3IjLFQjcjsnUyMpZDsnUzs9YCMvdTwlbE8jKWQjWiMqc1omciFiJmhzT3coVnd4KXd4I08oViNPI1ArWiNQI28oViNvI3AreCNwI3EoViNxI3IreCNyOydTKFY7J1M7PWAvUjwlbE8oViNaIytrVyZyIWJPI28jKWQjbyNwIyxUI3AjcSMpZCNxI3IjLFQjcjsnUyMpZDsnUzs9YCMueDs9YDwlbCMsVDwlbE8jKWR3IyxbWiZqUyZoc09ZIyxUWVoreFpdIyxUXV4reF53IyxUd3gjLH14I08jLFQjTyNQIy1pI1A7J1MjLFQ7J1M7PWAjLnI8JWxPIyxUdyMtU1YmaHNPdyt4d3gsfHgjTyt4I08jUC1jI1A7J1MreDsnUzs9YC5ePCVsTyt4dyMtbFJPOydTIyxUOydTOz1gIy11Oz1gTyMsVHcjLXxbJmpTJmhzT1kjLFRZWit4Wl0jLFRdXit4XncjLFR3eCMsfXgjTyMsVCNPI1AjLWkjUDsnUyMsVDsnUzs9YCMucjs9YDwlbCMsVDwlbE8jLFR3Iy51UDs9YDwlbCMsVCNaIy9QWyZqUyZoc09ZIyxUWVoreFpdIyxUXV4reF53IyxUd3gjLH14I08jLFQjTyNQIy1pI1A7J1MjLFQ7J1M7PWAjLnI7PWA8JWwjKWQ8JWxPIyxUI1ojL3hQOz1gPCVsIylkI2MjMFVdJnIhYiZtVyZoc09yJVRycyZWc3clVHd4MFh4I08lVCNPI1A3byNQI28lVCNvI3A4XiNwI3ElVCNxI3I4XiNyOydTJVQ7J1M7PWA9djwlbE8lVCNjIzFTVyZyIWJPI28jJWYjbyNwIzFsI3AjcSMlZiNxI3IjMWwjcjsnUyMlZjsnUzs9YCM2eTs9YDwlbCMxbDwlbE8jJWYhUCMxdV0malMmbVcmaHNPWSMxbFlaOF5aXSMxbF1eOF5eciMxbHJzIzJuc3cjMWx3eCM0bngjTyMxbCNPI1AjNWIjUDsnUyMxbDsnUzs9YCM2czwlbE8jMWwhUCMydV0malMmaHNPWSMxbFlaOF5aXSMxbF1eOF5eciMxbHJzIzNuc3cjMWx3eCM0bngjTyMxbCNPI1AjNWIjUDsnUyMxbDsnUzs9YCM2czwlbE8jMWwhUCMzdV0malMmaHNPWSMxbFlaOF5aXSMxbF1eOF5eciMxbHJzIyxUc3cjMWx3eCM0bngjTyMxbCNPI1AjNWIjUDsnUyMxbDsnUzs9YCM2czwlbE8jMWwhUCM0dVgmbVcmaHNPcjhecnM5UXN3OF53eDtVeCNPOF4jTyNQO3YjUDsnUzheOydTOz1gPHk8JWxPOF4hUCM1ZVJPOydTIzFsOydTOz1gIzVuOz1gTyMxbCFQIzV3XiZqUyZtVyZoc09ZIzFsWVo4XlpdIzFsXV44Xl5yIzFscnMjMm5zdyMxbHd4IzRueCNPIzFsI08jUCM1YiNQOydTIzFsOydTOz1gIzZzOz1gPCVsIzFsPCVsTyMxbCFQIzZ2UDs9YDwlbCMxbCNjIzdTXiZqUyZtVyZoc09ZIzFsWVo4XlpdIzFsXV44Xl5yIzFscnMjMm5zdyMxbHd4IzRueCNPIzFsI08jUCM1YiNQOydTIzFsOydTOz1gIzZzOz1gPCVsIyVmPCVsTyMxbCNjIzhSUDs9YDwlbCMlZiNjIzhfXSZyIWImbVcmaHNPciVUcnMmVnN3JVR3eCM5V3gjTyVUI08jUDdvI1AjbyVUI28jcDheI3AjcSVUI3EjcjheI3I7J1MlVDsnUzs9YD12PCVsTyVUI2MjOWNaJmtTJnIhYiZtVyZpc09yMVhyczJScyNPMVgjTyNQM3EjUCNvMVgjbyNwNGAjcCNxMVgjcSNyNGAjcjsnUzFYOydTOz1gN2k8JWxPMVgjYyM6YV1qcyZyIWImalMmbVdPciVUcnMmVnN3JVR3eC9YeCNPJVQjTyNQN28jUCNvJVQjbyNwOF4jcCNxJVQjcSNyOF4jcjsnUyVUOydTOz1gPXY8JWxPJVQhcSM7ZV1pUiZyIWImalMmbVdPciVUcnMmVnN3JVR3eC9YeCNPJVQjTyNQN28jUCNvJVQjbyNwOF4jcCNxJVQjcSNyOF4jcjsnUyVUOydTOz1gPXY8JWxPJVQjYyM8aWFYcyZyIWImalMmbVdPciVUcnMmVnN3JVR3eC9YeHolVHp7Iz1ueyFfJVQhXyFgIyB4IWAjTyVUI08jUDdvI1AjbyVUI28jcDheI3AjcSVUI3EjcjheI3I7J1MlVDsnUzs9YD12PCVsTyVUI2MjPXlfY1ImciFiJmpTJm1XT3IlVHJzJlZzdyVUd3gvWHghXyVUIV8hYCMgeCFgI08lVCNPI1A3byNQI28lVCNvI3A4XiNwI3ElVCNxI3I4XiNyOydTJVQ7J1M7PWA9djwlbE8lVCNjIz9UXyV8cyZyIWImalMmbVdPciVUcnMmVnN3JVR3eC9YeCFfJVQhXyFgIyB4IWAjTyVUI08jUDdvI1AjbyVUI28jcDheI3AjcSVUI3EjcjheI3I7J1MlVDsnUzs9YD12PCVsTyVUIXEjQF9dfFImciFiJmpTJm1XT3IlVHJzJlZzdyVUd3gvWHgjTyVUI08jUDdvI1AjbyVUI28jcDheI3AjcSVUI3EjcjheI3I7J1MlVDsnUzs9YD12PCVsTyVUI3MjQWNgJX1zJnIhYiZqUyZtV09yJVRycyZWc3clVHd4L1h4IV8lVCFfIWAjIHghYCFhI0JlIWEjTyVUI08jUDdvI1AjbyVUI28jcDheI3AjcSVUI3EjcjheI3I7J1MlVDsnUzs9YD12PCVsTyVUI08jQnBdJ1JgJnIhYiZqUyZtV09yJVRycyZWc3clVHd4L1h4I08lVCNPI1A3byNQI28lVCNvI3A4XiNwI3ElVCNxI3I4XiNyOydTJVQ7J1M7PWA9djwlbE8lVCNjI0N0YSFoUSZyIWImalMmbVdPciVUcnMmVnN3JVR3eC9YeCFPJVQhTyFQI0R5IVAhUSVUIVEhWyNHViFbI08lVCNPI1A3byNQI28lVCNvI3A4XiNwI3ElVCNxI3I4XiNyOydTJVQ7J1M7PWA9djwlbE8lVCNjI0VTXyZyIWImalMmbVdPciVUcnMmVnN3JVR3eC9YeCFPJVQhTyFQI0ZSIVAjTyVUI08jUDdvI1AjbyVUI28jcDheI3AjcSVUI3EjcjheI3I7J1MlVDsnUzs9YD12PCVsTyVUI2MjRl5dIXVzJnIhYiZqUyZtV09yJVRycyZWc3clVHd4L1h4I08lVCNPI1A3byNQI28lVCNvI3A4XiNwI3ElVCNxI3I4XiNyOydTJVQ7J1M7PWA9djwlbE8lVCNhI0diaSFqcSZyIWImalMmbVdPciVUcnMmVnN3JVR3eC9YeCFRJVQhUSFbI0dWIVshZyVUIWchaCNJUCFoIWwlVCFsIW0jTVohbSNPJVQjTyNQN28jUCNSJVQjUiNTI0dWI1MjWCVUI1gjWSNJUCNZI14lVCNeI18jTVojXyNvJVQjbyNwOF4jcCNxJVQjcSNyOF4jcjsnUyVUOydTOz1gPXY8JWxPJVQjYSNJWWMmciFiJmpTJm1XT3IlVHJzJlZzdyVUd3gvWHh7JVR7fCNKZXx9JVR9IU8jSmUhTyFRJVQhUSFbI0ttIVsjTyVUI08jUDdvI1AjbyVUI28jcDheI3AjcSVUI3EjcjheI3I7J1MlVDsnUzs9YD12PCVsTyVUI2EjSm5fJnIhYiZqUyZtV09yJVRycyZWc3clVHd4L1h4IVElVCFRIVsjS20hWyNPJVQjTyNQN28jUCNvJVQjbyNwOF4jcCNxJVQjcSNyOF4jcjsnUyVUOydTOz1gPXY8JWxPJVQjYSNLeGUhanEmciFiJmpTJm1XT3IlVHJzJlZzdyVUd3gvWHghUSVUIVEhWyNLbSFbIWwlVCFsIW0jTVohbSNPJVQjTyNQN28jUCNSJVQjUiNTI0ttI1MjXiVUI14jXyNNWiNfI28lVCNvI3A4XiNwI3ElVCNxI3I4XiNyOydTJVQ7J1M7PWA9djwlbE8lVCNhI01mXSFqcSZyIWImalMmbVdPciVUcnMmVnN3JVR3eC9YeCNPJVQjTyNQN28jUCNvJVQjbyNwOF4jcCNxJVQjcSNyOF4jcjsnUyVUOydTOz1gPXY8JWxPJVQjYyNOamEmT1ImciFiJmpTJm1XT3IlVHJzJlZzdyVUd3gvWHghUCVUIVAhUSQgbyFRIV8lVCFfIWAjIHghYCNPJVQjTyNQN28jUCNvJVQjbyNwOF4jcCNxJVQjcSNyOF4jcjsnUyVUOydTOz1gPXY8JWxPJVQjYiQgel8mUVEmciFiJmpTJm1XT3IlVHJzJlZzdyVUd3gvWHghXyVUIV8hYCMgeCFgI08lVCNPI1A3byNQI28lVCNvI3A4XiNwI3ElVCNxI3I4XiNyOydTJVQ7J1M7PWA9djwlbE8lVCNhJCNVdyFqcSZyIWImalMmbVdPciVUcnMmVnN3JVR3eC9YeCFPJVQhTyFQJCVvIVAhUSVUIVEhWyQmdyFbIWQlVCFkIWUkKHchZSFnJVQhZyFoI0lQIWghbCVUIWwhbSNNWiFtIXElVCFxIXIkK20hciF6JVQheiF7JC5dIXsjTyVUI08jUDdvI1AjUiVUI1IjUyQmdyNTI1UlVCNVI1YkKHcjViNYJVQjWCNZI0lQI1kjXiVUI14jXyNNWiNfI2MlVCNjI2QkK20jZCNsJVQjbCNtJC5dI20jbyVUI28jcDheI3AjcSVUI3EjcjheI3I7J1MlVDsnUzs9YD12PCVsTyVUI2EkJXhfJnIhYiZqUyZtV09yJVRycyZWc3clVHd4L1h4IVElVCFRIVsjR1YhWyNPJVQjTyNQN28jUCNvJVQjbyNwOF4jcCNxJVQjcSNyOF4jcjsnUyVUOydTOz1gPXY8JWxPJVQjYSQnU2shanEmciFiJmpTJm1XT3IlVHJzJlZzdyVUd3gvWHghTyVUIU8hUCQlbyFQIVElVCFRIVskJnchWyFnJVQhZyFoI0lQIWghbCVUIWwhbSNNWiFtI08lVCNPI1A3byNQI1IlVCNSI1MkJncjUyNYJVQjWCNZI0lQI1kjXiVUI14jXyNNWiNfI28lVCNvI3A4XiNwI3ElVCNxI3I4XiNyOydTJVQ7J1M7PWA9djwlbE8lVCNhJClRYiZyIWImalMmbVdPciVUcnMmVnN3JVR3eC9YeCFRJVQhUSFSJCpZIVIhUyQqWSFTI08lVCNPI1A3byNQI1IlVCNSI1MkKlkjUyNvJVQjbyNwOF4jcCNxJVQjcSNyOF4jcjsnUyVUOydTOz1gPXY8JWxPJVQjYSQqZWIhanEmciFiJmpTJm1XT3IlVHJzJlZzdyVUd3gvWHghUSVUIVEhUiQqWSFSIVMkKlkhUyNPJVQjTyNQN28jUCNSJVQjUiNTJCpZI1MjbyVUI28jcDheI3AjcSVUI3EjcjheI3I7J1MlVDsnUzs9YD12PCVsTyVUI2EkK3ZhJnIhYiZqUyZtV09yJVRycyZWc3clVHd4L1h4IVElVCFRIVkkLHshWSNPJVQjTyNQN28jUCNSJVQjUiNTJCx7I1MjbyVUI28jcDheI3AjcSVUI3EjcjheI3I7J1MlVDsnUzs9YD12PCVsTyVUI2EkLVdhIWpxJnIhYiZqUyZtV09yJVRycyZWc3clVHd4L1h4IVElVCFRIVkkLHshWSNPJVQjTyNQN28jUCNSJVQjUiNTJCx7I1MjbyVUI28jcDheI3AjcSVUI3EjcjheI3I7J1MlVDsnUzs9YD12PCVsTyVUI2EkLmZlJnIhYiZqUyZtV09yJVRycyZWc3clVHd4L1h4IVElVCFRIVskL3chWyFjJVQhYyFpJC93IWkjTyVUI08jUDdvI1AjUiVUI1IjUyQvdyNTI1QlVCNUI1okL3cjWiNvJVQjbyNwOF4jcCNxJVQjcSNyOF4jcjsnUyVUOydTOz1gPXY8JWxPJVQjYSQwU2UhanEmciFiJmpTJm1XT3IlVHJzJlZzdyVUd3gvWHghUSVUIVEhWyQvdyFbIWMlVCFjIWkkL3chaSNPJVQjTyNQN28jUCNSJVQjUiNTJC93I1MjVCVUI1QjWiQvdyNaI28lVCNvI3A4XiNwI3ElVCNxI3I4XiNyOydTJVQ7J1M7PWA9djwlbE8lVCNzJDFwX30hVCZyIWImalMmbVdPciVUcnMmVnN3JVR3eC9YeCFfJVQhXyFgJDJvIWAjTyVUI08jUDdvI1AjbyVUI28jcDheI3AjcSVUI3EjcjheI3I7J1MlVDsnUzs9YD12PCVsTyVUIXEkMnpdJllSJnIhYiZqUyZtV09yJVRycyZWc3clVHd4L1h4I08lVCNPI1A3byNQI28lVCNvI3A4XiNwI3ElVCNxI3I4XiNyOydTJVQ7J1M7PWA9djwlbE8lVCNjJDRPXSNqcyZyIWImalMmbVdPciVUcnMmVnN3JVR3eC9YeCNPJVQjTyNQN28jUCNvJVQjbyNwOF4jcCNxJVQjcSNyOF4jcjsnUyVUOydTOz1gPXY8JWxPJVQjYyQ1U2FvUiZyIWImalMmbVdPciVUcnMmVnN3JVR3eC9YeCFeJVQhXiFfJDZYIV8hYEF2IWAhYUF2IWEjTyVUI08jUDdvI1AjbyVUI28jcDheI3AjcSVUI3EjcjheI3I7J1MlVDsnUzs9YD12PCVsTyVUI2IkNmRfJXpRJnIhYiZqUyZtV09yJVRycyZWc3clVHd4L1h4IV8lVCFfIWAjIHghYCNPJVQjTyNQN28jUCNvJVQjbyNwOF4jcCNxJVQjcSNyOF4jcjsnUyVUOydTOz1gPXY8JWxPJVQjYyQ3bl8mWHMmciFiJmpTJm1XT3IlVHJzJlZzdyVUd3gvWHghXyVUIV8hYEF2IWAjTyVUI08jUDdvI1AjbyVUI28jcDheI3AjcSVUI3EjcjheI3I7J1MlVDsnUzs9YD12PCVsTyVUI2MkOHhgb1ImciFiJmpTJm1XT3IlVHJzJlZzdyVUd3gvWHghXyVUIV8hYEF2IWAhYSQ5eiFhI08lVCNPI1A3byNQI28lVCNvI3A4XiNwI3ElVCNxI3I4XiNyOydTJVQ7J1M7PWA9djwlbE8lVCNiJDpWXyV7USZyIWImalMmbVdPciVUcnMmVnN3JVR3eC9YeCFfJVQhXyFgIyB4IWAjTyVUI08jUDdvI1AjbyVUI28jcDheI3AjcSVUI3EjcjheI3I7J1MlVDsnUzs9YD12PCVsTyVUI2MkO2NfYVEkUVAmciFiJmpTJm1XT3IlVHJzJlZzdyVUd3gvWHghXyVUIV8hYCMgeCFgI08lVCNPI1A3byNQI28lVCNvI3A4XiNwI3ElVCNxI3I4XiNyOydTJVQ7J1M7PWA9djwlbE8lVCNzJDxvZSZyIWImalMmbVcmZ2AmU3NPciVUcnMmVnN3JVR3eC9YeCFRJVQhUSFbJDxiIVshYyVUIWMhfSQ8YiF9I08lVCNPI1A3byNQI1IlVCNSI1MkPGIjUyNUJVQjVCNvJDxiI28jcDheI3AjcSVUI3EjcjheI3IkZyVUJGc7J1MkPGI7J1M7PWAkPlE8JWxPJDxiI3MkPlRQOz1gPCVsJDxiI3MkPmVpJnIhYiZqUyZtVyZnYCZTc09yJVRycyRAU3N3JVR3eCRDYHghUSVUIVEhWyQ8YiFbIWMlVCFjIXQkPGIhdCF1JEZsIXUhfSQ8YiF9I08lVCNPI1A3byNQI1IlVCNSI1MkPGIjUyNUJVQjVCNmJDxiI2YjZyRGbCNnI28kPGIjbyNwOF4jcCNxJVQjcSNyOF4jciRnJVQkZzsnUyQ8YjsnUzs9YCQ+UTwlbE8kPGIjYyRAXWEmciFiJmpTJmhzT1lFXllaJVRaXUVeXV4lVF5yRV5ycyRBYnN3RV53eEdweCNPRV4jTyNQISF1I1Ajb0VeI28jcCEjZCNwI3FFXiNxI3IhI2QjcjsnU0VeOydTOz1gISl2PCVsT0VeI2MkQWtdJnIhYiZqUyZoc09yJVRycyRCZHN3JVR3eC9YeCNPJVQjTyNQN28jUCNvJVQjbyNwOF4jcCNxJVQjcSNyOF4jcjsnUyVUOydTOz1gPXY8JWxPJVQjWiRCbVomciFiJmpTJmxzT3coVnd4KVB4I08oViNPI1ArWiNQI28oViNvI3AreCNwI3EoViNxI3IreCNyOydTKFY7J1M7PWAvUjwlbE8oViNjJENpYSZyIWImbVcmaHNPWSMlZllaJVRaXSMlZl1eJVReciMlZnJzIyZ2c3cjJWZ3eCREbngjTyMlZiNPI1AjMH0jUCNvIyVmI28jcCMxbCNwI3EjJWYjcSNyIzFsI3I7J1MjJWY7J1M7PWAjOE88JWxPIyVmI2MkRHddJnIhYiZtVyZoc09yJVRycyZWc3clVHd4JEVweCNPJVQjTyNQN28jUCNvJVQjbyNwOF4jcCNxJVQjcSNyOF4jcjsnUyVUOydTOz1gPXY8JWxPJVQjXyRFeVomciFiJm1XJmlzT3IxWHJzMlJzI08xWCNPI1AzcSNQI28xWCNvI3A0YCNwI3ExWCNxI3I0YCNyOydTMVg7J1M7PWA3aTwlbE8xWCNzJEZ5ZSZyIWImalMmbVcmZ2AmU3NPciVUcnMkQFNzdyVUd3gkQ2B4IVElVCFRIVskPGIhWyFjJVQhYyF9JDxiIX0jTyVUI08jUDdvI1AjUiVUI1IjUyQ8YiNTI1QlVCNUI28kPGIjbyNwOF4jcCNxJVQjcSNyOF4jciRnJVQkZzsnUyQ8YjsnUzs9YCQ+UTwlbE8kPGIjcyRIaWkmciFiJmpTJm1XJmdgJlNzT3IlVHJzJEpXc3clVHd4JE1VeCFRJVQhUSFbJDxiIVshYyVUIWMhdCQ8YiF0IXUlIVMhdSF9JDxiIX0jTyVUI08jUDdvI1AjUiVUI1IjUyQ8YiNTI1QlVCNUI2YkPGIjZiNnJSFTI2cjbyQ8YiNvI3A4XiNwI3ElVCNxI3I4XiNyJGclVCRnOydTJDxiOydTOz1gJD5RPCVsTyQ8YiNjJEphXSZyIWImalMmc3NPciVUcnMkS1lzdyVUd3gvWHgjTyVUI08jUDdvI1AjbyVUI28jcDheI3AjcSVUI3EjcjheI3I7J1MlVDsnUzs9YD12PCVsTyVUI2MkS2FdJnIhYiZqU09yJVRycyRMWXN3JVR3eC9YeCNPJVQjTyNQN28jUCNvJVQjbyNwOF4jcCNxJVQjcSNyOF4jcjsnUyVUOydTOz1gPXY8JWxPJVQjWiRMY1omciFiJmpTJnVzT3coVnd4KVB4I08oViNPI1ArWiNQI28oViNvI3AreCNwI3EoViNxI3IreCNyOydTKFY7J1M7PWAvUjwlbE8oViNjJE1fXSZyIWImbVcmb3NPciVUcnMmVnN3JVR3eCROV3gjTyVUI08jUDdvI1AjbyVUI28jcDheI3AjcSVUI3EjcjheI3I7J1MlVDsnUzs9YD12PCVsTyVUI2MkTl9dJnIhYiZtV09yJVRycyZWc3clVHd4JSBXeCNPJVQjTyNQN28jUCNvJVQjbyNwOF4jcCNxJVQjcSNyOF4jcjsnUyVUOydTOz1gPXY8JWxPJVQjXyUgYVomciFiJm1XJnRzT3IxWHJzMlJzI08xWCNPI1AzcSNQI28xWCNvI3A0YCNwI3ExWCNxI3I0YCNyOydTMVg7J1M7PWA3aTwlbE8xWCNzJSFhZSZyIWImalMmbVcmZ2AmU3NPciVUcnMkSldzdyVUd3gkTVV4IVElVCFRIVskPGIhWyFjJVQhYyF9JDxiIX0jTyVUI08jUDdvI1AjUiVUI1IjUyQ8YiNTI1QlVCNUI28kPGIjbyNwOF4jcCNxJVQjcSNyOF4jciRnJVQkZzsnUyQ8YjsnUzs9YCQ+UTwlbE8kPGIjcyUkUG0mciFiJmpTJm1XJmdgJlNzT3IlVHJzJEBTc3clVHd4JENgeCFRJVQhUSFbJDxiIVshYyVUIWMhaCQ8YiFoIWklIVMhaSF0JDxiIXQhdSRGbCF1IX0kPGIhfSNPJVQjTyNQN28jUCNSJVQjUiNTJDxiI1MjVCVUI1QjVSQ8YiNVI1YkRmwjViNZJDxiI1kjWiUhUyNaI28kPGIjbyNwOF4jcCNxJVQjcSNyOF4jciRnJVQkZzsnUyQ8YjsnUzs9YCQ+UTwlbE8kPGIjYyUmVl0hWnMmciFiJmpTJm1XT3IlVHJzJlZzdyVUd3gvWHgjTyVUI08jUDdvI1AjbyVUI28jcDheI3AjcSVUI3EjcjheI3I7J1MlVDsnUzs9YD12PCVsTyVUIXElJ1pdIVlSJnIhYiZqUyZtV09yJVRycyZWc3clVHd4L1h4I08lVCNPI1A3byNQI28lVCNvI3A4XiNwI3ElVCNxI3I4XiNyOydTJVQ7J1M7PWA9djwlbE8lVCNiJShfXyV4USZyIWImalMmbVdPciVUcnMmVnN3JVR3eC9YeCFfJVQhXyFgIyB4IWAjTyVUI08jUDdvI1AjbyVUI28jcDheI3AjcSVUI3EjcjheI3I7J1MlVDsnUzs9YD12PCVsTyVUI2ElKWdYIV8jVCZqUyZtV09yOF5yczlRc3c4Xnd4OmR4I084XiNPI1A7diNQOydTOF47J1M7PWA8eTwlbE84XiNjJSpfXyV3UiZyIWImalMmbVdPciVUcnMmVnN3JVR3eC9YeCFfJVQhXyFgIyB4IWAjTyVUI08jUDdvI1AjbyVUI28jcDheI3AjcSVUI3EjcjheI3I7J1MlVDsnUzs9YD12PCVsTyVUIXElK2dYIV4hZSZqUyZtV09yOF5yczlRc3c4Xnd4OmR4I084XiNPI1A7diNQOydTOF47J1M7PWA8eTwlbE84XiNhJSxfXSZScSZyIWImalMmbVdPciVUcnMmVnN3JVR3eC9YeCNPJVQjTyNQN28jUCNvJVQjbyNwOF4jcCNxJVQjcSNyOF4jcjsnUyVUOydTOz1gPXY8JWxPJVRcIixcbiAgdG9rZW5pemVyczogW2xlZ2FjeVByaW50LCBpbmRlbnRhdGlvbiwgbmV3bGluZXMsIGZvcm1hdFN0cmluZzEsIGZvcm1hdFN0cmluZzIsIGZvcm1hdFN0cmluZzFsLCBmb3JtYXRTdHJpbmcybCwgMCwgMSwgMiwgMywgNCwgNSwgNl0sXG4gIHRvcFJ1bGVzOiB7XCJTY3JpcHRcIjpbMCw3XX0sXG4gIHNwZWNpYWxpemVkOiBbe3Rlcm06IDIzNCwgZ2V0OiAodmFsdWUpID0+IHNwZWNfaWRlbnRpZmllclt2YWx1ZV0gfHwgLTF9XSxcbiAgdG9rZW5QcmVjOiA3MzcyXG59KTtcblxuZXhwb3J0IHsgcGFyc2VyIH07XG4iXSwibmFtZXMiOlsiRXh0ZXJuYWxUb2tlbml6ZXIiLCJDb250ZXh0VHJhY2tlciIsIkxSUGFyc2VyIiwic3R5bGVUYWdzIiwidGFncyIsInByaW50S2V5d29yZCIsImluZGVudCIsImRlZGVudCIsIm5ld2xpbmUkMSIsImJsYW5rTGluZVN0YXJ0IiwibmV3bGluZUJyYWNrZXRlZCIsImVvZiIsImZvcm1hdFN0cmluZzFDb250ZW50IiwiZm9ybWF0U3RyaW5nMUJyYWNlIiwiZm9ybWF0U3RyaW5nMUVuZCIsImZvcm1hdFN0cmluZzJDb250ZW50IiwiZm9ybWF0U3RyaW5nMkJyYWNlIiwiZm9ybWF0U3RyaW5nMkVuZCIsImZvcm1hdFN0cmluZzFsQ29udGVudCIsImZvcm1hdFN0cmluZzFsQnJhY2UiLCJmb3JtYXRTdHJpbmcxbEVuZCIsImZvcm1hdFN0cmluZzJsQ29udGVudCIsImZvcm1hdFN0cmluZzJsQnJhY2UiLCJmb3JtYXRTdHJpbmcybEVuZCIsIlBhcmVuTCIsIlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uIiwiVHVwbGVFeHByZXNzaW9uIiwiQ29tcHJlaGVuc2lvbkV4cHJlc3Npb24iLCJCcmFja2V0TCIsIkFycmF5RXhwcmVzc2lvbiIsIkFycmF5Q29tcHJlaGVuc2lvbkV4cHJlc3Npb24iLCJCcmFjZUwiLCJEaWN0aW9uYXJ5RXhwcmVzc2lvbiIsIkRpY3Rpb25hcnlDb21wcmVoZW5zaW9uRXhwcmVzc2lvbiIsIlNldEV4cHJlc3Npb24iLCJTZXRDb21wcmVoZW5zaW9uRXhwcmVzc2lvbiIsIkFyZ0xpc3QiLCJzdWJzY3JpcHQiLCJGb3JtYXRTdHJpbmciLCJpbXBvcnRMaXN0IiwiVHlwZVBhcmFtTGlzdCIsIlBhcmFtTGlzdCIsIlNlcXVlbmNlUGF0dGVybiIsIk1hcHBpbmdQYXR0ZXJuIiwiUGF0dGVybkFyZ0xpc3QiLCJuZXdsaW5lIiwiY2FycmlhZ2VSZXR1cm4iLCJzcGFjZSIsInRhYiIsImhhc2giLCJwYXJlbk9wZW4iLCJkb3QiLCJicmFjZU9wZW4iLCJzaW5nbGVRdW90ZSIsImRvdWJsZVF1b3RlIiwiYmFja3NsYXNoIiwiYnJhY2tldGVkIiwiU2V0IiwiaXNMaW5lQnJlYWsiLCJjaCIsIm5ld2xpbmVzIiwiaW5wdXQiLCJzdGFjayIsInByZXYiLCJuZXh0IiwiYWNjZXB0VG9rZW4iLCJjb250ZXh0IiwiZGVwdGgiLCJwZWVrIiwiY2FuU2hpZnQiLCJzcGFjZXMiLCJhZHZhbmNlIiwiY29udGV4dHVhbCIsImluZGVudGF0aW9uIiwiY0RlcHRoIiwiY2hhcnMiLCJJbmRlbnRMZXZlbCIsInBhcmVudCIsInRvcEluZGVudCIsImNvdW50SW5kZW50IiwiaSIsImxlbmd0aCIsImNoYXJDb2RlQXQiLCJ0cmFja0luZGVudCIsInN0YXJ0IiwicmVkdWNlIiwidGVybSIsImhhcyIsInNoaWZ0IiwicmVhZCIsInBvcyIsImxlZ2FjeVByaW50IiwidGVzdCIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsIm9mZiIsImZvcm1hdFN0cmluZyIsInF1b3RlIiwibGVuIiwiY29udGVudCIsImJyYWNlIiwiZW5kIiwiZm9ybWF0U3RyaW5nMSIsImZvcm1hdFN0cmluZzIiLCJmb3JtYXRTdHJpbmcxbCIsImZvcm1hdFN0cmluZzJsIiwicHl0aG9uSGlnaGxpZ2h0aW5nIiwibW9kaWZpZXIiLCJjb250cm9sS2V5d29yZCIsIm9wZXJhdG9yS2V5d29yZCIsImRlZmluaXRpb25LZXl3b3JkIiwiaW1wb3J0IiwibW9kdWxlS2V5d29yZCIsImtleXdvcmQiLCJCb29sZWFuIiwiYm9vbCIsIk5vbmUiLCJudWxsIiwiVmFyaWFibGVOYW1lIiwidmFyaWFibGVOYW1lIiwiZnVuY3Rpb24iLCJkZWZpbml0aW9uIiwiY2xhc3NOYW1lIiwiUHJvcGVydHlOYW1lIiwicHJvcGVydHlOYW1lIiwiQ29tbWVudCIsImxpbmVDb21tZW50IiwiTnVtYmVyIiwibnVtYmVyIiwic3RyaW5nIiwic3BlY2lhbCIsIlVwZGF0ZU9wIiwidXBkYXRlT3BlcmF0b3IiLCJhcml0aG1ldGljT3BlcmF0b3IiLCJCaXRPcCIsImJpdHdpc2VPcGVyYXRvciIsIkNvbXBhcmVPcCIsImNvbXBhcmVPcGVyYXRvciIsIkFzc2lnbk9wIiwiZGVmaW5pdGlvbk9wZXJhdG9yIiwiRWxsaXBzaXMiLCJwdW5jdHVhdGlvbiIsIkF0IiwibWV0YSIsInBhcmVuIiwic3F1YXJlQnJhY2tldCIsImRlcmVmT3BlcmF0b3IiLCJzZXBhcmF0b3IiLCJzcGVjX2lkZW50aWZpZXIiLCJfX3Byb3RvX18iLCJhd2FpdCIsIm9yIiwiYW5kIiwiaW4iLCJub3QiLCJpcyIsImlmIiwiZWxzZSIsImxhbWJkYSIsInlpZWxkIiwiZnJvbSIsImFzeW5jIiwiZm9yIiwiVHJ1ZSIsIkZhbHNlIiwiZGVsIiwicGFzcyIsImJyZWFrIiwiY29udGludWUiLCJyZXR1cm4iLCJyYWlzZSIsImFzIiwiZ2xvYmFsIiwibm9ubG9jYWwiLCJhc3NlcnQiLCJ0eXBlIiwiZWxpZiIsIndoaWxlIiwidHJ5IiwiZXhjZXB0IiwiZmluYWxseSIsIndpdGgiLCJkZWYiLCJjbGFzcyIsIm1hdGNoIiwiY2FzZSIsInBhcnNlciIsImRlc2VyaWFsaXplIiwidmVyc2lvbiIsInN0YXRlcyIsInN0YXRlRGF0YSIsImdvdG8iLCJub2RlTmFtZXMiLCJtYXhUZXJtIiwibm9kZVByb3BzIiwicHJvcFNvdXJjZXMiLCJza2lwcGVkTm9kZXMiLCJyZXBlYXROb2RlQ291bnQiLCJ0b2tlbkRhdGEiLCJ0b2tlbml6ZXJzIiwidG9wUnVsZXMiLCJzcGVjaWFsaXplZCIsImdldCIsInZhbHVlIiwidG9rZW5QcmVjIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lezer/python/dist/index.js\n");

/***/ })

};
;