"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@codemirror";
exports.ids = ["vendor-chunks/@codemirror"];
exports.modules = {

/***/ "(ssr)/./node_modules/@codemirror/autocomplete/dist/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@codemirror/autocomplete/dist/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CompletionContext: () => (/* binding */ CompletionContext),\n/* harmony export */   acceptCompletion: () => (/* binding */ acceptCompletion),\n/* harmony export */   autocompletion: () => (/* binding */ autocompletion),\n/* harmony export */   clearSnippet: () => (/* binding */ clearSnippet),\n/* harmony export */   closeBrackets: () => (/* binding */ closeBrackets),\n/* harmony export */   closeBracketsKeymap: () => (/* binding */ closeBracketsKeymap),\n/* harmony export */   closeCompletion: () => (/* binding */ closeCompletion),\n/* harmony export */   completeAnyWord: () => (/* binding */ completeAnyWord),\n/* harmony export */   completeFromList: () => (/* binding */ completeFromList),\n/* harmony export */   completionKeymap: () => (/* binding */ completionKeymap),\n/* harmony export */   completionStatus: () => (/* binding */ completionStatus),\n/* harmony export */   currentCompletions: () => (/* binding */ currentCompletions),\n/* harmony export */   deleteBracketPair: () => (/* binding */ deleteBracketPair),\n/* harmony export */   hasNextSnippetField: () => (/* binding */ hasNextSnippetField),\n/* harmony export */   hasPrevSnippetField: () => (/* binding */ hasPrevSnippetField),\n/* harmony export */   ifIn: () => (/* binding */ ifIn),\n/* harmony export */   ifNotIn: () => (/* binding */ ifNotIn),\n/* harmony export */   insertBracket: () => (/* binding */ insertBracket),\n/* harmony export */   insertCompletionText: () => (/* binding */ insertCompletionText),\n/* harmony export */   moveCompletionSelection: () => (/* binding */ moveCompletionSelection),\n/* harmony export */   nextSnippetField: () => (/* binding */ nextSnippetField),\n/* harmony export */   pickedCompletion: () => (/* binding */ pickedCompletion),\n/* harmony export */   prevSnippetField: () => (/* binding */ prevSnippetField),\n/* harmony export */   selectedCompletion: () => (/* binding */ selectedCompletion),\n/* harmony export */   selectedCompletionIndex: () => (/* binding */ selectedCompletionIndex),\n/* harmony export */   setSelectedCompletion: () => (/* binding */ setSelectedCompletion),\n/* harmony export */   snippet: () => (/* binding */ snippet),\n/* harmony export */   snippetCompletion: () => (/* binding */ snippetCompletion),\n/* harmony export */   snippetKeymap: () => (/* binding */ snippetKeymap),\n/* harmony export */   startCompletion: () => (/* binding */ startCompletion)\n/* harmony export */ });\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/state */ \"(ssr)/./node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/view */ \"(ssr)/./node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _codemirror_language__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @codemirror/language */ \"(ssr)/./node_modules/@codemirror/language/dist/index.js\");\n\n\n\n/**\nAn instance of this is passed to completion source functions.\n*/ class CompletionContext {\n    /**\n    Create a new completion context. (Mostly useful for testing\n    completion sources—in the editor, the extension will create\n    these for you.)\n    */ constructor(/**\n    The editor state that the completion happens in.\n    */ state, /**\n    The position at which the completion is happening.\n    */ pos, /**\n    Indicates whether completion was activated explicitly, or\n    implicitly by typing. The usual way to respond to this is to\n    only return completions when either there is part of a\n    completable entity before the cursor, or `explicit` is true.\n    */ explicit){\n        this.state = state;\n        this.pos = pos;\n        this.explicit = explicit;\n        /**\n        @internal\n        */ this.abortListeners = [];\n    }\n    /**\n    Get the extent, content, and (if there is a token) type of the\n    token before `this.pos`.\n    */ tokenBefore(types) {\n        let token = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_0__.syntaxTree)(this.state).resolveInner(this.pos, -1);\n        while(token && types.indexOf(token.name) < 0)token = token.parent;\n        return token ? {\n            from: token.from,\n            to: this.pos,\n            text: this.state.sliceDoc(token.from, this.pos),\n            type: token.type\n        } : null;\n    }\n    /**\n    Get the match of the given expression directly before the\n    cursor.\n    */ matchBefore(expr) {\n        let line = this.state.doc.lineAt(this.pos);\n        let start = Math.max(line.from, this.pos - 250);\n        let str = line.text.slice(start - line.from, this.pos - line.from);\n        let found = str.search(ensureAnchor(expr, false));\n        return found < 0 ? null : {\n            from: start + found,\n            to: this.pos,\n            text: str.slice(found)\n        };\n    }\n    /**\n    Yields true when the query has been aborted. Can be useful in\n    asynchronous queries to avoid doing work that will be ignored.\n    */ get aborted() {\n        return this.abortListeners == null;\n    }\n    /**\n    Allows you to register abort handlers, which will be called when\n    the query is\n    [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).\n    */ addEventListener(type, listener) {\n        if (type == \"abort\" && this.abortListeners) this.abortListeners.push(listener);\n    }\n}\nfunction toSet(chars) {\n    let flat = Object.keys(chars).join(\"\");\n    let words = /\\w/.test(flat);\n    if (words) flat = flat.replace(/\\w/g, \"\");\n    return `[${words ? \"\\\\w\" : \"\"}${flat.replace(/[^\\w\\s]/g, \"\\\\$&\")}]`;\n}\nfunction prefixMatch(options) {\n    let first = Object.create(null), rest = Object.create(null);\n    for (let { label } of options){\n        first[label[0]] = true;\n        for(let i = 1; i < label.length; i++)rest[label[i]] = true;\n    }\n    let source = toSet(first) + toSet(rest) + \"*$\";\n    return [\n        new RegExp(\"^\" + source),\n        new RegExp(source)\n    ];\n}\n/**\nGiven a a fixed array of options, return an autocompleter that\ncompletes them.\n*/ function completeFromList(list) {\n    let options = list.map((o)=>typeof o == \"string\" ? {\n            label: o\n        } : o);\n    let [validFor, match] = options.every((o)=>/^\\w+$/.test(o.label)) ? [\n        /\\w*$/,\n        /\\w+$/\n    ] : prefixMatch(options);\n    return (context)=>{\n        let token = context.matchBefore(match);\n        return token || context.explicit ? {\n            from: token ? token.from : context.pos,\n            options,\n            validFor\n        } : null;\n    };\n}\n/**\nWrap the given completion source so that it will only fire when the\ncursor is in a syntax node with one of the given names.\n*/ function ifIn(nodes, source) {\n    return (context)=>{\n        for(let pos = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_0__.syntaxTree)(context.state).resolveInner(context.pos, -1); pos; pos = pos.parent){\n            if (nodes.indexOf(pos.name) > -1) return source(context);\n            if (pos.type.isTop) break;\n        }\n        return null;\n    };\n}\n/**\nWrap the given completion source so that it will not fire when the\ncursor is in a syntax node with one of the given names.\n*/ function ifNotIn(nodes, source) {\n    return (context)=>{\n        for(let pos = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_0__.syntaxTree)(context.state).resolveInner(context.pos, -1); pos; pos = pos.parent){\n            if (nodes.indexOf(pos.name) > -1) return null;\n            if (pos.type.isTop) break;\n        }\n        return source(context);\n    };\n}\nclass Option {\n    constructor(completion, source, match, score){\n        this.completion = completion;\n        this.source = source;\n        this.match = match;\n        this.score = score;\n    }\n}\nfunction cur(state) {\n    return state.selection.main.from;\n}\n// Make sure the given regexp has a $ at its end and, if `start` is\n// true, a ^ at its start.\nfunction ensureAnchor(expr, start) {\n    var _a;\n    let { source } = expr;\n    let addStart = start && source[0] != \"^\", addEnd = source[source.length - 1] != \"$\";\n    if (!addStart && !addEnd) return expr;\n    return new RegExp(`${addStart ? \"^\" : \"\"}(?:${source})${addEnd ? \"$\" : \"\"}`, (_a = expr.flags) !== null && _a !== void 0 ? _a : expr.ignoreCase ? \"i\" : \"\");\n}\n/**\nThis annotation is added to transactions that are produced by\npicking a completion.\n*/ const pickedCompletion = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Annotation.define();\n/**\nHelper function that returns a transaction spec which inserts a\ncompletion's text in the main selection range, and any other\nselection range that has the same text in front of it.\n*/ function insertCompletionText(state, text, from, to) {\n    let { main } = state.selection, fromOff = from - main.from, toOff = to - main.from;\n    return Object.assign(Object.assign({}, state.changeByRange((range)=>{\n        if (range != main && from != to && state.sliceDoc(range.from + fromOff, range.from + toOff) != state.sliceDoc(from, to)) return {\n            range\n        };\n        return {\n            changes: {\n                from: range.from + fromOff,\n                to: to == main.from ? range.to : range.from + toOff,\n                insert: text\n            },\n            range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(range.from + fromOff + text.length)\n        };\n    })), {\n        scrollIntoView: true,\n        userEvent: \"input.complete\"\n    });\n}\nconst SourceCache = /*@__PURE__*/ new WeakMap();\nfunction asSource(source) {\n    if (!Array.isArray(source)) return source;\n    let known = SourceCache.get(source);\n    if (!known) SourceCache.set(source, known = completeFromList(source));\n    return known;\n}\nconst startCompletionEffect = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();\nconst closeCompletionEffect = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();\n// A pattern matcher for fuzzy completion matching. Create an instance\n// once for a pattern, and then use that to match any number of\n// completions.\nclass FuzzyMatcher {\n    constructor(pattern){\n        this.pattern = pattern;\n        this.chars = [];\n        this.folded = [];\n        // Buffers reused by calls to `match` to track matched character\n        // positions.\n        this.any = [];\n        this.precise = [];\n        this.byWord = [];\n        this.score = 0;\n        this.matched = [];\n        for(let p = 0; p < pattern.length;){\n            let char = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(pattern, p), size = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)(char);\n            this.chars.push(char);\n            let part = pattern.slice(p, p + size), upper = part.toUpperCase();\n            this.folded.push((0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(upper == part ? part.toLowerCase() : upper, 0));\n            p += size;\n        }\n        this.astral = pattern.length != this.chars.length;\n    }\n    ret(score, matched) {\n        this.score = score;\n        this.matched = matched;\n        return true;\n    }\n    // Matches a given word (completion) against the pattern (input).\n    // Will return a boolean indicating whether there was a match and,\n    // on success, set `this.score` to the score, `this.matched` to an\n    // array of `from, to` pairs indicating the matched parts of `word`.\n    //\n    // The score is a number that is more negative the worse the match\n    // is. See `Penalty` above.\n    match(word) {\n        if (this.pattern.length == 0) return this.ret(-100 /* Penalty.NotFull */ , []);\n        if (word.length < this.pattern.length) return false;\n        let { chars, folded, any, precise, byWord } = this;\n        // For single-character queries, only match when they occur right\n        // at the start\n        if (chars.length == 1) {\n            let first = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(word, 0), firstSize = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)(first);\n            let score = firstSize == word.length ? 0 : -100 /* Penalty.NotFull */ ;\n            if (first == chars[0]) ;\n            else if (first == folded[0]) score += -200 /* Penalty.CaseFold */ ;\n            else return false;\n            return this.ret(score, [\n                0,\n                firstSize\n            ]);\n        }\n        let direct = word.indexOf(this.pattern);\n        if (direct == 0) return this.ret(word.length == this.pattern.length ? 0 : -100 /* Penalty.NotFull */ , [\n            0,\n            this.pattern.length\n        ]);\n        let len = chars.length, anyTo = 0;\n        if (direct < 0) {\n            for(let i = 0, e = Math.min(word.length, 200); i < e && anyTo < len;){\n                let next = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(word, i);\n                if (next == chars[anyTo] || next == folded[anyTo]) any[anyTo++] = i;\n                i += (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)(next);\n            }\n            // No match, exit immediately\n            if (anyTo < len) return false;\n        }\n        // This tracks the extent of the precise (non-folded, not\n        // necessarily adjacent) match\n        let preciseTo = 0;\n        // Tracks whether there is a match that hits only characters that\n        // appear to be starting words. `byWordFolded` is set to true when\n        // a case folded character is encountered in such a match\n        let byWordTo = 0, byWordFolded = false;\n        // If we've found a partial adjacent match, these track its state\n        let adjacentTo = 0, adjacentStart = -1, adjacentEnd = -1;\n        let hasLower = /[a-z]/.test(word), wordAdjacent = true;\n        // Go over the option's text, scanning for the various kinds of matches\n        for(let i = 0, e = Math.min(word.length, 200), prevType = 0 /* Tp.NonWord */ ; i < e && byWordTo < len;){\n            let next = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(word, i);\n            if (direct < 0) {\n                if (preciseTo < len && next == chars[preciseTo]) precise[preciseTo++] = i;\n                if (adjacentTo < len) {\n                    if (next == chars[adjacentTo] || next == folded[adjacentTo]) {\n                        if (adjacentTo == 0) adjacentStart = i;\n                        adjacentEnd = i + 1;\n                        adjacentTo++;\n                    } else {\n                        adjacentTo = 0;\n                    }\n                }\n            }\n            let ch, type = next < 0xff ? next >= 48 && next <= 57 || next >= 97 && next <= 122 ? 2 /* Tp.Lower */  : next >= 65 && next <= 90 ? 1 /* Tp.Upper */  : 0 /* Tp.NonWord */  : (ch = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.fromCodePoint)(next)) != ch.toLowerCase() ? 1 /* Tp.Upper */  : ch != ch.toUpperCase() ? 2 /* Tp.Lower */  : 0 /* Tp.NonWord */ ;\n            if (!i || type == 1 /* Tp.Upper */  && hasLower || prevType == 0 /* Tp.NonWord */  && type != 0 /* Tp.NonWord */ ) {\n                if (chars[byWordTo] == next || folded[byWordTo] == next && (byWordFolded = true)) byWord[byWordTo++] = i;\n                else if (byWord.length) wordAdjacent = false;\n            }\n            prevType = type;\n            i += (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)(next);\n        }\n        if (byWordTo == len && byWord[0] == 0 && wordAdjacent) return this.result(-100 /* Penalty.ByWord */  + (byWordFolded ? -200 /* Penalty.CaseFold */  : 0), byWord, word);\n        if (adjacentTo == len && adjacentStart == 0) return this.ret(-200 /* Penalty.CaseFold */  - word.length + (adjacentEnd == word.length ? 0 : -100 /* Penalty.NotFull */ ), [\n            0,\n            adjacentEnd\n        ]);\n        if (direct > -1) return this.ret(-700 /* Penalty.NotStart */  - word.length, [\n            direct,\n            direct + this.pattern.length\n        ]);\n        if (adjacentTo == len) return this.ret(-200 /* Penalty.CaseFold */  + -700 /* Penalty.NotStart */  - word.length, [\n            adjacentStart,\n            adjacentEnd\n        ]);\n        if (byWordTo == len) return this.result(-100 /* Penalty.ByWord */  + (byWordFolded ? -200 /* Penalty.CaseFold */  : 0) + -700 /* Penalty.NotStart */  + (wordAdjacent ? 0 : -1100 /* Penalty.Gap */ ), byWord, word);\n        return chars.length == 2 ? false : this.result((any[0] ? -700 /* Penalty.NotStart */  : 0) + -200 /* Penalty.CaseFold */  + -1100 /* Penalty.Gap */ , any, word);\n    }\n    result(score, positions, word) {\n        let result = [], i = 0;\n        for (let pos of positions){\n            let to = pos + (this.astral ? (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)((0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(word, pos)) : 1);\n            if (i && result[i - 1] == pos) result[i - 1] = to;\n            else {\n                result[i++] = pos;\n                result[i++] = to;\n            }\n        }\n        return this.ret(score - word.length, result);\n    }\n}\nconst completionConfig = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define({\n    combine (configs) {\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.combineConfig)(configs, {\n            activateOnTyping: true,\n            selectOnOpen: true,\n            override: null,\n            closeOnBlur: true,\n            maxRenderedOptions: 100,\n            defaultKeymap: true,\n            tooltipClass: ()=>\"\",\n            optionClass: ()=>\"\",\n            aboveCursor: false,\n            icons: true,\n            addToOptions: [],\n            positionInfo: defaultPositionInfo,\n            compareCompletions: (a, b)=>a.label.localeCompare(b.label),\n            interactionDelay: 75,\n            updateSyncTime: 100\n        }, {\n            defaultKeymap: (a, b)=>a && b,\n            closeOnBlur: (a, b)=>a && b,\n            icons: (a, b)=>a && b,\n            tooltipClass: (a, b)=>(c)=>joinClass(a(c), b(c)),\n            optionClass: (a, b)=>(c)=>joinClass(a(c), b(c)),\n            addToOptions: (a, b)=>a.concat(b)\n        });\n    }\n});\nfunction joinClass(a, b) {\n    return a ? b ? a + \" \" + b : a : b;\n}\nfunction defaultPositionInfo(view, list, option, info, space, tooltip) {\n    let rtl = view.textDirection == _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Direction.RTL, left = rtl, narrow = false;\n    let side = \"top\", offset, maxWidth;\n    let spaceLeft = list.left - space.left, spaceRight = space.right - list.right;\n    let infoWidth = info.right - info.left, infoHeight = info.bottom - info.top;\n    if (left && spaceLeft < Math.min(infoWidth, spaceRight)) left = false;\n    else if (!left && spaceRight < Math.min(infoWidth, spaceLeft)) left = true;\n    if (infoWidth <= (left ? spaceLeft : spaceRight)) {\n        offset = Math.max(space.top, Math.min(option.top, space.bottom - infoHeight)) - list.top;\n        maxWidth = Math.min(400 /* Info.Width */ , left ? spaceLeft : spaceRight);\n    } else {\n        narrow = true;\n        maxWidth = Math.min(400 /* Info.Width */ , (rtl ? list.right : space.right - list.left) - 30 /* Info.Margin */ );\n        let spaceBelow = space.bottom - list.bottom;\n        if (spaceBelow >= infoHeight || spaceBelow > list.top) {\n            offset = option.bottom - list.top;\n        } else {\n            side = \"bottom\";\n            offset = list.bottom - option.top;\n        }\n    }\n    let scaleY = (list.bottom - list.top) / tooltip.offsetHeight;\n    let scaleX = (list.right - list.left) / tooltip.offsetWidth;\n    return {\n        style: `${side}: ${offset / scaleY}px; max-width: ${maxWidth / scaleX}px`,\n        class: \"cm-completionInfo-\" + (narrow ? rtl ? \"left-narrow\" : \"right-narrow\" : left ? \"left\" : \"right\")\n    };\n}\nfunction optionContent(config) {\n    let content = config.addToOptions.slice();\n    if (config.icons) content.push({\n        render (completion) {\n            let icon = document.createElement(\"div\");\n            icon.classList.add(\"cm-completionIcon\");\n            if (completion.type) icon.classList.add(...completion.type.split(/\\s+/g).map((cls)=>\"cm-completionIcon-\" + cls));\n            icon.setAttribute(\"aria-hidden\", \"true\");\n            return icon;\n        },\n        position: 20\n    });\n    content.push({\n        render (completion, _s, _v, match) {\n            let labelElt = document.createElement(\"span\");\n            labelElt.className = \"cm-completionLabel\";\n            let label = completion.displayLabel || completion.label, off = 0;\n            for(let j = 0; j < match.length;){\n                let from = match[j++], to = match[j++];\n                if (from > off) labelElt.appendChild(document.createTextNode(label.slice(off, from)));\n                let span = labelElt.appendChild(document.createElement(\"span\"));\n                span.appendChild(document.createTextNode(label.slice(from, to)));\n                span.className = \"cm-completionMatchedText\";\n                off = to;\n            }\n            if (off < label.length) labelElt.appendChild(document.createTextNode(label.slice(off)));\n            return labelElt;\n        },\n        position: 50\n    }, {\n        render (completion) {\n            if (!completion.detail) return null;\n            let detailElt = document.createElement(\"span\");\n            detailElt.className = \"cm-completionDetail\";\n            detailElt.textContent = completion.detail;\n            return detailElt;\n        },\n        position: 80\n    });\n    return content.sort((a, b)=>a.position - b.position).map((a)=>a.render);\n}\nfunction rangeAroundSelected(total, selected, max) {\n    if (total <= max) return {\n        from: 0,\n        to: total\n    };\n    if (selected < 0) selected = 0;\n    if (selected <= total >> 1) {\n        let off = Math.floor(selected / max);\n        return {\n            from: off * max,\n            to: (off + 1) * max\n        };\n    }\n    let off = Math.floor((total - selected) / max);\n    return {\n        from: total - (off + 1) * max,\n        to: total - off * max\n    };\n}\nclass CompletionTooltip {\n    constructor(view, stateField, applyCompletion){\n        this.view = view;\n        this.stateField = stateField;\n        this.applyCompletion = applyCompletion;\n        this.info = null;\n        this.infoDestroy = null;\n        this.placeInfoReq = {\n            read: ()=>this.measureInfo(),\n            write: (pos)=>this.placeInfo(pos),\n            key: this\n        };\n        this.space = null;\n        this.currentClass = \"\";\n        let cState = view.state.field(stateField);\n        let { options, selected } = cState.open;\n        let config = view.state.facet(completionConfig);\n        this.optionContent = optionContent(config);\n        this.optionClass = config.optionClass;\n        this.tooltipClass = config.tooltipClass;\n        this.range = rangeAroundSelected(options.length, selected, config.maxRenderedOptions);\n        this.dom = document.createElement(\"div\");\n        this.dom.className = \"cm-tooltip-autocomplete\";\n        this.updateTooltipClass(view.state);\n        this.dom.addEventListener(\"mousedown\", (e)=>{\n            let { options } = view.state.field(stateField).open;\n            for(let dom = e.target, match; dom && dom != this.dom; dom = dom.parentNode){\n                if (dom.nodeName == \"LI\" && (match = /-(\\d+)$/.exec(dom.id)) && +match[1] < options.length) {\n                    this.applyCompletion(view, options[+match[1]]);\n                    e.preventDefault();\n                    return;\n                }\n            }\n        });\n        this.dom.addEventListener(\"focusout\", (e)=>{\n            let state = view.state.field(this.stateField, false);\n            if (state && state.tooltip && view.state.facet(completionConfig).closeOnBlur && e.relatedTarget != view.contentDOM) view.dispatch({\n                effects: closeCompletionEffect.of(null)\n            });\n        });\n        this.showOptions(options, cState.id);\n    }\n    mount() {\n        this.updateSel();\n    }\n    showOptions(options, id) {\n        if (this.list) this.list.remove();\n        this.list = this.dom.appendChild(this.createListBox(options, id, this.range));\n        this.list.addEventListener(\"scroll\", ()=>{\n            if (this.info) this.view.requestMeasure(this.placeInfoReq);\n        });\n    }\n    update(update) {\n        var _a;\n        let cState = update.state.field(this.stateField);\n        let prevState = update.startState.field(this.stateField);\n        this.updateTooltipClass(update.state);\n        if (cState != prevState) {\n            let { options, selected, disabled } = cState.open;\n            if (!prevState.open || prevState.open.options != options) {\n                this.range = rangeAroundSelected(options.length, selected, update.state.facet(completionConfig).maxRenderedOptions);\n                this.showOptions(options, cState.id);\n            }\n            this.updateSel();\n            if (disabled != ((_a = prevState.open) === null || _a === void 0 ? void 0 : _a.disabled)) this.dom.classList.toggle(\"cm-tooltip-autocomplete-disabled\", !!disabled);\n        }\n    }\n    updateTooltipClass(state) {\n        let cls = this.tooltipClass(state);\n        if (cls != this.currentClass) {\n            for (let c of this.currentClass.split(\" \"))if (c) this.dom.classList.remove(c);\n            for (let c of cls.split(\" \"))if (c) this.dom.classList.add(c);\n            this.currentClass = cls;\n        }\n    }\n    positioned(space) {\n        this.space = space;\n        if (this.info) this.view.requestMeasure(this.placeInfoReq);\n    }\n    updateSel() {\n        let cState = this.view.state.field(this.stateField), open = cState.open;\n        if (open.selected > -1 && open.selected < this.range.from || open.selected >= this.range.to) {\n            this.range = rangeAroundSelected(open.options.length, open.selected, this.view.state.facet(completionConfig).maxRenderedOptions);\n            this.showOptions(open.options, cState.id);\n        }\n        if (this.updateSelectedOption(open.selected)) {\n            this.destroyInfo();\n            let { completion } = open.options[open.selected];\n            let { info } = completion;\n            if (!info) return;\n            let infoResult = typeof info === \"string\" ? document.createTextNode(info) : info(completion);\n            if (!infoResult) return;\n            if (\"then\" in infoResult) {\n                infoResult.then((obj)=>{\n                    if (obj && this.view.state.field(this.stateField, false) == cState) this.addInfoPane(obj, completion);\n                }).catch((e)=>(0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.logException)(this.view.state, e, \"completion info\"));\n            } else {\n                this.addInfoPane(infoResult, completion);\n            }\n        }\n    }\n    addInfoPane(content, completion) {\n        this.destroyInfo();\n        let wrap = this.info = document.createElement(\"div\");\n        wrap.className = \"cm-tooltip cm-completionInfo\";\n        if (content.nodeType != null) {\n            wrap.appendChild(content);\n            this.infoDestroy = null;\n        } else {\n            let { dom, destroy } = content;\n            wrap.appendChild(dom);\n            this.infoDestroy = destroy || null;\n        }\n        this.dom.appendChild(wrap);\n        this.view.requestMeasure(this.placeInfoReq);\n    }\n    updateSelectedOption(selected) {\n        let set = null;\n        for(let opt = this.list.firstChild, i = this.range.from; opt; opt = opt.nextSibling, i++){\n            if (opt.nodeName != \"LI\" || !opt.id) {\n                i--; // A section header\n            } else if (i == selected) {\n                if (!opt.hasAttribute(\"aria-selected\")) {\n                    opt.setAttribute(\"aria-selected\", \"true\");\n                    set = opt;\n                }\n            } else {\n                if (opt.hasAttribute(\"aria-selected\")) opt.removeAttribute(\"aria-selected\");\n            }\n        }\n        if (set) scrollIntoView(this.list, set);\n        return set;\n    }\n    measureInfo() {\n        let sel = this.dom.querySelector(\"[aria-selected]\");\n        if (!sel || !this.info) return null;\n        let listRect = this.dom.getBoundingClientRect();\n        let infoRect = this.info.getBoundingClientRect();\n        let selRect = sel.getBoundingClientRect();\n        let space = this.space;\n        if (!space) {\n            let win = this.dom.ownerDocument.defaultView || window;\n            space = {\n                left: 0,\n                top: 0,\n                right: win.innerWidth,\n                bottom: win.innerHeight\n            };\n        }\n        if (selRect.top > Math.min(space.bottom, listRect.bottom) - 10 || selRect.bottom < Math.max(space.top, listRect.top) + 10) return null;\n        return this.view.state.facet(completionConfig).positionInfo(this.view, listRect, selRect, infoRect, space, this.dom);\n    }\n    placeInfo(pos) {\n        if (this.info) {\n            if (pos) {\n                if (pos.style) this.info.style.cssText = pos.style;\n                this.info.className = \"cm-tooltip cm-completionInfo \" + (pos.class || \"\");\n            } else {\n                this.info.style.cssText = \"top: -1e6px\";\n            }\n        }\n    }\n    createListBox(options, id, range) {\n        const ul = document.createElement(\"ul\");\n        ul.id = id;\n        ul.setAttribute(\"role\", \"listbox\");\n        ul.setAttribute(\"aria-expanded\", \"true\");\n        ul.setAttribute(\"aria-label\", this.view.state.phrase(\"Completions\"));\n        let curSection = null;\n        for(let i = range.from; i < range.to; i++){\n            let { completion, match } = options[i], { section } = completion;\n            if (section) {\n                let name = typeof section == \"string\" ? section : section.name;\n                if (name != curSection && (i > range.from || range.from == 0)) {\n                    curSection = name;\n                    if (typeof section != \"string\" && section.header) {\n                        ul.appendChild(section.header(section));\n                    } else {\n                        let header = ul.appendChild(document.createElement(\"completion-section\"));\n                        header.textContent = name;\n                    }\n                }\n            }\n            const li = ul.appendChild(document.createElement(\"li\"));\n            li.id = id + \"-\" + i;\n            li.setAttribute(\"role\", \"option\");\n            let cls = this.optionClass(completion);\n            if (cls) li.className = cls;\n            for (let source of this.optionContent){\n                let node = source(completion, this.view.state, this.view, match);\n                if (node) li.appendChild(node);\n            }\n        }\n        if (range.from) ul.classList.add(\"cm-completionListIncompleteTop\");\n        if (range.to < options.length) ul.classList.add(\"cm-completionListIncompleteBottom\");\n        return ul;\n    }\n    destroyInfo() {\n        if (this.info) {\n            if (this.infoDestroy) this.infoDestroy();\n            this.info.remove();\n            this.info = null;\n        }\n    }\n    destroy() {\n        this.destroyInfo();\n    }\n}\nfunction completionTooltip(stateField, applyCompletion) {\n    return (view)=>new CompletionTooltip(view, stateField, applyCompletion);\n}\nfunction scrollIntoView(container, element) {\n    let parent = container.getBoundingClientRect();\n    let self = element.getBoundingClientRect();\n    let scaleY = parent.height / container.offsetHeight;\n    if (self.top < parent.top) container.scrollTop -= (parent.top - self.top) / scaleY;\n    else if (self.bottom > parent.bottom) container.scrollTop += (self.bottom - parent.bottom) / scaleY;\n}\n// Used to pick a preferred option when two options with the same\n// label occur in the result.\nfunction score(option) {\n    return (option.boost || 0) * 100 + (option.apply ? 10 : 0) + (option.info ? 5 : 0) + (option.type ? 1 : 0);\n}\nfunction sortOptions(active, state) {\n    let options = [];\n    let sections = null;\n    let addOption = (option)=>{\n        options.push(option);\n        let { section } = option.completion;\n        if (section) {\n            if (!sections) sections = [];\n            let name = typeof section == \"string\" ? section : section.name;\n            if (!sections.some((s)=>s.name == name)) sections.push(typeof section == \"string\" ? {\n                name\n            } : section);\n        }\n    };\n    for (let a of active)if (a.hasResult()) {\n        let getMatch = a.result.getMatch;\n        if (a.result.filter === false) {\n            for (let option of a.result.options){\n                addOption(new Option(option, a.source, getMatch ? getMatch(option) : [], 1e9 - options.length));\n            }\n        } else {\n            let matcher = new FuzzyMatcher(state.sliceDoc(a.from, a.to));\n            for (let option of a.result.options)if (matcher.match(option.label)) {\n                let matched = !option.displayLabel ? matcher.matched : getMatch ? getMatch(option, matcher.matched) : [];\n                addOption(new Option(option, a.source, matched, matcher.score + (option.boost || 0)));\n            }\n        }\n    }\n    if (sections) {\n        let sectionOrder = Object.create(null), pos = 0;\n        let cmp = (a, b)=>{\n            var _a, _b;\n            return ((_a = a.rank) !== null && _a !== void 0 ? _a : 1e9) - ((_b = b.rank) !== null && _b !== void 0 ? _b : 1e9) || (a.name < b.name ? -1 : 1);\n        };\n        for (let s of sections.sort(cmp)){\n            pos -= 1e5;\n            sectionOrder[s.name] = pos;\n        }\n        for (let option of options){\n            let { section } = option.completion;\n            if (section) option.score += sectionOrder[typeof section == \"string\" ? section : section.name];\n        }\n    }\n    let result = [], prev = null;\n    let compare = state.facet(completionConfig).compareCompletions;\n    for (let opt of options.sort((a, b)=>b.score - a.score || compare(a.completion, b.completion))){\n        let cur = opt.completion;\n        if (!prev || prev.label != cur.label || prev.detail != cur.detail || prev.type != null && cur.type != null && prev.type != cur.type || prev.apply != cur.apply || prev.boost != cur.boost) result.push(opt);\n        else if (score(opt.completion) > score(prev)) result[result.length - 1] = opt;\n        prev = opt.completion;\n    }\n    return result;\n}\nclass CompletionDialog {\n    constructor(options, attrs, tooltip, timestamp, selected, disabled){\n        this.options = options;\n        this.attrs = attrs;\n        this.tooltip = tooltip;\n        this.timestamp = timestamp;\n        this.selected = selected;\n        this.disabled = disabled;\n    }\n    setSelected(selected, id) {\n        return selected == this.selected || selected >= this.options.length ? this : new CompletionDialog(this.options, makeAttrs(id, selected), this.tooltip, this.timestamp, selected, this.disabled);\n    }\n    static build(active, state, id, prev, conf) {\n        let options = sortOptions(active, state);\n        if (!options.length) {\n            return prev && active.some((a)=>a.state == 1 /* State.Pending */ ) ? new CompletionDialog(prev.options, prev.attrs, prev.tooltip, prev.timestamp, prev.selected, true) : null;\n        }\n        let selected = state.facet(completionConfig).selectOnOpen ? 0 : -1;\n        if (prev && prev.selected != selected && prev.selected != -1) {\n            let selectedValue = prev.options[prev.selected].completion;\n            for(let i = 0; i < options.length; i++)if (options[i].completion == selectedValue) {\n                selected = i;\n                break;\n            }\n        }\n        return new CompletionDialog(options, makeAttrs(id, selected), {\n            pos: active.reduce((a, b)=>b.hasResult() ? Math.min(a, b.from) : a, 1e8),\n            create: createTooltip,\n            above: conf.aboveCursor\n        }, prev ? prev.timestamp : Date.now(), selected, false);\n    }\n    map(changes) {\n        return new CompletionDialog(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), {\n            pos: changes.mapPos(this.tooltip.pos)\n        }), this.timestamp, this.selected, this.disabled);\n    }\n}\nclass CompletionState {\n    constructor(active, id, open){\n        this.active = active;\n        this.id = id;\n        this.open = open;\n    }\n    static start() {\n        return new CompletionState(none, \"cm-ac-\" + Math.floor(Math.random() * 2e6).toString(36), null);\n    }\n    update(tr) {\n        let { state } = tr, conf = state.facet(completionConfig);\n        let sources = conf.override || state.languageDataAt(\"autocomplete\", cur(state)).map(asSource);\n        let active = sources.map((source)=>{\n            let value = this.active.find((s)=>s.source == source) || new ActiveSource(source, this.active.some((a)=>a.state != 0 /* State.Inactive */ ) ? 1 /* State.Pending */  : 0 /* State.Inactive */ );\n            return value.update(tr, conf);\n        });\n        if (active.length == this.active.length && active.every((a, i)=>a == this.active[i])) active = this.active;\n        let open = this.open;\n        if (open && tr.docChanged) open = open.map(tr.changes);\n        if (tr.selection || active.some((a)=>a.hasResult() && tr.changes.touchesRange(a.from, a.to)) || !sameResults(active, this.active)) open = CompletionDialog.build(active, state, this.id, open, conf);\n        else if (open && open.disabled && !active.some((a)=>a.state == 1 /* State.Pending */ )) open = null;\n        if (!open && active.every((a)=>a.state != 1 /* State.Pending */ ) && active.some((a)=>a.hasResult())) active = active.map((a)=>a.hasResult() ? new ActiveSource(a.source, 0 /* State.Inactive */ ) : a);\n        for (let effect of tr.effects)if (effect.is(setSelectedEffect)) open = open && open.setSelected(effect.value, this.id);\n        return active == this.active && open == this.open ? this : new CompletionState(active, this.id, open);\n    }\n    get tooltip() {\n        return this.open ? this.open.tooltip : null;\n    }\n    get attrs() {\n        return this.open ? this.open.attrs : baseAttrs;\n    }\n}\nfunction sameResults(a, b) {\n    if (a == b) return true;\n    for(let iA = 0, iB = 0;;){\n        while(iA < a.length && !a[iA].hasResult)iA++;\n        while(iB < b.length && !b[iB].hasResult)iB++;\n        let endA = iA == a.length, endB = iB == b.length;\n        if (endA || endB) return endA == endB;\n        if (a[iA++].result != b[iB++].result) return false;\n    }\n}\nconst baseAttrs = {\n    \"aria-autocomplete\": \"list\"\n};\nfunction makeAttrs(id, selected) {\n    let result = {\n        \"aria-autocomplete\": \"list\",\n        \"aria-haspopup\": \"listbox\",\n        \"aria-controls\": id\n    };\n    if (selected > -1) result[\"aria-activedescendant\"] = id + \"-\" + selected;\n    return result;\n}\nconst none = [];\nfunction getUserEvent(tr) {\n    return tr.isUserEvent(\"input.type\") ? \"input\" : tr.isUserEvent(\"delete.backward\") ? \"delete\" : null;\n}\nclass ActiveSource {\n    constructor(source, state, explicitPos = -1){\n        this.source = source;\n        this.state = state;\n        this.explicitPos = explicitPos;\n    }\n    hasResult() {\n        return false;\n    }\n    update(tr, conf) {\n        let event = getUserEvent(tr), value = this;\n        if (event) value = value.handleUserEvent(tr, event, conf);\n        else if (tr.docChanged) value = value.handleChange(tr);\n        else if (tr.selection && value.state != 0 /* State.Inactive */ ) value = new ActiveSource(value.source, 0 /* State.Inactive */ );\n        for (let effect of tr.effects){\n            if (effect.is(startCompletionEffect)) value = new ActiveSource(value.source, 1 /* State.Pending */ , effect.value ? cur(tr.state) : -1);\n            else if (effect.is(closeCompletionEffect)) value = new ActiveSource(value.source, 0 /* State.Inactive */ );\n            else if (effect.is(setActiveEffect)) {\n                for (let active of effect.value)if (active.source == value.source) value = active;\n            }\n        }\n        return value;\n    }\n    handleUserEvent(tr, type, conf) {\n        return type == \"delete\" || !conf.activateOnTyping ? this.map(tr.changes) : new ActiveSource(this.source, 1 /* State.Pending */ );\n    }\n    handleChange(tr) {\n        return tr.changes.touchesRange(cur(tr.startState)) ? new ActiveSource(this.source, 0 /* State.Inactive */ ) : this.map(tr.changes);\n    }\n    map(changes) {\n        return changes.empty || this.explicitPos < 0 ? this : new ActiveSource(this.source, this.state, changes.mapPos(this.explicitPos));\n    }\n}\nclass ActiveResult extends ActiveSource {\n    constructor(source, explicitPos, result, from, to){\n        super(source, 2 /* State.Result */ , explicitPos);\n        this.result = result;\n        this.from = from;\n        this.to = to;\n    }\n    hasResult() {\n        return true;\n    }\n    handleUserEvent(tr, type, conf) {\n        var _a;\n        let from = tr.changes.mapPos(this.from), to = tr.changes.mapPos(this.to, 1);\n        let pos = cur(tr.state);\n        if ((this.explicitPos < 0 ? pos <= from : pos < this.from) || pos > to || type == \"delete\" && cur(tr.startState) == this.from) return new ActiveSource(this.source, type == \"input\" && conf.activateOnTyping ? 1 /* State.Pending */  : 0 /* State.Inactive */ );\n        let explicitPos = this.explicitPos < 0 ? -1 : tr.changes.mapPos(this.explicitPos), updated;\n        if (checkValid(this.result.validFor, tr.state, from, to)) return new ActiveResult(this.source, explicitPos, this.result, from, to);\n        if (this.result.update && (updated = this.result.update(this.result, from, to, new CompletionContext(tr.state, pos, explicitPos >= 0)))) return new ActiveResult(this.source, explicitPos, updated, updated.from, (_a = updated.to) !== null && _a !== void 0 ? _a : cur(tr.state));\n        return new ActiveSource(this.source, 1 /* State.Pending */ , explicitPos);\n    }\n    handleChange(tr) {\n        return tr.changes.touchesRange(this.from, this.to) ? new ActiveSource(this.source, 0 /* State.Inactive */ ) : this.map(tr.changes);\n    }\n    map(mapping) {\n        return mapping.empty ? this : new ActiveResult(this.source, this.explicitPos < 0 ? -1 : mapping.mapPos(this.explicitPos), this.result, mapping.mapPos(this.from), mapping.mapPos(this.to, 1));\n    }\n}\nfunction checkValid(validFor, state, from, to) {\n    if (!validFor) return false;\n    let text = state.sliceDoc(from, to);\n    return typeof validFor == \"function\" ? validFor(text, from, to, state) : ensureAnchor(validFor, true).test(text);\n}\nconst setActiveEffect = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define({\n    map (sources, mapping) {\n        return sources.map((s)=>s.map(mapping));\n    }\n});\nconst setSelectedEffect = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();\nconst completionState = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateField.define({\n    create () {\n        return CompletionState.start();\n    },\n    update (value, tr) {\n        return value.update(tr);\n    },\n    provide: (f)=>[\n            _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.showTooltip.from(f, (val)=>val.tooltip),\n            _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.contentAttributes.from(f, (state)=>state.attrs)\n        ]\n});\nfunction applyCompletion(view, option) {\n    const apply = option.completion.apply || option.completion.label;\n    let result = view.state.field(completionState).active.find((a)=>a.source == option.source);\n    if (!(result instanceof ActiveResult)) return false;\n    if (typeof apply == \"string\") view.dispatch(Object.assign(Object.assign({}, insertCompletionText(view.state, apply, result.from, result.to)), {\n        annotations: pickedCompletion.of(option.completion)\n    }));\n    else apply(view, option.completion, result.from, result.to);\n    return true;\n}\nconst createTooltip = /*@__PURE__*/ completionTooltip(completionState, applyCompletion);\n/**\nReturns a command that moves the completion selection forward or\nbackward by the given amount.\n*/ function moveCompletionSelection(forward, by = \"option\") {\n    return (view)=>{\n        let cState = view.state.field(completionState, false);\n        if (!cState || !cState.open || cState.open.disabled || Date.now() - cState.open.timestamp < view.state.facet(completionConfig).interactionDelay) return false;\n        let step = 1, tooltip;\n        if (by == \"page\" && (tooltip = (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.getTooltip)(view, cState.open.tooltip))) step = Math.max(2, Math.floor(tooltip.dom.offsetHeight / tooltip.dom.querySelector(\"li\").offsetHeight) - 1);\n        let { length } = cState.open.options;\n        let selected = cState.open.selected > -1 ? cState.open.selected + step * (forward ? 1 : -1) : forward ? 0 : length - 1;\n        if (selected < 0) selected = by == \"page\" ? 0 : length - 1;\n        else if (selected >= length) selected = by == \"page\" ? length - 1 : 0;\n        view.dispatch({\n            effects: setSelectedEffect.of(selected)\n        });\n        return true;\n    };\n}\n/**\nAccept the current completion.\n*/ const acceptCompletion = (view)=>{\n    let cState = view.state.field(completionState, false);\n    if (view.state.readOnly || !cState || !cState.open || cState.open.selected < 0 || cState.open.disabled || Date.now() - cState.open.timestamp < view.state.facet(completionConfig).interactionDelay) return false;\n    return applyCompletion(view, cState.open.options[cState.open.selected]);\n};\n/**\nExplicitly start autocompletion.\n*/ const startCompletion = (view)=>{\n    let cState = view.state.field(completionState, false);\n    if (!cState) return false;\n    view.dispatch({\n        effects: startCompletionEffect.of(true)\n    });\n    return true;\n};\n/**\nClose the currently active completion.\n*/ const closeCompletion = (view)=>{\n    let cState = view.state.field(completionState, false);\n    if (!cState || !cState.active.some((a)=>a.state != 0 /* State.Inactive */ )) return false;\n    view.dispatch({\n        effects: closeCompletionEffect.of(null)\n    });\n    return true;\n};\nclass RunningQuery {\n    constructor(active, context){\n        this.active = active;\n        this.context = context;\n        this.time = Date.now();\n        this.updates = [];\n        // Note that 'undefined' means 'not done yet', whereas 'null' means\n        // 'query returned null'.\n        this.done = undefined;\n    }\n}\nconst MaxUpdateCount = 50, MinAbortTime = 1000;\nconst completionPlugin = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.ViewPlugin.fromClass(class {\n    constructor(view){\n        this.view = view;\n        this.debounceUpdate = -1;\n        this.running = [];\n        this.debounceAccept = -1;\n        this.composing = 0 /* CompositionState.None */ ;\n        for (let active of view.state.field(completionState).active)if (active.state == 1 /* State.Pending */ ) this.startQuery(active);\n    }\n    update(update) {\n        let cState = update.state.field(completionState);\n        if (!update.selectionSet && !update.docChanged && update.startState.field(completionState) == cState) return;\n        let doesReset = update.transactions.some((tr)=>{\n            return (tr.selection || tr.docChanged) && !getUserEvent(tr);\n        });\n        for(let i = 0; i < this.running.length; i++){\n            let query = this.running[i];\n            if (doesReset || query.updates.length + update.transactions.length > MaxUpdateCount && Date.now() - query.time > MinAbortTime) {\n                for (let handler of query.context.abortListeners){\n                    try {\n                        handler();\n                    } catch (e) {\n                        (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.logException)(this.view.state, e);\n                    }\n                }\n                query.context.abortListeners = null;\n                this.running.splice(i--, 1);\n            } else {\n                query.updates.push(...update.transactions);\n            }\n        }\n        if (this.debounceUpdate > -1) clearTimeout(this.debounceUpdate);\n        this.debounceUpdate = cState.active.some((a)=>a.state == 1 /* State.Pending */  && !this.running.some((q)=>q.active.source == a.source)) ? setTimeout(()=>this.startUpdate(), 50) : -1;\n        if (this.composing != 0 /* CompositionState.None */ ) for (let tr of update.transactions){\n            if (getUserEvent(tr) == \"input\") this.composing = 2 /* CompositionState.Changed */ ;\n            else if (this.composing == 2 /* CompositionState.Changed */  && tr.selection) this.composing = 3 /* CompositionState.ChangedAndMoved */ ;\n        }\n    }\n    startUpdate() {\n        this.debounceUpdate = -1;\n        let { state } = this.view, cState = state.field(completionState);\n        for (let active of cState.active){\n            if (active.state == 1 /* State.Pending */  && !this.running.some((r)=>r.active.source == active.source)) this.startQuery(active);\n        }\n    }\n    startQuery(active) {\n        let { state } = this.view, pos = cur(state);\n        let context = new CompletionContext(state, pos, active.explicitPos == pos);\n        let pending = new RunningQuery(active, context);\n        this.running.push(pending);\n        Promise.resolve(active.source(context)).then((result)=>{\n            if (!pending.context.aborted) {\n                pending.done = result || null;\n                this.scheduleAccept();\n            }\n        }, (err)=>{\n            this.view.dispatch({\n                effects: closeCompletionEffect.of(null)\n            });\n            (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.logException)(this.view.state, err);\n        });\n    }\n    scheduleAccept() {\n        if (this.running.every((q)=>q.done !== undefined)) this.accept();\n        else if (this.debounceAccept < 0) this.debounceAccept = setTimeout(()=>this.accept(), this.view.state.facet(completionConfig).updateSyncTime);\n    }\n    // For each finished query in this.running, try to create a result\n    // or, if appropriate, restart the query.\n    accept() {\n        var _a;\n        if (this.debounceAccept > -1) clearTimeout(this.debounceAccept);\n        this.debounceAccept = -1;\n        let updated = [];\n        let conf = this.view.state.facet(completionConfig);\n        for(let i = 0; i < this.running.length; i++){\n            let query = this.running[i];\n            if (query.done === undefined) continue;\n            this.running.splice(i--, 1);\n            if (query.done) {\n                let active = new ActiveResult(query.active.source, query.active.explicitPos, query.done, query.done.from, (_a = query.done.to) !== null && _a !== void 0 ? _a : cur(query.updates.length ? query.updates[0].startState : this.view.state));\n                // Replay the transactions that happened since the start of\n                // the request and see if that preserves the result\n                for (let tr of query.updates)active = active.update(tr, conf);\n                if (active.hasResult()) {\n                    updated.push(active);\n                    continue;\n                }\n            }\n            let current = this.view.state.field(completionState).active.find((a)=>a.source == query.active.source);\n            if (current && current.state == 1 /* State.Pending */ ) {\n                if (query.done == null) {\n                    // Explicitly failed. Should clear the pending status if it\n                    // hasn't been re-set in the meantime.\n                    let active = new ActiveSource(query.active.source, 0 /* State.Inactive */ );\n                    for (let tr of query.updates)active = active.update(tr, conf);\n                    if (active.state != 1 /* State.Pending */ ) updated.push(active);\n                } else {\n                    // Cleared by subsequent transactions. Restart.\n                    this.startQuery(current);\n                }\n            }\n        }\n        if (updated.length) this.view.dispatch({\n            effects: setActiveEffect.of(updated)\n        });\n    }\n}, {\n    eventHandlers: {\n        blur (event) {\n            let state = this.view.state.field(completionState, false);\n            if (state && state.tooltip && this.view.state.facet(completionConfig).closeOnBlur) {\n                let dialog = state.open && (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.getTooltip)(this.view, state.open.tooltip);\n                if (!dialog || !dialog.dom.contains(event.relatedTarget)) this.view.dispatch({\n                    effects: closeCompletionEffect.of(null)\n                });\n            }\n        },\n        compositionstart () {\n            this.composing = 1 /* CompositionState.Started */ ;\n        },\n        compositionend () {\n            if (this.composing == 3 /* CompositionState.ChangedAndMoved */ ) {\n                // Safari fires compositionend events synchronously, possibly\n                // from inside an update, so dispatch asynchronously to avoid reentrancy\n                setTimeout(()=>this.view.dispatch({\n                        effects: startCompletionEffect.of(false)\n                    }), 20);\n            }\n            this.composing = 0 /* CompositionState.None */ ;\n        }\n    }\n});\nconst baseTheme = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.baseTheme({\n    \".cm-tooltip.cm-tooltip-autocomplete\": {\n        \"& > ul\": {\n            fontFamily: \"monospace\",\n            whiteSpace: \"nowrap\",\n            overflow: \"hidden auto\",\n            maxWidth_fallback: \"700px\",\n            maxWidth: \"min(700px, 95vw)\",\n            minWidth: \"250px\",\n            maxHeight: \"10em\",\n            height: \"100%\",\n            listStyle: \"none\",\n            margin: 0,\n            padding: 0,\n            \"& > li, & > completion-section\": {\n                padding: \"1px 3px\",\n                lineHeight: 1.2\n            },\n            \"& > li\": {\n                overflowX: \"hidden\",\n                textOverflow: \"ellipsis\",\n                cursor: \"pointer\"\n            },\n            \"& > completion-section\": {\n                display: \"list-item\",\n                borderBottom: \"1px solid silver\",\n                paddingLeft: \"0.5em\",\n                opacity: 0.7\n            }\n        }\n    },\n    \"&light .cm-tooltip-autocomplete ul li[aria-selected]\": {\n        background: \"#17c\",\n        color: \"white\"\n    },\n    \"&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]\": {\n        background: \"#777\"\n    },\n    \"&dark .cm-tooltip-autocomplete ul li[aria-selected]\": {\n        background: \"#347\",\n        color: \"white\"\n    },\n    \"&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]\": {\n        background: \"#444\"\n    },\n    \".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after\": {\n        content: '\"\\xb7\\xb7\\xb7\"',\n        opacity: 0.5,\n        display: \"block\",\n        textAlign: \"center\"\n    },\n    \".cm-tooltip.cm-completionInfo\": {\n        position: \"absolute\",\n        padding: \"3px 9px\",\n        width: \"max-content\",\n        maxWidth: `${400 /* Info.Width */ }px`,\n        boxSizing: \"border-box\"\n    },\n    \".cm-completionInfo.cm-completionInfo-left\": {\n        right: \"100%\"\n    },\n    \".cm-completionInfo.cm-completionInfo-right\": {\n        left: \"100%\"\n    },\n    \".cm-completionInfo.cm-completionInfo-left-narrow\": {\n        right: `${30 /* Info.Margin */ }px`\n    },\n    \".cm-completionInfo.cm-completionInfo-right-narrow\": {\n        left: `${30 /* Info.Margin */ }px`\n    },\n    \"&light .cm-snippetField\": {\n        backgroundColor: \"#00000022\"\n    },\n    \"&dark .cm-snippetField\": {\n        backgroundColor: \"#ffffff22\"\n    },\n    \".cm-snippetFieldPosition\": {\n        verticalAlign: \"text-top\",\n        width: 0,\n        height: \"1.15em\",\n        display: \"inline-block\",\n        margin: \"0 -0.7px -.7em\",\n        borderLeft: \"1.4px dotted #888\"\n    },\n    \".cm-completionMatchedText\": {\n        textDecoration: \"underline\"\n    },\n    \".cm-completionDetail\": {\n        marginLeft: \"0.5em\",\n        fontStyle: \"italic\"\n    },\n    \".cm-completionIcon\": {\n        fontSize: \"90%\",\n        width: \".8em\",\n        display: \"inline-block\",\n        textAlign: \"center\",\n        paddingRight: \".6em\",\n        opacity: \"0.6\",\n        boxSizing: \"content-box\"\n    },\n    \".cm-completionIcon-function, .cm-completionIcon-method\": {\n        \"&:after\": {\n            content: \"'ƒ'\"\n        }\n    },\n    \".cm-completionIcon-class\": {\n        \"&:after\": {\n            content: \"'○'\"\n        }\n    },\n    \".cm-completionIcon-interface\": {\n        \"&:after\": {\n            content: \"'◌'\"\n        }\n    },\n    \".cm-completionIcon-variable\": {\n        \"&:after\": {\n            content: \"'\\uD835\\uDC65'\"\n        }\n    },\n    \".cm-completionIcon-constant\": {\n        \"&:after\": {\n            content: \"'\\uD835\\uDC36'\"\n        }\n    },\n    \".cm-completionIcon-type\": {\n        \"&:after\": {\n            content: \"'\\uD835\\uDC61'\"\n        }\n    },\n    \".cm-completionIcon-enum\": {\n        \"&:after\": {\n            content: \"'∪'\"\n        }\n    },\n    \".cm-completionIcon-property\": {\n        \"&:after\": {\n            content: \"'□'\"\n        }\n    },\n    \".cm-completionIcon-keyword\": {\n        \"&:after\": {\n            content: \"'\\uD83D\\uDD11︎'\"\n        } // Disable emoji rendering\n    },\n    \".cm-completionIcon-namespace\": {\n        \"&:after\": {\n            content: \"'▢'\"\n        }\n    },\n    \".cm-completionIcon-text\": {\n        \"&:after\": {\n            content: \"'abc'\",\n            fontSize: \"50%\",\n            verticalAlign: \"middle\"\n        }\n    }\n});\nclass FieldPos {\n    constructor(field, line, from, to){\n        this.field = field;\n        this.line = line;\n        this.from = from;\n        this.to = to;\n    }\n}\nclass FieldRange {\n    constructor(field, from, to){\n        this.field = field;\n        this.from = from;\n        this.to = to;\n    }\n    map(changes) {\n        let from = changes.mapPos(this.from, -1, _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.MapMode.TrackDel);\n        let to = changes.mapPos(this.to, 1, _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.MapMode.TrackDel);\n        return from == null || to == null ? null : new FieldRange(this.field, from, to);\n    }\n}\nclass Snippet {\n    constructor(lines, fieldPositions){\n        this.lines = lines;\n        this.fieldPositions = fieldPositions;\n    }\n    instantiate(state, pos) {\n        let text = [], lineStart = [\n            pos\n        ];\n        let lineObj = state.doc.lineAt(pos), baseIndent = /^\\s*/.exec(lineObj.text)[0];\n        for (let line of this.lines){\n            if (text.length) {\n                let indent = baseIndent, tabs = /^\\t*/.exec(line)[0].length;\n                for(let i = 0; i < tabs; i++)indent += state.facet(_codemirror_language__WEBPACK_IMPORTED_MODULE_0__.indentUnit);\n                lineStart.push(pos + indent.length - tabs);\n                line = indent + line.slice(tabs);\n            }\n            text.push(line);\n            pos += line.length + 1;\n        }\n        let ranges = this.fieldPositions.map((pos)=>new FieldRange(pos.field, lineStart[pos.line] + pos.from, lineStart[pos.line] + pos.to));\n        return {\n            text,\n            ranges\n        };\n    }\n    static parse(template) {\n        let fields = [];\n        let lines = [], positions = [], m;\n        for (let line of template.split(/\\r\\n?|\\n/)){\n            while(m = /[#$]\\{(?:(\\d+)(?::([^}]*))?|([^}]*))\\}/.exec(line)){\n                let seq = m[1] ? +m[1] : null, name = m[2] || m[3] || \"\", found = -1;\n                for(let i = 0; i < fields.length; i++){\n                    if (seq != null ? fields[i].seq == seq : name ? fields[i].name == name : false) found = i;\n                }\n                if (found < 0) {\n                    let i = 0;\n                    while(i < fields.length && (seq == null || fields[i].seq != null && fields[i].seq < seq))i++;\n                    fields.splice(i, 0, {\n                        seq,\n                        name\n                    });\n                    found = i;\n                    for (let pos of positions)if (pos.field >= found) pos.field++;\n                }\n                positions.push(new FieldPos(found, lines.length, m.index, m.index + name.length));\n                line = line.slice(0, m.index) + name + line.slice(m.index + m[0].length);\n            }\n            for(let esc; esc = /\\\\([{}])/.exec(line);){\n                line = line.slice(0, esc.index) + esc[1] + line.slice(esc.index + esc[0].length);\n                for (let pos of positions)if (pos.line == lines.length && pos.from > esc.index) {\n                    pos.from--;\n                    pos.to--;\n                }\n            }\n            lines.push(line);\n        }\n        return new Snippet(lines, positions);\n    }\n}\nlet fieldMarker = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.widget({\n    widget: /*@__PURE__*/ new class extends _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.WidgetType {\n        toDOM() {\n            let span = document.createElement(\"span\");\n            span.className = \"cm-snippetFieldPosition\";\n            return span;\n        }\n        ignoreEvent() {\n            return false;\n        }\n    }\n});\nlet fieldRange = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.mark({\n    class: \"cm-snippetField\"\n});\nclass ActiveSnippet {\n    constructor(ranges, active){\n        this.ranges = ranges;\n        this.active = active;\n        this.deco = _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.set(ranges.map((r)=>(r.from == r.to ? fieldMarker : fieldRange).range(r.from, r.to)));\n    }\n    map(changes) {\n        let ranges = [];\n        for (let r of this.ranges){\n            let mapped = r.map(changes);\n            if (!mapped) return null;\n            ranges.push(mapped);\n        }\n        return new ActiveSnippet(ranges, this.active);\n    }\n    selectionInsideField(sel) {\n        return sel.ranges.every((range)=>this.ranges.some((r)=>r.field == this.active && r.from <= range.from && r.to >= range.to));\n    }\n}\nconst setActive = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define({\n    map (value, changes) {\n        return value && value.map(changes);\n    }\n});\nconst moveToField = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();\nconst snippetState = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateField.define({\n    create () {\n        return null;\n    },\n    update (value, tr) {\n        for (let effect of tr.effects){\n            if (effect.is(setActive)) return effect.value;\n            if (effect.is(moveToField) && value) return new ActiveSnippet(value.ranges, effect.value);\n        }\n        if (value && tr.docChanged) value = value.map(tr.changes);\n        if (value && tr.selection && !value.selectionInsideField(tr.selection)) value = null;\n        return value;\n    },\n    provide: (f)=>_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.decorations.from(f, (val)=>val ? val.deco : _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none)\n});\nfunction fieldSelection(ranges, field) {\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create(ranges.filter((r)=>r.field == field).map((r)=>_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(r.from, r.to)));\n}\n/**\nConvert a snippet template to a function that can\n[apply](https://codemirror.net/6/docs/ref/#autocomplete.Completion.apply) it. Snippets are written\nusing syntax like this:\n\n    \"for (let ${index} = 0; ${index} < ${end}; ${index}++) {\\n\\t${}\\n}\"\n\nEach `${}` placeholder (you may also use `#{}`) indicates a field\nthat the user can fill in. Its name, if any, will be the default\ncontent for the field.\n\nWhen the snippet is activated by calling the returned function,\nthe code is inserted at the given position. Newlines in the\ntemplate are indented by the indentation of the start line, plus\none [indent unit](https://codemirror.net/6/docs/ref/#language.indentUnit) per tab character after\nthe newline.\n\nOn activation, (all instances of) the first field are selected.\nThe user can move between fields with Tab and Shift-Tab as long as\nthe fields are active. Moving to the last field or moving the\ncursor out of the current field deactivates the fields.\n\nThe order of fields defaults to textual order, but you can add\nnumbers to placeholders (`${1}` or `${1:defaultText}`) to provide\na custom order.\n\nTo include a literal `{` or `}` in your template, put a backslash\nin front of it. This will be removed and the brace will not be\ninterpreted as indicating a placeholder.\n*/ function snippet(template) {\n    let snippet = Snippet.parse(template);\n    return (editor, completion, from, to)=>{\n        let { text, ranges } = snippet.instantiate(editor.state, from);\n        let spec = {\n            changes: {\n                from,\n                to,\n                insert: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Text.of(text)\n            },\n            scrollIntoView: true,\n            annotations: completion ? pickedCompletion.of(completion) : undefined\n        };\n        if (ranges.length) spec.selection = fieldSelection(ranges, 0);\n        if (ranges.length > 1) {\n            let active = new ActiveSnippet(ranges, 0);\n            let effects = spec.effects = [\n                setActive.of(active)\n            ];\n            if (editor.state.field(snippetState, false) === undefined) effects.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.appendConfig.of([\n                snippetState,\n                addSnippetKeymap,\n                snippetPointerHandler,\n                baseTheme\n            ]));\n        }\n        editor.dispatch(editor.state.update(spec));\n    };\n}\nfunction moveField(dir) {\n    return ({ state, dispatch })=>{\n        let active = state.field(snippetState, false);\n        if (!active || dir < 0 && active.active == 0) return false;\n        let next = active.active + dir, last = dir > 0 && !active.ranges.some((r)=>r.field == next + dir);\n        dispatch(state.update({\n            selection: fieldSelection(active.ranges, next),\n            effects: setActive.of(last ? null : new ActiveSnippet(active.ranges, next)),\n            scrollIntoView: true\n        }));\n        return true;\n    };\n}\n/**\nA command that clears the active snippet, if any.\n*/ const clearSnippet = ({ state, dispatch })=>{\n    let active = state.field(snippetState, false);\n    if (!active) return false;\n    dispatch(state.update({\n        effects: setActive.of(null)\n    }));\n    return true;\n};\n/**\nMove to the next snippet field, if available.\n*/ const nextSnippetField = /*@__PURE__*/ moveField(1);\n/**\nMove to the previous snippet field, if available.\n*/ const prevSnippetField = /*@__PURE__*/ moveField(-1);\n/**\nCheck if there is an active snippet with a next field for\n`nextSnippetField` to move to.\n*/ function hasNextSnippetField(state) {\n    let active = state.field(snippetState, false);\n    return !!(active && active.ranges.some((r)=>r.field == active.active + 1));\n}\n/**\nReturns true if there is an active snippet and a previous field\nfor `prevSnippetField` to move to.\n*/ function hasPrevSnippetField(state) {\n    let active = state.field(snippetState, false);\n    return !!(active && active.active > 0);\n}\nconst defaultSnippetKeymap = [\n    {\n        key: \"Tab\",\n        run: nextSnippetField,\n        shift: prevSnippetField\n    },\n    {\n        key: \"Escape\",\n        run: clearSnippet\n    }\n];\n/**\nA facet that can be used to configure the key bindings used by\nsnippets. The default binds Tab to\n[`nextSnippetField`](https://codemirror.net/6/docs/ref/#autocomplete.nextSnippetField), Shift-Tab to\n[`prevSnippetField`](https://codemirror.net/6/docs/ref/#autocomplete.prevSnippetField), and Escape\nto [`clearSnippet`](https://codemirror.net/6/docs/ref/#autocomplete.clearSnippet).\n*/ const snippetKeymap = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define({\n    combine (maps) {\n        return maps.length ? maps[0] : defaultSnippetKeymap;\n    }\n});\nconst addSnippetKeymap = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Prec.highest(/*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.keymap.compute([\n    snippetKeymap\n], (state)=>state.facet(snippetKeymap)));\n/**\nCreate a completion from a snippet. Returns an object with the\nproperties from `completion`, plus an `apply` function that\napplies the snippet.\n*/ function snippetCompletion(template, completion) {\n    return Object.assign(Object.assign({}, completion), {\n        apply: snippet(template)\n    });\n}\nconst snippetPointerHandler = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.domEventHandlers({\n    mousedown (event, view) {\n        let active = view.state.field(snippetState, false), pos;\n        if (!active || (pos = view.posAtCoords({\n            x: event.clientX,\n            y: event.clientY\n        })) == null) return false;\n        let match = active.ranges.find((r)=>r.from <= pos && r.to >= pos);\n        if (!match || match.field == active.active) return false;\n        view.dispatch({\n            selection: fieldSelection(active.ranges, match.field),\n            effects: setActive.of(active.ranges.some((r)=>r.field > match.field) ? new ActiveSnippet(active.ranges, match.field) : null),\n            scrollIntoView: true\n        });\n        return true;\n    }\n});\nfunction wordRE(wordChars) {\n    let escaped = wordChars.replace(/[\\]\\-\\\\]/g, \"\\\\$&\");\n    try {\n        return new RegExp(`[\\\\p{Alphabetic}\\\\p{Number}_${escaped}]+`, \"ug\");\n    } catch (_a) {\n        return new RegExp(`[\\w${escaped}]`, \"g\");\n    }\n}\nfunction mapRE(re, f) {\n    return new RegExp(f(re.source), re.unicode ? \"u\" : \"\");\n}\nconst wordCaches = /*@__PURE__*/ Object.create(null);\nfunction wordCache(wordChars) {\n    return wordCaches[wordChars] || (wordCaches[wordChars] = new WeakMap);\n}\nfunction storeWords(doc, wordRE, result, seen, ignoreAt) {\n    for(let lines = doc.iterLines(), pos = 0; !lines.next().done;){\n        let { value } = lines, m;\n        wordRE.lastIndex = 0;\n        while(m = wordRE.exec(value)){\n            if (!seen[m[0]] && pos + m.index != ignoreAt) {\n                result.push({\n                    type: \"text\",\n                    label: m[0]\n                });\n                seen[m[0]] = true;\n                if (result.length >= 2000 /* C.MaxList */ ) return;\n            }\n        }\n        pos += value.length + 1;\n    }\n}\nfunction collectWords(doc, cache, wordRE, to, ignoreAt) {\n    let big = doc.length >= 1000 /* C.MinCacheLen */ ;\n    let cached = big && cache.get(doc);\n    if (cached) return cached;\n    let result = [], seen = Object.create(null);\n    if (doc.children) {\n        let pos = 0;\n        for (let ch of doc.children){\n            if (ch.length >= 1000 /* C.MinCacheLen */ ) {\n                for (let c of collectWords(ch, cache, wordRE, to - pos, ignoreAt - pos)){\n                    if (!seen[c.label]) {\n                        seen[c.label] = true;\n                        result.push(c);\n                    }\n                }\n            } else {\n                storeWords(ch, wordRE, result, seen, ignoreAt - pos);\n            }\n            pos += ch.length + 1;\n        }\n    } else {\n        storeWords(doc, wordRE, result, seen, ignoreAt);\n    }\n    if (big && result.length < 2000 /* C.MaxList */ ) cache.set(doc, result);\n    return result;\n}\n/**\nA completion source that will scan the document for words (using a\n[character categorizer](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer)), and\nreturn those as completions.\n*/ const completeAnyWord = (context)=>{\n    let wordChars = context.state.languageDataAt(\"wordChars\", context.pos).join(\"\");\n    let re = wordRE(wordChars);\n    let token = context.matchBefore(mapRE(re, (s)=>s + \"$\"));\n    if (!token && !context.explicit) return null;\n    let from = token ? token.from : context.pos;\n    let options = collectWords(context.state.doc, wordCache(wordChars), re, 50000 /* C.Range */ , from);\n    return {\n        from,\n        options,\n        validFor: mapRE(re, (s)=>\"^\" + s)\n    };\n};\nconst defaults = {\n    brackets: [\n        \"(\",\n        \"[\",\n        \"{\",\n        \"'\",\n        '\"'\n    ],\n    before: \")]}:;>\",\n    stringPrefixes: []\n};\nconst closeBracketEffect = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define({\n    map (value, mapping) {\n        let mapped = mapping.mapPos(value, -1, _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.MapMode.TrackAfter);\n        return mapped == null ? undefined : mapped;\n    }\n});\nconst closedBracket = /*@__PURE__*/ new class extends _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.RangeValue {\n};\nclosedBracket.startSide = 1;\nclosedBracket.endSide = -1;\nconst bracketState = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateField.define({\n    create () {\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.RangeSet.empty;\n    },\n    update (value, tr) {\n        value = value.map(tr.changes);\n        if (tr.selection) {\n            let line = tr.state.doc.lineAt(tr.selection.main.head);\n            value = value.update({\n                filter: (from)=>from >= line.from && from <= line.to\n            });\n        }\n        for (let effect of tr.effects)if (effect.is(closeBracketEffect)) value = value.update({\n            add: [\n                closedBracket.range(effect.value, effect.value + 1)\n            ]\n        });\n        return value;\n    }\n});\n/**\nExtension to enable bracket-closing behavior. When a closeable\nbracket is typed, its closing bracket is immediately inserted\nafter the cursor. When closing a bracket directly in front of a\nclosing bracket inserted by the extension, the cursor moves over\nthat bracket.\n*/ function closeBrackets() {\n    return [\n        inputHandler,\n        bracketState\n    ];\n}\nconst definedClosing = \"()[]{}<>\";\nfunction closing(ch) {\n    for(let i = 0; i < definedClosing.length; i += 2)if (definedClosing.charCodeAt(i) == ch) return definedClosing.charAt(i + 1);\n    return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.fromCodePoint)(ch < 128 ? ch : ch + 1);\n}\nfunction config(state, pos) {\n    return state.languageDataAt(\"closeBrackets\", pos)[0] || defaults;\n}\nconst android = typeof navigator == \"object\" && /*@__PURE__*/ /Android\\b/.test(navigator.userAgent);\nconst inputHandler = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.inputHandler.of((view, from, to, insert)=>{\n    if ((android ? view.composing : view.compositionStarted) || view.state.readOnly) return false;\n    let sel = view.state.selection.main;\n    if (insert.length > 2 || insert.length == 2 && (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)((0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(insert, 0)) == 1 || from != sel.from || to != sel.to) return false;\n    let tr = insertBracket(view.state, insert);\n    if (!tr) return false;\n    view.dispatch(tr);\n    return true;\n});\n/**\nCommand that implements deleting a pair of matching brackets when\nthe cursor is between them.\n*/ const deleteBracketPair = ({ state, dispatch })=>{\n    if (state.readOnly) return false;\n    let conf = config(state, state.selection.main.head);\n    let tokens = conf.brackets || defaults.brackets;\n    let dont = null, changes = state.changeByRange((range)=>{\n        if (range.empty) {\n            let before = prevChar(state.doc, range.head);\n            for (let token of tokens){\n                if (token == before && nextChar(state.doc, range.head) == closing((0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(token, 0))) return {\n                    changes: {\n                        from: range.head - token.length,\n                        to: range.head + token.length\n                    },\n                    range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(range.head - token.length)\n                };\n            }\n        }\n        return {\n            range: dont = range\n        };\n    });\n    if (!dont) dispatch(state.update(changes, {\n        scrollIntoView: true,\n        userEvent: \"delete.backward\"\n    }));\n    return !dont;\n};\n/**\nClose-brackets related key bindings. Binds Backspace to\n[`deleteBracketPair`](https://codemirror.net/6/docs/ref/#autocomplete.deleteBracketPair).\n*/ const closeBracketsKeymap = [\n    {\n        key: \"Backspace\",\n        run: deleteBracketPair\n    }\n];\n/**\nImplements the extension's behavior on text insertion. If the\ngiven string counts as a bracket in the language around the\nselection, and replacing the selection with it requires custom\nbehavior (inserting a closing version or skipping past a\npreviously-closed bracket), this function returns a transaction\nrepresenting that custom behavior. (You only need this if you want\nto programmatically insert brackets—the\n[`closeBrackets`](https://codemirror.net/6/docs/ref/#autocomplete.closeBrackets) extension will\ntake care of running this for user input.)\n*/ function insertBracket(state, bracket) {\n    let conf = config(state, state.selection.main.head);\n    let tokens = conf.brackets || defaults.brackets;\n    for (let tok of tokens){\n        let closed = closing((0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(tok, 0));\n        if (bracket == tok) return closed == tok ? handleSame(state, tok, tokens.indexOf(tok + tok + tok) > -1, conf) : handleOpen(state, tok, closed, conf.before || defaults.before);\n        if (bracket == closed && closedBracketAt(state, state.selection.main.from)) return handleClose(state, tok, closed);\n    }\n    return null;\n}\nfunction closedBracketAt(state, pos) {\n    let found = false;\n    state.field(bracketState).between(0, state.doc.length, (from)=>{\n        if (from == pos) found = true;\n    });\n    return found;\n}\nfunction nextChar(doc, pos) {\n    let next = doc.sliceString(pos, pos + 2);\n    return next.slice(0, (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)((0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(next, 0)));\n}\nfunction prevChar(doc, pos) {\n    let prev = doc.sliceString(pos - 2, pos);\n    return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)((0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(prev, 0)) == prev.length ? prev : prev.slice(1);\n}\nfunction handleOpen(state, open, close, closeBefore) {\n    let dont = null, changes = state.changeByRange((range)=>{\n        if (!range.empty) return {\n            changes: [\n                {\n                    insert: open,\n                    from: range.from\n                },\n                {\n                    insert: close,\n                    from: range.to\n                }\n            ],\n            effects: closeBracketEffect.of(range.to + open.length),\n            range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(range.anchor + open.length, range.head + open.length)\n        };\n        let next = nextChar(state.doc, range.head);\n        if (!next || /\\s/.test(next) || closeBefore.indexOf(next) > -1) return {\n            changes: {\n                insert: open + close,\n                from: range.head\n            },\n            effects: closeBracketEffect.of(range.head + open.length),\n            range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(range.head + open.length)\n        };\n        return {\n            range: dont = range\n        };\n    });\n    return dont ? null : state.update(changes, {\n        scrollIntoView: true,\n        userEvent: \"input.type\"\n    });\n}\nfunction handleClose(state, _open, close) {\n    let dont = null, changes = state.changeByRange((range)=>{\n        if (range.empty && nextChar(state.doc, range.head) == close) return {\n            changes: {\n                from: range.head,\n                to: range.head + close.length,\n                insert: close\n            },\n            range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(range.head + close.length)\n        };\n        return dont = {\n            range\n        };\n    });\n    return dont ? null : state.update(changes, {\n        scrollIntoView: true,\n        userEvent: \"input.type\"\n    });\n}\n// Handles cases where the open and close token are the same, and\n// possibly triple quotes (as in `\"\"\"abc\"\"\"`-style quoting).\nfunction handleSame(state, token, allowTriple, config) {\n    let stringPrefixes = config.stringPrefixes || defaults.stringPrefixes;\n    let dont = null, changes = state.changeByRange((range)=>{\n        if (!range.empty) return {\n            changes: [\n                {\n                    insert: token,\n                    from: range.from\n                },\n                {\n                    insert: token,\n                    from: range.to\n                }\n            ],\n            effects: closeBracketEffect.of(range.to + token.length),\n            range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(range.anchor + token.length, range.head + token.length)\n        };\n        let pos = range.head, next = nextChar(state.doc, pos), start;\n        if (next == token) {\n            if (nodeStart(state, pos)) {\n                return {\n                    changes: {\n                        insert: token + token,\n                        from: pos\n                    },\n                    effects: closeBracketEffect.of(pos + token.length),\n                    range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(pos + token.length)\n                };\n            } else if (closedBracketAt(state, pos)) {\n                let isTriple = allowTriple && state.sliceDoc(pos, pos + token.length * 3) == token + token + token;\n                let content = isTriple ? token + token + token : token;\n                return {\n                    changes: {\n                        from: pos,\n                        to: pos + content.length,\n                        insert: content\n                    },\n                    range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(pos + content.length)\n                };\n            }\n        } else if (allowTriple && state.sliceDoc(pos - 2 * token.length, pos) == token + token && (start = canStartStringAt(state, pos - 2 * token.length, stringPrefixes)) > -1 && nodeStart(state, start)) {\n            return {\n                changes: {\n                    insert: token + token + token + token,\n                    from: pos\n                },\n                effects: closeBracketEffect.of(pos + token.length),\n                range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(pos + token.length)\n            };\n        } else if (state.charCategorizer(pos)(next) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word) {\n            if (canStartStringAt(state, pos, stringPrefixes) > -1 && !probablyInString(state, pos, token, stringPrefixes)) return {\n                changes: {\n                    insert: token + token,\n                    from: pos\n                },\n                effects: closeBracketEffect.of(pos + token.length),\n                range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(pos + token.length)\n            };\n        }\n        return {\n            range: dont = range\n        };\n    });\n    return dont ? null : state.update(changes, {\n        scrollIntoView: true,\n        userEvent: \"input.type\"\n    });\n}\nfunction nodeStart(state, pos) {\n    let tree = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_0__.syntaxTree)(state).resolveInner(pos + 1);\n    return tree.parent && tree.from == pos;\n}\nfunction probablyInString(state, pos, quoteToken, prefixes) {\n    let node = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_0__.syntaxTree)(state).resolveInner(pos, -1);\n    let maxPrefix = prefixes.reduce((m, p)=>Math.max(m, p.length), 0);\n    for(let i = 0; i < 5; i++){\n        let start = state.sliceDoc(node.from, Math.min(node.to, node.from + quoteToken.length + maxPrefix));\n        let quotePos = start.indexOf(quoteToken);\n        if (!quotePos || quotePos > -1 && prefixes.indexOf(start.slice(0, quotePos)) > -1) {\n            let first = node.firstChild;\n            while(first && first.from == node.from && first.to - first.from > quoteToken.length + quotePos){\n                if (state.sliceDoc(first.to - quoteToken.length, first.to) == quoteToken) return false;\n                first = first.firstChild;\n            }\n            return true;\n        }\n        let parent = node.to == pos && node.parent;\n        if (!parent) break;\n        node = parent;\n    }\n    return false;\n}\nfunction canStartStringAt(state, pos, prefixes) {\n    let charCat = state.charCategorizer(pos);\n    if (charCat(state.sliceDoc(pos - 1, pos)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word) return pos;\n    for (let prefix of prefixes){\n        let start = pos - prefix.length;\n        if (state.sliceDoc(start, pos) == prefix && charCat(state.sliceDoc(start - 1, start)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word) return start;\n    }\n    return -1;\n}\n/**\nReturns an extension that enables autocompletion.\n*/ function autocompletion(config = {}) {\n    return [\n        completionState,\n        completionConfig.of(config),\n        completionPlugin,\n        completionKeymapExt,\n        baseTheme\n    ];\n}\n/**\nBasic keybindings for autocompletion.\n\n - Ctrl-Space: [`startCompletion`](https://codemirror.net/6/docs/ref/#autocomplete.startCompletion)\n - Escape: [`closeCompletion`](https://codemirror.net/6/docs/ref/#autocomplete.closeCompletion)\n - ArrowDown: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(true)`\n - ArrowUp: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(false)`\n - PageDown: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(true, \"page\")`\n - PageDown: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(true, \"page\")`\n - Enter: [`acceptCompletion`](https://codemirror.net/6/docs/ref/#autocomplete.acceptCompletion)\n*/ const completionKeymap = [\n    {\n        key: \"Ctrl-Space\",\n        run: startCompletion\n    },\n    {\n        key: \"Escape\",\n        run: closeCompletion\n    },\n    {\n        key: \"ArrowDown\",\n        run: /*@__PURE__*/ moveCompletionSelection(true)\n    },\n    {\n        key: \"ArrowUp\",\n        run: /*@__PURE__*/ moveCompletionSelection(false)\n    },\n    {\n        key: \"PageDown\",\n        run: /*@__PURE__*/ moveCompletionSelection(true, \"page\")\n    },\n    {\n        key: \"PageUp\",\n        run: /*@__PURE__*/ moveCompletionSelection(false, \"page\")\n    },\n    {\n        key: \"Enter\",\n        run: acceptCompletion\n    }\n];\nconst completionKeymapExt = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Prec.highest(/*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.keymap.computeN([\n    completionConfig\n], (state)=>state.facet(completionConfig).defaultKeymap ? [\n        completionKeymap\n    ] : []));\n/**\nGet the current completion status. When completions are available,\nthis will return `\"active\"`. When completions are pending (in the\nprocess of being queried), this returns `\"pending\"`. Otherwise, it\nreturns `null`.\n*/ function completionStatus(state) {\n    let cState = state.field(completionState, false);\n    return cState && cState.active.some((a)=>a.state == 1 /* State.Pending */ ) ? \"pending\" : cState && cState.active.some((a)=>a.state != 0 /* State.Inactive */ ) ? \"active\" : null;\n}\nconst completionArrayCache = /*@__PURE__*/ new WeakMap;\n/**\nReturns the available completions as an array.\n*/ function currentCompletions(state) {\n    var _a;\n    let open = (_a = state.field(completionState, false)) === null || _a === void 0 ? void 0 : _a.open;\n    if (!open || open.disabled) return [];\n    let completions = completionArrayCache.get(open.options);\n    if (!completions) completionArrayCache.set(open.options, completions = open.options.map((o)=>o.completion));\n    return completions;\n}\n/**\nReturn the currently selected completion, if any.\n*/ function selectedCompletion(state) {\n    var _a;\n    let open = (_a = state.field(completionState, false)) === null || _a === void 0 ? void 0 : _a.open;\n    return open && !open.disabled && open.selected >= 0 ? open.options[open.selected].completion : null;\n}\n/**\nReturns the currently selected position in the active completion\nlist, or null if no completions are active.\n*/ function selectedCompletionIndex(state) {\n    var _a;\n    let open = (_a = state.field(completionState, false)) === null || _a === void 0 ? void 0 : _a.open;\n    return open && !open.disabled && open.selected >= 0 ? open.selected : null;\n}\n/**\nCreate an effect that can be attached to a transaction to change\nthe currently selected completion.\n*/ function setSelectedCompletion(index) {\n    return setSelectedEffect.of(index);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvYXV0b2NvbXBsZXRlL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQW1OO0FBQ3ZFO0FBQzlFO0FBRTlEOztBQUVBLEdBQ0EsTUFBTTBCO0lBQ0Y7Ozs7SUFJQSxHQUNBQyxZQUNBOztJQUVBLEdBQ0FDLEtBQUssRUFDTDs7SUFFQSxHQUNBQyxHQUFHLEVBQ0g7Ozs7O0lBS0EsR0FDQUMsUUFBUSxDQUFFO1FBQ04sSUFBSSxDQUFDRixLQUFLLEdBQUdBO1FBQ2IsSUFBSSxDQUFDQyxHQUFHLEdBQUdBO1FBQ1gsSUFBSSxDQUFDQyxRQUFRLEdBQUdBO1FBQ2hCOztRQUVBLEdBQ0EsSUFBSSxDQUFDQyxjQUFjLEdBQUcsRUFBRTtJQUM1QjtJQUNBOzs7SUFHQSxHQUNBQyxZQUFZQyxLQUFLLEVBQUU7UUFDZixJQUFJQyxRQUFRVixnRUFBVUEsQ0FBQyxJQUFJLENBQUNJLEtBQUssRUFBRU8sWUFBWSxDQUFDLElBQUksQ0FBQ04sR0FBRyxFQUFFLENBQUM7UUFDM0QsTUFBT0ssU0FBU0QsTUFBTUcsT0FBTyxDQUFDRixNQUFNRyxJQUFJLElBQUksRUFDeENILFFBQVFBLE1BQU1JLE1BQU07UUFDeEIsT0FBT0osUUFBUTtZQUFFSyxNQUFNTCxNQUFNSyxJQUFJO1lBQUVDLElBQUksSUFBSSxDQUFDWCxHQUFHO1lBQzNDWSxNQUFNLElBQUksQ0FBQ2IsS0FBSyxDQUFDYyxRQUFRLENBQUNSLE1BQU1LLElBQUksRUFBRSxJQUFJLENBQUNWLEdBQUc7WUFDOUNjLE1BQU1ULE1BQU1TLElBQUk7UUFBQyxJQUFJO0lBQzdCO0lBQ0E7OztJQUdBLEdBQ0FDLFlBQVlDLElBQUksRUFBRTtRQUNkLElBQUlDLE9BQU8sSUFBSSxDQUFDbEIsS0FBSyxDQUFDbUIsR0FBRyxDQUFDQyxNQUFNLENBQUMsSUFBSSxDQUFDbkIsR0FBRztRQUN6QyxJQUFJb0Is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b3IvLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvYXV0b2NvbXBsZXRlL2Rpc3QvaW5kZXguanM/YTEwMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBbm5vdGF0aW9uLCBTdGF0ZUVmZmVjdCwgRWRpdG9yU2VsZWN0aW9uLCBjb2RlUG9pbnRBdCwgY29kZVBvaW50U2l6ZSwgZnJvbUNvZGVQb2ludCwgRmFjZXQsIGNvbWJpbmVDb25maWcsIFN0YXRlRmllbGQsIFByZWMsIFRleHQsIE1hcE1vZGUsIFJhbmdlVmFsdWUsIFJhbmdlU2V0LCBDaGFyQ2F0ZWdvcnkgfSBmcm9tICdAY29kZW1pcnJvci9zdGF0ZSc7XG5pbXBvcnQgeyBEaXJlY3Rpb24sIGxvZ0V4Y2VwdGlvbiwgc2hvd1Rvb2x0aXAsIEVkaXRvclZpZXcsIFZpZXdQbHVnaW4sIGdldFRvb2x0aXAsIERlY29yYXRpb24sIFdpZGdldFR5cGUsIGtleW1hcCB9IGZyb20gJ0Bjb2RlbWlycm9yL3ZpZXcnO1xuaW1wb3J0IHsgc3ludGF4VHJlZSwgaW5kZW50VW5pdCB9IGZyb20gJ0Bjb2RlbWlycm9yL2xhbmd1YWdlJztcblxuLyoqXG5BbiBpbnN0YW5jZSBvZiB0aGlzIGlzIHBhc3NlZCB0byBjb21wbGV0aW9uIHNvdXJjZSBmdW5jdGlvbnMuXG4qL1xuY2xhc3MgQ29tcGxldGlvbkNvbnRleHQge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIG5ldyBjb21wbGV0aW9uIGNvbnRleHQuIChNb3N0bHkgdXNlZnVsIGZvciB0ZXN0aW5nXG4gICAgY29tcGxldGlvbiBzb3VyY2Vz4oCUaW4gdGhlIGVkaXRvciwgdGhlIGV4dGVuc2lvbiB3aWxsIGNyZWF0ZVxuICAgIHRoZXNlIGZvciB5b3UuKVxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIGVkaXRvciBzdGF0ZSB0aGF0IHRoZSBjb21wbGV0aW9uIGhhcHBlbnMgaW4uXG4gICAgKi9cbiAgICBzdGF0ZSwgXG4gICAgLyoqXG4gICAgVGhlIHBvc2l0aW9uIGF0IHdoaWNoIHRoZSBjb21wbGV0aW9uIGlzIGhhcHBlbmluZy5cbiAgICAqL1xuICAgIHBvcywgXG4gICAgLyoqXG4gICAgSW5kaWNhdGVzIHdoZXRoZXIgY29tcGxldGlvbiB3YXMgYWN0aXZhdGVkIGV4cGxpY2l0bHksIG9yXG4gICAgaW1wbGljaXRseSBieSB0eXBpbmcuIFRoZSB1c3VhbCB3YXkgdG8gcmVzcG9uZCB0byB0aGlzIGlzIHRvXG4gICAgb25seSByZXR1cm4gY29tcGxldGlvbnMgd2hlbiBlaXRoZXIgdGhlcmUgaXMgcGFydCBvZiBhXG4gICAgY29tcGxldGFibGUgZW50aXR5IGJlZm9yZSB0aGUgY3Vyc29yLCBvciBgZXhwbGljaXRgIGlzIHRydWUuXG4gICAgKi9cbiAgICBleHBsaWNpdCkge1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICB0aGlzLmV4cGxpY2l0ID0gZXhwbGljaXQ7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hYm9ydExpc3RlbmVycyA9IFtdO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGV4dGVudCwgY29udGVudCwgYW5kIChpZiB0aGVyZSBpcyBhIHRva2VuKSB0eXBlIG9mIHRoZVxuICAgIHRva2VuIGJlZm9yZSBgdGhpcy5wb3NgLlxuICAgICovXG4gICAgdG9rZW5CZWZvcmUodHlwZXMpIHtcbiAgICAgICAgbGV0IHRva2VuID0gc3ludGF4VHJlZSh0aGlzLnN0YXRlKS5yZXNvbHZlSW5uZXIodGhpcy5wb3MsIC0xKTtcbiAgICAgICAgd2hpbGUgKHRva2VuICYmIHR5cGVzLmluZGV4T2YodG9rZW4ubmFtZSkgPCAwKVxuICAgICAgICAgICAgdG9rZW4gPSB0b2tlbi5wYXJlbnQ7XG4gICAgICAgIHJldHVybiB0b2tlbiA/IHsgZnJvbTogdG9rZW4uZnJvbSwgdG86IHRoaXMucG9zLFxuICAgICAgICAgICAgdGV4dDogdGhpcy5zdGF0ZS5zbGljZURvYyh0b2tlbi5mcm9tLCB0aGlzLnBvcyksXG4gICAgICAgICAgICB0eXBlOiB0b2tlbi50eXBlIH0gOiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIG1hdGNoIG9mIHRoZSBnaXZlbiBleHByZXNzaW9uIGRpcmVjdGx5IGJlZm9yZSB0aGVcbiAgICBjdXJzb3IuXG4gICAgKi9cbiAgICBtYXRjaEJlZm9yZShleHByKSB7XG4gICAgICAgIGxldCBsaW5lID0gdGhpcy5zdGF0ZS5kb2MubGluZUF0KHRoaXMucG9zKTtcbiAgICAgICAgbGV0IHN0YXJ0ID0gTWF0aC5tYXgobGluZS5mcm9tLCB0aGlzLnBvcyAtIDI1MCk7XG4gICAgICAgIGxldCBzdHIgPSBsaW5lLnRleHQuc2xpY2Uoc3RhcnQgLSBsaW5lLmZyb20sIHRoaXMucG9zIC0gbGluZS5mcm9tKTtcbiAgICAgICAgbGV0IGZvdW5kID0gc3RyLnNlYXJjaChlbnN1cmVBbmNob3IoZXhwciwgZmFsc2UpKTtcbiAgICAgICAgcmV0dXJuIGZvdW5kIDwgMCA/IG51bGwgOiB7IGZyb206IHN0YXJ0ICsgZm91bmQsIHRvOiB0aGlzLnBvcywgdGV4dDogc3RyLnNsaWNlKGZvdW5kKSB9O1xuICAgIH1cbiAgICAvKipcbiAgICBZaWVsZHMgdHJ1ZSB3aGVuIHRoZSBxdWVyeSBoYXMgYmVlbiBhYm9ydGVkLiBDYW4gYmUgdXNlZnVsIGluXG4gICAgYXN5bmNocm9ub3VzIHF1ZXJpZXMgdG8gYXZvaWQgZG9pbmcgd29yayB0aGF0IHdpbGwgYmUgaWdub3JlZC5cbiAgICAqL1xuICAgIGdldCBhYm9ydGVkKCkgeyByZXR1cm4gdGhpcy5hYm9ydExpc3RlbmVycyA9PSBudWxsOyB9XG4gICAgLyoqXG4gICAgQWxsb3dzIHlvdSB0byByZWdpc3RlciBhYm9ydCBoYW5kbGVycywgd2hpY2ggd2lsbCBiZSBjYWxsZWQgd2hlblxuICAgIHRoZSBxdWVyeSBpc1xuICAgIFthYm9ydGVkXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5Db21wbGV0aW9uQ29udGV4dC5hYm9ydGVkKS5cbiAgICAqL1xuICAgIGFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKHR5cGUgPT0gXCJhYm9ydFwiICYmIHRoaXMuYWJvcnRMaXN0ZW5lcnMpXG4gICAgICAgICAgICB0aGlzLmFib3J0TGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRvU2V0KGNoYXJzKSB7XG4gICAgbGV0IGZsYXQgPSBPYmplY3Qua2V5cyhjaGFycykuam9pbihcIlwiKTtcbiAgICBsZXQgd29yZHMgPSAvXFx3Ly50ZXN0KGZsYXQpO1xuICAgIGlmICh3b3JkcylcbiAgICAgICAgZmxhdCA9IGZsYXQucmVwbGFjZSgvXFx3L2csIFwiXCIpO1xuICAgIHJldHVybiBgWyR7d29yZHMgPyBcIlxcXFx3XCIgOiBcIlwifSR7ZmxhdC5yZXBsYWNlKC9bXlxcd1xcc10vZywgXCJcXFxcJCZcIil9XWA7XG59XG5mdW5jdGlvbiBwcmVmaXhNYXRjaChvcHRpb25zKSB7XG4gICAgbGV0IGZpcnN0ID0gT2JqZWN0LmNyZWF0ZShudWxsKSwgcmVzdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZm9yIChsZXQgeyBsYWJlbCB9IG9mIG9wdGlvbnMpIHtcbiAgICAgICAgZmlyc3RbbGFiZWxbMF1dID0gdHJ1ZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBsYWJlbC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHJlc3RbbGFiZWxbaV1dID0gdHJ1ZTtcbiAgICB9XG4gICAgbGV0IHNvdXJjZSA9IHRvU2V0KGZpcnN0KSArIHRvU2V0KHJlc3QpICsgXCIqJFwiO1xuICAgIHJldHVybiBbbmV3IFJlZ0V4cChcIl5cIiArIHNvdXJjZSksIG5ldyBSZWdFeHAoc291cmNlKV07XG59XG4vKipcbkdpdmVuIGEgYSBmaXhlZCBhcnJheSBvZiBvcHRpb25zLCByZXR1cm4gYW4gYXV0b2NvbXBsZXRlciB0aGF0XG5jb21wbGV0ZXMgdGhlbS5cbiovXG5mdW5jdGlvbiBjb21wbGV0ZUZyb21MaXN0KGxpc3QpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGxpc3QubWFwKG8gPT4gdHlwZW9mIG8gPT0gXCJzdHJpbmdcIiA/IHsgbGFiZWw6IG8gfSA6IG8pO1xuICAgIGxldCBbdmFsaWRGb3IsIG1hdGNoXSA9IG9wdGlvbnMuZXZlcnkobyA9PiAvXlxcdyskLy50ZXN0KG8ubGFiZWwpKSA/IFsvXFx3KiQvLCAvXFx3KyQvXSA6IHByZWZpeE1hdGNoKG9wdGlvbnMpO1xuICAgIHJldHVybiAoY29udGV4dCkgPT4ge1xuICAgICAgICBsZXQgdG9rZW4gPSBjb250ZXh0Lm1hdGNoQmVmb3JlKG1hdGNoKTtcbiAgICAgICAgcmV0dXJuIHRva2VuIHx8IGNvbnRleHQuZXhwbGljaXQgPyB7IGZyb206IHRva2VuID8gdG9rZW4uZnJvbSA6IGNvbnRleHQucG9zLCBvcHRpb25zLCB2YWxpZEZvciB9IDogbnVsbDtcbiAgICB9O1xufVxuLyoqXG5XcmFwIHRoZSBnaXZlbiBjb21wbGV0aW9uIHNvdXJjZSBzbyB0aGF0IGl0IHdpbGwgb25seSBmaXJlIHdoZW4gdGhlXG5jdXJzb3IgaXMgaW4gYSBzeW50YXggbm9kZSB3aXRoIG9uZSBvZiB0aGUgZ2l2ZW4gbmFtZXMuXG4qL1xuZnVuY3Rpb24gaWZJbihub2Rlcywgc291cmNlKSB7XG4gICAgcmV0dXJuIChjb250ZXh0KSA9PiB7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IHN5bnRheFRyZWUoY29udGV4dC5zdGF0ZSkucmVzb2x2ZUlubmVyKGNvbnRleHQucG9zLCAtMSk7IHBvczsgcG9zID0gcG9zLnBhcmVudCkge1xuICAgICAgICAgICAgaWYgKG5vZGVzLmluZGV4T2YocG9zLm5hbWUpID4gLTEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNvdXJjZShjb250ZXh0KTtcbiAgICAgICAgICAgIGlmIChwb3MudHlwZS5pc1RvcClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xufVxuLyoqXG5XcmFwIHRoZSBnaXZlbiBjb21wbGV0aW9uIHNvdXJjZSBzbyB0aGF0IGl0IHdpbGwgbm90IGZpcmUgd2hlbiB0aGVcbmN1cnNvciBpcyBpbiBhIHN5bnRheCBub2RlIHdpdGggb25lIG9mIHRoZSBnaXZlbiBuYW1lcy5cbiovXG5mdW5jdGlvbiBpZk5vdEluKG5vZGVzLCBzb3VyY2UpIHtcbiAgICByZXR1cm4gKGNvbnRleHQpID0+IHtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gc3ludGF4VHJlZShjb250ZXh0LnN0YXRlKS5yZXNvbHZlSW5uZXIoY29udGV4dC5wb3MsIC0xKTsgcG9zOyBwb3MgPSBwb3MucGFyZW50KSB7XG4gICAgICAgICAgICBpZiAobm9kZXMuaW5kZXhPZihwb3MubmFtZSkgPiAtMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGlmIChwb3MudHlwZS5pc1RvcClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc291cmNlKGNvbnRleHQpO1xuICAgIH07XG59XG5jbGFzcyBPcHRpb24ge1xuICAgIGNvbnN0cnVjdG9yKGNvbXBsZXRpb24sIHNvdXJjZSwgbWF0Y2gsIHNjb3JlKSB7XG4gICAgICAgIHRoaXMuY29tcGxldGlvbiA9IGNvbXBsZXRpb247XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICB0aGlzLm1hdGNoID0gbWF0Y2g7XG4gICAgICAgIHRoaXMuc2NvcmUgPSBzY29yZTtcbiAgICB9XG59XG5mdW5jdGlvbiBjdXIoc3RhdGUpIHsgcmV0dXJuIHN0YXRlLnNlbGVjdGlvbi5tYWluLmZyb207IH1cbi8vIE1ha2Ugc3VyZSB0aGUgZ2l2ZW4gcmVnZXhwIGhhcyBhICQgYXQgaXRzIGVuZCBhbmQsIGlmIGBzdGFydGAgaXNcbi8vIHRydWUsIGEgXiBhdCBpdHMgc3RhcnQuXG5mdW5jdGlvbiBlbnN1cmVBbmNob3IoZXhwciwgc3RhcnQpIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IHsgc291cmNlIH0gPSBleHByO1xuICAgIGxldCBhZGRTdGFydCA9IHN0YXJ0ICYmIHNvdXJjZVswXSAhPSBcIl5cIiwgYWRkRW5kID0gc291cmNlW3NvdXJjZS5sZW5ndGggLSAxXSAhPSBcIiRcIjtcbiAgICBpZiAoIWFkZFN0YXJ0ICYmICFhZGRFbmQpXG4gICAgICAgIHJldHVybiBleHByO1xuICAgIHJldHVybiBuZXcgUmVnRXhwKGAke2FkZFN0YXJ0ID8gXCJeXCIgOiBcIlwifSg/OiR7c291cmNlfSkke2FkZEVuZCA/IFwiJFwiIDogXCJcIn1gLCAoX2EgPSBleHByLmZsYWdzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoZXhwci5pZ25vcmVDYXNlID8gXCJpXCIgOiBcIlwiKSk7XG59XG4vKipcblRoaXMgYW5ub3RhdGlvbiBpcyBhZGRlZCB0byB0cmFuc2FjdGlvbnMgdGhhdCBhcmUgcHJvZHVjZWQgYnlcbnBpY2tpbmcgYSBjb21wbGV0aW9uLlxuKi9cbmNvbnN0IHBpY2tlZENvbXBsZXRpb24gPSAvKkBfX1BVUkVfXyovQW5ub3RhdGlvbi5kZWZpbmUoKTtcbi8qKlxuSGVscGVyIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHRyYW5zYWN0aW9uIHNwZWMgd2hpY2ggaW5zZXJ0cyBhXG5jb21wbGV0aW9uJ3MgdGV4dCBpbiB0aGUgbWFpbiBzZWxlY3Rpb24gcmFuZ2UsIGFuZCBhbnkgb3RoZXJcbnNlbGVjdGlvbiByYW5nZSB0aGF0IGhhcyB0aGUgc2FtZSB0ZXh0IGluIGZyb250IG9mIGl0LlxuKi9cbmZ1bmN0aW9uIGluc2VydENvbXBsZXRpb25UZXh0KHN0YXRlLCB0ZXh0LCBmcm9tLCB0bykge1xuICAgIGxldCB7IG1haW4gfSA9IHN0YXRlLnNlbGVjdGlvbiwgZnJvbU9mZiA9IGZyb20gLSBtYWluLmZyb20sIHRvT2ZmID0gdG8gLSBtYWluLmZyb207XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUuY2hhbmdlQnlSYW5nZShyYW5nZSA9PiB7XG4gICAgICAgIGlmIChyYW5nZSAhPSBtYWluICYmIGZyb20gIT0gdG8gJiZcbiAgICAgICAgICAgIHN0YXRlLnNsaWNlRG9jKHJhbmdlLmZyb20gKyBmcm9tT2ZmLCByYW5nZS5mcm9tICsgdG9PZmYpICE9IHN0YXRlLnNsaWNlRG9jKGZyb20sIHRvKSlcbiAgICAgICAgICAgIHJldHVybiB7IHJhbmdlIH07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjaGFuZ2VzOiB7IGZyb206IHJhbmdlLmZyb20gKyBmcm9tT2ZmLCB0bzogdG8gPT0gbWFpbi5mcm9tID8gcmFuZ2UudG8gOiByYW5nZS5mcm9tICsgdG9PZmYsIGluc2VydDogdGV4dCB9LFxuICAgICAgICAgICAgcmFuZ2U6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocmFuZ2UuZnJvbSArIGZyb21PZmYgKyB0ZXh0Lmxlbmd0aClcbiAgICAgICAgfTtcbiAgICB9KSksIHsgc2Nyb2xsSW50b1ZpZXc6IHRydWUsIHVzZXJFdmVudDogXCJpbnB1dC5jb21wbGV0ZVwiIH0pO1xufVxuY29uc3QgU291cmNlQ2FjaGUgPSAvKkBfX1BVUkVfXyovbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIGFzU291cmNlKHNvdXJjZSkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShzb3VyY2UpKVxuICAgICAgICByZXR1cm4gc291cmNlO1xuICAgIGxldCBrbm93biA9IFNvdXJjZUNhY2hlLmdldChzb3VyY2UpO1xuICAgIGlmICgha25vd24pXG4gICAgICAgIFNvdXJjZUNhY2hlLnNldChzb3VyY2UsIGtub3duID0gY29tcGxldGVGcm9tTGlzdChzb3VyY2UpKTtcbiAgICByZXR1cm4ga25vd247XG59XG5jb25zdCBzdGFydENvbXBsZXRpb25FZmZlY3QgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG5jb25zdCBjbG9zZUNvbXBsZXRpb25FZmZlY3QgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG5cbi8vIEEgcGF0dGVybiBtYXRjaGVyIGZvciBmdXp6eSBjb21wbGV0aW9uIG1hdGNoaW5nLiBDcmVhdGUgYW4gaW5zdGFuY2Vcbi8vIG9uY2UgZm9yIGEgcGF0dGVybiwgYW5kIHRoZW4gdXNlIHRoYXQgdG8gbWF0Y2ggYW55IG51bWJlciBvZlxuLy8gY29tcGxldGlvbnMuXG5jbGFzcyBGdXp6eU1hdGNoZXIge1xuICAgIGNvbnN0cnVjdG9yKHBhdHRlcm4pIHtcbiAgICAgICAgdGhpcy5wYXR0ZXJuID0gcGF0dGVybjtcbiAgICAgICAgdGhpcy5jaGFycyA9IFtdO1xuICAgICAgICB0aGlzLmZvbGRlZCA9IFtdO1xuICAgICAgICAvLyBCdWZmZXJzIHJldXNlZCBieSBjYWxscyB0byBgbWF0Y2hgIHRvIHRyYWNrIG1hdGNoZWQgY2hhcmFjdGVyXG4gICAgICAgIC8vIHBvc2l0aW9ucy5cbiAgICAgICAgdGhpcy5hbnkgPSBbXTtcbiAgICAgICAgdGhpcy5wcmVjaXNlID0gW107XG4gICAgICAgIHRoaXMuYnlXb3JkID0gW107XG4gICAgICAgIHRoaXMuc2NvcmUgPSAwO1xuICAgICAgICB0aGlzLm1hdGNoZWQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgcCA9IDA7IHAgPCBwYXR0ZXJuLmxlbmd0aDspIHtcbiAgICAgICAgICAgIGxldCBjaGFyID0gY29kZVBvaW50QXQocGF0dGVybiwgcCksIHNpemUgPSBjb2RlUG9pbnRTaXplKGNoYXIpO1xuICAgICAgICAgICAgdGhpcy5jaGFycy5wdXNoKGNoYXIpO1xuICAgICAgICAgICAgbGV0IHBhcnQgPSBwYXR0ZXJuLnNsaWNlKHAsIHAgKyBzaXplKSwgdXBwZXIgPSBwYXJ0LnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICB0aGlzLmZvbGRlZC5wdXNoKGNvZGVQb2ludEF0KHVwcGVyID09IHBhcnQgPyBwYXJ0LnRvTG93ZXJDYXNlKCkgOiB1cHBlciwgMCkpO1xuICAgICAgICAgICAgcCArPSBzaXplO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXN0cmFsID0gcGF0dGVybi5sZW5ndGggIT0gdGhpcy5jaGFycy5sZW5ndGg7XG4gICAgfVxuICAgIHJldChzY29yZSwgbWF0Y2hlZCkge1xuICAgICAgICB0aGlzLnNjb3JlID0gc2NvcmU7XG4gICAgICAgIHRoaXMubWF0Y2hlZCA9IG1hdGNoZWQ7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBNYXRjaGVzIGEgZ2l2ZW4gd29yZCAoY29tcGxldGlvbikgYWdhaW5zdCB0aGUgcGF0dGVybiAoaW5wdXQpLlxuICAgIC8vIFdpbGwgcmV0dXJuIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlcmUgd2FzIGEgbWF0Y2ggYW5kLFxuICAgIC8vIG9uIHN1Y2Nlc3MsIHNldCBgdGhpcy5zY29yZWAgdG8gdGhlIHNjb3JlLCBgdGhpcy5tYXRjaGVkYCB0byBhblxuICAgIC8vIGFycmF5IG9mIGBmcm9tLCB0b2AgcGFpcnMgaW5kaWNhdGluZyB0aGUgbWF0Y2hlZCBwYXJ0cyBvZiBgd29yZGAuXG4gICAgLy9cbiAgICAvLyBUaGUgc2NvcmUgaXMgYSBudW1iZXIgdGhhdCBpcyBtb3JlIG5lZ2F0aXZlIHRoZSB3b3JzZSB0aGUgbWF0Y2hcbiAgICAvLyBpcy4gU2VlIGBQZW5hbHR5YCBhYm92ZS5cbiAgICBtYXRjaCh3b3JkKSB7XG4gICAgICAgIGlmICh0aGlzLnBhdHRlcm4ubGVuZ3RoID09IDApXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXQoLTEwMCAvKiBQZW5hbHR5Lk5vdEZ1bGwgKi8sIFtdKTtcbiAgICAgICAgaWYgKHdvcmQubGVuZ3RoIDwgdGhpcy5wYXR0ZXJuLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IHsgY2hhcnMsIGZvbGRlZCwgYW55LCBwcmVjaXNlLCBieVdvcmQgfSA9IHRoaXM7XG4gICAgICAgIC8vIEZvciBzaW5nbGUtY2hhcmFjdGVyIHF1ZXJpZXMsIG9ubHkgbWF0Y2ggd2hlbiB0aGV5IG9jY3VyIHJpZ2h0XG4gICAgICAgIC8vIGF0IHRoZSBzdGFydFxuICAgICAgICBpZiAoY2hhcnMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgIGxldCBmaXJzdCA9IGNvZGVQb2ludEF0KHdvcmQsIDApLCBmaXJzdFNpemUgPSBjb2RlUG9pbnRTaXplKGZpcnN0KTtcbiAgICAgICAgICAgIGxldCBzY29yZSA9IGZpcnN0U2l6ZSA9PSB3b3JkLmxlbmd0aCA/IDAgOiAtMTAwIC8qIFBlbmFsdHkuTm90RnVsbCAqLztcbiAgICAgICAgICAgIGlmIChmaXJzdCA9PSBjaGFyc1swXSkgO1xuICAgICAgICAgICAgZWxzZSBpZiAoZmlyc3QgPT0gZm9sZGVkWzBdKVxuICAgICAgICAgICAgICAgIHNjb3JlICs9IC0yMDAgLyogUGVuYWx0eS5DYXNlRm9sZCAqLztcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXQoc2NvcmUsIFswLCBmaXJzdFNpemVdKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGlyZWN0ID0gd29yZC5pbmRleE9mKHRoaXMucGF0dGVybik7XG4gICAgICAgIGlmIChkaXJlY3QgPT0gMClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJldCh3b3JkLmxlbmd0aCA9PSB0aGlzLnBhdHRlcm4ubGVuZ3RoID8gMCA6IC0xMDAgLyogUGVuYWx0eS5Ob3RGdWxsICovLCBbMCwgdGhpcy5wYXR0ZXJuLmxlbmd0aF0pO1xuICAgICAgICBsZXQgbGVuID0gY2hhcnMubGVuZ3RoLCBhbnlUbyA9IDA7XG4gICAgICAgIGlmIChkaXJlY3QgPCAwKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgZSA9IE1hdGgubWluKHdvcmQubGVuZ3RoLCAyMDApOyBpIDwgZSAmJiBhbnlUbyA8IGxlbjspIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IGNvZGVQb2ludEF0KHdvcmQsIGkpO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0ID09IGNoYXJzW2FueVRvXSB8fCBuZXh0ID09IGZvbGRlZFthbnlUb10pXG4gICAgICAgICAgICAgICAgICAgIGFueVthbnlUbysrXSA9IGk7XG4gICAgICAgICAgICAgICAgaSArPSBjb2RlUG9pbnRTaXplKG5leHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTm8gbWF0Y2gsIGV4aXQgaW1tZWRpYXRlbHlcbiAgICAgICAgICAgIGlmIChhbnlUbyA8IGxlbilcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhpcyB0cmFja3MgdGhlIGV4dGVudCBvZiB0aGUgcHJlY2lzZSAobm9uLWZvbGRlZCwgbm90XG4gICAgICAgIC8vIG5lY2Vzc2FyaWx5IGFkamFjZW50KSBtYXRjaFxuICAgICAgICBsZXQgcHJlY2lzZVRvID0gMDtcbiAgICAgICAgLy8gVHJhY2tzIHdoZXRoZXIgdGhlcmUgaXMgYSBtYXRjaCB0aGF0IGhpdHMgb25seSBjaGFyYWN0ZXJzIHRoYXRcbiAgICAgICAgLy8gYXBwZWFyIHRvIGJlIHN0YXJ0aW5nIHdvcmRzLiBgYnlXb3JkRm9sZGVkYCBpcyBzZXQgdG8gdHJ1ZSB3aGVuXG4gICAgICAgIC8vIGEgY2FzZSBmb2xkZWQgY2hhcmFjdGVyIGlzIGVuY291bnRlcmVkIGluIHN1Y2ggYSBtYXRjaFxuICAgICAgICBsZXQgYnlXb3JkVG8gPSAwLCBieVdvcmRGb2xkZWQgPSBmYWxzZTtcbiAgICAgICAgLy8gSWYgd2UndmUgZm91bmQgYSBwYXJ0aWFsIGFkamFjZW50IG1hdGNoLCB0aGVzZSB0cmFjayBpdHMgc3RhdGVcbiAgICAgICAgbGV0IGFkamFjZW50VG8gPSAwLCBhZGphY2VudFN0YXJ0ID0gLTEsIGFkamFjZW50RW5kID0gLTE7XG4gICAgICAgIGxldCBoYXNMb3dlciA9IC9bYS16XS8udGVzdCh3b3JkKSwgd29yZEFkamFjZW50ID0gdHJ1ZTtcbiAgICAgICAgLy8gR28gb3ZlciB0aGUgb3B0aW9uJ3MgdGV4dCwgc2Nhbm5pbmcgZm9yIHRoZSB2YXJpb3VzIGtpbmRzIG9mIG1hdGNoZXNcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGUgPSBNYXRoLm1pbih3b3JkLmxlbmd0aCwgMjAwKSwgcHJldlR5cGUgPSAwIC8qIFRwLk5vbldvcmQgKi87IGkgPCBlICYmIGJ5V29yZFRvIDwgbGVuOykge1xuICAgICAgICAgICAgbGV0IG5leHQgPSBjb2RlUG9pbnRBdCh3b3JkLCBpKTtcbiAgICAgICAgICAgIGlmIChkaXJlY3QgPCAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByZWNpc2VUbyA8IGxlbiAmJiBuZXh0ID09IGNoYXJzW3ByZWNpc2VUb10pXG4gICAgICAgICAgICAgICAgICAgIHByZWNpc2VbcHJlY2lzZVRvKytdID0gaTtcbiAgICAgICAgICAgICAgICBpZiAoYWRqYWNlbnRUbyA8IGxlbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCA9PSBjaGFyc1thZGphY2VudFRvXSB8fCBuZXh0ID09IGZvbGRlZFthZGphY2VudFRvXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFkamFjZW50VG8gPT0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGphY2VudFN0YXJ0ID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkamFjZW50RW5kID0gaSArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGphY2VudFRvKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGphY2VudFRvID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBjaCwgdHlwZSA9IG5leHQgPCAweGZmXG4gICAgICAgICAgICAgICAgPyAobmV4dCA+PSA0OCAmJiBuZXh0IDw9IDU3IHx8IG5leHQgPj0gOTcgJiYgbmV4dCA8PSAxMjIgPyAyIC8qIFRwLkxvd2VyICovIDogbmV4dCA+PSA2NSAmJiBuZXh0IDw9IDkwID8gMSAvKiBUcC5VcHBlciAqLyA6IDAgLyogVHAuTm9uV29yZCAqLylcbiAgICAgICAgICAgICAgICA6ICgoY2ggPSBmcm9tQ29kZVBvaW50KG5leHQpKSAhPSBjaC50b0xvd2VyQ2FzZSgpID8gMSAvKiBUcC5VcHBlciAqLyA6IGNoICE9IGNoLnRvVXBwZXJDYXNlKCkgPyAyIC8qIFRwLkxvd2VyICovIDogMCAvKiBUcC5Ob25Xb3JkICovKTtcbiAgICAgICAgICAgIGlmICghaSB8fCB0eXBlID09IDEgLyogVHAuVXBwZXIgKi8gJiYgaGFzTG93ZXIgfHwgcHJldlR5cGUgPT0gMCAvKiBUcC5Ob25Xb3JkICovICYmIHR5cGUgIT0gMCAvKiBUcC5Ob25Xb3JkICovKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoYXJzW2J5V29yZFRvXSA9PSBuZXh0IHx8IChmb2xkZWRbYnlXb3JkVG9dID09IG5leHQgJiYgKGJ5V29yZEZvbGRlZCA9IHRydWUpKSlcbiAgICAgICAgICAgICAgICAgICAgYnlXb3JkW2J5V29yZFRvKytdID0gaTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChieVdvcmQubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICB3b3JkQWRqYWNlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXZUeXBlID0gdHlwZTtcbiAgICAgICAgICAgIGkgKz0gY29kZVBvaW50U2l6ZShuZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnlXb3JkVG8gPT0gbGVuICYmIGJ5V29yZFswXSA9PSAwICYmIHdvcmRBZGphY2VudClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc3VsdCgtMTAwIC8qIFBlbmFsdHkuQnlXb3JkICovICsgKGJ5V29yZEZvbGRlZCA/IC0yMDAgLyogUGVuYWx0eS5DYXNlRm9sZCAqLyA6IDApLCBieVdvcmQsIHdvcmQpO1xuICAgICAgICBpZiAoYWRqYWNlbnRUbyA9PSBsZW4gJiYgYWRqYWNlbnRTdGFydCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmV0KC0yMDAgLyogUGVuYWx0eS5DYXNlRm9sZCAqLyAtIHdvcmQubGVuZ3RoICsgKGFkamFjZW50RW5kID09IHdvcmQubGVuZ3RoID8gMCA6IC0xMDAgLyogUGVuYWx0eS5Ob3RGdWxsICovKSwgWzAsIGFkamFjZW50RW5kXSk7XG4gICAgICAgIGlmIChkaXJlY3QgPiAtMSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJldCgtNzAwIC8qIFBlbmFsdHkuTm90U3RhcnQgKi8gLSB3b3JkLmxlbmd0aCwgW2RpcmVjdCwgZGlyZWN0ICsgdGhpcy5wYXR0ZXJuLmxlbmd0aF0pO1xuICAgICAgICBpZiAoYWRqYWNlbnRUbyA9PSBsZW4pXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXQoLTIwMCAvKiBQZW5hbHR5LkNhc2VGb2xkICovICsgLTcwMCAvKiBQZW5hbHR5Lk5vdFN0YXJ0ICovIC0gd29yZC5sZW5ndGgsIFthZGphY2VudFN0YXJ0LCBhZGphY2VudEVuZF0pO1xuICAgICAgICBpZiAoYnlXb3JkVG8gPT0gbGVuKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0KC0xMDAgLyogUGVuYWx0eS5CeVdvcmQgKi8gKyAoYnlXb3JkRm9sZGVkID8gLTIwMCAvKiBQZW5hbHR5LkNhc2VGb2xkICovIDogMCkgKyAtNzAwIC8qIFBlbmFsdHkuTm90U3RhcnQgKi8gK1xuICAgICAgICAgICAgICAgICh3b3JkQWRqYWNlbnQgPyAwIDogLTExMDAgLyogUGVuYWx0eS5HYXAgKi8pLCBieVdvcmQsIHdvcmQpO1xuICAgICAgICByZXR1cm4gY2hhcnMubGVuZ3RoID09IDIgPyBmYWxzZVxuICAgICAgICAgICAgOiB0aGlzLnJlc3VsdCgoYW55WzBdID8gLTcwMCAvKiBQZW5hbHR5Lk5vdFN0YXJ0ICovIDogMCkgKyAtMjAwIC8qIFBlbmFsdHkuQ2FzZUZvbGQgKi8gKyAtMTEwMCAvKiBQZW5hbHR5LkdhcCAqLywgYW55LCB3b3JkKTtcbiAgICB9XG4gICAgcmVzdWx0KHNjb3JlLCBwb3NpdGlvbnMsIHdvcmQpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdLCBpID0gMDtcbiAgICAgICAgZm9yIChsZXQgcG9zIG9mIHBvc2l0aW9ucykge1xuICAgICAgICAgICAgbGV0IHRvID0gcG9zICsgKHRoaXMuYXN0cmFsID8gY29kZVBvaW50U2l6ZShjb2RlUG9pbnRBdCh3b3JkLCBwb3MpKSA6IDEpO1xuICAgICAgICAgICAgaWYgKGkgJiYgcmVzdWx0W2kgLSAxXSA9PSBwb3MpXG4gICAgICAgICAgICAgICAgcmVzdWx0W2kgLSAxXSA9IHRvO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2krK10gPSBwb3M7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2krK10gPSB0bztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yZXQoc2NvcmUgLSB3b3JkLmxlbmd0aCwgcmVzdWx0KTtcbiAgICB9XG59XG5cbmNvbnN0IGNvbXBsZXRpb25Db25maWcgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lKGNvbmZpZ3MpIHtcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVDb25maWcoY29uZmlncywge1xuICAgICAgICAgICAgYWN0aXZhdGVPblR5cGluZzogdHJ1ZSxcbiAgICAgICAgICAgIHNlbGVjdE9uT3BlbjogdHJ1ZSxcbiAgICAgICAgICAgIG92ZXJyaWRlOiBudWxsLFxuICAgICAgICAgICAgY2xvc2VPbkJsdXI6IHRydWUsXG4gICAgICAgICAgICBtYXhSZW5kZXJlZE9wdGlvbnM6IDEwMCxcbiAgICAgICAgICAgIGRlZmF1bHRLZXltYXA6IHRydWUsXG4gICAgICAgICAgICB0b29sdGlwQ2xhc3M6ICgpID0+IFwiXCIsXG4gICAgICAgICAgICBvcHRpb25DbGFzczogKCkgPT4gXCJcIixcbiAgICAgICAgICAgIGFib3ZlQ3Vyc29yOiBmYWxzZSxcbiAgICAgICAgICAgIGljb25zOiB0cnVlLFxuICAgICAgICAgICAgYWRkVG9PcHRpb25zOiBbXSxcbiAgICAgICAgICAgIHBvc2l0aW9uSW5mbzogZGVmYXVsdFBvc2l0aW9uSW5mbyxcbiAgICAgICAgICAgIGNvbXBhcmVDb21wbGV0aW9uczogKGEsIGIpID0+IGEubGFiZWwubG9jYWxlQ29tcGFyZShiLmxhYmVsKSxcbiAgICAgICAgICAgIGludGVyYWN0aW9uRGVsYXk6IDc1LFxuICAgICAgICAgICAgdXBkYXRlU3luY1RpbWU6IDEwMFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBkZWZhdWx0S2V5bWFwOiAoYSwgYikgPT4gYSAmJiBiLFxuICAgICAgICAgICAgY2xvc2VPbkJsdXI6IChhLCBiKSA9PiBhICYmIGIsXG4gICAgICAgICAgICBpY29uczogKGEsIGIpID0+IGEgJiYgYixcbiAgICAgICAgICAgIHRvb2x0aXBDbGFzczogKGEsIGIpID0+IGMgPT4gam9pbkNsYXNzKGEoYyksIGIoYykpLFxuICAgICAgICAgICAgb3B0aW9uQ2xhc3M6IChhLCBiKSA9PiBjID0+IGpvaW5DbGFzcyhhKGMpLCBiKGMpKSxcbiAgICAgICAgICAgIGFkZFRvT3B0aW9uczogKGEsIGIpID0+IGEuY29uY2F0KGIpXG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuZnVuY3Rpb24gam9pbkNsYXNzKGEsIGIpIHtcbiAgICByZXR1cm4gYSA/IGIgPyBhICsgXCIgXCIgKyBiIDogYSA6IGI7XG59XG5mdW5jdGlvbiBkZWZhdWx0UG9zaXRpb25JbmZvKHZpZXcsIGxpc3QsIG9wdGlvbiwgaW5mbywgc3BhY2UsIHRvb2x0aXApIHtcbiAgICBsZXQgcnRsID0gdmlldy50ZXh0RGlyZWN0aW9uID09IERpcmVjdGlvbi5SVEwsIGxlZnQgPSBydGwsIG5hcnJvdyA9IGZhbHNlO1xuICAgIGxldCBzaWRlID0gXCJ0b3BcIiwgb2Zmc2V0LCBtYXhXaWR0aDtcbiAgICBsZXQgc3BhY2VMZWZ0ID0gbGlzdC5sZWZ0IC0gc3BhY2UubGVmdCwgc3BhY2VSaWdodCA9IHNwYWNlLnJpZ2h0IC0gbGlzdC5yaWdodDtcbiAgICBsZXQgaW5mb1dpZHRoID0gaW5mby5yaWdodCAtIGluZm8ubGVmdCwgaW5mb0hlaWdodCA9IGluZm8uYm90dG9tIC0gaW5mby50b3A7XG4gICAgaWYgKGxlZnQgJiYgc3BhY2VMZWZ0IDwgTWF0aC5taW4oaW5mb1dpZHRoLCBzcGFjZVJpZ2h0KSlcbiAgICAgICAgbGVmdCA9IGZhbHNlO1xuICAgIGVsc2UgaWYgKCFsZWZ0ICYmIHNwYWNlUmlnaHQgPCBNYXRoLm1pbihpbmZvV2lkdGgsIHNwYWNlTGVmdCkpXG4gICAgICAgIGxlZnQgPSB0cnVlO1xuICAgIGlmIChpbmZvV2lkdGggPD0gKGxlZnQgPyBzcGFjZUxlZnQgOiBzcGFjZVJpZ2h0KSkge1xuICAgICAgICBvZmZzZXQgPSBNYXRoLm1heChzcGFjZS50b3AsIE1hdGgubWluKG9wdGlvbi50b3AsIHNwYWNlLmJvdHRvbSAtIGluZm9IZWlnaHQpKSAtIGxpc3QudG9wO1xuICAgICAgICBtYXhXaWR0aCA9IE1hdGgubWluKDQwMCAvKiBJbmZvLldpZHRoICovLCBsZWZ0ID8gc3BhY2VMZWZ0IDogc3BhY2VSaWdodCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBuYXJyb3cgPSB0cnVlO1xuICAgICAgICBtYXhXaWR0aCA9IE1hdGgubWluKDQwMCAvKiBJbmZvLldpZHRoICovLCAocnRsID8gbGlzdC5yaWdodCA6IHNwYWNlLnJpZ2h0IC0gbGlzdC5sZWZ0KSAtIDMwIC8qIEluZm8uTWFyZ2luICovKTtcbiAgICAgICAgbGV0IHNwYWNlQmVsb3cgPSBzcGFjZS5ib3R0b20gLSBsaXN0LmJvdHRvbTtcbiAgICAgICAgaWYgKHNwYWNlQmVsb3cgPj0gaW5mb0hlaWdodCB8fCBzcGFjZUJlbG93ID4gbGlzdC50b3ApIHsgLy8gQmVsb3cgdGhlIGNvbXBsZXRpb25cbiAgICAgICAgICAgIG9mZnNldCA9IG9wdGlvbi5ib3R0b20gLSBsaXN0LnRvcDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gQWJvdmUgaXRcbiAgICAgICAgICAgIHNpZGUgPSBcImJvdHRvbVwiO1xuICAgICAgICAgICAgb2Zmc2V0ID0gbGlzdC5ib3R0b20gLSBvcHRpb24udG9wO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBzY2FsZVkgPSAobGlzdC5ib3R0b20gLSBsaXN0LnRvcCkgLyB0b29sdGlwLm9mZnNldEhlaWdodDtcbiAgICBsZXQgc2NhbGVYID0gKGxpc3QucmlnaHQgLSBsaXN0LmxlZnQpIC8gdG9vbHRpcC5vZmZzZXRXaWR0aDtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdHlsZTogYCR7c2lkZX06ICR7b2Zmc2V0IC8gc2NhbGVZfXB4OyBtYXgtd2lkdGg6ICR7bWF4V2lkdGggLyBzY2FsZVh9cHhgLFxuICAgICAgICBjbGFzczogXCJjbS1jb21wbGV0aW9uSW5mby1cIiArIChuYXJyb3cgPyAocnRsID8gXCJsZWZ0LW5hcnJvd1wiIDogXCJyaWdodC1uYXJyb3dcIikgOiBsZWZ0ID8gXCJsZWZ0XCIgOiBcInJpZ2h0XCIpXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gb3B0aW9uQ29udGVudChjb25maWcpIHtcbiAgICBsZXQgY29udGVudCA9IGNvbmZpZy5hZGRUb09wdGlvbnMuc2xpY2UoKTtcbiAgICBpZiAoY29uZmlnLmljb25zKVxuICAgICAgICBjb250ZW50LnB1c2goe1xuICAgICAgICAgICAgcmVuZGVyKGNvbXBsZXRpb24pIHtcbiAgICAgICAgICAgICAgICBsZXQgaWNvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICAgICAgaWNvbi5jbGFzc0xpc3QuYWRkKFwiY20tY29tcGxldGlvbkljb25cIik7XG4gICAgICAgICAgICAgICAgaWYgKGNvbXBsZXRpb24udHlwZSlcbiAgICAgICAgICAgICAgICAgICAgaWNvbi5jbGFzc0xpc3QuYWRkKC4uLmNvbXBsZXRpb24udHlwZS5zcGxpdCgvXFxzKy9nKS5tYXAoY2xzID0+IFwiY20tY29tcGxldGlvbkljb24tXCIgKyBjbHMpKTtcbiAgICAgICAgICAgICAgICBpY29uLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIFwidHJ1ZVwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWNvbjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwb3NpdGlvbjogMjBcbiAgICAgICAgfSk7XG4gICAgY29udGVudC5wdXNoKHtcbiAgICAgICAgcmVuZGVyKGNvbXBsZXRpb24sIF9zLCBfdiwgbWF0Y2gpIHtcbiAgICAgICAgICAgIGxldCBsYWJlbEVsdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICAgICAgbGFiZWxFbHQuY2xhc3NOYW1lID0gXCJjbS1jb21wbGV0aW9uTGFiZWxcIjtcbiAgICAgICAgICAgIGxldCBsYWJlbCA9IGNvbXBsZXRpb24uZGlzcGxheUxhYmVsIHx8IGNvbXBsZXRpb24ubGFiZWwsIG9mZiA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG1hdGNoLmxlbmd0aDspIHtcbiAgICAgICAgICAgICAgICBsZXQgZnJvbSA9IG1hdGNoW2orK10sIHRvID0gbWF0Y2hbaisrXTtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbSA+IG9mZilcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxFbHQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobGFiZWwuc2xpY2Uob2ZmLCBmcm9tKSkpO1xuICAgICAgICAgICAgICAgIGxldCBzcGFuID0gbGFiZWxFbHQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIikpO1xuICAgICAgICAgICAgICAgIHNwYW4uYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobGFiZWwuc2xpY2UoZnJvbSwgdG8pKSk7XG4gICAgICAgICAgICAgICAgc3Bhbi5jbGFzc05hbWUgPSBcImNtLWNvbXBsZXRpb25NYXRjaGVkVGV4dFwiO1xuICAgICAgICAgICAgICAgIG9mZiA9IHRvO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9mZiA8IGxhYmVsLmxlbmd0aClcbiAgICAgICAgICAgICAgICBsYWJlbEVsdC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShsYWJlbC5zbGljZShvZmYpKSk7XG4gICAgICAgICAgICByZXR1cm4gbGFiZWxFbHQ7XG4gICAgICAgIH0sXG4gICAgICAgIHBvc2l0aW9uOiA1MFxuICAgIH0sIHtcbiAgICAgICAgcmVuZGVyKGNvbXBsZXRpb24pIHtcbiAgICAgICAgICAgIGlmICghY29tcGxldGlvbi5kZXRhaWwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBsZXQgZGV0YWlsRWx0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgICAgICBkZXRhaWxFbHQuY2xhc3NOYW1lID0gXCJjbS1jb21wbGV0aW9uRGV0YWlsXCI7XG4gICAgICAgICAgICBkZXRhaWxFbHQudGV4dENvbnRlbnQgPSBjb21wbGV0aW9uLmRldGFpbDtcbiAgICAgICAgICAgIHJldHVybiBkZXRhaWxFbHQ7XG4gICAgICAgIH0sXG4gICAgICAgIHBvc2l0aW9uOiA4MFxuICAgIH0pO1xuICAgIHJldHVybiBjb250ZW50LnNvcnQoKGEsIGIpID0+IGEucG9zaXRpb24gLSBiLnBvc2l0aW9uKS5tYXAoYSA9PiBhLnJlbmRlcik7XG59XG5mdW5jdGlvbiByYW5nZUFyb3VuZFNlbGVjdGVkKHRvdGFsLCBzZWxlY3RlZCwgbWF4KSB7XG4gICAgaWYgKHRvdGFsIDw9IG1heClcbiAgICAgICAgcmV0dXJuIHsgZnJvbTogMCwgdG86IHRvdGFsIH07XG4gICAgaWYgKHNlbGVjdGVkIDwgMClcbiAgICAgICAgc2VsZWN0ZWQgPSAwO1xuICAgIGlmIChzZWxlY3RlZCA8PSAodG90YWwgPj4gMSkpIHtcbiAgICAgICAgbGV0IG9mZiA9IE1hdGguZmxvb3Ioc2VsZWN0ZWQgLyBtYXgpO1xuICAgICAgICByZXR1cm4geyBmcm9tOiBvZmYgKiBtYXgsIHRvOiAob2ZmICsgMSkgKiBtYXggfTtcbiAgICB9XG4gICAgbGV0IG9mZiA9IE1hdGguZmxvb3IoKHRvdGFsIC0gc2VsZWN0ZWQpIC8gbWF4KTtcbiAgICByZXR1cm4geyBmcm9tOiB0b3RhbCAtIChvZmYgKyAxKSAqIG1heCwgdG86IHRvdGFsIC0gb2ZmICogbWF4IH07XG59XG5jbGFzcyBDb21wbGV0aW9uVG9vbHRpcCB7XG4gICAgY29uc3RydWN0b3Iodmlldywgc3RhdGVGaWVsZCwgYXBwbHlDb21wbGV0aW9uKSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuc3RhdGVGaWVsZCA9IHN0YXRlRmllbGQ7XG4gICAgICAgIHRoaXMuYXBwbHlDb21wbGV0aW9uID0gYXBwbHlDb21wbGV0aW9uO1xuICAgICAgICB0aGlzLmluZm8gPSBudWxsO1xuICAgICAgICB0aGlzLmluZm9EZXN0cm95ID0gbnVsbDtcbiAgICAgICAgdGhpcy5wbGFjZUluZm9SZXEgPSB7XG4gICAgICAgICAgICByZWFkOiAoKSA9PiB0aGlzLm1lYXN1cmVJbmZvKCksXG4gICAgICAgICAgICB3cml0ZTogKHBvcykgPT4gdGhpcy5wbGFjZUluZm8ocG9zKSxcbiAgICAgICAgICAgIGtleTogdGhpc1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNwYWNlID0gbnVsbDtcbiAgICAgICAgdGhpcy5jdXJyZW50Q2xhc3MgPSBcIlwiO1xuICAgICAgICBsZXQgY1N0YXRlID0gdmlldy5zdGF0ZS5maWVsZChzdGF0ZUZpZWxkKTtcbiAgICAgICAgbGV0IHsgb3B0aW9ucywgc2VsZWN0ZWQgfSA9IGNTdGF0ZS5vcGVuO1xuICAgICAgICBsZXQgY29uZmlnID0gdmlldy5zdGF0ZS5mYWNldChjb21wbGV0aW9uQ29uZmlnKTtcbiAgICAgICAgdGhpcy5vcHRpb25Db250ZW50ID0gb3B0aW9uQ29udGVudChjb25maWcpO1xuICAgICAgICB0aGlzLm9wdGlvbkNsYXNzID0gY29uZmlnLm9wdGlvbkNsYXNzO1xuICAgICAgICB0aGlzLnRvb2x0aXBDbGFzcyA9IGNvbmZpZy50b29sdGlwQ2xhc3M7XG4gICAgICAgIHRoaXMucmFuZ2UgPSByYW5nZUFyb3VuZFNlbGVjdGVkKG9wdGlvbnMubGVuZ3RoLCBzZWxlY3RlZCwgY29uZmlnLm1heFJlbmRlcmVkT3B0aW9ucyk7XG4gICAgICAgIHRoaXMuZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy5kb20uY2xhc3NOYW1lID0gXCJjbS10b29sdGlwLWF1dG9jb21wbGV0ZVwiO1xuICAgICAgICB0aGlzLnVwZGF0ZVRvb2x0aXBDbGFzcyh2aWV3LnN0YXRlKTtcbiAgICAgICAgdGhpcy5kb20uYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCAoZSkgPT4ge1xuICAgICAgICAgICAgbGV0IHsgb3B0aW9ucyB9ID0gdmlldy5zdGF0ZS5maWVsZChzdGF0ZUZpZWxkKS5vcGVuO1xuICAgICAgICAgICAgZm9yIChsZXQgZG9tID0gZS50YXJnZXQsIG1hdGNoOyBkb20gJiYgZG9tICE9IHRoaXMuZG9tOyBkb20gPSBkb20ucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgIGlmIChkb20ubm9kZU5hbWUgPT0gXCJMSVwiICYmIChtYXRjaCA9IC8tKFxcZCspJC8uZXhlYyhkb20uaWQpKSAmJiArbWF0Y2hbMV0gPCBvcHRpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcGx5Q29tcGxldGlvbih2aWV3LCBvcHRpb25zWyttYXRjaFsxXV0pO1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmRvbS5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNvdXRcIiwgKGUpID0+IHtcbiAgICAgICAgICAgIGxldCBzdGF0ZSA9IHZpZXcuc3RhdGUuZmllbGQodGhpcy5zdGF0ZUZpZWxkLCBmYWxzZSk7XG4gICAgICAgICAgICBpZiAoc3RhdGUgJiYgc3RhdGUudG9vbHRpcCAmJiB2aWV3LnN0YXRlLmZhY2V0KGNvbXBsZXRpb25Db25maWcpLmNsb3NlT25CbHVyICYmXG4gICAgICAgICAgICAgICAgZS5yZWxhdGVkVGFyZ2V0ICE9IHZpZXcuY29udGVudERPTSlcbiAgICAgICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogY2xvc2VDb21wbGV0aW9uRWZmZWN0Lm9mKG51bGwpIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zaG93T3B0aW9ucyhvcHRpb25zLCBjU3RhdGUuaWQpO1xuICAgIH1cbiAgICBtb3VudCgpIHsgdGhpcy51cGRhdGVTZWwoKTsgfVxuICAgIHNob3dPcHRpb25zKG9wdGlvbnMsIGlkKSB7XG4gICAgICAgIGlmICh0aGlzLmxpc3QpXG4gICAgICAgICAgICB0aGlzLmxpc3QucmVtb3ZlKCk7XG4gICAgICAgIHRoaXMubGlzdCA9IHRoaXMuZG9tLmFwcGVuZENoaWxkKHRoaXMuY3JlYXRlTGlzdEJveChvcHRpb25zLCBpZCwgdGhpcy5yYW5nZSkpO1xuICAgICAgICB0aGlzLmxpc3QuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5pbmZvKVxuICAgICAgICAgICAgICAgIHRoaXMudmlldy5yZXF1ZXN0TWVhc3VyZSh0aGlzLnBsYWNlSW5mb1JlcSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgbGV0IGNTdGF0ZSA9IHVwZGF0ZS5zdGF0ZS5maWVsZCh0aGlzLnN0YXRlRmllbGQpO1xuICAgICAgICBsZXQgcHJldlN0YXRlID0gdXBkYXRlLnN0YXJ0U3RhdGUuZmllbGQodGhpcy5zdGF0ZUZpZWxkKTtcbiAgICAgICAgdGhpcy51cGRhdGVUb29sdGlwQ2xhc3ModXBkYXRlLnN0YXRlKTtcbiAgICAgICAgaWYgKGNTdGF0ZSAhPSBwcmV2U3RhdGUpIHtcbiAgICAgICAgICAgIGxldCB7IG9wdGlvbnMsIHNlbGVjdGVkLCBkaXNhYmxlZCB9ID0gY1N0YXRlLm9wZW47XG4gICAgICAgICAgICBpZiAoIXByZXZTdGF0ZS5vcGVuIHx8IHByZXZTdGF0ZS5vcGVuLm9wdGlvbnMgIT0gb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIHRoaXMucmFuZ2UgPSByYW5nZUFyb3VuZFNlbGVjdGVkKG9wdGlvbnMubGVuZ3RoLCBzZWxlY3RlZCwgdXBkYXRlLnN0YXRlLmZhY2V0KGNvbXBsZXRpb25Db25maWcpLm1heFJlbmRlcmVkT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgdGhpcy5zaG93T3B0aW9ucyhvcHRpb25zLCBjU3RhdGUuaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy51cGRhdGVTZWwoKTtcbiAgICAgICAgICAgIGlmIChkaXNhYmxlZCAhPSAoKF9hID0gcHJldlN0YXRlLm9wZW4pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kaXNhYmxlZCkpXG4gICAgICAgICAgICAgICAgdGhpcy5kb20uY2xhc3NMaXN0LnRvZ2dsZShcImNtLXRvb2x0aXAtYXV0b2NvbXBsZXRlLWRpc2FibGVkXCIsICEhZGlzYWJsZWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZVRvb2x0aXBDbGFzcyhzdGF0ZSkge1xuICAgICAgICBsZXQgY2xzID0gdGhpcy50b29sdGlwQ2xhc3Moc3RhdGUpO1xuICAgICAgICBpZiAoY2xzICE9IHRoaXMuY3VycmVudENsYXNzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBjIG9mIHRoaXMuY3VycmVudENsYXNzLnNwbGl0KFwiIFwiKSlcbiAgICAgICAgICAgICAgICBpZiAoYylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb20uY2xhc3NMaXN0LnJlbW92ZShjKTtcbiAgICAgICAgICAgIGZvciAobGV0IGMgb2YgY2xzLnNwbGl0KFwiIFwiKSlcbiAgICAgICAgICAgICAgICBpZiAoYylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb20uY2xhc3NMaXN0LmFkZChjKTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudENsYXNzID0gY2xzO1xuICAgICAgICB9XG4gICAgfVxuICAgIHBvc2l0aW9uZWQoc3BhY2UpIHtcbiAgICAgICAgdGhpcy5zcGFjZSA9IHNwYWNlO1xuICAgICAgICBpZiAodGhpcy5pbmZvKVxuICAgICAgICAgICAgdGhpcy52aWV3LnJlcXVlc3RNZWFzdXJlKHRoaXMucGxhY2VJbmZvUmVxKTtcbiAgICB9XG4gICAgdXBkYXRlU2VsKCkge1xuICAgICAgICBsZXQgY1N0YXRlID0gdGhpcy52aWV3LnN0YXRlLmZpZWxkKHRoaXMuc3RhdGVGaWVsZCksIG9wZW4gPSBjU3RhdGUub3BlbjtcbiAgICAgICAgaWYgKG9wZW4uc2VsZWN0ZWQgPiAtMSAmJiBvcGVuLnNlbGVjdGVkIDwgdGhpcy5yYW5nZS5mcm9tIHx8IG9wZW4uc2VsZWN0ZWQgPj0gdGhpcy5yYW5nZS50bykge1xuICAgICAgICAgICAgdGhpcy5yYW5nZSA9IHJhbmdlQXJvdW5kU2VsZWN0ZWQob3Blbi5vcHRpb25zLmxlbmd0aCwgb3Blbi5zZWxlY3RlZCwgdGhpcy52aWV3LnN0YXRlLmZhY2V0KGNvbXBsZXRpb25Db25maWcpLm1heFJlbmRlcmVkT3B0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLnNob3dPcHRpb25zKG9wZW4ub3B0aW9ucywgY1N0YXRlLmlkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy51cGRhdGVTZWxlY3RlZE9wdGlvbihvcGVuLnNlbGVjdGVkKSkge1xuICAgICAgICAgICAgdGhpcy5kZXN0cm95SW5mbygpO1xuICAgICAgICAgICAgbGV0IHsgY29tcGxldGlvbiB9ID0gb3Blbi5vcHRpb25zW29wZW4uc2VsZWN0ZWRdO1xuICAgICAgICAgICAgbGV0IHsgaW5mbyB9ID0gY29tcGxldGlvbjtcbiAgICAgICAgICAgIGlmICghaW5mbylcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsZXQgaW5mb1Jlc3VsdCA9IHR5cGVvZiBpbmZvID09PSBcInN0cmluZ1wiID8gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoaW5mbykgOiBpbmZvKGNvbXBsZXRpb24pO1xuICAgICAgICAgICAgaWYgKCFpbmZvUmVzdWx0KVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmIChcInRoZW5cIiBpbiBpbmZvUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgaW5mb1Jlc3VsdC50aGVuKG9iaiA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvYmogJiYgdGhpcy52aWV3LnN0YXRlLmZpZWxkKHRoaXMuc3RhdGVGaWVsZCwgZmFsc2UpID09IGNTdGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkSW5mb1BhbmUob2JqLCBjb21wbGV0aW9uKTtcbiAgICAgICAgICAgICAgICB9KS5jYXRjaChlID0+IGxvZ0V4Y2VwdGlvbih0aGlzLnZpZXcuc3RhdGUsIGUsIFwiY29tcGxldGlvbiBpbmZvXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkSW5mb1BhbmUoaW5mb1Jlc3VsdCwgY29tcGxldGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkSW5mb1BhbmUoY29udGVudCwgY29tcGxldGlvbikge1xuICAgICAgICB0aGlzLmRlc3Ryb3lJbmZvKCk7XG4gICAgICAgIGxldCB3cmFwID0gdGhpcy5pbmZvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgd3JhcC5jbGFzc05hbWUgPSBcImNtLXRvb2x0aXAgY20tY29tcGxldGlvbkluZm9cIjtcbiAgICAgICAgaWYgKGNvbnRlbnQubm9kZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgd3JhcC5hcHBlbmRDaGlsZChjb250ZW50KTtcbiAgICAgICAgICAgIHRoaXMuaW5mb0Rlc3Ryb3kgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IHsgZG9tLCBkZXN0cm95IH0gPSBjb250ZW50O1xuICAgICAgICAgICAgd3JhcC5hcHBlbmRDaGlsZChkb20pO1xuICAgICAgICAgICAgdGhpcy5pbmZvRGVzdHJveSA9IGRlc3Ryb3kgfHwgbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRvbS5hcHBlbmRDaGlsZCh3cmFwKTtcbiAgICAgICAgdGhpcy52aWV3LnJlcXVlc3RNZWFzdXJlKHRoaXMucGxhY2VJbmZvUmVxKTtcbiAgICB9XG4gICAgdXBkYXRlU2VsZWN0ZWRPcHRpb24oc2VsZWN0ZWQpIHtcbiAgICAgICAgbGV0IHNldCA9IG51bGw7XG4gICAgICAgIGZvciAobGV0IG9wdCA9IHRoaXMubGlzdC5maXJzdENoaWxkLCBpID0gdGhpcy5yYW5nZS5mcm9tOyBvcHQ7IG9wdCA9IG9wdC5uZXh0U2libGluZywgaSsrKSB7XG4gICAgICAgICAgICBpZiAob3B0Lm5vZGVOYW1lICE9IFwiTElcIiB8fCAhb3B0LmlkKSB7XG4gICAgICAgICAgICAgICAgaS0tOyAvLyBBIHNlY3Rpb24gaGVhZGVyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpID09IHNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFvcHQuaGFzQXR0cmlidXRlKFwiYXJpYS1zZWxlY3RlZFwiKSkge1xuICAgICAgICAgICAgICAgICAgICBvcHQuc2V0QXR0cmlidXRlKFwiYXJpYS1zZWxlY3RlZFwiLCBcInRydWVcIik7XG4gICAgICAgICAgICAgICAgICAgIHNldCA9IG9wdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0Lmhhc0F0dHJpYnV0ZShcImFyaWEtc2VsZWN0ZWRcIikpXG4gICAgICAgICAgICAgICAgICAgIG9wdC5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLXNlbGVjdGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzZXQpXG4gICAgICAgICAgICBzY3JvbGxJbnRvVmlldyh0aGlzLmxpc3QsIHNldCk7XG4gICAgICAgIHJldHVybiBzZXQ7XG4gICAgfVxuICAgIG1lYXN1cmVJbmZvKCkge1xuICAgICAgICBsZXQgc2VsID0gdGhpcy5kb20ucXVlcnlTZWxlY3RvcihcIlthcmlhLXNlbGVjdGVkXVwiKTtcbiAgICAgICAgaWYgKCFzZWwgfHwgIXRoaXMuaW5mbylcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgbGlzdFJlY3QgPSB0aGlzLmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgbGV0IGluZm9SZWN0ID0gdGhpcy5pbmZvLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBsZXQgc2VsUmVjdCA9IHNlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgbGV0IHNwYWNlID0gdGhpcy5zcGFjZTtcbiAgICAgICAgaWYgKCFzcGFjZSkge1xuICAgICAgICAgICAgbGV0IHdpbiA9IHRoaXMuZG9tLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgfHwgd2luZG93O1xuICAgICAgICAgICAgc3BhY2UgPSB7IGxlZnQ6IDAsIHRvcDogMCwgcmlnaHQ6IHdpbi5pbm5lcldpZHRoLCBib3R0b206IHdpbi5pbm5lckhlaWdodCB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxSZWN0LnRvcCA+IE1hdGgubWluKHNwYWNlLmJvdHRvbSwgbGlzdFJlY3QuYm90dG9tKSAtIDEwIHx8XG4gICAgICAgICAgICBzZWxSZWN0LmJvdHRvbSA8IE1hdGgubWF4KHNwYWNlLnRvcCwgbGlzdFJlY3QudG9wKSArIDEwKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXcuc3RhdGUuZmFjZXQoY29tcGxldGlvbkNvbmZpZykucG9zaXRpb25JbmZvKHRoaXMudmlldywgbGlzdFJlY3QsIHNlbFJlY3QsIGluZm9SZWN0LCBzcGFjZSwgdGhpcy5kb20pO1xuICAgIH1cbiAgICBwbGFjZUluZm8ocG9zKSB7XG4gICAgICAgIGlmICh0aGlzLmluZm8pIHtcbiAgICAgICAgICAgIGlmIChwb3MpIHtcbiAgICAgICAgICAgICAgICBpZiAocG9zLnN0eWxlKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmluZm8uc3R5bGUuY3NzVGV4dCA9IHBvcy5zdHlsZTtcbiAgICAgICAgICAgICAgICB0aGlzLmluZm8uY2xhc3NOYW1lID0gXCJjbS10b29sdGlwIGNtLWNvbXBsZXRpb25JbmZvIFwiICsgKHBvcy5jbGFzcyB8fCBcIlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5mby5zdHlsZS5jc3NUZXh0ID0gXCJ0b3A6IC0xZTZweFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNyZWF0ZUxpc3RCb3gob3B0aW9ucywgaWQsIHJhbmdlKSB7XG4gICAgICAgIGNvbnN0IHVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInVsXCIpO1xuICAgICAgICB1bC5pZCA9IGlkO1xuICAgICAgICB1bC5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwibGlzdGJveFwiKTtcbiAgICAgICAgdWwuc2V0QXR0cmlidXRlKFwiYXJpYS1leHBhbmRlZFwiLCBcInRydWVcIik7XG4gICAgICAgIHVsLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgdGhpcy52aWV3LnN0YXRlLnBocmFzZShcIkNvbXBsZXRpb25zXCIpKTtcbiAgICAgICAgbGV0IGN1clNlY3Rpb24gPSBudWxsO1xuICAgICAgICBmb3IgKGxldCBpID0gcmFuZ2UuZnJvbTsgaSA8IHJhbmdlLnRvOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB7IGNvbXBsZXRpb24sIG1hdGNoIH0gPSBvcHRpb25zW2ldLCB7IHNlY3Rpb24gfSA9IGNvbXBsZXRpb247XG4gICAgICAgICAgICBpZiAoc2VjdGlvbikge1xuICAgICAgICAgICAgICAgIGxldCBuYW1lID0gdHlwZW9mIHNlY3Rpb24gPT0gXCJzdHJpbmdcIiA/IHNlY3Rpb24gOiBzZWN0aW9uLm5hbWU7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUgIT0gY3VyU2VjdGlvbiAmJiAoaSA+IHJhbmdlLmZyb20gfHwgcmFuZ2UuZnJvbSA9PSAwKSkge1xuICAgICAgICAgICAgICAgICAgICBjdXJTZWN0aW9uID0gbmFtZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzZWN0aW9uICE9IFwic3RyaW5nXCIgJiYgc2VjdGlvbi5oZWFkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVsLmFwcGVuZENoaWxkKHNlY3Rpb24uaGVhZGVyKHNlY3Rpb24pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBoZWFkZXIgPSB1bC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY29tcGxldGlvbi1zZWN0aW9uXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlci50ZXh0Q29udGVudCA9IG5hbWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsaSA9IHVsLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaVwiKSk7XG4gICAgICAgICAgICBsaS5pZCA9IGlkICsgXCItXCIgKyBpO1xuICAgICAgICAgICAgbGkuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcIm9wdGlvblwiKTtcbiAgICAgICAgICAgIGxldCBjbHMgPSB0aGlzLm9wdGlvbkNsYXNzKGNvbXBsZXRpb24pO1xuICAgICAgICAgICAgaWYgKGNscylcbiAgICAgICAgICAgICAgICBsaS5jbGFzc05hbWUgPSBjbHM7XG4gICAgICAgICAgICBmb3IgKGxldCBzb3VyY2Ugb2YgdGhpcy5vcHRpb25Db250ZW50KSB7XG4gICAgICAgICAgICAgICAgbGV0IG5vZGUgPSBzb3VyY2UoY29tcGxldGlvbiwgdGhpcy52aWV3LnN0YXRlLCB0aGlzLnZpZXcsIG1hdGNoKTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZSlcbiAgICAgICAgICAgICAgICAgICAgbGkuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJhbmdlLmZyb20pXG4gICAgICAgICAgICB1bC5jbGFzc0xpc3QuYWRkKFwiY20tY29tcGxldGlvbkxpc3RJbmNvbXBsZXRlVG9wXCIpO1xuICAgICAgICBpZiAocmFuZ2UudG8gPCBvcHRpb25zLmxlbmd0aClcbiAgICAgICAgICAgIHVsLmNsYXNzTGlzdC5hZGQoXCJjbS1jb21wbGV0aW9uTGlzdEluY29tcGxldGVCb3R0b21cIik7XG4gICAgICAgIHJldHVybiB1bDtcbiAgICB9XG4gICAgZGVzdHJveUluZm8oKSB7XG4gICAgICAgIGlmICh0aGlzLmluZm8pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmluZm9EZXN0cm95KVxuICAgICAgICAgICAgICAgIHRoaXMuaW5mb0Rlc3Ryb3koKTtcbiAgICAgICAgICAgIHRoaXMuaW5mby5yZW1vdmUoKTtcbiAgICAgICAgICAgIHRoaXMuaW5mbyA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95SW5mbygpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbXBsZXRpb25Ub29sdGlwKHN0YXRlRmllbGQsIGFwcGx5Q29tcGxldGlvbikge1xuICAgIHJldHVybiAodmlldykgPT4gbmV3IENvbXBsZXRpb25Ub29sdGlwKHZpZXcsIHN0YXRlRmllbGQsIGFwcGx5Q29tcGxldGlvbik7XG59XG5mdW5jdGlvbiBzY3JvbGxJbnRvVmlldyhjb250YWluZXIsIGVsZW1lbnQpIHtcbiAgICBsZXQgcGFyZW50ID0gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGxldCBzZWxmID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBsZXQgc2NhbGVZID0gcGFyZW50LmhlaWdodCAvIGNvbnRhaW5lci5vZmZzZXRIZWlnaHQ7XG4gICAgaWYgKHNlbGYudG9wIDwgcGFyZW50LnRvcClcbiAgICAgICAgY29udGFpbmVyLnNjcm9sbFRvcCAtPSAocGFyZW50LnRvcCAtIHNlbGYudG9wKSAvIHNjYWxlWTtcbiAgICBlbHNlIGlmIChzZWxmLmJvdHRvbSA+IHBhcmVudC5ib3R0b20pXG4gICAgICAgIGNvbnRhaW5lci5zY3JvbGxUb3AgKz0gKHNlbGYuYm90dG9tIC0gcGFyZW50LmJvdHRvbSkgLyBzY2FsZVk7XG59XG5cbi8vIFVzZWQgdG8gcGljayBhIHByZWZlcnJlZCBvcHRpb24gd2hlbiB0d28gb3B0aW9ucyB3aXRoIHRoZSBzYW1lXG4vLyBsYWJlbCBvY2N1ciBpbiB0aGUgcmVzdWx0LlxuZnVuY3Rpb24gc2NvcmUob3B0aW9uKSB7XG4gICAgcmV0dXJuIChvcHRpb24uYm9vc3QgfHwgMCkgKiAxMDAgKyAob3B0aW9uLmFwcGx5ID8gMTAgOiAwKSArIChvcHRpb24uaW5mbyA/IDUgOiAwKSArXG4gICAgICAgIChvcHRpb24udHlwZSA/IDEgOiAwKTtcbn1cbmZ1bmN0aW9uIHNvcnRPcHRpb25zKGFjdGl2ZSwgc3RhdGUpIHtcbiAgICBsZXQgb3B0aW9ucyA9IFtdO1xuICAgIGxldCBzZWN0aW9ucyA9IG51bGw7XG4gICAgbGV0IGFkZE9wdGlvbiA9IChvcHRpb24pID0+IHtcbiAgICAgICAgb3B0aW9ucy5wdXNoKG9wdGlvbik7XG4gICAgICAgIGxldCB7IHNlY3Rpb24gfSA9IG9wdGlvbi5jb21wbGV0aW9uO1xuICAgICAgICBpZiAoc2VjdGlvbikge1xuICAgICAgICAgICAgaWYgKCFzZWN0aW9ucylcbiAgICAgICAgICAgICAgICBzZWN0aW9ucyA9IFtdO1xuICAgICAgICAgICAgbGV0IG5hbWUgPSB0eXBlb2Ygc2VjdGlvbiA9PSBcInN0cmluZ1wiID8gc2VjdGlvbiA6IHNlY3Rpb24ubmFtZTtcbiAgICAgICAgICAgIGlmICghc2VjdGlvbnMuc29tZShzID0+IHMubmFtZSA9PSBuYW1lKSlcbiAgICAgICAgICAgICAgICBzZWN0aW9ucy5wdXNoKHR5cGVvZiBzZWN0aW9uID09IFwic3RyaW5nXCIgPyB7IG5hbWUgfSA6IHNlY3Rpb24pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBmb3IgKGxldCBhIG9mIGFjdGl2ZSlcbiAgICAgICAgaWYgKGEuaGFzUmVzdWx0KCkpIHtcbiAgICAgICAgICAgIGxldCBnZXRNYXRjaCA9IGEucmVzdWx0LmdldE1hdGNoO1xuICAgICAgICAgICAgaWYgKGEucmVzdWx0LmZpbHRlciA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBvcHRpb24gb2YgYS5yZXN1bHQub3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICBhZGRPcHRpb24obmV3IE9wdGlvbihvcHRpb24sIGEuc291cmNlLCBnZXRNYXRjaCA/IGdldE1hdGNoKG9wdGlvbikgOiBbXSwgMWU5IC0gb3B0aW9ucy5sZW5ndGgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgbWF0Y2hlciA9IG5ldyBGdXp6eU1hdGNoZXIoc3RhdGUuc2xpY2VEb2MoYS5mcm9tLCBhLnRvKSk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgb3B0aW9uIG9mIGEucmVzdWx0Lm9wdGlvbnMpXG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGVyLm1hdGNoKG9wdGlvbi5sYWJlbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtYXRjaGVkID0gIW9wdGlvbi5kaXNwbGF5TGFiZWwgPyBtYXRjaGVyLm1hdGNoZWQgOiBnZXRNYXRjaCA/IGdldE1hdGNoKG9wdGlvbiwgbWF0Y2hlci5tYXRjaGVkKSA6IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkT3B0aW9uKG5ldyBPcHRpb24ob3B0aW9uLCBhLnNvdXJjZSwgbWF0Y2hlZCwgbWF0Y2hlci5zY29yZSArIChvcHRpb24uYm9vc3QgfHwgMCkpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgaWYgKHNlY3Rpb25zKSB7XG4gICAgICAgIGxldCBzZWN0aW9uT3JkZXIgPSBPYmplY3QuY3JlYXRlKG51bGwpLCBwb3MgPSAwO1xuICAgICAgICBsZXQgY21wID0gKGEsIGIpID0+IHsgdmFyIF9hLCBfYjsgcmV0dXJuICgoX2EgPSBhLnJhbmspICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDFlOSkgLSAoKF9iID0gYi5yYW5rKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAxZTkpIHx8IChhLm5hbWUgPCBiLm5hbWUgPyAtMSA6IDEpOyB9O1xuICAgICAgICBmb3IgKGxldCBzIG9mIHNlY3Rpb25zLnNvcnQoY21wKSkge1xuICAgICAgICAgICAgcG9zIC09IDFlNTtcbiAgICAgICAgICAgIHNlY3Rpb25PcmRlcltzLm5hbWVdID0gcG9zO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IG9wdGlvbiBvZiBvcHRpb25zKSB7XG4gICAgICAgICAgICBsZXQgeyBzZWN0aW9uIH0gPSBvcHRpb24uY29tcGxldGlvbjtcbiAgICAgICAgICAgIGlmIChzZWN0aW9uKVxuICAgICAgICAgICAgICAgIG9wdGlvbi5zY29yZSArPSBzZWN0aW9uT3JkZXJbdHlwZW9mIHNlY3Rpb24gPT0gXCJzdHJpbmdcIiA/IHNlY3Rpb24gOiBzZWN0aW9uLm5hbWVdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCByZXN1bHQgPSBbXSwgcHJldiA9IG51bGw7XG4gICAgbGV0IGNvbXBhcmUgPSBzdGF0ZS5mYWNldChjb21wbGV0aW9uQ29uZmlnKS5jb21wYXJlQ29tcGxldGlvbnM7XG4gICAgZm9yIChsZXQgb3B0IG9mIG9wdGlvbnMuc29ydCgoYSwgYikgPT4gKGIuc2NvcmUgLSBhLnNjb3JlKSB8fCBjb21wYXJlKGEuY29tcGxldGlvbiwgYi5jb21wbGV0aW9uKSkpIHtcbiAgICAgICAgbGV0IGN1ciA9IG9wdC5jb21wbGV0aW9uO1xuICAgICAgICBpZiAoIXByZXYgfHwgcHJldi5sYWJlbCAhPSBjdXIubGFiZWwgfHwgcHJldi5kZXRhaWwgIT0gY3VyLmRldGFpbCB8fFxuICAgICAgICAgICAgKHByZXYudHlwZSAhPSBudWxsICYmIGN1ci50eXBlICE9IG51bGwgJiYgcHJldi50eXBlICE9IGN1ci50eXBlKSB8fFxuICAgICAgICAgICAgcHJldi5hcHBseSAhPSBjdXIuYXBwbHkgfHwgcHJldi5ib29zdCAhPSBjdXIuYm9vc3QpXG4gICAgICAgICAgICByZXN1bHQucHVzaChvcHQpO1xuICAgICAgICBlbHNlIGlmIChzY29yZShvcHQuY29tcGxldGlvbikgPiBzY29yZShwcmV2KSlcbiAgICAgICAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0gPSBvcHQ7XG4gICAgICAgIHByZXYgPSBvcHQuY29tcGxldGlvbjtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNsYXNzIENvbXBsZXRpb25EaWFsb2cge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGF0dHJzLCB0b29sdGlwLCB0aW1lc3RhbXAsIHNlbGVjdGVkLCBkaXNhYmxlZCkge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLmF0dHJzID0gYXR0cnM7XG4gICAgICAgIHRoaXMudG9vbHRpcCA9IHRvb2x0aXA7XG4gICAgICAgIHRoaXMudGltZXN0YW1wID0gdGltZXN0YW1wO1xuICAgICAgICB0aGlzLnNlbGVjdGVkID0gc2VsZWN0ZWQ7XG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBkaXNhYmxlZDtcbiAgICB9XG4gICAgc2V0U2VsZWN0ZWQoc2VsZWN0ZWQsIGlkKSB7XG4gICAgICAgIHJldHVybiBzZWxlY3RlZCA9PSB0aGlzLnNlbGVjdGVkIHx8IHNlbGVjdGVkID49IHRoaXMub3B0aW9ucy5sZW5ndGggPyB0aGlzXG4gICAgICAgICAgICA6IG5ldyBDb21wbGV0aW9uRGlhbG9nKHRoaXMub3B0aW9ucywgbWFrZUF0dHJzKGlkLCBzZWxlY3RlZCksIHRoaXMudG9vbHRpcCwgdGhpcy50aW1lc3RhbXAsIHNlbGVjdGVkLCB0aGlzLmRpc2FibGVkKTtcbiAgICB9XG4gICAgc3RhdGljIGJ1aWxkKGFjdGl2ZSwgc3RhdGUsIGlkLCBwcmV2LCBjb25mKSB7XG4gICAgICAgIGxldCBvcHRpb25zID0gc29ydE9wdGlvbnMoYWN0aXZlLCBzdGF0ZSk7XG4gICAgICAgIGlmICghb3B0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBwcmV2ICYmIGFjdGl2ZS5zb21lKGEgPT4gYS5zdGF0ZSA9PSAxIC8qIFN0YXRlLlBlbmRpbmcgKi8pID9cbiAgICAgICAgICAgICAgICBuZXcgQ29tcGxldGlvbkRpYWxvZyhwcmV2Lm9wdGlvbnMsIHByZXYuYXR0cnMsIHByZXYudG9vbHRpcCwgcHJldi50aW1lc3RhbXAsIHByZXYuc2VsZWN0ZWQsIHRydWUpIDogbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc2VsZWN0ZWQgPSBzdGF0ZS5mYWNldChjb21wbGV0aW9uQ29uZmlnKS5zZWxlY3RPbk9wZW4gPyAwIDogLTE7XG4gICAgICAgIGlmIChwcmV2ICYmIHByZXYuc2VsZWN0ZWQgIT0gc2VsZWN0ZWQgJiYgcHJldi5zZWxlY3RlZCAhPSAtMSkge1xuICAgICAgICAgICAgbGV0IHNlbGVjdGVkVmFsdWUgPSBwcmV2Lm9wdGlvbnNbcHJldi5zZWxlY3RlZF0uY29tcGxldGlvbjtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3B0aW9ucy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9uc1tpXS5jb21wbGV0aW9uID09IHNlbGVjdGVkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQgPSBpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV0aW9uRGlhbG9nKG9wdGlvbnMsIG1ha2VBdHRycyhpZCwgc2VsZWN0ZWQpLCB7XG4gICAgICAgICAgICBwb3M6IGFjdGl2ZS5yZWR1Y2UoKGEsIGIpID0+IGIuaGFzUmVzdWx0KCkgPyBNYXRoLm1pbihhLCBiLmZyb20pIDogYSwgMWU4KSxcbiAgICAgICAgICAgIGNyZWF0ZTogY3JlYXRlVG9vbHRpcCxcbiAgICAgICAgICAgIGFib3ZlOiBjb25mLmFib3ZlQ3Vyc29yLFxuICAgICAgICB9LCBwcmV2ID8gcHJldi50aW1lc3RhbXAgOiBEYXRlLm5vdygpLCBzZWxlY3RlZCwgZmFsc2UpO1xuICAgIH1cbiAgICBtYXAoY2hhbmdlcykge1xuICAgICAgICByZXR1cm4gbmV3IENvbXBsZXRpb25EaWFsb2codGhpcy5vcHRpb25zLCB0aGlzLmF0dHJzLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMudG9vbHRpcCksIHsgcG9zOiBjaGFuZ2VzLm1hcFBvcyh0aGlzLnRvb2x0aXAucG9zKSB9KSwgdGhpcy50aW1lc3RhbXAsIHRoaXMuc2VsZWN0ZWQsIHRoaXMuZGlzYWJsZWQpO1xuICAgIH1cbn1cbmNsYXNzIENvbXBsZXRpb25TdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoYWN0aXZlLCBpZCwgb3Blbikge1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IGFjdGl2ZTtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLm9wZW4gPSBvcGVuO1xuICAgIH1cbiAgICBzdGF0aWMgc3RhcnQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29tcGxldGlvblN0YXRlKG5vbmUsIFwiY20tYWMtXCIgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyZTYpLnRvU3RyaW5nKDM2KSwgbnVsbCk7XG4gICAgfVxuICAgIHVwZGF0ZSh0cikge1xuICAgICAgICBsZXQgeyBzdGF0ZSB9ID0gdHIsIGNvbmYgPSBzdGF0ZS5mYWNldChjb21wbGV0aW9uQ29uZmlnKTtcbiAgICAgICAgbGV0IHNvdXJjZXMgPSBjb25mLm92ZXJyaWRlIHx8XG4gICAgICAgICAgICBzdGF0ZS5sYW5ndWFnZURhdGFBdChcImF1dG9jb21wbGV0ZVwiLCBjdXIoc3RhdGUpKS5tYXAoYXNTb3VyY2UpO1xuICAgICAgICBsZXQgYWN0aXZlID0gc291cmNlcy5tYXAoc291cmNlID0+IHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IHRoaXMuYWN0aXZlLmZpbmQocyA9PiBzLnNvdXJjZSA9PSBzb3VyY2UpIHx8XG4gICAgICAgICAgICAgICAgbmV3IEFjdGl2ZVNvdXJjZShzb3VyY2UsIHRoaXMuYWN0aXZlLnNvbWUoYSA9PiBhLnN0YXRlICE9IDAgLyogU3RhdGUuSW5hY3RpdmUgKi8pID8gMSAvKiBTdGF0ZS5QZW5kaW5nICovIDogMCAvKiBTdGF0ZS5JbmFjdGl2ZSAqLyk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUudXBkYXRlKHRyLCBjb25mKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChhY3RpdmUubGVuZ3RoID09IHRoaXMuYWN0aXZlLmxlbmd0aCAmJiBhY3RpdmUuZXZlcnkoKGEsIGkpID0+IGEgPT0gdGhpcy5hY3RpdmVbaV0pKVxuICAgICAgICAgICAgYWN0aXZlID0gdGhpcy5hY3RpdmU7XG4gICAgICAgIGxldCBvcGVuID0gdGhpcy5vcGVuO1xuICAgICAgICBpZiAob3BlbiAmJiB0ci5kb2NDaGFuZ2VkKVxuICAgICAgICAgICAgb3BlbiA9IG9wZW4ubWFwKHRyLmNoYW5nZXMpO1xuICAgICAgICBpZiAodHIuc2VsZWN0aW9uIHx8IGFjdGl2ZS5zb21lKGEgPT4gYS5oYXNSZXN1bHQoKSAmJiB0ci5jaGFuZ2VzLnRvdWNoZXNSYW5nZShhLmZyb20sIGEudG8pKSB8fFxuICAgICAgICAgICAgIXNhbWVSZXN1bHRzKGFjdGl2ZSwgdGhpcy5hY3RpdmUpKVxuICAgICAgICAgICAgb3BlbiA9IENvbXBsZXRpb25EaWFsb2cuYnVpbGQoYWN0aXZlLCBzdGF0ZSwgdGhpcy5pZCwgb3BlbiwgY29uZik7XG4gICAgICAgIGVsc2UgaWYgKG9wZW4gJiYgb3Blbi5kaXNhYmxlZCAmJiAhYWN0aXZlLnNvbWUoYSA9PiBhLnN0YXRlID09IDEgLyogU3RhdGUuUGVuZGluZyAqLykpXG4gICAgICAgICAgICBvcGVuID0gbnVsbDtcbiAgICAgICAgaWYgKCFvcGVuICYmIGFjdGl2ZS5ldmVyeShhID0+IGEuc3RhdGUgIT0gMSAvKiBTdGF0ZS5QZW5kaW5nICovKSAmJiBhY3RpdmUuc29tZShhID0+IGEuaGFzUmVzdWx0KCkpKVxuICAgICAgICAgICAgYWN0aXZlID0gYWN0aXZlLm1hcChhID0+IGEuaGFzUmVzdWx0KCkgPyBuZXcgQWN0aXZlU291cmNlKGEuc291cmNlLCAwIC8qIFN0YXRlLkluYWN0aXZlICovKSA6IGEpO1xuICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgdHIuZWZmZWN0cylcbiAgICAgICAgICAgIGlmIChlZmZlY3QuaXMoc2V0U2VsZWN0ZWRFZmZlY3QpKVxuICAgICAgICAgICAgICAgIG9wZW4gPSBvcGVuICYmIG9wZW4uc2V0U2VsZWN0ZWQoZWZmZWN0LnZhbHVlLCB0aGlzLmlkKTtcbiAgICAgICAgcmV0dXJuIGFjdGl2ZSA9PSB0aGlzLmFjdGl2ZSAmJiBvcGVuID09IHRoaXMub3BlbiA/IHRoaXMgOiBuZXcgQ29tcGxldGlvblN0YXRlKGFjdGl2ZSwgdGhpcy5pZCwgb3Blbik7XG4gICAgfVxuICAgIGdldCB0b29sdGlwKCkgeyByZXR1cm4gdGhpcy5vcGVuID8gdGhpcy5vcGVuLnRvb2x0aXAgOiBudWxsOyB9XG4gICAgZ2V0IGF0dHJzKCkgeyByZXR1cm4gdGhpcy5vcGVuID8gdGhpcy5vcGVuLmF0dHJzIDogYmFzZUF0dHJzOyB9XG59XG5mdW5jdGlvbiBzYW1lUmVzdWx0cyhhLCBiKSB7XG4gICAgaWYgKGEgPT0gYilcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgZm9yIChsZXQgaUEgPSAwLCBpQiA9IDA7Oykge1xuICAgICAgICB3aGlsZSAoaUEgPCBhLmxlbmd0aCAmJiAhYVtpQV0uaGFzUmVzdWx0KVxuICAgICAgICAgICAgaUErKztcbiAgICAgICAgd2hpbGUgKGlCIDwgYi5sZW5ndGggJiYgIWJbaUJdLmhhc1Jlc3VsdClcbiAgICAgICAgICAgIGlCKys7XG4gICAgICAgIGxldCBlbmRBID0gaUEgPT0gYS5sZW5ndGgsIGVuZEIgPSBpQiA9PSBiLmxlbmd0aDtcbiAgICAgICAgaWYgKGVuZEEgfHwgZW5kQilcbiAgICAgICAgICAgIHJldHVybiBlbmRBID09IGVuZEI7XG4gICAgICAgIGlmIChhW2lBKytdLnJlc3VsdCAhPSBiW2lCKytdLnJlc3VsdClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5jb25zdCBiYXNlQXR0cnMgPSB7XG4gICAgXCJhcmlhLWF1dG9jb21wbGV0ZVwiOiBcImxpc3RcIlxufTtcbmZ1bmN0aW9uIG1ha2VBdHRycyhpZCwgc2VsZWN0ZWQpIHtcbiAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgICBcImFyaWEtYXV0b2NvbXBsZXRlXCI6IFwibGlzdFwiLFxuICAgICAgICBcImFyaWEtaGFzcG9wdXBcIjogXCJsaXN0Ym94XCIsXG4gICAgICAgIFwiYXJpYS1jb250cm9sc1wiOiBpZFxuICAgIH07XG4gICAgaWYgKHNlbGVjdGVkID4gLTEpXG4gICAgICAgIHJlc3VsdFtcImFyaWEtYWN0aXZlZGVzY2VuZGFudFwiXSA9IGlkICsgXCItXCIgKyBzZWxlY3RlZDtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuY29uc3Qgbm9uZSA9IFtdO1xuZnVuY3Rpb24gZ2V0VXNlckV2ZW50KHRyKSB7XG4gICAgcmV0dXJuIHRyLmlzVXNlckV2ZW50KFwiaW5wdXQudHlwZVwiKSA/IFwiaW5wdXRcIiA6IHRyLmlzVXNlckV2ZW50KFwiZGVsZXRlLmJhY2t3YXJkXCIpID8gXCJkZWxldGVcIiA6IG51bGw7XG59XG5jbGFzcyBBY3RpdmVTb3VyY2Uge1xuICAgIGNvbnN0cnVjdG9yKHNvdXJjZSwgc3RhdGUsIGV4cGxpY2l0UG9zID0gLTEpIHtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgdGhpcy5leHBsaWNpdFBvcyA9IGV4cGxpY2l0UG9zO1xuICAgIH1cbiAgICBoYXNSZXN1bHQoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIHVwZGF0ZSh0ciwgY29uZikge1xuICAgICAgICBsZXQgZXZlbnQgPSBnZXRVc2VyRXZlbnQodHIpLCB2YWx1ZSA9IHRoaXM7XG4gICAgICAgIGlmIChldmVudClcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuaGFuZGxlVXNlckV2ZW50KHRyLCBldmVudCwgY29uZik7XG4gICAgICAgIGVsc2UgaWYgKHRyLmRvY0NoYW5nZWQpXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLmhhbmRsZUNoYW5nZSh0cik7XG4gICAgICAgIGVsc2UgaWYgKHRyLnNlbGVjdGlvbiAmJiB2YWx1ZS5zdGF0ZSAhPSAwIC8qIFN0YXRlLkluYWN0aXZlICovKVxuICAgICAgICAgICAgdmFsdWUgPSBuZXcgQWN0aXZlU291cmNlKHZhbHVlLnNvdXJjZSwgMCAvKiBTdGF0ZS5JbmFjdGl2ZSAqLyk7XG4gICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiB0ci5lZmZlY3RzKSB7XG4gICAgICAgICAgICBpZiAoZWZmZWN0LmlzKHN0YXJ0Q29tcGxldGlvbkVmZmVjdCkpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBuZXcgQWN0aXZlU291cmNlKHZhbHVlLnNvdXJjZSwgMSAvKiBTdGF0ZS5QZW5kaW5nICovLCBlZmZlY3QudmFsdWUgPyBjdXIodHIuc3RhdGUpIDogLTEpO1xuICAgICAgICAgICAgZWxzZSBpZiAoZWZmZWN0LmlzKGNsb3NlQ29tcGxldGlvbkVmZmVjdCkpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBuZXcgQWN0aXZlU291cmNlKHZhbHVlLnNvdXJjZSwgMCAvKiBTdGF0ZS5JbmFjdGl2ZSAqLyk7XG4gICAgICAgICAgICBlbHNlIGlmIChlZmZlY3QuaXMoc2V0QWN0aXZlRWZmZWN0KSlcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBhY3RpdmUgb2YgZWZmZWN0LnZhbHVlKVxuICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aXZlLnNvdXJjZSA9PSB2YWx1ZS5zb3VyY2UpXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGFjdGl2ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGhhbmRsZVVzZXJFdmVudCh0ciwgdHlwZSwgY29uZikge1xuICAgICAgICByZXR1cm4gdHlwZSA9PSBcImRlbGV0ZVwiIHx8ICFjb25mLmFjdGl2YXRlT25UeXBpbmcgPyB0aGlzLm1hcCh0ci5jaGFuZ2VzKSA6IG5ldyBBY3RpdmVTb3VyY2UodGhpcy5zb3VyY2UsIDEgLyogU3RhdGUuUGVuZGluZyAqLyk7XG4gICAgfVxuICAgIGhhbmRsZUNoYW5nZSh0cikge1xuICAgICAgICByZXR1cm4gdHIuY2hhbmdlcy50b3VjaGVzUmFuZ2UoY3VyKHRyLnN0YXJ0U3RhdGUpKSA/IG5ldyBBY3RpdmVTb3VyY2UodGhpcy5zb3VyY2UsIDAgLyogU3RhdGUuSW5hY3RpdmUgKi8pIDogdGhpcy5tYXAodHIuY2hhbmdlcyk7XG4gICAgfVxuICAgIG1hcChjaGFuZ2VzKSB7XG4gICAgICAgIHJldHVybiBjaGFuZ2VzLmVtcHR5IHx8IHRoaXMuZXhwbGljaXRQb3MgPCAwID8gdGhpcyA6IG5ldyBBY3RpdmVTb3VyY2UodGhpcy5zb3VyY2UsIHRoaXMuc3RhdGUsIGNoYW5nZXMubWFwUG9zKHRoaXMuZXhwbGljaXRQb3MpKTtcbiAgICB9XG59XG5jbGFzcyBBY3RpdmVSZXN1bHQgZXh0ZW5kcyBBY3RpdmVTb3VyY2Uge1xuICAgIGNvbnN0cnVjdG9yKHNvdXJjZSwgZXhwbGljaXRQb3MsIHJlc3VsdCwgZnJvbSwgdG8pIHtcbiAgICAgICAgc3VwZXIoc291cmNlLCAyIC8qIFN0YXRlLlJlc3VsdCAqLywgZXhwbGljaXRQb3MpO1xuICAgICAgICB0aGlzLnJlc3VsdCA9IHJlc3VsdDtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgIH1cbiAgICBoYXNSZXN1bHQoKSB7IHJldHVybiB0cnVlOyB9XG4gICAgaGFuZGxlVXNlckV2ZW50KHRyLCB0eXBlLCBjb25mKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgbGV0IGZyb20gPSB0ci5jaGFuZ2VzLm1hcFBvcyh0aGlzLmZyb20pLCB0byA9IHRyLmNoYW5nZXMubWFwUG9zKHRoaXMudG8sIDEpO1xuICAgICAgICBsZXQgcG9zID0gY3VyKHRyLnN0YXRlKTtcbiAgICAgICAgaWYgKCh0aGlzLmV4cGxpY2l0UG9zIDwgMCA/IHBvcyA8PSBmcm9tIDogcG9zIDwgdGhpcy5mcm9tKSB8fFxuICAgICAgICAgICAgcG9zID4gdG8gfHxcbiAgICAgICAgICAgIHR5cGUgPT0gXCJkZWxldGVcIiAmJiBjdXIodHIuc3RhcnRTdGF0ZSkgPT0gdGhpcy5mcm9tKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBY3RpdmVTb3VyY2UodGhpcy5zb3VyY2UsIHR5cGUgPT0gXCJpbnB1dFwiICYmIGNvbmYuYWN0aXZhdGVPblR5cGluZyA/IDEgLyogU3RhdGUuUGVuZGluZyAqLyA6IDAgLyogU3RhdGUuSW5hY3RpdmUgKi8pO1xuICAgICAgICBsZXQgZXhwbGljaXRQb3MgPSB0aGlzLmV4cGxpY2l0UG9zIDwgMCA/IC0xIDogdHIuY2hhbmdlcy5tYXBQb3ModGhpcy5leHBsaWNpdFBvcyksIHVwZGF0ZWQ7XG4gICAgICAgIGlmIChjaGVja1ZhbGlkKHRoaXMucmVzdWx0LnZhbGlkRm9yLCB0ci5zdGF0ZSwgZnJvbSwgdG8pKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBY3RpdmVSZXN1bHQodGhpcy5zb3VyY2UsIGV4cGxpY2l0UG9zLCB0aGlzLnJlc3VsdCwgZnJvbSwgdG8pO1xuICAgICAgICBpZiAodGhpcy5yZXN1bHQudXBkYXRlICYmXG4gICAgICAgICAgICAodXBkYXRlZCA9IHRoaXMucmVzdWx0LnVwZGF0ZSh0aGlzLnJlc3VsdCwgZnJvbSwgdG8sIG5ldyBDb21wbGV0aW9uQ29udGV4dCh0ci5zdGF0ZSwgcG9zLCBleHBsaWNpdFBvcyA+PSAwKSkpKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBY3RpdmVSZXN1bHQodGhpcy5zb3VyY2UsIGV4cGxpY2l0UG9zLCB1cGRhdGVkLCB1cGRhdGVkLmZyb20sIChfYSA9IHVwZGF0ZWQudG8pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGN1cih0ci5zdGF0ZSkpO1xuICAgICAgICByZXR1cm4gbmV3IEFjdGl2ZVNvdXJjZSh0aGlzLnNvdXJjZSwgMSAvKiBTdGF0ZS5QZW5kaW5nICovLCBleHBsaWNpdFBvcyk7XG4gICAgfVxuICAgIGhhbmRsZUNoYW5nZSh0cikge1xuICAgICAgICByZXR1cm4gdHIuY2hhbmdlcy50b3VjaGVzUmFuZ2UodGhpcy5mcm9tLCB0aGlzLnRvKSA/IG5ldyBBY3RpdmVTb3VyY2UodGhpcy5zb3VyY2UsIDAgLyogU3RhdGUuSW5hY3RpdmUgKi8pIDogdGhpcy5tYXAodHIuY2hhbmdlcyk7XG4gICAgfVxuICAgIG1hcChtYXBwaW5nKSB7XG4gICAgICAgIHJldHVybiBtYXBwaW5nLmVtcHR5ID8gdGhpcyA6XG4gICAgICAgICAgICBuZXcgQWN0aXZlUmVzdWx0KHRoaXMuc291cmNlLCB0aGlzLmV4cGxpY2l0UG9zIDwgMCA/IC0xIDogbWFwcGluZy5tYXBQb3ModGhpcy5leHBsaWNpdFBvcyksIHRoaXMucmVzdWx0LCBtYXBwaW5nLm1hcFBvcyh0aGlzLmZyb20pLCBtYXBwaW5nLm1hcFBvcyh0aGlzLnRvLCAxKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gY2hlY2tWYWxpZCh2YWxpZEZvciwgc3RhdGUsIGZyb20sIHRvKSB7XG4gICAgaWYgKCF2YWxpZEZvcilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCB0ZXh0ID0gc3RhdGUuc2xpY2VEb2MoZnJvbSwgdG8pO1xuICAgIHJldHVybiB0eXBlb2YgdmFsaWRGb3IgPT0gXCJmdW5jdGlvblwiID8gdmFsaWRGb3IodGV4dCwgZnJvbSwgdG8sIHN0YXRlKSA6IGVuc3VyZUFuY2hvcih2YWxpZEZvciwgdHJ1ZSkudGVzdCh0ZXh0KTtcbn1cbmNvbnN0IHNldEFjdGl2ZUVmZmVjdCA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoe1xuICAgIG1hcChzb3VyY2VzLCBtYXBwaW5nKSB7IHJldHVybiBzb3VyY2VzLm1hcChzID0+IHMubWFwKG1hcHBpbmcpKTsgfVxufSk7XG5jb25zdCBzZXRTZWxlY3RlZEVmZmVjdCA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcbmNvbnN0IGNvbXBsZXRpb25TdGF0ZSA9IC8qQF9fUFVSRV9fKi9TdGF0ZUZpZWxkLmRlZmluZSh7XG4gICAgY3JlYXRlKCkgeyByZXR1cm4gQ29tcGxldGlvblN0YXRlLnN0YXJ0KCk7IH0sXG4gICAgdXBkYXRlKHZhbHVlLCB0cikgeyByZXR1cm4gdmFsdWUudXBkYXRlKHRyKTsgfSxcbiAgICBwcm92aWRlOiBmID0+IFtcbiAgICAgICAgc2hvd1Rvb2x0aXAuZnJvbShmLCB2YWwgPT4gdmFsLnRvb2x0aXApLFxuICAgICAgICBFZGl0b3JWaWV3LmNvbnRlbnRBdHRyaWJ1dGVzLmZyb20oZiwgc3RhdGUgPT4gc3RhdGUuYXR0cnMpXG4gICAgXVxufSk7XG5mdW5jdGlvbiBhcHBseUNvbXBsZXRpb24odmlldywgb3B0aW9uKSB7XG4gICAgY29uc3QgYXBwbHkgPSBvcHRpb24uY29tcGxldGlvbi5hcHBseSB8fCBvcHRpb24uY29tcGxldGlvbi5sYWJlbDtcbiAgICBsZXQgcmVzdWx0ID0gdmlldy5zdGF0ZS5maWVsZChjb21wbGV0aW9uU3RhdGUpLmFjdGl2ZS5maW5kKGEgPT4gYS5zb3VyY2UgPT0gb3B0aW9uLnNvdXJjZSk7XG4gICAgaWYgKCEocmVzdWx0IGluc3RhbmNlb2YgQWN0aXZlUmVzdWx0KSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0eXBlb2YgYXBwbHkgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgdmlldy5kaXNwYXRjaChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGluc2VydENvbXBsZXRpb25UZXh0KHZpZXcuc3RhdGUsIGFwcGx5LCByZXN1bHQuZnJvbSwgcmVzdWx0LnRvKSksIHsgYW5ub3RhdGlvbnM6IHBpY2tlZENvbXBsZXRpb24ub2Yob3B0aW9uLmNvbXBsZXRpb24pIH0pKTtcbiAgICBlbHNlXG4gICAgICAgIGFwcGx5KHZpZXcsIG9wdGlvbi5jb21wbGV0aW9uLCByZXN1bHQuZnJvbSwgcmVzdWx0LnRvKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmNvbnN0IGNyZWF0ZVRvb2x0aXAgPSAvKkBfX1BVUkVfXyovY29tcGxldGlvblRvb2x0aXAoY29tcGxldGlvblN0YXRlLCBhcHBseUNvbXBsZXRpb24pO1xuXG4vKipcblJldHVybnMgYSBjb21tYW5kIHRoYXQgbW92ZXMgdGhlIGNvbXBsZXRpb24gc2VsZWN0aW9uIGZvcndhcmQgb3JcbmJhY2t3YXJkIGJ5IHRoZSBnaXZlbiBhbW91bnQuXG4qL1xuZnVuY3Rpb24gbW92ZUNvbXBsZXRpb25TZWxlY3Rpb24oZm9yd2FyZCwgYnkgPSBcIm9wdGlvblwiKSB7XG4gICAgcmV0dXJuICh2aWV3KSA9PiB7XG4gICAgICAgIGxldCBjU3RhdGUgPSB2aWV3LnN0YXRlLmZpZWxkKGNvbXBsZXRpb25TdGF0ZSwgZmFsc2UpO1xuICAgICAgICBpZiAoIWNTdGF0ZSB8fCAhY1N0YXRlLm9wZW4gfHwgY1N0YXRlLm9wZW4uZGlzYWJsZWQgfHxcbiAgICAgICAgICAgIERhdGUubm93KCkgLSBjU3RhdGUub3Blbi50aW1lc3RhbXAgPCB2aWV3LnN0YXRlLmZhY2V0KGNvbXBsZXRpb25Db25maWcpLmludGVyYWN0aW9uRGVsYXkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCBzdGVwID0gMSwgdG9vbHRpcDtcbiAgICAgICAgaWYgKGJ5ID09IFwicGFnZVwiICYmICh0b29sdGlwID0gZ2V0VG9vbHRpcCh2aWV3LCBjU3RhdGUub3Blbi50b29sdGlwKSkpXG4gICAgICAgICAgICBzdGVwID0gTWF0aC5tYXgoMiwgTWF0aC5mbG9vcih0b29sdGlwLmRvbS5vZmZzZXRIZWlnaHQgL1xuICAgICAgICAgICAgICAgIHRvb2x0aXAuZG9tLnF1ZXJ5U2VsZWN0b3IoXCJsaVwiKS5vZmZzZXRIZWlnaHQpIC0gMSk7XG4gICAgICAgIGxldCB7IGxlbmd0aCB9ID0gY1N0YXRlLm9wZW4ub3B0aW9ucztcbiAgICAgICAgbGV0IHNlbGVjdGVkID0gY1N0YXRlLm9wZW4uc2VsZWN0ZWQgPiAtMSA/IGNTdGF0ZS5vcGVuLnNlbGVjdGVkICsgc3RlcCAqIChmb3J3YXJkID8gMSA6IC0xKSA6IGZvcndhcmQgPyAwIDogbGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKHNlbGVjdGVkIDwgMClcbiAgICAgICAgICAgIHNlbGVjdGVkID0gYnkgPT0gXCJwYWdlXCIgPyAwIDogbGVuZ3RoIC0gMTtcbiAgICAgICAgZWxzZSBpZiAoc2VsZWN0ZWQgPj0gbGVuZ3RoKVxuICAgICAgICAgICAgc2VsZWN0ZWQgPSBieSA9PSBcInBhZ2VcIiA/IGxlbmd0aCAtIDEgOiAwO1xuICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogc2V0U2VsZWN0ZWRFZmZlY3Qub2Yoc2VsZWN0ZWQpIH0pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuLyoqXG5BY2NlcHQgdGhlIGN1cnJlbnQgY29tcGxldGlvbi5cbiovXG5jb25zdCBhY2NlcHRDb21wbGV0aW9uID0gKHZpZXcpID0+IHtcbiAgICBsZXQgY1N0YXRlID0gdmlldy5zdGF0ZS5maWVsZChjb21wbGV0aW9uU3RhdGUsIGZhbHNlKTtcbiAgICBpZiAodmlldy5zdGF0ZS5yZWFkT25seSB8fCAhY1N0YXRlIHx8ICFjU3RhdGUub3BlbiB8fCBjU3RhdGUub3Blbi5zZWxlY3RlZCA8IDAgfHwgY1N0YXRlLm9wZW4uZGlzYWJsZWQgfHxcbiAgICAgICAgRGF0ZS5ub3coKSAtIGNTdGF0ZS5vcGVuLnRpbWVzdGFtcCA8IHZpZXcuc3RhdGUuZmFjZXQoY29tcGxldGlvbkNvbmZpZykuaW50ZXJhY3Rpb25EZWxheSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBhcHBseUNvbXBsZXRpb24odmlldywgY1N0YXRlLm9wZW4ub3B0aW9uc1tjU3RhdGUub3Blbi5zZWxlY3RlZF0pO1xufTtcbi8qKlxuRXhwbGljaXRseSBzdGFydCBhdXRvY29tcGxldGlvbi5cbiovXG5jb25zdCBzdGFydENvbXBsZXRpb24gPSAodmlldykgPT4ge1xuICAgIGxldCBjU3RhdGUgPSB2aWV3LnN0YXRlLmZpZWxkKGNvbXBsZXRpb25TdGF0ZSwgZmFsc2UpO1xuICAgIGlmICghY1N0YXRlKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHN0YXJ0Q29tcGxldGlvbkVmZmVjdC5vZih0cnVlKSB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbkNsb3NlIHRoZSBjdXJyZW50bHkgYWN0aXZlIGNvbXBsZXRpb24uXG4qL1xuY29uc3QgY2xvc2VDb21wbGV0aW9uID0gKHZpZXcpID0+IHtcbiAgICBsZXQgY1N0YXRlID0gdmlldy5zdGF0ZS5maWVsZChjb21wbGV0aW9uU3RhdGUsIGZhbHNlKTtcbiAgICBpZiAoIWNTdGF0ZSB8fCAhY1N0YXRlLmFjdGl2ZS5zb21lKGEgPT4gYS5zdGF0ZSAhPSAwIC8qIFN0YXRlLkluYWN0aXZlICovKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBjbG9zZUNvbXBsZXRpb25FZmZlY3Qub2YobnVsbCkgfSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuY2xhc3MgUnVubmluZ1F1ZXJ5IHtcbiAgICBjb25zdHJ1Y3RvcihhY3RpdmUsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSBhY3RpdmU7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMudGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIHRoaXMudXBkYXRlcyA9IFtdO1xuICAgICAgICAvLyBOb3RlIHRoYXQgJ3VuZGVmaW5lZCcgbWVhbnMgJ25vdCBkb25lIHlldCcsIHdoZXJlYXMgJ251bGwnIG1lYW5zXG4gICAgICAgIC8vICdxdWVyeSByZXR1cm5lZCBudWxsJy5cbiAgICAgICAgdGhpcy5kb25lID0gdW5kZWZpbmVkO1xuICAgIH1cbn1cbmNvbnN0IE1heFVwZGF0ZUNvdW50ID0gNTAsIE1pbkFib3J0VGltZSA9IDEwMDA7XG5jb25zdCBjb21wbGV0aW9uUGx1Z2luID0gLypAX19QVVJFX18qL1ZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuZGVib3VuY2VVcGRhdGUgPSAtMTtcbiAgICAgICAgdGhpcy5ydW5uaW5nID0gW107XG4gICAgICAgIHRoaXMuZGVib3VuY2VBY2NlcHQgPSAtMTtcbiAgICAgICAgdGhpcy5jb21wb3NpbmcgPSAwIC8qIENvbXBvc2l0aW9uU3RhdGUuTm9uZSAqLztcbiAgICAgICAgZm9yIChsZXQgYWN0aXZlIG9mIHZpZXcuc3RhdGUuZmllbGQoY29tcGxldGlvblN0YXRlKS5hY3RpdmUpXG4gICAgICAgICAgICBpZiAoYWN0aXZlLnN0YXRlID09IDEgLyogU3RhdGUuUGVuZGluZyAqLylcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0UXVlcnkoYWN0aXZlKTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBsZXQgY1N0YXRlID0gdXBkYXRlLnN0YXRlLmZpZWxkKGNvbXBsZXRpb25TdGF0ZSk7XG4gICAgICAgIGlmICghdXBkYXRlLnNlbGVjdGlvblNldCAmJiAhdXBkYXRlLmRvY0NoYW5nZWQgJiYgdXBkYXRlLnN0YXJ0U3RhdGUuZmllbGQoY29tcGxldGlvblN0YXRlKSA9PSBjU3RhdGUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBkb2VzUmVzZXQgPSB1cGRhdGUudHJhbnNhY3Rpb25zLnNvbWUodHIgPT4ge1xuICAgICAgICAgICAgcmV0dXJuICh0ci5zZWxlY3Rpb24gfHwgdHIuZG9jQ2hhbmdlZCkgJiYgIWdldFVzZXJFdmVudCh0cik7XG4gICAgICAgIH0pO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucnVubmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHF1ZXJ5ID0gdGhpcy5ydW5uaW5nW2ldO1xuICAgICAgICAgICAgaWYgKGRvZXNSZXNldCB8fFxuICAgICAgICAgICAgICAgIHF1ZXJ5LnVwZGF0ZXMubGVuZ3RoICsgdXBkYXRlLnRyYW5zYWN0aW9ucy5sZW5ndGggPiBNYXhVcGRhdGVDb3VudCAmJiBEYXRlLm5vdygpIC0gcXVlcnkudGltZSA+IE1pbkFib3J0VGltZSkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGhhbmRsZXIgb2YgcXVlcnkuY29udGV4dC5hYm9ydExpc3RlbmVycykge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlcigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dFeGNlcHRpb24odGhpcy52aWV3LnN0YXRlLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBxdWVyeS5jb250ZXh0LmFib3J0TGlzdGVuZXJzID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLnJ1bm5pbmcuc3BsaWNlKGktLSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBxdWVyeS51cGRhdGVzLnB1c2goLi4udXBkYXRlLnRyYW5zYWN0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZGVib3VuY2VVcGRhdGUgPiAtMSlcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmRlYm91bmNlVXBkYXRlKTtcbiAgICAgICAgdGhpcy5kZWJvdW5jZVVwZGF0ZSA9IGNTdGF0ZS5hY3RpdmUuc29tZShhID0+IGEuc3RhdGUgPT0gMSAvKiBTdGF0ZS5QZW5kaW5nICovICYmICF0aGlzLnJ1bm5pbmcuc29tZShxID0+IHEuYWN0aXZlLnNvdXJjZSA9PSBhLnNvdXJjZSkpXG4gICAgICAgICAgICA/IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5zdGFydFVwZGF0ZSgpLCA1MCkgOiAtMTtcbiAgICAgICAgaWYgKHRoaXMuY29tcG9zaW5nICE9IDAgLyogQ29tcG9zaXRpb25TdGF0ZS5Ob25lICovKVxuICAgICAgICAgICAgZm9yIChsZXQgdHIgb2YgdXBkYXRlLnRyYW5zYWN0aW9ucykge1xuICAgICAgICAgICAgICAgIGlmIChnZXRVc2VyRXZlbnQodHIpID09IFwiaW5wdXRcIilcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wb3NpbmcgPSAyIC8qIENvbXBvc2l0aW9uU3RhdGUuQ2hhbmdlZCAqLztcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmNvbXBvc2luZyA9PSAyIC8qIENvbXBvc2l0aW9uU3RhdGUuQ2hhbmdlZCAqLyAmJiB0ci5zZWxlY3Rpb24pXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcG9zaW5nID0gMyAvKiBDb21wb3NpdGlvblN0YXRlLkNoYW5nZWRBbmRNb3ZlZCAqLztcbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgc3RhcnRVcGRhdGUoKSB7XG4gICAgICAgIHRoaXMuZGVib3VuY2VVcGRhdGUgPSAtMTtcbiAgICAgICAgbGV0IHsgc3RhdGUgfSA9IHRoaXMudmlldywgY1N0YXRlID0gc3RhdGUuZmllbGQoY29tcGxldGlvblN0YXRlKTtcbiAgICAgICAgZm9yIChsZXQgYWN0aXZlIG9mIGNTdGF0ZS5hY3RpdmUpIHtcbiAgICAgICAgICAgIGlmIChhY3RpdmUuc3RhdGUgPT0gMSAvKiBTdGF0ZS5QZW5kaW5nICovICYmICF0aGlzLnJ1bm5pbmcuc29tZShyID0+IHIuYWN0aXZlLnNvdXJjZSA9PSBhY3RpdmUuc291cmNlKSlcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0UXVlcnkoYWN0aXZlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGFydFF1ZXJ5KGFjdGl2ZSkge1xuICAgICAgICBsZXQgeyBzdGF0ZSB9ID0gdGhpcy52aWV3LCBwb3MgPSBjdXIoc3RhdGUpO1xuICAgICAgICBsZXQgY29udGV4dCA9IG5ldyBDb21wbGV0aW9uQ29udGV4dChzdGF0ZSwgcG9zLCBhY3RpdmUuZXhwbGljaXRQb3MgPT0gcG9zKTtcbiAgICAgICAgbGV0IHBlbmRpbmcgPSBuZXcgUnVubmluZ1F1ZXJ5KGFjdGl2ZSwgY29udGV4dCk7XG4gICAgICAgIHRoaXMucnVubmluZy5wdXNoKHBlbmRpbmcpO1xuICAgICAgICBQcm9taXNlLnJlc29sdmUoYWN0aXZlLnNvdXJjZShjb250ZXh0KSkudGhlbihyZXN1bHQgPT4ge1xuICAgICAgICAgICAgaWYgKCFwZW5kaW5nLmNvbnRleHQuYWJvcnRlZCkge1xuICAgICAgICAgICAgICAgIHBlbmRpbmcuZG9uZSA9IHJlc3VsdCB8fCBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVBY2NlcHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgZXJyID0+IHtcbiAgICAgICAgICAgIHRoaXMudmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IGNsb3NlQ29tcGxldGlvbkVmZmVjdC5vZihudWxsKSB9KTtcbiAgICAgICAgICAgIGxvZ0V4Y2VwdGlvbih0aGlzLnZpZXcuc3RhdGUsIGVycik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzY2hlZHVsZUFjY2VwdCgpIHtcbiAgICAgICAgaWYgKHRoaXMucnVubmluZy5ldmVyeShxID0+IHEuZG9uZSAhPT0gdW5kZWZpbmVkKSlcbiAgICAgICAgICAgIHRoaXMuYWNjZXB0KCk7XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZGVib3VuY2VBY2NlcHQgPCAwKVxuICAgICAgICAgICAgdGhpcy5kZWJvdW5jZUFjY2VwdCA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5hY2NlcHQoKSwgdGhpcy52aWV3LnN0YXRlLmZhY2V0KGNvbXBsZXRpb25Db25maWcpLnVwZGF0ZVN5bmNUaW1lKTtcbiAgICB9XG4gICAgLy8gRm9yIGVhY2ggZmluaXNoZWQgcXVlcnkgaW4gdGhpcy5ydW5uaW5nLCB0cnkgdG8gY3JlYXRlIGEgcmVzdWx0XG4gICAgLy8gb3IsIGlmIGFwcHJvcHJpYXRlLCByZXN0YXJ0IHRoZSBxdWVyeS5cbiAgICBhY2NlcHQoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHRoaXMuZGVib3VuY2VBY2NlcHQgPiAtMSlcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmRlYm91bmNlQWNjZXB0KTtcbiAgICAgICAgdGhpcy5kZWJvdW5jZUFjY2VwdCA9IC0xO1xuICAgICAgICBsZXQgdXBkYXRlZCA9IFtdO1xuICAgICAgICBsZXQgY29uZiA9IHRoaXMudmlldy5zdGF0ZS5mYWNldChjb21wbGV0aW9uQ29uZmlnKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJ1bm5pbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBxdWVyeSA9IHRoaXMucnVubmluZ1tpXTtcbiAgICAgICAgICAgIGlmIChxdWVyeS5kb25lID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB0aGlzLnJ1bm5pbmcuc3BsaWNlKGktLSwgMSk7XG4gICAgICAgICAgICBpZiAocXVlcnkuZG9uZSkge1xuICAgICAgICAgICAgICAgIGxldCBhY3RpdmUgPSBuZXcgQWN0aXZlUmVzdWx0KHF1ZXJ5LmFjdGl2ZS5zb3VyY2UsIHF1ZXJ5LmFjdGl2ZS5leHBsaWNpdFBvcywgcXVlcnkuZG9uZSwgcXVlcnkuZG9uZS5mcm9tLCAoX2EgPSBxdWVyeS5kb25lLnRvKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjdXIocXVlcnkudXBkYXRlcy5sZW5ndGggPyBxdWVyeS51cGRhdGVzWzBdLnN0YXJ0U3RhdGUgOiB0aGlzLnZpZXcuc3RhdGUpKTtcbiAgICAgICAgICAgICAgICAvLyBSZXBsYXkgdGhlIHRyYW5zYWN0aW9ucyB0aGF0IGhhcHBlbmVkIHNpbmNlIHRoZSBzdGFydCBvZlxuICAgICAgICAgICAgICAgIC8vIHRoZSByZXF1ZXN0IGFuZCBzZWUgaWYgdGhhdCBwcmVzZXJ2ZXMgdGhlIHJlc3VsdFxuICAgICAgICAgICAgICAgIGZvciAobGV0IHRyIG9mIHF1ZXJ5LnVwZGF0ZXMpXG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZSA9IGFjdGl2ZS51cGRhdGUodHIsIGNvbmYpO1xuICAgICAgICAgICAgICAgIGlmIChhY3RpdmUuaGFzUmVzdWx0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlZC5wdXNoKGFjdGl2ZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy52aWV3LnN0YXRlLmZpZWxkKGNvbXBsZXRpb25TdGF0ZSkuYWN0aXZlLmZpbmQoYSA9PiBhLnNvdXJjZSA9PSBxdWVyeS5hY3RpdmUuc291cmNlKTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50ICYmIGN1cnJlbnQuc3RhdGUgPT0gMSAvKiBTdGF0ZS5QZW5kaW5nICovKSB7XG4gICAgICAgICAgICAgICAgaWYgKHF1ZXJ5LmRvbmUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBFeHBsaWNpdGx5IGZhaWxlZC4gU2hvdWxkIGNsZWFyIHRoZSBwZW5kaW5nIHN0YXR1cyBpZiBpdFxuICAgICAgICAgICAgICAgICAgICAvLyBoYXNuJ3QgYmVlbiByZS1zZXQgaW4gdGhlIG1lYW50aW1lLlxuICAgICAgICAgICAgICAgICAgICBsZXQgYWN0aXZlID0gbmV3IEFjdGl2ZVNvdXJjZShxdWVyeS5hY3RpdmUuc291cmNlLCAwIC8qIFN0YXRlLkluYWN0aXZlICovKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgdHIgb2YgcXVlcnkudXBkYXRlcylcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZSA9IGFjdGl2ZS51cGRhdGUodHIsIGNvbmYpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aXZlLnN0YXRlICE9IDEgLyogU3RhdGUuUGVuZGluZyAqLylcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZWQucHVzaChhY3RpdmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2xlYXJlZCBieSBzdWJzZXF1ZW50IHRyYW5zYWN0aW9ucy4gUmVzdGFydC5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydFF1ZXJ5KGN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodXBkYXRlZC5sZW5ndGgpXG4gICAgICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBzZXRBY3RpdmVFZmZlY3Qub2YodXBkYXRlZCkgfSk7XG4gICAgfVxufSwge1xuICAgIGV2ZW50SGFuZGxlcnM6IHtcbiAgICAgICAgYmx1cihldmVudCkge1xuICAgICAgICAgICAgbGV0IHN0YXRlID0gdGhpcy52aWV3LnN0YXRlLmZpZWxkKGNvbXBsZXRpb25TdGF0ZSwgZmFsc2UpO1xuICAgICAgICAgICAgaWYgKHN0YXRlICYmIHN0YXRlLnRvb2x0aXAgJiYgdGhpcy52aWV3LnN0YXRlLmZhY2V0KGNvbXBsZXRpb25Db25maWcpLmNsb3NlT25CbHVyKSB7XG4gICAgICAgICAgICAgICAgbGV0IGRpYWxvZyA9IHN0YXRlLm9wZW4gJiYgZ2V0VG9vbHRpcCh0aGlzLnZpZXcsIHN0YXRlLm9wZW4udG9vbHRpcCk7XG4gICAgICAgICAgICAgICAgaWYgKCFkaWFsb2cgfHwgIWRpYWxvZy5kb20uY29udGFpbnMoZXZlbnQucmVsYXRlZFRhcmdldCkpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IGNsb3NlQ29tcGxldGlvbkVmZmVjdC5vZihudWxsKSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY29tcG9zaXRpb25zdGFydCgpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcG9zaW5nID0gMSAvKiBDb21wb3NpdGlvblN0YXRlLlN0YXJ0ZWQgKi87XG4gICAgICAgIH0sXG4gICAgICAgIGNvbXBvc2l0aW9uZW5kKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29tcG9zaW5nID09IDMgLyogQ29tcG9zaXRpb25TdGF0ZS5DaGFuZ2VkQW5kTW92ZWQgKi8pIHtcbiAgICAgICAgICAgICAgICAvLyBTYWZhcmkgZmlyZXMgY29tcG9zaXRpb25lbmQgZXZlbnRzIHN5bmNocm9ub3VzbHksIHBvc3NpYmx5XG4gICAgICAgICAgICAgICAgLy8gZnJvbSBpbnNpZGUgYW4gdXBkYXRlLCBzbyBkaXNwYXRjaCBhc3luY2hyb25vdXNseSB0byBhdm9pZCByZWVudHJhbmN5XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBzdGFydENvbXBsZXRpb25FZmZlY3Qub2YoZmFsc2UpIH0pLCAyMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNvbXBvc2luZyA9IDAgLyogQ29tcG9zaXRpb25TdGF0ZS5Ob25lICovO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbmNvbnN0IGJhc2VUaGVtZSA9IC8qQF9fUFVSRV9fKi9FZGl0b3JWaWV3LmJhc2VUaGVtZSh7XG4gICAgXCIuY20tdG9vbHRpcC5jbS10b29sdGlwLWF1dG9jb21wbGV0ZVwiOiB7XG4gICAgICAgIFwiJiA+IHVsXCI6IHtcbiAgICAgICAgICAgIGZvbnRGYW1pbHk6IFwibW9ub3NwYWNlXCIsXG4gICAgICAgICAgICB3aGl0ZVNwYWNlOiBcIm5vd3JhcFwiLFxuICAgICAgICAgICAgb3ZlcmZsb3c6IFwiaGlkZGVuIGF1dG9cIixcbiAgICAgICAgICAgIG1heFdpZHRoX2ZhbGxiYWNrOiBcIjcwMHB4XCIsXG4gICAgICAgICAgICBtYXhXaWR0aDogXCJtaW4oNzAwcHgsIDk1dncpXCIsXG4gICAgICAgICAgICBtaW5XaWR0aDogXCIyNTBweFwiLFxuICAgICAgICAgICAgbWF4SGVpZ2h0OiBcIjEwZW1cIixcbiAgICAgICAgICAgIGhlaWdodDogXCIxMDAlXCIsXG4gICAgICAgICAgICBsaXN0U3R5bGU6IFwibm9uZVwiLFxuICAgICAgICAgICAgbWFyZ2luOiAwLFxuICAgICAgICAgICAgcGFkZGluZzogMCxcbiAgICAgICAgICAgIFwiJiA+IGxpLCAmID4gY29tcGxldGlvbi1zZWN0aW9uXCI6IHtcbiAgICAgICAgICAgICAgICBwYWRkaW5nOiBcIjFweCAzcHhcIixcbiAgICAgICAgICAgICAgICBsaW5lSGVpZ2h0OiAxLjJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcIiYgPiBsaVwiOiB7XG4gICAgICAgICAgICAgICAgb3ZlcmZsb3dYOiBcImhpZGRlblwiLFxuICAgICAgICAgICAgICAgIHRleHRPdmVyZmxvdzogXCJlbGxpcHNpc1wiLFxuICAgICAgICAgICAgICAgIGN1cnNvcjogXCJwb2ludGVyXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcIiYgPiBjb21wbGV0aW9uLXNlY3Rpb25cIjoge1xuICAgICAgICAgICAgICAgIGRpc3BsYXk6IFwibGlzdC1pdGVtXCIsXG4gICAgICAgICAgICAgICAgYm9yZGVyQm90dG9tOiBcIjFweCBzb2xpZCBzaWx2ZXJcIixcbiAgICAgICAgICAgICAgICBwYWRkaW5nTGVmdDogXCIwLjVlbVwiLFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDAuN1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBcIiZsaWdodCAuY20tdG9vbHRpcC1hdXRvY29tcGxldGUgdWwgbGlbYXJpYS1zZWxlY3RlZF1cIjoge1xuICAgICAgICBiYWNrZ3JvdW5kOiBcIiMxN2NcIixcbiAgICAgICAgY29sb3I6IFwid2hpdGVcIixcbiAgICB9LFxuICAgIFwiJmxpZ2h0IC5jbS10b29sdGlwLWF1dG9jb21wbGV0ZS1kaXNhYmxlZCB1bCBsaVthcmlhLXNlbGVjdGVkXVwiOiB7XG4gICAgICAgIGJhY2tncm91bmQ6IFwiIzc3N1wiLFxuICAgIH0sXG4gICAgXCImZGFyayAuY20tdG9vbHRpcC1hdXRvY29tcGxldGUgdWwgbGlbYXJpYS1zZWxlY3RlZF1cIjoge1xuICAgICAgICBiYWNrZ3JvdW5kOiBcIiMzNDdcIixcbiAgICAgICAgY29sb3I6IFwid2hpdGVcIixcbiAgICB9LFxuICAgIFwiJmRhcmsgLmNtLXRvb2x0aXAtYXV0b2NvbXBsZXRlLWRpc2FibGVkIHVsIGxpW2FyaWEtc2VsZWN0ZWRdXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZDogXCIjNDQ0XCIsXG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uTGlzdEluY29tcGxldGVUb3A6YmVmb3JlLCAuY20tY29tcGxldGlvbkxpc3RJbmNvbXBsZXRlQm90dG9tOmFmdGVyXCI6IHtcbiAgICAgICAgY29udGVudDogJ1wiwrfCt8K3XCInLFxuICAgICAgICBvcGFjaXR5OiAwLjUsXG4gICAgICAgIGRpc3BsYXk6IFwiYmxvY2tcIixcbiAgICAgICAgdGV4dEFsaWduOiBcImNlbnRlclwiXG4gICAgfSxcbiAgICBcIi5jbS10b29sdGlwLmNtLWNvbXBsZXRpb25JbmZvXCI6IHtcbiAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgcGFkZGluZzogXCIzcHggOXB4XCIsXG4gICAgICAgIHdpZHRoOiBcIm1heC1jb250ZW50XCIsXG4gICAgICAgIG1heFdpZHRoOiBgJHs0MDAgLyogSW5mby5XaWR0aCAqL31weGAsXG4gICAgICAgIGJveFNpemluZzogXCJib3JkZXItYm94XCJcbiAgICB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25JbmZvLmNtLWNvbXBsZXRpb25JbmZvLWxlZnRcIjogeyByaWdodDogXCIxMDAlXCIgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uSW5mby5jbS1jb21wbGV0aW9uSW5mby1yaWdodFwiOiB7IGxlZnQ6IFwiMTAwJVwiIH0sXG4gICAgXCIuY20tY29tcGxldGlvbkluZm8uY20tY29tcGxldGlvbkluZm8tbGVmdC1uYXJyb3dcIjogeyByaWdodDogYCR7MzAgLyogSW5mby5NYXJnaW4gKi99cHhgIH0sXG4gICAgXCIuY20tY29tcGxldGlvbkluZm8uY20tY29tcGxldGlvbkluZm8tcmlnaHQtbmFycm93XCI6IHsgbGVmdDogYCR7MzAgLyogSW5mby5NYXJnaW4gKi99cHhgIH0sXG4gICAgXCImbGlnaHQgLmNtLXNuaXBwZXRGaWVsZFwiOiB7IGJhY2tncm91bmRDb2xvcjogXCIjMDAwMDAwMjJcIiB9LFxuICAgIFwiJmRhcmsgLmNtLXNuaXBwZXRGaWVsZFwiOiB7IGJhY2tncm91bmRDb2xvcjogXCIjZmZmZmZmMjJcIiB9LFxuICAgIFwiLmNtLXNuaXBwZXRGaWVsZFBvc2l0aW9uXCI6IHtcbiAgICAgICAgdmVydGljYWxBbGlnbjogXCJ0ZXh0LXRvcFwiLFxuICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgaGVpZ2h0OiBcIjEuMTVlbVwiLFxuICAgICAgICBkaXNwbGF5OiBcImlubGluZS1ibG9ja1wiLFxuICAgICAgICBtYXJnaW46IFwiMCAtMC43cHggLS43ZW1cIixcbiAgICAgICAgYm9yZGVyTGVmdDogXCIxLjRweCBkb3R0ZWQgIzg4OFwiXG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uTWF0Y2hlZFRleHRcIjoge1xuICAgICAgICB0ZXh0RGVjb3JhdGlvbjogXCJ1bmRlcmxpbmVcIlxuICAgIH0sXG4gICAgXCIuY20tY29tcGxldGlvbkRldGFpbFwiOiB7XG4gICAgICAgIG1hcmdpbkxlZnQ6IFwiMC41ZW1cIixcbiAgICAgICAgZm9udFN0eWxlOiBcIml0YWxpY1wiXG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uSWNvblwiOiB7XG4gICAgICAgIGZvbnRTaXplOiBcIjkwJVwiLFxuICAgICAgICB3aWR0aDogXCIuOGVtXCIsXG4gICAgICAgIGRpc3BsYXk6IFwiaW5saW5lLWJsb2NrXCIsXG4gICAgICAgIHRleHRBbGlnbjogXCJjZW50ZXJcIixcbiAgICAgICAgcGFkZGluZ1JpZ2h0OiBcIi42ZW1cIixcbiAgICAgICAgb3BhY2l0eTogXCIwLjZcIixcbiAgICAgICAgYm94U2l6aW5nOiBcImNvbnRlbnQtYm94XCJcbiAgICB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25JY29uLWZ1bmN0aW9uLCAuY20tY29tcGxldGlvbkljb24tbWV0aG9kXCI6IHtcbiAgICAgICAgXCImOmFmdGVyXCI6IHsgY29udGVudDogXCInxpInXCIgfVxuICAgIH0sXG4gICAgXCIuY20tY29tcGxldGlvbkljb24tY2xhc3NcIjoge1xuICAgICAgICBcIiY6YWZ0ZXJcIjogeyBjb250ZW50OiBcIifil4snXCIgfVxuICAgIH0sXG4gICAgXCIuY20tY29tcGxldGlvbkljb24taW50ZXJmYWNlXCI6IHtcbiAgICAgICAgXCImOmFmdGVyXCI6IHsgY29udGVudDogXCIn4peMJ1wiIH1cbiAgICB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25JY29uLXZhcmlhYmxlXCI6IHtcbiAgICAgICAgXCImOmFmdGVyXCI6IHsgY29udGVudDogXCIn8J2RpSdcIiB9XG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uSWNvbi1jb25zdGFudFwiOiB7XG4gICAgICAgIFwiJjphZnRlclwiOiB7IGNvbnRlbnQ6IFwiJ/CdkLYnXCIgfVxuICAgIH0sXG4gICAgXCIuY20tY29tcGxldGlvbkljb24tdHlwZVwiOiB7XG4gICAgICAgIFwiJjphZnRlclwiOiB7IGNvbnRlbnQ6IFwiJ/CdkaEnXCIgfVxuICAgIH0sXG4gICAgXCIuY20tY29tcGxldGlvbkljb24tZW51bVwiOiB7XG4gICAgICAgIFwiJjphZnRlclwiOiB7IGNvbnRlbnQ6IFwiJ+KIqidcIiB9XG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uSWNvbi1wcm9wZXJ0eVwiOiB7XG4gICAgICAgIFwiJjphZnRlclwiOiB7IGNvbnRlbnQ6IFwiJ+KWoSdcIiB9XG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uSWNvbi1rZXl3b3JkXCI6IHtcbiAgICAgICAgXCImOmFmdGVyXCI6IHsgY29udGVudDogXCIn8J+UkVxcdUZFMEUnXCIgfSAvLyBEaXNhYmxlIGVtb2ppIHJlbmRlcmluZ1xuICAgIH0sXG4gICAgXCIuY20tY29tcGxldGlvbkljb24tbmFtZXNwYWNlXCI6IHtcbiAgICAgICAgXCImOmFmdGVyXCI6IHsgY29udGVudDogXCIn4paiJ1wiIH1cbiAgICB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25JY29uLXRleHRcIjoge1xuICAgICAgICBcIiY6YWZ0ZXJcIjogeyBjb250ZW50OiBcIidhYmMnXCIsIGZvbnRTaXplOiBcIjUwJVwiLCB2ZXJ0aWNhbEFsaWduOiBcIm1pZGRsZVwiIH1cbiAgICB9XG59KTtcblxuY2xhc3MgRmllbGRQb3Mge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkLCBsaW5lLCBmcm9tLCB0bykge1xuICAgICAgICB0aGlzLmZpZWxkID0gZmllbGQ7XG4gICAgICAgIHRoaXMubGluZSA9IGxpbmU7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICB9XG59XG5jbGFzcyBGaWVsZFJhbmdlIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZCwgZnJvbSwgdG8pIHtcbiAgICAgICAgdGhpcy5maWVsZCA9IGZpZWxkO1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgfVxuICAgIG1hcChjaGFuZ2VzKSB7XG4gICAgICAgIGxldCBmcm9tID0gY2hhbmdlcy5tYXBQb3ModGhpcy5mcm9tLCAtMSwgTWFwTW9kZS5UcmFja0RlbCk7XG4gICAgICAgIGxldCB0byA9IGNoYW5nZXMubWFwUG9zKHRoaXMudG8sIDEsIE1hcE1vZGUuVHJhY2tEZWwpO1xuICAgICAgICByZXR1cm4gZnJvbSA9PSBudWxsIHx8IHRvID09IG51bGwgPyBudWxsIDogbmV3IEZpZWxkUmFuZ2UodGhpcy5maWVsZCwgZnJvbSwgdG8pO1xuICAgIH1cbn1cbmNsYXNzIFNuaXBwZXQge1xuICAgIGNvbnN0cnVjdG9yKGxpbmVzLCBmaWVsZFBvc2l0aW9ucykge1xuICAgICAgICB0aGlzLmxpbmVzID0gbGluZXM7XG4gICAgICAgIHRoaXMuZmllbGRQb3NpdGlvbnMgPSBmaWVsZFBvc2l0aW9ucztcbiAgICB9XG4gICAgaW5zdGFudGlhdGUoc3RhdGUsIHBvcykge1xuICAgICAgICBsZXQgdGV4dCA9IFtdLCBsaW5lU3RhcnQgPSBbcG9zXTtcbiAgICAgICAgbGV0IGxpbmVPYmogPSBzdGF0ZS5kb2MubGluZUF0KHBvcyksIGJhc2VJbmRlbnQgPSAvXlxccyovLmV4ZWMobGluZU9iai50ZXh0KVswXTtcbiAgICAgICAgZm9yIChsZXQgbGluZSBvZiB0aGlzLmxpbmVzKSB7XG4gICAgICAgICAgICBpZiAodGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBsZXQgaW5kZW50ID0gYmFzZUluZGVudCwgdGFicyA9IC9eXFx0Ki8uZXhlYyhsaW5lKVswXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YWJzOyBpKyspXG4gICAgICAgICAgICAgICAgICAgIGluZGVudCArPSBzdGF0ZS5mYWNldChpbmRlbnRVbml0KTtcbiAgICAgICAgICAgICAgICBsaW5lU3RhcnQucHVzaChwb3MgKyBpbmRlbnQubGVuZ3RoIC0gdGFicyk7XG4gICAgICAgICAgICAgICAgbGluZSA9IGluZGVudCArIGxpbmUuc2xpY2UodGFicyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ZXh0LnB1c2gobGluZSk7XG4gICAgICAgICAgICBwb3MgKz0gbGluZS5sZW5ndGggKyAxO1xuICAgICAgICB9XG4gICAgICAgIGxldCByYW5nZXMgPSB0aGlzLmZpZWxkUG9zaXRpb25zLm1hcChwb3MgPT4gbmV3IEZpZWxkUmFuZ2UocG9zLmZpZWxkLCBsaW5lU3RhcnRbcG9zLmxpbmVdICsgcG9zLmZyb20sIGxpbmVTdGFydFtwb3MubGluZV0gKyBwb3MudG8pKTtcbiAgICAgICAgcmV0dXJuIHsgdGV4dCwgcmFuZ2VzIH07XG4gICAgfVxuICAgIHN0YXRpYyBwYXJzZSh0ZW1wbGF0ZSkge1xuICAgICAgICBsZXQgZmllbGRzID0gW107XG4gICAgICAgIGxldCBsaW5lcyA9IFtdLCBwb3NpdGlvbnMgPSBbXSwgbTtcbiAgICAgICAgZm9yIChsZXQgbGluZSBvZiB0ZW1wbGF0ZS5zcGxpdCgvXFxyXFxuP3xcXG4vKSkge1xuICAgICAgICAgICAgd2hpbGUgKG0gPSAvWyMkXVxceyg/OihcXGQrKSg/OjooW159XSopKT98KFtefV0qKSlcXH0vLmV4ZWMobGluZSkpIHtcbiAgICAgICAgICAgICAgICBsZXQgc2VxID0gbVsxXSA/ICttWzFdIDogbnVsbCwgbmFtZSA9IG1bMl0gfHwgbVszXSB8fCBcIlwiLCBmb3VuZCA9IC0xO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmllbGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXEgIT0gbnVsbCA/IGZpZWxkc1tpXS5zZXEgPT0gc2VxIDogbmFtZSA/IGZpZWxkc1tpXS5uYW1lID09IG5hbWUgOiBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChpIDwgZmllbGRzLmxlbmd0aCAmJiAoc2VxID09IG51bGwgfHwgKGZpZWxkc1tpXS5zZXEgIT0gbnVsbCAmJiBmaWVsZHNbaV0uc2VxIDwgc2VxKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkcy5zcGxpY2UoaSwgMCwgeyBzZXEsIG5hbWUgfSk7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kID0gaTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgcG9zIG9mIHBvc2l0aW9ucylcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb3MuZmllbGQgPj0gZm91bmQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zLmZpZWxkKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBvc2l0aW9ucy5wdXNoKG5ldyBGaWVsZFBvcyhmb3VuZCwgbGluZXMubGVuZ3RoLCBtLmluZGV4LCBtLmluZGV4ICsgbmFtZS5sZW5ndGgpKTtcbiAgICAgICAgICAgICAgICBsaW5lID0gbGluZS5zbGljZSgwLCBtLmluZGV4KSArIG5hbWUgKyBsaW5lLnNsaWNlKG0uaW5kZXggKyBtWzBdLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBlc2M7IGVzYyA9IC9cXFxcKFt7fV0pLy5leGVjKGxpbmUpOykge1xuICAgICAgICAgICAgICAgIGxpbmUgPSBsaW5lLnNsaWNlKDAsIGVzYy5pbmRleCkgKyBlc2NbMV0gKyBsaW5lLnNsaWNlKGVzYy5pbmRleCArIGVzY1swXS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHBvcyBvZiBwb3NpdGlvbnMpXG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3MubGluZSA9PSBsaW5lcy5sZW5ndGggJiYgcG9zLmZyb20gPiBlc2MuaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcy5mcm9tLS07XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MudG8tLTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGluZXMucHVzaChsaW5lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFNuaXBwZXQobGluZXMsIHBvc2l0aW9ucyk7XG4gICAgfVxufVxubGV0IGZpZWxkTWFya2VyID0gLypAX19QVVJFX18qL0RlY29yYXRpb24ud2lkZ2V0KHsgd2lkZ2V0OiAvKkBfX1BVUkVfXyovbmV3IGNsYXNzIGV4dGVuZHMgV2lkZ2V0VHlwZSB7XG4gICAgICAgIHRvRE9NKCkge1xuICAgICAgICAgICAgbGV0IHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgICAgIHNwYW4uY2xhc3NOYW1lID0gXCJjbS1zbmlwcGV0RmllbGRQb3NpdGlvblwiO1xuICAgICAgICAgICAgcmV0dXJuIHNwYW47XG4gICAgICAgIH1cbiAgICAgICAgaWdub3JlRXZlbnQoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIH0gfSk7XG5sZXQgZmllbGRSYW5nZSA9IC8qQF9fUFVSRV9fKi9EZWNvcmF0aW9uLm1hcmsoeyBjbGFzczogXCJjbS1zbmlwcGV0RmllbGRcIiB9KTtcbmNsYXNzIEFjdGl2ZVNuaXBwZXQge1xuICAgIGNvbnN0cnVjdG9yKHJhbmdlcywgYWN0aXZlKSB7XG4gICAgICAgIHRoaXMucmFuZ2VzID0gcmFuZ2VzO1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IGFjdGl2ZTtcbiAgICAgICAgdGhpcy5kZWNvID0gRGVjb3JhdGlvbi5zZXQocmFuZ2VzLm1hcChyID0+IChyLmZyb20gPT0gci50byA/IGZpZWxkTWFya2VyIDogZmllbGRSYW5nZSkucmFuZ2Uoci5mcm9tLCByLnRvKSkpO1xuICAgIH1cbiAgICBtYXAoY2hhbmdlcykge1xuICAgICAgICBsZXQgcmFuZ2VzID0gW107XG4gICAgICAgIGZvciAobGV0IHIgb2YgdGhpcy5yYW5nZXMpIHtcbiAgICAgICAgICAgIGxldCBtYXBwZWQgPSByLm1hcChjaGFuZ2VzKTtcbiAgICAgICAgICAgIGlmICghbWFwcGVkKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgcmFuZ2VzLnB1c2gobWFwcGVkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEFjdGl2ZVNuaXBwZXQocmFuZ2VzLCB0aGlzLmFjdGl2ZSk7XG4gICAgfVxuICAgIHNlbGVjdGlvbkluc2lkZUZpZWxkKHNlbCkge1xuICAgICAgICByZXR1cm4gc2VsLnJhbmdlcy5ldmVyeShyYW5nZSA9PiB0aGlzLnJhbmdlcy5zb21lKHIgPT4gci5maWVsZCA9PSB0aGlzLmFjdGl2ZSAmJiByLmZyb20gPD0gcmFuZ2UuZnJvbSAmJiByLnRvID49IHJhbmdlLnRvKSk7XG4gICAgfVxufVxuY29uc3Qgc2V0QWN0aXZlID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSh7XG4gICAgbWFwKHZhbHVlLCBjaGFuZ2VzKSB7IHJldHVybiB2YWx1ZSAmJiB2YWx1ZS5tYXAoY2hhbmdlcyk7IH1cbn0pO1xuY29uc3QgbW92ZVRvRmllbGQgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG5jb25zdCBzbmlwcGV0U3RhdGUgPSAvKkBfX1BVUkVfXyovU3RhdGVGaWVsZC5kZWZpbmUoe1xuICAgIGNyZWF0ZSgpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgdXBkYXRlKHZhbHVlLCB0cikge1xuICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgdHIuZWZmZWN0cykge1xuICAgICAgICAgICAgaWYgKGVmZmVjdC5pcyhzZXRBY3RpdmUpKVxuICAgICAgICAgICAgICAgIHJldHVybiBlZmZlY3QudmFsdWU7XG4gICAgICAgICAgICBpZiAoZWZmZWN0LmlzKG1vdmVUb0ZpZWxkKSAmJiB2YWx1ZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFjdGl2ZVNuaXBwZXQodmFsdWUucmFuZ2VzLCBlZmZlY3QudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSAmJiB0ci5kb2NDaGFuZ2VkKVxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5tYXAodHIuY2hhbmdlcyk7XG4gICAgICAgIGlmICh2YWx1ZSAmJiB0ci5zZWxlY3Rpb24gJiYgIXZhbHVlLnNlbGVjdGlvbkluc2lkZUZpZWxkKHRyLnNlbGVjdGlvbikpXG4gICAgICAgICAgICB2YWx1ZSA9IG51bGw7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIHByb3ZpZGU6IGYgPT4gRWRpdG9yVmlldy5kZWNvcmF0aW9ucy5mcm9tKGYsIHZhbCA9PiB2YWwgPyB2YWwuZGVjbyA6IERlY29yYXRpb24ubm9uZSlcbn0pO1xuZnVuY3Rpb24gZmllbGRTZWxlY3Rpb24ocmFuZ2VzLCBmaWVsZCkge1xuICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKHJhbmdlcy5maWx0ZXIociA9PiByLmZpZWxkID09IGZpZWxkKS5tYXAociA9PiBFZGl0b3JTZWxlY3Rpb24ucmFuZ2Uoci5mcm9tLCByLnRvKSkpO1xufVxuLyoqXG5Db252ZXJ0IGEgc25pcHBldCB0ZW1wbGF0ZSB0byBhIGZ1bmN0aW9uIHRoYXQgY2FuXG5bYXBwbHldKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLkNvbXBsZXRpb24uYXBwbHkpIGl0LiBTbmlwcGV0cyBhcmUgd3JpdHRlblxudXNpbmcgc3ludGF4IGxpa2UgdGhpczpcblxuICAgIFwiZm9yIChsZXQgJHtpbmRleH0gPSAwOyAke2luZGV4fSA8ICR7ZW5kfTsgJHtpbmRleH0rKykge1xcblxcdCR7fVxcbn1cIlxuXG5FYWNoIGAke31gIHBsYWNlaG9sZGVyICh5b3UgbWF5IGFsc28gdXNlIGAje31gKSBpbmRpY2F0ZXMgYSBmaWVsZFxudGhhdCB0aGUgdXNlciBjYW4gZmlsbCBpbi4gSXRzIG5hbWUsIGlmIGFueSwgd2lsbCBiZSB0aGUgZGVmYXVsdFxuY29udGVudCBmb3IgdGhlIGZpZWxkLlxuXG5XaGVuIHRoZSBzbmlwcGV0IGlzIGFjdGl2YXRlZCBieSBjYWxsaW5nIHRoZSByZXR1cm5lZCBmdW5jdGlvbixcbnRoZSBjb2RlIGlzIGluc2VydGVkIGF0IHRoZSBnaXZlbiBwb3NpdGlvbi4gTmV3bGluZXMgaW4gdGhlXG50ZW1wbGF0ZSBhcmUgaW5kZW50ZWQgYnkgdGhlIGluZGVudGF0aW9uIG9mIHRoZSBzdGFydCBsaW5lLCBwbHVzXG5vbmUgW2luZGVudCB1bml0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmluZGVudFVuaXQpIHBlciB0YWIgY2hhcmFjdGVyIGFmdGVyXG50aGUgbmV3bGluZS5cblxuT24gYWN0aXZhdGlvbiwgKGFsbCBpbnN0YW5jZXMgb2YpIHRoZSBmaXJzdCBmaWVsZCBhcmUgc2VsZWN0ZWQuXG5UaGUgdXNlciBjYW4gbW92ZSBiZXR3ZWVuIGZpZWxkcyB3aXRoIFRhYiBhbmQgU2hpZnQtVGFiIGFzIGxvbmcgYXNcbnRoZSBmaWVsZHMgYXJlIGFjdGl2ZS4gTW92aW5nIHRvIHRoZSBsYXN0IGZpZWxkIG9yIG1vdmluZyB0aGVcbmN1cnNvciBvdXQgb2YgdGhlIGN1cnJlbnQgZmllbGQgZGVhY3RpdmF0ZXMgdGhlIGZpZWxkcy5cblxuVGhlIG9yZGVyIG9mIGZpZWxkcyBkZWZhdWx0cyB0byB0ZXh0dWFsIG9yZGVyLCBidXQgeW91IGNhbiBhZGRcbm51bWJlcnMgdG8gcGxhY2Vob2xkZXJzIChgJHsxfWAgb3IgYCR7MTpkZWZhdWx0VGV4dH1gKSB0byBwcm92aWRlXG5hIGN1c3RvbSBvcmRlci5cblxuVG8gaW5jbHVkZSBhIGxpdGVyYWwgYHtgIG9yIGB9YCBpbiB5b3VyIHRlbXBsYXRlLCBwdXQgYSBiYWNrc2xhc2hcbmluIGZyb250IG9mIGl0LiBUaGlzIHdpbGwgYmUgcmVtb3ZlZCBhbmQgdGhlIGJyYWNlIHdpbGwgbm90IGJlXG5pbnRlcnByZXRlZCBhcyBpbmRpY2F0aW5nIGEgcGxhY2Vob2xkZXIuXG4qL1xuZnVuY3Rpb24gc25pcHBldCh0ZW1wbGF0ZSkge1xuICAgIGxldCBzbmlwcGV0ID0gU25pcHBldC5wYXJzZSh0ZW1wbGF0ZSk7XG4gICAgcmV0dXJuIChlZGl0b3IsIGNvbXBsZXRpb24sIGZyb20sIHRvKSA9PiB7XG4gICAgICAgIGxldCB7IHRleHQsIHJhbmdlcyB9ID0gc25pcHBldC5pbnN0YW50aWF0ZShlZGl0b3Iuc3RhdGUsIGZyb20pO1xuICAgICAgICBsZXQgc3BlYyA9IHtcbiAgICAgICAgICAgIGNoYW5nZXM6IHsgZnJvbSwgdG8sIGluc2VydDogVGV4dC5vZih0ZXh0KSB9LFxuICAgICAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IHRydWUsXG4gICAgICAgICAgICBhbm5vdGF0aW9uczogY29tcGxldGlvbiA/IHBpY2tlZENvbXBsZXRpb24ub2YoY29tcGxldGlvbikgOiB1bmRlZmluZWRcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHJhbmdlcy5sZW5ndGgpXG4gICAgICAgICAgICBzcGVjLnNlbGVjdGlvbiA9IGZpZWxkU2VsZWN0aW9uKHJhbmdlcywgMCk7XG4gICAgICAgIGlmIChyYW5nZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgbGV0IGFjdGl2ZSA9IG5ldyBBY3RpdmVTbmlwcGV0KHJhbmdlcywgMCk7XG4gICAgICAgICAgICBsZXQgZWZmZWN0cyA9IHNwZWMuZWZmZWN0cyA9IFtzZXRBY3RpdmUub2YoYWN0aXZlKV07XG4gICAgICAgICAgICBpZiAoZWRpdG9yLnN0YXRlLmZpZWxkKHNuaXBwZXRTdGF0ZSwgZmFsc2UpID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgZWZmZWN0cy5wdXNoKFN0YXRlRWZmZWN0LmFwcGVuZENvbmZpZy5vZihbc25pcHBldFN0YXRlLCBhZGRTbmlwcGV0S2V5bWFwLCBzbmlwcGV0UG9pbnRlckhhbmRsZXIsIGJhc2VUaGVtZV0pKTtcbiAgICAgICAgfVxuICAgICAgICBlZGl0b3IuZGlzcGF0Y2goZWRpdG9yLnN0YXRlLnVwZGF0ZShzcGVjKSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIG1vdmVGaWVsZChkaXIpIHtcbiAgICByZXR1cm4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICAgICAgbGV0IGFjdGl2ZSA9IHN0YXRlLmZpZWxkKHNuaXBwZXRTdGF0ZSwgZmFsc2UpO1xuICAgICAgICBpZiAoIWFjdGl2ZSB8fCBkaXIgPCAwICYmIGFjdGl2ZS5hY3RpdmUgPT0gMClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IG5leHQgPSBhY3RpdmUuYWN0aXZlICsgZGlyLCBsYXN0ID0gZGlyID4gMCAmJiAhYWN0aXZlLnJhbmdlcy5zb21lKHIgPT4gci5maWVsZCA9PSBuZXh0ICsgZGlyKTtcbiAgICAgICAgZGlzcGF0Y2goc3RhdGUudXBkYXRlKHtcbiAgICAgICAgICAgIHNlbGVjdGlvbjogZmllbGRTZWxlY3Rpb24oYWN0aXZlLnJhbmdlcywgbmV4dCksXG4gICAgICAgICAgICBlZmZlY3RzOiBzZXRBY3RpdmUub2YobGFzdCA/IG51bGwgOiBuZXcgQWN0aXZlU25pcHBldChhY3RpdmUucmFuZ2VzLCBuZXh0KSksXG4gICAgICAgICAgICBzY3JvbGxJbnRvVmlldzogdHJ1ZVxuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG4vKipcbkEgY29tbWFuZCB0aGF0IGNsZWFycyB0aGUgYWN0aXZlIHNuaXBwZXQsIGlmIGFueS5cbiovXG5jb25zdCBjbGVhclNuaXBwZXQgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGxldCBhY3RpdmUgPSBzdGF0ZS5maWVsZChzbmlwcGV0U3RhdGUsIGZhbHNlKTtcbiAgICBpZiAoIWFjdGl2ZSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZSh7IGVmZmVjdHM6IHNldEFjdGl2ZS5vZihudWxsKSB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5Nb3ZlIHRvIHRoZSBuZXh0IHNuaXBwZXQgZmllbGQsIGlmIGF2YWlsYWJsZS5cbiovXG5jb25zdCBuZXh0U25pcHBldEZpZWxkID0gLypAX19QVVJFX18qL21vdmVGaWVsZCgxKTtcbi8qKlxuTW92ZSB0byB0aGUgcHJldmlvdXMgc25pcHBldCBmaWVsZCwgaWYgYXZhaWxhYmxlLlxuKi9cbmNvbnN0IHByZXZTbmlwcGV0RmllbGQgPSAvKkBfX1BVUkVfXyovbW92ZUZpZWxkKC0xKTtcbi8qKlxuQ2hlY2sgaWYgdGhlcmUgaXMgYW4gYWN0aXZlIHNuaXBwZXQgd2l0aCBhIG5leHQgZmllbGQgZm9yXG5gbmV4dFNuaXBwZXRGaWVsZGAgdG8gbW92ZSB0by5cbiovXG5mdW5jdGlvbiBoYXNOZXh0U25pcHBldEZpZWxkKHN0YXRlKSB7XG4gICAgbGV0IGFjdGl2ZSA9IHN0YXRlLmZpZWxkKHNuaXBwZXRTdGF0ZSwgZmFsc2UpO1xuICAgIHJldHVybiAhIShhY3RpdmUgJiYgYWN0aXZlLnJhbmdlcy5zb21lKHIgPT4gci5maWVsZCA9PSBhY3RpdmUuYWN0aXZlICsgMSkpO1xufVxuLyoqXG5SZXR1cm5zIHRydWUgaWYgdGhlcmUgaXMgYW4gYWN0aXZlIHNuaXBwZXQgYW5kIGEgcHJldmlvdXMgZmllbGRcbmZvciBgcHJldlNuaXBwZXRGaWVsZGAgdG8gbW92ZSB0by5cbiovXG5mdW5jdGlvbiBoYXNQcmV2U25pcHBldEZpZWxkKHN0YXRlKSB7XG4gICAgbGV0IGFjdGl2ZSA9IHN0YXRlLmZpZWxkKHNuaXBwZXRTdGF0ZSwgZmFsc2UpO1xuICAgIHJldHVybiAhIShhY3RpdmUgJiYgYWN0aXZlLmFjdGl2ZSA+IDApO1xufVxuY29uc3QgZGVmYXVsdFNuaXBwZXRLZXltYXAgPSBbXG4gICAgeyBrZXk6IFwiVGFiXCIsIHJ1bjogbmV4dFNuaXBwZXRGaWVsZCwgc2hpZnQ6IHByZXZTbmlwcGV0RmllbGQgfSxcbiAgICB7IGtleTogXCJFc2NhcGVcIiwgcnVuOiBjbGVhclNuaXBwZXQgfVxuXTtcbi8qKlxuQSBmYWNldCB0aGF0IGNhbiBiZSB1c2VkIHRvIGNvbmZpZ3VyZSB0aGUga2V5IGJpbmRpbmdzIHVzZWQgYnlcbnNuaXBwZXRzLiBUaGUgZGVmYXVsdCBiaW5kcyBUYWIgdG9cbltgbmV4dFNuaXBwZXRGaWVsZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLm5leHRTbmlwcGV0RmllbGQpLCBTaGlmdC1UYWIgdG9cbltgcHJldlNuaXBwZXRGaWVsZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLnByZXZTbmlwcGV0RmllbGQpLCBhbmQgRXNjYXBlXG50byBbYGNsZWFyU25pcHBldGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLmNsZWFyU25pcHBldCkuXG4qL1xuY29uc3Qgc25pcHBldEtleW1hcCA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmUobWFwcykgeyByZXR1cm4gbWFwcy5sZW5ndGggPyBtYXBzWzBdIDogZGVmYXVsdFNuaXBwZXRLZXltYXA7IH1cbn0pO1xuY29uc3QgYWRkU25pcHBldEtleW1hcCA9IC8qQF9fUFVSRV9fKi9QcmVjLmhpZ2hlc3QoLypAX19QVVJFX18qL2tleW1hcC5jb21wdXRlKFtzbmlwcGV0S2V5bWFwXSwgc3RhdGUgPT4gc3RhdGUuZmFjZXQoc25pcHBldEtleW1hcCkpKTtcbi8qKlxuQ3JlYXRlIGEgY29tcGxldGlvbiBmcm9tIGEgc25pcHBldC4gUmV0dXJucyBhbiBvYmplY3Qgd2l0aCB0aGVcbnByb3BlcnRpZXMgZnJvbSBgY29tcGxldGlvbmAsIHBsdXMgYW4gYGFwcGx5YCBmdW5jdGlvbiB0aGF0XG5hcHBsaWVzIHRoZSBzbmlwcGV0LlxuKi9cbmZ1bmN0aW9uIHNuaXBwZXRDb21wbGV0aW9uKHRlbXBsYXRlLCBjb21wbGV0aW9uKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY29tcGxldGlvbiksIHsgYXBwbHk6IHNuaXBwZXQodGVtcGxhdGUpIH0pO1xufVxuY29uc3Qgc25pcHBldFBvaW50ZXJIYW5kbGVyID0gLypAX19QVVJFX18qL0VkaXRvclZpZXcuZG9tRXZlbnRIYW5kbGVycyh7XG4gICAgbW91c2Vkb3duKGV2ZW50LCB2aWV3KSB7XG4gICAgICAgIGxldCBhY3RpdmUgPSB2aWV3LnN0YXRlLmZpZWxkKHNuaXBwZXRTdGF0ZSwgZmFsc2UpLCBwb3M7XG4gICAgICAgIGlmICghYWN0aXZlIHx8IChwb3MgPSB2aWV3LnBvc0F0Q29vcmRzKHsgeDogZXZlbnQuY2xpZW50WCwgeTogZXZlbnQuY2xpZW50WSB9KSkgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IG1hdGNoID0gYWN0aXZlLnJhbmdlcy5maW5kKHIgPT4gci5mcm9tIDw9IHBvcyAmJiByLnRvID49IHBvcyk7XG4gICAgICAgIGlmICghbWF0Y2ggfHwgbWF0Y2guZmllbGQgPT0gYWN0aXZlLmFjdGl2ZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmlldy5kaXNwYXRjaCh7XG4gICAgICAgICAgICBzZWxlY3Rpb246IGZpZWxkU2VsZWN0aW9uKGFjdGl2ZS5yYW5nZXMsIG1hdGNoLmZpZWxkKSxcbiAgICAgICAgICAgIGVmZmVjdHM6IHNldEFjdGl2ZS5vZihhY3RpdmUucmFuZ2VzLnNvbWUociA9PiByLmZpZWxkID4gbWF0Y2guZmllbGQpXG4gICAgICAgICAgICAgICAgPyBuZXcgQWN0aXZlU25pcHBldChhY3RpdmUucmFuZ2VzLCBtYXRjaC5maWVsZCkgOiBudWxsKSxcbiAgICAgICAgICAgIHNjcm9sbEludG9WaWV3OiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59KTtcblxuZnVuY3Rpb24gd29yZFJFKHdvcmRDaGFycykge1xuICAgIGxldCBlc2NhcGVkID0gd29yZENoYXJzLnJlcGxhY2UoL1tcXF1cXC1cXFxcXS9nLCBcIlxcXFwkJlwiKTtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChgW1xcXFxwe0FscGhhYmV0aWN9XFxcXHB7TnVtYmVyfV8ke2VzY2FwZWR9XStgLCBcInVnXCIpO1xuICAgIH1cbiAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoYFtcXHcke2VzY2FwZWR9XWAsIFwiZ1wiKTtcbiAgICB9XG59XG5mdW5jdGlvbiBtYXBSRShyZSwgZikge1xuICAgIHJldHVybiBuZXcgUmVnRXhwKGYocmUuc291cmNlKSwgcmUudW5pY29kZSA/IFwidVwiIDogXCJcIik7XG59XG5jb25zdCB3b3JkQ2FjaGVzID0gLypAX19QVVJFX18qL09iamVjdC5jcmVhdGUobnVsbCk7XG5mdW5jdGlvbiB3b3JkQ2FjaGUod29yZENoYXJzKSB7XG4gICAgcmV0dXJuIHdvcmRDYWNoZXNbd29yZENoYXJzXSB8fCAod29yZENhY2hlc1t3b3JkQ2hhcnNdID0gbmV3IFdlYWtNYXApO1xufVxuZnVuY3Rpb24gc3RvcmVXb3Jkcyhkb2MsIHdvcmRSRSwgcmVzdWx0LCBzZWVuLCBpZ25vcmVBdCkge1xuICAgIGZvciAobGV0IGxpbmVzID0gZG9jLml0ZXJMaW5lcygpLCBwb3MgPSAwOyAhbGluZXMubmV4dCgpLmRvbmU7KSB7XG4gICAgICAgIGxldCB7IHZhbHVlIH0gPSBsaW5lcywgbTtcbiAgICAgICAgd29yZFJFLmxhc3RJbmRleCA9IDA7XG4gICAgICAgIHdoaWxlIChtID0gd29yZFJFLmV4ZWModmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAoIXNlZW5bbVswXV0gJiYgcG9zICsgbS5pbmRleCAhPSBpZ25vcmVBdCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHsgdHlwZTogXCJ0ZXh0XCIsIGxhYmVsOiBtWzBdIH0pO1xuICAgICAgICAgICAgICAgIHNlZW5bbVswXV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID49IDIwMDAgLyogQy5NYXhMaXN0ICovKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcG9zICs9IHZhbHVlLmxlbmd0aCArIDE7XG4gICAgfVxufVxuZnVuY3Rpb24gY29sbGVjdFdvcmRzKGRvYywgY2FjaGUsIHdvcmRSRSwgdG8sIGlnbm9yZUF0KSB7XG4gICAgbGV0IGJpZyA9IGRvYy5sZW5ndGggPj0gMTAwMCAvKiBDLk1pbkNhY2hlTGVuICovO1xuICAgIGxldCBjYWNoZWQgPSBiaWcgJiYgY2FjaGUuZ2V0KGRvYyk7XG4gICAgaWYgKGNhY2hlZClcbiAgICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICBsZXQgcmVzdWx0ID0gW10sIHNlZW4gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGlmIChkb2MuY2hpbGRyZW4pIHtcbiAgICAgICAgbGV0IHBvcyA9IDA7XG4gICAgICAgIGZvciAobGV0IGNoIG9mIGRvYy5jaGlsZHJlbikge1xuICAgICAgICAgICAgaWYgKGNoLmxlbmd0aCA+PSAxMDAwIC8qIEMuTWluQ2FjaGVMZW4gKi8pIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjIG9mIGNvbGxlY3RXb3JkcyhjaCwgY2FjaGUsIHdvcmRSRSwgdG8gLSBwb3MsIGlnbm9yZUF0IC0gcG9zKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNlZW5bYy5sYWJlbF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZW5bYy5sYWJlbF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdG9yZVdvcmRzKGNoLCB3b3JkUkUsIHJlc3VsdCwgc2VlbiwgaWdub3JlQXQgLSBwb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zICs9IGNoLmxlbmd0aCArIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHN0b3JlV29yZHMoZG9jLCB3b3JkUkUsIHJlc3VsdCwgc2VlbiwgaWdub3JlQXQpO1xuICAgIH1cbiAgICBpZiAoYmlnICYmIHJlc3VsdC5sZW5ndGggPCAyMDAwIC8qIEMuTWF4TGlzdCAqLylcbiAgICAgICAgY2FjaGUuc2V0KGRvYywgcmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG5BIGNvbXBsZXRpb24gc291cmNlIHRoYXQgd2lsbCBzY2FuIHRoZSBkb2N1bWVudCBmb3Igd29yZHMgKHVzaW5nIGFcbltjaGFyYWN0ZXIgY2F0ZWdvcml6ZXJdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUuY2hhckNhdGVnb3JpemVyKSksIGFuZFxucmV0dXJuIHRob3NlIGFzIGNvbXBsZXRpb25zLlxuKi9cbmNvbnN0IGNvbXBsZXRlQW55V29yZCA9IGNvbnRleHQgPT4ge1xuICAgIGxldCB3b3JkQ2hhcnMgPSBjb250ZXh0LnN0YXRlLmxhbmd1YWdlRGF0YUF0KFwid29yZENoYXJzXCIsIGNvbnRleHQucG9zKS5qb2luKFwiXCIpO1xuICAgIGxldCByZSA9IHdvcmRSRSh3b3JkQ2hhcnMpO1xuICAgIGxldCB0b2tlbiA9IGNvbnRleHQubWF0Y2hCZWZvcmUobWFwUkUocmUsIHMgPT4gcyArIFwiJFwiKSk7XG4gICAgaWYgKCF0b2tlbiAmJiAhY29udGV4dC5leHBsaWNpdClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IGZyb20gPSB0b2tlbiA/IHRva2VuLmZyb20gOiBjb250ZXh0LnBvcztcbiAgICBsZXQgb3B0aW9ucyA9IGNvbGxlY3RXb3Jkcyhjb250ZXh0LnN0YXRlLmRvYywgd29yZENhY2hlKHdvcmRDaGFycyksIHJlLCA1MDAwMCAvKiBDLlJhbmdlICovLCBmcm9tKTtcbiAgICByZXR1cm4geyBmcm9tLCBvcHRpb25zLCB2YWxpZEZvcjogbWFwUkUocmUsIHMgPT4gXCJeXCIgKyBzKSB9O1xufTtcblxuY29uc3QgZGVmYXVsdHMgPSB7XG4gICAgYnJhY2tldHM6IFtcIihcIiwgXCJbXCIsIFwie1wiLCBcIidcIiwgJ1wiJ10sXG4gICAgYmVmb3JlOiBcIildfTo7PlwiLFxuICAgIHN0cmluZ1ByZWZpeGVzOiBbXVxufTtcbmNvbnN0IGNsb3NlQnJhY2tldEVmZmVjdCA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoe1xuICAgIG1hcCh2YWx1ZSwgbWFwcGluZykge1xuICAgICAgICBsZXQgbWFwcGVkID0gbWFwcGluZy5tYXBQb3ModmFsdWUsIC0xLCBNYXBNb2RlLlRyYWNrQWZ0ZXIpO1xuICAgICAgICByZXR1cm4gbWFwcGVkID09IG51bGwgPyB1bmRlZmluZWQgOiBtYXBwZWQ7XG4gICAgfVxufSk7XG5jb25zdCBjbG9zZWRCcmFja2V0ID0gLypAX19QVVJFX18qL25ldyBjbGFzcyBleHRlbmRzIFJhbmdlVmFsdWUge1xufTtcbmNsb3NlZEJyYWNrZXQuc3RhcnRTaWRlID0gMTtcbmNsb3NlZEJyYWNrZXQuZW5kU2lkZSA9IC0xO1xuY29uc3QgYnJhY2tldFN0YXRlID0gLypAX19QVVJFX18qL1N0YXRlRmllbGQuZGVmaW5lKHtcbiAgICBjcmVhdGUoKSB7IHJldHVybiBSYW5nZVNldC5lbXB0eTsgfSxcbiAgICB1cGRhdGUodmFsdWUsIHRyKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUubWFwKHRyLmNoYW5nZXMpO1xuICAgICAgICBpZiAodHIuc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICBsZXQgbGluZSA9IHRyLnN0YXRlLmRvYy5saW5lQXQodHIuc2VsZWN0aW9uLm1haW4uaGVhZCk7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnVwZGF0ZSh7IGZpbHRlcjogZnJvbSA9PiBmcm9tID49IGxpbmUuZnJvbSAmJiBmcm9tIDw9IGxpbmUudG8gfSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIHRyLmVmZmVjdHMpXG4gICAgICAgICAgICBpZiAoZWZmZWN0LmlzKGNsb3NlQnJhY2tldEVmZmVjdCkpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS51cGRhdGUoeyBhZGQ6IFtjbG9zZWRCcmFja2V0LnJhbmdlKGVmZmVjdC52YWx1ZSwgZWZmZWN0LnZhbHVlICsgMSldIH0pO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxufSk7XG4vKipcbkV4dGVuc2lvbiB0byBlbmFibGUgYnJhY2tldC1jbG9zaW5nIGJlaGF2aW9yLiBXaGVuIGEgY2xvc2VhYmxlXG5icmFja2V0IGlzIHR5cGVkLCBpdHMgY2xvc2luZyBicmFja2V0IGlzIGltbWVkaWF0ZWx5IGluc2VydGVkXG5hZnRlciB0aGUgY3Vyc29yLiBXaGVuIGNsb3NpbmcgYSBicmFja2V0IGRpcmVjdGx5IGluIGZyb250IG9mIGFcbmNsb3NpbmcgYnJhY2tldCBpbnNlcnRlZCBieSB0aGUgZXh0ZW5zaW9uLCB0aGUgY3Vyc29yIG1vdmVzIG92ZXJcbnRoYXQgYnJhY2tldC5cbiovXG5mdW5jdGlvbiBjbG9zZUJyYWNrZXRzKCkge1xuICAgIHJldHVybiBbaW5wdXRIYW5kbGVyLCBicmFja2V0U3RhdGVdO1xufVxuY29uc3QgZGVmaW5lZENsb3NpbmcgPSBcIigpW117fTw+XCI7XG5mdW5jdGlvbiBjbG9zaW5nKGNoKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZWZpbmVkQ2xvc2luZy5sZW5ndGg7IGkgKz0gMilcbiAgICAgICAgaWYgKGRlZmluZWRDbG9zaW5nLmNoYXJDb2RlQXQoaSkgPT0gY2gpXG4gICAgICAgICAgICByZXR1cm4gZGVmaW5lZENsb3NpbmcuY2hhckF0KGkgKyAxKTtcbiAgICByZXR1cm4gZnJvbUNvZGVQb2ludChjaCA8IDEyOCA/IGNoIDogY2ggKyAxKTtcbn1cbmZ1bmN0aW9uIGNvbmZpZyhzdGF0ZSwgcG9zKSB7XG4gICAgcmV0dXJuIHN0YXRlLmxhbmd1YWdlRGF0YUF0KFwiY2xvc2VCcmFja2V0c1wiLCBwb3MpWzBdIHx8IGRlZmF1bHRzO1xufVxuY29uc3QgYW5kcm9pZCA9IHR5cGVvZiBuYXZpZ2F0b3IgPT0gXCJvYmplY3RcIiAmJiAvKkBfX1BVUkVfXyovL0FuZHJvaWRcXGIvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5jb25zdCBpbnB1dEhhbmRsZXIgPSAvKkBfX1BVUkVfXyovRWRpdG9yVmlldy5pbnB1dEhhbmRsZXIub2YoKHZpZXcsIGZyb20sIHRvLCBpbnNlcnQpID0+IHtcbiAgICBpZiAoKGFuZHJvaWQgPyB2aWV3LmNvbXBvc2luZyA6IHZpZXcuY29tcG9zaXRpb25TdGFydGVkKSB8fCB2aWV3LnN0YXRlLnJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW47XG4gICAgaWYgKGluc2VydC5sZW5ndGggPiAyIHx8IGluc2VydC5sZW5ndGggPT0gMiAmJiBjb2RlUG9pbnRTaXplKGNvZGVQb2ludEF0KGluc2VydCwgMCkpID09IDEgfHxcbiAgICAgICAgZnJvbSAhPSBzZWwuZnJvbSB8fCB0byAhPSBzZWwudG8pXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgdHIgPSBpbnNlcnRCcmFja2V0KHZpZXcuc3RhdGUsIGluc2VydCk7XG4gICAgaWYgKCF0cilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHZpZXcuZGlzcGF0Y2godHIpO1xuICAgIHJldHVybiB0cnVlO1xufSk7XG4vKipcbkNvbW1hbmQgdGhhdCBpbXBsZW1lbnRzIGRlbGV0aW5nIGEgcGFpciBvZiBtYXRjaGluZyBicmFja2V0cyB3aGVuXG50aGUgY3Vyc29yIGlzIGJldHdlZW4gdGhlbS5cbiovXG5jb25zdCBkZWxldGVCcmFja2V0UGFpciA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgaWYgKHN0YXRlLnJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGNvbmYgPSBjb25maWcoc3RhdGUsIHN0YXRlLnNlbGVjdGlvbi5tYWluLmhlYWQpO1xuICAgIGxldCB0b2tlbnMgPSBjb25mLmJyYWNrZXRzIHx8IGRlZmF1bHRzLmJyYWNrZXRzO1xuICAgIGxldCBkb250ID0gbnVsbCwgY2hhbmdlcyA9IHN0YXRlLmNoYW5nZUJ5UmFuZ2UocmFuZ2UgPT4ge1xuICAgICAgICBpZiAocmFuZ2UuZW1wdHkpIHtcbiAgICAgICAgICAgIGxldCBiZWZvcmUgPSBwcmV2Q2hhcihzdGF0ZS5kb2MsIHJhbmdlLmhlYWQpO1xuICAgICAgICAgICAgZm9yIChsZXQgdG9rZW4gb2YgdG9rZW5zKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuID09IGJlZm9yZSAmJiBuZXh0Q2hhcihzdGF0ZS5kb2MsIHJhbmdlLmhlYWQpID09IGNsb3NpbmcoY29kZVBvaW50QXQodG9rZW4sIDApKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogeyBmcm9tOiByYW5nZS5oZWFkIC0gdG9rZW4ubGVuZ3RoLCB0bzogcmFuZ2UuaGVhZCArIHRva2VuLmxlbmd0aCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocmFuZ2UuaGVhZCAtIHRva2VuLmxlbmd0aCkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyByYW5nZTogZG9udCA9IHJhbmdlIH07XG4gICAgfSk7XG4gICAgaWYgKCFkb250KVxuICAgICAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoY2hhbmdlcywgeyBzY3JvbGxJbnRvVmlldzogdHJ1ZSwgdXNlckV2ZW50OiBcImRlbGV0ZS5iYWNrd2FyZFwiIH0pKTtcbiAgICByZXR1cm4gIWRvbnQ7XG59O1xuLyoqXG5DbG9zZS1icmFja2V0cyByZWxhdGVkIGtleSBiaW5kaW5ncy4gQmluZHMgQmFja3NwYWNlIHRvXG5bYGRlbGV0ZUJyYWNrZXRQYWlyYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUuZGVsZXRlQnJhY2tldFBhaXIpLlxuKi9cbmNvbnN0IGNsb3NlQnJhY2tldHNLZXltYXAgPSBbXG4gICAgeyBrZXk6IFwiQmFja3NwYWNlXCIsIHJ1bjogZGVsZXRlQnJhY2tldFBhaXIgfVxuXTtcbi8qKlxuSW1wbGVtZW50cyB0aGUgZXh0ZW5zaW9uJ3MgYmVoYXZpb3Igb24gdGV4dCBpbnNlcnRpb24uIElmIHRoZVxuZ2l2ZW4gc3RyaW5nIGNvdW50cyBhcyBhIGJyYWNrZXQgaW4gdGhlIGxhbmd1YWdlIGFyb3VuZCB0aGVcbnNlbGVjdGlvbiwgYW5kIHJlcGxhY2luZyB0aGUgc2VsZWN0aW9uIHdpdGggaXQgcmVxdWlyZXMgY3VzdG9tXG5iZWhhdmlvciAoaW5zZXJ0aW5nIGEgY2xvc2luZyB2ZXJzaW9uIG9yIHNraXBwaW5nIHBhc3QgYVxucHJldmlvdXNseS1jbG9zZWQgYnJhY2tldCksIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIHRyYW5zYWN0aW9uXG5yZXByZXNlbnRpbmcgdGhhdCBjdXN0b20gYmVoYXZpb3IuIChZb3Ugb25seSBuZWVkIHRoaXMgaWYgeW91IHdhbnRcbnRvIHByb2dyYW1tYXRpY2FsbHkgaW5zZXJ0IGJyYWNrZXRz4oCUdGhlXG5bYGNsb3NlQnJhY2tldHNgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5jbG9zZUJyYWNrZXRzKSBleHRlbnNpb24gd2lsbFxudGFrZSBjYXJlIG9mIHJ1bm5pbmcgdGhpcyBmb3IgdXNlciBpbnB1dC4pXG4qL1xuZnVuY3Rpb24gaW5zZXJ0QnJhY2tldChzdGF0ZSwgYnJhY2tldCkge1xuICAgIGxldCBjb25mID0gY29uZmlnKHN0YXRlLCBzdGF0ZS5zZWxlY3Rpb24ubWFpbi5oZWFkKTtcbiAgICBsZXQgdG9rZW5zID0gY29uZi5icmFja2V0cyB8fCBkZWZhdWx0cy5icmFja2V0cztcbiAgICBmb3IgKGxldCB0b2sgb2YgdG9rZW5zKSB7XG4gICAgICAgIGxldCBjbG9zZWQgPSBjbG9zaW5nKGNvZGVQb2ludEF0KHRvaywgMCkpO1xuICAgICAgICBpZiAoYnJhY2tldCA9PSB0b2spXG4gICAgICAgICAgICByZXR1cm4gY2xvc2VkID09IHRvayA/IGhhbmRsZVNhbWUoc3RhdGUsIHRvaywgdG9rZW5zLmluZGV4T2YodG9rICsgdG9rICsgdG9rKSA+IC0xLCBjb25mKVxuICAgICAgICAgICAgICAgIDogaGFuZGxlT3BlbihzdGF0ZSwgdG9rLCBjbG9zZWQsIGNvbmYuYmVmb3JlIHx8IGRlZmF1bHRzLmJlZm9yZSk7XG4gICAgICAgIGlmIChicmFja2V0ID09IGNsb3NlZCAmJiBjbG9zZWRCcmFja2V0QXQoc3RhdGUsIHN0YXRlLnNlbGVjdGlvbi5tYWluLmZyb20pKVxuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUNsb3NlKHN0YXRlLCB0b2ssIGNsb3NlZCk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gY2xvc2VkQnJhY2tldEF0KHN0YXRlLCBwb3MpIHtcbiAgICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgICBzdGF0ZS5maWVsZChicmFja2V0U3RhdGUpLmJldHdlZW4oMCwgc3RhdGUuZG9jLmxlbmd0aCwgZnJvbSA9PiB7XG4gICAgICAgIGlmIChmcm9tID09IHBvcylcbiAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gZm91bmQ7XG59XG5mdW5jdGlvbiBuZXh0Q2hhcihkb2MsIHBvcykge1xuICAgIGxldCBuZXh0ID0gZG9jLnNsaWNlU3RyaW5nKHBvcywgcG9zICsgMik7XG4gICAgcmV0dXJuIG5leHQuc2xpY2UoMCwgY29kZVBvaW50U2l6ZShjb2RlUG9pbnRBdChuZXh0LCAwKSkpO1xufVxuZnVuY3Rpb24gcHJldkNoYXIoZG9jLCBwb3MpIHtcbiAgICBsZXQgcHJldiA9IGRvYy5zbGljZVN0cmluZyhwb3MgLSAyLCBwb3MpO1xuICAgIHJldHVybiBjb2RlUG9pbnRTaXplKGNvZGVQb2ludEF0KHByZXYsIDApKSA9PSBwcmV2Lmxlbmd0aCA/IHByZXYgOiBwcmV2LnNsaWNlKDEpO1xufVxuZnVuY3Rpb24gaGFuZGxlT3BlbihzdGF0ZSwgb3BlbiwgY2xvc2UsIGNsb3NlQmVmb3JlKSB7XG4gICAgbGV0IGRvbnQgPSBudWxsLCBjaGFuZ2VzID0gc3RhdGUuY2hhbmdlQnlSYW5nZShyYW5nZSA9PiB7XG4gICAgICAgIGlmICghcmFuZ2UuZW1wdHkpXG4gICAgICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiBbeyBpbnNlcnQ6IG9wZW4sIGZyb206IHJhbmdlLmZyb20gfSwgeyBpbnNlcnQ6IGNsb3NlLCBmcm9tOiByYW5nZS50byB9XSxcbiAgICAgICAgICAgICAgICBlZmZlY3RzOiBjbG9zZUJyYWNrZXRFZmZlY3Qub2YocmFuZ2UudG8gKyBvcGVuLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgcmFuZ2U6IEVkaXRvclNlbGVjdGlvbi5yYW5nZShyYW5nZS5hbmNob3IgKyBvcGVuLmxlbmd0aCwgcmFuZ2UuaGVhZCArIG9wZW4ubGVuZ3RoKSB9O1xuICAgICAgICBsZXQgbmV4dCA9IG5leHRDaGFyKHN0YXRlLmRvYywgcmFuZ2UuaGVhZCk7XG4gICAgICAgIGlmICghbmV4dCB8fCAvXFxzLy50ZXN0KG5leHQpIHx8IGNsb3NlQmVmb3JlLmluZGV4T2YobmV4dCkgPiAtMSlcbiAgICAgICAgICAgIHJldHVybiB7IGNoYW5nZXM6IHsgaW5zZXJ0OiBvcGVuICsgY2xvc2UsIGZyb206IHJhbmdlLmhlYWQgfSxcbiAgICAgICAgICAgICAgICBlZmZlY3RzOiBjbG9zZUJyYWNrZXRFZmZlY3Qub2YocmFuZ2UuaGVhZCArIG9wZW4ubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihyYW5nZS5oZWFkICsgb3Blbi5sZW5ndGgpIH07XG4gICAgICAgIHJldHVybiB7IHJhbmdlOiBkb250ID0gcmFuZ2UgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gZG9udCA/IG51bGwgOiBzdGF0ZS51cGRhdGUoY2hhbmdlcywge1xuICAgICAgICBzY3JvbGxJbnRvVmlldzogdHJ1ZSxcbiAgICAgICAgdXNlckV2ZW50OiBcImlucHV0LnR5cGVcIlxuICAgIH0pO1xufVxuZnVuY3Rpb24gaGFuZGxlQ2xvc2Uoc3RhdGUsIF9vcGVuLCBjbG9zZSkge1xuICAgIGxldCBkb250ID0gbnVsbCwgY2hhbmdlcyA9IHN0YXRlLmNoYW5nZUJ5UmFuZ2UocmFuZ2UgPT4ge1xuICAgICAgICBpZiAocmFuZ2UuZW1wdHkgJiYgbmV4dENoYXIoc3RhdGUuZG9jLCByYW5nZS5oZWFkKSA9PSBjbG9zZSlcbiAgICAgICAgICAgIHJldHVybiB7IGNoYW5nZXM6IHsgZnJvbTogcmFuZ2UuaGVhZCwgdG86IHJhbmdlLmhlYWQgKyBjbG9zZS5sZW5ndGgsIGluc2VydDogY2xvc2UgfSxcbiAgICAgICAgICAgICAgICByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihyYW5nZS5oZWFkICsgY2xvc2UubGVuZ3RoKSB9O1xuICAgICAgICByZXR1cm4gZG9udCA9IHsgcmFuZ2UgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gZG9udCA/IG51bGwgOiBzdGF0ZS51cGRhdGUoY2hhbmdlcywge1xuICAgICAgICBzY3JvbGxJbnRvVmlldzogdHJ1ZSxcbiAgICAgICAgdXNlckV2ZW50OiBcImlucHV0LnR5cGVcIlxuICAgIH0pO1xufVxuLy8gSGFuZGxlcyBjYXNlcyB3aGVyZSB0aGUgb3BlbiBhbmQgY2xvc2UgdG9rZW4gYXJlIHRoZSBzYW1lLCBhbmRcbi8vIHBvc3NpYmx5IHRyaXBsZSBxdW90ZXMgKGFzIGluIGBcIlwiXCJhYmNcIlwiXCJgLXN0eWxlIHF1b3RpbmcpLlxuZnVuY3Rpb24gaGFuZGxlU2FtZShzdGF0ZSwgdG9rZW4sIGFsbG93VHJpcGxlLCBjb25maWcpIHtcbiAgICBsZXQgc3RyaW5nUHJlZml4ZXMgPSBjb25maWcuc3RyaW5nUHJlZml4ZXMgfHwgZGVmYXVsdHMuc3RyaW5nUHJlZml4ZXM7XG4gICAgbGV0IGRvbnQgPSBudWxsLCBjaGFuZ2VzID0gc3RhdGUuY2hhbmdlQnlSYW5nZShyYW5nZSA9PiB7XG4gICAgICAgIGlmICghcmFuZ2UuZW1wdHkpXG4gICAgICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiBbeyBpbnNlcnQ6IHRva2VuLCBmcm9tOiByYW5nZS5mcm9tIH0sIHsgaW5zZXJ0OiB0b2tlbiwgZnJvbTogcmFuZ2UudG8gfV0sXG4gICAgICAgICAgICAgICAgZWZmZWN0czogY2xvc2VCcmFja2V0RWZmZWN0Lm9mKHJhbmdlLnRvICsgdG9rZW4ubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICByYW5nZTogRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHJhbmdlLmFuY2hvciArIHRva2VuLmxlbmd0aCwgcmFuZ2UuaGVhZCArIHRva2VuLmxlbmd0aCkgfTtcbiAgICAgICAgbGV0IHBvcyA9IHJhbmdlLmhlYWQsIG5leHQgPSBuZXh0Q2hhcihzdGF0ZS5kb2MsIHBvcyksIHN0YXJ0O1xuICAgICAgICBpZiAobmV4dCA9PSB0b2tlbikge1xuICAgICAgICAgICAgaWYgKG5vZGVTdGFydChzdGF0ZSwgcG9zKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGNoYW5nZXM6IHsgaW5zZXJ0OiB0b2tlbiArIHRva2VuLCBmcm9tOiBwb3MgfSxcbiAgICAgICAgICAgICAgICAgICAgZWZmZWN0czogY2xvc2VCcmFja2V0RWZmZWN0Lm9mKHBvcyArIHRva2VuLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHBvcyArIHRva2VuLmxlbmd0aCkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNsb3NlZEJyYWNrZXRBdChzdGF0ZSwgcG9zKSkge1xuICAgICAgICAgICAgICAgIGxldCBpc1RyaXBsZSA9IGFsbG93VHJpcGxlICYmIHN0YXRlLnNsaWNlRG9jKHBvcywgcG9zICsgdG9rZW4ubGVuZ3RoICogMykgPT0gdG9rZW4gKyB0b2tlbiArIHRva2VuO1xuICAgICAgICAgICAgICAgIGxldCBjb250ZW50ID0gaXNUcmlwbGUgPyB0b2tlbiArIHRva2VuICsgdG9rZW4gOiB0b2tlbjtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiB7IGZyb206IHBvcywgdG86IHBvcyArIGNvbnRlbnQubGVuZ3RoLCBpbnNlcnQ6IGNvbnRlbnQgfSxcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocG9zICsgY29udGVudC5sZW5ndGgpIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYWxsb3dUcmlwbGUgJiYgc3RhdGUuc2xpY2VEb2MocG9zIC0gMiAqIHRva2VuLmxlbmd0aCwgcG9zKSA9PSB0b2tlbiArIHRva2VuICYmXG4gICAgICAgICAgICAoc3RhcnQgPSBjYW5TdGFydFN0cmluZ0F0KHN0YXRlLCBwb3MgLSAyICogdG9rZW4ubGVuZ3RoLCBzdHJpbmdQcmVmaXhlcykpID4gLTEgJiZcbiAgICAgICAgICAgIG5vZGVTdGFydChzdGF0ZSwgc3RhcnQpKSB7XG4gICAgICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiB7IGluc2VydDogdG9rZW4gKyB0b2tlbiArIHRva2VuICsgdG9rZW4sIGZyb206IHBvcyB9LFxuICAgICAgICAgICAgICAgIGVmZmVjdHM6IGNsb3NlQnJhY2tldEVmZmVjdC5vZihwb3MgKyB0b2tlbi5sZW5ndGgpLFxuICAgICAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHBvcyArIHRva2VuLmxlbmd0aCkgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGF0ZS5jaGFyQ2F0ZWdvcml6ZXIocG9zKShuZXh0KSAhPSBDaGFyQ2F0ZWdvcnkuV29yZCkge1xuICAgICAgICAgICAgaWYgKGNhblN0YXJ0U3RyaW5nQXQoc3RhdGUsIHBvcywgc3RyaW5nUHJlZml4ZXMpID4gLTEgJiYgIXByb2JhYmx5SW5TdHJpbmcoc3RhdGUsIHBvcywgdG9rZW4sIHN0cmluZ1ByZWZpeGVzKSlcbiAgICAgICAgICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiB7IGluc2VydDogdG9rZW4gKyB0b2tlbiwgZnJvbTogcG9zIH0sXG4gICAgICAgICAgICAgICAgICAgIGVmZmVjdHM6IGNsb3NlQnJhY2tldEVmZmVjdC5vZihwb3MgKyB0b2tlbi5sZW5ndGgpLFxuICAgICAgICAgICAgICAgICAgICByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihwb3MgKyB0b2tlbi5sZW5ndGgpIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgcmFuZ2U6IGRvbnQgPSByYW5nZSB9O1xuICAgIH0pO1xuICAgIHJldHVybiBkb250ID8gbnVsbCA6IHN0YXRlLnVwZGF0ZShjaGFuZ2VzLCB7XG4gICAgICAgIHNjcm9sbEludG9WaWV3OiB0cnVlLFxuICAgICAgICB1c2VyRXZlbnQ6IFwiaW5wdXQudHlwZVwiXG4gICAgfSk7XG59XG5mdW5jdGlvbiBub2RlU3RhcnQoc3RhdGUsIHBvcykge1xuICAgIGxldCB0cmVlID0gc3ludGF4VHJlZShzdGF0ZSkucmVzb2x2ZUlubmVyKHBvcyArIDEpO1xuICAgIHJldHVybiB0cmVlLnBhcmVudCAmJiB0cmVlLmZyb20gPT0gcG9zO1xufVxuZnVuY3Rpb24gcHJvYmFibHlJblN0cmluZyhzdGF0ZSwgcG9zLCBxdW90ZVRva2VuLCBwcmVmaXhlcykge1xuICAgIGxldCBub2RlID0gc3ludGF4VHJlZShzdGF0ZSkucmVzb2x2ZUlubmVyKHBvcywgLTEpO1xuICAgIGxldCBtYXhQcmVmaXggPSBwcmVmaXhlcy5yZWR1Y2UoKG0sIHApID0+IE1hdGgubWF4KG0sIHAubGVuZ3RoKSwgMCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA1OyBpKyspIHtcbiAgICAgICAgbGV0IHN0YXJ0ID0gc3RhdGUuc2xpY2VEb2Mobm9kZS5mcm9tLCBNYXRoLm1pbihub2RlLnRvLCBub2RlLmZyb20gKyBxdW90ZVRva2VuLmxlbmd0aCArIG1heFByZWZpeCkpO1xuICAgICAgICBsZXQgcXVvdGVQb3MgPSBzdGFydC5pbmRleE9mKHF1b3RlVG9rZW4pO1xuICAgICAgICBpZiAoIXF1b3RlUG9zIHx8IHF1b3RlUG9zID4gLTEgJiYgcHJlZml4ZXMuaW5kZXhPZihzdGFydC5zbGljZSgwLCBxdW90ZVBvcykpID4gLTEpIHtcbiAgICAgICAgICAgIGxldCBmaXJzdCA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIHdoaWxlIChmaXJzdCAmJiBmaXJzdC5mcm9tID09IG5vZGUuZnJvbSAmJiBmaXJzdC50byAtIGZpcnN0LmZyb20gPiBxdW90ZVRva2VuLmxlbmd0aCArIHF1b3RlUG9zKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLnNsaWNlRG9jKGZpcnN0LnRvIC0gcXVvdGVUb2tlbi5sZW5ndGgsIGZpcnN0LnRvKSA9PSBxdW90ZVRva2VuKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgZmlyc3QgPSBmaXJzdC5maXJzdENoaWxkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBhcmVudCA9IG5vZGUudG8gPT0gcG9zICYmIG5vZGUucGFyZW50O1xuICAgICAgICBpZiAoIXBhcmVudClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBub2RlID0gcGFyZW50O1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBjYW5TdGFydFN0cmluZ0F0KHN0YXRlLCBwb3MsIHByZWZpeGVzKSB7XG4gICAgbGV0IGNoYXJDYXQgPSBzdGF0ZS5jaGFyQ2F0ZWdvcml6ZXIocG9zKTtcbiAgICBpZiAoY2hhckNhdChzdGF0ZS5zbGljZURvYyhwb3MgLSAxLCBwb3MpKSAhPSBDaGFyQ2F0ZWdvcnkuV29yZClcbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICBmb3IgKGxldCBwcmVmaXggb2YgcHJlZml4ZXMpIHtcbiAgICAgICAgbGV0IHN0YXJ0ID0gcG9zIC0gcHJlZml4Lmxlbmd0aDtcbiAgICAgICAgaWYgKHN0YXRlLnNsaWNlRG9jKHN0YXJ0LCBwb3MpID09IHByZWZpeCAmJiBjaGFyQ2F0KHN0YXRlLnNsaWNlRG9jKHN0YXJ0IC0gMSwgc3RhcnQpKSAhPSBDaGFyQ2F0ZWdvcnkuV29yZClcbiAgICAgICAgICAgIHJldHVybiBzdGFydDtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufVxuXG4vKipcblJldHVybnMgYW4gZXh0ZW5zaW9uIHRoYXQgZW5hYmxlcyBhdXRvY29tcGxldGlvbi5cbiovXG5mdW5jdGlvbiBhdXRvY29tcGxldGlvbihjb25maWcgPSB7fSkge1xuICAgIHJldHVybiBbXG4gICAgICAgIGNvbXBsZXRpb25TdGF0ZSxcbiAgICAgICAgY29tcGxldGlvbkNvbmZpZy5vZihjb25maWcpLFxuICAgICAgICBjb21wbGV0aW9uUGx1Z2luLFxuICAgICAgICBjb21wbGV0aW9uS2V5bWFwRXh0LFxuICAgICAgICBiYXNlVGhlbWVcbiAgICBdO1xufVxuLyoqXG5CYXNpYyBrZXliaW5kaW5ncyBmb3IgYXV0b2NvbXBsZXRpb24uXG5cbiAtIEN0cmwtU3BhY2U6IFtgc3RhcnRDb21wbGV0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUuc3RhcnRDb21wbGV0aW9uKVxuIC0gRXNjYXBlOiBbYGNsb3NlQ29tcGxldGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLmNsb3NlQ29tcGxldGlvbilcbiAtIEFycm93RG93bjogW2Btb3ZlQ29tcGxldGlvblNlbGVjdGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLm1vdmVDb21wbGV0aW9uU2VsZWN0aW9uKWAodHJ1ZSlgXG4gLSBBcnJvd1VwOiBbYG1vdmVDb21wbGV0aW9uU2VsZWN0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUubW92ZUNvbXBsZXRpb25TZWxlY3Rpb24pYChmYWxzZSlgXG4gLSBQYWdlRG93bjogW2Btb3ZlQ29tcGxldGlvblNlbGVjdGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLm1vdmVDb21wbGV0aW9uU2VsZWN0aW9uKWAodHJ1ZSwgXCJwYWdlXCIpYFxuIC0gUGFnZURvd246IFtgbW92ZUNvbXBsZXRpb25TZWxlY3Rpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5tb3ZlQ29tcGxldGlvblNlbGVjdGlvbilgKHRydWUsIFwicGFnZVwiKWBcbiAtIEVudGVyOiBbYGFjY2VwdENvbXBsZXRpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5hY2NlcHRDb21wbGV0aW9uKVxuKi9cbmNvbnN0IGNvbXBsZXRpb25LZXltYXAgPSBbXG4gICAgeyBrZXk6IFwiQ3RybC1TcGFjZVwiLCBydW46IHN0YXJ0Q29tcGxldGlvbiB9LFxuICAgIHsga2V5OiBcIkVzY2FwZVwiLCBydW46IGNsb3NlQ29tcGxldGlvbiB9LFxuICAgIHsga2V5OiBcIkFycm93RG93blwiLCBydW46IC8qQF9fUFVSRV9fKi9tb3ZlQ29tcGxldGlvblNlbGVjdGlvbih0cnVlKSB9LFxuICAgIHsga2V5OiBcIkFycm93VXBcIiwgcnVuOiAvKkBfX1BVUkVfXyovbW92ZUNvbXBsZXRpb25TZWxlY3Rpb24oZmFsc2UpIH0sXG4gICAgeyBrZXk6IFwiUGFnZURvd25cIiwgcnVuOiAvKkBfX1BVUkVfXyovbW92ZUNvbXBsZXRpb25TZWxlY3Rpb24odHJ1ZSwgXCJwYWdlXCIpIH0sXG4gICAgeyBrZXk6IFwiUGFnZVVwXCIsIHJ1bjogLypAX19QVVJFX18qL21vdmVDb21wbGV0aW9uU2VsZWN0aW9uKGZhbHNlLCBcInBhZ2VcIikgfSxcbiAgICB7IGtleTogXCJFbnRlclwiLCBydW46IGFjY2VwdENvbXBsZXRpb24gfVxuXTtcbmNvbnN0IGNvbXBsZXRpb25LZXltYXBFeHQgPSAvKkBfX1BVUkVfXyovUHJlYy5oaWdoZXN0KC8qQF9fUFVSRV9fKi9rZXltYXAuY29tcHV0ZU4oW2NvbXBsZXRpb25Db25maWddLCBzdGF0ZSA9PiBzdGF0ZS5mYWNldChjb21wbGV0aW9uQ29uZmlnKS5kZWZhdWx0S2V5bWFwID8gW2NvbXBsZXRpb25LZXltYXBdIDogW10pKTtcbi8qKlxuR2V0IHRoZSBjdXJyZW50IGNvbXBsZXRpb24gc3RhdHVzLiBXaGVuIGNvbXBsZXRpb25zIGFyZSBhdmFpbGFibGUsXG50aGlzIHdpbGwgcmV0dXJuIGBcImFjdGl2ZVwiYC4gV2hlbiBjb21wbGV0aW9ucyBhcmUgcGVuZGluZyAoaW4gdGhlXG5wcm9jZXNzIG9mIGJlaW5nIHF1ZXJpZWQpLCB0aGlzIHJldHVybnMgYFwicGVuZGluZ1wiYC4gT3RoZXJ3aXNlLCBpdFxucmV0dXJucyBgbnVsbGAuXG4qL1xuZnVuY3Rpb24gY29tcGxldGlvblN0YXR1cyhzdGF0ZSkge1xuICAgIGxldCBjU3RhdGUgPSBzdGF0ZS5maWVsZChjb21wbGV0aW9uU3RhdGUsIGZhbHNlKTtcbiAgICByZXR1cm4gY1N0YXRlICYmIGNTdGF0ZS5hY3RpdmUuc29tZShhID0+IGEuc3RhdGUgPT0gMSAvKiBTdGF0ZS5QZW5kaW5nICovKSA/IFwicGVuZGluZ1wiXG4gICAgICAgIDogY1N0YXRlICYmIGNTdGF0ZS5hY3RpdmUuc29tZShhID0+IGEuc3RhdGUgIT0gMCAvKiBTdGF0ZS5JbmFjdGl2ZSAqLykgPyBcImFjdGl2ZVwiIDogbnVsbDtcbn1cbmNvbnN0IGNvbXBsZXRpb25BcnJheUNhY2hlID0gLypAX19QVVJFX18qL25ldyBXZWFrTWFwO1xuLyoqXG5SZXR1cm5zIHRoZSBhdmFpbGFibGUgY29tcGxldGlvbnMgYXMgYW4gYXJyYXkuXG4qL1xuZnVuY3Rpb24gY3VycmVudENvbXBsZXRpb25zKHN0YXRlKSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCBvcGVuID0gKF9hID0gc3RhdGUuZmllbGQoY29tcGxldGlvblN0YXRlLCBmYWxzZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vcGVuO1xuICAgIGlmICghb3BlbiB8fCBvcGVuLmRpc2FibGVkKVxuICAgICAgICByZXR1cm4gW107XG4gICAgbGV0IGNvbXBsZXRpb25zID0gY29tcGxldGlvbkFycmF5Q2FjaGUuZ2V0KG9wZW4ub3B0aW9ucyk7XG4gICAgaWYgKCFjb21wbGV0aW9ucylcbiAgICAgICAgY29tcGxldGlvbkFycmF5Q2FjaGUuc2V0KG9wZW4ub3B0aW9ucywgY29tcGxldGlvbnMgPSBvcGVuLm9wdGlvbnMubWFwKG8gPT4gby5jb21wbGV0aW9uKSk7XG4gICAgcmV0dXJuIGNvbXBsZXRpb25zO1xufVxuLyoqXG5SZXR1cm4gdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBjb21wbGV0aW9uLCBpZiBhbnkuXG4qL1xuZnVuY3Rpb24gc2VsZWN0ZWRDb21wbGV0aW9uKHN0YXRlKSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCBvcGVuID0gKF9hID0gc3RhdGUuZmllbGQoY29tcGxldGlvblN0YXRlLCBmYWxzZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vcGVuO1xuICAgIHJldHVybiBvcGVuICYmICFvcGVuLmRpc2FibGVkICYmIG9wZW4uc2VsZWN0ZWQgPj0gMCA/IG9wZW4ub3B0aW9uc1tvcGVuLnNlbGVjdGVkXS5jb21wbGV0aW9uIDogbnVsbDtcbn1cbi8qKlxuUmV0dXJucyB0aGUgY3VycmVudGx5IHNlbGVjdGVkIHBvc2l0aW9uIGluIHRoZSBhY3RpdmUgY29tcGxldGlvblxubGlzdCwgb3IgbnVsbCBpZiBubyBjb21wbGV0aW9ucyBhcmUgYWN0aXZlLlxuKi9cbmZ1bmN0aW9uIHNlbGVjdGVkQ29tcGxldGlvbkluZGV4KHN0YXRlKSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCBvcGVuID0gKF9hID0gc3RhdGUuZmllbGQoY29tcGxldGlvblN0YXRlLCBmYWxzZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vcGVuO1xuICAgIHJldHVybiBvcGVuICYmICFvcGVuLmRpc2FibGVkICYmIG9wZW4uc2VsZWN0ZWQgPj0gMCA/IG9wZW4uc2VsZWN0ZWQgOiBudWxsO1xufVxuLyoqXG5DcmVhdGUgYW4gZWZmZWN0IHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIGEgdHJhbnNhY3Rpb24gdG8gY2hhbmdlXG50aGUgY3VycmVudGx5IHNlbGVjdGVkIGNvbXBsZXRpb24uXG4qL1xuZnVuY3Rpb24gc2V0U2VsZWN0ZWRDb21wbGV0aW9uKGluZGV4KSB7XG4gICAgcmV0dXJuIHNldFNlbGVjdGVkRWZmZWN0Lm9mKGluZGV4KTtcbn1cblxuZXhwb3J0IHsgQ29tcGxldGlvbkNvbnRleHQsIGFjY2VwdENvbXBsZXRpb24sIGF1dG9jb21wbGV0aW9uLCBjbGVhclNuaXBwZXQsIGNsb3NlQnJhY2tldHMsIGNsb3NlQnJhY2tldHNLZXltYXAsIGNsb3NlQ29tcGxldGlvbiwgY29tcGxldGVBbnlXb3JkLCBjb21wbGV0ZUZyb21MaXN0LCBjb21wbGV0aW9uS2V5bWFwLCBjb21wbGV0aW9uU3RhdHVzLCBjdXJyZW50Q29tcGxldGlvbnMsIGRlbGV0ZUJyYWNrZXRQYWlyLCBoYXNOZXh0U25pcHBldEZpZWxkLCBoYXNQcmV2U25pcHBldEZpZWxkLCBpZkluLCBpZk5vdEluLCBpbnNlcnRCcmFja2V0LCBpbnNlcnRDb21wbGV0aW9uVGV4dCwgbW92ZUNvbXBsZXRpb25TZWxlY3Rpb24sIG5leHRTbmlwcGV0RmllbGQsIHBpY2tlZENvbXBsZXRpb24sIHByZXZTbmlwcGV0RmllbGQsIHNlbGVjdGVkQ29tcGxldGlvbiwgc2VsZWN0ZWRDb21wbGV0aW9uSW5kZXgsIHNldFNlbGVjdGVkQ29tcGxldGlvbiwgc25pcHBldCwgc25pcHBldENvbXBsZXRpb24sIHNuaXBwZXRLZXltYXAsIHN0YXJ0Q29tcGxldGlvbiB9O1xuIl0sIm5hbWVzIjpbIkFubm90YXRpb24iLCJTdGF0ZUVmZmVjdCIsIkVkaXRvclNlbGVjdGlvbiIsImNvZGVQb2ludEF0IiwiY29kZVBvaW50U2l6ZSIsImZyb21Db2RlUG9pbnQiLCJGYWNldCIsImNvbWJpbmVDb25maWciLCJTdGF0ZUZpZWxkIiwiUHJlYyIsIlRleHQiLCJNYXBNb2RlIiwiUmFuZ2VWYWx1ZSIsIlJhbmdlU2V0IiwiQ2hhckNhdGVnb3J5IiwiRGlyZWN0aW9uIiwibG9nRXhjZXB0aW9uIiwic2hvd1Rvb2x0aXAiLCJFZGl0b3JWaWV3IiwiVmlld1BsdWdpbiIsImdldFRvb2x0aXAiLCJEZWNvcmF0aW9uIiwiV2lkZ2V0VHlwZSIsImtleW1hcCIsInN5bnRheFRyZWUiLCJpbmRlbnRVbml0IiwiQ29tcGxldGlvbkNvbnRleHQiLCJjb25zdHJ1Y3RvciIsInN0YXRlIiwicG9zIiwiZXhwbGljaXQiLCJhYm9ydExpc3RlbmVycyIsInRva2VuQmVmb3JlIiwidHlwZXMiLCJ0b2tlbiIsInJlc29sdmVJbm5lciIsImluZGV4T2YiLCJuYW1lIiwicGFyZW50IiwiZnJvbSIsInRvIiwidGV4dCIsInNsaWNlRG9jIiwidHlwZSIsIm1hdGNoQmVmb3JlIiwiZXhwciIsImxpbmUiLCJkb2MiLCJsaW5lQXQiLCJzdGFydCIsIk1hdGgiLCJtYXgiLCJzdHIiLCJzbGljZSIsImZvdW5kIiwic2VhcmNoIiwiZW5zdXJlQW5jaG9yIiwiYWJvcnRlZCIsImFkZEV2ZW50TGlzdGVuZXIiLCJsaXN0ZW5lciIsInB1c2giLCJ0b1NldCIsImNoYXJzIiwiZmxhdCIsIk9iamVjdCIsImtleXMiLCJqb2luIiwid29yZHMiLCJ0ZXN0IiwicmVwbGFjZSIsInByZWZpeE1hdGNoIiwib3B0aW9ucyIsImZpcnN0IiwiY3JlYXRlIiwicmVzdCIsImxhYmVsIiwiaSIsImxlbmd0aCIsInNvdXJjZSIsIlJlZ0V4cCIsImNvbXBsZXRlRnJvbUxpc3QiLCJsaXN0IiwibWFwIiwibyIsInZhbGlkRm9yIiwibWF0Y2giLCJldmVyeSIsImNvbnRleHQiLCJpZkluIiwibm9kZXMiLCJpc1RvcCIsImlmTm90SW4iLCJPcHRpb24iLCJjb21wbGV0aW9uIiwic2NvcmUiLCJjdXIiLCJzZWxlY3Rpb24iLCJtYWluIiwiX2EiLCJhZGRTdGFydCIsImFkZEVuZCIsImZsYWdzIiwiaWdub3JlQ2FzZSIsInBpY2tlZENvbXBsZXRpb24iLCJkZWZpbmUiLCJpbnNlcnRDb21wbGV0aW9uVGV4dCIsImZyb21PZmYiLCJ0b09mZiIsImFzc2lnbiIsImNoYW5nZUJ5UmFuZ2UiLCJyYW5nZSIsImNoYW5nZXMiLCJpbnNlcnQiLCJjdXJzb3IiLCJzY3JvbGxJbnRvVmlldyIsInVzZXJFdmVudCIsIlNvdXJjZUNhY2hlIiwiV2Vha01hcCIsImFzU291cmNlIiwiQXJyYXkiLCJpc0FycmF5Iiwia25vd24iLCJnZXQiLCJzZXQiLCJzdGFydENvbXBsZXRpb25FZmZlY3QiLCJjbG9zZUNvbXBsZXRpb25FZmZlY3QiLCJGdXp6eU1hdGNoZXIiLCJwYXR0ZXJuIiwiZm9sZGVkIiwiYW55IiwicHJlY2lzZSIsImJ5V29yZCIsIm1hdGNoZWQiLCJwIiwiY2hhciIsInNpemUiLCJwYXJ0IiwidXBwZXIiLCJ0b1VwcGVyQ2FzZSIsInRvTG93ZXJDYXNlIiwiYXN0cmFsIiwicmV0Iiwid29yZCIsImZpcnN0U2l6ZSIsImRpcmVjdCIsImxlbiIsImFueVRvIiwiZSIsIm1pbiIsIm5leHQiLCJwcmVjaXNlVG8iLCJieVdvcmRUbyIsImJ5V29yZEZvbGRlZCIsImFkamFjZW50VG8iLCJhZGphY2VudFN0YXJ0IiwiYWRqYWNlbnRFbmQiLCJoYXNMb3dlciIsIndvcmRBZGphY2VudCIsInByZXZUeXBlIiwiY2giLCJyZXN1bHQiLCJwb3NpdGlvbnMiLCJjb21wbGV0aW9uQ29uZmlnIiwiY29tYmluZSIsImNvbmZpZ3MiLCJhY3RpdmF0ZU9uVHlwaW5nIiwic2VsZWN0T25PcGVuIiwib3ZlcnJpZGUiLCJjbG9zZU9uQmx1ciIsIm1heFJlbmRlcmVkT3B0aW9ucyIsImRlZmF1bHRLZXltYXAiLCJ0b29sdGlwQ2xhc3MiLCJvcHRpb25DbGFzcyIsImFib3ZlQ3Vyc29yIiwiaWNvbnMiLCJhZGRUb09wdGlvbnMiLCJwb3NpdGlvbkluZm8iLCJkZWZhdWx0UG9zaXRpb25JbmZvIiwiY29tcGFyZUNvbXBsZXRpb25zIiwiYSIsImIiLCJsb2NhbGVDb21wYXJlIiwiaW50ZXJhY3Rpb25EZWxheSIsInVwZGF0ZVN5bmNUaW1lIiwiYyIsImpvaW5DbGFzcyIsImNvbmNhdCIsInZpZXciLCJvcHRpb24iLCJpbmZvIiwic3BhY2UiLCJ0b29sdGlwIiwicnRsIiwidGV4dERpcmVjdGlvbiIsIlJUTCIsImxlZnQiLCJuYXJyb3ciLCJzaWRlIiwib2Zmc2V0IiwibWF4V2lkdGgiLCJzcGFjZUxlZnQiLCJzcGFjZVJpZ2h0IiwicmlnaHQiLCJpbmZvV2lkdGgiLCJpbmZvSGVpZ2h0IiwiYm90dG9tIiwidG9wIiwic3BhY2VCZWxvdyIsInNjYWxlWSIsIm9mZnNldEhlaWdodCIsInNjYWxlWCIsIm9mZnNldFdpZHRoIiwic3R5bGUiLCJjbGFzcyIsIm9wdGlvbkNvbnRlbnQiLCJjb25maWciLCJjb250ZW50IiwicmVuZGVyIiwiaWNvbiIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImNsYXNzTGlzdCIsImFkZCIsInNwbGl0IiwiY2xzIiwic2V0QXR0cmlidXRlIiwicG9zaXRpb24iLCJfcyIsIl92IiwibGFiZWxFbHQiLCJjbGFzc05hbWUiLCJkaXNwbGF5TGFiZWwiLCJvZmYiLCJqIiwiYXBwZW5kQ2hpbGQiLCJjcmVhdGVUZXh0Tm9kZSIsInNwYW4iLCJkZXRhaWwiLCJkZXRhaWxFbHQiLCJ0ZXh0Q29udGVudCIsInNvcnQiLCJyYW5nZUFyb3VuZFNlbGVjdGVkIiwidG90YWwiLCJzZWxlY3RlZCIsImZsb29yIiwiQ29tcGxldGlvblRvb2x0aXAiLCJzdGF0ZUZpZWxkIiwiYXBwbHlDb21wbGV0aW9uIiwiaW5mb0Rlc3Ryb3kiLCJwbGFjZUluZm9SZXEiLCJyZWFkIiwibWVhc3VyZUluZm8iLCJ3cml0ZSIsInBsYWNlSW5mbyIsImtleSIsImN1cnJlbnRDbGFzcyIsImNTdGF0ZSIsImZpZWxkIiwib3BlbiIsImZhY2V0IiwiZG9tIiwidXBkYXRlVG9vbHRpcENsYXNzIiwidGFyZ2V0IiwicGFyZW50Tm9kZSIsIm5vZGVOYW1lIiwiZXhlYyIsImlkIiwicHJldmVudERlZmF1bHQiLCJyZWxhdGVkVGFyZ2V0IiwiY29udGVudERPTSIsImRpc3BhdGNoIiwiZWZmZWN0cyIsIm9mIiwic2hvd09wdGlvbnMiLCJtb3VudCIsInVwZGF0ZVNlbCIsInJlbW92ZSIsImNyZWF0ZUxpc3RCb3giLCJyZXF1ZXN0TWVhc3VyZSIsInVwZGF0ZSIsInByZXZTdGF0ZSIsInN0YXJ0U3RhdGUiLCJkaXNhYmxlZCIsInRvZ2dsZSIsInBvc2l0aW9uZWQiLCJ1cGRhdGVTZWxlY3RlZE9wdGlvbiIsImRlc3Ryb3lJbmZvIiwiaW5mb1Jlc3VsdCIsInRoZW4iLCJvYmoiLCJhZGRJbmZvUGFuZSIsImNhdGNoIiwid3JhcCIsIm5vZGVUeXBlIiwiZGVzdHJveSIsIm9wdCIsImZpcnN0Q2hpbGQiLCJuZXh0U2libGluZyIsImhhc0F0dHJpYnV0ZSIsInJlbW92ZUF0dHJpYnV0ZSIsInNlbCIsInF1ZXJ5U2VsZWN0b3IiLCJsaXN0UmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImluZm9SZWN0Iiwic2VsUmVjdCIsIndpbiIsIm93bmVyRG9jdW1lbnQiLCJkZWZhdWx0VmlldyIsIndpbmRvdyIsImlubmVyV2lkdGgiLCJpbm5lckhlaWdodCIsImNzc1RleHQiLCJ1bCIsInBocmFzZSIsImN1clNlY3Rpb24iLCJzZWN0aW9uIiwiaGVhZGVyIiwibGkiLCJub2RlIiwiY29tcGxldGlvblRvb2x0aXAiLCJjb250YWluZXIiLCJlbGVtZW50Iiwic2VsZiIsImhlaWdodCIsInNjcm9sbFRvcCIsImJvb3N0IiwiYXBwbHkiLCJzb3J0T3B0aW9ucyIsImFjdGl2ZSIsInNlY3Rpb25zIiwiYWRkT3B0aW9uIiwic29tZSIsInMiLCJoYXNSZXN1bHQiLCJnZXRNYXRjaCIsImZpbHRlciIsIm1hdGNoZXIiLCJzZWN0aW9uT3JkZXIiLCJjbXAiLCJfYiIsInJhbmsiLCJwcmV2IiwiY29tcGFyZSIsIkNvbXBsZXRpb25EaWFsb2ciLCJhdHRycyIsInRpbWVzdGFtcCIsInNldFNlbGVjdGVkIiwibWFrZUF0dHJzIiwiYnVpbGQiLCJjb25mIiwic2VsZWN0ZWRWYWx1ZSIsInJlZHVjZSIsImNyZWF0ZVRvb2x0aXAiLCJhYm92ZSIsIkRhdGUiLCJub3ciLCJtYXBQb3MiLCJDb21wbGV0aW9uU3RhdGUiLCJub25lIiwicmFuZG9tIiwidG9TdHJpbmciLCJ0ciIsInNvdXJjZXMiLCJsYW5ndWFnZURhdGFBdCIsInZhbHVlIiwiZmluZCIsIkFjdGl2ZVNvdXJjZSIsImRvY0NoYW5nZWQiLCJ0b3VjaGVzUmFuZ2UiLCJzYW1lUmVzdWx0cyIsImVmZmVjdCIsImlzIiwic2V0U2VsZWN0ZWRFZmZlY3QiLCJiYXNlQXR0cnMiLCJpQSIsImlCIiwiZW5kQSIsImVuZEIiLCJnZXRVc2VyRXZlbnQiLCJpc1VzZXJFdmVudCIsImV4cGxpY2l0UG9zIiwiZXZlbnQiLCJoYW5kbGVVc2VyRXZlbnQiLCJoYW5kbGVDaGFuZ2UiLCJzZXRBY3RpdmVFZmZlY3QiLCJlbXB0eSIsIkFjdGl2ZVJlc3VsdCIsInVwZGF0ZWQiLCJjaGVja1ZhbGlkIiwibWFwcGluZyIsImNvbXBsZXRpb25TdGF0ZSIsInByb3ZpZGUiLCJmIiwidmFsIiwiY29udGVudEF0dHJpYnV0ZXMiLCJhbm5vdGF0aW9ucyIsIm1vdmVDb21wbGV0aW9uU2VsZWN0aW9uIiwiZm9yd2FyZCIsImJ5Iiwic3RlcCIsImFjY2VwdENvbXBsZXRpb24iLCJyZWFkT25seSIsInN0YXJ0Q29tcGxldGlvbiIsImNsb3NlQ29tcGxldGlvbiIsIlJ1bm5pbmdRdWVyeSIsInRpbWUiLCJ1cGRhdGVzIiwiZG9uZSIsInVuZGVmaW5lZCIsIk1heFVwZGF0ZUNvdW50IiwiTWluQWJvcnRUaW1lIiwiY29tcGxldGlvblBsdWdpbiIsImZyb21DbGFzcyIsImRlYm91bmNlVXBkYXRlIiwicnVubmluZyIsImRlYm91bmNlQWNjZXB0IiwiY29tcG9zaW5nIiwic3RhcnRRdWVyeSIsInNlbGVjdGlvblNldCIsImRvZXNSZXNldCIsInRyYW5zYWN0aW9ucyIsInF1ZXJ5IiwiaGFuZGxlciIsInNwbGljZSIsImNsZWFyVGltZW91dCIsInEiLCJzZXRUaW1lb3V0Iiwic3RhcnRVcGRhdGUiLCJyIiwicGVuZGluZyIsIlByb21pc2UiLCJyZXNvbHZlIiwic2NoZWR1bGVBY2NlcHQiLCJlcnIiLCJhY2NlcHQiLCJjdXJyZW50IiwiZXZlbnRIYW5kbGVycyIsImJsdXIiLCJkaWFsb2ciLCJjb250YWlucyIsImNvbXBvc2l0aW9uc3RhcnQiLCJjb21wb3NpdGlvbmVuZCIsImJhc2VUaGVtZSIsImZvbnRGYW1pbHkiLCJ3aGl0ZVNwYWNlIiwib3ZlcmZsb3ciLCJtYXhXaWR0aF9mYWxsYmFjayIsIm1pbldpZHRoIiwibWF4SGVpZ2h0IiwibGlzdFN0eWxlIiwibWFyZ2luIiwicGFkZGluZyIsImxpbmVIZWlnaHQiLCJvdmVyZmxvd1giLCJ0ZXh0T3ZlcmZsb3ciLCJkaXNwbGF5IiwiYm9yZGVyQm90dG9tIiwicGFkZGluZ0xlZnQiLCJvcGFjaXR5IiwiYmFja2dyb3VuZCIsImNvbG9yIiwidGV4dEFsaWduIiwid2lkdGgiLCJib3hTaXppbmciLCJiYWNrZ3JvdW5kQ29sb3IiLCJ2ZXJ0aWNhbEFsaWduIiwiYm9yZGVyTGVmdCIsInRleHREZWNvcmF0aW9uIiwibWFyZ2luTGVmdCIsImZvbnRTdHlsZSIsImZvbnRTaXplIiwicGFkZGluZ1JpZ2h0IiwiRmllbGRQb3MiLCJGaWVsZFJhbmdlIiwiVHJhY2tEZWwiLCJTbmlwcGV0IiwibGluZXMiLCJmaWVsZFBvc2l0aW9ucyIsImluc3RhbnRpYXRlIiwibGluZVN0YXJ0IiwibGluZU9iaiIsImJhc2VJbmRlbnQiLCJpbmRlbnQiLCJ0YWJzIiwicmFuZ2VzIiwicGFyc2UiLCJ0ZW1wbGF0ZSIsImZpZWxkcyIsIm0iLCJzZXEiLCJpbmRleCIsImVzYyIsImZpZWxkTWFya2VyIiwid2lkZ2V0IiwidG9ET00iLCJpZ25vcmVFdmVudCIsImZpZWxkUmFuZ2UiLCJtYXJrIiwiQWN0aXZlU25pcHBldCIsImRlY28iLCJtYXBwZWQiLCJzZWxlY3Rpb25JbnNpZGVGaWVsZCIsInNldEFjdGl2ZSIsIm1vdmVUb0ZpZWxkIiwic25pcHBldFN0YXRlIiwiZGVjb3JhdGlvbnMiLCJmaWVsZFNlbGVjdGlvbiIsInNuaXBwZXQiLCJlZGl0b3IiLCJzcGVjIiwiYXBwZW5kQ29uZmlnIiwiYWRkU25pcHBldEtleW1hcCIsInNuaXBwZXRQb2ludGVySGFuZGxlciIsIm1vdmVGaWVsZCIsImRpciIsImxhc3QiLCJjbGVhclNuaXBwZXQiLCJuZXh0U25pcHBldEZpZWxkIiwicHJldlNuaXBwZXRGaWVsZCIsImhhc05leHRTbmlwcGV0RmllbGQiLCJoYXNQcmV2U25pcHBldEZpZWxkIiwiZGVmYXVsdFNuaXBwZXRLZXltYXAiLCJydW4iLCJzaGlmdCIsInNuaXBwZXRLZXltYXAiLCJtYXBzIiwiaGlnaGVzdCIsImNvbXB1dGUiLCJzbmlwcGV0Q29tcGxldGlvbiIsImRvbUV2ZW50SGFuZGxlcnMiLCJtb3VzZWRvd24iLCJwb3NBdENvb3JkcyIsIngiLCJjbGllbnRYIiwieSIsImNsaWVudFkiLCJ3b3JkUkUiLCJ3b3JkQ2hhcnMiLCJlc2NhcGVkIiwibWFwUkUiLCJyZSIsInVuaWNvZGUiLCJ3b3JkQ2FjaGVzIiwid29yZENhY2hlIiwic3RvcmVXb3JkcyIsInNlZW4iLCJpZ25vcmVBdCIsIml0ZXJMaW5lcyIsImxhc3RJbmRleCIsImNvbGxlY3RXb3JkcyIsImNhY2hlIiwiYmlnIiwiY2FjaGVkIiwiY2hpbGRyZW4iLCJjb21wbGV0ZUFueVdvcmQiLCJkZWZhdWx0cyIsImJyYWNrZXRzIiwiYmVmb3JlIiwic3RyaW5nUHJlZml4ZXMiLCJjbG9zZUJyYWNrZXRFZmZlY3QiLCJUcmFja0FmdGVyIiwiY2xvc2VkQnJhY2tldCIsInN0YXJ0U2lkZSIsImVuZFNpZGUiLCJicmFja2V0U3RhdGUiLCJoZWFkIiwiY2xvc2VCcmFja2V0cyIsImlucHV0SGFuZGxlciIsImRlZmluZWRDbG9zaW5nIiwiY2xvc2luZyIsImNoYXJDb2RlQXQiLCJjaGFyQXQiLCJhbmRyb2lkIiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwiY29tcG9zaXRpb25TdGFydGVkIiwiaW5zZXJ0QnJhY2tldCIsImRlbGV0ZUJyYWNrZXRQYWlyIiwidG9rZW5zIiwiZG9udCIsInByZXZDaGFyIiwibmV4dENoYXIiLCJjbG9zZUJyYWNrZXRzS2V5bWFwIiwiYnJhY2tldCIsInRvayIsImNsb3NlZCIsImhhbmRsZVNhbWUiLCJoYW5kbGVPcGVuIiwiY2xvc2VkQnJhY2tldEF0IiwiaGFuZGxlQ2xvc2UiLCJiZXR3ZWVuIiwic2xpY2VTdHJpbmciLCJjbG9zZSIsImNsb3NlQmVmb3JlIiwiYW5jaG9yIiwiX29wZW4iLCJhbGxvd1RyaXBsZSIsIm5vZGVTdGFydCIsImlzVHJpcGxlIiwiY2FuU3RhcnRTdHJpbmdBdCIsImNoYXJDYXRlZ29yaXplciIsIldvcmQiLCJwcm9iYWJseUluU3RyaW5nIiwidHJlZSIsInF1b3RlVG9rZW4iLCJwcmVmaXhlcyIsIm1heFByZWZpeCIsInF1b3RlUG9zIiwiY2hhckNhdCIsInByZWZpeCIsImF1dG9jb21wbGV0aW9uIiwiY29tcGxldGlvbktleW1hcEV4dCIsImNvbXBsZXRpb25LZXltYXAiLCJjb21wdXRlTiIsImNvbXBsZXRpb25TdGF0dXMiLCJjb21wbGV0aW9uQXJyYXlDYWNoZSIsImN1cnJlbnRDb21wbGV0aW9ucyIsImNvbXBsZXRpb25zIiwic2VsZWN0ZWRDb21wbGV0aW9uIiwic2VsZWN0ZWRDb21wbGV0aW9uSW5kZXgiLCJzZXRTZWxlY3RlZENvbXBsZXRpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@codemirror/autocomplete/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@codemirror/commands/dist/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@codemirror/commands/dist/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   blockComment: () => (/* binding */ blockComment),\n/* harmony export */   blockUncomment: () => (/* binding */ blockUncomment),\n/* harmony export */   copyLineDown: () => (/* binding */ copyLineDown),\n/* harmony export */   copyLineUp: () => (/* binding */ copyLineUp),\n/* harmony export */   cursorCharBackward: () => (/* binding */ cursorCharBackward),\n/* harmony export */   cursorCharForward: () => (/* binding */ cursorCharForward),\n/* harmony export */   cursorCharLeft: () => (/* binding */ cursorCharLeft),\n/* harmony export */   cursorCharRight: () => (/* binding */ cursorCharRight),\n/* harmony export */   cursorDocEnd: () => (/* binding */ cursorDocEnd),\n/* harmony export */   cursorDocStart: () => (/* binding */ cursorDocStart),\n/* harmony export */   cursorGroupBackward: () => (/* binding */ cursorGroupBackward),\n/* harmony export */   cursorGroupForward: () => (/* binding */ cursorGroupForward),\n/* harmony export */   cursorGroupLeft: () => (/* binding */ cursorGroupLeft),\n/* harmony export */   cursorGroupRight: () => (/* binding */ cursorGroupRight),\n/* harmony export */   cursorLineBoundaryBackward: () => (/* binding */ cursorLineBoundaryBackward),\n/* harmony export */   cursorLineBoundaryForward: () => (/* binding */ cursorLineBoundaryForward),\n/* harmony export */   cursorLineBoundaryLeft: () => (/* binding */ cursorLineBoundaryLeft),\n/* harmony export */   cursorLineBoundaryRight: () => (/* binding */ cursorLineBoundaryRight),\n/* harmony export */   cursorLineDown: () => (/* binding */ cursorLineDown),\n/* harmony export */   cursorLineEnd: () => (/* binding */ cursorLineEnd),\n/* harmony export */   cursorLineStart: () => (/* binding */ cursorLineStart),\n/* harmony export */   cursorLineUp: () => (/* binding */ cursorLineUp),\n/* harmony export */   cursorMatchingBracket: () => (/* binding */ cursorMatchingBracket),\n/* harmony export */   cursorPageDown: () => (/* binding */ cursorPageDown),\n/* harmony export */   cursorPageUp: () => (/* binding */ cursorPageUp),\n/* harmony export */   cursorSubwordBackward: () => (/* binding */ cursorSubwordBackward),\n/* harmony export */   cursorSubwordForward: () => (/* binding */ cursorSubwordForward),\n/* harmony export */   cursorSyntaxLeft: () => (/* binding */ cursorSyntaxLeft),\n/* harmony export */   cursorSyntaxRight: () => (/* binding */ cursorSyntaxRight),\n/* harmony export */   defaultKeymap: () => (/* binding */ defaultKeymap),\n/* harmony export */   deleteCharBackward: () => (/* binding */ deleteCharBackward),\n/* harmony export */   deleteCharForward: () => (/* binding */ deleteCharForward),\n/* harmony export */   deleteGroupBackward: () => (/* binding */ deleteGroupBackward),\n/* harmony export */   deleteGroupForward: () => (/* binding */ deleteGroupForward),\n/* harmony export */   deleteLine: () => (/* binding */ deleteLine),\n/* harmony export */   deleteLineBoundaryBackward: () => (/* binding */ deleteLineBoundaryBackward),\n/* harmony export */   deleteLineBoundaryForward: () => (/* binding */ deleteLineBoundaryForward),\n/* harmony export */   deleteToLineEnd: () => (/* binding */ deleteToLineEnd),\n/* harmony export */   deleteToLineStart: () => (/* binding */ deleteToLineStart),\n/* harmony export */   deleteTrailingWhitespace: () => (/* binding */ deleteTrailingWhitespace),\n/* harmony export */   emacsStyleKeymap: () => (/* binding */ emacsStyleKeymap),\n/* harmony export */   history: () => (/* binding */ history),\n/* harmony export */   historyField: () => (/* binding */ historyField),\n/* harmony export */   historyKeymap: () => (/* binding */ historyKeymap),\n/* harmony export */   indentLess: () => (/* binding */ indentLess),\n/* harmony export */   indentMore: () => (/* binding */ indentMore),\n/* harmony export */   indentSelection: () => (/* binding */ indentSelection),\n/* harmony export */   indentWithTab: () => (/* binding */ indentWithTab),\n/* harmony export */   insertBlankLine: () => (/* binding */ insertBlankLine),\n/* harmony export */   insertNewline: () => (/* binding */ insertNewline),\n/* harmony export */   insertNewlineAndIndent: () => (/* binding */ insertNewlineAndIndent),\n/* harmony export */   insertTab: () => (/* binding */ insertTab),\n/* harmony export */   invertedEffects: () => (/* binding */ invertedEffects),\n/* harmony export */   isolateHistory: () => (/* binding */ isolateHistory),\n/* harmony export */   lineComment: () => (/* binding */ lineComment),\n/* harmony export */   lineUncomment: () => (/* binding */ lineUncomment),\n/* harmony export */   moveLineDown: () => (/* binding */ moveLineDown),\n/* harmony export */   moveLineUp: () => (/* binding */ moveLineUp),\n/* harmony export */   redo: () => (/* binding */ redo),\n/* harmony export */   redoDepth: () => (/* binding */ redoDepth),\n/* harmony export */   redoSelection: () => (/* binding */ redoSelection),\n/* harmony export */   selectAll: () => (/* binding */ selectAll),\n/* harmony export */   selectCharBackward: () => (/* binding */ selectCharBackward),\n/* harmony export */   selectCharForward: () => (/* binding */ selectCharForward),\n/* harmony export */   selectCharLeft: () => (/* binding */ selectCharLeft),\n/* harmony export */   selectCharRight: () => (/* binding */ selectCharRight),\n/* harmony export */   selectDocEnd: () => (/* binding */ selectDocEnd),\n/* harmony export */   selectDocStart: () => (/* binding */ selectDocStart),\n/* harmony export */   selectGroupBackward: () => (/* binding */ selectGroupBackward),\n/* harmony export */   selectGroupForward: () => (/* binding */ selectGroupForward),\n/* harmony export */   selectGroupLeft: () => (/* binding */ selectGroupLeft),\n/* harmony export */   selectGroupRight: () => (/* binding */ selectGroupRight),\n/* harmony export */   selectLine: () => (/* binding */ selectLine),\n/* harmony export */   selectLineBoundaryBackward: () => (/* binding */ selectLineBoundaryBackward),\n/* harmony export */   selectLineBoundaryForward: () => (/* binding */ selectLineBoundaryForward),\n/* harmony export */   selectLineBoundaryLeft: () => (/* binding */ selectLineBoundaryLeft),\n/* harmony export */   selectLineBoundaryRight: () => (/* binding */ selectLineBoundaryRight),\n/* harmony export */   selectLineDown: () => (/* binding */ selectLineDown),\n/* harmony export */   selectLineEnd: () => (/* binding */ selectLineEnd),\n/* harmony export */   selectLineStart: () => (/* binding */ selectLineStart),\n/* harmony export */   selectLineUp: () => (/* binding */ selectLineUp),\n/* harmony export */   selectMatchingBracket: () => (/* binding */ selectMatchingBracket),\n/* harmony export */   selectPageDown: () => (/* binding */ selectPageDown),\n/* harmony export */   selectPageUp: () => (/* binding */ selectPageUp),\n/* harmony export */   selectParentSyntax: () => (/* binding */ selectParentSyntax),\n/* harmony export */   selectSubwordBackward: () => (/* binding */ selectSubwordBackward),\n/* harmony export */   selectSubwordForward: () => (/* binding */ selectSubwordForward),\n/* harmony export */   selectSyntaxLeft: () => (/* binding */ selectSyntaxLeft),\n/* harmony export */   selectSyntaxRight: () => (/* binding */ selectSyntaxRight),\n/* harmony export */   simplifySelection: () => (/* binding */ simplifySelection),\n/* harmony export */   splitLine: () => (/* binding */ splitLine),\n/* harmony export */   standardKeymap: () => (/* binding */ standardKeymap),\n/* harmony export */   toggleBlockComment: () => (/* binding */ toggleBlockComment),\n/* harmony export */   toggleBlockCommentByLine: () => (/* binding */ toggleBlockCommentByLine),\n/* harmony export */   toggleComment: () => (/* binding */ toggleComment),\n/* harmony export */   toggleLineComment: () => (/* binding */ toggleLineComment),\n/* harmony export */   transposeChars: () => (/* binding */ transposeChars),\n/* harmony export */   undo: () => (/* binding */ undo),\n/* harmony export */   undoDepth: () => (/* binding */ undoDepth),\n/* harmony export */   undoSelection: () => (/* binding */ undoSelection)\n/* harmony export */ });\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/state */ \"(ssr)/./node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/view */ \"(ssr)/./node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _codemirror_language__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @codemirror/language */ \"(ssr)/./node_modules/@codemirror/language/dist/index.js\");\n/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/common */ \"(ssr)/./node_modules/@lezer/common/dist/index.js\");\n\n\n\n\n/**\nComment or uncomment the current selection. Will use line comments\nif available, otherwise falling back to block comments.\n*/ const toggleComment = (target)=>{\n    let { state } = target, line = state.doc.lineAt(state.selection.main.from), config = getConfig(target.state, line.from);\n    return config.line ? toggleLineComment(target) : config.block ? toggleBlockCommentByLine(target) : false;\n};\nfunction command(f, option) {\n    return ({ state, dispatch })=>{\n        if (state.readOnly) return false;\n        let tr = f(option, state);\n        if (!tr) return false;\n        dispatch(state.update(tr));\n        return true;\n    };\n}\n/**\nComment or uncomment the current selection using line comments.\nThe line comment syntax is taken from the\n[`commentTokens`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) [language\ndata](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt).\n*/ const toggleLineComment = /*@__PURE__*/ command(changeLineComment, 0 /* CommentOption.Toggle */ );\n/**\nComment the current selection using line comments.\n*/ const lineComment = /*@__PURE__*/ command(changeLineComment, 1 /* CommentOption.Comment */ );\n/**\nUncomment the current selection using line comments.\n*/ const lineUncomment = /*@__PURE__*/ command(changeLineComment, 2 /* CommentOption.Uncomment */ );\n/**\nComment or uncomment the current selection using block comments.\nThe block comment syntax is taken from the\n[`commentTokens`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) [language\ndata](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt).\n*/ const toggleBlockComment = /*@__PURE__*/ command(changeBlockComment, 0 /* CommentOption.Toggle */ );\n/**\nComment the current selection using block comments.\n*/ const blockComment = /*@__PURE__*/ command(changeBlockComment, 1 /* CommentOption.Comment */ );\n/**\nUncomment the current selection using block comments.\n*/ const blockUncomment = /*@__PURE__*/ command(changeBlockComment, 2 /* CommentOption.Uncomment */ );\n/**\nComment or uncomment the lines around the current selection using\nblock comments.\n*/ const toggleBlockCommentByLine = /*@__PURE__*/ command((o, s)=>changeBlockComment(o, s, selectedLineRanges(s)), 0 /* CommentOption.Toggle */ );\nfunction getConfig(state, pos) {\n    let data = state.languageDataAt(\"commentTokens\", pos);\n    return data.length ? data[0] : {};\n}\nconst SearchMargin = 50;\n/**\nDetermines if the given range is block-commented in the given\nstate.\n*/ function findBlockComment(state, { open, close }, from, to) {\n    let textBefore = state.sliceDoc(from - SearchMargin, from);\n    let textAfter = state.sliceDoc(to, to + SearchMargin);\n    let spaceBefore = /\\s*$/.exec(textBefore)[0].length, spaceAfter = /^\\s*/.exec(textAfter)[0].length;\n    let beforeOff = textBefore.length - spaceBefore;\n    if (textBefore.slice(beforeOff - open.length, beforeOff) == open && textAfter.slice(spaceAfter, spaceAfter + close.length) == close) {\n        return {\n            open: {\n                pos: from - spaceBefore,\n                margin: spaceBefore && 1\n            },\n            close: {\n                pos: to + spaceAfter,\n                margin: spaceAfter && 1\n            }\n        };\n    }\n    let startText, endText;\n    if (to - from <= 2 * SearchMargin) {\n        startText = endText = state.sliceDoc(from, to);\n    } else {\n        startText = state.sliceDoc(from, from + SearchMargin);\n        endText = state.sliceDoc(to - SearchMargin, to);\n    }\n    let startSpace = /^\\s*/.exec(startText)[0].length, endSpace = /\\s*$/.exec(endText)[0].length;\n    let endOff = endText.length - endSpace - close.length;\n    if (startText.slice(startSpace, startSpace + open.length) == open && endText.slice(endOff, endOff + close.length) == close) {\n        return {\n            open: {\n                pos: from + startSpace + open.length,\n                margin: /\\s/.test(startText.charAt(startSpace + open.length)) ? 1 : 0\n            },\n            close: {\n                pos: to - endSpace - close.length,\n                margin: /\\s/.test(endText.charAt(endOff - 1)) ? 1 : 0\n            }\n        };\n    }\n    return null;\n}\nfunction selectedLineRanges(state) {\n    let ranges = [];\n    for (let r of state.selection.ranges){\n        let fromLine = state.doc.lineAt(r.from);\n        let toLine = r.to <= fromLine.to ? fromLine : state.doc.lineAt(r.to);\n        let last = ranges.length - 1;\n        if (last >= 0 && ranges[last].to > fromLine.from) ranges[last].to = toLine.to;\n        else ranges.push({\n            from: fromLine.from + /^\\s*/.exec(fromLine.text)[0].length,\n            to: toLine.to\n        });\n    }\n    return ranges;\n}\n// Performs toggle, comment and uncomment of block comments in\n// languages that support them.\nfunction changeBlockComment(option, state, ranges = state.selection.ranges) {\n    let tokens = ranges.map((r)=>getConfig(state, r.from).block);\n    if (!tokens.every((c)=>c)) return null;\n    let comments = ranges.map((r, i)=>findBlockComment(state, tokens[i], r.from, r.to));\n    if (option != 2 /* CommentOption.Uncomment */  && !comments.every((c)=>c)) {\n        return {\n            changes: state.changes(ranges.map((range, i)=>{\n                if (comments[i]) return [];\n                return [\n                    {\n                        from: range.from,\n                        insert: tokens[i].open + \" \"\n                    },\n                    {\n                        from: range.to,\n                        insert: \" \" + tokens[i].close\n                    }\n                ];\n            }))\n        };\n    } else if (option != 1 /* CommentOption.Comment */  && comments.some((c)=>c)) {\n        let changes = [];\n        for(let i = 0, comment; i < comments.length; i++)if (comment = comments[i]) {\n            let token = tokens[i], { open, close } = comment;\n            changes.push({\n                from: open.pos - token.open.length,\n                to: open.pos + open.margin\n            }, {\n                from: close.pos - close.margin,\n                to: close.pos + token.close.length\n            });\n        }\n        return {\n            changes\n        };\n    }\n    return null;\n}\n// Performs toggle, comment and uncomment of line comments.\nfunction changeLineComment(option, state, ranges = state.selection.ranges) {\n    let lines = [];\n    let prevLine = -1;\n    for (let { from, to } of ranges){\n        let startI = lines.length, minIndent = 1e9;\n        let token = getConfig(state, from).line;\n        if (!token) continue;\n        for(let pos = from; pos <= to;){\n            let line = state.doc.lineAt(pos);\n            if (line.from > prevLine && (from == to || to > line.from)) {\n                prevLine = line.from;\n                let indent = /^\\s*/.exec(line.text)[0].length;\n                let empty = indent == line.length;\n                let comment = line.text.slice(indent, indent + token.length) == token ? indent : -1;\n                if (indent < line.text.length && indent < minIndent) minIndent = indent;\n                lines.push({\n                    line,\n                    comment,\n                    token,\n                    indent,\n                    empty,\n                    single: false\n                });\n            }\n            pos = line.to + 1;\n        }\n        if (minIndent < 1e9) {\n            for(let i = startI; i < lines.length; i++)if (lines[i].indent < lines[i].line.text.length) lines[i].indent = minIndent;\n        }\n        if (lines.length == startI + 1) lines[startI].single = true;\n    }\n    if (option != 2 /* CommentOption.Uncomment */  && lines.some((l)=>l.comment < 0 && (!l.empty || l.single))) {\n        let changes = [];\n        for (let { line, token, indent, empty, single } of lines)if (single || !empty) changes.push({\n            from: line.from + indent,\n            insert: token + \" \"\n        });\n        let changeSet = state.changes(changes);\n        return {\n            changes: changeSet,\n            selection: state.selection.map(changeSet, 1)\n        };\n    } else if (option != 1 /* CommentOption.Comment */  && lines.some((l)=>l.comment >= 0)) {\n        let changes = [];\n        for (let { line, comment, token } of lines)if (comment >= 0) {\n            let from = line.from + comment, to = from + token.length;\n            if (line.text[to - line.from] == \" \") to++;\n            changes.push({\n                from,\n                to\n            });\n        }\n        return {\n            changes\n        };\n    }\n    return null;\n}\nconst fromHistory = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Annotation.define();\n/**\nTransaction annotation that will prevent that transaction from\nbeing combined with other transactions in the undo history. Given\n`\"before\"`, it'll prevent merging with previous transactions. With\n`\"after\"`, subsequent transactions won't be combined with this\none. With `\"full\"`, the transaction is isolated on both sides.\n*/ const isolateHistory = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Annotation.define();\n/**\nThis facet provides a way to register functions that, given a\ntransaction, provide a set of effects that the history should\nstore when inverting the transaction. This can be used to\nintegrate some kinds of effects in the history, so that they can\nbe undone (and redone again).\n*/ const invertedEffects = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define();\nconst historyConfig = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define({\n    combine (configs) {\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.combineConfig)(configs, {\n            minDepth: 100,\n            newGroupDelay: 500,\n            joinToEvent: (_t, isAdjacent)=>isAdjacent\n        }, {\n            minDepth: Math.max,\n            newGroupDelay: Math.min,\n            joinToEvent: (a, b)=>(tr, adj)=>a(tr, adj) || b(tr, adj)\n        });\n    }\n});\nconst historyField_ = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateField.define({\n    create () {\n        return HistoryState.empty;\n    },\n    update (state, tr) {\n        let config = tr.state.facet(historyConfig);\n        let fromHist = tr.annotation(fromHistory);\n        if (fromHist) {\n            let item = HistEvent.fromTransaction(tr, fromHist.selection), from = fromHist.side;\n            let other = from == 0 /* BranchName.Done */  ? state.undone : state.done;\n            if (item) other = updateBranch(other, other.length, config.minDepth, item);\n            else other = addSelection(other, tr.startState.selection);\n            return new HistoryState(from == 0 /* BranchName.Done */  ? fromHist.rest : other, from == 0 /* BranchName.Done */  ? other : fromHist.rest);\n        }\n        let isolate = tr.annotation(isolateHistory);\n        if (isolate == \"full\" || isolate == \"before\") state = state.isolate();\n        if (tr.annotation(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Transaction.addToHistory) === false) return !tr.changes.empty ? state.addMapping(tr.changes.desc) : state;\n        let event = HistEvent.fromTransaction(tr);\n        let time = tr.annotation(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Transaction.time), userEvent = tr.annotation(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Transaction.userEvent);\n        if (event) state = state.addChanges(event, time, userEvent, config, tr);\n        else if (tr.selection) state = state.addSelection(tr.startState.selection, time, userEvent, config.newGroupDelay);\n        if (isolate == \"full\" || isolate == \"after\") state = state.isolate();\n        return state;\n    },\n    toJSON (value) {\n        return {\n            done: value.done.map((e)=>e.toJSON()),\n            undone: value.undone.map((e)=>e.toJSON())\n        };\n    },\n    fromJSON (json) {\n        return new HistoryState(json.done.map(HistEvent.fromJSON), json.undone.map(HistEvent.fromJSON));\n    }\n});\n/**\nCreate a history extension with the given configuration.\n*/ function history(config = {}) {\n    return [\n        historyField_,\n        historyConfig.of(config),\n        _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.domEventHandlers({\n            beforeinput (e, view) {\n                let command = e.inputType == \"historyUndo\" ? undo : e.inputType == \"historyRedo\" ? redo : null;\n                if (!command) return false;\n                e.preventDefault();\n                return command(view);\n            }\n        })\n    ];\n}\n/**\nThe state field used to store the history data. Should probably\nonly be used when you want to\n[serialize](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) or\n[deserialize](https://codemirror.net/6/docs/ref/#state.EditorState^fromJSON) state objects in a way\nthat preserves history.\n*/ const historyField = historyField_;\nfunction cmd(side, selection) {\n    return function({ state, dispatch }) {\n        if (!selection && state.readOnly) return false;\n        let historyState = state.field(historyField_, false);\n        if (!historyState) return false;\n        let tr = historyState.pop(side, state, selection);\n        if (!tr) return false;\n        dispatch(tr);\n        return true;\n    };\n}\n/**\nUndo a single group of history events. Returns false if no group\nwas available.\n*/ const undo = /*@__PURE__*/ cmd(0 /* BranchName.Done */ , false);\n/**\nRedo a group of history events. Returns false if no group was\navailable.\n*/ const redo = /*@__PURE__*/ cmd(1 /* BranchName.Undone */ , false);\n/**\nUndo a change or selection change.\n*/ const undoSelection = /*@__PURE__*/ cmd(0 /* BranchName.Done */ , true);\n/**\nRedo a change or selection change.\n*/ const redoSelection = /*@__PURE__*/ cmd(1 /* BranchName.Undone */ , true);\nfunction depth(side) {\n    return function(state) {\n        let histState = state.field(historyField_, false);\n        if (!histState) return 0;\n        let branch = side == 0 /* BranchName.Done */  ? histState.done : histState.undone;\n        return branch.length - (branch.length && !branch[0].changes ? 1 : 0);\n    };\n}\n/**\nThe amount of undoable change events available in a given state.\n*/ const undoDepth = /*@__PURE__*/ depth(0 /* BranchName.Done */ );\n/**\nThe amount of redoable change events available in a given state.\n*/ const redoDepth = /*@__PURE__*/ depth(1 /* BranchName.Undone */ );\n// History events store groups of changes or effects that need to be\n// undone/redone together.\nclass HistEvent {\n    constructor(// The changes in this event. Normal events hold at least one\n    // change or effect. But it may be necessary to store selection\n    // events before the first change, in which case a special type of\n    // instance is created which doesn't hold any changes, with\n    // changes == startSelection == undefined\n    changes, // The effects associated with this event\n    effects, // Accumulated mapping (from addToHistory==false) that should be\n    // applied to events below this one.\n    mapped, // The selection before this event\n    startSelection, // Stores selection changes after this event, to be used for\n    // selection undo/redo.\n    selectionsAfter){\n        this.changes = changes;\n        this.effects = effects;\n        this.mapped = mapped;\n        this.startSelection = startSelection;\n        this.selectionsAfter = selectionsAfter;\n    }\n    setSelAfter(after) {\n        return new HistEvent(this.changes, this.effects, this.mapped, this.startSelection, after);\n    }\n    toJSON() {\n        var _a, _b, _c;\n        return {\n            changes: (_a = this.changes) === null || _a === void 0 ? void 0 : _a.toJSON(),\n            mapped: (_b = this.mapped) === null || _b === void 0 ? void 0 : _b.toJSON(),\n            startSelection: (_c = this.startSelection) === null || _c === void 0 ? void 0 : _c.toJSON(),\n            selectionsAfter: this.selectionsAfter.map((s)=>s.toJSON())\n        };\n    }\n    static fromJSON(json) {\n        return new HistEvent(json.changes && _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.ChangeSet.fromJSON(json.changes), [], json.mapped && _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.ChangeDesc.fromJSON(json.mapped), json.startSelection && _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.fromJSON(json.startSelection), json.selectionsAfter.map(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.fromJSON));\n    }\n    // This does not check `addToHistory` and such, it assumes the\n    // transaction needs to be converted to an item. Returns null when\n    // there are no changes or effects in the transaction.\n    static fromTransaction(tr, selection) {\n        let effects = none;\n        for (let invert of tr.startState.facet(invertedEffects)){\n            let result = invert(tr);\n            if (result.length) effects = effects.concat(result);\n        }\n        if (!effects.length && tr.changes.empty) return null;\n        return new HistEvent(tr.changes.invert(tr.startState.doc), effects, undefined, selection || tr.startState.selection, none);\n    }\n    static selection(selections) {\n        return new HistEvent(undefined, none, undefined, undefined, selections);\n    }\n}\nfunction updateBranch(branch, to, maxLen, newEvent) {\n    let start = to + 1 > maxLen + 20 ? to - maxLen - 1 : 0;\n    let newBranch = branch.slice(start, to);\n    newBranch.push(newEvent);\n    return newBranch;\n}\nfunction isAdjacent(a, b) {\n    let ranges = [], isAdjacent = false;\n    a.iterChangedRanges((f, t)=>ranges.push(f, t));\n    b.iterChangedRanges((_f, _t, f, t)=>{\n        for(let i = 0; i < ranges.length;){\n            let from = ranges[i++], to = ranges[i++];\n            if (t >= from && f <= to) isAdjacent = true;\n        }\n    });\n    return isAdjacent;\n}\nfunction eqSelectionShape(a, b) {\n    return a.ranges.length == b.ranges.length && a.ranges.filter((r, i)=>r.empty != b.ranges[i].empty).length === 0;\n}\nfunction conc(a, b) {\n    return !a.length ? b : !b.length ? a : a.concat(b);\n}\nconst none = [];\nconst MaxSelectionsPerEvent = 200;\nfunction addSelection(branch, selection) {\n    if (!branch.length) {\n        return [\n            HistEvent.selection([\n                selection\n            ])\n        ];\n    } else {\n        let lastEvent = branch[branch.length - 1];\n        let sels = lastEvent.selectionsAfter.slice(Math.max(0, lastEvent.selectionsAfter.length - MaxSelectionsPerEvent));\n        if (sels.length && sels[sels.length - 1].eq(selection)) return branch;\n        sels.push(selection);\n        return updateBranch(branch, branch.length - 1, 1e9, lastEvent.setSelAfter(sels));\n    }\n}\n// Assumes the top item has one or more selectionAfter values\nfunction popSelection(branch) {\n    let last = branch[branch.length - 1];\n    let newBranch = branch.slice();\n    newBranch[branch.length - 1] = last.setSelAfter(last.selectionsAfter.slice(0, last.selectionsAfter.length - 1));\n    return newBranch;\n}\n// Add a mapping to the top event in the given branch. If this maps\n// away all the changes and effects in that item, drop it and\n// propagate the mapping to the next item.\nfunction addMappingToBranch(branch, mapping) {\n    if (!branch.length) return branch;\n    let length = branch.length, selections = none;\n    while(length){\n        let event = mapEvent(branch[length - 1], mapping, selections);\n        if (event.changes && !event.changes.empty || event.effects.length) {\n            let result = branch.slice(0, length);\n            result[length - 1] = event;\n            return result;\n        } else {\n            mapping = event.mapped;\n            length--;\n            selections = event.selectionsAfter;\n        }\n    }\n    return selections.length ? [\n        HistEvent.selection(selections)\n    ] : none;\n}\nfunction mapEvent(event, mapping, extraSelections) {\n    let selections = conc(event.selectionsAfter.length ? event.selectionsAfter.map((s)=>s.map(mapping)) : none, extraSelections);\n    // Change-less events don't store mappings (they are always the last event in a branch)\n    if (!event.changes) return HistEvent.selection(selections);\n    let mappedChanges = event.changes.map(mapping), before = mapping.mapDesc(event.changes, true);\n    let fullMapping = event.mapped ? event.mapped.composeDesc(before) : before;\n    return new HistEvent(mappedChanges, _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.mapEffects(event.effects, mapping), fullMapping, event.startSelection.map(before), selections);\n}\nconst joinableUserEvent = /^(input\\.type|delete)($|\\.)/;\nclass HistoryState {\n    constructor(done, undone, prevTime = 0, prevUserEvent = undefined){\n        this.done = done;\n        this.undone = undone;\n        this.prevTime = prevTime;\n        this.prevUserEvent = prevUserEvent;\n    }\n    isolate() {\n        return this.prevTime ? new HistoryState(this.done, this.undone) : this;\n    }\n    addChanges(event, time, userEvent, config, tr) {\n        let done = this.done, lastEvent = done[done.length - 1];\n        if (lastEvent && lastEvent.changes && !lastEvent.changes.empty && event.changes && (!userEvent || joinableUserEvent.test(userEvent)) && (!lastEvent.selectionsAfter.length && time - this.prevTime < config.newGroupDelay && config.joinToEvent(tr, isAdjacent(lastEvent.changes, event.changes)) || // For compose (but not compose.start) events, always join with previous event\n        userEvent == \"input.type.compose\")) {\n            done = updateBranch(done, done.length - 1, config.minDepth, new HistEvent(event.changes.compose(lastEvent.changes), conc(event.effects, lastEvent.effects), lastEvent.mapped, lastEvent.startSelection, none));\n        } else {\n            done = updateBranch(done, done.length, config.minDepth, event);\n        }\n        return new HistoryState(done, none, time, userEvent);\n    }\n    addSelection(selection, time, userEvent, newGroupDelay) {\n        let last = this.done.length ? this.done[this.done.length - 1].selectionsAfter : none;\n        if (last.length > 0 && time - this.prevTime < newGroupDelay && userEvent == this.prevUserEvent && userEvent && /^select($|\\.)/.test(userEvent) && eqSelectionShape(last[last.length - 1], selection)) return this;\n        return new HistoryState(addSelection(this.done, selection), this.undone, time, userEvent);\n    }\n    addMapping(mapping) {\n        return new HistoryState(addMappingToBranch(this.done, mapping), addMappingToBranch(this.undone, mapping), this.prevTime, this.prevUserEvent);\n    }\n    pop(side, state, onlySelection) {\n        let branch = side == 0 /* BranchName.Done */  ? this.done : this.undone;\n        if (branch.length == 0) return null;\n        let event = branch[branch.length - 1], selection = event.selectionsAfter[0] || state.selection;\n        if (onlySelection && event.selectionsAfter.length) {\n            return state.update({\n                selection: event.selectionsAfter[event.selectionsAfter.length - 1],\n                annotations: fromHistory.of({\n                    side,\n                    rest: popSelection(branch),\n                    selection\n                }),\n                userEvent: side == 0 /* BranchName.Done */  ? \"select.undo\" : \"select.redo\",\n                scrollIntoView: true\n            });\n        } else if (!event.changes) {\n            return null;\n        } else {\n            let rest = branch.length == 1 ? none : branch.slice(0, branch.length - 1);\n            if (event.mapped) rest = addMappingToBranch(rest, event.mapped);\n            return state.update({\n                changes: event.changes,\n                selection: event.startSelection,\n                effects: event.effects,\n                annotations: fromHistory.of({\n                    side,\n                    rest,\n                    selection\n                }),\n                filter: false,\n                userEvent: side == 0 /* BranchName.Done */  ? \"undo\" : \"redo\",\n                scrollIntoView: true\n            });\n        }\n    }\n}\nHistoryState.empty = /*@__PURE__*/ new HistoryState(none, none);\n/**\nDefault key bindings for the undo history.\n\n- Mod-z: [`undo`](https://codemirror.net/6/docs/ref/#commands.undo).\n- Mod-y (Mod-Shift-z on macOS) + Ctrl-Shift-z on Linux: [`redo`](https://codemirror.net/6/docs/ref/#commands.redo).\n- Mod-u: [`undoSelection`](https://codemirror.net/6/docs/ref/#commands.undoSelection).\n- Alt-u (Mod-Shift-u on macOS): [`redoSelection`](https://codemirror.net/6/docs/ref/#commands.redoSelection).\n*/ const historyKeymap = [\n    {\n        key: \"Mod-z\",\n        run: undo,\n        preventDefault: true\n    },\n    {\n        key: \"Mod-y\",\n        mac: \"Mod-Shift-z\",\n        run: redo,\n        preventDefault: true\n    },\n    {\n        linux: \"Ctrl-Shift-z\",\n        run: redo,\n        preventDefault: true\n    },\n    {\n        key: \"Mod-u\",\n        run: undoSelection,\n        preventDefault: true\n    },\n    {\n        key: \"Alt-u\",\n        mac: \"Mod-Shift-u\",\n        run: redoSelection,\n        preventDefault: true\n    }\n];\nfunction updateSel(sel, by) {\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create(sel.ranges.map(by), sel.mainIndex);\n}\nfunction setSel(state, selection) {\n    return state.update({\n        selection,\n        scrollIntoView: true,\n        userEvent: \"select\"\n    });\n}\nfunction moveSel({ state, dispatch }, how) {\n    let selection = updateSel(state.selection, how);\n    if (selection.eq(state.selection)) return false;\n    dispatch(setSel(state, selection));\n    return true;\n}\nfunction rangeEnd(range, forward) {\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(forward ? range.to : range.from);\n}\nfunction cursorByChar(view, forward) {\n    return moveSel(view, (range)=>range.empty ? view.moveByChar(range, forward) : rangeEnd(range, forward));\n}\nfunction ltrAtCursor(view) {\n    return view.textDirectionAt(view.state.selection.main.head) == _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Direction.LTR;\n}\n/**\nMove the selection one character to the left (which is backward in\nleft-to-right text, forward in right-to-left text).\n*/ const cursorCharLeft = (view)=>cursorByChar(view, !ltrAtCursor(view));\n/**\nMove the selection one character to the right.\n*/ const cursorCharRight = (view)=>cursorByChar(view, ltrAtCursor(view));\n/**\nMove the selection one character forward.\n*/ const cursorCharForward = (view)=>cursorByChar(view, true);\n/**\nMove the selection one character backward.\n*/ const cursorCharBackward = (view)=>cursorByChar(view, false);\nfunction cursorByGroup(view, forward) {\n    return moveSel(view, (range)=>range.empty ? view.moveByGroup(range, forward) : rangeEnd(range, forward));\n}\n/**\nMove the selection to the left across one group of word or\nnon-word (but also non-space) characters.\n*/ const cursorGroupLeft = (view)=>cursorByGroup(view, !ltrAtCursor(view));\n/**\nMove the selection one group to the right.\n*/ const cursorGroupRight = (view)=>cursorByGroup(view, ltrAtCursor(view));\n/**\nMove the selection one group forward.\n*/ const cursorGroupForward = (view)=>cursorByGroup(view, true);\n/**\nMove the selection one group backward.\n*/ const cursorGroupBackward = (view)=>cursorByGroup(view, false);\nconst segmenter = typeof Intl != \"undefined\" && Intl.Segmenter ? /*@__PURE__*/ new Intl.Segmenter(undefined, {\n    granularity: \"word\"\n}) : null;\nfunction moveBySubword(view, range, forward) {\n    let categorize = view.state.charCategorizer(range.from);\n    let cat = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Space, pos = range.from, steps = 0;\n    let done = false, sawUpper = false, sawLower = false;\n    let step = (next)=>{\n        if (done) return false;\n        pos += forward ? next.length : -next.length;\n        let nextCat = categorize(next), ahead;\n        if (nextCat == _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word && next.charCodeAt(0) < 128 && /[\\W_]/.test(next)) nextCat = -1; // Treat word punctuation specially\n        if (cat == _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Space) cat = nextCat;\n        if (cat != nextCat) return false;\n        if (cat == _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word) {\n            if (next.toLowerCase() == next) {\n                if (!forward && sawUpper) return false;\n                sawLower = true;\n            } else if (sawLower) {\n                if (forward) return false;\n                done = true;\n            } else {\n                if (sawUpper && forward && categorize(ahead = view.state.sliceDoc(pos, pos + 1)) == _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word && ahead.toLowerCase() == ahead) return false;\n                sawUpper = true;\n            }\n        }\n        steps++;\n        return true;\n    };\n    let end = view.moveByChar(range, forward, (start)=>{\n        step(start);\n        return step;\n    });\n    if (segmenter && cat == _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word && end.from == range.from + steps * (forward ? 1 : -1)) {\n        let from = Math.min(range.head, end.head), to = Math.max(range.head, end.head);\n        let skipped = view.state.sliceDoc(from, to);\n        if (skipped.length > 1 && /[\\u4E00-\\uffff]/.test(skipped)) {\n            let segments = Array.from(segmenter.segment(skipped));\n            if (segments.length > 1) {\n                if (forward) return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(range.head + segments[1].index, -1);\n                return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(end.head + segments[segments.length - 1].index, 1);\n            }\n        }\n    }\n    return end;\n}\nfunction cursorBySubword(view, forward) {\n    return moveSel(view, (range)=>range.empty ? moveBySubword(view, range, forward) : rangeEnd(range, forward));\n}\n/**\nMove the selection one group or camel-case subword forward.\n*/ const cursorSubwordForward = (view)=>cursorBySubword(view, true);\n/**\nMove the selection one group or camel-case subword backward.\n*/ const cursorSubwordBackward = (view)=>cursorBySubword(view, false);\nfunction interestingNode(state, node, bracketProp) {\n    if (node.type.prop(bracketProp)) return true;\n    let len = node.to - node.from;\n    return len && (len > 2 || /[^\\s,.;:]/.test(state.sliceDoc(node.from, node.to))) || node.firstChild;\n}\nfunction moveBySyntax(state, start, forward) {\n    let pos = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.syntaxTree)(state).resolveInner(start.head);\n    let bracketProp = forward ? _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.closedBy : _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.openedBy;\n    // Scan forward through child nodes to see if there's an interesting\n    // node ahead.\n    for(let at = start.head;;){\n        let next = forward ? pos.childAfter(at) : pos.childBefore(at);\n        if (!next) break;\n        if (interestingNode(state, next, bracketProp)) pos = next;\n        else at = forward ? next.to : next.from;\n    }\n    let bracket = pos.type.prop(bracketProp), match, newPos;\n    if (bracket && (match = forward ? (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.matchBrackets)(state, pos.from, 1) : (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.matchBrackets)(state, pos.to, -1)) && match.matched) newPos = forward ? match.end.to : match.end.from;\n    else newPos = forward ? pos.to : pos.from;\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(newPos, forward ? -1 : 1);\n}\n/**\nMove the cursor over the next syntactic element to the left.\n*/ const cursorSyntaxLeft = (view)=>moveSel(view, (range)=>moveBySyntax(view.state, range, !ltrAtCursor(view)));\n/**\nMove the cursor over the next syntactic element to the right.\n*/ const cursorSyntaxRight = (view)=>moveSel(view, (range)=>moveBySyntax(view.state, range, ltrAtCursor(view)));\nfunction cursorByLine(view, forward) {\n    return moveSel(view, (range)=>{\n        if (!range.empty) return rangeEnd(range, forward);\n        let moved = view.moveVertically(range, forward);\n        return moved.head != range.head ? moved : view.moveToLineBoundary(range, forward);\n    });\n}\n/**\nMove the selection one line up.\n*/ const cursorLineUp = (view)=>cursorByLine(view, false);\n/**\nMove the selection one line down.\n*/ const cursorLineDown = (view)=>cursorByLine(view, true);\nfunction pageInfo(view) {\n    let selfScroll = view.scrollDOM.clientHeight < view.scrollDOM.scrollHeight - 2;\n    let marginTop = 0, marginBottom = 0, height;\n    if (selfScroll) {\n        for (let source of view.state.facet(_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.scrollMargins)){\n            let margins = source(view);\n            if (margins === null || margins === void 0 ? void 0 : margins.top) marginTop = Math.max(margins === null || margins === void 0 ? void 0 : margins.top, marginTop);\n            if (margins === null || margins === void 0 ? void 0 : margins.bottom) marginBottom = Math.max(margins === null || margins === void 0 ? void 0 : margins.bottom, marginBottom);\n        }\n        height = view.scrollDOM.clientHeight - marginTop - marginBottom;\n    } else {\n        height = (view.dom.ownerDocument.defaultView || window).innerHeight;\n    }\n    return {\n        marginTop,\n        marginBottom,\n        selfScroll,\n        height: Math.max(view.defaultLineHeight, height - 5)\n    };\n}\nfunction cursorByPage(view, forward) {\n    let page = pageInfo(view);\n    let { state } = view, selection = updateSel(state.selection, (range)=>{\n        return range.empty ? view.moveVertically(range, forward, page.height) : rangeEnd(range, forward);\n    });\n    if (selection.eq(state.selection)) return false;\n    let effect;\n    if (page.selfScroll) {\n        let startPos = view.coordsAtPos(state.selection.main.head);\n        let scrollRect = view.scrollDOM.getBoundingClientRect();\n        let scrollTop = scrollRect.top + page.marginTop, scrollBottom = scrollRect.bottom - page.marginBottom;\n        if (startPos && startPos.top > scrollTop && startPos.bottom < scrollBottom) effect = _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.scrollIntoView(selection.main.head, {\n            y: \"start\",\n            yMargin: startPos.top - scrollTop\n        });\n    }\n    view.dispatch(setSel(state, selection), {\n        effects: effect\n    });\n    return true;\n}\n/**\nMove the selection one page up.\n*/ const cursorPageUp = (view)=>cursorByPage(view, false);\n/**\nMove the selection one page down.\n*/ const cursorPageDown = (view)=>cursorByPage(view, true);\nfunction moveByLineBoundary(view, start, forward) {\n    let line = view.lineBlockAt(start.head), moved = view.moveToLineBoundary(start, forward);\n    if (moved.head == start.head && moved.head != (forward ? line.to : line.from)) moved = view.moveToLineBoundary(start, forward, false);\n    if (!forward && moved.head == line.from && line.length) {\n        let space = /^\\s*/.exec(view.state.sliceDoc(line.from, Math.min(line.from + 100, line.to)))[0].length;\n        if (space && start.head != line.from + space) moved = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(line.from + space);\n    }\n    return moved;\n}\n/**\nMove the selection to the next line wrap point, or to the end of\nthe line if there isn't one left on this line.\n*/ const cursorLineBoundaryForward = (view)=>moveSel(view, (range)=>moveByLineBoundary(view, range, true));\n/**\nMove the selection to previous line wrap point, or failing that to\nthe start of the line. If the line is indented, and the cursor\nisn't already at the end of the indentation, this will move to the\nend of the indentation instead of the start of the line.\n*/ const cursorLineBoundaryBackward = (view)=>moveSel(view, (range)=>moveByLineBoundary(view, range, false));\n/**\nMove the selection one line wrap point to the left.\n*/ const cursorLineBoundaryLeft = (view)=>moveSel(view, (range)=>moveByLineBoundary(view, range, !ltrAtCursor(view)));\n/**\nMove the selection one line wrap point to the right.\n*/ const cursorLineBoundaryRight = (view)=>moveSel(view, (range)=>moveByLineBoundary(view, range, ltrAtCursor(view)));\n/**\nMove the selection to the start of the line.\n*/ const cursorLineStart = (view)=>moveSel(view, (range)=>_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(view.lineBlockAt(range.head).from, 1));\n/**\nMove the selection to the end of the line.\n*/ const cursorLineEnd = (view)=>moveSel(view, (range)=>_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(view.lineBlockAt(range.head).to, -1));\nfunction toMatchingBracket(state, dispatch, extend) {\n    let found = false, selection = updateSel(state.selection, (range)=>{\n        let matching = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.matchBrackets)(state, range.head, -1) || (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.matchBrackets)(state, range.head, 1) || range.head > 0 && (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.matchBrackets)(state, range.head - 1, 1) || range.head < state.doc.length && (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.matchBrackets)(state, range.head + 1, -1);\n        if (!matching || !matching.end) return range;\n        found = true;\n        let head = matching.start.from == range.head ? matching.end.to : matching.end.from;\n        return extend ? _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(range.anchor, head) : _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(head);\n    });\n    if (!found) return false;\n    dispatch(setSel(state, selection));\n    return true;\n}\n/**\nMove the selection to the bracket matching the one it is currently\non, if any.\n*/ const cursorMatchingBracket = ({ state, dispatch })=>toMatchingBracket(state, dispatch, false);\n/**\nExtend the selection to the bracket matching the one the selection\nhead is currently on, if any.\n*/ const selectMatchingBracket = ({ state, dispatch })=>toMatchingBracket(state, dispatch, true);\nfunction extendSel(view, how) {\n    let selection = updateSel(view.state.selection, (range)=>{\n        let head = how(range);\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(range.anchor, head.head, head.goalColumn, head.bidiLevel || undefined);\n    });\n    if (selection.eq(view.state.selection)) return false;\n    view.dispatch(setSel(view.state, selection));\n    return true;\n}\nfunction selectByChar(view, forward) {\n    return extendSel(view, (range)=>view.moveByChar(range, forward));\n}\n/**\nMove the selection head one character to the left, while leaving\nthe anchor in place.\n*/ const selectCharLeft = (view)=>selectByChar(view, !ltrAtCursor(view));\n/**\nMove the selection head one character to the right.\n*/ const selectCharRight = (view)=>selectByChar(view, ltrAtCursor(view));\n/**\nMove the selection head one character forward.\n*/ const selectCharForward = (view)=>selectByChar(view, true);\n/**\nMove the selection head one character backward.\n*/ const selectCharBackward = (view)=>selectByChar(view, false);\nfunction selectByGroup(view, forward) {\n    return extendSel(view, (range)=>view.moveByGroup(range, forward));\n}\n/**\nMove the selection head one [group](https://codemirror.net/6/docs/ref/#commands.cursorGroupLeft) to\nthe left.\n*/ const selectGroupLeft = (view)=>selectByGroup(view, !ltrAtCursor(view));\n/**\nMove the selection head one group to the right.\n*/ const selectGroupRight = (view)=>selectByGroup(view, ltrAtCursor(view));\n/**\nMove the selection head one group forward.\n*/ const selectGroupForward = (view)=>selectByGroup(view, true);\n/**\nMove the selection head one group backward.\n*/ const selectGroupBackward = (view)=>selectByGroup(view, false);\nfunction selectBySubword(view, forward) {\n    return extendSel(view, (range)=>moveBySubword(view, range, forward));\n}\n/**\nMove the selection head one group or camel-case subword forward.\n*/ const selectSubwordForward = (view)=>selectBySubword(view, true);\n/**\nMove the selection head one group or subword backward.\n*/ const selectSubwordBackward = (view)=>selectBySubword(view, false);\n/**\nMove the selection head over the next syntactic element to the left.\n*/ const selectSyntaxLeft = (view)=>extendSel(view, (range)=>moveBySyntax(view.state, range, !ltrAtCursor(view)));\n/**\nMove the selection head over the next syntactic element to the right.\n*/ const selectSyntaxRight = (view)=>extendSel(view, (range)=>moveBySyntax(view.state, range, ltrAtCursor(view)));\nfunction selectByLine(view, forward) {\n    return extendSel(view, (range)=>view.moveVertically(range, forward));\n}\n/**\nMove the selection head one line up.\n*/ const selectLineUp = (view)=>selectByLine(view, false);\n/**\nMove the selection head one line down.\n*/ const selectLineDown = (view)=>selectByLine(view, true);\nfunction selectByPage(view, forward) {\n    return extendSel(view, (range)=>view.moveVertically(range, forward, pageInfo(view).height));\n}\n/**\nMove the selection head one page up.\n*/ const selectPageUp = (view)=>selectByPage(view, false);\n/**\nMove the selection head one page down.\n*/ const selectPageDown = (view)=>selectByPage(view, true);\n/**\nMove the selection head to the next line boundary.\n*/ const selectLineBoundaryForward = (view)=>extendSel(view, (range)=>moveByLineBoundary(view, range, true));\n/**\nMove the selection head to the previous line boundary.\n*/ const selectLineBoundaryBackward = (view)=>extendSel(view, (range)=>moveByLineBoundary(view, range, false));\n/**\nMove the selection head one line boundary to the left.\n*/ const selectLineBoundaryLeft = (view)=>extendSel(view, (range)=>moveByLineBoundary(view, range, !ltrAtCursor(view)));\n/**\nMove the selection head one line boundary to the right.\n*/ const selectLineBoundaryRight = (view)=>extendSel(view, (range)=>moveByLineBoundary(view, range, ltrAtCursor(view)));\n/**\nMove the selection head to the start of the line.\n*/ const selectLineStart = (view)=>extendSel(view, (range)=>_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(view.lineBlockAt(range.head).from));\n/**\nMove the selection head to the end of the line.\n*/ const selectLineEnd = (view)=>extendSel(view, (range)=>_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(view.lineBlockAt(range.head).to));\n/**\nMove the selection to the start of the document.\n*/ const cursorDocStart = ({ state, dispatch })=>{\n    dispatch(setSel(state, {\n        anchor: 0\n    }));\n    return true;\n};\n/**\nMove the selection to the end of the document.\n*/ const cursorDocEnd = ({ state, dispatch })=>{\n    dispatch(setSel(state, {\n        anchor: state.doc.length\n    }));\n    return true;\n};\n/**\nMove the selection head to the start of the document.\n*/ const selectDocStart = ({ state, dispatch })=>{\n    dispatch(setSel(state, {\n        anchor: state.selection.main.anchor,\n        head: 0\n    }));\n    return true;\n};\n/**\nMove the selection head to the end of the document.\n*/ const selectDocEnd = ({ state, dispatch })=>{\n    dispatch(setSel(state, {\n        anchor: state.selection.main.anchor,\n        head: state.doc.length\n    }));\n    return true;\n};\n/**\nSelect the entire document.\n*/ const selectAll = ({ state, dispatch })=>{\n    dispatch(state.update({\n        selection: {\n            anchor: 0,\n            head: state.doc.length\n        },\n        userEvent: \"select\"\n    }));\n    return true;\n};\n/**\nExpand the selection to cover entire lines.\n*/ const selectLine = ({ state, dispatch })=>{\n    let ranges = selectedLineBlocks(state).map(({ from, to })=>_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(from, Math.min(to + 1, state.doc.length)));\n    dispatch(state.update({\n        selection: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create(ranges),\n        userEvent: \"select\"\n    }));\n    return true;\n};\n/**\nSelect the next syntactic construct that is larger than the\nselection. Note that this will only work insofar as the language\n[provider](https://codemirror.net/6/docs/ref/#language.language) you use builds up a full\nsyntax tree.\n*/ const selectParentSyntax = ({ state, dispatch })=>{\n    let selection = updateSel(state.selection, (range)=>{\n        var _a;\n        let stack = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.syntaxTree)(state).resolveStack(range.from, 1);\n        for(let cur = stack; cur; cur = cur.next){\n            let { node } = cur;\n            if ((node.from < range.from && node.to >= range.to || node.to > range.to && node.from <= range.from) && ((_a = node.parent) === null || _a === void 0 ? void 0 : _a.parent)) return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(node.to, node.from);\n        }\n        return range;\n    });\n    dispatch(setSel(state, selection));\n    return true;\n};\n/**\nSimplify the current selection. When multiple ranges are selected,\nreduce it to its main range. Otherwise, if the selection is\nnon-empty, convert it to a cursor selection.\n*/ const simplifySelection = ({ state, dispatch })=>{\n    let cur = state.selection, selection = null;\n    if (cur.ranges.length > 1) selection = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create([\n        cur.main\n    ]);\n    else if (!cur.main.empty) selection = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create([\n        _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(cur.main.head)\n    ]);\n    if (!selection) return false;\n    dispatch(setSel(state, selection));\n    return true;\n};\nfunction deleteBy(target, by) {\n    if (target.state.readOnly) return false;\n    let event = \"delete.selection\", { state } = target;\n    let changes = state.changeByRange((range)=>{\n        let { from, to } = range;\n        if (from == to) {\n            let towards = by(range);\n            if (towards < from) {\n                event = \"delete.backward\";\n                towards = skipAtomic(target, towards, false);\n            } else if (towards > from) {\n                event = \"delete.forward\";\n                towards = skipAtomic(target, towards, true);\n            }\n            from = Math.min(from, towards);\n            to = Math.max(to, towards);\n        } else {\n            from = skipAtomic(target, from, false);\n            to = skipAtomic(target, to, true);\n        }\n        return from == to ? {\n            range\n        } : {\n            changes: {\n                from,\n                to\n            },\n            range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(from, from < range.head ? -1 : 1)\n        };\n    });\n    if (changes.changes.empty) return false;\n    target.dispatch(state.update(changes, {\n        scrollIntoView: true,\n        userEvent: event,\n        effects: event == \"delete.selection\" ? _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.announce.of(state.phrase(\"Selection deleted\")) : undefined\n    }));\n    return true;\n}\nfunction skipAtomic(target, pos, forward) {\n    if (target instanceof _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView) for (let ranges of target.state.facet(_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.atomicRanges).map((f)=>f(target)))ranges.between(pos, pos, (from, to)=>{\n        if (from < pos && to > pos) pos = forward ? to : from;\n    });\n    return pos;\n}\nconst deleteByChar = (target, forward)=>deleteBy(target, (range)=>{\n        let pos = range.from, { state } = target, line = state.doc.lineAt(pos), before, targetPos;\n        if (!forward && pos > line.from && pos < line.from + 200 && !/[^ \\t]/.test(before = line.text.slice(0, pos - line.from))) {\n            if (before[before.length - 1] == \"\t\") return pos - 1;\n            let col = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.countColumn)(before, state.tabSize), drop = col % (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.getIndentUnit)(state) || (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.getIndentUnit)(state);\n            for(let i = 0; i < drop && before[before.length - 1 - i] == \" \"; i++)pos--;\n            targetPos = pos;\n        } else {\n            targetPos = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.findClusterBreak)(line.text, pos - line.from, forward, forward) + line.from;\n            if (targetPos == pos && line.number != (forward ? state.doc.lines : 1)) targetPos += forward ? 1 : -1;\n            else if (!forward && /[\\ufe00-\\ufe0f]/.test(line.text.slice(targetPos - line.from, pos - line.from))) targetPos = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.findClusterBreak)(line.text, targetPos - line.from, false, false);\n        }\n        return targetPos;\n    });\n/**\nDelete the selection, or, for cursor selections, the character\nbefore the cursor.\n*/ const deleteCharBackward = (view)=>deleteByChar(view, false);\n/**\nDelete the selection or the character after the cursor.\n*/ const deleteCharForward = (view)=>deleteByChar(view, true);\nconst deleteByGroup = (target, forward)=>deleteBy(target, (range)=>{\n        let pos = range.head, { state } = target, line = state.doc.lineAt(pos);\n        let categorize = state.charCategorizer(pos);\n        for(let cat = null;;){\n            if (pos == (forward ? line.to : line.from)) {\n                if (pos == range.head && line.number != (forward ? state.doc.lines : 1)) pos += forward ? 1 : -1;\n                break;\n            }\n            let next = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.findClusterBreak)(line.text, pos - line.from, forward) + line.from;\n            let nextChar = line.text.slice(Math.min(pos, next) - line.from, Math.max(pos, next) - line.from);\n            let nextCat = categorize(nextChar);\n            if (cat != null && nextCat != cat) break;\n            if (nextChar != \" \" || pos != range.head) cat = nextCat;\n            pos = next;\n        }\n        return pos;\n    });\n/**\nDelete the selection or backward until the end of the next\n[group](https://codemirror.net/6/docs/ref/#view.EditorView.moveByGroup), only skipping groups of\nwhitespace when they consist of a single space.\n*/ const deleteGroupBackward = (target)=>deleteByGroup(target, false);\n/**\nDelete the selection or forward until the end of the next group.\n*/ const deleteGroupForward = (target)=>deleteByGroup(target, true);\n/**\nDelete the selection, or, if it is a cursor selection, delete to\nthe end of the line. If the cursor is directly at the end of the\nline, delete the line break after it.\n*/ const deleteToLineEnd = (view)=>deleteBy(view, (range)=>{\n        let lineEnd = view.lineBlockAt(range.head).to;\n        return range.head < lineEnd ? lineEnd : Math.min(view.state.doc.length, range.head + 1);\n    });\n/**\nDelete the selection, or, if it is a cursor selection, delete to\nthe start of the line. If the cursor is directly at the start of the\nline, delete the line break before it.\n*/ const deleteToLineStart = (view)=>deleteBy(view, (range)=>{\n        let lineStart = view.lineBlockAt(range.head).from;\n        return range.head > lineStart ? lineStart : Math.max(0, range.head - 1);\n    });\n/**\nDelete the selection, or, if it is a cursor selection, delete to\nthe start of the line or the next line wrap before the cursor.\n*/ const deleteLineBoundaryBackward = (view)=>deleteBy(view, (range)=>{\n        let lineStart = view.moveToLineBoundary(range, false).head;\n        return range.head > lineStart ? lineStart : Math.max(0, range.head - 1);\n    });\n/**\nDelete the selection, or, if it is a cursor selection, delete to\nthe end of the line or the next line wrap after the cursor.\n*/ const deleteLineBoundaryForward = (view)=>deleteBy(view, (range)=>{\n        let lineStart = view.moveToLineBoundary(range, true).head;\n        return range.head < lineStart ? lineStart : Math.min(view.state.doc.length, range.head + 1);\n    });\n/**\nDelete all whitespace directly before a line end from the\ndocument.\n*/ const deleteTrailingWhitespace = ({ state, dispatch })=>{\n    if (state.readOnly) return false;\n    let changes = [];\n    for(let pos = 0, prev = \"\", iter = state.doc.iter();;){\n        iter.next();\n        if (iter.lineBreak || iter.done) {\n            let trailing = prev.search(/\\s+$/);\n            if (trailing > -1) changes.push({\n                from: pos - (prev.length - trailing),\n                to: pos\n            });\n            if (iter.done) break;\n            prev = \"\";\n        } else {\n            prev = iter.value;\n        }\n        pos += iter.value.length;\n    }\n    if (!changes.length) return false;\n    dispatch(state.update({\n        changes,\n        userEvent: \"delete\"\n    }));\n    return true;\n};\n/**\nReplace each selection range with a line break, leaving the cursor\non the line before the break.\n*/ const splitLine = ({ state, dispatch })=>{\n    if (state.readOnly) return false;\n    let changes = state.changeByRange((range)=>{\n        return {\n            changes: {\n                from: range.from,\n                to: range.to,\n                insert: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Text.of([\n                    \"\",\n                    \"\"\n                ])\n            },\n            range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(range.from)\n        };\n    });\n    dispatch(state.update(changes, {\n        scrollIntoView: true,\n        userEvent: \"input\"\n    }));\n    return true;\n};\n/**\nFlip the characters before and after the cursor(s).\n*/ const transposeChars = ({ state, dispatch })=>{\n    if (state.readOnly) return false;\n    let changes = state.changeByRange((range)=>{\n        if (!range.empty || range.from == 0 || range.from == state.doc.length) return {\n            range\n        };\n        let pos = range.from, line = state.doc.lineAt(pos);\n        let from = pos == line.from ? pos - 1 : (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.findClusterBreak)(line.text, pos - line.from, false) + line.from;\n        let to = pos == line.to ? pos + 1 : (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.findClusterBreak)(line.text, pos - line.from, true) + line.from;\n        return {\n            changes: {\n                from,\n                to,\n                insert: state.doc.slice(pos, to).append(state.doc.slice(from, pos))\n            },\n            range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(to)\n        };\n    });\n    if (changes.changes.empty) return false;\n    dispatch(state.update(changes, {\n        scrollIntoView: true,\n        userEvent: \"move.character\"\n    }));\n    return true;\n};\nfunction selectedLineBlocks(state) {\n    let blocks = [], upto = -1;\n    for (let range of state.selection.ranges){\n        let startLine = state.doc.lineAt(range.from), endLine = state.doc.lineAt(range.to);\n        if (!range.empty && range.to == endLine.from) endLine = state.doc.lineAt(range.to - 1);\n        if (upto >= startLine.number) {\n            let prev = blocks[blocks.length - 1];\n            prev.to = endLine.to;\n            prev.ranges.push(range);\n        } else {\n            blocks.push({\n                from: startLine.from,\n                to: endLine.to,\n                ranges: [\n                    range\n                ]\n            });\n        }\n        upto = endLine.number + 1;\n    }\n    return blocks;\n}\nfunction moveLine(state, dispatch, forward) {\n    if (state.readOnly) return false;\n    let changes = [], ranges = [];\n    for (let block of selectedLineBlocks(state)){\n        if (forward ? block.to == state.doc.length : block.from == 0) continue;\n        let nextLine = state.doc.lineAt(forward ? block.to + 1 : block.from - 1);\n        let size = nextLine.length + 1;\n        if (forward) {\n            changes.push({\n                from: block.to,\n                to: nextLine.to\n            }, {\n                from: block.from,\n                insert: nextLine.text + state.lineBreak\n            });\n            for (let r of block.ranges)ranges.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(Math.min(state.doc.length, r.anchor + size), Math.min(state.doc.length, r.head + size)));\n        } else {\n            changes.push({\n                from: nextLine.from,\n                to: block.from\n            }, {\n                from: block.to,\n                insert: state.lineBreak + nextLine.text\n            });\n            for (let r of block.ranges)ranges.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(r.anchor - size, r.head - size));\n        }\n    }\n    if (!changes.length) return false;\n    dispatch(state.update({\n        changes,\n        scrollIntoView: true,\n        selection: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create(ranges, state.selection.mainIndex),\n        userEvent: \"move.line\"\n    }));\n    return true;\n}\n/**\nMove the selected lines up one line.\n*/ const moveLineUp = ({ state, dispatch })=>moveLine(state, dispatch, false);\n/**\nMove the selected lines down one line.\n*/ const moveLineDown = ({ state, dispatch })=>moveLine(state, dispatch, true);\nfunction copyLine(state, dispatch, forward) {\n    if (state.readOnly) return false;\n    let changes = [];\n    for (let block of selectedLineBlocks(state)){\n        if (forward) changes.push({\n            from: block.from,\n            insert: state.doc.slice(block.from, block.to) + state.lineBreak\n        });\n        else changes.push({\n            from: block.to,\n            insert: state.lineBreak + state.doc.slice(block.from, block.to)\n        });\n    }\n    dispatch(state.update({\n        changes,\n        scrollIntoView: true,\n        userEvent: \"input.copyline\"\n    }));\n    return true;\n}\n/**\nCreate a copy of the selected lines. Keep the selection in the top copy.\n*/ const copyLineUp = ({ state, dispatch })=>copyLine(state, dispatch, false);\n/**\nCreate a copy of the selected lines. Keep the selection in the bottom copy.\n*/ const copyLineDown = ({ state, dispatch })=>copyLine(state, dispatch, true);\n/**\nDelete selected lines.\n*/ const deleteLine = (view)=>{\n    if (view.state.readOnly) return false;\n    let { state } = view, changes = state.changes(selectedLineBlocks(state).map(({ from, to })=>{\n        if (from > 0) from--;\n        else if (to < state.doc.length) to++;\n        return {\n            from,\n            to\n        };\n    }));\n    let selection = updateSel(state.selection, (range)=>view.moveVertically(range, true)).map(changes);\n    view.dispatch({\n        changes,\n        selection,\n        scrollIntoView: true,\n        userEvent: \"delete.line\"\n    });\n    return true;\n};\n/**\nReplace the selection with a newline.\n*/ const insertNewline = ({ state, dispatch })=>{\n    dispatch(state.update(state.replaceSelection(state.lineBreak), {\n        scrollIntoView: true,\n        userEvent: \"input\"\n    }));\n    return true;\n};\nfunction isBetweenBrackets(state, pos) {\n    if (/\\(\\)|\\[\\]|\\{\\}/.test(state.sliceDoc(pos - 1, pos + 1))) return {\n        from: pos,\n        to: pos\n    };\n    let context = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.syntaxTree)(state).resolveInner(pos);\n    let before = context.childBefore(pos), after = context.childAfter(pos), closedBy;\n    if (before && after && before.to <= pos && after.from >= pos && (closedBy = before.type.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.closedBy)) && closedBy.indexOf(after.name) > -1 && state.doc.lineAt(before.to).from == state.doc.lineAt(after.from).from && !/\\S/.test(state.sliceDoc(before.to, after.from))) return {\n        from: before.to,\n        to: after.from\n    };\n    return null;\n}\n/**\nReplace the selection with a newline and indent the newly created\nline(s). If the current line consists only of whitespace, this\nwill also delete that whitespace. When the cursor is between\nmatching brackets, an additional newline will be inserted after\nthe cursor.\n*/ const insertNewlineAndIndent = /*@__PURE__*/ newlineAndIndent(false);\n/**\nCreate a blank, indented line below the current line.\n*/ const insertBlankLine = /*@__PURE__*/ newlineAndIndent(true);\nfunction newlineAndIndent(atEof) {\n    return ({ state, dispatch })=>{\n        if (state.readOnly) return false;\n        let changes = state.changeByRange((range)=>{\n            let { from, to } = range, line = state.doc.lineAt(from);\n            let explode = !atEof && from == to && isBetweenBrackets(state, from);\n            if (atEof) from = to = (to <= line.to ? line : state.doc.lineAt(to)).to;\n            let cx = new _codemirror_language__WEBPACK_IMPORTED_MODULE_3__.IndentContext(state, {\n                simulateBreak: from,\n                simulateDoubleBreak: !!explode\n            });\n            let indent = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.getIndentation)(cx, from);\n            if (indent == null) indent = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.countColumn)(/^\\s*/.exec(state.doc.lineAt(from).text)[0], state.tabSize);\n            while(to < line.to && /\\s/.test(line.text[to - line.from]))to++;\n            if (explode) ({ from, to } = explode);\n            else if (from > line.from && from < line.from + 100 && !/\\S/.test(line.text.slice(0, from))) from = line.from;\n            let insert = [\n                \"\",\n                (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.indentString)(state, indent)\n            ];\n            if (explode) insert.push((0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.indentString)(state, cx.lineIndent(line.from, -1)));\n            return {\n                changes: {\n                    from,\n                    to,\n                    insert: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Text.of(insert)\n                },\n                range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(from + 1 + insert[1].length)\n            };\n        });\n        dispatch(state.update(changes, {\n            scrollIntoView: true,\n            userEvent: \"input\"\n        }));\n        return true;\n    };\n}\nfunction changeBySelectedLine(state, f) {\n    let atLine = -1;\n    return state.changeByRange((range)=>{\n        let changes = [];\n        for(let pos = range.from; pos <= range.to;){\n            let line = state.doc.lineAt(pos);\n            if (line.number > atLine && (range.empty || range.to > line.from)) {\n                f(line, changes, range);\n                atLine = line.number;\n            }\n            pos = line.to + 1;\n        }\n        let changeSet = state.changes(changes);\n        return {\n            changes,\n            range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(changeSet.mapPos(range.anchor, 1), changeSet.mapPos(range.head, 1))\n        };\n    });\n}\n/**\nAuto-indent the selected lines. This uses the [indentation service\nfacet](https://codemirror.net/6/docs/ref/#language.indentService) as source for auto-indent\ninformation.\n*/ const indentSelection = ({ state, dispatch })=>{\n    if (state.readOnly) return false;\n    let updated = Object.create(null);\n    let context = new _codemirror_language__WEBPACK_IMPORTED_MODULE_3__.IndentContext(state, {\n        overrideIndentation: (start)=>{\n            let found = updated[start];\n            return found == null ? -1 : found;\n        }\n    });\n    let changes = changeBySelectedLine(state, (line, changes, range)=>{\n        let indent = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.getIndentation)(context, line.from);\n        if (indent == null) return;\n        if (!/\\S/.test(line.text)) indent = 0;\n        let cur = /^\\s*/.exec(line.text)[0];\n        let norm = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.indentString)(state, indent);\n        if (cur != norm || range.from < line.from + cur.length) {\n            updated[line.from] = indent;\n            changes.push({\n                from: line.from,\n                to: line.from + cur.length,\n                insert: norm\n            });\n        }\n    });\n    if (!changes.changes.empty) dispatch(state.update(changes, {\n        userEvent: \"indent\"\n    }));\n    return true;\n};\n/**\nAdd a [unit](https://codemirror.net/6/docs/ref/#language.indentUnit) of indentation to all selected\nlines.\n*/ const indentMore = ({ state, dispatch })=>{\n    if (state.readOnly) return false;\n    dispatch(state.update(changeBySelectedLine(state, (line, changes)=>{\n        changes.push({\n            from: line.from,\n            insert: state.facet(_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.indentUnit)\n        });\n    }), {\n        userEvent: \"input.indent\"\n    }));\n    return true;\n};\n/**\nRemove a [unit](https://codemirror.net/6/docs/ref/#language.indentUnit) of indentation from all\nselected lines.\n*/ const indentLess = ({ state, dispatch })=>{\n    if (state.readOnly) return false;\n    dispatch(state.update(changeBySelectedLine(state, (line, changes)=>{\n        let space = /^\\s*/.exec(line.text)[0];\n        if (!space) return;\n        let col = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.countColumn)(space, state.tabSize), keep = 0;\n        let insert = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.indentString)(state, Math.max(0, col - (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.getIndentUnit)(state)));\n        while(keep < space.length && keep < insert.length && space.charCodeAt(keep) == insert.charCodeAt(keep))keep++;\n        changes.push({\n            from: line.from + keep,\n            to: line.from + space.length,\n            insert: insert.slice(keep)\n        });\n    }), {\n        userEvent: \"delete.dedent\"\n    }));\n    return true;\n};\n/**\nInsert a tab character at the cursor or, if something is selected,\nuse [`indentMore`](https://codemirror.net/6/docs/ref/#commands.indentMore) to indent the entire\nselection.\n*/ const insertTab = ({ state, dispatch })=>{\n    if (state.selection.ranges.some((r)=>!r.empty)) return indentMore({\n        state,\n        dispatch\n    });\n    dispatch(state.update(state.replaceSelection(\"\t\"), {\n        scrollIntoView: true,\n        userEvent: \"input\"\n    }));\n    return true;\n};\n/**\nArray of key bindings containing the Emacs-style bindings that are\navailable on macOS by default.\n\n - Ctrl-b: [`cursorCharLeft`](https://codemirror.net/6/docs/ref/#commands.cursorCharLeft) ([`selectCharLeft`](https://codemirror.net/6/docs/ref/#commands.selectCharLeft) with Shift)\n - Ctrl-f: [`cursorCharRight`](https://codemirror.net/6/docs/ref/#commands.cursorCharRight) ([`selectCharRight`](https://codemirror.net/6/docs/ref/#commands.selectCharRight) with Shift)\n - Ctrl-p: [`cursorLineUp`](https://codemirror.net/6/docs/ref/#commands.cursorLineUp) ([`selectLineUp`](https://codemirror.net/6/docs/ref/#commands.selectLineUp) with Shift)\n - Ctrl-n: [`cursorLineDown`](https://codemirror.net/6/docs/ref/#commands.cursorLineDown) ([`selectLineDown`](https://codemirror.net/6/docs/ref/#commands.selectLineDown) with Shift)\n - Ctrl-a: [`cursorLineStart`](https://codemirror.net/6/docs/ref/#commands.cursorLineStart) ([`selectLineStart`](https://codemirror.net/6/docs/ref/#commands.selectLineStart) with Shift)\n - Ctrl-e: [`cursorLineEnd`](https://codemirror.net/6/docs/ref/#commands.cursorLineEnd) ([`selectLineEnd`](https://codemirror.net/6/docs/ref/#commands.selectLineEnd) with Shift)\n - Ctrl-d: [`deleteCharForward`](https://codemirror.net/6/docs/ref/#commands.deleteCharForward)\n - Ctrl-h: [`deleteCharBackward`](https://codemirror.net/6/docs/ref/#commands.deleteCharBackward)\n - Ctrl-k: [`deleteToLineEnd`](https://codemirror.net/6/docs/ref/#commands.deleteToLineEnd)\n - Ctrl-Alt-h: [`deleteGroupBackward`](https://codemirror.net/6/docs/ref/#commands.deleteGroupBackward)\n - Ctrl-o: [`splitLine`](https://codemirror.net/6/docs/ref/#commands.splitLine)\n - Ctrl-t: [`transposeChars`](https://codemirror.net/6/docs/ref/#commands.transposeChars)\n - Ctrl-v: [`cursorPageDown`](https://codemirror.net/6/docs/ref/#commands.cursorPageDown)\n - Alt-v: [`cursorPageUp`](https://codemirror.net/6/docs/ref/#commands.cursorPageUp)\n*/ const emacsStyleKeymap = [\n    {\n        key: \"Ctrl-b\",\n        run: cursorCharLeft,\n        shift: selectCharLeft,\n        preventDefault: true\n    },\n    {\n        key: \"Ctrl-f\",\n        run: cursorCharRight,\n        shift: selectCharRight\n    },\n    {\n        key: \"Ctrl-p\",\n        run: cursorLineUp,\n        shift: selectLineUp\n    },\n    {\n        key: \"Ctrl-n\",\n        run: cursorLineDown,\n        shift: selectLineDown\n    },\n    {\n        key: \"Ctrl-a\",\n        run: cursorLineStart,\n        shift: selectLineStart\n    },\n    {\n        key: \"Ctrl-e\",\n        run: cursorLineEnd,\n        shift: selectLineEnd\n    },\n    {\n        key: \"Ctrl-d\",\n        run: deleteCharForward\n    },\n    {\n        key: \"Ctrl-h\",\n        run: deleteCharBackward\n    },\n    {\n        key: \"Ctrl-k\",\n        run: deleteToLineEnd\n    },\n    {\n        key: \"Ctrl-Alt-h\",\n        run: deleteGroupBackward\n    },\n    {\n        key: \"Ctrl-o\",\n        run: splitLine\n    },\n    {\n        key: \"Ctrl-t\",\n        run: transposeChars\n    },\n    {\n        key: \"Ctrl-v\",\n        run: cursorPageDown\n    }\n];\n/**\nAn array of key bindings closely sticking to platform-standard or\nwidely used bindings. (This includes the bindings from\n[`emacsStyleKeymap`](https://codemirror.net/6/docs/ref/#commands.emacsStyleKeymap), with their `key`\nproperty changed to `mac`.)\n\n - ArrowLeft: [`cursorCharLeft`](https://codemirror.net/6/docs/ref/#commands.cursorCharLeft) ([`selectCharLeft`](https://codemirror.net/6/docs/ref/#commands.selectCharLeft) with Shift)\n - ArrowRight: [`cursorCharRight`](https://codemirror.net/6/docs/ref/#commands.cursorCharRight) ([`selectCharRight`](https://codemirror.net/6/docs/ref/#commands.selectCharRight) with Shift)\n - Ctrl-ArrowLeft (Alt-ArrowLeft on macOS): [`cursorGroupLeft`](https://codemirror.net/6/docs/ref/#commands.cursorGroupLeft) ([`selectGroupLeft`](https://codemirror.net/6/docs/ref/#commands.selectGroupLeft) with Shift)\n - Ctrl-ArrowRight (Alt-ArrowRight on macOS): [`cursorGroupRight`](https://codemirror.net/6/docs/ref/#commands.cursorGroupRight) ([`selectGroupRight`](https://codemirror.net/6/docs/ref/#commands.selectGroupRight) with Shift)\n - Cmd-ArrowLeft (on macOS): [`cursorLineStart`](https://codemirror.net/6/docs/ref/#commands.cursorLineStart) ([`selectLineStart`](https://codemirror.net/6/docs/ref/#commands.selectLineStart) with Shift)\n - Cmd-ArrowRight (on macOS): [`cursorLineEnd`](https://codemirror.net/6/docs/ref/#commands.cursorLineEnd) ([`selectLineEnd`](https://codemirror.net/6/docs/ref/#commands.selectLineEnd) with Shift)\n - ArrowUp: [`cursorLineUp`](https://codemirror.net/6/docs/ref/#commands.cursorLineUp) ([`selectLineUp`](https://codemirror.net/6/docs/ref/#commands.selectLineUp) with Shift)\n - ArrowDown: [`cursorLineDown`](https://codemirror.net/6/docs/ref/#commands.cursorLineDown) ([`selectLineDown`](https://codemirror.net/6/docs/ref/#commands.selectLineDown) with Shift)\n - Cmd-ArrowUp (on macOS): [`cursorDocStart`](https://codemirror.net/6/docs/ref/#commands.cursorDocStart) ([`selectDocStart`](https://codemirror.net/6/docs/ref/#commands.selectDocStart) with Shift)\n - Cmd-ArrowDown (on macOS): [`cursorDocEnd`](https://codemirror.net/6/docs/ref/#commands.cursorDocEnd) ([`selectDocEnd`](https://codemirror.net/6/docs/ref/#commands.selectDocEnd) with Shift)\n - Ctrl-ArrowUp (on macOS): [`cursorPageUp`](https://codemirror.net/6/docs/ref/#commands.cursorPageUp) ([`selectPageUp`](https://codemirror.net/6/docs/ref/#commands.selectPageUp) with Shift)\n - Ctrl-ArrowDown (on macOS): [`cursorPageDown`](https://codemirror.net/6/docs/ref/#commands.cursorPageDown) ([`selectPageDown`](https://codemirror.net/6/docs/ref/#commands.selectPageDown) with Shift)\n - PageUp: [`cursorPageUp`](https://codemirror.net/6/docs/ref/#commands.cursorPageUp) ([`selectPageUp`](https://codemirror.net/6/docs/ref/#commands.selectPageUp) with Shift)\n - PageDown: [`cursorPageDown`](https://codemirror.net/6/docs/ref/#commands.cursorPageDown) ([`selectPageDown`](https://codemirror.net/6/docs/ref/#commands.selectPageDown) with Shift)\n - Home: [`cursorLineBoundaryBackward`](https://codemirror.net/6/docs/ref/#commands.cursorLineBoundaryBackward) ([`selectLineBoundaryBackward`](https://codemirror.net/6/docs/ref/#commands.selectLineBoundaryBackward) with Shift)\n - End: [`cursorLineBoundaryForward`](https://codemirror.net/6/docs/ref/#commands.cursorLineBoundaryForward) ([`selectLineBoundaryForward`](https://codemirror.net/6/docs/ref/#commands.selectLineBoundaryForward) with Shift)\n - Ctrl-Home (Cmd-Home on macOS): [`cursorDocStart`](https://codemirror.net/6/docs/ref/#commands.cursorDocStart) ([`selectDocStart`](https://codemirror.net/6/docs/ref/#commands.selectDocStart) with Shift)\n - Ctrl-End (Cmd-Home on macOS): [`cursorDocEnd`](https://codemirror.net/6/docs/ref/#commands.cursorDocEnd) ([`selectDocEnd`](https://codemirror.net/6/docs/ref/#commands.selectDocEnd) with Shift)\n - Enter: [`insertNewlineAndIndent`](https://codemirror.net/6/docs/ref/#commands.insertNewlineAndIndent)\n - Ctrl-a (Cmd-a on macOS): [`selectAll`](https://codemirror.net/6/docs/ref/#commands.selectAll)\n - Backspace: [`deleteCharBackward`](https://codemirror.net/6/docs/ref/#commands.deleteCharBackward)\n - Delete: [`deleteCharForward`](https://codemirror.net/6/docs/ref/#commands.deleteCharForward)\n - Ctrl-Backspace (Alt-Backspace on macOS): [`deleteGroupBackward`](https://codemirror.net/6/docs/ref/#commands.deleteGroupBackward)\n - Ctrl-Delete (Alt-Delete on macOS): [`deleteGroupForward`](https://codemirror.net/6/docs/ref/#commands.deleteGroupForward)\n - Cmd-Backspace (macOS): [`deleteLineBoundaryBackward`](https://codemirror.net/6/docs/ref/#commands.deleteLineBoundaryBackward).\n - Cmd-Delete (macOS): [`deleteLineBoundaryForward`](https://codemirror.net/6/docs/ref/#commands.deleteLineBoundaryForward).\n*/ const standardKeymap = /*@__PURE__*/ [\n    {\n        key: \"ArrowLeft\",\n        run: cursorCharLeft,\n        shift: selectCharLeft,\n        preventDefault: true\n    },\n    {\n        key: \"Mod-ArrowLeft\",\n        mac: \"Alt-ArrowLeft\",\n        run: cursorGroupLeft,\n        shift: selectGroupLeft,\n        preventDefault: true\n    },\n    {\n        mac: \"Cmd-ArrowLeft\",\n        run: cursorLineBoundaryLeft,\n        shift: selectLineBoundaryLeft,\n        preventDefault: true\n    },\n    {\n        key: \"ArrowRight\",\n        run: cursorCharRight,\n        shift: selectCharRight,\n        preventDefault: true\n    },\n    {\n        key: \"Mod-ArrowRight\",\n        mac: \"Alt-ArrowRight\",\n        run: cursorGroupRight,\n        shift: selectGroupRight,\n        preventDefault: true\n    },\n    {\n        mac: \"Cmd-ArrowRight\",\n        run: cursorLineBoundaryRight,\n        shift: selectLineBoundaryRight,\n        preventDefault: true\n    },\n    {\n        key: \"ArrowUp\",\n        run: cursorLineUp,\n        shift: selectLineUp,\n        preventDefault: true\n    },\n    {\n        mac: \"Cmd-ArrowUp\",\n        run: cursorDocStart,\n        shift: selectDocStart\n    },\n    {\n        mac: \"Ctrl-ArrowUp\",\n        run: cursorPageUp,\n        shift: selectPageUp\n    },\n    {\n        key: \"ArrowDown\",\n        run: cursorLineDown,\n        shift: selectLineDown,\n        preventDefault: true\n    },\n    {\n        mac: \"Cmd-ArrowDown\",\n        run: cursorDocEnd,\n        shift: selectDocEnd\n    },\n    {\n        mac: \"Ctrl-ArrowDown\",\n        run: cursorPageDown,\n        shift: selectPageDown\n    },\n    {\n        key: \"PageUp\",\n        run: cursorPageUp,\n        shift: selectPageUp\n    },\n    {\n        key: \"PageDown\",\n        run: cursorPageDown,\n        shift: selectPageDown\n    },\n    {\n        key: \"Home\",\n        run: cursorLineBoundaryBackward,\n        shift: selectLineBoundaryBackward,\n        preventDefault: true\n    },\n    {\n        key: \"Mod-Home\",\n        run: cursorDocStart,\n        shift: selectDocStart\n    },\n    {\n        key: \"End\",\n        run: cursorLineBoundaryForward,\n        shift: selectLineBoundaryForward,\n        preventDefault: true\n    },\n    {\n        key: \"Mod-End\",\n        run: cursorDocEnd,\n        shift: selectDocEnd\n    },\n    {\n        key: \"Enter\",\n        run: insertNewlineAndIndent\n    },\n    {\n        key: \"Mod-a\",\n        run: selectAll\n    },\n    {\n        key: \"Backspace\",\n        run: deleteCharBackward,\n        shift: deleteCharBackward\n    },\n    {\n        key: \"Delete\",\n        run: deleteCharForward\n    },\n    {\n        key: \"Mod-Backspace\",\n        mac: \"Alt-Backspace\",\n        run: deleteGroupBackward\n    },\n    {\n        key: \"Mod-Delete\",\n        mac: \"Alt-Delete\",\n        run: deleteGroupForward\n    },\n    {\n        mac: \"Mod-Backspace\",\n        run: deleteLineBoundaryBackward\n    },\n    {\n        mac: \"Mod-Delete\",\n        run: deleteLineBoundaryForward\n    }\n].concat(/*@__PURE__*/ emacsStyleKeymap.map((b)=>({\n        mac: b.key,\n        run: b.run,\n        shift: b.shift\n    })));\n/**\nThe default keymap. Includes all bindings from\n[`standardKeymap`](https://codemirror.net/6/docs/ref/#commands.standardKeymap) plus the following:\n\n- Alt-ArrowLeft (Ctrl-ArrowLeft on macOS): [`cursorSyntaxLeft`](https://codemirror.net/6/docs/ref/#commands.cursorSyntaxLeft) ([`selectSyntaxLeft`](https://codemirror.net/6/docs/ref/#commands.selectSyntaxLeft) with Shift)\n- Alt-ArrowRight (Ctrl-ArrowRight on macOS): [`cursorSyntaxRight`](https://codemirror.net/6/docs/ref/#commands.cursorSyntaxRight) ([`selectSyntaxRight`](https://codemirror.net/6/docs/ref/#commands.selectSyntaxRight) with Shift)\n- Alt-ArrowUp: [`moveLineUp`](https://codemirror.net/6/docs/ref/#commands.moveLineUp)\n- Alt-ArrowDown: [`moveLineDown`](https://codemirror.net/6/docs/ref/#commands.moveLineDown)\n- Shift-Alt-ArrowUp: [`copyLineUp`](https://codemirror.net/6/docs/ref/#commands.copyLineUp)\n- Shift-Alt-ArrowDown: [`copyLineDown`](https://codemirror.net/6/docs/ref/#commands.copyLineDown)\n- Escape: [`simplifySelection`](https://codemirror.net/6/docs/ref/#commands.simplifySelection)\n- Ctrl-Enter (Cmd-Enter on macOS): [`insertBlankLine`](https://codemirror.net/6/docs/ref/#commands.insertBlankLine)\n- Alt-l (Ctrl-l on macOS): [`selectLine`](https://codemirror.net/6/docs/ref/#commands.selectLine)\n- Ctrl-i (Cmd-i on macOS): [`selectParentSyntax`](https://codemirror.net/6/docs/ref/#commands.selectParentSyntax)\n- Ctrl-[ (Cmd-[ on macOS): [`indentLess`](https://codemirror.net/6/docs/ref/#commands.indentLess)\n- Ctrl-] (Cmd-] on macOS): [`indentMore`](https://codemirror.net/6/docs/ref/#commands.indentMore)\n- Ctrl-Alt-\\\\ (Cmd-Alt-\\\\ on macOS): [`indentSelection`](https://codemirror.net/6/docs/ref/#commands.indentSelection)\n- Shift-Ctrl-k (Shift-Cmd-k on macOS): [`deleteLine`](https://codemirror.net/6/docs/ref/#commands.deleteLine)\n- Shift-Ctrl-\\\\ (Shift-Cmd-\\\\ on macOS): [`cursorMatchingBracket`](https://codemirror.net/6/docs/ref/#commands.cursorMatchingBracket)\n- Ctrl-/ (Cmd-/ on macOS): [`toggleComment`](https://codemirror.net/6/docs/ref/#commands.toggleComment).\n- Shift-Alt-a: [`toggleBlockComment`](https://codemirror.net/6/docs/ref/#commands.toggleBlockComment).\n*/ const defaultKeymap = /*@__PURE__*/ [\n    {\n        key: \"Alt-ArrowLeft\",\n        mac: \"Ctrl-ArrowLeft\",\n        run: cursorSyntaxLeft,\n        shift: selectSyntaxLeft\n    },\n    {\n        key: \"Alt-ArrowRight\",\n        mac: \"Ctrl-ArrowRight\",\n        run: cursorSyntaxRight,\n        shift: selectSyntaxRight\n    },\n    {\n        key: \"Alt-ArrowUp\",\n        run: moveLineUp\n    },\n    {\n        key: \"Shift-Alt-ArrowUp\",\n        run: copyLineUp\n    },\n    {\n        key: \"Alt-ArrowDown\",\n        run: moveLineDown\n    },\n    {\n        key: \"Shift-Alt-ArrowDown\",\n        run: copyLineDown\n    },\n    {\n        key: \"Escape\",\n        run: simplifySelection\n    },\n    {\n        key: \"Mod-Enter\",\n        run: insertBlankLine\n    },\n    {\n        key: \"Alt-l\",\n        mac: \"Ctrl-l\",\n        run: selectLine\n    },\n    {\n        key: \"Mod-i\",\n        run: selectParentSyntax,\n        preventDefault: true\n    },\n    {\n        key: \"Mod-[\",\n        run: indentLess\n    },\n    {\n        key: \"Mod-]\",\n        run: indentMore\n    },\n    {\n        key: \"Mod-Alt-\\\\\",\n        run: indentSelection\n    },\n    {\n        key: \"Shift-Mod-k\",\n        run: deleteLine\n    },\n    {\n        key: \"Shift-Mod-\\\\\",\n        run: cursorMatchingBracket\n    },\n    {\n        key: \"Mod-/\",\n        run: toggleComment\n    },\n    {\n        key: \"Alt-A\",\n        run: toggleBlockComment\n    }\n].concat(standardKeymap);\n/**\nA binding that binds Tab to [`indentMore`](https://codemirror.net/6/docs/ref/#commands.indentMore) and\nShift-Tab to [`indentLess`](https://codemirror.net/6/docs/ref/#commands.indentLess).\nPlease see the [Tab example](../../examples/tab/) before using\nthis.\n*/ const indentWithTab = {\n    key: \"Tab\",\n    run: indentMore,\n    shift: indentLess\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvY29tbWFuZHMvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFzTTtBQUM3STtBQUNnRjtBQUNoRztBQUV6Qzs7O0FBR0EsR0FDQSxNQUFNdUIsZ0JBQWdCQyxDQUFBQTtJQUNsQixJQUFJLEVBQUVDLEtBQUssRUFBRSxHQUFHRCxRQUFRRSxPQUFPRCxNQUFNRSxHQUFHLENBQUNDLE1BQU0sQ0FBQ0gsTUFBTUksU0FBUyxDQUFDQyxJQUFJLENBQUNDLElBQUksR0FBR0MsU0FBU0MsVUFBVVQsT0FBT0MsS0FBSyxFQUFFQyxLQUFLSyxJQUFJO0lBQ3RILE9BQU9DLE9BQU9OLElBQUksR0FBR1Esa0JBQWtCVixVQUFVUSxPQUFPRyxLQUFLLEdBQUdDLHlCQUF5QlosVUFBVTtBQUN2RztBQUNBLFNBQVNhLFFBQVFDLENBQUMsRUFBRUMsTUFBTTtJQUN0QixPQUFPLENBQUMsRUFBRWQsS0FBSyxFQUFFZSxRQUFRLEVBQUU7UUFDdkIsSUFBSWYsTUFBTWdCLFFBQVEsRUFDZCxPQUFPO1FBQ1gsSUFBSUMsS0FBS0osRUFBRUMsUUFBUWQ7UUFDbkIsSUFBSSxDQUFDaUIsSUFDRCxPQUFPO1FBQ1hGLFNBQVNmLE1BQU1rQixNQUFNLENBQUNEO1FBQ3RCLE9BQU87SUFDWDtBQUNKO0FBQ0E7Ozs7O0FBS0EsR0FDQSxNQUFNUixvQkFBb0IsV0FBVyxHQUFFRyxRQUFRTyxtQkFBbUIsRUFBRSx3QkFBd0I7QUFDNUY7O0FBRUEsR0FDQSxNQUFNQyxjQUFjLFdBQVcsR0FBRVIsUUFBUU8sbUJBQW1CLEVBQUUseUJBQXlCO0FBQ3ZGOztBQUVBLEdBQ0EsTUFBTUUsZ0JBQWdCLFdBQVcsR0FBRVQsUUFBUU8sbUJBQW1CLEVBQUUs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QSxNQUFNRSxnQkFBZ0I7SUFBRTlQLEtBQUs7SUFBT0MsS0FBS3FQO0lBQVlLLE9BQU9KO0FBQVc7QUFFNHBEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHl0aG9uLW9ubGluZS1lZGl0b3IvLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvY29tbWFuZHMvZGlzdC9pbmRleC5qcz9iZjJiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFubm90YXRpb24sIEZhY2V0LCBjb21iaW5lQ29uZmlnLCBTdGF0ZUZpZWxkLCBUcmFuc2FjdGlvbiwgQ2hhbmdlU2V0LCBDaGFuZ2VEZXNjLCBFZGl0b3JTZWxlY3Rpb24sIFN0YXRlRWZmZWN0LCBUZXh0LCBmaW5kQ2x1c3RlckJyZWFrLCBjb3VudENvbHVtbiwgQ2hhckNhdGVnb3J5IH0gZnJvbSAnQGNvZGVtaXJyb3Ivc3RhdGUnO1xuaW1wb3J0IHsgRWRpdG9yVmlldywgRGlyZWN0aW9uIH0gZnJvbSAnQGNvZGVtaXJyb3Ivdmlldyc7XG5pbXBvcnQgeyBJbmRlbnRDb250ZXh0LCBnZXRJbmRlbnRhdGlvbiwgaW5kZW50U3RyaW5nLCBtYXRjaEJyYWNrZXRzLCBzeW50YXhUcmVlLCBnZXRJbmRlbnRVbml0LCBpbmRlbnRVbml0IH0gZnJvbSAnQGNvZGVtaXJyb3IvbGFuZ3VhZ2UnO1xuaW1wb3J0IHsgTm9kZVByb3AgfSBmcm9tICdAbGV6ZXIvY29tbW9uJztcblxuLyoqXG5Db21tZW50IG9yIHVuY29tbWVudCB0aGUgY3VycmVudCBzZWxlY3Rpb24uIFdpbGwgdXNlIGxpbmUgY29tbWVudHNcbmlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIGZhbGxpbmcgYmFjayB0byBibG9jayBjb21tZW50cy5cbiovXG5jb25zdCB0b2dnbGVDb21tZW50ID0gdGFyZ2V0ID0+IHtcbiAgICBsZXQgeyBzdGF0ZSB9ID0gdGFyZ2V0LCBsaW5lID0gc3RhdGUuZG9jLmxpbmVBdChzdGF0ZS5zZWxlY3Rpb24ubWFpbi5mcm9tKSwgY29uZmlnID0gZ2V0Q29uZmlnKHRhcmdldC5zdGF0ZSwgbGluZS5mcm9tKTtcbiAgICByZXR1cm4gY29uZmlnLmxpbmUgPyB0b2dnbGVMaW5lQ29tbWVudCh0YXJnZXQpIDogY29uZmlnLmJsb2NrID8gdG9nZ2xlQmxvY2tDb21tZW50QnlMaW5lKHRhcmdldCkgOiBmYWxzZTtcbn07XG5mdW5jdGlvbiBjb21tYW5kKGYsIG9wdGlvbikge1xuICAgIHJldHVybiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgICAgICBpZiAoc3RhdGUucmVhZE9ubHkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCB0ciA9IGYob3B0aW9uLCBzdGF0ZSk7XG4gICAgICAgIGlmICghdHIpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZSh0cikpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuLyoqXG5Db21tZW50IG9yIHVuY29tbWVudCB0aGUgY3VycmVudCBzZWxlY3Rpb24gdXNpbmcgbGluZSBjb21tZW50cy5cblRoZSBsaW5lIGNvbW1lbnQgc3ludGF4IGlzIHRha2VuIGZyb20gdGhlXG5bYGNvbW1lbnRUb2tlbnNgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLkNvbW1lbnRUb2tlbnMpIFtsYW5ndWFnZVxuZGF0YV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5sYW5ndWFnZURhdGFBdCkuXG4qL1xuY29uc3QgdG9nZ2xlTGluZUNvbW1lbnQgPSAvKkBfX1BVUkVfXyovY29tbWFuZChjaGFuZ2VMaW5lQ29tbWVudCwgMCAvKiBDb21tZW50T3B0aW9uLlRvZ2dsZSAqLyk7XG4vKipcbkNvbW1lbnQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIHVzaW5nIGxpbmUgY29tbWVudHMuXG4qL1xuY29uc3QgbGluZUNvbW1lbnQgPSAvKkBfX1BVUkVfXyovY29tbWFuZChjaGFuZ2VMaW5lQ29tbWVudCwgMSAvKiBDb21tZW50T3B0aW9uLkNvbW1lbnQgKi8pO1xuLyoqXG5VbmNvbW1lbnQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIHVzaW5nIGxpbmUgY29tbWVudHMuXG4qL1xuY29uc3QgbGluZVVuY29tbWVudCA9IC8qQF9fUFVSRV9fKi9jb21tYW5kKGNoYW5nZUxpbmVDb21tZW50LCAyIC8qIENvbW1lbnRPcHRpb24uVW5jb21tZW50ICovKTtcbi8qKlxuQ29tbWVudCBvciB1bmNvbW1lbnQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIHVzaW5nIGJsb2NrIGNvbW1lbnRzLlxuVGhlIGJsb2NrIGNvbW1lbnQgc3ludGF4IGlzIHRha2VuIGZyb20gdGhlXG5bYGNvbW1lbnRUb2tlbnNgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLkNvbW1lbnRUb2tlbnMpIFtsYW5ndWFnZVxuZGF0YV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5sYW5ndWFnZURhdGFBdCkuXG4qL1xuY29uc3QgdG9nZ2xlQmxvY2tDb21tZW50ID0gLypAX19QVVJFX18qL2NvbW1hbmQoY2hhbmdlQmxvY2tDb21tZW50LCAwIC8qIENvbW1lbnRPcHRpb24uVG9nZ2xlICovKTtcbi8qKlxuQ29tbWVudCB0aGUgY3VycmVudCBzZWxlY3Rpb24gdXNpbmcgYmxvY2sgY29tbWVudHMuXG4qL1xuY29uc3QgYmxvY2tDb21tZW50ID0gLypAX19QVVJFX18qL2NvbW1hbmQoY2hhbmdlQmxvY2tDb21tZW50LCAxIC8qIENvbW1lbnRPcHRpb24uQ29tbWVudCAqLyk7XG4vKipcblVuY29tbWVudCB0aGUgY3VycmVudCBzZWxlY3Rpb24gdXNpbmcgYmxvY2sgY29tbWVudHMuXG4qL1xuY29uc3QgYmxvY2tVbmNvbW1lbnQgPSAvKkBfX1BVUkVfXyovY29tbWFuZChjaGFuZ2VCbG9ja0NvbW1lbnQsIDIgLyogQ29tbWVudE9wdGlvbi5VbmNvbW1lbnQgKi8pO1xuLyoqXG5Db21tZW50IG9yIHVuY29tbWVudCB0aGUgbGluZXMgYXJvdW5kIHRoZSBjdXJyZW50IHNlbGVjdGlvbiB1c2luZ1xuYmxvY2sgY29tbWVudHMuXG4qL1xuY29uc3QgdG9nZ2xlQmxvY2tDb21tZW50QnlMaW5lID0gLypAX19QVVJFX18qL2NvbW1hbmQoKG8sIHMpID0+IGNoYW5nZUJsb2NrQ29tbWVudChvLCBzLCBzZWxlY3RlZExpbmVSYW5nZXMocykpLCAwIC8qIENvbW1lbnRPcHRpb24uVG9nZ2xlICovKTtcbmZ1bmN0aW9uIGdldENvbmZpZyhzdGF0ZSwgcG9zKSB7XG4gICAgbGV0IGRhdGEgPSBzdGF0ZS5sYW5ndWFnZURhdGFBdChcImNvbW1lbnRUb2tlbnNcIiwgcG9zKTtcbiAgICByZXR1cm4gZGF0YS5sZW5ndGggPyBkYXRhWzBdIDoge307XG59XG5jb25zdCBTZWFyY2hNYXJnaW4gPSA1MDtcbi8qKlxuRGV0ZXJtaW5lcyBpZiB0aGUgZ2l2ZW4gcmFuZ2UgaXMgYmxvY2stY29tbWVudGVkIGluIHRoZSBnaXZlblxuc3RhdGUuXG4qL1xuZnVuY3Rpb24gZmluZEJsb2NrQ29tbWVudChzdGF0ZSwgeyBvcGVuLCBjbG9zZSB9LCBmcm9tLCB0bykge1xuICAgIGxldCB0ZXh0QmVmb3JlID0gc3RhdGUuc2xpY2VEb2MoZnJvbSAtIFNlYXJjaE1hcmdpbiwgZnJvbSk7XG4gICAgbGV0IHRleHRBZnRlciA9IHN0YXRlLnNsaWNlRG9jKHRvLCB0byArIFNlYXJjaE1hcmdpbik7XG4gICAgbGV0IHNwYWNlQmVmb3JlID0gL1xccyokLy5leGVjKHRleHRCZWZvcmUpWzBdLmxlbmd0aCwgc3BhY2VBZnRlciA9IC9eXFxzKi8uZXhlYyh0ZXh0QWZ0ZXIpWzBdLmxlbmd0aDtcbiAgICBsZXQgYmVmb3JlT2ZmID0gdGV4dEJlZm9yZS5sZW5ndGggLSBzcGFjZUJlZm9yZTtcbiAgICBpZiAodGV4dEJlZm9yZS5zbGljZShiZWZvcmVPZmYgLSBvcGVuLmxlbmd0aCwgYmVmb3JlT2ZmKSA9PSBvcGVuICYmXG4gICAgICAgIHRleHRBZnRlci5zbGljZShzcGFjZUFmdGVyLCBzcGFjZUFmdGVyICsgY2xvc2UubGVuZ3RoKSA9PSBjbG9zZSkge1xuICAgICAgICByZXR1cm4geyBvcGVuOiB7IHBvczogZnJvbSAtIHNwYWNlQmVmb3JlLCBtYXJnaW46IHNwYWNlQmVmb3JlICYmIDEgfSxcbiAgICAgICAgICAgIGNsb3NlOiB7IHBvczogdG8gKyBzcGFjZUFmdGVyLCBtYXJnaW46IHNwYWNlQWZ0ZXIgJiYgMSB9IH07XG4gICAgfVxuICAgIGxldCBzdGFydFRleHQsIGVuZFRleHQ7XG4gICAgaWYgKHRvIC0gZnJvbSA8PSAyICogU2VhcmNoTWFyZ2luKSB7XG4gICAgICAgIHN0YXJ0VGV4dCA9IGVuZFRleHQgPSBzdGF0ZS5zbGljZURvYyhmcm9tLCB0byk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzdGFydFRleHQgPSBzdGF0ZS5zbGljZURvYyhmcm9tLCBmcm9tICsgU2VhcmNoTWFyZ2luKTtcbiAgICAgICAgZW5kVGV4dCA9IHN0YXRlLnNsaWNlRG9jKHRvIC0gU2VhcmNoTWFyZ2luLCB0byk7XG4gICAgfVxuICAgIGxldCBzdGFydFNwYWNlID0gL15cXHMqLy5leGVjKHN0YXJ0VGV4dClbMF0ubGVuZ3RoLCBlbmRTcGFjZSA9IC9cXHMqJC8uZXhlYyhlbmRUZXh0KVswXS5sZW5ndGg7XG4gICAgbGV0IGVuZE9mZiA9IGVuZFRleHQubGVuZ3RoIC0gZW5kU3BhY2UgLSBjbG9zZS5sZW5ndGg7XG4gICAgaWYgKHN0YXJ0VGV4dC5zbGljZShzdGFydFNwYWNlLCBzdGFydFNwYWNlICsgb3Blbi5sZW5ndGgpID09IG9wZW4gJiZcbiAgICAgICAgZW5kVGV4dC5zbGljZShlbmRPZmYsIGVuZE9mZiArIGNsb3NlLmxlbmd0aCkgPT0gY2xvc2UpIHtcbiAgICAgICAgcmV0dXJuIHsgb3BlbjogeyBwb3M6IGZyb20gKyBzdGFydFNwYWNlICsgb3Blbi5sZW5ndGgsXG4gICAgICAgICAgICAgICAgbWFyZ2luOiAvXFxzLy50ZXN0KHN0YXJ0VGV4dC5jaGFyQXQoc3RhcnRTcGFjZSArIG9wZW4ubGVuZ3RoKSkgPyAxIDogMCB9LFxuICAgICAgICAgICAgY2xvc2U6IHsgcG9zOiB0byAtIGVuZFNwYWNlIC0gY2xvc2UubGVuZ3RoLFxuICAgICAgICAgICAgICAgIG1hcmdpbjogL1xccy8udGVzdChlbmRUZXh0LmNoYXJBdChlbmRPZmYgLSAxKSkgPyAxIDogMCB9IH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gc2VsZWN0ZWRMaW5lUmFuZ2VzKHN0YXRlKSB7XG4gICAgbGV0IHJhbmdlcyA9IFtdO1xuICAgIGZvciAobGV0IHIgb2Ygc3RhdGUuc2VsZWN0aW9uLnJhbmdlcykge1xuICAgICAgICBsZXQgZnJvbUxpbmUgPSBzdGF0ZS5kb2MubGluZUF0KHIuZnJvbSk7XG4gICAgICAgIGxldCB0b0xpbmUgPSByLnRvIDw9IGZyb21MaW5lLnRvID8gZnJvbUxpbmUgOiBzdGF0ZS5kb2MubGluZUF0KHIudG8pO1xuICAgICAgICBsZXQgbGFzdCA9IHJhbmdlcy5sZW5ndGggLSAxO1xuICAgICAgICBpZiAobGFzdCA+PSAwICYmIHJhbmdlc1tsYXN0XS50byA+IGZyb21MaW5lLmZyb20pXG4gICAgICAgICAgICByYW5nZXNbbGFzdF0udG8gPSB0b0xpbmUudG87XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJhbmdlcy5wdXNoKHsgZnJvbTogZnJvbUxpbmUuZnJvbSArIC9eXFxzKi8uZXhlYyhmcm9tTGluZS50ZXh0KVswXS5sZW5ndGgsIHRvOiB0b0xpbmUudG8gfSk7XG4gICAgfVxuICAgIHJldHVybiByYW5nZXM7XG59XG4vLyBQZXJmb3JtcyB0b2dnbGUsIGNvbW1lbnQgYW5kIHVuY29tbWVudCBvZiBibG9jayBjb21tZW50cyBpblxuLy8gbGFuZ3VhZ2VzIHRoYXQgc3VwcG9ydCB0aGVtLlxuZnVuY3Rpb24gY2hhbmdlQmxvY2tDb21tZW50KG9wdGlvbiwgc3RhdGUsIHJhbmdlcyA9IHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMpIHtcbiAgICBsZXQgdG9rZW5zID0gcmFuZ2VzLm1hcChyID0+IGdldENvbmZpZyhzdGF0ZSwgci5mcm9tKS5ibG9jayk7XG4gICAgaWYgKCF0b2tlbnMuZXZlcnkoYyA9PiBjKSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IGNvbW1lbnRzID0gcmFuZ2VzLm1hcCgociwgaSkgPT4gZmluZEJsb2NrQ29tbWVudChzdGF0ZSwgdG9rZW5zW2ldLCByLmZyb20sIHIudG8pKTtcbiAgICBpZiAob3B0aW9uICE9IDIgLyogQ29tbWVudE9wdGlvbi5VbmNvbW1lbnQgKi8gJiYgIWNvbW1lbnRzLmV2ZXJ5KGMgPT4gYykpIHtcbiAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogc3RhdGUuY2hhbmdlcyhyYW5nZXMubWFwKChyYW5nZSwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChjb21tZW50c1tpXSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICAgIHJldHVybiBbeyBmcm9tOiByYW5nZS5mcm9tLCBpbnNlcnQ6IHRva2Vuc1tpXS5vcGVuICsgXCIgXCIgfSwgeyBmcm9tOiByYW5nZS50bywgaW5zZXJ0OiBcIiBcIiArIHRva2Vuc1tpXS5jbG9zZSB9XTtcbiAgICAgICAgICAgIH0pKSB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChvcHRpb24gIT0gMSAvKiBDb21tZW50T3B0aW9uLkNvbW1lbnQgKi8gJiYgY29tbWVudHMuc29tZShjID0+IGMpKSB7XG4gICAgICAgIGxldCBjaGFuZ2VzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBjb21tZW50OyBpIDwgY29tbWVudHMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoY29tbWVudCA9IGNvbW1lbnRzW2ldKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRva2VuID0gdG9rZW5zW2ldLCB7IG9wZW4sIGNsb3NlIH0gPSBjb21tZW50O1xuICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7IGZyb206IG9wZW4ucG9zIC0gdG9rZW4ub3Blbi5sZW5ndGgsIHRvOiBvcGVuLnBvcyArIG9wZW4ubWFyZ2luIH0sIHsgZnJvbTogY2xvc2UucG9zIC0gY2xvc2UubWFyZ2luLCB0bzogY2xvc2UucG9zICsgdG9rZW4uY2xvc2UubGVuZ3RoIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBjaGFuZ2VzIH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuLy8gUGVyZm9ybXMgdG9nZ2xlLCBjb21tZW50IGFuZCB1bmNvbW1lbnQgb2YgbGluZSBjb21tZW50cy5cbmZ1bmN0aW9uIGNoYW5nZUxpbmVDb21tZW50KG9wdGlvbiwgc3RhdGUsIHJhbmdlcyA9IHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMpIHtcbiAgICBsZXQgbGluZXMgPSBbXTtcbiAgICBsZXQgcHJldkxpbmUgPSAtMTtcbiAgICBmb3IgKGxldCB7IGZyb20sIHRvIH0gb2YgcmFuZ2VzKSB7XG4gICAgICAgIGxldCBzdGFydEkgPSBsaW5lcy5sZW5ndGgsIG1pbkluZGVudCA9IDFlOTtcbiAgICAgICAgbGV0IHRva2VuID0gZ2V0Q29uZmlnKHN0YXRlLCBmcm9tKS5saW5lO1xuICAgICAgICBpZiAoIXRva2VuKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IGZyb207IHBvcyA8PSB0bzspIHtcbiAgICAgICAgICAgIGxldCBsaW5lID0gc3RhdGUuZG9jLmxpbmVBdChwb3MpO1xuICAgICAgICAgICAgaWYgKGxpbmUuZnJvbSA+IHByZXZMaW5lICYmIChmcm9tID09IHRvIHx8IHRvID4gbGluZS5mcm9tKSkge1xuICAgICAgICAgICAgICAgIHByZXZMaW5lID0gbGluZS5mcm9tO1xuICAgICAgICAgICAgICAgIGxldCBpbmRlbnQgPSAvXlxccyovLmV4ZWMobGluZS50ZXh0KVswXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgbGV0IGVtcHR5ID0gaW5kZW50ID09IGxpbmUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGxldCBjb21tZW50ID0gbGluZS50ZXh0LnNsaWNlKGluZGVudCwgaW5kZW50ICsgdG9rZW4ubGVuZ3RoKSA9PSB0b2tlbiA/IGluZGVudCA6IC0xO1xuICAgICAgICAgICAgICAgIGlmIChpbmRlbnQgPCBsaW5lLnRleHQubGVuZ3RoICYmIGluZGVudCA8IG1pbkluZGVudClcbiAgICAgICAgICAgICAgICAgICAgbWluSW5kZW50ID0gaW5kZW50O1xuICAgICAgICAgICAgICAgIGxpbmVzLnB1c2goeyBsaW5lLCBjb21tZW50LCB0b2tlbiwgaW5kZW50LCBlbXB0eSwgc2luZ2xlOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcyA9IGxpbmUudG8gKyAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtaW5JbmRlbnQgPCAxZTkpXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gc3RhcnRJOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgaWYgKGxpbmVzW2ldLmluZGVudCA8IGxpbmVzW2ldLmxpbmUudGV4dC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIGxpbmVzW2ldLmluZGVudCA9IG1pbkluZGVudDtcbiAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCA9PSBzdGFydEkgKyAxKVxuICAgICAgICAgICAgbGluZXNbc3RhcnRJXS5zaW5nbGUgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAob3B0aW9uICE9IDIgLyogQ29tbWVudE9wdGlvbi5VbmNvbW1lbnQgKi8gJiYgbGluZXMuc29tZShsID0+IGwuY29tbWVudCA8IDAgJiYgKCFsLmVtcHR5IHx8IGwuc2luZ2xlKSkpIHtcbiAgICAgICAgbGV0IGNoYW5nZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgeyBsaW5lLCB0b2tlbiwgaW5kZW50LCBlbXB0eSwgc2luZ2xlIH0gb2YgbGluZXMpXG4gICAgICAgICAgICBpZiAoc2luZ2xlIHx8ICFlbXB0eSlcbiAgICAgICAgICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tOiBsaW5lLmZyb20gKyBpbmRlbnQsIGluc2VydDogdG9rZW4gKyBcIiBcIiB9KTtcbiAgICAgICAgbGV0IGNoYW5nZVNldCA9IHN0YXRlLmNoYW5nZXMoY2hhbmdlcyk7XG4gICAgICAgIHJldHVybiB7IGNoYW5nZXM6IGNoYW5nZVNldCwgc2VsZWN0aW9uOiBzdGF0ZS5zZWxlY3Rpb24ubWFwKGNoYW5nZVNldCwgMSkgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAob3B0aW9uICE9IDEgLyogQ29tbWVudE9wdGlvbi5Db21tZW50ICovICYmIGxpbmVzLnNvbWUobCA9PiBsLmNvbW1lbnQgPj0gMCkpIHtcbiAgICAgICAgbGV0IGNoYW5nZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgeyBsaW5lLCBjb21tZW50LCB0b2tlbiB9IG9mIGxpbmVzKVxuICAgICAgICAgICAgaWYgKGNvbW1lbnQgPj0gMCkge1xuICAgICAgICAgICAgICAgIGxldCBmcm9tID0gbGluZS5mcm9tICsgY29tbWVudCwgdG8gPSBmcm9tICsgdG9rZW4ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChsaW5lLnRleHRbdG8gLSBsaW5lLmZyb21dID09IFwiIFwiKVxuICAgICAgICAgICAgICAgICAgICB0bysrO1xuICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7IGZyb20sIHRvIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBjaGFuZ2VzIH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG5jb25zdCBmcm9tSGlzdG9yeSA9IC8qQF9fUFVSRV9fKi9Bbm5vdGF0aW9uLmRlZmluZSgpO1xuLyoqXG5UcmFuc2FjdGlvbiBhbm5vdGF0aW9uIHRoYXQgd2lsbCBwcmV2ZW50IHRoYXQgdHJhbnNhY3Rpb24gZnJvbVxuYmVpbmcgY29tYmluZWQgd2l0aCBvdGhlciB0cmFuc2FjdGlvbnMgaW4gdGhlIHVuZG8gaGlzdG9yeS4gR2l2ZW5cbmBcImJlZm9yZVwiYCwgaXQnbGwgcHJldmVudCBtZXJnaW5nIHdpdGggcHJldmlvdXMgdHJhbnNhY3Rpb25zLiBXaXRoXG5gXCJhZnRlclwiYCwgc3Vic2VxdWVudCB0cmFuc2FjdGlvbnMgd29uJ3QgYmUgY29tYmluZWQgd2l0aCB0aGlzXG5vbmUuIFdpdGggYFwiZnVsbFwiYCwgdGhlIHRyYW5zYWN0aW9uIGlzIGlzb2xhdGVkIG9uIGJvdGggc2lkZXMuXG4qL1xuY29uc3QgaXNvbGF0ZUhpc3RvcnkgPSAvKkBfX1BVUkVfXyovQW5ub3RhdGlvbi5kZWZpbmUoKTtcbi8qKlxuVGhpcyBmYWNldCBwcm92aWRlcyBhIHdheSB0byByZWdpc3RlciBmdW5jdGlvbnMgdGhhdCwgZ2l2ZW4gYVxudHJhbnNhY3Rpb24sIHByb3ZpZGUgYSBzZXQgb2YgZWZmZWN0cyB0aGF0IHRoZSBoaXN0b3J5IHNob3VsZFxuc3RvcmUgd2hlbiBpbnZlcnRpbmcgdGhlIHRyYW5zYWN0aW9uLiBUaGlzIGNhbiBiZSB1c2VkIHRvXG5pbnRlZ3JhdGUgc29tZSBraW5kcyBvZiBlZmZlY3RzIGluIHRoZSBoaXN0b3J5LCBzbyB0aGF0IHRoZXkgY2FuXG5iZSB1bmRvbmUgKGFuZCByZWRvbmUgYWdhaW4pLlxuKi9cbmNvbnN0IGludmVydGVkRWZmZWN0cyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IGhpc3RvcnlDb25maWcgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lKGNvbmZpZ3MpIHtcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVDb25maWcoY29uZmlncywge1xuICAgICAgICAgICAgbWluRGVwdGg6IDEwMCxcbiAgICAgICAgICAgIG5ld0dyb3VwRGVsYXk6IDUwMCxcbiAgICAgICAgICAgIGpvaW5Ub0V2ZW50OiAoX3QsIGlzQWRqYWNlbnQpID0+IGlzQWRqYWNlbnQsXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG1pbkRlcHRoOiBNYXRoLm1heCxcbiAgICAgICAgICAgIG5ld0dyb3VwRGVsYXk6IE1hdGgubWluLFxuICAgICAgICAgICAgam9pblRvRXZlbnQ6IChhLCBiKSA9PiAodHIsIGFkaikgPT4gYSh0ciwgYWRqKSB8fCBiKHRyLCBhZGopXG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuY29uc3QgaGlzdG9yeUZpZWxkXyA9IC8qQF9fUFVSRV9fKi9TdGF0ZUZpZWxkLmRlZmluZSh7XG4gICAgY3JlYXRlKCkge1xuICAgICAgICByZXR1cm4gSGlzdG9yeVN0YXRlLmVtcHR5O1xuICAgIH0sXG4gICAgdXBkYXRlKHN0YXRlLCB0cikge1xuICAgICAgICBsZXQgY29uZmlnID0gdHIuc3RhdGUuZmFjZXQoaGlzdG9yeUNvbmZpZyk7XG4gICAgICAgIGxldCBmcm9tSGlzdCA9IHRyLmFubm90YXRpb24oZnJvbUhpc3RvcnkpO1xuICAgICAgICBpZiAoZnJvbUhpc3QpIHtcbiAgICAgICAgICAgIGxldCBpdGVtID0gSGlzdEV2ZW50LmZyb21UcmFuc2FjdGlvbih0ciwgZnJvbUhpc3Quc2VsZWN0aW9uKSwgZnJvbSA9IGZyb21IaXN0LnNpZGU7XG4gICAgICAgICAgICBsZXQgb3RoZXIgPSBmcm9tID09IDAgLyogQnJhbmNoTmFtZS5Eb25lICovID8gc3RhdGUudW5kb25lIDogc3RhdGUuZG9uZTtcbiAgICAgICAgICAgIGlmIChpdGVtKVxuICAgICAgICAgICAgICAgIG90aGVyID0gdXBkYXRlQnJhbmNoKG90aGVyLCBvdGhlci5sZW5ndGgsIGNvbmZpZy5taW5EZXB0aCwgaXRlbSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgb3RoZXIgPSBhZGRTZWxlY3Rpb24ob3RoZXIsIHRyLnN0YXJ0U3RhdGUuc2VsZWN0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSGlzdG9yeVN0YXRlKGZyb20gPT0gMCAvKiBCcmFuY2hOYW1lLkRvbmUgKi8gPyBmcm9tSGlzdC5yZXN0IDogb3RoZXIsIGZyb20gPT0gMCAvKiBCcmFuY2hOYW1lLkRvbmUgKi8gPyBvdGhlciA6IGZyb21IaXN0LnJlc3QpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpc29sYXRlID0gdHIuYW5ub3RhdGlvbihpc29sYXRlSGlzdG9yeSk7XG4gICAgICAgIGlmIChpc29sYXRlID09IFwiZnVsbFwiIHx8IGlzb2xhdGUgPT0gXCJiZWZvcmVcIilcbiAgICAgICAgICAgIHN0YXRlID0gc3RhdGUuaXNvbGF0ZSgpO1xuICAgICAgICBpZiAodHIuYW5ub3RhdGlvbihUcmFuc2FjdGlvbi5hZGRUb0hpc3RvcnkpID09PSBmYWxzZSlcbiAgICAgICAgICAgIHJldHVybiAhdHIuY2hhbmdlcy5lbXB0eSA/IHN0YXRlLmFkZE1hcHBpbmcodHIuY2hhbmdlcy5kZXNjKSA6IHN0YXRlO1xuICAgICAgICBsZXQgZXZlbnQgPSBIaXN0RXZlbnQuZnJvbVRyYW5zYWN0aW9uKHRyKTtcbiAgICAgICAgbGV0IHRpbWUgPSB0ci5hbm5vdGF0aW9uKFRyYW5zYWN0aW9uLnRpbWUpLCB1c2VyRXZlbnQgPSB0ci5hbm5vdGF0aW9uKFRyYW5zYWN0aW9uLnVzZXJFdmVudCk7XG4gICAgICAgIGlmIChldmVudClcbiAgICAgICAgICAgIHN0YXRlID0gc3RhdGUuYWRkQ2hhbmdlcyhldmVudCwgdGltZSwgdXNlckV2ZW50LCBjb25maWcsIHRyKTtcbiAgICAgICAgZWxzZSBpZiAodHIuc2VsZWN0aW9uKVxuICAgICAgICAgICAgc3RhdGUgPSBzdGF0ZS5hZGRTZWxlY3Rpb24odHIuc3RhcnRTdGF0ZS5zZWxlY3Rpb24sIHRpbWUsIHVzZXJFdmVudCwgY29uZmlnLm5ld0dyb3VwRGVsYXkpO1xuICAgICAgICBpZiAoaXNvbGF0ZSA9PSBcImZ1bGxcIiB8fCBpc29sYXRlID09IFwiYWZ0ZXJcIilcbiAgICAgICAgICAgIHN0YXRlID0gc3RhdGUuaXNvbGF0ZSgpO1xuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfSxcbiAgICB0b0pTT04odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHsgZG9uZTogdmFsdWUuZG9uZS5tYXAoZSA9PiBlLnRvSlNPTigpKSwgdW5kb25lOiB2YWx1ZS51bmRvbmUubWFwKGUgPT4gZS50b0pTT04oKSkgfTtcbiAgICB9LFxuICAgIGZyb21KU09OKGpzb24pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIaXN0b3J5U3RhdGUoanNvbi5kb25lLm1hcChIaXN0RXZlbnQuZnJvbUpTT04pLCBqc29uLnVuZG9uZS5tYXAoSGlzdEV2ZW50LmZyb21KU09OKSk7XG4gICAgfVxufSk7XG4vKipcbkNyZWF0ZSBhIGhpc3RvcnkgZXh0ZW5zaW9uIHdpdGggdGhlIGdpdmVuIGNvbmZpZ3VyYXRpb24uXG4qL1xuZnVuY3Rpb24gaGlzdG9yeShjb25maWcgPSB7fSkge1xuICAgIHJldHVybiBbXG4gICAgICAgIGhpc3RvcnlGaWVsZF8sXG4gICAgICAgIGhpc3RvcnlDb25maWcub2YoY29uZmlnKSxcbiAgICAgICAgRWRpdG9yVmlldy5kb21FdmVudEhhbmRsZXJzKHtcbiAgICAgICAgICAgIGJlZm9yZWlucHV0KGUsIHZpZXcpIHtcbiAgICAgICAgICAgICAgICBsZXQgY29tbWFuZCA9IGUuaW5wdXRUeXBlID09IFwiaGlzdG9yeVVuZG9cIiA/IHVuZG8gOiBlLmlucHV0VHlwZSA9PSBcImhpc3RvcnlSZWRvXCIgPyByZWRvIDogbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoIWNvbW1hbmQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1hbmQodmlldyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgXTtcbn1cbi8qKlxuVGhlIHN0YXRlIGZpZWxkIHVzZWQgdG8gc3RvcmUgdGhlIGhpc3RvcnkgZGF0YS4gU2hvdWxkIHByb2JhYmx5XG5vbmx5IGJlIHVzZWQgd2hlbiB5b3Ugd2FudCB0b1xuW3NlcmlhbGl6ZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS50b0pTT04pIG9yXG5bZGVzZXJpYWxpemVdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVeZnJvbUpTT04pIHN0YXRlIG9iamVjdHMgaW4gYSB3YXlcbnRoYXQgcHJlc2VydmVzIGhpc3RvcnkuXG4qL1xuY29uc3QgaGlzdG9yeUZpZWxkID0gaGlzdG9yeUZpZWxkXztcbmZ1bmN0aW9uIGNtZChzaWRlLCBzZWxlY3Rpb24pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHsgc3RhdGUsIGRpc3BhdGNoIH0pIHtcbiAgICAgICAgaWYgKCFzZWxlY3Rpb24gJiYgc3RhdGUucmVhZE9ubHkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCBoaXN0b3J5U3RhdGUgPSBzdGF0ZS5maWVsZChoaXN0b3J5RmllbGRfLCBmYWxzZSk7XG4gICAgICAgIGlmICghaGlzdG9yeVN0YXRlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgdHIgPSBoaXN0b3J5U3RhdGUucG9wKHNpZGUsIHN0YXRlLCBzZWxlY3Rpb24pO1xuICAgICAgICBpZiAoIXRyKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBkaXNwYXRjaCh0cik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG4vKipcblVuZG8gYSBzaW5nbGUgZ3JvdXAgb2YgaGlzdG9yeSBldmVudHMuIFJldHVybnMgZmFsc2UgaWYgbm8gZ3JvdXBcbndhcyBhdmFpbGFibGUuXG4qL1xuY29uc3QgdW5kbyA9IC8qQF9fUFVSRV9fKi9jbWQoMCAvKiBCcmFuY2hOYW1lLkRvbmUgKi8sIGZhbHNlKTtcbi8qKlxuUmVkbyBhIGdyb3VwIG9mIGhpc3RvcnkgZXZlbnRzLiBSZXR1cm5zIGZhbHNlIGlmIG5vIGdyb3VwIHdhc1xuYXZhaWxhYmxlLlxuKi9cbmNvbnN0IHJlZG8gPSAvKkBfX1BVUkVfXyovY21kKDEgLyogQnJhbmNoTmFtZS5VbmRvbmUgKi8sIGZhbHNlKTtcbi8qKlxuVW5kbyBhIGNoYW5nZSBvciBzZWxlY3Rpb24gY2hhbmdlLlxuKi9cbmNvbnN0IHVuZG9TZWxlY3Rpb24gPSAvKkBfX1BVUkVfXyovY21kKDAgLyogQnJhbmNoTmFtZS5Eb25lICovLCB0cnVlKTtcbi8qKlxuUmVkbyBhIGNoYW5nZSBvciBzZWxlY3Rpb24gY2hhbmdlLlxuKi9cbmNvbnN0IHJlZG9TZWxlY3Rpb24gPSAvKkBfX1BVUkVfXyovY21kKDEgLyogQnJhbmNoTmFtZS5VbmRvbmUgKi8sIHRydWUpO1xuZnVuY3Rpb24gZGVwdGgoc2lkZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgbGV0IGhpc3RTdGF0ZSA9IHN0YXRlLmZpZWxkKGhpc3RvcnlGaWVsZF8sIGZhbHNlKTtcbiAgICAgICAgaWYgKCFoaXN0U3RhdGUpXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgbGV0IGJyYW5jaCA9IHNpZGUgPT0gMCAvKiBCcmFuY2hOYW1lLkRvbmUgKi8gPyBoaXN0U3RhdGUuZG9uZSA6IGhpc3RTdGF0ZS51bmRvbmU7XG4gICAgICAgIHJldHVybiBicmFuY2gubGVuZ3RoIC0gKGJyYW5jaC5sZW5ndGggJiYgIWJyYW5jaFswXS5jaGFuZ2VzID8gMSA6IDApO1xuICAgIH07XG59XG4vKipcblRoZSBhbW91bnQgb2YgdW5kb2FibGUgY2hhbmdlIGV2ZW50cyBhdmFpbGFibGUgaW4gYSBnaXZlbiBzdGF0ZS5cbiovXG5jb25zdCB1bmRvRGVwdGggPSAvKkBfX1BVUkVfXyovZGVwdGgoMCAvKiBCcmFuY2hOYW1lLkRvbmUgKi8pO1xuLyoqXG5UaGUgYW1vdW50IG9mIHJlZG9hYmxlIGNoYW5nZSBldmVudHMgYXZhaWxhYmxlIGluIGEgZ2l2ZW4gc3RhdGUuXG4qL1xuY29uc3QgcmVkb0RlcHRoID0gLypAX19QVVJFX18qL2RlcHRoKDEgLyogQnJhbmNoTmFtZS5VbmRvbmUgKi8pO1xuLy8gSGlzdG9yeSBldmVudHMgc3RvcmUgZ3JvdXBzIG9mIGNoYW5nZXMgb3IgZWZmZWN0cyB0aGF0IG5lZWQgdG8gYmVcbi8vIHVuZG9uZS9yZWRvbmUgdG9nZXRoZXIuXG5jbGFzcyBIaXN0RXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8vIFRoZSBjaGFuZ2VzIGluIHRoaXMgZXZlbnQuIE5vcm1hbCBldmVudHMgaG9sZCBhdCBsZWFzdCBvbmVcbiAgICAvLyBjaGFuZ2Ugb3IgZWZmZWN0LiBCdXQgaXQgbWF5IGJlIG5lY2Vzc2FyeSB0byBzdG9yZSBzZWxlY3Rpb25cbiAgICAvLyBldmVudHMgYmVmb3JlIHRoZSBmaXJzdCBjaGFuZ2UsIGluIHdoaWNoIGNhc2UgYSBzcGVjaWFsIHR5cGUgb2ZcbiAgICAvLyBpbnN0YW5jZSBpcyBjcmVhdGVkIHdoaWNoIGRvZXNuJ3QgaG9sZCBhbnkgY2hhbmdlcywgd2l0aFxuICAgIC8vIGNoYW5nZXMgPT0gc3RhcnRTZWxlY3Rpb24gPT0gdW5kZWZpbmVkXG4gICAgY2hhbmdlcywgXG4gICAgLy8gVGhlIGVmZmVjdHMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgZXZlbnRcbiAgICBlZmZlY3RzLCBcbiAgICAvLyBBY2N1bXVsYXRlZCBtYXBwaW5nIChmcm9tIGFkZFRvSGlzdG9yeT09ZmFsc2UpIHRoYXQgc2hvdWxkIGJlXG4gICAgLy8gYXBwbGllZCB0byBldmVudHMgYmVsb3cgdGhpcyBvbmUuXG4gICAgbWFwcGVkLCBcbiAgICAvLyBUaGUgc2VsZWN0aW9uIGJlZm9yZSB0aGlzIGV2ZW50XG4gICAgc3RhcnRTZWxlY3Rpb24sIFxuICAgIC8vIFN0b3JlcyBzZWxlY3Rpb24gY2hhbmdlcyBhZnRlciB0aGlzIGV2ZW50LCB0byBiZSB1c2VkIGZvclxuICAgIC8vIHNlbGVjdGlvbiB1bmRvL3JlZG8uXG4gICAgc2VsZWN0aW9uc0FmdGVyKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlcyA9IGNoYW5nZXM7XG4gICAgICAgIHRoaXMuZWZmZWN0cyA9IGVmZmVjdHM7XG4gICAgICAgIHRoaXMubWFwcGVkID0gbWFwcGVkO1xuICAgICAgICB0aGlzLnN0YXJ0U2VsZWN0aW9uID0gc3RhcnRTZWxlY3Rpb247XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uc0FmdGVyID0gc2VsZWN0aW9uc0FmdGVyO1xuICAgIH1cbiAgICBzZXRTZWxBZnRlcihhZnRlcikge1xuICAgICAgICByZXR1cm4gbmV3IEhpc3RFdmVudCh0aGlzLmNoYW5nZXMsIHRoaXMuZWZmZWN0cywgdGhpcy5tYXBwZWQsIHRoaXMuc3RhcnRTZWxlY3Rpb24sIGFmdGVyKTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNoYW5nZXM6IChfYSA9IHRoaXMuY2hhbmdlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRvSlNPTigpLFxuICAgICAgICAgICAgbWFwcGVkOiAoX2IgPSB0aGlzLm1hcHBlZCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnRvSlNPTigpLFxuICAgICAgICAgICAgc3RhcnRTZWxlY3Rpb246IChfYyA9IHRoaXMuc3RhcnRTZWxlY3Rpb24pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy50b0pTT04oKSxcbiAgICAgICAgICAgIHNlbGVjdGlvbnNBZnRlcjogdGhpcy5zZWxlY3Rpb25zQWZ0ZXIubWFwKHMgPT4gcy50b0pTT04oKSlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21KU09OKGpzb24pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIaXN0RXZlbnQoanNvbi5jaGFuZ2VzICYmIENoYW5nZVNldC5mcm9tSlNPTihqc29uLmNoYW5nZXMpLCBbXSwganNvbi5tYXBwZWQgJiYgQ2hhbmdlRGVzYy5mcm9tSlNPTihqc29uLm1hcHBlZCksIGpzb24uc3RhcnRTZWxlY3Rpb24gJiYgRWRpdG9yU2VsZWN0aW9uLmZyb21KU09OKGpzb24uc3RhcnRTZWxlY3Rpb24pLCBqc29uLnNlbGVjdGlvbnNBZnRlci5tYXAoRWRpdG9yU2VsZWN0aW9uLmZyb21KU09OKSk7XG4gICAgfVxuICAgIC8vIFRoaXMgZG9lcyBub3QgY2hlY2sgYGFkZFRvSGlzdG9yeWAgYW5kIHN1Y2gsIGl0IGFzc3VtZXMgdGhlXG4gICAgLy8gdHJhbnNhY3Rpb24gbmVlZHMgdG8gYmUgY29udmVydGVkIHRvIGFuIGl0ZW0uIFJldHVybnMgbnVsbCB3aGVuXG4gICAgLy8gdGhlcmUgYXJlIG5vIGNoYW5nZXMgb3IgZWZmZWN0cyBpbiB0aGUgdHJhbnNhY3Rpb24uXG4gICAgc3RhdGljIGZyb21UcmFuc2FjdGlvbih0ciwgc2VsZWN0aW9uKSB7XG4gICAgICAgIGxldCBlZmZlY3RzID0gbm9uZTtcbiAgICAgICAgZm9yIChsZXQgaW52ZXJ0IG9mIHRyLnN0YXJ0U3RhdGUuZmFjZXQoaW52ZXJ0ZWRFZmZlY3RzKSkge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IGludmVydCh0cik7XG4gICAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aClcbiAgICAgICAgICAgICAgICBlZmZlY3RzID0gZWZmZWN0cy5jb25jYXQocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWVmZmVjdHMubGVuZ3RoICYmIHRyLmNoYW5nZXMuZW1wdHkpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIG5ldyBIaXN0RXZlbnQodHIuY2hhbmdlcy5pbnZlcnQodHIuc3RhcnRTdGF0ZS5kb2MpLCBlZmZlY3RzLCB1bmRlZmluZWQsIHNlbGVjdGlvbiB8fCB0ci5zdGFydFN0YXRlLnNlbGVjdGlvbiwgbm9uZSk7XG4gICAgfVxuICAgIHN0YXRpYyBzZWxlY3Rpb24oc2VsZWN0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IEhpc3RFdmVudCh1bmRlZmluZWQsIG5vbmUsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBzZWxlY3Rpb25zKTtcbiAgICB9XG59XG5mdW5jdGlvbiB1cGRhdGVCcmFuY2goYnJhbmNoLCB0bywgbWF4TGVuLCBuZXdFdmVudCkge1xuICAgIGxldCBzdGFydCA9IHRvICsgMSA+IG1heExlbiArIDIwID8gdG8gLSBtYXhMZW4gLSAxIDogMDtcbiAgICBsZXQgbmV3QnJhbmNoID0gYnJhbmNoLnNsaWNlKHN0YXJ0LCB0byk7XG4gICAgbmV3QnJhbmNoLnB1c2gobmV3RXZlbnQpO1xuICAgIHJldHVybiBuZXdCcmFuY2g7XG59XG5mdW5jdGlvbiBpc0FkamFjZW50KGEsIGIpIHtcbiAgICBsZXQgcmFuZ2VzID0gW10sIGlzQWRqYWNlbnQgPSBmYWxzZTtcbiAgICBhLml0ZXJDaGFuZ2VkUmFuZ2VzKChmLCB0KSA9PiByYW5nZXMucHVzaChmLCB0KSk7XG4gICAgYi5pdGVyQ2hhbmdlZFJhbmdlcygoX2YsIF90LCBmLCB0KSA9PiB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDspIHtcbiAgICAgICAgICAgIGxldCBmcm9tID0gcmFuZ2VzW2krK10sIHRvID0gcmFuZ2VzW2krK107XG4gICAgICAgICAgICBpZiAodCA+PSBmcm9tICYmIGYgPD0gdG8pXG4gICAgICAgICAgICAgICAgaXNBZGphY2VudCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gaXNBZGphY2VudDtcbn1cbmZ1bmN0aW9uIGVxU2VsZWN0aW9uU2hhcGUoYSwgYikge1xuICAgIHJldHVybiBhLnJhbmdlcy5sZW5ndGggPT0gYi5yYW5nZXMubGVuZ3RoICYmXG4gICAgICAgIGEucmFuZ2VzLmZpbHRlcigociwgaSkgPT4gci5lbXB0eSAhPSBiLnJhbmdlc1tpXS5lbXB0eSkubGVuZ3RoID09PSAwO1xufVxuZnVuY3Rpb24gY29uYyhhLCBiKSB7XG4gICAgcmV0dXJuICFhLmxlbmd0aCA/IGIgOiAhYi5sZW5ndGggPyBhIDogYS5jb25jYXQoYik7XG59XG5jb25zdCBub25lID0gW107XG5jb25zdCBNYXhTZWxlY3Rpb25zUGVyRXZlbnQgPSAyMDA7XG5mdW5jdGlvbiBhZGRTZWxlY3Rpb24oYnJhbmNoLCBzZWxlY3Rpb24pIHtcbiAgICBpZiAoIWJyYW5jaC5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtIaXN0RXZlbnQuc2VsZWN0aW9uKFtzZWxlY3Rpb25dKV07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgbGFzdEV2ZW50ID0gYnJhbmNoW2JyYW5jaC5sZW5ndGggLSAxXTtcbiAgICAgICAgbGV0IHNlbHMgPSBsYXN0RXZlbnQuc2VsZWN0aW9uc0FmdGVyLnNsaWNlKE1hdGgubWF4KDAsIGxhc3RFdmVudC5zZWxlY3Rpb25zQWZ0ZXIubGVuZ3RoIC0gTWF4U2VsZWN0aW9uc1BlckV2ZW50KSk7XG4gICAgICAgIGlmIChzZWxzLmxlbmd0aCAmJiBzZWxzW3NlbHMubGVuZ3RoIC0gMV0uZXEoc2VsZWN0aW9uKSlcbiAgICAgICAgICAgIHJldHVybiBicmFuY2g7XG4gICAgICAgIHNlbHMucHVzaChzZWxlY3Rpb24pO1xuICAgICAgICByZXR1cm4gdXBkYXRlQnJhbmNoKGJyYW5jaCwgYnJhbmNoLmxlbmd0aCAtIDEsIDFlOSwgbGFzdEV2ZW50LnNldFNlbEFmdGVyKHNlbHMpKTtcbiAgICB9XG59XG4vLyBBc3N1bWVzIHRoZSB0b3AgaXRlbSBoYXMgb25lIG9yIG1vcmUgc2VsZWN0aW9uQWZ0ZXIgdmFsdWVzXG5mdW5jdGlvbiBwb3BTZWxlY3Rpb24oYnJhbmNoKSB7XG4gICAgbGV0IGxhc3QgPSBicmFuY2hbYnJhbmNoLmxlbmd0aCAtIDFdO1xuICAgIGxldCBuZXdCcmFuY2ggPSBicmFuY2guc2xpY2UoKTtcbiAgICBuZXdCcmFuY2hbYnJhbmNoLmxlbmd0aCAtIDFdID0gbGFzdC5zZXRTZWxBZnRlcihsYXN0LnNlbGVjdGlvbnNBZnRlci5zbGljZSgwLCBsYXN0LnNlbGVjdGlvbnNBZnRlci5sZW5ndGggLSAxKSk7XG4gICAgcmV0dXJuIG5ld0JyYW5jaDtcbn1cbi8vIEFkZCBhIG1hcHBpbmcgdG8gdGhlIHRvcCBldmVudCBpbiB0aGUgZ2l2ZW4gYnJhbmNoLiBJZiB0aGlzIG1hcHNcbi8vIGF3YXkgYWxsIHRoZSBjaGFuZ2VzIGFuZCBlZmZlY3RzIGluIHRoYXQgaXRlbSwgZHJvcCBpdCBhbmRcbi8vIHByb3BhZ2F0ZSB0aGUgbWFwcGluZyB0byB0aGUgbmV4dCBpdGVtLlxuZnVuY3Rpb24gYWRkTWFwcGluZ1RvQnJhbmNoKGJyYW5jaCwgbWFwcGluZykge1xuICAgIGlmICghYnJhbmNoLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGJyYW5jaDtcbiAgICBsZXQgbGVuZ3RoID0gYnJhbmNoLmxlbmd0aCwgc2VsZWN0aW9ucyA9IG5vbmU7XG4gICAgd2hpbGUgKGxlbmd0aCkge1xuICAgICAgICBsZXQgZXZlbnQgPSBtYXBFdmVudChicmFuY2hbbGVuZ3RoIC0gMV0sIG1hcHBpbmcsIHNlbGVjdGlvbnMpO1xuICAgICAgICBpZiAoZXZlbnQuY2hhbmdlcyAmJiAhZXZlbnQuY2hhbmdlcy5lbXB0eSB8fCBldmVudC5lZmZlY3RzLmxlbmd0aCkgeyAvLyBFdmVudCBzdXJ2aXZlZCBtYXBwaW5nXG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gYnJhbmNoLnNsaWNlKDAsIGxlbmd0aCk7XG4gICAgICAgICAgICByZXN1bHRbbGVuZ3RoIC0gMV0gPSBldmVudDtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vIERyb3AgdGhpcyBldmVudCwgc2luY2UgdGhlcmUncyBubyBjaGFuZ2VzIG9yIGVmZmVjdHMgbGVmdFxuICAgICAgICAgICAgbWFwcGluZyA9IGV2ZW50Lm1hcHBlZDtcbiAgICAgICAgICAgIGxlbmd0aC0tO1xuICAgICAgICAgICAgc2VsZWN0aW9ucyA9IGV2ZW50LnNlbGVjdGlvbnNBZnRlcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2VsZWN0aW9ucy5sZW5ndGggPyBbSGlzdEV2ZW50LnNlbGVjdGlvbihzZWxlY3Rpb25zKV0gOiBub25lO1xufVxuZnVuY3Rpb24gbWFwRXZlbnQoZXZlbnQsIG1hcHBpbmcsIGV4dHJhU2VsZWN0aW9ucykge1xuICAgIGxldCBzZWxlY3Rpb25zID0gY29uYyhldmVudC5zZWxlY3Rpb25zQWZ0ZXIubGVuZ3RoID8gZXZlbnQuc2VsZWN0aW9uc0FmdGVyLm1hcChzID0+IHMubWFwKG1hcHBpbmcpKSA6IG5vbmUsIGV4dHJhU2VsZWN0aW9ucyk7XG4gICAgLy8gQ2hhbmdlLWxlc3MgZXZlbnRzIGRvbid0IHN0b3JlIG1hcHBpbmdzICh0aGV5IGFyZSBhbHdheXMgdGhlIGxhc3QgZXZlbnQgaW4gYSBicmFuY2gpXG4gICAgaWYgKCFldmVudC5jaGFuZ2VzKVxuICAgICAgICByZXR1cm4gSGlzdEV2ZW50LnNlbGVjdGlvbihzZWxlY3Rpb25zKTtcbiAgICBsZXQgbWFwcGVkQ2hhbmdlcyA9IGV2ZW50LmNoYW5nZXMubWFwKG1hcHBpbmcpLCBiZWZvcmUgPSBtYXBwaW5nLm1hcERlc2MoZXZlbnQuY2hhbmdlcywgdHJ1ZSk7XG4gICAgbGV0IGZ1bGxNYXBwaW5nID0gZXZlbnQubWFwcGVkID8gZXZlbnQubWFwcGVkLmNvbXBvc2VEZXNjKGJlZm9yZSkgOiBiZWZvcmU7XG4gICAgcmV0dXJuIG5ldyBIaXN0RXZlbnQobWFwcGVkQ2hhbmdlcywgU3RhdGVFZmZlY3QubWFwRWZmZWN0cyhldmVudC5lZmZlY3RzLCBtYXBwaW5nKSwgZnVsbE1hcHBpbmcsIGV2ZW50LnN0YXJ0U2VsZWN0aW9uLm1hcChiZWZvcmUpLCBzZWxlY3Rpb25zKTtcbn1cbmNvbnN0IGpvaW5hYmxlVXNlckV2ZW50ID0gL14oaW5wdXRcXC50eXBlfGRlbGV0ZSkoJHxcXC4pLztcbmNsYXNzIEhpc3RvcnlTdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoZG9uZSwgdW5kb25lLCBwcmV2VGltZSA9IDAsIHByZXZVc2VyRXZlbnQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5kb25lID0gZG9uZTtcbiAgICAgICAgdGhpcy51bmRvbmUgPSB1bmRvbmU7XG4gICAgICAgIHRoaXMucHJldlRpbWUgPSBwcmV2VGltZTtcbiAgICAgICAgdGhpcy5wcmV2VXNlckV2ZW50ID0gcHJldlVzZXJFdmVudDtcbiAgICB9XG4gICAgaXNvbGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJldlRpbWUgPyBuZXcgSGlzdG9yeVN0YXRlKHRoaXMuZG9uZSwgdGhpcy51bmRvbmUpIDogdGhpcztcbiAgICB9XG4gICAgYWRkQ2hhbmdlcyhldmVudCwgdGltZSwgdXNlckV2ZW50LCBjb25maWcsIHRyKSB7XG4gICAgICAgIGxldCBkb25lID0gdGhpcy5kb25lLCBsYXN0RXZlbnQgPSBkb25lW2RvbmUubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChsYXN0RXZlbnQgJiYgbGFzdEV2ZW50LmNoYW5nZXMgJiYgIWxhc3RFdmVudC5jaGFuZ2VzLmVtcHR5ICYmIGV2ZW50LmNoYW5nZXMgJiZcbiAgICAgICAgICAgICghdXNlckV2ZW50IHx8IGpvaW5hYmxlVXNlckV2ZW50LnRlc3QodXNlckV2ZW50KSkgJiZcbiAgICAgICAgICAgICgoIWxhc3RFdmVudC5zZWxlY3Rpb25zQWZ0ZXIubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgdGltZSAtIHRoaXMucHJldlRpbWUgPCBjb25maWcubmV3R3JvdXBEZWxheSAmJlxuICAgICAgICAgICAgICAgIGNvbmZpZy5qb2luVG9FdmVudCh0ciwgaXNBZGphY2VudChsYXN0RXZlbnQuY2hhbmdlcywgZXZlbnQuY2hhbmdlcykpKSB8fFxuICAgICAgICAgICAgICAgIC8vIEZvciBjb21wb3NlIChidXQgbm90IGNvbXBvc2Uuc3RhcnQpIGV2ZW50cywgYWx3YXlzIGpvaW4gd2l0aCBwcmV2aW91cyBldmVudFxuICAgICAgICAgICAgICAgIHVzZXJFdmVudCA9PSBcImlucHV0LnR5cGUuY29tcG9zZVwiKSkge1xuICAgICAgICAgICAgZG9uZSA9IHVwZGF0ZUJyYW5jaChkb25lLCBkb25lLmxlbmd0aCAtIDEsIGNvbmZpZy5taW5EZXB0aCwgbmV3IEhpc3RFdmVudChldmVudC5jaGFuZ2VzLmNvbXBvc2UobGFzdEV2ZW50LmNoYW5nZXMpLCBjb25jKGV2ZW50LmVmZmVjdHMsIGxhc3RFdmVudC5lZmZlY3RzKSwgbGFzdEV2ZW50Lm1hcHBlZCwgbGFzdEV2ZW50LnN0YXJ0U2VsZWN0aW9uLCBub25lKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkb25lID0gdXBkYXRlQnJhbmNoKGRvbmUsIGRvbmUubGVuZ3RoLCBjb25maWcubWluRGVwdGgsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEhpc3RvcnlTdGF0ZShkb25lLCBub25lLCB0aW1lLCB1c2VyRXZlbnQpO1xuICAgIH1cbiAgICBhZGRTZWxlY3Rpb24oc2VsZWN0aW9uLCB0aW1lLCB1c2VyRXZlbnQsIG5ld0dyb3VwRGVsYXkpIHtcbiAgICAgICAgbGV0IGxhc3QgPSB0aGlzLmRvbmUubGVuZ3RoID8gdGhpcy5kb25lW3RoaXMuZG9uZS5sZW5ndGggLSAxXS5zZWxlY3Rpb25zQWZ0ZXIgOiBub25lO1xuICAgICAgICBpZiAobGFzdC5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICB0aW1lIC0gdGhpcy5wcmV2VGltZSA8IG5ld0dyb3VwRGVsYXkgJiZcbiAgICAgICAgICAgIHVzZXJFdmVudCA9PSB0aGlzLnByZXZVc2VyRXZlbnQgJiYgdXNlckV2ZW50ICYmIC9ec2VsZWN0KCR8XFwuKS8udGVzdCh1c2VyRXZlbnQpICYmXG4gICAgICAgICAgICBlcVNlbGVjdGlvblNoYXBlKGxhc3RbbGFzdC5sZW5ndGggLSAxXSwgc2VsZWN0aW9uKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICByZXR1cm4gbmV3IEhpc3RvcnlTdGF0ZShhZGRTZWxlY3Rpb24odGhpcy5kb25lLCBzZWxlY3Rpb24pLCB0aGlzLnVuZG9uZSwgdGltZSwgdXNlckV2ZW50KTtcbiAgICB9XG4gICAgYWRkTWFwcGluZyhtYXBwaW5nKSB7XG4gICAgICAgIHJldHVybiBuZXcgSGlzdG9yeVN0YXRlKGFkZE1hcHBpbmdUb0JyYW5jaCh0aGlzLmRvbmUsIG1hcHBpbmcpLCBhZGRNYXBwaW5nVG9CcmFuY2godGhpcy51bmRvbmUsIG1hcHBpbmcpLCB0aGlzLnByZXZUaW1lLCB0aGlzLnByZXZVc2VyRXZlbnQpO1xuICAgIH1cbiAgICBwb3Aoc2lkZSwgc3RhdGUsIG9ubHlTZWxlY3Rpb24pIHtcbiAgICAgICAgbGV0IGJyYW5jaCA9IHNpZGUgPT0gMCAvKiBCcmFuY2hOYW1lLkRvbmUgKi8gPyB0aGlzLmRvbmUgOiB0aGlzLnVuZG9uZTtcbiAgICAgICAgaWYgKGJyYW5jaC5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgZXZlbnQgPSBicmFuY2hbYnJhbmNoLmxlbmd0aCAtIDFdLCBzZWxlY3Rpb24gPSBldmVudC5zZWxlY3Rpb25zQWZ0ZXJbMF0gfHwgc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICBpZiAob25seVNlbGVjdGlvbiAmJiBldmVudC5zZWxlY3Rpb25zQWZ0ZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhdGUudXBkYXRlKHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb246IGV2ZW50LnNlbGVjdGlvbnNBZnRlcltldmVudC5zZWxlY3Rpb25zQWZ0ZXIubGVuZ3RoIC0gMV0sXG4gICAgICAgICAgICAgICAgYW5ub3RhdGlvbnM6IGZyb21IaXN0b3J5Lm9mKHsgc2lkZSwgcmVzdDogcG9wU2VsZWN0aW9uKGJyYW5jaCksIHNlbGVjdGlvbiB9KSxcbiAgICAgICAgICAgICAgICB1c2VyRXZlbnQ6IHNpZGUgPT0gMCAvKiBCcmFuY2hOYW1lLkRvbmUgKi8gPyBcInNlbGVjdC51bmRvXCIgOiBcInNlbGVjdC5yZWRvXCIsXG4gICAgICAgICAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFldmVudC5jaGFuZ2VzKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCByZXN0ID0gYnJhbmNoLmxlbmd0aCA9PSAxID8gbm9uZSA6IGJyYW5jaC5zbGljZSgwLCBicmFuY2gubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICBpZiAoZXZlbnQubWFwcGVkKVxuICAgICAgICAgICAgICAgIHJlc3QgPSBhZGRNYXBwaW5nVG9CcmFuY2gocmVzdCwgZXZlbnQubWFwcGVkKTtcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZS51cGRhdGUoe1xuICAgICAgICAgICAgICAgIGNoYW5nZXM6IGV2ZW50LmNoYW5nZXMsXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uOiBldmVudC5zdGFydFNlbGVjdGlvbixcbiAgICAgICAgICAgICAgICBlZmZlY3RzOiBldmVudC5lZmZlY3RzLFxuICAgICAgICAgICAgICAgIGFubm90YXRpb25zOiBmcm9tSGlzdG9yeS5vZih7IHNpZGUsIHJlc3QsIHNlbGVjdGlvbiB9KSxcbiAgICAgICAgICAgICAgICBmaWx0ZXI6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHVzZXJFdmVudDogc2lkZSA9PSAwIC8qIEJyYW5jaE5hbWUuRG9uZSAqLyA/IFwidW5kb1wiIDogXCJyZWRvXCIsXG4gICAgICAgICAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuSGlzdG9yeVN0YXRlLmVtcHR5ID0gLypAX19QVVJFX18qL25ldyBIaXN0b3J5U3RhdGUobm9uZSwgbm9uZSk7XG4vKipcbkRlZmF1bHQga2V5IGJpbmRpbmdzIGZvciB0aGUgdW5kbyBoaXN0b3J5LlxuXG4tIE1vZC16OiBbYHVuZG9gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnVuZG8pLlxuLSBNb2QteSAoTW9kLVNoaWZ0LXogb24gbWFjT1MpICsgQ3RybC1TaGlmdC16IG9uIExpbnV4OiBbYHJlZG9gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnJlZG8pLlxuLSBNb2QtdTogW2B1bmRvU2VsZWN0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy51bmRvU2VsZWN0aW9uKS5cbi0gQWx0LXUgKE1vZC1TaGlmdC11IG9uIG1hY09TKTogW2ByZWRvU2VsZWN0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5yZWRvU2VsZWN0aW9uKS5cbiovXG5jb25zdCBoaXN0b3J5S2V5bWFwID0gW1xuICAgIHsga2V5OiBcIk1vZC16XCIsIHJ1bjogdW5kbywgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IGtleTogXCJNb2QteVwiLCBtYWM6IFwiTW9kLVNoaWZ0LXpcIiwgcnVuOiByZWRvLCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsgbGludXg6IFwiQ3RybC1TaGlmdC16XCIsIHJ1bjogcmVkbywgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IGtleTogXCJNb2QtdVwiLCBydW46IHVuZG9TZWxlY3Rpb24sIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBrZXk6IFwiQWx0LXVcIiwgbWFjOiBcIk1vZC1TaGlmdC11XCIsIHJ1bjogcmVkb1NlbGVjdGlvbiwgcHJldmVudERlZmF1bHQ6IHRydWUgfVxuXTtcblxuZnVuY3Rpb24gdXBkYXRlU2VsKHNlbCwgYnkpIHtcbiAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShzZWwucmFuZ2VzLm1hcChieSksIHNlbC5tYWluSW5kZXgpO1xufVxuZnVuY3Rpb24gc2V0U2VsKHN0YXRlLCBzZWxlY3Rpb24pIHtcbiAgICByZXR1cm4gc3RhdGUudXBkYXRlKHsgc2VsZWN0aW9uLCBzY3JvbGxJbnRvVmlldzogdHJ1ZSwgdXNlckV2ZW50OiBcInNlbGVjdFwiIH0pO1xufVxuZnVuY3Rpb24gbW92ZVNlbCh7IHN0YXRlLCBkaXNwYXRjaCB9LCBob3cpIHtcbiAgICBsZXQgc2VsZWN0aW9uID0gdXBkYXRlU2VsKHN0YXRlLnNlbGVjdGlvbiwgaG93KTtcbiAgICBpZiAoc2VsZWN0aW9uLmVxKHN0YXRlLnNlbGVjdGlvbikpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkaXNwYXRjaChzZXRTZWwoc3RhdGUsIHNlbGVjdGlvbikpO1xuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gcmFuZ2VFbmQocmFuZ2UsIGZvcndhcmQpIHtcbiAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihmb3J3YXJkID8gcmFuZ2UudG8gOiByYW5nZS5mcm9tKTtcbn1cbmZ1bmN0aW9uIGN1cnNvckJ5Q2hhcih2aWV3LCBmb3J3YXJkKSB7XG4gICAgcmV0dXJuIG1vdmVTZWwodmlldywgcmFuZ2UgPT4gcmFuZ2UuZW1wdHkgPyB2aWV3Lm1vdmVCeUNoYXIocmFuZ2UsIGZvcndhcmQpIDogcmFuZ2VFbmQocmFuZ2UsIGZvcndhcmQpKTtcbn1cbmZ1bmN0aW9uIGx0ckF0Q3Vyc29yKHZpZXcpIHtcbiAgICByZXR1cm4gdmlldy50ZXh0RGlyZWN0aW9uQXQodmlldy5zdGF0ZS5zZWxlY3Rpb24ubWFpbi5oZWFkKSA9PSBEaXJlY3Rpb24uTFRSO1xufVxuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIGNoYXJhY3RlciB0byB0aGUgbGVmdCAod2hpY2ggaXMgYmFja3dhcmQgaW5cbmxlZnQtdG8tcmlnaHQgdGV4dCwgZm9yd2FyZCBpbiByaWdodC10by1sZWZ0IHRleHQpLlxuKi9cbmNvbnN0IGN1cnNvckNoYXJMZWZ0ID0gdmlldyA9PiBjdXJzb3JCeUNoYXIodmlldywgIWx0ckF0Q3Vyc29yKHZpZXcpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBjaGFyYWN0ZXIgdG8gdGhlIHJpZ2h0LlxuKi9cbmNvbnN0IGN1cnNvckNoYXJSaWdodCA9IHZpZXcgPT4gY3Vyc29yQnlDaGFyKHZpZXcsIGx0ckF0Q3Vyc29yKHZpZXcpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBjaGFyYWN0ZXIgZm9yd2FyZC5cbiovXG5jb25zdCBjdXJzb3JDaGFyRm9yd2FyZCA9IHZpZXcgPT4gY3Vyc29yQnlDaGFyKHZpZXcsIHRydWUpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIGNoYXJhY3RlciBiYWNrd2FyZC5cbiovXG5jb25zdCBjdXJzb3JDaGFyQmFja3dhcmQgPSB2aWV3ID0+IGN1cnNvckJ5Q2hhcih2aWV3LCBmYWxzZSk7XG5mdW5jdGlvbiBjdXJzb3JCeUdyb3VwKHZpZXcsIGZvcndhcmQpIHtcbiAgICByZXR1cm4gbW92ZVNlbCh2aWV3LCByYW5nZSA9PiByYW5nZS5lbXB0eSA/IHZpZXcubW92ZUJ5R3JvdXAocmFuZ2UsIGZvcndhcmQpIDogcmFuZ2VFbmQocmFuZ2UsIGZvcndhcmQpKTtcbn1cbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIHRvIHRoZSBsZWZ0IGFjcm9zcyBvbmUgZ3JvdXAgb2Ygd29yZCBvclxubm9uLXdvcmQgKGJ1dCBhbHNvIG5vbi1zcGFjZSkgY2hhcmFjdGVycy5cbiovXG5jb25zdCBjdXJzb3JHcm91cExlZnQgPSB2aWV3ID0+IGN1cnNvckJ5R3JvdXAodmlldywgIWx0ckF0Q3Vyc29yKHZpZXcpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBncm91cCB0byB0aGUgcmlnaHQuXG4qL1xuY29uc3QgY3Vyc29yR3JvdXBSaWdodCA9IHZpZXcgPT4gY3Vyc29yQnlHcm91cCh2aWV3LCBsdHJBdEN1cnNvcih2aWV3KSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBvbmUgZ3JvdXAgZm9yd2FyZC5cbiovXG5jb25zdCBjdXJzb3JHcm91cEZvcndhcmQgPSB2aWV3ID0+IGN1cnNvckJ5R3JvdXAodmlldywgdHJ1ZSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBvbmUgZ3JvdXAgYmFja3dhcmQuXG4qL1xuY29uc3QgY3Vyc29yR3JvdXBCYWNrd2FyZCA9IHZpZXcgPT4gY3Vyc29yQnlHcm91cCh2aWV3LCBmYWxzZSk7XG5jb25zdCBzZWdtZW50ZXIgPSB0eXBlb2YgSW50bCAhPSBcInVuZGVmaW5lZFwiICYmIEludGwuU2VnbWVudGVyID9cbiAgICAvKkBfX1BVUkVfXyovbmV3IChJbnRsLlNlZ21lbnRlcikodW5kZWZpbmVkLCB7IGdyYW51bGFyaXR5OiBcIndvcmRcIiB9KSA6IG51bGw7XG5mdW5jdGlvbiBtb3ZlQnlTdWJ3b3JkKHZpZXcsIHJhbmdlLCBmb3J3YXJkKSB7XG4gICAgbGV0IGNhdGVnb3JpemUgPSB2aWV3LnN0YXRlLmNoYXJDYXRlZ29yaXplcihyYW5nZS5mcm9tKTtcbiAgICBsZXQgY2F0ID0gQ2hhckNhdGVnb3J5LlNwYWNlLCBwb3MgPSByYW5nZS5mcm9tLCBzdGVwcyA9IDA7XG4gICAgbGV0IGRvbmUgPSBmYWxzZSwgc2F3VXBwZXIgPSBmYWxzZSwgc2F3TG93ZXIgPSBmYWxzZTtcbiAgICBsZXQgc3RlcCA9IChuZXh0KSA9PiB7XG4gICAgICAgIGlmIChkb25lKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBwb3MgKz0gZm9yd2FyZCA/IG5leHQubGVuZ3RoIDogLW5leHQubGVuZ3RoO1xuICAgICAgICBsZXQgbmV4dENhdCA9IGNhdGVnb3JpemUobmV4dCksIGFoZWFkO1xuICAgICAgICBpZiAobmV4dENhdCA9PSBDaGFyQ2F0ZWdvcnkuV29yZCAmJiBuZXh0LmNoYXJDb2RlQXQoMCkgPCAxMjggJiYgL1tcXFdfXS8udGVzdChuZXh0KSlcbiAgICAgICAgICAgIG5leHRDYXQgPSAtMTsgLy8gVHJlYXQgd29yZCBwdW5jdHVhdGlvbiBzcGVjaWFsbHlcbiAgICAgICAgaWYgKGNhdCA9PSBDaGFyQ2F0ZWdvcnkuU3BhY2UpXG4gICAgICAgICAgICBjYXQgPSBuZXh0Q2F0O1xuICAgICAgICBpZiAoY2F0ICE9IG5leHRDYXQpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChjYXQgPT0gQ2hhckNhdGVnb3J5LldvcmQpIHtcbiAgICAgICAgICAgIGlmIChuZXh0LnRvTG93ZXJDYXNlKCkgPT0gbmV4dCkge1xuICAgICAgICAgICAgICAgIGlmICghZm9yd2FyZCAmJiBzYXdVcHBlcilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIHNhd0xvd2VyID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNhd0xvd2VyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZvcndhcmQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChzYXdVcHBlciAmJiBmb3J3YXJkICYmIGNhdGVnb3JpemUoYWhlYWQgPSB2aWV3LnN0YXRlLnNsaWNlRG9jKHBvcywgcG9zICsgMSkpID09IENoYXJDYXRlZ29yeS5Xb3JkICYmXG4gICAgICAgICAgICAgICAgICAgIGFoZWFkLnRvTG93ZXJDYXNlKCkgPT0gYWhlYWQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICBzYXdVcHBlciA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RlcHMrKztcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBsZXQgZW5kID0gdmlldy5tb3ZlQnlDaGFyKHJhbmdlLCBmb3J3YXJkLCBzdGFydCA9PiB7XG4gICAgICAgIHN0ZXAoc3RhcnQpO1xuICAgICAgICByZXR1cm4gc3RlcDtcbiAgICB9KTtcbiAgICBpZiAoc2VnbWVudGVyICYmIGNhdCA9PSBDaGFyQ2F0ZWdvcnkuV29yZCAmJiBlbmQuZnJvbSA9PSByYW5nZS5mcm9tICsgc3RlcHMgKiAoZm9yd2FyZCA/IDEgOiAtMSkpIHtcbiAgICAgICAgbGV0IGZyb20gPSBNYXRoLm1pbihyYW5nZS5oZWFkLCBlbmQuaGVhZCksIHRvID0gTWF0aC5tYXgocmFuZ2UuaGVhZCwgZW5kLmhlYWQpO1xuICAgICAgICBsZXQgc2tpcHBlZCA9IHZpZXcuc3RhdGUuc2xpY2VEb2MoZnJvbSwgdG8pO1xuICAgICAgICBpZiAoc2tpcHBlZC5sZW5ndGggPiAxICYmIC9bXFx1NEUwMC1cXHVmZmZmXS8udGVzdChza2lwcGVkKSkge1xuICAgICAgICAgICAgbGV0IHNlZ21lbnRzID0gQXJyYXkuZnJvbShzZWdtZW50ZXIuc2VnbWVudChza2lwcGVkKSk7XG4gICAgICAgICAgICBpZiAoc2VnbWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIGlmIChmb3J3YXJkKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihyYW5nZS5oZWFkICsgc2VnbWVudHNbMV0uaW5kZXgsIC0xKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihlbmQuaGVhZCArIHNlZ21lbnRzW3NlZ21lbnRzLmxlbmd0aCAtIDFdLmluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZW5kO1xufVxuZnVuY3Rpb24gY3Vyc29yQnlTdWJ3b3JkKHZpZXcsIGZvcndhcmQpIHtcbiAgICByZXR1cm4gbW92ZVNlbCh2aWV3LCByYW5nZSA9PiByYW5nZS5lbXB0eSA/IG1vdmVCeVN1YndvcmQodmlldywgcmFuZ2UsIGZvcndhcmQpIDogcmFuZ2VFbmQocmFuZ2UsIGZvcndhcmQpKTtcbn1cbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBncm91cCBvciBjYW1lbC1jYXNlIHN1YndvcmQgZm9yd2FyZC5cbiovXG5jb25zdCBjdXJzb3JTdWJ3b3JkRm9yd2FyZCA9IHZpZXcgPT4gY3Vyc29yQnlTdWJ3b3JkKHZpZXcsIHRydWUpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIGdyb3VwIG9yIGNhbWVsLWNhc2Ugc3Vid29yZCBiYWNrd2FyZC5cbiovXG5jb25zdCBjdXJzb3JTdWJ3b3JkQmFja3dhcmQgPSB2aWV3ID0+IGN1cnNvckJ5U3Vid29yZCh2aWV3LCBmYWxzZSk7XG5mdW5jdGlvbiBpbnRlcmVzdGluZ05vZGUoc3RhdGUsIG5vZGUsIGJyYWNrZXRQcm9wKSB7XG4gICAgaWYgKG5vZGUudHlwZS5wcm9wKGJyYWNrZXRQcm9wKSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgbGV0IGxlbiA9IG5vZGUudG8gLSBub2RlLmZyb207XG4gICAgcmV0dXJuIGxlbiAmJiAobGVuID4gMiB8fCAvW15cXHMsLjs6XS8udGVzdChzdGF0ZS5zbGljZURvYyhub2RlLmZyb20sIG5vZGUudG8pKSkgfHwgbm9kZS5maXJzdENoaWxkO1xufVxuZnVuY3Rpb24gbW92ZUJ5U3ludGF4KHN0YXRlLCBzdGFydCwgZm9yd2FyZCkge1xuICAgIGxldCBwb3MgPSBzeW50YXhUcmVlKHN0YXRlKS5yZXNvbHZlSW5uZXIoc3RhcnQuaGVhZCk7XG4gICAgbGV0IGJyYWNrZXRQcm9wID0gZm9yd2FyZCA/IE5vZGVQcm9wLmNsb3NlZEJ5IDogTm9kZVByb3Aub3BlbmVkQnk7XG4gICAgLy8gU2NhbiBmb3J3YXJkIHRocm91Z2ggY2hpbGQgbm9kZXMgdG8gc2VlIGlmIHRoZXJlJ3MgYW4gaW50ZXJlc3RpbmdcbiAgICAvLyBub2RlIGFoZWFkLlxuICAgIGZvciAobGV0IGF0ID0gc3RhcnQuaGVhZDs7KSB7XG4gICAgICAgIGxldCBuZXh0ID0gZm9yd2FyZCA/IHBvcy5jaGlsZEFmdGVyKGF0KSA6IHBvcy5jaGlsZEJlZm9yZShhdCk7XG4gICAgICAgIGlmICghbmV4dClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBpZiAoaW50ZXJlc3RpbmdOb2RlKHN0YXRlLCBuZXh0LCBicmFja2V0UHJvcCkpXG4gICAgICAgICAgICBwb3MgPSBuZXh0O1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBhdCA9IGZvcndhcmQgPyBuZXh0LnRvIDogbmV4dC5mcm9tO1xuICAgIH1cbiAgICBsZXQgYnJhY2tldCA9IHBvcy50eXBlLnByb3AoYnJhY2tldFByb3ApLCBtYXRjaCwgbmV3UG9zO1xuICAgIGlmIChicmFja2V0ICYmIChtYXRjaCA9IGZvcndhcmQgPyBtYXRjaEJyYWNrZXRzKHN0YXRlLCBwb3MuZnJvbSwgMSkgOiBtYXRjaEJyYWNrZXRzKHN0YXRlLCBwb3MudG8sIC0xKSkgJiYgbWF0Y2gubWF0Y2hlZClcbiAgICAgICAgbmV3UG9zID0gZm9yd2FyZCA/IG1hdGNoLmVuZC50byA6IG1hdGNoLmVuZC5mcm9tO1xuICAgIGVsc2VcbiAgICAgICAgbmV3UG9zID0gZm9yd2FyZCA/IHBvcy50byA6IHBvcy5mcm9tO1xuICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKG5ld1BvcywgZm9yd2FyZCA/IC0xIDogMSk7XG59XG4vKipcbk1vdmUgdGhlIGN1cnNvciBvdmVyIHRoZSBuZXh0IHN5bnRhY3RpYyBlbGVtZW50IHRvIHRoZSBsZWZ0LlxuKi9cbmNvbnN0IGN1cnNvclN5bnRheExlZnQgPSB2aWV3ID0+IG1vdmVTZWwodmlldywgcmFuZ2UgPT4gbW92ZUJ5U3ludGF4KHZpZXcuc3RhdGUsIHJhbmdlLCAhbHRyQXRDdXJzb3IodmlldykpKTtcbi8qKlxuTW92ZSB0aGUgY3Vyc29yIG92ZXIgdGhlIG5leHQgc3ludGFjdGljIGVsZW1lbnQgdG8gdGhlIHJpZ2h0LlxuKi9cbmNvbnN0IGN1cnNvclN5bnRheFJpZ2h0ID0gdmlldyA9PiBtb3ZlU2VsKHZpZXcsIHJhbmdlID0+IG1vdmVCeVN5bnRheCh2aWV3LnN0YXRlLCByYW5nZSwgbHRyQXRDdXJzb3IodmlldykpKTtcbmZ1bmN0aW9uIGN1cnNvckJ5TGluZSh2aWV3LCBmb3J3YXJkKSB7XG4gICAgcmV0dXJuIG1vdmVTZWwodmlldywgcmFuZ2UgPT4ge1xuICAgICAgICBpZiAoIXJhbmdlLmVtcHR5KVxuICAgICAgICAgICAgcmV0dXJuIHJhbmdlRW5kKHJhbmdlLCBmb3J3YXJkKTtcbiAgICAgICAgbGV0IG1vdmVkID0gdmlldy5tb3ZlVmVydGljYWxseShyYW5nZSwgZm9yd2FyZCk7XG4gICAgICAgIHJldHVybiBtb3ZlZC5oZWFkICE9IHJhbmdlLmhlYWQgPyBtb3ZlZCA6IHZpZXcubW92ZVRvTGluZUJvdW5kYXJ5KHJhbmdlLCBmb3J3YXJkKTtcbiAgICB9KTtcbn1cbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBsaW5lIHVwLlxuKi9cbmNvbnN0IGN1cnNvckxpbmVVcCA9IHZpZXcgPT4gY3Vyc29yQnlMaW5lKHZpZXcsIGZhbHNlKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBsaW5lIGRvd24uXG4qL1xuY29uc3QgY3Vyc29yTGluZURvd24gPSB2aWV3ID0+IGN1cnNvckJ5TGluZSh2aWV3LCB0cnVlKTtcbmZ1bmN0aW9uIHBhZ2VJbmZvKHZpZXcpIHtcbiAgICBsZXQgc2VsZlNjcm9sbCA9IHZpZXcuc2Nyb2xsRE9NLmNsaWVudEhlaWdodCA8IHZpZXcuc2Nyb2xsRE9NLnNjcm9sbEhlaWdodCAtIDI7XG4gICAgbGV0IG1hcmdpblRvcCA9IDAsIG1hcmdpbkJvdHRvbSA9IDAsIGhlaWdodDtcbiAgICBpZiAoc2VsZlNjcm9sbCkge1xuICAgICAgICBmb3IgKGxldCBzb3VyY2Ugb2Ygdmlldy5zdGF0ZS5mYWNldChFZGl0b3JWaWV3LnNjcm9sbE1hcmdpbnMpKSB7XG4gICAgICAgICAgICBsZXQgbWFyZ2lucyA9IHNvdXJjZSh2aWV3KTtcbiAgICAgICAgICAgIGlmIChtYXJnaW5zID09PSBudWxsIHx8IG1hcmdpbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1hcmdpbnMudG9wKVxuICAgICAgICAgICAgICAgIG1hcmdpblRvcCA9IE1hdGgubWF4KG1hcmdpbnMgPT09IG51bGwgfHwgbWFyZ2lucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWFyZ2lucy50b3AsIG1hcmdpblRvcCk7XG4gICAgICAgICAgICBpZiAobWFyZ2lucyA9PT0gbnVsbCB8fCBtYXJnaW5zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYXJnaW5zLmJvdHRvbSlcbiAgICAgICAgICAgICAgICBtYXJnaW5Cb3R0b20gPSBNYXRoLm1heChtYXJnaW5zID09PSBudWxsIHx8IG1hcmdpbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1hcmdpbnMuYm90dG9tLCBtYXJnaW5Cb3R0b20pO1xuICAgICAgICB9XG4gICAgICAgIGhlaWdodCA9IHZpZXcuc2Nyb2xsRE9NLmNsaWVudEhlaWdodCAtIG1hcmdpblRvcCAtIG1hcmdpbkJvdHRvbTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGhlaWdodCA9ICh2aWV3LmRvbS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IHx8IHdpbmRvdykuaW5uZXJIZWlnaHQ7XG4gICAgfVxuICAgIHJldHVybiB7IG1hcmdpblRvcCwgbWFyZ2luQm90dG9tLCBzZWxmU2Nyb2xsLFxuICAgICAgICBoZWlnaHQ6IE1hdGgubWF4KHZpZXcuZGVmYXVsdExpbmVIZWlnaHQsIGhlaWdodCAtIDUpIH07XG59XG5mdW5jdGlvbiBjdXJzb3JCeVBhZ2UodmlldywgZm9yd2FyZCkge1xuICAgIGxldCBwYWdlID0gcGFnZUluZm8odmlldyk7XG4gICAgbGV0IHsgc3RhdGUgfSA9IHZpZXcsIHNlbGVjdGlvbiA9IHVwZGF0ZVNlbChzdGF0ZS5zZWxlY3Rpb24sIHJhbmdlID0+IHtcbiAgICAgICAgcmV0dXJuIHJhbmdlLmVtcHR5ID8gdmlldy5tb3ZlVmVydGljYWxseShyYW5nZSwgZm9yd2FyZCwgcGFnZS5oZWlnaHQpXG4gICAgICAgICAgICA6IHJhbmdlRW5kKHJhbmdlLCBmb3J3YXJkKTtcbiAgICB9KTtcbiAgICBpZiAoc2VsZWN0aW9uLmVxKHN0YXRlLnNlbGVjdGlvbikpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgZWZmZWN0O1xuICAgIGlmIChwYWdlLnNlbGZTY3JvbGwpIHtcbiAgICAgICAgbGV0IHN0YXJ0UG9zID0gdmlldy5jb29yZHNBdFBvcyhzdGF0ZS5zZWxlY3Rpb24ubWFpbi5oZWFkKTtcbiAgICAgICAgbGV0IHNjcm9sbFJlY3QgPSB2aWV3LnNjcm9sbERPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgbGV0IHNjcm9sbFRvcCA9IHNjcm9sbFJlY3QudG9wICsgcGFnZS5tYXJnaW5Ub3AsIHNjcm9sbEJvdHRvbSA9IHNjcm9sbFJlY3QuYm90dG9tIC0gcGFnZS5tYXJnaW5Cb3R0b207XG4gICAgICAgIGlmIChzdGFydFBvcyAmJiBzdGFydFBvcy50b3AgPiBzY3JvbGxUb3AgJiYgc3RhcnRQb3MuYm90dG9tIDwgc2Nyb2xsQm90dG9tKVxuICAgICAgICAgICAgZWZmZWN0ID0gRWRpdG9yVmlldy5zY3JvbGxJbnRvVmlldyhzZWxlY3Rpb24ubWFpbi5oZWFkLCB7IHk6IFwic3RhcnRcIiwgeU1hcmdpbjogc3RhcnRQb3MudG9wIC0gc2Nyb2xsVG9wIH0pO1xuICAgIH1cbiAgICB2aWV3LmRpc3BhdGNoKHNldFNlbChzdGF0ZSwgc2VsZWN0aW9uKSwgeyBlZmZlY3RzOiBlZmZlY3QgfSk7XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBvbmUgcGFnZSB1cC5cbiovXG5jb25zdCBjdXJzb3JQYWdlVXAgPSB2aWV3ID0+IGN1cnNvckJ5UGFnZSh2aWV3LCBmYWxzZSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBvbmUgcGFnZSBkb3duLlxuKi9cbmNvbnN0IGN1cnNvclBhZ2VEb3duID0gdmlldyA9PiBjdXJzb3JCeVBhZ2UodmlldywgdHJ1ZSk7XG5mdW5jdGlvbiBtb3ZlQnlMaW5lQm91bmRhcnkodmlldywgc3RhcnQsIGZvcndhcmQpIHtcbiAgICBsZXQgbGluZSA9IHZpZXcubGluZUJsb2NrQXQoc3RhcnQuaGVhZCksIG1vdmVkID0gdmlldy5tb3ZlVG9MaW5lQm91bmRhcnkoc3RhcnQsIGZvcndhcmQpO1xuICAgIGlmIChtb3ZlZC5oZWFkID09IHN0YXJ0LmhlYWQgJiYgbW92ZWQuaGVhZCAhPSAoZm9yd2FyZCA/IGxpbmUudG8gOiBsaW5lLmZyb20pKVxuICAgICAgICBtb3ZlZCA9IHZpZXcubW92ZVRvTGluZUJvdW5kYXJ5KHN0YXJ0LCBmb3J3YXJkLCBmYWxzZSk7XG4gICAgaWYgKCFmb3J3YXJkICYmIG1vdmVkLmhlYWQgPT0gbGluZS5mcm9tICYmIGxpbmUubGVuZ3RoKSB7XG4gICAgICAgIGxldCBzcGFjZSA9IC9eXFxzKi8uZXhlYyh2aWV3LnN0YXRlLnNsaWNlRG9jKGxpbmUuZnJvbSwgTWF0aC5taW4obGluZS5mcm9tICsgMTAwLCBsaW5lLnRvKSkpWzBdLmxlbmd0aDtcbiAgICAgICAgaWYgKHNwYWNlICYmIHN0YXJ0LmhlYWQgIT0gbGluZS5mcm9tICsgc3BhY2UpXG4gICAgICAgICAgICBtb3ZlZCA9IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IobGluZS5mcm9tICsgc3BhY2UpO1xuICAgIH1cbiAgICByZXR1cm4gbW92ZWQ7XG59XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiB0byB0aGUgbmV4dCBsaW5lIHdyYXAgcG9pbnQsIG9yIHRvIHRoZSBlbmQgb2ZcbnRoZSBsaW5lIGlmIHRoZXJlIGlzbid0IG9uZSBsZWZ0IG9uIHRoaXMgbGluZS5cbiovXG5jb25zdCBjdXJzb3JMaW5lQm91bmRhcnlGb3J3YXJkID0gdmlldyA9PiBtb3ZlU2VsKHZpZXcsIHJhbmdlID0+IG1vdmVCeUxpbmVCb3VuZGFyeSh2aWV3LCByYW5nZSwgdHJ1ZSkpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gdG8gcHJldmlvdXMgbGluZSB3cmFwIHBvaW50LCBvciBmYWlsaW5nIHRoYXQgdG9cbnRoZSBzdGFydCBvZiB0aGUgbGluZS4gSWYgdGhlIGxpbmUgaXMgaW5kZW50ZWQsIGFuZCB0aGUgY3Vyc29yXG5pc24ndCBhbHJlYWR5IGF0IHRoZSBlbmQgb2YgdGhlIGluZGVudGF0aW9uLCB0aGlzIHdpbGwgbW92ZSB0byB0aGVcbmVuZCBvZiB0aGUgaW5kZW50YXRpb24gaW5zdGVhZCBvZiB0aGUgc3RhcnQgb2YgdGhlIGxpbmUuXG4qL1xuY29uc3QgY3Vyc29yTGluZUJvdW5kYXJ5QmFja3dhcmQgPSB2aWV3ID0+IG1vdmVTZWwodmlldywgcmFuZ2UgPT4gbW92ZUJ5TGluZUJvdW5kYXJ5KHZpZXcsIHJhbmdlLCBmYWxzZSkpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIGxpbmUgd3JhcCBwb2ludCB0byB0aGUgbGVmdC5cbiovXG5jb25zdCBjdXJzb3JMaW5lQm91bmRhcnlMZWZ0ID0gdmlldyA9PiBtb3ZlU2VsKHZpZXcsIHJhbmdlID0+IG1vdmVCeUxpbmVCb3VuZGFyeSh2aWV3LCByYW5nZSwgIWx0ckF0Q3Vyc29yKHZpZXcpKSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBvbmUgbGluZSB3cmFwIHBvaW50IHRvIHRoZSByaWdodC5cbiovXG5jb25zdCBjdXJzb3JMaW5lQm91bmRhcnlSaWdodCA9IHZpZXcgPT4gbW92ZVNlbCh2aWV3LCByYW5nZSA9PiBtb3ZlQnlMaW5lQm91bmRhcnkodmlldywgcmFuZ2UsIGx0ckF0Q3Vyc29yKHZpZXcpKSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiB0byB0aGUgc3RhcnQgb2YgdGhlIGxpbmUuXG4qL1xuY29uc3QgY3Vyc29yTGluZVN0YXJ0ID0gdmlldyA9PiBtb3ZlU2VsKHZpZXcsIHJhbmdlID0+IEVkaXRvclNlbGVjdGlvbi5jdXJzb3Iodmlldy5saW5lQmxvY2tBdChyYW5nZS5oZWFkKS5mcm9tLCAxKSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiB0byB0aGUgZW5kIG9mIHRoZSBsaW5lLlxuKi9cbmNvbnN0IGN1cnNvckxpbmVFbmQgPSB2aWV3ID0+IG1vdmVTZWwodmlldywgcmFuZ2UgPT4gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcih2aWV3LmxpbmVCbG9ja0F0KHJhbmdlLmhlYWQpLnRvLCAtMSkpO1xuZnVuY3Rpb24gdG9NYXRjaGluZ0JyYWNrZXQoc3RhdGUsIGRpc3BhdGNoLCBleHRlbmQpIHtcbiAgICBsZXQgZm91bmQgPSBmYWxzZSwgc2VsZWN0aW9uID0gdXBkYXRlU2VsKHN0YXRlLnNlbGVjdGlvbiwgcmFuZ2UgPT4ge1xuICAgICAgICBsZXQgbWF0Y2hpbmcgPSBtYXRjaEJyYWNrZXRzKHN0YXRlLCByYW5nZS5oZWFkLCAtMSlcbiAgICAgICAgICAgIHx8IG1hdGNoQnJhY2tldHMoc3RhdGUsIHJhbmdlLmhlYWQsIDEpXG4gICAgICAgICAgICB8fCAocmFuZ2UuaGVhZCA+IDAgJiYgbWF0Y2hCcmFja2V0cyhzdGF0ZSwgcmFuZ2UuaGVhZCAtIDEsIDEpKVxuICAgICAgICAgICAgfHwgKHJhbmdlLmhlYWQgPCBzdGF0ZS5kb2MubGVuZ3RoICYmIG1hdGNoQnJhY2tldHMoc3RhdGUsIHJhbmdlLmhlYWQgKyAxLCAtMSkpO1xuICAgICAgICBpZiAoIW1hdGNoaW5nIHx8ICFtYXRjaGluZy5lbmQpXG4gICAgICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgbGV0IGhlYWQgPSBtYXRjaGluZy5zdGFydC5mcm9tID09IHJhbmdlLmhlYWQgPyBtYXRjaGluZy5lbmQudG8gOiBtYXRjaGluZy5lbmQuZnJvbTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZCA/IEVkaXRvclNlbGVjdGlvbi5yYW5nZShyYW5nZS5hbmNob3IsIGhlYWQpIDogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihoZWFkKTtcbiAgICB9KTtcbiAgICBpZiAoIWZvdW5kKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZGlzcGF0Y2goc2V0U2VsKHN0YXRlLCBzZWxlY3Rpb24pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIHRvIHRoZSBicmFja2V0IG1hdGNoaW5nIHRoZSBvbmUgaXQgaXMgY3VycmVudGx5XG5vbiwgaWYgYW55LlxuKi9cbmNvbnN0IGN1cnNvck1hdGNoaW5nQnJhY2tldCA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB0b01hdGNoaW5nQnJhY2tldChzdGF0ZSwgZGlzcGF0Y2gsIGZhbHNlKTtcbi8qKlxuRXh0ZW5kIHRoZSBzZWxlY3Rpb24gdG8gdGhlIGJyYWNrZXQgbWF0Y2hpbmcgdGhlIG9uZSB0aGUgc2VsZWN0aW9uXG5oZWFkIGlzIGN1cnJlbnRseSBvbiwgaWYgYW55LlxuKi9cbmNvbnN0IHNlbGVjdE1hdGNoaW5nQnJhY2tldCA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB0b01hdGNoaW5nQnJhY2tldChzdGF0ZSwgZGlzcGF0Y2gsIHRydWUpO1xuZnVuY3Rpb24gZXh0ZW5kU2VsKHZpZXcsIGhvdykge1xuICAgIGxldCBzZWxlY3Rpb24gPSB1cGRhdGVTZWwodmlldy5zdGF0ZS5zZWxlY3Rpb24sIHJhbmdlID0+IHtcbiAgICAgICAgbGV0IGhlYWQgPSBob3cocmFuZ2UpO1xuICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHJhbmdlLmFuY2hvciwgaGVhZC5oZWFkLCBoZWFkLmdvYWxDb2x1bW4sIGhlYWQuYmlkaUxldmVsIHx8IHVuZGVmaW5lZCk7XG4gICAgfSk7XG4gICAgaWYgKHNlbGVjdGlvbi5lcSh2aWV3LnN0YXRlLnNlbGVjdGlvbikpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB2aWV3LmRpc3BhdGNoKHNldFNlbCh2aWV3LnN0YXRlLCBzZWxlY3Rpb24pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHNlbGVjdEJ5Q2hhcih2aWV3LCBmb3J3YXJkKSB7XG4gICAgcmV0dXJuIGV4dGVuZFNlbCh2aWV3LCByYW5nZSA9PiB2aWV3Lm1vdmVCeUNoYXIocmFuZ2UsIGZvcndhcmQpKTtcbn1cbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGNoYXJhY3RlciB0byB0aGUgbGVmdCwgd2hpbGUgbGVhdmluZ1xudGhlIGFuY2hvciBpbiBwbGFjZS5cbiovXG5jb25zdCBzZWxlY3RDaGFyTGVmdCA9IHZpZXcgPT4gc2VsZWN0QnlDaGFyKHZpZXcsICFsdHJBdEN1cnNvcih2aWV3KSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBjaGFyYWN0ZXIgdG8gdGhlIHJpZ2h0LlxuKi9cbmNvbnN0IHNlbGVjdENoYXJSaWdodCA9IHZpZXcgPT4gc2VsZWN0QnlDaGFyKHZpZXcsIGx0ckF0Q3Vyc29yKHZpZXcpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGNoYXJhY3RlciBmb3J3YXJkLlxuKi9cbmNvbnN0IHNlbGVjdENoYXJGb3J3YXJkID0gdmlldyA9PiBzZWxlY3RCeUNoYXIodmlldywgdHJ1ZSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBjaGFyYWN0ZXIgYmFja3dhcmQuXG4qL1xuY29uc3Qgc2VsZWN0Q2hhckJhY2t3YXJkID0gdmlldyA9PiBzZWxlY3RCeUNoYXIodmlldywgZmFsc2UpO1xuZnVuY3Rpb24gc2VsZWN0QnlHcm91cCh2aWV3LCBmb3J3YXJkKSB7XG4gICAgcmV0dXJuIGV4dGVuZFNlbCh2aWV3LCByYW5nZSA9PiB2aWV3Lm1vdmVCeUdyb3VwKHJhbmdlLCBmb3J3YXJkKSk7XG59XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBbZ3JvdXBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yR3JvdXBMZWZ0KSB0b1xudGhlIGxlZnQuXG4qL1xuY29uc3Qgc2VsZWN0R3JvdXBMZWZ0ID0gdmlldyA9PiBzZWxlY3RCeUdyb3VwKHZpZXcsICFsdHJBdEN1cnNvcih2aWV3KSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBncm91cCB0byB0aGUgcmlnaHQuXG4qL1xuY29uc3Qgc2VsZWN0R3JvdXBSaWdodCA9IHZpZXcgPT4gc2VsZWN0QnlHcm91cCh2aWV3LCBsdHJBdEN1cnNvcih2aWV3KSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBncm91cCBmb3J3YXJkLlxuKi9cbmNvbnN0IHNlbGVjdEdyb3VwRm9yd2FyZCA9IHZpZXcgPT4gc2VsZWN0QnlHcm91cCh2aWV3LCB0cnVlKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGdyb3VwIGJhY2t3YXJkLlxuKi9cbmNvbnN0IHNlbGVjdEdyb3VwQmFja3dhcmQgPSB2aWV3ID0+IHNlbGVjdEJ5R3JvdXAodmlldywgZmFsc2UpO1xuZnVuY3Rpb24gc2VsZWN0QnlTdWJ3b3JkKHZpZXcsIGZvcndhcmQpIHtcbiAgICByZXR1cm4gZXh0ZW5kU2VsKHZpZXcsIHJhbmdlID0+IG1vdmVCeVN1YndvcmQodmlldywgcmFuZ2UsIGZvcndhcmQpKTtcbn1cbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGdyb3VwIG9yIGNhbWVsLWNhc2Ugc3Vid29yZCBmb3J3YXJkLlxuKi9cbmNvbnN0IHNlbGVjdFN1YndvcmRGb3J3YXJkID0gdmlldyA9PiBzZWxlY3RCeVN1YndvcmQodmlldywgdHJ1ZSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBncm91cCBvciBzdWJ3b3JkIGJhY2t3YXJkLlxuKi9cbmNvbnN0IHNlbGVjdFN1YndvcmRCYWNrd2FyZCA9IHZpZXcgPT4gc2VsZWN0QnlTdWJ3b3JkKHZpZXcsIGZhbHNlKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb3ZlciB0aGUgbmV4dCBzeW50YWN0aWMgZWxlbWVudCB0byB0aGUgbGVmdC5cbiovXG5jb25zdCBzZWxlY3RTeW50YXhMZWZ0ID0gdmlldyA9PiBleHRlbmRTZWwodmlldywgcmFuZ2UgPT4gbW92ZUJ5U3ludGF4KHZpZXcuc3RhdGUsIHJhbmdlLCAhbHRyQXRDdXJzb3IodmlldykpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb3ZlciB0aGUgbmV4dCBzeW50YWN0aWMgZWxlbWVudCB0byB0aGUgcmlnaHQuXG4qL1xuY29uc3Qgc2VsZWN0U3ludGF4UmlnaHQgPSB2aWV3ID0+IGV4dGVuZFNlbCh2aWV3LCByYW5nZSA9PiBtb3ZlQnlTeW50YXgodmlldy5zdGF0ZSwgcmFuZ2UsIGx0ckF0Q3Vyc29yKHZpZXcpKSk7XG5mdW5jdGlvbiBzZWxlY3RCeUxpbmUodmlldywgZm9yd2FyZCkge1xuICAgIHJldHVybiBleHRlbmRTZWwodmlldywgcmFuZ2UgPT4gdmlldy5tb3ZlVmVydGljYWxseShyYW5nZSwgZm9yd2FyZCkpO1xufVxuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvbmUgbGluZSB1cC5cbiovXG5jb25zdCBzZWxlY3RMaW5lVXAgPSB2aWV3ID0+IHNlbGVjdEJ5TGluZSh2aWV3LCBmYWxzZSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBsaW5lIGRvd24uXG4qL1xuY29uc3Qgc2VsZWN0TGluZURvd24gPSB2aWV3ID0+IHNlbGVjdEJ5TGluZSh2aWV3LCB0cnVlKTtcbmZ1bmN0aW9uIHNlbGVjdEJ5UGFnZSh2aWV3LCBmb3J3YXJkKSB7XG4gICAgcmV0dXJuIGV4dGVuZFNlbCh2aWV3LCByYW5nZSA9PiB2aWV3Lm1vdmVWZXJ0aWNhbGx5KHJhbmdlLCBmb3J3YXJkLCBwYWdlSW5mbyh2aWV3KS5oZWlnaHQpKTtcbn1cbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIHBhZ2UgdXAuXG4qL1xuY29uc3Qgc2VsZWN0UGFnZVVwID0gdmlldyA9PiBzZWxlY3RCeVBhZ2UodmlldywgZmFsc2UpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvbmUgcGFnZSBkb3duLlxuKi9cbmNvbnN0IHNlbGVjdFBhZ2VEb3duID0gdmlldyA9PiBzZWxlY3RCeVBhZ2UodmlldywgdHJ1ZSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIHRvIHRoZSBuZXh0IGxpbmUgYm91bmRhcnkuXG4qL1xuY29uc3Qgc2VsZWN0TGluZUJvdW5kYXJ5Rm9yd2FyZCA9IHZpZXcgPT4gZXh0ZW5kU2VsKHZpZXcsIHJhbmdlID0+IG1vdmVCeUxpbmVCb3VuZGFyeSh2aWV3LCByYW5nZSwgdHJ1ZSkpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCB0byB0aGUgcHJldmlvdXMgbGluZSBib3VuZGFyeS5cbiovXG5jb25zdCBzZWxlY3RMaW5lQm91bmRhcnlCYWNrd2FyZCA9IHZpZXcgPT4gZXh0ZW5kU2VsKHZpZXcsIHJhbmdlID0+IG1vdmVCeUxpbmVCb3VuZGFyeSh2aWV3LCByYW5nZSwgZmFsc2UpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGxpbmUgYm91bmRhcnkgdG8gdGhlIGxlZnQuXG4qL1xuY29uc3Qgc2VsZWN0TGluZUJvdW5kYXJ5TGVmdCA9IHZpZXcgPT4gZXh0ZW5kU2VsKHZpZXcsIHJhbmdlID0+IG1vdmVCeUxpbmVCb3VuZGFyeSh2aWV3LCByYW5nZSwgIWx0ckF0Q3Vyc29yKHZpZXcpKSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBsaW5lIGJvdW5kYXJ5IHRvIHRoZSByaWdodC5cbiovXG5jb25zdCBzZWxlY3RMaW5lQm91bmRhcnlSaWdodCA9IHZpZXcgPT4gZXh0ZW5kU2VsKHZpZXcsIHJhbmdlID0+IG1vdmVCeUxpbmVCb3VuZGFyeSh2aWV3LCByYW5nZSwgbHRyQXRDdXJzb3IodmlldykpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgdG8gdGhlIHN0YXJ0IG9mIHRoZSBsaW5lLlxuKi9cbmNvbnN0IHNlbGVjdExpbmVTdGFydCA9IHZpZXcgPT4gZXh0ZW5kU2VsKHZpZXcsIHJhbmdlID0+IEVkaXRvclNlbGVjdGlvbi5jdXJzb3Iodmlldy5saW5lQmxvY2tBdChyYW5nZS5oZWFkKS5mcm9tKSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIHRvIHRoZSBlbmQgb2YgdGhlIGxpbmUuXG4qL1xuY29uc3Qgc2VsZWN0TGluZUVuZCA9IHZpZXcgPT4gZXh0ZW5kU2VsKHZpZXcsIHJhbmdlID0+IEVkaXRvclNlbGVjdGlvbi5jdXJzb3Iodmlldy5saW5lQmxvY2tBdChyYW5nZS5oZWFkKS50bykpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gdG8gdGhlIHN0YXJ0IG9mIHRoZSBkb2N1bWVudC5cbiovXG5jb25zdCBjdXJzb3JEb2NTdGFydCA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgZGlzcGF0Y2goc2V0U2VsKHN0YXRlLCB7IGFuY2hvcjogMCB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gdG8gdGhlIGVuZCBvZiB0aGUgZG9jdW1lbnQuXG4qL1xuY29uc3QgY3Vyc29yRG9jRW5kID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBkaXNwYXRjaChzZXRTZWwoc3RhdGUsIHsgYW5jaG9yOiBzdGF0ZS5kb2MubGVuZ3RoIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIHRvIHRoZSBzdGFydCBvZiB0aGUgZG9jdW1lbnQuXG4qL1xuY29uc3Qgc2VsZWN0RG9jU3RhcnQgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGRpc3BhdGNoKHNldFNlbChzdGF0ZSwgeyBhbmNob3I6IHN0YXRlLnNlbGVjdGlvbi5tYWluLmFuY2hvciwgaGVhZDogMCB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCB0byB0aGUgZW5kIG9mIHRoZSBkb2N1bWVudC5cbiovXG5jb25zdCBzZWxlY3REb2NFbmQgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGRpc3BhdGNoKHNldFNlbChzdGF0ZSwgeyBhbmNob3I6IHN0YXRlLnNlbGVjdGlvbi5tYWluLmFuY2hvciwgaGVhZDogc3RhdGUuZG9jLmxlbmd0aCB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5TZWxlY3QgdGhlIGVudGlyZSBkb2N1bWVudC5cbiovXG5jb25zdCBzZWxlY3RBbGwgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZSh7IHNlbGVjdGlvbjogeyBhbmNob3I6IDAsIGhlYWQ6IHN0YXRlLmRvYy5sZW5ndGggfSwgdXNlckV2ZW50OiBcInNlbGVjdFwiIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbkV4cGFuZCB0aGUgc2VsZWN0aW9uIHRvIGNvdmVyIGVudGlyZSBsaW5lcy5cbiovXG5jb25zdCBzZWxlY3RMaW5lID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBsZXQgcmFuZ2VzID0gc2VsZWN0ZWRMaW5lQmxvY2tzKHN0YXRlKS5tYXAoKHsgZnJvbSwgdG8gfSkgPT4gRWRpdG9yU2VsZWN0aW9uLnJhbmdlKGZyb20sIE1hdGgubWluKHRvICsgMSwgc3RhdGUuZG9jLmxlbmd0aCkpKTtcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoeyBzZWxlY3Rpb246IEVkaXRvclNlbGVjdGlvbi5jcmVhdGUocmFuZ2VzKSwgdXNlckV2ZW50OiBcInNlbGVjdFwiIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcblNlbGVjdCB0aGUgbmV4dCBzeW50YWN0aWMgY29uc3RydWN0IHRoYXQgaXMgbGFyZ2VyIHRoYW4gdGhlXG5zZWxlY3Rpb24uIE5vdGUgdGhhdCB0aGlzIHdpbGwgb25seSB3b3JrIGluc29mYXIgYXMgdGhlIGxhbmd1YWdlXG5bcHJvdmlkZXJdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UubGFuZ3VhZ2UpIHlvdSB1c2UgYnVpbGRzIHVwIGEgZnVsbFxuc3ludGF4IHRyZWUuXG4qL1xuY29uc3Qgc2VsZWN0UGFyZW50U3ludGF4ID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBsZXQgc2VsZWN0aW9uID0gdXBkYXRlU2VsKHN0YXRlLnNlbGVjdGlvbiwgcmFuZ2UgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGxldCBzdGFjayA9IHN5bnRheFRyZWUoc3RhdGUpLnJlc29sdmVTdGFjayhyYW5nZS5mcm9tLCAxKTtcbiAgICAgICAgZm9yIChsZXQgY3VyID0gc3RhY2s7IGN1cjsgY3VyID0gY3VyLm5leHQpIHtcbiAgICAgICAgICAgIGxldCB7IG5vZGUgfSA9IGN1cjtcbiAgICAgICAgICAgIGlmICgoKG5vZGUuZnJvbSA8IHJhbmdlLmZyb20gJiYgbm9kZS50byA+PSByYW5nZS50bykgfHxcbiAgICAgICAgICAgICAgICAobm9kZS50byA+IHJhbmdlLnRvICYmIG5vZGUuZnJvbSA8PSByYW5nZS5mcm9tKSkgJiZcbiAgICAgICAgICAgICAgICAoKF9hID0gbm9kZS5wYXJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wYXJlbnQpKVxuICAgICAgICAgICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24ucmFuZ2Uobm9kZS50bywgbm9kZS5mcm9tKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgfSk7XG4gICAgZGlzcGF0Y2goc2V0U2VsKHN0YXRlLCBzZWxlY3Rpb24pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcblNpbXBsaWZ5IHRoZSBjdXJyZW50IHNlbGVjdGlvbi4gV2hlbiBtdWx0aXBsZSByYW5nZXMgYXJlIHNlbGVjdGVkLFxucmVkdWNlIGl0IHRvIGl0cyBtYWluIHJhbmdlLiBPdGhlcndpc2UsIGlmIHRoZSBzZWxlY3Rpb24gaXNcbm5vbi1lbXB0eSwgY29udmVydCBpdCB0byBhIGN1cnNvciBzZWxlY3Rpb24uXG4qL1xuY29uc3Qgc2ltcGxpZnlTZWxlY3Rpb24gPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGxldCBjdXIgPSBzdGF0ZS5zZWxlY3Rpb24sIHNlbGVjdGlvbiA9IG51bGw7XG4gICAgaWYgKGN1ci5yYW5nZXMubGVuZ3RoID4gMSlcbiAgICAgICAgc2VsZWN0aW9uID0gRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShbY3VyLm1haW5dKTtcbiAgICBlbHNlIGlmICghY3VyLm1haW4uZW1wdHkpXG4gICAgICAgIHNlbGVjdGlvbiA9IEVkaXRvclNlbGVjdGlvbi5jcmVhdGUoW0VkaXRvclNlbGVjdGlvbi5jdXJzb3IoY3VyLm1haW4uaGVhZCldKTtcbiAgICBpZiAoIXNlbGVjdGlvbilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGRpc3BhdGNoKHNldFNlbChzdGF0ZSwgc2VsZWN0aW9uKSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuZnVuY3Rpb24gZGVsZXRlQnkodGFyZ2V0LCBieSkge1xuICAgIGlmICh0YXJnZXQuc3RhdGUucmVhZE9ubHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgZXZlbnQgPSBcImRlbGV0ZS5zZWxlY3Rpb25cIiwgeyBzdGF0ZSB9ID0gdGFyZ2V0O1xuICAgIGxldCBjaGFuZ2VzID0gc3RhdGUuY2hhbmdlQnlSYW5nZShyYW5nZSA9PiB7XG4gICAgICAgIGxldCB7IGZyb20sIHRvIH0gPSByYW5nZTtcbiAgICAgICAgaWYgKGZyb20gPT0gdG8pIHtcbiAgICAgICAgICAgIGxldCB0b3dhcmRzID0gYnkocmFuZ2UpO1xuICAgICAgICAgICAgaWYgKHRvd2FyZHMgPCBmcm9tKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQgPSBcImRlbGV0ZS5iYWNrd2FyZFwiO1xuICAgICAgICAgICAgICAgIHRvd2FyZHMgPSBza2lwQXRvbWljKHRhcmdldCwgdG93YXJkcywgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodG93YXJkcyA+IGZyb20pIHtcbiAgICAgICAgICAgICAgICBldmVudCA9IFwiZGVsZXRlLmZvcndhcmRcIjtcbiAgICAgICAgICAgICAgICB0b3dhcmRzID0gc2tpcEF0b21pYyh0YXJnZXQsIHRvd2FyZHMsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnJvbSA9IE1hdGgubWluKGZyb20sIHRvd2FyZHMpO1xuICAgICAgICAgICAgdG8gPSBNYXRoLm1heCh0bywgdG93YXJkcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmcm9tID0gc2tpcEF0b21pYyh0YXJnZXQsIGZyb20sIGZhbHNlKTtcbiAgICAgICAgICAgIHRvID0gc2tpcEF0b21pYyh0YXJnZXQsIHRvLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnJvbSA9PSB0byA/IHsgcmFuZ2UgfSA6IHsgY2hhbmdlczogeyBmcm9tLCB0byB9LCByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihmcm9tLCBmcm9tIDwgcmFuZ2UuaGVhZCA/IC0xIDogMSkgfTtcbiAgICB9KTtcbiAgICBpZiAoY2hhbmdlcy5jaGFuZ2VzLmVtcHR5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdGFyZ2V0LmRpc3BhdGNoKHN0YXRlLnVwZGF0ZShjaGFuZ2VzLCB7XG4gICAgICAgIHNjcm9sbEludG9WaWV3OiB0cnVlLFxuICAgICAgICB1c2VyRXZlbnQ6IGV2ZW50LFxuICAgICAgICBlZmZlY3RzOiBldmVudCA9PSBcImRlbGV0ZS5zZWxlY3Rpb25cIiA/IEVkaXRvclZpZXcuYW5ub3VuY2Uub2Yoc3RhdGUucGhyYXNlKFwiU2VsZWN0aW9uIGRlbGV0ZWRcIikpIDogdW5kZWZpbmVkXG4gICAgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gc2tpcEF0b21pYyh0YXJnZXQsIHBvcywgZm9yd2FyZCkge1xuICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBFZGl0b3JWaWV3KVxuICAgICAgICBmb3IgKGxldCByYW5nZXMgb2YgdGFyZ2V0LnN0YXRlLmZhY2V0KEVkaXRvclZpZXcuYXRvbWljUmFuZ2VzKS5tYXAoZiA9PiBmKHRhcmdldCkpKVxuICAgICAgICAgICAgcmFuZ2VzLmJldHdlZW4ocG9zLCBwb3MsIChmcm9tLCB0bykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChmcm9tIDwgcG9zICYmIHRvID4gcG9zKVxuICAgICAgICAgICAgICAgICAgICBwb3MgPSBmb3J3YXJkID8gdG8gOiBmcm9tO1xuICAgICAgICAgICAgfSk7XG4gICAgcmV0dXJuIHBvcztcbn1cbmNvbnN0IGRlbGV0ZUJ5Q2hhciA9ICh0YXJnZXQsIGZvcndhcmQpID0+IGRlbGV0ZUJ5KHRhcmdldCwgcmFuZ2UgPT4ge1xuICAgIGxldCBwb3MgPSByYW5nZS5mcm9tLCB7IHN0YXRlIH0gPSB0YXJnZXQsIGxpbmUgPSBzdGF0ZS5kb2MubGluZUF0KHBvcyksIGJlZm9yZSwgdGFyZ2V0UG9zO1xuICAgIGlmICghZm9yd2FyZCAmJiBwb3MgPiBsaW5lLmZyb20gJiYgcG9zIDwgbGluZS5mcm9tICsgMjAwICYmXG4gICAgICAgICEvW14gXFx0XS8udGVzdChiZWZvcmUgPSBsaW5lLnRleHQuc2xpY2UoMCwgcG9zIC0gbGluZS5mcm9tKSkpIHtcbiAgICAgICAgaWYgKGJlZm9yZVtiZWZvcmUubGVuZ3RoIC0gMV0gPT0gXCJcXHRcIilcbiAgICAgICAgICAgIHJldHVybiBwb3MgLSAxO1xuICAgICAgICBsZXQgY29sID0gY291bnRDb2x1bW4oYmVmb3JlLCBzdGF0ZS50YWJTaXplKSwgZHJvcCA9IGNvbCAlIGdldEluZGVudFVuaXQoc3RhdGUpIHx8IGdldEluZGVudFVuaXQoc3RhdGUpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRyb3AgJiYgYmVmb3JlW2JlZm9yZS5sZW5ndGggLSAxIC0gaV0gPT0gXCIgXCI7IGkrKylcbiAgICAgICAgICAgIHBvcy0tO1xuICAgICAgICB0YXJnZXRQb3MgPSBwb3M7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0YXJnZXRQb3MgPSBmaW5kQ2x1c3RlckJyZWFrKGxpbmUudGV4dCwgcG9zIC0gbGluZS5mcm9tLCBmb3J3YXJkLCBmb3J3YXJkKSArIGxpbmUuZnJvbTtcbiAgICAgICAgaWYgKHRhcmdldFBvcyA9PSBwb3MgJiYgbGluZS5udW1iZXIgIT0gKGZvcndhcmQgPyBzdGF0ZS5kb2MubGluZXMgOiAxKSlcbiAgICAgICAgICAgIHRhcmdldFBvcyArPSBmb3J3YXJkID8gMSA6IC0xO1xuICAgICAgICBlbHNlIGlmICghZm9yd2FyZCAmJiAvW1xcdWZlMDAtXFx1ZmUwZl0vLnRlc3QobGluZS50ZXh0LnNsaWNlKHRhcmdldFBvcyAtIGxpbmUuZnJvbSwgcG9zIC0gbGluZS5mcm9tKSkpXG4gICAgICAgICAgICB0YXJnZXRQb3MgPSBmaW5kQ2x1c3RlckJyZWFrKGxpbmUudGV4dCwgdGFyZ2V0UG9zIC0gbGluZS5mcm9tLCBmYWxzZSwgZmFsc2UpO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0UG9zO1xufSk7XG4vKipcbkRlbGV0ZSB0aGUgc2VsZWN0aW9uLCBvciwgZm9yIGN1cnNvciBzZWxlY3Rpb25zLCB0aGUgY2hhcmFjdGVyXG5iZWZvcmUgdGhlIGN1cnNvci5cbiovXG5jb25zdCBkZWxldGVDaGFyQmFja3dhcmQgPSB2aWV3ID0+IGRlbGV0ZUJ5Q2hhcih2aWV3LCBmYWxzZSk7XG4vKipcbkRlbGV0ZSB0aGUgc2VsZWN0aW9uIG9yIHRoZSBjaGFyYWN0ZXIgYWZ0ZXIgdGhlIGN1cnNvci5cbiovXG5jb25zdCBkZWxldGVDaGFyRm9yd2FyZCA9IHZpZXcgPT4gZGVsZXRlQnlDaGFyKHZpZXcsIHRydWUpO1xuY29uc3QgZGVsZXRlQnlHcm91cCA9ICh0YXJnZXQsIGZvcndhcmQpID0+IGRlbGV0ZUJ5KHRhcmdldCwgcmFuZ2UgPT4ge1xuICAgIGxldCBwb3MgPSByYW5nZS5oZWFkLCB7IHN0YXRlIH0gPSB0YXJnZXQsIGxpbmUgPSBzdGF0ZS5kb2MubGluZUF0KHBvcyk7XG4gICAgbGV0IGNhdGVnb3JpemUgPSBzdGF0ZS5jaGFyQ2F0ZWdvcml6ZXIocG9zKTtcbiAgICBmb3IgKGxldCBjYXQgPSBudWxsOzspIHtcbiAgICAgICAgaWYgKHBvcyA9PSAoZm9yd2FyZCA/IGxpbmUudG8gOiBsaW5lLmZyb20pKSB7XG4gICAgICAgICAgICBpZiAocG9zID09IHJhbmdlLmhlYWQgJiYgbGluZS5udW1iZXIgIT0gKGZvcndhcmQgPyBzdGF0ZS5kb2MubGluZXMgOiAxKSlcbiAgICAgICAgICAgICAgICBwb3MgKz0gZm9yd2FyZCA/IDEgOiAtMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGxldCBuZXh0ID0gZmluZENsdXN0ZXJCcmVhayhsaW5lLnRleHQsIHBvcyAtIGxpbmUuZnJvbSwgZm9yd2FyZCkgKyBsaW5lLmZyb207XG4gICAgICAgIGxldCBuZXh0Q2hhciA9IGxpbmUudGV4dC5zbGljZShNYXRoLm1pbihwb3MsIG5leHQpIC0gbGluZS5mcm9tLCBNYXRoLm1heChwb3MsIG5leHQpIC0gbGluZS5mcm9tKTtcbiAgICAgICAgbGV0IG5leHRDYXQgPSBjYXRlZ29yaXplKG5leHRDaGFyKTtcbiAgICAgICAgaWYgKGNhdCAhPSBudWxsICYmIG5leHRDYXQgIT0gY2F0KVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGlmIChuZXh0Q2hhciAhPSBcIiBcIiB8fCBwb3MgIT0gcmFuZ2UuaGVhZClcbiAgICAgICAgICAgIGNhdCA9IG5leHRDYXQ7XG4gICAgICAgIHBvcyA9IG5leHQ7XG4gICAgfVxuICAgIHJldHVybiBwb3M7XG59KTtcbi8qKlxuRGVsZXRlIHRoZSBzZWxlY3Rpb24gb3IgYmFja3dhcmQgdW50aWwgdGhlIGVuZCBvZiB0aGUgbmV4dFxuW2dyb3VwXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5tb3ZlQnlHcm91cCksIG9ubHkgc2tpcHBpbmcgZ3JvdXBzIG9mXG53aGl0ZXNwYWNlIHdoZW4gdGhleSBjb25zaXN0IG9mIGEgc2luZ2xlIHNwYWNlLlxuKi9cbmNvbnN0IGRlbGV0ZUdyb3VwQmFja3dhcmQgPSB0YXJnZXQgPT4gZGVsZXRlQnlHcm91cCh0YXJnZXQsIGZhbHNlKTtcbi8qKlxuRGVsZXRlIHRoZSBzZWxlY3Rpb24gb3IgZm9yd2FyZCB1bnRpbCB0aGUgZW5kIG9mIHRoZSBuZXh0IGdyb3VwLlxuKi9cbmNvbnN0IGRlbGV0ZUdyb3VwRm9yd2FyZCA9IHRhcmdldCA9PiBkZWxldGVCeUdyb3VwKHRhcmdldCwgdHJ1ZSk7XG4vKipcbkRlbGV0ZSB0aGUgc2VsZWN0aW9uLCBvciwgaWYgaXQgaXMgYSBjdXJzb3Igc2VsZWN0aW9uLCBkZWxldGUgdG9cbnRoZSBlbmQgb2YgdGhlIGxpbmUuIElmIHRoZSBjdXJzb3IgaXMgZGlyZWN0bHkgYXQgdGhlIGVuZCBvZiB0aGVcbmxpbmUsIGRlbGV0ZSB0aGUgbGluZSBicmVhayBhZnRlciBpdC5cbiovXG5jb25zdCBkZWxldGVUb0xpbmVFbmQgPSB2aWV3ID0+IGRlbGV0ZUJ5KHZpZXcsIHJhbmdlID0+IHtcbiAgICBsZXQgbGluZUVuZCA9IHZpZXcubGluZUJsb2NrQXQocmFuZ2UuaGVhZCkudG87XG4gICAgcmV0dXJuIHJhbmdlLmhlYWQgPCBsaW5lRW5kID8gbGluZUVuZCA6IE1hdGgubWluKHZpZXcuc3RhdGUuZG9jLmxlbmd0aCwgcmFuZ2UuaGVhZCArIDEpO1xufSk7XG4vKipcbkRlbGV0ZSB0aGUgc2VsZWN0aW9uLCBvciwgaWYgaXQgaXMgYSBjdXJzb3Igc2VsZWN0aW9uLCBkZWxldGUgdG9cbnRoZSBzdGFydCBvZiB0aGUgbGluZS4gSWYgdGhlIGN1cnNvciBpcyBkaXJlY3RseSBhdCB0aGUgc3RhcnQgb2YgdGhlXG5saW5lLCBkZWxldGUgdGhlIGxpbmUgYnJlYWsgYmVmb3JlIGl0LlxuKi9cbmNvbnN0IGRlbGV0ZVRvTGluZVN0YXJ0ID0gdmlldyA9PiBkZWxldGVCeSh2aWV3LCByYW5nZSA9PiB7XG4gICAgbGV0IGxpbmVTdGFydCA9IHZpZXcubGluZUJsb2NrQXQocmFuZ2UuaGVhZCkuZnJvbTtcbiAgICByZXR1cm4gcmFuZ2UuaGVhZCA+IGxpbmVTdGFydCA/IGxpbmVTdGFydCA6IE1hdGgubWF4KDAsIHJhbmdlLmhlYWQgLSAxKTtcbn0pO1xuLyoqXG5EZWxldGUgdGhlIHNlbGVjdGlvbiwgb3IsIGlmIGl0IGlzIGEgY3Vyc29yIHNlbGVjdGlvbiwgZGVsZXRlIHRvXG50aGUgc3RhcnQgb2YgdGhlIGxpbmUgb3IgdGhlIG5leHQgbGluZSB3cmFwIGJlZm9yZSB0aGUgY3Vyc29yLlxuKi9cbmNvbnN0IGRlbGV0ZUxpbmVCb3VuZGFyeUJhY2t3YXJkID0gdmlldyA9PiBkZWxldGVCeSh2aWV3LCByYW5nZSA9PiB7XG4gICAgbGV0IGxpbmVTdGFydCA9IHZpZXcubW92ZVRvTGluZUJvdW5kYXJ5KHJhbmdlLCBmYWxzZSkuaGVhZDtcbiAgICByZXR1cm4gcmFuZ2UuaGVhZCA+IGxpbmVTdGFydCA/IGxpbmVTdGFydCA6IE1hdGgubWF4KDAsIHJhbmdlLmhlYWQgLSAxKTtcbn0pO1xuLyoqXG5EZWxldGUgdGhlIHNlbGVjdGlvbiwgb3IsIGlmIGl0IGlzIGEgY3Vyc29yIHNlbGVjdGlvbiwgZGVsZXRlIHRvXG50aGUgZW5kIG9mIHRoZSBsaW5lIG9yIHRoZSBuZXh0IGxpbmUgd3JhcCBhZnRlciB0aGUgY3Vyc29yLlxuKi9cbmNvbnN0IGRlbGV0ZUxpbmVCb3VuZGFyeUZvcndhcmQgPSB2aWV3ID0+IGRlbGV0ZUJ5KHZpZXcsIHJhbmdlID0+IHtcbiAgICBsZXQgbGluZVN0YXJ0ID0gdmlldy5tb3ZlVG9MaW5lQm91bmRhcnkocmFuZ2UsIHRydWUpLmhlYWQ7XG4gICAgcmV0dXJuIHJhbmdlLmhlYWQgPCBsaW5lU3RhcnQgPyBsaW5lU3RhcnQgOiBNYXRoLm1pbih2aWV3LnN0YXRlLmRvYy5sZW5ndGgsIHJhbmdlLmhlYWQgKyAxKTtcbn0pO1xuLyoqXG5EZWxldGUgYWxsIHdoaXRlc3BhY2UgZGlyZWN0bHkgYmVmb3JlIGEgbGluZSBlbmQgZnJvbSB0aGVcbmRvY3VtZW50LlxuKi9cbmNvbnN0IGRlbGV0ZVRyYWlsaW5nV2hpdGVzcGFjZSA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgaWYgKHN0YXRlLnJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGNoYW5nZXMgPSBbXTtcbiAgICBmb3IgKGxldCBwb3MgPSAwLCBwcmV2ID0gXCJcIiwgaXRlciA9IHN0YXRlLmRvYy5pdGVyKCk7Oykge1xuICAgICAgICBpdGVyLm5leHQoKTtcbiAgICAgICAgaWYgKGl0ZXIubGluZUJyZWFrIHx8IGl0ZXIuZG9uZSkge1xuICAgICAgICAgICAgbGV0IHRyYWlsaW5nID0gcHJldi5zZWFyY2goL1xccyskLyk7XG4gICAgICAgICAgICBpZiAodHJhaWxpbmcgPiAtMSlcbiAgICAgICAgICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tOiBwb3MgLSAocHJldi5sZW5ndGggLSB0cmFpbGluZyksIHRvOiBwb3MgfSk7XG4gICAgICAgICAgICBpZiAoaXRlci5kb25lKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgcHJldiA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwcmV2ID0gaXRlci52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBwb3MgKz0gaXRlci52YWx1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGlmICghY2hhbmdlcy5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoeyBjaGFuZ2VzLCB1c2VyRXZlbnQ6IFwiZGVsZXRlXCIgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuUmVwbGFjZSBlYWNoIHNlbGVjdGlvbiByYW5nZSB3aXRoIGEgbGluZSBicmVhaywgbGVhdmluZyB0aGUgY3Vyc29yXG5vbiB0aGUgbGluZSBiZWZvcmUgdGhlIGJyZWFrLlxuKi9cbmNvbnN0IHNwbGl0TGluZSA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgaWYgKHN0YXRlLnJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGNoYW5nZXMgPSBzdGF0ZS5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+IHtcbiAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogeyBmcm9tOiByYW5nZS5mcm9tLCB0bzogcmFuZ2UudG8sIGluc2VydDogVGV4dC5vZihbXCJcIiwgXCJcIl0pIH0sXG4gICAgICAgICAgICByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihyYW5nZS5mcm9tKSB9O1xuICAgIH0pO1xuICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZShjaGFuZ2VzLCB7IHNjcm9sbEludG9WaWV3OiB0cnVlLCB1c2VyRXZlbnQ6IFwiaW5wdXRcIiB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5GbGlwIHRoZSBjaGFyYWN0ZXJzIGJlZm9yZSBhbmQgYWZ0ZXIgdGhlIGN1cnNvcihzKS5cbiovXG5jb25zdCB0cmFuc3Bvc2VDaGFycyA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgaWYgKHN0YXRlLnJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGNoYW5nZXMgPSBzdGF0ZS5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+IHtcbiAgICAgICAgaWYgKCFyYW5nZS5lbXB0eSB8fCByYW5nZS5mcm9tID09IDAgfHwgcmFuZ2UuZnJvbSA9PSBzdGF0ZS5kb2MubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHsgcmFuZ2UgfTtcbiAgICAgICAgbGV0IHBvcyA9IHJhbmdlLmZyb20sIGxpbmUgPSBzdGF0ZS5kb2MubGluZUF0KHBvcyk7XG4gICAgICAgIGxldCBmcm9tID0gcG9zID09IGxpbmUuZnJvbSA/IHBvcyAtIDEgOiBmaW5kQ2x1c3RlckJyZWFrKGxpbmUudGV4dCwgcG9zIC0gbGluZS5mcm9tLCBmYWxzZSkgKyBsaW5lLmZyb207XG4gICAgICAgIGxldCB0byA9IHBvcyA9PSBsaW5lLnRvID8gcG9zICsgMSA6IGZpbmRDbHVzdGVyQnJlYWsobGluZS50ZXh0LCBwb3MgLSBsaW5lLmZyb20sIHRydWUpICsgbGluZS5mcm9tO1xuICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiB7IGZyb20sIHRvLCBpbnNlcnQ6IHN0YXRlLmRvYy5zbGljZShwb3MsIHRvKS5hcHBlbmQoc3RhdGUuZG9jLnNsaWNlKGZyb20sIHBvcykpIH0sXG4gICAgICAgICAgICByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcih0bykgfTtcbiAgICB9KTtcbiAgICBpZiAoY2hhbmdlcy5jaGFuZ2VzLmVtcHR5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZGlzcGF0Y2goc3RhdGUudXBkYXRlKGNoYW5nZXMsIHsgc2Nyb2xsSW50b1ZpZXc6IHRydWUsIHVzZXJFdmVudDogXCJtb3ZlLmNoYXJhY3RlclwiIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5mdW5jdGlvbiBzZWxlY3RlZExpbmVCbG9ja3Moc3RhdGUpIHtcbiAgICBsZXQgYmxvY2tzID0gW10sIHVwdG8gPSAtMTtcbiAgICBmb3IgKGxldCByYW5nZSBvZiBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzKSB7XG4gICAgICAgIGxldCBzdGFydExpbmUgPSBzdGF0ZS5kb2MubGluZUF0KHJhbmdlLmZyb20pLCBlbmRMaW5lID0gc3RhdGUuZG9jLmxpbmVBdChyYW5nZS50byk7XG4gICAgICAgIGlmICghcmFuZ2UuZW1wdHkgJiYgcmFuZ2UudG8gPT0gZW5kTGluZS5mcm9tKVxuICAgICAgICAgICAgZW5kTGluZSA9IHN0YXRlLmRvYy5saW5lQXQocmFuZ2UudG8gLSAxKTtcbiAgICAgICAgaWYgKHVwdG8gPj0gc3RhcnRMaW5lLm51bWJlcikge1xuICAgICAgICAgICAgbGV0IHByZXYgPSBibG9ja3NbYmxvY2tzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgcHJldi50byA9IGVuZExpbmUudG87XG4gICAgICAgICAgICBwcmV2LnJhbmdlcy5wdXNoKHJhbmdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJsb2Nrcy5wdXNoKHsgZnJvbTogc3RhcnRMaW5lLmZyb20sIHRvOiBlbmRMaW5lLnRvLCByYW5nZXM6IFtyYW5nZV0gfSk7XG4gICAgICAgIH1cbiAgICAgICAgdXB0byA9IGVuZExpbmUubnVtYmVyICsgMTtcbiAgICB9XG4gICAgcmV0dXJuIGJsb2Nrcztcbn1cbmZ1bmN0aW9uIG1vdmVMaW5lKHN0YXRlLCBkaXNwYXRjaCwgZm9yd2FyZCkge1xuICAgIGlmIChzdGF0ZS5yZWFkT25seSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBjaGFuZ2VzID0gW10sIHJhbmdlcyA9IFtdO1xuICAgIGZvciAobGV0IGJsb2NrIG9mIHNlbGVjdGVkTGluZUJsb2NrcyhzdGF0ZSkpIHtcbiAgICAgICAgaWYgKGZvcndhcmQgPyBibG9jay50byA9PSBzdGF0ZS5kb2MubGVuZ3RoIDogYmxvY2suZnJvbSA9PSAwKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGxldCBuZXh0TGluZSA9IHN0YXRlLmRvYy5saW5lQXQoZm9yd2FyZCA/IGJsb2NrLnRvICsgMSA6IGJsb2NrLmZyb20gLSAxKTtcbiAgICAgICAgbGV0IHNpemUgPSBuZXh0TGluZS5sZW5ndGggKyAxO1xuICAgICAgICBpZiAoZm9yd2FyZCkge1xuICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHsgZnJvbTogYmxvY2sudG8sIHRvOiBuZXh0TGluZS50byB9LCB7IGZyb206IGJsb2NrLmZyb20sIGluc2VydDogbmV4dExpbmUudGV4dCArIHN0YXRlLmxpbmVCcmVhayB9KTtcbiAgICAgICAgICAgIGZvciAobGV0IHIgb2YgYmxvY2sucmFuZ2VzKVxuICAgICAgICAgICAgICAgIHJhbmdlcy5wdXNoKEVkaXRvclNlbGVjdGlvbi5yYW5nZShNYXRoLm1pbihzdGF0ZS5kb2MubGVuZ3RoLCByLmFuY2hvciArIHNpemUpLCBNYXRoLm1pbihzdGF0ZS5kb2MubGVuZ3RoLCByLmhlYWQgKyBzaXplKSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHsgZnJvbTogbmV4dExpbmUuZnJvbSwgdG86IGJsb2NrLmZyb20gfSwgeyBmcm9tOiBibG9jay50bywgaW5zZXJ0OiBzdGF0ZS5saW5lQnJlYWsgKyBuZXh0TGluZS50ZXh0IH0pO1xuICAgICAgICAgICAgZm9yIChsZXQgciBvZiBibG9jay5yYW5nZXMpXG4gICAgICAgICAgICAgICAgcmFuZ2VzLnB1c2goRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHIuYW5jaG9yIC0gc2l6ZSwgci5oZWFkIC0gc2l6ZSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghY2hhbmdlcy5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoe1xuICAgICAgICBjaGFuZ2VzLFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogdHJ1ZSxcbiAgICAgICAgc2VsZWN0aW9uOiBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKHJhbmdlcywgc3RhdGUuc2VsZWN0aW9uLm1haW5JbmRleCksXG4gICAgICAgIHVzZXJFdmVudDogXCJtb3ZlLmxpbmVcIlxuICAgIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuTW92ZSB0aGUgc2VsZWN0ZWQgbGluZXMgdXAgb25lIGxpbmUuXG4qL1xuY29uc3QgbW92ZUxpbmVVcCA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiBtb3ZlTGluZShzdGF0ZSwgZGlzcGF0Y2gsIGZhbHNlKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0ZWQgbGluZXMgZG93biBvbmUgbGluZS5cbiovXG5jb25zdCBtb3ZlTGluZURvd24gPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4gbW92ZUxpbmUoc3RhdGUsIGRpc3BhdGNoLCB0cnVlKTtcbmZ1bmN0aW9uIGNvcHlMaW5lKHN0YXRlLCBkaXNwYXRjaCwgZm9yd2FyZCkge1xuICAgIGlmIChzdGF0ZS5yZWFkT25seSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBjaGFuZ2VzID0gW107XG4gICAgZm9yIChsZXQgYmxvY2sgb2Ygc2VsZWN0ZWRMaW5lQmxvY2tzKHN0YXRlKSkge1xuICAgICAgICBpZiAoZm9yd2FyZClcbiAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7IGZyb206IGJsb2NrLmZyb20sIGluc2VydDogc3RhdGUuZG9jLnNsaWNlKGJsb2NrLmZyb20sIGJsb2NrLnRvKSArIHN0YXRlLmxpbmVCcmVhayB9KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHsgZnJvbTogYmxvY2sudG8sIGluc2VydDogc3RhdGUubGluZUJyZWFrICsgc3RhdGUuZG9jLnNsaWNlKGJsb2NrLmZyb20sIGJsb2NrLnRvKSB9KTtcbiAgICB9XG4gICAgZGlzcGF0Y2goc3RhdGUudXBkYXRlKHsgY2hhbmdlcywgc2Nyb2xsSW50b1ZpZXc6IHRydWUsIHVzZXJFdmVudDogXCJpbnB1dC5jb3B5bGluZVwiIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuQ3JlYXRlIGEgY29weSBvZiB0aGUgc2VsZWN0ZWQgbGluZXMuIEtlZXAgdGhlIHNlbGVjdGlvbiBpbiB0aGUgdG9wIGNvcHkuXG4qL1xuY29uc3QgY29weUxpbmVVcCA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiBjb3B5TGluZShzdGF0ZSwgZGlzcGF0Y2gsIGZhbHNlKTtcbi8qKlxuQ3JlYXRlIGEgY29weSBvZiB0aGUgc2VsZWN0ZWQgbGluZXMuIEtlZXAgdGhlIHNlbGVjdGlvbiBpbiB0aGUgYm90dG9tIGNvcHkuXG4qL1xuY29uc3QgY29weUxpbmVEb3duID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IGNvcHlMaW5lKHN0YXRlLCBkaXNwYXRjaCwgdHJ1ZSk7XG4vKipcbkRlbGV0ZSBzZWxlY3RlZCBsaW5lcy5cbiovXG5jb25zdCBkZWxldGVMaW5lID0gdmlldyA9PiB7XG4gICAgaWYgKHZpZXcuc3RhdGUucmVhZE9ubHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgeyBzdGF0ZSB9ID0gdmlldywgY2hhbmdlcyA9IHN0YXRlLmNoYW5nZXMoc2VsZWN0ZWRMaW5lQmxvY2tzKHN0YXRlKS5tYXAoKHsgZnJvbSwgdG8gfSkgPT4ge1xuICAgICAgICBpZiAoZnJvbSA+IDApXG4gICAgICAgICAgICBmcm9tLS07XG4gICAgICAgIGVsc2UgaWYgKHRvIDwgc3RhdGUuZG9jLmxlbmd0aClcbiAgICAgICAgICAgIHRvKys7XG4gICAgICAgIHJldHVybiB7IGZyb20sIHRvIH07XG4gICAgfSkpO1xuICAgIGxldCBzZWxlY3Rpb24gPSB1cGRhdGVTZWwoc3RhdGUuc2VsZWN0aW9uLCByYW5nZSA9PiB2aWV3Lm1vdmVWZXJ0aWNhbGx5KHJhbmdlLCB0cnVlKSkubWFwKGNoYW5nZXMpO1xuICAgIHZpZXcuZGlzcGF0Y2goeyBjaGFuZ2VzLCBzZWxlY3Rpb24sIHNjcm9sbEludG9WaWV3OiB0cnVlLCB1c2VyRXZlbnQ6IFwiZGVsZXRlLmxpbmVcIiB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcblJlcGxhY2UgdGhlIHNlbGVjdGlvbiB3aXRoIGEgbmV3bGluZS5cbiovXG5jb25zdCBpbnNlcnROZXdsaW5lID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoc3RhdGUucmVwbGFjZVNlbGVjdGlvbihzdGF0ZS5saW5lQnJlYWspLCB7IHNjcm9sbEludG9WaWV3OiB0cnVlLCB1c2VyRXZlbnQ6IFwiaW5wdXRcIiB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuZnVuY3Rpb24gaXNCZXR3ZWVuQnJhY2tldHMoc3RhdGUsIHBvcykge1xuICAgIGlmICgvXFwoXFwpfFxcW1xcXXxcXHtcXH0vLnRlc3Qoc3RhdGUuc2xpY2VEb2MocG9zIC0gMSwgcG9zICsgMSkpKVxuICAgICAgICByZXR1cm4geyBmcm9tOiBwb3MsIHRvOiBwb3MgfTtcbiAgICBsZXQgY29udGV4dCA9IHN5bnRheFRyZWUoc3RhdGUpLnJlc29sdmVJbm5lcihwb3MpO1xuICAgIGxldCBiZWZvcmUgPSBjb250ZXh0LmNoaWxkQmVmb3JlKHBvcyksIGFmdGVyID0gY29udGV4dC5jaGlsZEFmdGVyKHBvcyksIGNsb3NlZEJ5O1xuICAgIGlmIChiZWZvcmUgJiYgYWZ0ZXIgJiYgYmVmb3JlLnRvIDw9IHBvcyAmJiBhZnRlci5mcm9tID49IHBvcyAmJlxuICAgICAgICAoY2xvc2VkQnkgPSBiZWZvcmUudHlwZS5wcm9wKE5vZGVQcm9wLmNsb3NlZEJ5KSkgJiYgY2xvc2VkQnkuaW5kZXhPZihhZnRlci5uYW1lKSA+IC0xICYmXG4gICAgICAgIHN0YXRlLmRvYy5saW5lQXQoYmVmb3JlLnRvKS5mcm9tID09IHN0YXRlLmRvYy5saW5lQXQoYWZ0ZXIuZnJvbSkuZnJvbSAmJlxuICAgICAgICAhL1xcUy8udGVzdChzdGF0ZS5zbGljZURvYyhiZWZvcmUudG8sIGFmdGVyLmZyb20pKSlcbiAgICAgICAgcmV0dXJuIHsgZnJvbTogYmVmb3JlLnRvLCB0bzogYWZ0ZXIuZnJvbSB9O1xuICAgIHJldHVybiBudWxsO1xufVxuLyoqXG5SZXBsYWNlIHRoZSBzZWxlY3Rpb24gd2l0aCBhIG5ld2xpbmUgYW5kIGluZGVudCB0aGUgbmV3bHkgY3JlYXRlZFxubGluZShzKS4gSWYgdGhlIGN1cnJlbnQgbGluZSBjb25zaXN0cyBvbmx5IG9mIHdoaXRlc3BhY2UsIHRoaXNcbndpbGwgYWxzbyBkZWxldGUgdGhhdCB3aGl0ZXNwYWNlLiBXaGVuIHRoZSBjdXJzb3IgaXMgYmV0d2VlblxubWF0Y2hpbmcgYnJhY2tldHMsIGFuIGFkZGl0aW9uYWwgbmV3bGluZSB3aWxsIGJlIGluc2VydGVkIGFmdGVyXG50aGUgY3Vyc29yLlxuKi9cbmNvbnN0IGluc2VydE5ld2xpbmVBbmRJbmRlbnQgPSAvKkBfX1BVUkVfXyovbmV3bGluZUFuZEluZGVudChmYWxzZSk7XG4vKipcbkNyZWF0ZSBhIGJsYW5rLCBpbmRlbnRlZCBsaW5lIGJlbG93IHRoZSBjdXJyZW50IGxpbmUuXG4qL1xuY29uc3QgaW5zZXJ0QmxhbmtMaW5lID0gLypAX19QVVJFX18qL25ld2xpbmVBbmRJbmRlbnQodHJ1ZSk7XG5mdW5jdGlvbiBuZXdsaW5lQW5kSW5kZW50KGF0RW9mKSB7XG4gICAgcmV0dXJuICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgICAgIGlmIChzdGF0ZS5yZWFkT25seSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IGNoYW5nZXMgPSBzdGF0ZS5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+IHtcbiAgICAgICAgICAgIGxldCB7IGZyb20sIHRvIH0gPSByYW5nZSwgbGluZSA9IHN0YXRlLmRvYy5saW5lQXQoZnJvbSk7XG4gICAgICAgICAgICBsZXQgZXhwbG9kZSA9ICFhdEVvZiAmJiBmcm9tID09IHRvICYmIGlzQmV0d2VlbkJyYWNrZXRzKHN0YXRlLCBmcm9tKTtcbiAgICAgICAgICAgIGlmIChhdEVvZilcbiAgICAgICAgICAgICAgICBmcm9tID0gdG8gPSAodG8gPD0gbGluZS50byA/IGxpbmUgOiBzdGF0ZS5kb2MubGluZUF0KHRvKSkudG87XG4gICAgICAgICAgICBsZXQgY3ggPSBuZXcgSW5kZW50Q29udGV4dChzdGF0ZSwgeyBzaW11bGF0ZUJyZWFrOiBmcm9tLCBzaW11bGF0ZURvdWJsZUJyZWFrOiAhIWV4cGxvZGUgfSk7XG4gICAgICAgICAgICBsZXQgaW5kZW50ID0gZ2V0SW5kZW50YXRpb24oY3gsIGZyb20pO1xuICAgICAgICAgICAgaWYgKGluZGVudCA9PSBudWxsKVxuICAgICAgICAgICAgICAgIGluZGVudCA9IGNvdW50Q29sdW1uKC9eXFxzKi8uZXhlYyhzdGF0ZS5kb2MubGluZUF0KGZyb20pLnRleHQpWzBdLCBzdGF0ZS50YWJTaXplKTtcbiAgICAgICAgICAgIHdoaWxlICh0byA8IGxpbmUudG8gJiYgL1xccy8udGVzdChsaW5lLnRleHRbdG8gLSBsaW5lLmZyb21dKSlcbiAgICAgICAgICAgICAgICB0bysrO1xuICAgICAgICAgICAgaWYgKGV4cGxvZGUpXG4gICAgICAgICAgICAgICAgKHsgZnJvbSwgdG8gfSA9IGV4cGxvZGUpO1xuICAgICAgICAgICAgZWxzZSBpZiAoZnJvbSA+IGxpbmUuZnJvbSAmJiBmcm9tIDwgbGluZS5mcm9tICsgMTAwICYmICEvXFxTLy50ZXN0KGxpbmUudGV4dC5zbGljZSgwLCBmcm9tKSkpXG4gICAgICAgICAgICAgICAgZnJvbSA9IGxpbmUuZnJvbTtcbiAgICAgICAgICAgIGxldCBpbnNlcnQgPSBbXCJcIiwgaW5kZW50U3RyaW5nKHN0YXRlLCBpbmRlbnQpXTtcbiAgICAgICAgICAgIGlmIChleHBsb2RlKVxuICAgICAgICAgICAgICAgIGluc2VydC5wdXNoKGluZGVudFN0cmluZyhzdGF0ZSwgY3gubGluZUluZGVudChsaW5lLmZyb20sIC0xKSkpO1xuICAgICAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogeyBmcm9tLCB0bywgaW5zZXJ0OiBUZXh0Lm9mKGluc2VydCkgfSxcbiAgICAgICAgICAgICAgICByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihmcm9tICsgMSArIGluc2VydFsxXS5sZW5ndGgpIH07XG4gICAgICAgIH0pO1xuICAgICAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoY2hhbmdlcywgeyBzY3JvbGxJbnRvVmlldzogdHJ1ZSwgdXNlckV2ZW50OiBcImlucHV0XCIgfSkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuZnVuY3Rpb24gY2hhbmdlQnlTZWxlY3RlZExpbmUoc3RhdGUsIGYpIHtcbiAgICBsZXQgYXRMaW5lID0gLTE7XG4gICAgcmV0dXJuIHN0YXRlLmNoYW5nZUJ5UmFuZ2UocmFuZ2UgPT4ge1xuICAgICAgICBsZXQgY2hhbmdlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSByYW5nZS5mcm9tOyBwb3MgPD0gcmFuZ2UudG87KSB7XG4gICAgICAgICAgICBsZXQgbGluZSA9IHN0YXRlLmRvYy5saW5lQXQocG9zKTtcbiAgICAgICAgICAgIGlmIChsaW5lLm51bWJlciA+IGF0TGluZSAmJiAocmFuZ2UuZW1wdHkgfHwgcmFuZ2UudG8gPiBsaW5lLmZyb20pKSB7XG4gICAgICAgICAgICAgICAgZihsaW5lLCBjaGFuZ2VzLCByYW5nZSk7XG4gICAgICAgICAgICAgICAgYXRMaW5lID0gbGluZS5udW1iZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3MgPSBsaW5lLnRvICsgMTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY2hhbmdlU2V0ID0gc3RhdGUuY2hhbmdlcyhjaGFuZ2VzKTtcbiAgICAgICAgcmV0dXJuIHsgY2hhbmdlcyxcbiAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UoY2hhbmdlU2V0Lm1hcFBvcyhyYW5nZS5hbmNob3IsIDEpLCBjaGFuZ2VTZXQubWFwUG9zKHJhbmdlLmhlYWQsIDEpKSB9O1xuICAgIH0pO1xufVxuLyoqXG5BdXRvLWluZGVudCB0aGUgc2VsZWN0ZWQgbGluZXMuIFRoaXMgdXNlcyB0aGUgW2luZGVudGF0aW9uIHNlcnZpY2VcbmZhY2V0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmluZGVudFNlcnZpY2UpIGFzIHNvdXJjZSBmb3IgYXV0by1pbmRlbnRcbmluZm9ybWF0aW9uLlxuKi9cbmNvbnN0IGluZGVudFNlbGVjdGlvbiA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgaWYgKHN0YXRlLnJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHVwZGF0ZWQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGxldCBjb250ZXh0ID0gbmV3IEluZGVudENvbnRleHQoc3RhdGUsIHsgb3ZlcnJpZGVJbmRlbnRhdGlvbjogc3RhcnQgPT4ge1xuICAgICAgICAgICAgbGV0IGZvdW5kID0gdXBkYXRlZFtzdGFydF07XG4gICAgICAgICAgICByZXR1cm4gZm91bmQgPT0gbnVsbCA/IC0xIDogZm91bmQ7XG4gICAgICAgIH0gfSk7XG4gICAgbGV0IGNoYW5nZXMgPSBjaGFuZ2VCeVNlbGVjdGVkTGluZShzdGF0ZSwgKGxpbmUsIGNoYW5nZXMsIHJhbmdlKSA9PiB7XG4gICAgICAgIGxldCBpbmRlbnQgPSBnZXRJbmRlbnRhdGlvbihjb250ZXh0LCBsaW5lLmZyb20pO1xuICAgICAgICBpZiAoaW5kZW50ID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICghL1xcUy8udGVzdChsaW5lLnRleHQpKVxuICAgICAgICAgICAgaW5kZW50ID0gMDtcbiAgICAgICAgbGV0IGN1ciA9IC9eXFxzKi8uZXhlYyhsaW5lLnRleHQpWzBdO1xuICAgICAgICBsZXQgbm9ybSA9IGluZGVudFN0cmluZyhzdGF0ZSwgaW5kZW50KTtcbiAgICAgICAgaWYgKGN1ciAhPSBub3JtIHx8IHJhbmdlLmZyb20gPCBsaW5lLmZyb20gKyBjdXIubGVuZ3RoKSB7XG4gICAgICAgICAgICB1cGRhdGVkW2xpbmUuZnJvbV0gPSBpbmRlbnQ7XG4gICAgICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tOiBsaW5lLmZyb20sIHRvOiBsaW5lLmZyb20gKyBjdXIubGVuZ3RoLCBpbnNlcnQ6IG5vcm0gfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIWNoYW5nZXMuY2hhbmdlcy5lbXB0eSlcbiAgICAgICAgZGlzcGF0Y2goc3RhdGUudXBkYXRlKGNoYW5nZXMsIHsgdXNlckV2ZW50OiBcImluZGVudFwiIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbkFkZCBhIFt1bml0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmluZGVudFVuaXQpIG9mIGluZGVudGF0aW9uIHRvIGFsbCBzZWxlY3RlZFxubGluZXMuXG4qL1xuY29uc3QgaW5kZW50TW9yZSA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgaWYgKHN0YXRlLnJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZGlzcGF0Y2goc3RhdGUudXBkYXRlKGNoYW5nZUJ5U2VsZWN0ZWRMaW5lKHN0YXRlLCAobGluZSwgY2hhbmdlcykgPT4ge1xuICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tOiBsaW5lLmZyb20sIGluc2VydDogc3RhdGUuZmFjZXQoaW5kZW50VW5pdCkgfSk7XG4gICAgfSksIHsgdXNlckV2ZW50OiBcImlucHV0LmluZGVudFwiIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcblJlbW92ZSBhIFt1bml0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmluZGVudFVuaXQpIG9mIGluZGVudGF0aW9uIGZyb20gYWxsXG5zZWxlY3RlZCBsaW5lcy5cbiovXG5jb25zdCBpbmRlbnRMZXNzID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBpZiAoc3RhdGUucmVhZE9ubHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoY2hhbmdlQnlTZWxlY3RlZExpbmUoc3RhdGUsIChsaW5lLCBjaGFuZ2VzKSA9PiB7XG4gICAgICAgIGxldCBzcGFjZSA9IC9eXFxzKi8uZXhlYyhsaW5lLnRleHQpWzBdO1xuICAgICAgICBpZiAoIXNwYWNlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgY29sID0gY291bnRDb2x1bW4oc3BhY2UsIHN0YXRlLnRhYlNpemUpLCBrZWVwID0gMDtcbiAgICAgICAgbGV0IGluc2VydCA9IGluZGVudFN0cmluZyhzdGF0ZSwgTWF0aC5tYXgoMCwgY29sIC0gZ2V0SW5kZW50VW5pdChzdGF0ZSkpKTtcbiAgICAgICAgd2hpbGUgKGtlZXAgPCBzcGFjZS5sZW5ndGggJiYga2VlcCA8IGluc2VydC5sZW5ndGggJiYgc3BhY2UuY2hhckNvZGVBdChrZWVwKSA9PSBpbnNlcnQuY2hhckNvZGVBdChrZWVwKSlcbiAgICAgICAgICAgIGtlZXArKztcbiAgICAgICAgY2hhbmdlcy5wdXNoKHsgZnJvbTogbGluZS5mcm9tICsga2VlcCwgdG86IGxpbmUuZnJvbSArIHNwYWNlLmxlbmd0aCwgaW5zZXJ0OiBpbnNlcnQuc2xpY2Uoa2VlcCkgfSk7XG4gICAgfSksIHsgdXNlckV2ZW50OiBcImRlbGV0ZS5kZWRlbnRcIiB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5JbnNlcnQgYSB0YWIgY2hhcmFjdGVyIGF0IHRoZSBjdXJzb3Igb3IsIGlmIHNvbWV0aGluZyBpcyBzZWxlY3RlZCxcbnVzZSBbYGluZGVudE1vcmVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmluZGVudE1vcmUpIHRvIGluZGVudCB0aGUgZW50aXJlXG5zZWxlY3Rpb24uXG4qL1xuY29uc3QgaW5zZXJ0VGFiID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBpZiAoc3RhdGUuc2VsZWN0aW9uLnJhbmdlcy5zb21lKHIgPT4gIXIuZW1wdHkpKVxuICAgICAgICByZXR1cm4gaW5kZW50TW9yZSh7IHN0YXRlLCBkaXNwYXRjaCB9KTtcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoc3RhdGUucmVwbGFjZVNlbGVjdGlvbihcIlxcdFwiKSwgeyBzY3JvbGxJbnRvVmlldzogdHJ1ZSwgdXNlckV2ZW50OiBcImlucHV0XCIgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuQXJyYXkgb2Yga2V5IGJpbmRpbmdzIGNvbnRhaW5pbmcgdGhlIEVtYWNzLXN0eWxlIGJpbmRpbmdzIHRoYXQgYXJlXG5hdmFpbGFibGUgb24gbWFjT1MgYnkgZGVmYXVsdC5cblxuIC0gQ3RybC1iOiBbYGN1cnNvckNoYXJMZWZ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JDaGFyTGVmdCkgKFtgc2VsZWN0Q2hhckxlZnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdENoYXJMZWZ0KSB3aXRoIFNoaWZ0KVxuIC0gQ3RybC1mOiBbYGN1cnNvckNoYXJSaWdodGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yQ2hhclJpZ2h0KSAoW2BzZWxlY3RDaGFyUmlnaHRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdENoYXJSaWdodCkgd2l0aCBTaGlmdClcbiAtIEN0cmwtcDogW2BjdXJzb3JMaW5lVXBgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckxpbmVVcCkgKFtgc2VsZWN0TGluZVVwYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RMaW5lVXApIHdpdGggU2hpZnQpXG4gLSBDdHJsLW46IFtgY3Vyc29yTGluZURvd25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckxpbmVEb3duKSAoW2BzZWxlY3RMaW5lRG93bmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0TGluZURvd24pIHdpdGggU2hpZnQpXG4gLSBDdHJsLWE6IFtgY3Vyc29yTGluZVN0YXJ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JMaW5lU3RhcnQpIChbYHNlbGVjdExpbmVTdGFydGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0TGluZVN0YXJ0KSB3aXRoIFNoaWZ0KVxuIC0gQ3RybC1lOiBbYGN1cnNvckxpbmVFbmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckxpbmVFbmQpIChbYHNlbGVjdExpbmVFbmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdExpbmVFbmQpIHdpdGggU2hpZnQpXG4gLSBDdHJsLWQ6IFtgZGVsZXRlQ2hhckZvcndhcmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmRlbGV0ZUNoYXJGb3J3YXJkKVxuIC0gQ3RybC1oOiBbYGRlbGV0ZUNoYXJCYWNrd2FyZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuZGVsZXRlQ2hhckJhY2t3YXJkKVxuIC0gQ3RybC1rOiBbYGRlbGV0ZVRvTGluZUVuZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuZGVsZXRlVG9MaW5lRW5kKVxuIC0gQ3RybC1BbHQtaDogW2BkZWxldGVHcm91cEJhY2t3YXJkYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5kZWxldGVHcm91cEJhY2t3YXJkKVxuIC0gQ3RybC1vOiBbYHNwbGl0TGluZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc3BsaXRMaW5lKVxuIC0gQ3RybC10OiBbYHRyYW5zcG9zZUNoYXJzYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy50cmFuc3Bvc2VDaGFycylcbiAtIEN0cmwtdjogW2BjdXJzb3JQYWdlRG93bmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yUGFnZURvd24pXG4gLSBBbHQtdjogW2BjdXJzb3JQYWdlVXBgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvclBhZ2VVcClcbiovXG5jb25zdCBlbWFjc1N0eWxlS2V5bWFwID0gW1xuICAgIHsga2V5OiBcIkN0cmwtYlwiLCBydW46IGN1cnNvckNoYXJMZWZ0LCBzaGlmdDogc2VsZWN0Q2hhckxlZnQsIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBrZXk6IFwiQ3RybC1mXCIsIHJ1bjogY3Vyc29yQ2hhclJpZ2h0LCBzaGlmdDogc2VsZWN0Q2hhclJpZ2h0IH0sXG4gICAgeyBrZXk6IFwiQ3RybC1wXCIsIHJ1bjogY3Vyc29yTGluZVVwLCBzaGlmdDogc2VsZWN0TGluZVVwIH0sXG4gICAgeyBrZXk6IFwiQ3RybC1uXCIsIHJ1bjogY3Vyc29yTGluZURvd24sIHNoaWZ0OiBzZWxlY3RMaW5lRG93biB9LFxuICAgIHsga2V5OiBcIkN0cmwtYVwiLCBydW46IGN1cnNvckxpbmVTdGFydCwgc2hpZnQ6IHNlbGVjdExpbmVTdGFydCB9LFxuICAgIHsga2V5OiBcIkN0cmwtZVwiLCBydW46IGN1cnNvckxpbmVFbmQsIHNoaWZ0OiBzZWxlY3RMaW5lRW5kIH0sXG4gICAgeyBrZXk6IFwiQ3RybC1kXCIsIHJ1bjogZGVsZXRlQ2hhckZvcndhcmQgfSxcbiAgICB7IGtleTogXCJDdHJsLWhcIiwgcnVuOiBkZWxldGVDaGFyQmFja3dhcmQgfSxcbiAgICB7IGtleTogXCJDdHJsLWtcIiwgcnVuOiBkZWxldGVUb0xpbmVFbmQgfSxcbiAgICB7IGtleTogXCJDdHJsLUFsdC1oXCIsIHJ1bjogZGVsZXRlR3JvdXBCYWNrd2FyZCB9LFxuICAgIHsga2V5OiBcIkN0cmwtb1wiLCBydW46IHNwbGl0TGluZSB9LFxuICAgIHsga2V5OiBcIkN0cmwtdFwiLCBydW46IHRyYW5zcG9zZUNoYXJzIH0sXG4gICAgeyBrZXk6IFwiQ3RybC12XCIsIHJ1bjogY3Vyc29yUGFnZURvd24gfSxcbl07XG4vKipcbkFuIGFycmF5IG9mIGtleSBiaW5kaW5ncyBjbG9zZWx5IHN0aWNraW5nIHRvIHBsYXRmb3JtLXN0YW5kYXJkIG9yXG53aWRlbHkgdXNlZCBiaW5kaW5ncy4gKFRoaXMgaW5jbHVkZXMgdGhlIGJpbmRpbmdzIGZyb21cbltgZW1hY3NTdHlsZUtleW1hcGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuZW1hY3NTdHlsZUtleW1hcCksIHdpdGggdGhlaXIgYGtleWBcbnByb3BlcnR5IGNoYW5nZWQgdG8gYG1hY2AuKVxuXG4gLSBBcnJvd0xlZnQ6IFtgY3Vyc29yQ2hhckxlZnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckNoYXJMZWZ0KSAoW2BzZWxlY3RDaGFyTGVmdGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0Q2hhckxlZnQpIHdpdGggU2hpZnQpXG4gLSBBcnJvd1JpZ2h0OiBbYGN1cnNvckNoYXJSaWdodGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yQ2hhclJpZ2h0KSAoW2BzZWxlY3RDaGFyUmlnaHRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdENoYXJSaWdodCkgd2l0aCBTaGlmdClcbiAtIEN0cmwtQXJyb3dMZWZ0IChBbHQtQXJyb3dMZWZ0IG9uIG1hY09TKTogW2BjdXJzb3JHcm91cExlZnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckdyb3VwTGVmdCkgKFtgc2VsZWN0R3JvdXBMZWZ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RHcm91cExlZnQpIHdpdGggU2hpZnQpXG4gLSBDdHJsLUFycm93UmlnaHQgKEFsdC1BcnJvd1JpZ2h0IG9uIG1hY09TKTogW2BjdXJzb3JHcm91cFJpZ2h0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JHcm91cFJpZ2h0KSAoW2BzZWxlY3RHcm91cFJpZ2h0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RHcm91cFJpZ2h0KSB3aXRoIFNoaWZ0KVxuIC0gQ21kLUFycm93TGVmdCAob24gbWFjT1MpOiBbYGN1cnNvckxpbmVTdGFydGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yTGluZVN0YXJ0KSAoW2BzZWxlY3RMaW5lU3RhcnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdExpbmVTdGFydCkgd2l0aCBTaGlmdClcbiAtIENtZC1BcnJvd1JpZ2h0IChvbiBtYWNPUyk6IFtgY3Vyc29yTGluZUVuZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yTGluZUVuZCkgKFtgc2VsZWN0TGluZUVuZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0TGluZUVuZCkgd2l0aCBTaGlmdClcbiAtIEFycm93VXA6IFtgY3Vyc29yTGluZVVwYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JMaW5lVXApIChbYHNlbGVjdExpbmVVcGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0TGluZVVwKSB3aXRoIFNoaWZ0KVxuIC0gQXJyb3dEb3duOiBbYGN1cnNvckxpbmVEb3duYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JMaW5lRG93bikgKFtgc2VsZWN0TGluZURvd25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdExpbmVEb3duKSB3aXRoIFNoaWZ0KVxuIC0gQ21kLUFycm93VXAgKG9uIG1hY09TKTogW2BjdXJzb3JEb2NTdGFydGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yRG9jU3RhcnQpIChbYHNlbGVjdERvY1N0YXJ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3REb2NTdGFydCkgd2l0aCBTaGlmdClcbiAtIENtZC1BcnJvd0Rvd24gKG9uIG1hY09TKTogW2BjdXJzb3JEb2NFbmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckRvY0VuZCkgKFtgc2VsZWN0RG9jRW5kYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3REb2NFbmQpIHdpdGggU2hpZnQpXG4gLSBDdHJsLUFycm93VXAgKG9uIG1hY09TKTogW2BjdXJzb3JQYWdlVXBgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvclBhZ2VVcCkgKFtgc2VsZWN0UGFnZVVwYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RQYWdlVXApIHdpdGggU2hpZnQpXG4gLSBDdHJsLUFycm93RG93biAob24gbWFjT1MpOiBbYGN1cnNvclBhZ2VEb3duYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JQYWdlRG93bikgKFtgc2VsZWN0UGFnZURvd25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdFBhZ2VEb3duKSB3aXRoIFNoaWZ0KVxuIC0gUGFnZVVwOiBbYGN1cnNvclBhZ2VVcGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yUGFnZVVwKSAoW2BzZWxlY3RQYWdlVXBgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdFBhZ2VVcCkgd2l0aCBTaGlmdClcbiAtIFBhZ2VEb3duOiBbYGN1cnNvclBhZ2VEb3duYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JQYWdlRG93bikgKFtgc2VsZWN0UGFnZURvd25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdFBhZ2VEb3duKSB3aXRoIFNoaWZ0KVxuIC0gSG9tZTogW2BjdXJzb3JMaW5lQm91bmRhcnlCYWNrd2FyZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yTGluZUJvdW5kYXJ5QmFja3dhcmQpIChbYHNlbGVjdExpbmVCb3VuZGFyeUJhY2t3YXJkYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RMaW5lQm91bmRhcnlCYWNrd2FyZCkgd2l0aCBTaGlmdClcbiAtIEVuZDogW2BjdXJzb3JMaW5lQm91bmRhcnlGb3J3YXJkYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JMaW5lQm91bmRhcnlGb3J3YXJkKSAoW2BzZWxlY3RMaW5lQm91bmRhcnlGb3J3YXJkYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RMaW5lQm91bmRhcnlGb3J3YXJkKSB3aXRoIFNoaWZ0KVxuIC0gQ3RybC1Ib21lIChDbWQtSG9tZSBvbiBtYWNPUyk6IFtgY3Vyc29yRG9jU3RhcnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckRvY1N0YXJ0KSAoW2BzZWxlY3REb2NTdGFydGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0RG9jU3RhcnQpIHdpdGggU2hpZnQpXG4gLSBDdHJsLUVuZCAoQ21kLUhvbWUgb24gbWFjT1MpOiBbYGN1cnNvckRvY0VuZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yRG9jRW5kKSAoW2BzZWxlY3REb2NFbmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdERvY0VuZCkgd2l0aCBTaGlmdClcbiAtIEVudGVyOiBbYGluc2VydE5ld2xpbmVBbmRJbmRlbnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmluc2VydE5ld2xpbmVBbmRJbmRlbnQpXG4gLSBDdHJsLWEgKENtZC1hIG9uIG1hY09TKTogW2BzZWxlY3RBbGxgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdEFsbClcbiAtIEJhY2tzcGFjZTogW2BkZWxldGVDaGFyQmFja3dhcmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmRlbGV0ZUNoYXJCYWNrd2FyZClcbiAtIERlbGV0ZTogW2BkZWxldGVDaGFyRm9yd2FyZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuZGVsZXRlQ2hhckZvcndhcmQpXG4gLSBDdHJsLUJhY2tzcGFjZSAoQWx0LUJhY2tzcGFjZSBvbiBtYWNPUyk6IFtgZGVsZXRlR3JvdXBCYWNrd2FyZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuZGVsZXRlR3JvdXBCYWNrd2FyZClcbiAtIEN0cmwtRGVsZXRlIChBbHQtRGVsZXRlIG9uIG1hY09TKTogW2BkZWxldGVHcm91cEZvcndhcmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmRlbGV0ZUdyb3VwRm9yd2FyZClcbiAtIENtZC1CYWNrc3BhY2UgKG1hY09TKTogW2BkZWxldGVMaW5lQm91bmRhcnlCYWNrd2FyZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuZGVsZXRlTGluZUJvdW5kYXJ5QmFja3dhcmQpLlxuIC0gQ21kLURlbGV0ZSAobWFjT1MpOiBbYGRlbGV0ZUxpbmVCb3VuZGFyeUZvcndhcmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmRlbGV0ZUxpbmVCb3VuZGFyeUZvcndhcmQpLlxuKi9cbmNvbnN0IHN0YW5kYXJkS2V5bWFwID0gLypAX19QVVJFX18qL1tcbiAgICB7IGtleTogXCJBcnJvd0xlZnRcIiwgcnVuOiBjdXJzb3JDaGFyTGVmdCwgc2hpZnQ6IHNlbGVjdENoYXJMZWZ0LCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsga2V5OiBcIk1vZC1BcnJvd0xlZnRcIiwgbWFjOiBcIkFsdC1BcnJvd0xlZnRcIiwgcnVuOiBjdXJzb3JHcm91cExlZnQsIHNoaWZ0OiBzZWxlY3RHcm91cExlZnQsIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBtYWM6IFwiQ21kLUFycm93TGVmdFwiLCBydW46IGN1cnNvckxpbmVCb3VuZGFyeUxlZnQsIHNoaWZ0OiBzZWxlY3RMaW5lQm91bmRhcnlMZWZ0LCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsga2V5OiBcIkFycm93UmlnaHRcIiwgcnVuOiBjdXJzb3JDaGFyUmlnaHQsIHNoaWZ0OiBzZWxlY3RDaGFyUmlnaHQsIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBrZXk6IFwiTW9kLUFycm93UmlnaHRcIiwgbWFjOiBcIkFsdC1BcnJvd1JpZ2h0XCIsIHJ1bjogY3Vyc29yR3JvdXBSaWdodCwgc2hpZnQ6IHNlbGVjdEdyb3VwUmlnaHQsIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBtYWM6IFwiQ21kLUFycm93UmlnaHRcIiwgcnVuOiBjdXJzb3JMaW5lQm91bmRhcnlSaWdodCwgc2hpZnQ6IHNlbGVjdExpbmVCb3VuZGFyeVJpZ2h0LCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsga2V5OiBcIkFycm93VXBcIiwgcnVuOiBjdXJzb3JMaW5lVXAsIHNoaWZ0OiBzZWxlY3RMaW5lVXAsIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBtYWM6IFwiQ21kLUFycm93VXBcIiwgcnVuOiBjdXJzb3JEb2NTdGFydCwgc2hpZnQ6IHNlbGVjdERvY1N0YXJ0IH0sXG4gICAgeyBtYWM6IFwiQ3RybC1BcnJvd1VwXCIsIHJ1bjogY3Vyc29yUGFnZVVwLCBzaGlmdDogc2VsZWN0UGFnZVVwIH0sXG4gICAgeyBrZXk6IFwiQXJyb3dEb3duXCIsIHJ1bjogY3Vyc29yTGluZURvd24sIHNoaWZ0OiBzZWxlY3RMaW5lRG93biwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IG1hYzogXCJDbWQtQXJyb3dEb3duXCIsIHJ1bjogY3Vyc29yRG9jRW5kLCBzaGlmdDogc2VsZWN0RG9jRW5kIH0sXG4gICAgeyBtYWM6IFwiQ3RybC1BcnJvd0Rvd25cIiwgcnVuOiBjdXJzb3JQYWdlRG93biwgc2hpZnQ6IHNlbGVjdFBhZ2VEb3duIH0sXG4gICAgeyBrZXk6IFwiUGFnZVVwXCIsIHJ1bjogY3Vyc29yUGFnZVVwLCBzaGlmdDogc2VsZWN0UGFnZVVwIH0sXG4gICAgeyBrZXk6IFwiUGFnZURvd25cIiwgcnVuOiBjdXJzb3JQYWdlRG93biwgc2hpZnQ6IHNlbGVjdFBhZ2VEb3duIH0sXG4gICAgeyBrZXk6IFwiSG9tZVwiLCBydW46IGN1cnNvckxpbmVCb3VuZGFyeUJhY2t3YXJkLCBzaGlmdDogc2VsZWN0TGluZUJvdW5kYXJ5QmFja3dhcmQsIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBrZXk6IFwiTW9kLUhvbWVcIiwgcnVuOiBjdXJzb3JEb2NTdGFydCwgc2hpZnQ6IHNlbGVjdERvY1N0YXJ0IH0sXG4gICAgeyBrZXk6IFwiRW5kXCIsIHJ1bjogY3Vyc29yTGluZUJvdW5kYXJ5Rm9yd2FyZCwgc2hpZnQ6IHNlbGVjdExpbmVCb3VuZGFyeUZvcndhcmQsIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBrZXk6IFwiTW9kLUVuZFwiLCBydW46IGN1cnNvckRvY0VuZCwgc2hpZnQ6IHNlbGVjdERvY0VuZCB9LFxuICAgIHsga2V5OiBcIkVudGVyXCIsIHJ1bjogaW5zZXJ0TmV3bGluZUFuZEluZGVudCB9LFxuICAgIHsga2V5OiBcIk1vZC1hXCIsIHJ1bjogc2VsZWN0QWxsIH0sXG4gICAgeyBrZXk6IFwiQmFja3NwYWNlXCIsIHJ1bjogZGVsZXRlQ2hhckJhY2t3YXJkLCBzaGlmdDogZGVsZXRlQ2hhckJhY2t3YXJkIH0sXG4gICAgeyBrZXk6IFwiRGVsZXRlXCIsIHJ1bjogZGVsZXRlQ2hhckZvcndhcmQgfSxcbiAgICB7IGtleTogXCJNb2QtQmFja3NwYWNlXCIsIG1hYzogXCJBbHQtQmFja3NwYWNlXCIsIHJ1bjogZGVsZXRlR3JvdXBCYWNrd2FyZCB9LFxuICAgIHsga2V5OiBcIk1vZC1EZWxldGVcIiwgbWFjOiBcIkFsdC1EZWxldGVcIiwgcnVuOiBkZWxldGVHcm91cEZvcndhcmQgfSxcbiAgICB7IG1hYzogXCJNb2QtQmFja3NwYWNlXCIsIHJ1bjogZGVsZXRlTGluZUJvdW5kYXJ5QmFja3dhcmQgfSxcbiAgICB7IG1hYzogXCJNb2QtRGVsZXRlXCIsIHJ1bjogZGVsZXRlTGluZUJvdW5kYXJ5Rm9yd2FyZCB9XG5dLmNvbmNhdCgvKkBfX1BVUkVfXyovZW1hY3NTdHlsZUtleW1hcC5tYXAoYiA9PiAoeyBtYWM6IGIua2V5LCBydW46IGIucnVuLCBzaGlmdDogYi5zaGlmdCB9KSkpO1xuLyoqXG5UaGUgZGVmYXVsdCBrZXltYXAuIEluY2x1ZGVzIGFsbCBiaW5kaW5ncyBmcm9tXG5bYHN0YW5kYXJkS2V5bWFwYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zdGFuZGFyZEtleW1hcCkgcGx1cyB0aGUgZm9sbG93aW5nOlxuXG4tIEFsdC1BcnJvd0xlZnQgKEN0cmwtQXJyb3dMZWZ0IG9uIG1hY09TKTogW2BjdXJzb3JTeW50YXhMZWZ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JTeW50YXhMZWZ0KSAoW2BzZWxlY3RTeW50YXhMZWZ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RTeW50YXhMZWZ0KSB3aXRoIFNoaWZ0KVxuLSBBbHQtQXJyb3dSaWdodCAoQ3RybC1BcnJvd1JpZ2h0IG9uIG1hY09TKTogW2BjdXJzb3JTeW50YXhSaWdodGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yU3ludGF4UmlnaHQpIChbYHNlbGVjdFN5bnRheFJpZ2h0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RTeW50YXhSaWdodCkgd2l0aCBTaGlmdClcbi0gQWx0LUFycm93VXA6IFtgbW92ZUxpbmVVcGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMubW92ZUxpbmVVcClcbi0gQWx0LUFycm93RG93bjogW2Btb3ZlTGluZURvd25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLm1vdmVMaW5lRG93bilcbi0gU2hpZnQtQWx0LUFycm93VXA6IFtgY29weUxpbmVVcGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY29weUxpbmVVcClcbi0gU2hpZnQtQWx0LUFycm93RG93bjogW2Bjb3B5TGluZURvd25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmNvcHlMaW5lRG93bilcbi0gRXNjYXBlOiBbYHNpbXBsaWZ5U2VsZWN0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zaW1wbGlmeVNlbGVjdGlvbilcbi0gQ3RybC1FbnRlciAoQ21kLUVudGVyIG9uIG1hY09TKTogW2BpbnNlcnRCbGFua0xpbmVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmluc2VydEJsYW5rTGluZSlcbi0gQWx0LWwgKEN0cmwtbCBvbiBtYWNPUyk6IFtgc2VsZWN0TGluZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0TGluZSlcbi0gQ3RybC1pIChDbWQtaSBvbiBtYWNPUyk6IFtgc2VsZWN0UGFyZW50U3ludGF4YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RQYXJlbnRTeW50YXgpXG4tIEN0cmwtWyAoQ21kLVsgb24gbWFjT1MpOiBbYGluZGVudExlc3NgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmluZGVudExlc3MpXG4tIEN0cmwtXSAoQ21kLV0gb24gbWFjT1MpOiBbYGluZGVudE1vcmVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmluZGVudE1vcmUpXG4tIEN0cmwtQWx0LVxcXFwgKENtZC1BbHQtXFxcXCBvbiBtYWNPUyk6IFtgaW5kZW50U2VsZWN0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5pbmRlbnRTZWxlY3Rpb24pXG4tIFNoaWZ0LUN0cmwtayAoU2hpZnQtQ21kLWsgb24gbWFjT1MpOiBbYGRlbGV0ZUxpbmVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmRlbGV0ZUxpbmUpXG4tIFNoaWZ0LUN0cmwtXFxcXCAoU2hpZnQtQ21kLVxcXFwgb24gbWFjT1MpOiBbYGN1cnNvck1hdGNoaW5nQnJhY2tldGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yTWF0Y2hpbmdCcmFja2V0KVxuLSBDdHJsLS8gKENtZC0vIG9uIG1hY09TKTogW2B0b2dnbGVDb21tZW50YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy50b2dnbGVDb21tZW50KS5cbi0gU2hpZnQtQWx0LWE6IFtgdG9nZ2xlQmxvY2tDb21tZW50YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy50b2dnbGVCbG9ja0NvbW1lbnQpLlxuKi9cbmNvbnN0IGRlZmF1bHRLZXltYXAgPSAvKkBfX1BVUkVfXyovW1xuICAgIHsga2V5OiBcIkFsdC1BcnJvd0xlZnRcIiwgbWFjOiBcIkN0cmwtQXJyb3dMZWZ0XCIsIHJ1bjogY3Vyc29yU3ludGF4TGVmdCwgc2hpZnQ6IHNlbGVjdFN5bnRheExlZnQgfSxcbiAgICB7IGtleTogXCJBbHQtQXJyb3dSaWdodFwiLCBtYWM6IFwiQ3RybC1BcnJvd1JpZ2h0XCIsIHJ1bjogY3Vyc29yU3ludGF4UmlnaHQsIHNoaWZ0OiBzZWxlY3RTeW50YXhSaWdodCB9LFxuICAgIHsga2V5OiBcIkFsdC1BcnJvd1VwXCIsIHJ1bjogbW92ZUxpbmVVcCB9LFxuICAgIHsga2V5OiBcIlNoaWZ0LUFsdC1BcnJvd1VwXCIsIHJ1bjogY29weUxpbmVVcCB9LFxuICAgIHsga2V5OiBcIkFsdC1BcnJvd0Rvd25cIiwgcnVuOiBtb3ZlTGluZURvd24gfSxcbiAgICB7IGtleTogXCJTaGlmdC1BbHQtQXJyb3dEb3duXCIsIHJ1bjogY29weUxpbmVEb3duIH0sXG4gICAgeyBrZXk6IFwiRXNjYXBlXCIsIHJ1bjogc2ltcGxpZnlTZWxlY3Rpb24gfSxcbiAgICB7IGtleTogXCJNb2QtRW50ZXJcIiwgcnVuOiBpbnNlcnRCbGFua0xpbmUgfSxcbiAgICB7IGtleTogXCJBbHQtbFwiLCBtYWM6IFwiQ3RybC1sXCIsIHJ1bjogc2VsZWN0TGluZSB9LFxuICAgIHsga2V5OiBcIk1vZC1pXCIsIHJ1bjogc2VsZWN0UGFyZW50U3ludGF4LCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsga2V5OiBcIk1vZC1bXCIsIHJ1bjogaW5kZW50TGVzcyB9LFxuICAgIHsga2V5OiBcIk1vZC1dXCIsIHJ1bjogaW5kZW50TW9yZSB9LFxuICAgIHsga2V5OiBcIk1vZC1BbHQtXFxcXFwiLCBydW46IGluZGVudFNlbGVjdGlvbiB9LFxuICAgIHsga2V5OiBcIlNoaWZ0LU1vZC1rXCIsIHJ1bjogZGVsZXRlTGluZSB9LFxuICAgIHsga2V5OiBcIlNoaWZ0LU1vZC1cXFxcXCIsIHJ1bjogY3Vyc29yTWF0Y2hpbmdCcmFja2V0IH0sXG4gICAgeyBrZXk6IFwiTW9kLS9cIiwgcnVuOiB0b2dnbGVDb21tZW50IH0sXG4gICAgeyBrZXk6IFwiQWx0LUFcIiwgcnVuOiB0b2dnbGVCbG9ja0NvbW1lbnQgfVxuXS5jb25jYXQoc3RhbmRhcmRLZXltYXApO1xuLyoqXG5BIGJpbmRpbmcgdGhhdCBiaW5kcyBUYWIgdG8gW2BpbmRlbnRNb3JlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5pbmRlbnRNb3JlKSBhbmRcblNoaWZ0LVRhYiB0byBbYGluZGVudExlc3NgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmluZGVudExlc3MpLlxuUGxlYXNlIHNlZSB0aGUgW1RhYiBleGFtcGxlXSguLi8uLi9leGFtcGxlcy90YWIvKSBiZWZvcmUgdXNpbmdcbnRoaXMuXG4qL1xuY29uc3QgaW5kZW50V2l0aFRhYiA9IHsga2V5OiBcIlRhYlwiLCBydW46IGluZGVudE1vcmUsIHNoaWZ0OiBpbmRlbnRMZXNzIH07XG5cbmV4cG9ydCB7IGJsb2NrQ29tbWVudCwgYmxvY2tVbmNvbW1lbnQsIGNvcHlMaW5lRG93biwgY29weUxpbmVVcCwgY3Vyc29yQ2hhckJhY2t3YXJkLCBjdXJzb3JDaGFyRm9yd2FyZCwgY3Vyc29yQ2hhckxlZnQsIGN1cnNvckNoYXJSaWdodCwgY3Vyc29yRG9jRW5kLCBjdXJzb3JEb2NTdGFydCwgY3Vyc29yR3JvdXBCYWNrd2FyZCwgY3Vyc29yR3JvdXBGb3J3YXJkLCBjdXJzb3JHcm91cExlZnQsIGN1cnNvckdyb3VwUmlnaHQsIGN1cnNvckxpbmVCb3VuZGFyeUJhY2t3YXJkLCBjdXJzb3JMaW5lQm91bmRhcnlGb3J3YXJkLCBjdXJzb3JMaW5lQm91bmRhcnlMZWZ0LCBjdXJzb3JMaW5lQm91bmRhcnlSaWdodCwgY3Vyc29yTGluZURvd24sIGN1cnNvckxpbmVFbmQsIGN1cnNvckxpbmVTdGFydCwgY3Vyc29yTGluZVVwLCBjdXJzb3JNYXRjaGluZ0JyYWNrZXQsIGN1cnNvclBhZ2VEb3duLCBjdXJzb3JQYWdlVXAsIGN1cnNvclN1YndvcmRCYWNrd2FyZCwgY3Vyc29yU3Vid29yZEZvcndhcmQsIGN1cnNvclN5bnRheExlZnQsIGN1cnNvclN5bnRheFJpZ2h0LCBkZWZhdWx0S2V5bWFwLCBkZWxldGVDaGFyQmFja3dhcmQsIGRlbGV0ZUNoYXJGb3J3YXJkLCBkZWxldGVHcm91cEJhY2t3YXJkLCBkZWxldGVHcm91cEZvcndhcmQsIGRlbGV0ZUxpbmUsIGRlbGV0ZUxpbmVCb3VuZGFyeUJhY2t3YXJkLCBkZWxldGVMaW5lQm91bmRhcnlGb3J3YXJkLCBkZWxldGVUb0xpbmVFbmQsIGRlbGV0ZVRvTGluZVN0YXJ0LCBkZWxldGVUcmFpbGluZ1doaXRlc3BhY2UsIGVtYWNzU3R5bGVLZXltYXAsIGhpc3RvcnksIGhpc3RvcnlGaWVsZCwgaGlzdG9yeUtleW1hcCwgaW5kZW50TGVzcywgaW5kZW50TW9yZSwgaW5kZW50U2VsZWN0aW9uLCBpbmRlbnRXaXRoVGFiLCBpbnNlcnRCbGFua0xpbmUsIGluc2VydE5ld2xpbmUsIGluc2VydE5ld2xpbmVBbmRJbmRlbnQsIGluc2VydFRhYiwgaW52ZXJ0ZWRFZmZlY3RzLCBpc29sYXRlSGlzdG9yeSwgbGluZUNvbW1lbnQsIGxpbmVVbmNvbW1lbnQsIG1vdmVMaW5lRG93biwgbW92ZUxpbmVVcCwgcmVkbywgcmVkb0RlcHRoLCByZWRvU2VsZWN0aW9uLCBzZWxlY3RBbGwsIHNlbGVjdENoYXJCYWNrd2FyZCwgc2VsZWN0Q2hhckZvcndhcmQsIHNlbGVjdENoYXJMZWZ0LCBzZWxlY3RDaGFyUmlnaHQsIHNlbGVjdERvY0VuZCwgc2VsZWN0RG9jU3RhcnQsIHNlbGVjdEdyb3VwQmFja3dhcmQsIHNlbGVjdEdyb3VwRm9yd2FyZCwgc2VsZWN0R3JvdXBMZWZ0LCBzZWxlY3RHcm91cFJpZ2h0LCBzZWxlY3RMaW5lLCBzZWxlY3RMaW5lQm91bmRhcnlCYWNrd2FyZCwgc2VsZWN0TGluZUJvdW5kYXJ5Rm9yd2FyZCwgc2VsZWN0TGluZUJvdW5kYXJ5TGVmdCwgc2VsZWN0TGluZUJvdW5kYXJ5UmlnaHQsIHNlbGVjdExpbmVEb3duLCBzZWxlY3RMaW5lRW5kLCBzZWxlY3RMaW5lU3RhcnQsIHNlbGVjdExpbmVVcCwgc2VsZWN0TWF0Y2hpbmdCcmFja2V0LCBzZWxlY3RQYWdlRG93biwgc2VsZWN0UGFnZVVwLCBzZWxlY3RQYXJlbnRTeW50YXgsIHNlbGVjdFN1YndvcmRCYWNrd2FyZCwgc2VsZWN0U3Vid29yZEZvcndhcmQsIHNlbGVjdFN5bnRheExlZnQsIHNlbGVjdFN5bnRheFJpZ2h0LCBzaW1wbGlmeVNlbGVjdGlvbiwgc3BsaXRMaW5lLCBzdGFuZGFyZEtleW1hcCwgdG9nZ2xlQmxvY2tDb21tZW50LCB0b2dnbGVCbG9ja0NvbW1lbnRCeUxpbmUsIHRvZ2dsZUNvbW1lbnQsIHRvZ2dsZUxpbmVDb21tZW50LCB0cmFuc3Bvc2VDaGFycywgdW5kbywgdW5kb0RlcHRoLCB1bmRvU2VsZWN0aW9uIH07XG4iXSwibmFtZXMiOlsiQW5ub3RhdGlvbiIsIkZhY2V0IiwiY29tYmluZUNvbmZpZyIsIlN0YXRlRmllbGQiLCJUcmFuc2FjdGlvbiIsIkNoYW5nZVNldCIsIkNoYW5nZURlc2MiLCJFZGl0b3JTZWxlY3Rpb24iLCJTdGF0ZUVmZmVjdCIsIlRleHQiLCJmaW5kQ2x1c3RlckJyZWFrIiwiY291bnRDb2x1bW4iLCJDaGFyQ2F0ZWdvcnkiLCJFZGl0b3JWaWV3IiwiRGlyZWN0aW9uIiwiSW5kZW50Q29udGV4dCIsImdldEluZGVudGF0aW9uIiwiaW5kZW50U3RyaW5nIiwibWF0Y2hCcmFja2V0cyIsInN5bnRheFRyZWUiLCJnZXRJbmRlbnRVbml0IiwiaW5kZW50VW5pdCIsIk5vZGVQcm9wIiwidG9nZ2xlQ29tbWVudCIsInRhcmdldCIsInN0YXRlIiwibGluZSIsImRvYyIsImxpbmVBdCIsInNlbGVjdGlvbiIsIm1haW4iLCJmcm9tIiwiY29uZmlnIiwiZ2V0Q29uZmlnIiwidG9nZ2xlTGluZUNvbW1lbnQiLCJibG9jayIsInRvZ2dsZUJsb2NrQ29tbWVudEJ5TGluZSIsImNvbW1hbmQiLCJmIiwib3B0aW9uIiwiZGlzcGF0Y2giLCJyZWFkT25seSIsInRyIiwidXBkYXRlIiwiY2hhbmdlTGluZUNvbW1lbnQiLCJsaW5lQ29tbWVudCIsImxpbmVVbmNvbW1lbnQiLCJ0b2dnbGVCbG9ja0NvbW1lbnQiLCJjaGFuZ2VCbG9ja0NvbW1lbnQiLCJibG9ja0NvbW1lbnQiLCJibG9ja1VuY29tbWVudCIsIm8iLCJzIiwic2VsZWN0ZWRMaW5lUmFuZ2VzIiwicG9zIiwiZGF0YSIsImxhbmd1YWdlRGF0YUF0IiwibGVuZ3RoIiwiU2VhcmNoTWFyZ2luIiwiZmluZEJsb2NrQ29tbWVudCIsIm9wZW4iLCJjbG9zZSIsInRvIiwidGV4dEJlZm9yZSIsInNsaWNlRG9jIiwidGV4dEFmdGVyIiwic3BhY2VCZWZvcmUiLCJleGVjIiwic3BhY2VBZnRlciIsImJlZm9yZU9mZiIsInNsaWNlIiwibWFyZ2luIiwic3RhcnRUZXh0IiwiZW5kVGV4dCIsInN0YXJ0U3BhY2UiLCJlbmRTcGFjZSIsImVuZE9mZiIsInRlc3QiLCJjaGFyQXQiLCJyYW5nZXMiLCJyIiwiZnJvbUxpbmUiLCJ0b0xpbmUiLCJsYXN0IiwicHVzaCIsInRleHQiLCJ0b2tlbnMiLCJtYXAiLCJldmVyeSIsImMiLCJjb21tZW50cyIsImkiLCJjaGFuZ2VzIiwicmFuZ2UiLCJpbnNlcnQiLCJzb21lIiwiY29tbWVudCIsInRva2VuIiwibGluZXMiLCJwcmV2TGluZSIsInN0YXJ0SSIsIm1pbkluZGVudCIsImluZGVudCIsImVtcHR5Iiwic2luZ2xlIiwibCIsImNoYW5nZVNldCIsImZyb21IaXN0b3J5IiwiZGVmaW5lIiwiaXNvbGF0ZUhpc3RvcnkiLCJpbnZlcnRlZEVmZmVjdHMiLCJoaXN0b3J5Q29uZmlnIiwiY29tYmluZSIsImNvbmZpZ3MiLCJtaW5EZXB0aCIsIm5ld0dyb3VwRGVsYXkiLCJqb2luVG9FdmVudCIsIl90IiwiaXNBZGphY2VudCIsIk1hdGgiLCJtYXgiLCJtaW4iLCJhIiwiYiIsImFkaiIsImhpc3RvcnlGaWVsZF8iLCJjcmVhdGUiLCJIaXN0b3J5U3RhdGUiLCJmYWNldCIsImZyb21IaXN0IiwiYW5ub3RhdGlvbiIsIml0ZW0iLCJIaXN0RXZlbnQiLCJmcm9tVHJhbnNhY3Rpb24iLCJzaWRlIiwib3RoZXIiLCJ1bmRvbmUiLCJkb25lIiwidXBkYXRlQnJhbmNoIiwiYWRkU2VsZWN0aW9uIiwic3RhcnRTdGF0ZSIsInJlc3QiLCJpc29sYXRlIiwiYWRkVG9IaXN0b3J5IiwiYWRkTWFwcGluZyIsImRlc2MiLCJldmVudCIsInRpbWUiLCJ1c2VyRXZlbnQiLCJhZGRDaGFuZ2VzIiwidG9KU09OIiwidmFsdWUiLCJlIiwiZnJvbUpTT04iLCJqc29uIiwiaGlzdG9yeSIsIm9mIiwiZG9tRXZlbnRIYW5kbGVycyIsImJlZm9yZWlucHV0IiwidmlldyIsImlucHV0VHlwZSIsInVuZG8iLCJyZWRvIiwicHJldmVudERlZmF1bHQiLCJoaXN0b3J5RmllbGQiLCJjbWQiLCJoaXN0b3J5U3RhdGUiLCJmaWVsZCIsInBvcCIsInVuZG9TZWxlY3Rpb24iLCJyZWRvU2VsZWN0aW9uIiwiZGVwdGgiLCJoaXN0U3RhdGUiLCJicmFuY2giLCJ1bmRvRGVwdGgiLCJyZWRvRGVwdGgiLCJjb25zdHJ1Y3RvciIsImVmZmVjdHMiLCJtYXBwZWQiLCJzdGFydFNlbGVjdGlvbiIsInNlbGVjdGlvbnNBZnRlciIsInNldFNlbEFmdGVyIiwiYWZ0ZXIiLCJfYSIsIl9iIiwiX2MiLCJub25lIiwiaW52ZXJ0IiwicmVzdWx0IiwiY29uY2F0IiwidW5kZWZpbmVkIiwic2VsZWN0aW9ucyIsIm1heExlbiIsIm5ld0V2ZW50Iiwic3RhcnQiLCJuZXdCcmFuY2giLCJpdGVyQ2hhbmdlZFJhbmdlcyIsInQiLCJfZiIsImVxU2VsZWN0aW9uU2hhcGUiLCJmaWx0ZXIiLCJjb25jIiwiTWF4U2VsZWN0aW9uc1BlckV2ZW50IiwibGFzdEV2ZW50Iiwic2VscyIsImVxIiwicG9wU2VsZWN0aW9uIiwiYWRkTWFwcGluZ1RvQnJhbmNoIiwibWFwcGluZyIsIm1hcEV2ZW50IiwiZXh0cmFTZWxlY3Rpb25zIiwibWFwcGVkQ2hhbmdlcyIsImJlZm9yZSIsIm1hcERlc2MiLCJmdWxsTWFwcGluZyIsImNvbXBvc2VEZXNjIiwibWFwRWZmZWN0cyIsImpvaW5hYmxlVXNlckV2ZW50IiwicHJldlRpbWUiLCJwcmV2VXNlckV2ZW50IiwiY29tcG9zZSIsIm9ubHlTZWxlY3Rpb24iLCJhbm5vdGF0aW9ucyIsInNjcm9sbEludG9WaWV3IiwiaGlzdG9yeUtleW1hcCIsImtleSIsInJ1biIsIm1hYyIsImxpbnV4IiwidXBkYXRlU2VsIiwic2VsIiwiYnkiLCJtYWluSW5kZXgiLCJzZXRTZWwiLCJtb3ZlU2VsIiwiaG93IiwicmFuZ2VFbmQiLCJmb3J3YXJkIiwiY3Vyc29yIiwiY3Vyc29yQnlDaGFyIiwibW92ZUJ5Q2hhciIsImx0ckF0Q3Vyc29yIiwidGV4dERpcmVjdGlvbkF0IiwiaGVhZCIsIkxUUiIsImN1cnNvckNoYXJMZWZ0IiwiY3Vyc29yQ2hhclJpZ2h0IiwiY3Vyc29yQ2hhckZvcndhcmQiLCJjdXJzb3JDaGFyQmFja3dhcmQiLCJjdXJzb3JCeUdyb3VwIiwibW92ZUJ5R3JvdXAiLCJjdXJzb3JHcm91cExlZnQiLCJjdXJzb3JHcm91cFJpZ2h0IiwiY3Vyc29yR3JvdXBGb3J3YXJkIiwiY3Vyc29yR3JvdXBCYWNrd2FyZCIsInNlZ21lbnRlciIsIkludGwiLCJTZWdtZW50ZXIiLCJncmFudWxhcml0eSIsIm1vdmVCeVN1YndvcmQiLCJjYXRlZ29yaXplIiwiY2hhckNhdGVnb3JpemVyIiwiY2F0IiwiU3BhY2UiLCJzdGVwcyIsInNhd1VwcGVyIiwic2F3TG93ZXIiLCJzdGVwIiwibmV4dCIsIm5leHRDYXQiLCJhaGVhZCIsIldvcmQiLCJjaGFyQ29kZUF0IiwidG9Mb3dlckNhc2UiLCJlbmQiLCJza2lwcGVkIiwic2VnbWVudHMiLCJBcnJheSIsInNlZ21lbnQiLCJpbmRleCIsImN1cnNvckJ5U3Vid29yZCIsImN1cnNvclN1YndvcmRGb3J3YXJkIiwiY3Vyc29yU3Vid29yZEJhY2t3YXJkIiwiaW50ZXJlc3RpbmdOb2RlIiwibm9kZSIsImJyYWNrZXRQcm9wIiwidHlwZSIsInByb3AiLCJsZW4iLCJmaXJzdENoaWxkIiwibW92ZUJ5U3ludGF4IiwicmVzb2x2ZUlubmVyIiwiY2xvc2VkQnkiLCJvcGVuZWRCeSIsImF0IiwiY2hpbGRBZnRlciIsImNoaWxkQmVmb3JlIiwiYnJhY2tldCIsIm1hdGNoIiwibmV3UG9zIiwibWF0Y2hlZCIsImN1cnNvclN5bnRheExlZnQiLCJjdXJzb3JTeW50YXhSaWdodCIsImN1cnNvckJ5TGluZSIsIm1vdmVkIiwibW92ZVZlcnRpY2FsbHkiLCJtb3ZlVG9MaW5lQm91bmRhcnkiLCJjdXJzb3JMaW5lVXAiLCJjdXJzb3JMaW5lRG93biIsInBhZ2VJbmZvIiwic2VsZlNjcm9sbCIsInNjcm9sbERPTSIsImNsaWVudEhlaWdodCIsInNjcm9sbEhlaWdodCIsIm1hcmdpblRvcCIsIm1hcmdpbkJvdHRvbSIsImhlaWdodCIsInNvdXJjZSIsInNjcm9sbE1hcmdpbnMiLCJtYXJnaW5zIiwidG9wIiwiYm90dG9tIiwiZG9tIiwib3duZXJEb2N1bWVudCIsImRlZmF1bHRWaWV3Iiwid2luZG93IiwiaW5uZXJIZWlnaHQiLCJkZWZhdWx0TGluZUhlaWdodCIsImN1cnNvckJ5UGFnZSIsInBhZ2UiLCJlZmZlY3QiLCJzdGFydFBvcyIsImNvb3Jkc0F0UG9zIiwic2Nyb2xsUmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInNjcm9sbFRvcCIsInNjcm9sbEJvdHRvbSIsInkiLCJ5TWFyZ2luIiwiY3Vyc29yUGFnZVVwIiwiY3Vyc29yUGFnZURvd24iLCJtb3ZlQnlMaW5lQm91bmRhcnkiLCJsaW5lQmxvY2tBdCIsInNwYWNlIiwiY3Vyc29yTGluZUJvdW5kYXJ5Rm9yd2FyZCIsImN1cnNvckxpbmVCb3VuZGFyeUJhY2t3YXJkIiwiY3Vyc29yTGluZUJvdW5kYXJ5TGVmdCIsImN1cnNvckxpbmVCb3VuZGFyeVJpZ2h0IiwiY3Vyc29yTGluZVN0YXJ0IiwiY3Vyc29yTGluZUVuZCIsInRvTWF0Y2hpbmdCcmFja2V0IiwiZXh0ZW5kIiwiZm91bmQiLCJtYXRjaGluZyIsImFuY2hvciIsImN1cnNvck1hdGNoaW5nQnJhY2tldCIsInNlbGVjdE1hdGNoaW5nQnJhY2tldCIsImV4dGVuZFNlbCIsImdvYWxDb2x1bW4iLCJiaWRpTGV2ZWwiLCJzZWxlY3RCeUNoYXIiLCJzZWxlY3RDaGFyTGVmdCIsInNlbGVjdENoYXJSaWdodCIsInNlbGVjdENoYXJGb3J3YXJkIiwic2VsZWN0Q2hhckJhY2t3YXJkIiwic2VsZWN0QnlHcm91cCIsInNlbGVjdEdyb3VwTGVmdCIsInNlbGVjdEdyb3VwUmlnaHQiLCJzZWxlY3RHcm91cEZvcndhcmQiLCJzZWxlY3RHcm91cEJhY2t3YXJkIiwic2VsZWN0QnlTdWJ3b3JkIiwic2VsZWN0U3Vid29yZEZvcndhcmQiLCJzZWxlY3RTdWJ3b3JkQmFja3dhcmQiLCJzZWxlY3RTeW50YXhMZWZ0Iiwic2VsZWN0U3ludGF4UmlnaHQiLCJzZWxlY3RCeUxpbmUiLCJzZWxlY3RMaW5lVXAiLCJzZWxlY3RMaW5lRG93biIsInNlbGVjdEJ5UGFnZSIsInNlbGVjdFBhZ2VVcCIsInNlbGVjdFBhZ2VEb3duIiwic2VsZWN0TGluZUJvdW5kYXJ5Rm9yd2FyZCIsInNlbGVjdExpbmVCb3VuZGFyeUJhY2t3YXJkIiwic2VsZWN0TGluZUJvdW5kYXJ5TGVmdCIsInNlbGVjdExpbmVCb3VuZGFyeVJpZ2h0Iiwic2VsZWN0TGluZVN0YXJ0Iiwic2VsZWN0TGluZUVuZCIsImN1cnNvckRvY1N0YXJ0IiwiY3Vyc29yRG9jRW5kIiwic2VsZWN0RG9jU3RhcnQiLCJzZWxlY3REb2NFbmQiLCJzZWxlY3RBbGwiLCJzZWxlY3RMaW5lIiwic2VsZWN0ZWRMaW5lQmxvY2tzIiwic2VsZWN0UGFyZW50U3ludGF4Iiwic3RhY2siLCJyZXNvbHZlU3RhY2siLCJjdXIiLCJwYXJlbnQiLCJzaW1wbGlmeVNlbGVjdGlvbiIsImRlbGV0ZUJ5IiwiY2hhbmdlQnlSYW5nZSIsInRvd2FyZHMiLCJza2lwQXRvbWljIiwiYW5ub3VuY2UiLCJwaHJhc2UiLCJhdG9taWNSYW5nZXMiLCJiZXR3ZWVuIiwiZGVsZXRlQnlDaGFyIiwidGFyZ2V0UG9zIiwiY29sIiwidGFiU2l6ZSIsImRyb3AiLCJudW1iZXIiLCJkZWxldGVDaGFyQmFja3dhcmQiLCJkZWxldGVDaGFyRm9yd2FyZCIsImRlbGV0ZUJ5R3JvdXAiLCJuZXh0Q2hhciIsImRlbGV0ZUdyb3VwQmFja3dhcmQiLCJkZWxldGVHcm91cEZvcndhcmQiLCJkZWxldGVUb0xpbmVFbmQiLCJsaW5lRW5kIiwiZGVsZXRlVG9MaW5lU3RhcnQiLCJsaW5lU3RhcnQiLCJkZWxldGVMaW5lQm91bmRhcnlCYWNrd2FyZCIsImRlbGV0ZUxpbmVCb3VuZGFyeUZvcndhcmQiLCJkZWxldGVUcmFpbGluZ1doaXRlc3BhY2UiLCJwcmV2IiwiaXRlciIsImxpbmVCcmVhayIsInRyYWlsaW5nIiwic2VhcmNoIiwic3BsaXRMaW5lIiwidHJhbnNwb3NlQ2hhcnMiLCJhcHBlbmQiLCJibG9ja3MiLCJ1cHRvIiwic3RhcnRMaW5lIiwiZW5kTGluZSIsIm1vdmVMaW5lIiwibmV4dExpbmUiLCJzaXplIiwibW92ZUxpbmVVcCIsIm1vdmVMaW5lRG93biIsImNvcHlMaW5lIiwiY29weUxpbmVVcCIsImNvcHlMaW5lRG93biIsImRlbGV0ZUxpbmUiLCJpbnNlcnROZXdsaW5lIiwicmVwbGFjZVNlbGVjdGlvbiIsImlzQmV0d2VlbkJyYWNrZXRzIiwiY29udGV4dCIsImluZGV4T2YiLCJuYW1lIiwiaW5zZXJ0TmV3bGluZUFuZEluZGVudCIsIm5ld2xpbmVBbmRJbmRlbnQiLCJpbnNlcnRCbGFua0xpbmUiLCJhdEVvZiIsImV4cGxvZGUiLCJjeCIsInNpbXVsYXRlQnJlYWsiLCJzaW11bGF0ZURvdWJsZUJyZWFrIiwibGluZUluZGVudCIsImNoYW5nZUJ5U2VsZWN0ZWRMaW5lIiwiYXRMaW5lIiwibWFwUG9zIiwiaW5kZW50U2VsZWN0aW9uIiwidXBkYXRlZCIsIk9iamVjdCIsIm92ZXJyaWRlSW5kZW50YXRpb24iLCJub3JtIiwiaW5kZW50TW9yZSIsImluZGVudExlc3MiLCJrZWVwIiwiaW5zZXJ0VGFiIiwiZW1hY3NTdHlsZUtleW1hcCIsInNoaWZ0Iiwic3RhbmRhcmRLZXltYXAiLCJkZWZhdWx0S2V5bWFwIiwiaW5kZW50V2l0aFRhYiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@codemirror/commands/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@codemirror/lang-python/dist/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@codemirror/lang-python/dist/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   globalCompletion: () => (/* binding */ globalCompletion),\n/* harmony export */   localCompletionSource: () => (/* binding */ localCompletionSource),\n/* harmony export */   python: () => (/* binding */ python),\n/* harmony export */   pythonLanguage: () => (/* binding */ pythonLanguage)\n/* harmony export */ });\n/* harmony import */ var _lezer_python__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/python */ \"(ssr)/./node_modules/@lezer/python/dist/index.js\");\n/* harmony import */ var _codemirror_language__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/language */ \"(ssr)/./node_modules/@codemirror/language/dist/index.js\");\n/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lezer/common */ \"(ssr)/./node_modules/@lezer/common/dist/index.js\");\n/* harmony import */ var _codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @codemirror/autocomplete */ \"(ssr)/./node_modules/@codemirror/autocomplete/dist/index.js\");\n\n\n\n\nconst cache = /*@__PURE__*/ new _lezer_common__WEBPACK_IMPORTED_MODULE_1__.NodeWeakMap();\nconst ScopeNodes = /*@__PURE__*/ new Set([\n    \"Script\",\n    \"Body\",\n    \"FunctionDefinition\",\n    \"ClassDefinition\",\n    \"LambdaExpression\",\n    \"ForStatement\",\n    \"MatchClause\"\n]);\nfunction defID(type) {\n    return (node, def, outer)=>{\n        if (outer) return false;\n        let id = node.node.getChild(\"VariableName\");\n        if (id) def(id, type);\n        return true;\n    };\n}\nconst gatherCompletions = {\n    FunctionDefinition: /*@__PURE__*/ defID(\"function\"),\n    ClassDefinition: /*@__PURE__*/ defID(\"class\"),\n    ForStatement (node, def, outer) {\n        if (outer) for(let child = node.node.firstChild; child; child = child.nextSibling){\n            if (child.name == \"VariableName\") def(child, \"variable\");\n            else if (child.name == \"in\") break;\n        }\n    },\n    ImportStatement (_node, def) {\n        var _a, _b;\n        let { node } = _node;\n        let isFrom = ((_a = node.firstChild) === null || _a === void 0 ? void 0 : _a.name) == \"from\";\n        for(let ch = node.getChild(\"import\"); ch; ch = ch.nextSibling){\n            if (ch.name == \"VariableName\" && ((_b = ch.nextSibling) === null || _b === void 0 ? void 0 : _b.name) != \"as\") def(ch, isFrom ? \"variable\" : \"namespace\");\n        }\n    },\n    AssignStatement (node, def) {\n        for(let child = node.node.firstChild; child; child = child.nextSibling){\n            if (child.name == \"VariableName\") def(child, \"variable\");\n            else if (child.name == \":\" || child.name == \"AssignOp\") break;\n        }\n    },\n    ParamList (node, def) {\n        for(let prev = null, child = node.node.firstChild; child; child = child.nextSibling){\n            if (child.name == \"VariableName\" && (!prev || !/\\*|AssignOp/.test(prev.name))) def(child, \"variable\");\n            prev = child;\n        }\n    },\n    CapturePattern: /*@__PURE__*/ defID(\"variable\"),\n    AsPattern: /*@__PURE__*/ defID(\"variable\"),\n    __proto__: null\n};\nfunction getScope(doc, node) {\n    let cached = cache.get(node);\n    if (cached) return cached;\n    let completions = [], top = true;\n    function def(node, type) {\n        let name = doc.sliceString(node.from, node.to);\n        completions.push({\n            label: name,\n            type\n        });\n    }\n    node.cursor(_lezer_common__WEBPACK_IMPORTED_MODULE_1__.IterMode.IncludeAnonymous).iterate((node)=>{\n        if (node.name) {\n            let gather = gatherCompletions[node.name];\n            if (gather && gather(node, def, top) || !top && ScopeNodes.has(node.name)) return false;\n            top = false;\n        } else if (node.to - node.from > 8192) {\n            // Allow caching for bigger internal nodes\n            for (let c of getScope(doc, node.node))completions.push(c);\n            return false;\n        }\n    });\n    cache.set(node, completions);\n    return completions;\n}\nconst Identifier = /^[\\w\\xa1-\\uffff][\\w\\d\\xa1-\\uffff]*$/;\nconst dontComplete = [\n    \"String\",\n    \"FormatString\",\n    \"Comment\",\n    \"PropertyName\"\n];\n/**\nCompletion source that looks up locally defined names in\nPython code.\n*/ function localCompletionSource(context) {\n    let inner = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_2__.syntaxTree)(context.state).resolveInner(context.pos, -1);\n    if (dontComplete.indexOf(inner.name) > -1) return null;\n    let isWord = inner.name == \"VariableName\" || inner.to - inner.from < 20 && Identifier.test(context.state.sliceDoc(inner.from, inner.to));\n    if (!isWord && !context.explicit) return null;\n    let options = [];\n    for(let pos = inner; pos; pos = pos.parent){\n        if (ScopeNodes.has(pos.name)) options = options.concat(getScope(context.state.doc, pos));\n    }\n    return {\n        options,\n        from: isWord ? inner.from : context.pos,\n        validFor: Identifier\n    };\n}\nconst globals = /*@__PURE__*/ [\n    \"__annotations__\",\n    \"__builtins__\",\n    \"__debug__\",\n    \"__doc__\",\n    \"__import__\",\n    \"__name__\",\n    \"__loader__\",\n    \"__package__\",\n    \"__spec__\",\n    \"False\",\n    \"None\",\n    \"True\"\n].map((n)=>({\n        label: n,\n        type: \"constant\"\n    })).concat(/*@__PURE__*/ [\n    \"ArithmeticError\",\n    \"AssertionError\",\n    \"AttributeError\",\n    \"BaseException\",\n    \"BlockingIOError\",\n    \"BrokenPipeError\",\n    \"BufferError\",\n    \"BytesWarning\",\n    \"ChildProcessError\",\n    \"ConnectionAbortedError\",\n    \"ConnectionError\",\n    \"ConnectionRefusedError\",\n    \"ConnectionResetError\",\n    \"DeprecationWarning\",\n    \"EOFError\",\n    \"Ellipsis\",\n    \"EncodingWarning\",\n    \"EnvironmentError\",\n    \"Exception\",\n    \"FileExistsError\",\n    \"FileNotFoundError\",\n    \"FloatingPointError\",\n    \"FutureWarning\",\n    \"GeneratorExit\",\n    \"IOError\",\n    \"ImportError\",\n    \"ImportWarning\",\n    \"IndentationError\",\n    \"IndexError\",\n    \"InterruptedError\",\n    \"IsADirectoryError\",\n    \"KeyError\",\n    \"KeyboardInterrupt\",\n    \"LookupError\",\n    \"MemoryError\",\n    \"ModuleNotFoundError\",\n    \"NameError\",\n    \"NotADirectoryError\",\n    \"NotImplemented\",\n    \"NotImplementedError\",\n    \"OSError\",\n    \"OverflowError\",\n    \"PendingDeprecationWarning\",\n    \"PermissionError\",\n    \"ProcessLookupError\",\n    \"RecursionError\",\n    \"ReferenceError\",\n    \"ResourceWarning\",\n    \"RuntimeError\",\n    \"RuntimeWarning\",\n    \"StopAsyncIteration\",\n    \"StopIteration\",\n    \"SyntaxError\",\n    \"SyntaxWarning\",\n    \"SystemError\",\n    \"SystemExit\",\n    \"TabError\",\n    \"TimeoutError\",\n    \"TypeError\",\n    \"UnboundLocalError\",\n    \"UnicodeDecodeError\",\n    \"UnicodeEncodeError\",\n    \"UnicodeError\",\n    \"UnicodeTranslateError\",\n    \"UnicodeWarning\",\n    \"UserWarning\",\n    \"ValueError\",\n    \"Warning\",\n    \"ZeroDivisionError\"\n].map((n)=>({\n        label: n,\n        type: \"type\"\n    }))).concat(/*@__PURE__*/ [\n    \"bool\",\n    \"bytearray\",\n    \"bytes\",\n    \"classmethod\",\n    \"complex\",\n    \"float\",\n    \"frozenset\",\n    \"int\",\n    \"list\",\n    \"map\",\n    \"memoryview\",\n    \"object\",\n    \"range\",\n    \"set\",\n    \"staticmethod\",\n    \"str\",\n    \"super\",\n    \"tuple\",\n    \"type\"\n].map((n)=>({\n        label: n,\n        type: \"class\"\n    }))).concat(/*@__PURE__*/ [\n    \"abs\",\n    \"aiter\",\n    \"all\",\n    \"anext\",\n    \"any\",\n    \"ascii\",\n    \"bin\",\n    \"breakpoint\",\n    \"callable\",\n    \"chr\",\n    \"compile\",\n    \"delattr\",\n    \"dict\",\n    \"dir\",\n    \"divmod\",\n    \"enumerate\",\n    \"eval\",\n    \"exec\",\n    \"exit\",\n    \"filter\",\n    \"format\",\n    \"getattr\",\n    \"globals\",\n    \"hasattr\",\n    \"hash\",\n    \"help\",\n    \"hex\",\n    \"id\",\n    \"input\",\n    \"isinstance\",\n    \"issubclass\",\n    \"iter\",\n    \"len\",\n    \"license\",\n    \"locals\",\n    \"max\",\n    \"min\",\n    \"next\",\n    \"oct\",\n    \"open\",\n    \"ord\",\n    \"pow\",\n    \"print\",\n    \"property\",\n    \"quit\",\n    \"repr\",\n    \"reversed\",\n    \"round\",\n    \"setattr\",\n    \"slice\",\n    \"sorted\",\n    \"sum\",\n    \"vars\",\n    \"zip\"\n].map((n)=>({\n        label: n,\n        type: \"function\"\n    })));\nconst snippets = [\n    /*@__PURE__*/ (0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_3__.snippetCompletion)(\"def ${name}(${params}):\\n\t${}\", {\n        label: \"def\",\n        detail: \"function\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/ (0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_3__.snippetCompletion)(\"for ${name} in ${collection}:\\n\t${}\", {\n        label: \"for\",\n        detail: \"loop\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/ (0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_3__.snippetCompletion)(\"while ${}:\\n\t${}\", {\n        label: \"while\",\n        detail: \"loop\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/ (0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_3__.snippetCompletion)(\"try:\\n\t${}\\nexcept ${error}:\\n\t${}\", {\n        label: \"try\",\n        detail: \"/ except block\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/ (0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_3__.snippetCompletion)(\"if ${}:\\n\t\\n\", {\n        label: \"if\",\n        detail: \"block\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/ (0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_3__.snippetCompletion)(\"if ${}:\\n\t${}\\nelse:\\n\t${}\", {\n        label: \"if\",\n        detail: \"/ else block\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/ (0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_3__.snippetCompletion)(\"class ${name}:\\n\tdef __init__(self, ${params}):\\n\t\t\t${}\", {\n        label: \"class\",\n        detail: \"definition\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/ (0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_3__.snippetCompletion)(\"import ${module}\", {\n        label: \"import\",\n        detail: \"statement\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/ (0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_3__.snippetCompletion)(\"from ${module} import ${names}\", {\n        label: \"from\",\n        detail: \"import\",\n        type: \"keyword\"\n    })\n];\n/**\nAutocompletion for built-in Python globals and keywords.\n*/ const globalCompletion = /*@__PURE__*/ (0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_3__.ifNotIn)(dontComplete, /*@__PURE__*/ (0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_3__.completeFromList)(/*@__PURE__*/ globals.concat(snippets)));\nfunction indentBody(context, node) {\n    let base = context.baseIndentFor(node);\n    let line = context.lineAt(context.pos, -1), to = line.from + line.text.length;\n    // Don't consider blank, deindented lines at the end of the\n    // block part of the block\n    if (/^\\s*($|#)/.test(line.text) && context.node.to < to + 100 && !/\\S/.test(context.state.sliceDoc(to, context.node.to)) && context.lineIndent(context.pos, -1) <= base) return null;\n    // A normally deindenting keyword that appears at a higher\n    // indentation than the block should probably be handled by the next\n    // level\n    if (/^\\s*(else:|elif |except |finally:)/.test(context.textAfter) && context.lineIndent(context.pos, -1) > base) return null;\n    return base + context.unit;\n}\n/**\nA language provider based on the [Lezer Python\nparser](https://github.com/lezer-parser/python), extended with\nhighlighting and indentation information.\n*/ const pythonLanguage = /*@__PURE__*/ _codemirror_language__WEBPACK_IMPORTED_MODULE_2__.LRLanguage.define({\n    name: \"python\",\n    parser: /*@__PURE__*/ _lezer_python__WEBPACK_IMPORTED_MODULE_0__.parser.configure({\n        props: [\n            /*@__PURE__*/ _codemirror_language__WEBPACK_IMPORTED_MODULE_2__.indentNodeProp.add({\n                Body: (context)=>{\n                    var _a;\n                    return (_a = indentBody(context, context.node)) !== null && _a !== void 0 ? _a : context.continue();\n                },\n                IfStatement: (cx)=>/^\\s*(else:|elif )/.test(cx.textAfter) ? cx.baseIndent : cx.continue(),\n                TryStatement: (cx)=>/^\\s*(except |finally:|else:)/.test(cx.textAfter) ? cx.baseIndent : cx.continue(),\n                \"TupleExpression ComprehensionExpression ParamList ArgList ParenthesizedExpression\": /*@__PURE__*/ (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_2__.delimitedIndent)({\n                    closing: \")\"\n                }),\n                \"DictionaryExpression DictionaryComprehensionExpression SetExpression SetComprehensionExpression\": /*@__PURE__*/ (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_2__.delimitedIndent)({\n                    closing: \"}\"\n                }),\n                \"ArrayExpression ArrayComprehensionExpression\": /*@__PURE__*/ (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_2__.delimitedIndent)({\n                    closing: \"]\"\n                }),\n                \"String FormatString\": ()=>null,\n                Script: (context)=>{\n                    if (context.pos + /\\s*/.exec(context.textAfter)[0].length >= context.node.to) {\n                        let endBody = null;\n                        for(let cur = context.node, to = cur.to;;){\n                            cur = cur.lastChild;\n                            if (!cur || cur.to != to) break;\n                            if (cur.type.name == \"Body\") endBody = cur;\n                        }\n                        if (endBody) {\n                            let bodyIndent = indentBody(context, endBody);\n                            if (bodyIndent != null) return bodyIndent;\n                        }\n                    }\n                    return context.continue();\n                }\n            }),\n            /*@__PURE__*/ _codemirror_language__WEBPACK_IMPORTED_MODULE_2__.foldNodeProp.add({\n                \"ArrayExpression DictionaryExpression SetExpression TupleExpression\": _codemirror_language__WEBPACK_IMPORTED_MODULE_2__.foldInside,\n                Body: (node, state)=>({\n                        from: node.from + 1,\n                        to: node.to - (node.to == state.doc.length ? 0 : 1)\n                    })\n            })\n        ]\n    }),\n    languageData: {\n        closeBrackets: {\n            brackets: [\n                \"(\",\n                \"[\",\n                \"{\",\n                \"'\",\n                '\"',\n                \"'''\",\n                '\"\"\"'\n            ],\n            stringPrefixes: [\n                \"f\",\n                \"fr\",\n                \"rf\",\n                \"r\",\n                \"u\",\n                \"b\",\n                \"br\",\n                \"rb\",\n                \"F\",\n                \"FR\",\n                \"RF\",\n                \"R\",\n                \"U\",\n                \"B\",\n                \"BR\",\n                \"RB\"\n            ]\n        },\n        commentTokens: {\n            line: \"#\"\n        },\n        indentOnInput: /^\\s*([\\}\\]\\)]|else:|elif |except |finally:)$/\n    }\n});\n/**\nPython language support.\n*/ function python() {\n    return new _codemirror_language__WEBPACK_IMPORTED_MODULE_2__.LanguageSupport(pythonLanguage, [\n        pythonLanguage.data.of({\n            autocomplete: localCompletionSource\n        }),\n        pythonLanguage.data.of({\n            autocomplete: globalCompletion\n        })\n    ]);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGFuZy1weXRob24vZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUF1QztBQUNtRztBQUNwRjtBQUNrQztBQUV4RixNQUFNYSxRQUFRLFdBQVcsR0FBRSxJQUFJTCxzREFBV0E7QUFDMUMsTUFBTU0sYUFBYSxXQUFXLEdBQUUsSUFBSUMsSUFBSTtJQUNwQztJQUFVO0lBQ1Y7SUFBc0I7SUFBbUI7SUFDekM7SUFBZ0I7Q0FDbkI7QUFDRCxTQUFTQyxNQUFNQyxJQUFJO0lBQ2YsT0FBTyxDQUFDQyxNQUFNQyxLQUFLQztRQUNmLElBQUlBLE9BQ0EsT0FBTztRQUNYLElBQUlDLEtBQUtILEtBQUtBLElBQUksQ0FBQ0ksUUFBUSxDQUFDO1FBQzVCLElBQUlELElBQ0FGLElBQUlFLElBQUlKO1FBQ1osT0FBTztJQUNYO0FBQ0o7QUFDQSxNQUFNTSxvQkFBb0I7SUFDdEJDLG9CQUFvQixXQUFXLEdBQUVSLE1BQU07SUFDdkNTLGlCQUFpQixXQUFXLEdBQUVULE1BQU07SUFDcENVLGNBQWFSLElBQUksRUFBRUMsR0FBRyxFQUFFQyxLQUFLO1FBQ3pCLElBQUlBLE9BQ0EsSUFBSyxJQUFJTyxRQUFRVCxLQUFLQSxJQUFJLENBQUNVLFVBQVUsRUFBRUQsT0FBT0EsUUFBUUEsTUFBTUUsV0FBVyxDQUFFO1lBQ3JFLElBQUlGLE1BQU1HLElBQUksSUFBSSxnQkFDZFgsSUFBSVEsT0FBTztpQkFDVixJQUFJQSxNQUFNRyxJQUFJLElBQUksTUFDbkI7UUFDUjtJQUNSO0lBQ0FDLGlCQUFnQkMsS0FBSyxFQUFFYixHQUFHO1FBQ3RCLElBQUljLElBQUlDO1FBQ1IsSUFBSSxFQUFFaEIsSUFBSSxFQUFFLEdBQUdjO1FBQ2YsSUFBSUcsU0FBUyxDQUFDLENBQUNGLEtBQUtmLEtBQUtVLFVBQVUsTUFBTSxRQUFRSyxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdILElBQUksS0FBSztRQUN0RixJ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R0FBRyxDQUFDNkMsTUFBTSxHQUFHLElBQUk7b0JBQUc7WUFDdkc7U0FDSDtJQUNMO0lBQ0FzQixjQUFjO1FBQ1ZDLGVBQWU7WUFDWEMsVUFBVTtnQkFBQztnQkFBSztnQkFBSztnQkFBSztnQkFBSztnQkFBSztnQkFBTzthQUFNO1lBQ2pEQyxnQkFBZ0I7Z0JBQUM7Z0JBQUs7Z0JBQU07Z0JBQU07Z0JBQUs7Z0JBQUs7Z0JBQUs7Z0JBQU07Z0JBQ25EO2dCQUFLO2dCQUFNO2dCQUFNO2dCQUFLO2dCQUFLO2dCQUFLO2dCQUFNO2FBQUs7UUFDbkQ7UUFDQUMsZUFBZTtZQUFFN0IsTUFBTTtRQUFJO1FBQzNCOEIsZUFBZTtJQUNuQjtBQUNKO0FBQ0E7O0FBRUEsR0FDQSxTQUFTQztJQUNMLE9BQU8sSUFBSS9HLGlFQUFlQSxDQUFDdUYsZ0JBQWdCO1FBQ3ZDQSxlQUFleUIsSUFBSSxDQUFDQyxFQUFFLENBQUM7WUFBRUMsY0FBY3pEO1FBQXNCO1FBQzdEOEIsZUFBZXlCLElBQUksQ0FBQ0MsRUFBRSxDQUFDO1lBQUVDLGNBQWN0QztRQUFpQjtLQUMzRDtBQUNMO0FBRTJFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHl0aG9uLW9ubGluZS1lZGl0b3IvLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGFuZy1weXRob24vZGlzdC9pbmRleC5qcz80YmEyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHBhcnNlciB9IGZyb20gJ0BsZXplci9weXRob24nO1xuaW1wb3J0IHsgc3ludGF4VHJlZSwgTFJMYW5ndWFnZSwgaW5kZW50Tm9kZVByb3AsIGRlbGltaXRlZEluZGVudCwgZm9sZE5vZGVQcm9wLCBmb2xkSW5zaWRlLCBMYW5ndWFnZVN1cHBvcnQgfSBmcm9tICdAY29kZW1pcnJvci9sYW5ndWFnZSc7XG5pbXBvcnQgeyBOb2RlV2Vha01hcCwgSXRlck1vZGUgfSBmcm9tICdAbGV6ZXIvY29tbW9uJztcbmltcG9ydCB7IHNuaXBwZXRDb21wbGV0aW9uLCBpZk5vdEluLCBjb21wbGV0ZUZyb21MaXN0IH0gZnJvbSAnQGNvZGVtaXJyb3IvYXV0b2NvbXBsZXRlJztcblxuY29uc3QgY2FjaGUgPSAvKkBfX1BVUkVfXyovbmV3IE5vZGVXZWFrTWFwKCk7XG5jb25zdCBTY29wZU5vZGVzID0gLypAX19QVVJFX18qL25ldyBTZXQoW1xuICAgIFwiU2NyaXB0XCIsIFwiQm9keVwiLFxuICAgIFwiRnVuY3Rpb25EZWZpbml0aW9uXCIsIFwiQ2xhc3NEZWZpbml0aW9uXCIsIFwiTGFtYmRhRXhwcmVzc2lvblwiLFxuICAgIFwiRm9yU3RhdGVtZW50XCIsIFwiTWF0Y2hDbGF1c2VcIlxuXSk7XG5mdW5jdGlvbiBkZWZJRCh0eXBlKSB7XG4gICAgcmV0dXJuIChub2RlLCBkZWYsIG91dGVyKSA9PiB7XG4gICAgICAgIGlmIChvdXRlcilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IGlkID0gbm9kZS5ub2RlLmdldENoaWxkKFwiVmFyaWFibGVOYW1lXCIpO1xuICAgICAgICBpZiAoaWQpXG4gICAgICAgICAgICBkZWYoaWQsIHR5cGUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuY29uc3QgZ2F0aGVyQ29tcGxldGlvbnMgPSB7XG4gICAgRnVuY3Rpb25EZWZpbml0aW9uOiAvKkBfX1BVUkVfXyovZGVmSUQoXCJmdW5jdGlvblwiKSxcbiAgICBDbGFzc0RlZmluaXRpb246IC8qQF9fUFVSRV9fKi9kZWZJRChcImNsYXNzXCIpLFxuICAgIEZvclN0YXRlbWVudChub2RlLCBkZWYsIG91dGVyKSB7XG4gICAgICAgIGlmIChvdXRlcilcbiAgICAgICAgICAgIGZvciAobGV0IGNoaWxkID0gbm9kZS5ub2RlLmZpcnN0Q2hpbGQ7IGNoaWxkOyBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLm5hbWUgPT0gXCJWYXJpYWJsZU5hbWVcIilcbiAgICAgICAgICAgICAgICAgICAgZGVmKGNoaWxkLCBcInZhcmlhYmxlXCIpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoaWxkLm5hbWUgPT0gXCJpblwiKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICB9LFxuICAgIEltcG9ydFN0YXRlbWVudChfbm9kZSwgZGVmKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGxldCB7IG5vZGUgfSA9IF9ub2RlO1xuICAgICAgICBsZXQgaXNGcm9tID0gKChfYSA9IG5vZGUuZmlyc3RDaGlsZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm5hbWUpID09IFwiZnJvbVwiO1xuICAgICAgICBmb3IgKGxldCBjaCA9IG5vZGUuZ2V0Q2hpbGQoXCJpbXBvcnRcIik7IGNoOyBjaCA9IGNoLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICBpZiAoY2gubmFtZSA9PSBcIlZhcmlhYmxlTmFtZVwiICYmICgoX2IgPSBjaC5uZXh0U2libGluZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm5hbWUpICE9IFwiYXNcIilcbiAgICAgICAgICAgICAgICBkZWYoY2gsIGlzRnJvbSA/IFwidmFyaWFibGVcIiA6IFwibmFtZXNwYWNlXCIpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBBc3NpZ25TdGF0ZW1lbnQobm9kZSwgZGVmKSB7XG4gICAgICAgIGZvciAobGV0IGNoaWxkID0gbm9kZS5ub2RlLmZpcnN0Q2hpbGQ7IGNoaWxkOyBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQubmFtZSA9PSBcIlZhcmlhYmxlTmFtZVwiKVxuICAgICAgICAgICAgICAgIGRlZihjaGlsZCwgXCJ2YXJpYWJsZVwiKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoaWxkLm5hbWUgPT0gXCI6XCIgfHwgY2hpbGQubmFtZSA9PSBcIkFzc2lnbk9wXCIpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIFBhcmFtTGlzdChub2RlLCBkZWYpIHtcbiAgICAgICAgZm9yIChsZXQgcHJldiA9IG51bGwsIGNoaWxkID0gbm9kZS5ub2RlLmZpcnN0Q2hpbGQ7IGNoaWxkOyBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQubmFtZSA9PSBcIlZhcmlhYmxlTmFtZVwiICYmICghcHJldiB8fCAhL1xcKnxBc3NpZ25PcC8udGVzdChwcmV2Lm5hbWUpKSlcbiAgICAgICAgICAgICAgICBkZWYoY2hpbGQsIFwidmFyaWFibGVcIik7XG4gICAgICAgICAgICBwcmV2ID0gY2hpbGQ7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIENhcHR1cmVQYXR0ZXJuOiAvKkBfX1BVUkVfXyovZGVmSUQoXCJ2YXJpYWJsZVwiKSxcbiAgICBBc1BhdHRlcm46IC8qQF9fUFVSRV9fKi9kZWZJRChcInZhcmlhYmxlXCIpLFxuICAgIF9fcHJvdG9fXzogbnVsbFxufTtcbmZ1bmN0aW9uIGdldFNjb3BlKGRvYywgbm9kZSkge1xuICAgIGxldCBjYWNoZWQgPSBjYWNoZS5nZXQobm9kZSk7XG4gICAgaWYgKGNhY2hlZClcbiAgICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICBsZXQgY29tcGxldGlvbnMgPSBbXSwgdG9wID0gdHJ1ZTtcbiAgICBmdW5jdGlvbiBkZWYobm9kZSwgdHlwZSkge1xuICAgICAgICBsZXQgbmFtZSA9IGRvYy5zbGljZVN0cmluZyhub2RlLmZyb20sIG5vZGUudG8pO1xuICAgICAgICBjb21wbGV0aW9ucy5wdXNoKHsgbGFiZWw6IG5hbWUsIHR5cGUgfSk7XG4gICAgfVxuICAgIG5vZGUuY3Vyc29yKEl0ZXJNb2RlLkluY2x1ZGVBbm9ueW1vdXMpLml0ZXJhdGUobm9kZSA9PiB7XG4gICAgICAgIGlmIChub2RlLm5hbWUpIHtcbiAgICAgICAgICAgIGxldCBnYXRoZXIgPSBnYXRoZXJDb21wbGV0aW9uc1tub2RlLm5hbWVdO1xuICAgICAgICAgICAgaWYgKGdhdGhlciAmJiBnYXRoZXIobm9kZSwgZGVmLCB0b3ApIHx8ICF0b3AgJiYgU2NvcGVOb2Rlcy5oYXMobm9kZS5uYW1lKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB0b3AgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlLnRvIC0gbm9kZS5mcm9tID4gODE5Mikge1xuICAgICAgICAgICAgLy8gQWxsb3cgY2FjaGluZyBmb3IgYmlnZ2VyIGludGVybmFsIG5vZGVzXG4gICAgICAgICAgICBmb3IgKGxldCBjIG9mIGdldFNjb3BlKGRvYywgbm9kZS5ub2RlKSlcbiAgICAgICAgICAgICAgICBjb21wbGV0aW9ucy5wdXNoKGMpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgY2FjaGUuc2V0KG5vZGUsIGNvbXBsZXRpb25zKTtcbiAgICByZXR1cm4gY29tcGxldGlvbnM7XG59XG5jb25zdCBJZGVudGlmaWVyID0gL15bXFx3XFx4YTEtXFx1ZmZmZl1bXFx3XFxkXFx4YTEtXFx1ZmZmZl0qJC87XG5jb25zdCBkb250Q29tcGxldGUgPSBbXCJTdHJpbmdcIiwgXCJGb3JtYXRTdHJpbmdcIiwgXCJDb21tZW50XCIsIFwiUHJvcGVydHlOYW1lXCJdO1xuLyoqXG5Db21wbGV0aW9uIHNvdXJjZSB0aGF0IGxvb2tzIHVwIGxvY2FsbHkgZGVmaW5lZCBuYW1lcyBpblxuUHl0aG9uIGNvZGUuXG4qL1xuZnVuY3Rpb24gbG9jYWxDb21wbGV0aW9uU291cmNlKGNvbnRleHQpIHtcbiAgICBsZXQgaW5uZXIgPSBzeW50YXhUcmVlKGNvbnRleHQuc3RhdGUpLnJlc29sdmVJbm5lcihjb250ZXh0LnBvcywgLTEpO1xuICAgIGlmIChkb250Q29tcGxldGUuaW5kZXhPZihpbm5lci5uYW1lKSA+IC0xKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgaXNXb3JkID0gaW5uZXIubmFtZSA9PSBcIlZhcmlhYmxlTmFtZVwiIHx8XG4gICAgICAgIGlubmVyLnRvIC0gaW5uZXIuZnJvbSA8IDIwICYmIElkZW50aWZpZXIudGVzdChjb250ZXh0LnN0YXRlLnNsaWNlRG9jKGlubmVyLmZyb20sIGlubmVyLnRvKSk7XG4gICAgaWYgKCFpc1dvcmQgJiYgIWNvbnRleHQuZXhwbGljaXQpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBvcHRpb25zID0gW107XG4gICAgZm9yIChsZXQgcG9zID0gaW5uZXI7IHBvczsgcG9zID0gcG9zLnBhcmVudCkge1xuICAgICAgICBpZiAoU2NvcGVOb2Rlcy5oYXMocG9zLm5hbWUpKVxuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMuY29uY2F0KGdldFNjb3BlKGNvbnRleHQuc3RhdGUuZG9jLCBwb3MpKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgZnJvbTogaXNXb3JkID8gaW5uZXIuZnJvbSA6IGNvbnRleHQucG9zLFxuICAgICAgICB2YWxpZEZvcjogSWRlbnRpZmllclxuICAgIH07XG59XG5jb25zdCBnbG9iYWxzID0gLypAX19QVVJFX18qL1tcbiAgICBcIl9fYW5ub3RhdGlvbnNfX1wiLCBcIl9fYnVpbHRpbnNfX1wiLCBcIl9fZGVidWdfX1wiLCBcIl9fZG9jX19cIiwgXCJfX2ltcG9ydF9fXCIsIFwiX19uYW1lX19cIixcbiAgICBcIl9fbG9hZGVyX19cIiwgXCJfX3BhY2thZ2VfX1wiLCBcIl9fc3BlY19fXCIsXG4gICAgXCJGYWxzZVwiLCBcIk5vbmVcIiwgXCJUcnVlXCJcbl0ubWFwKG4gPT4gKHsgbGFiZWw6IG4sIHR5cGU6IFwiY29uc3RhbnRcIiB9KSkuY29uY2F0KC8qQF9fUFVSRV9fKi9bXG4gICAgXCJBcml0aG1ldGljRXJyb3JcIiwgXCJBc3NlcnRpb25FcnJvclwiLCBcIkF0dHJpYnV0ZUVycm9yXCIsIFwiQmFzZUV4Y2VwdGlvblwiLCBcIkJsb2NraW5nSU9FcnJvclwiLFxuICAgIFwiQnJva2VuUGlwZUVycm9yXCIsIFwiQnVmZmVyRXJyb3JcIiwgXCJCeXRlc1dhcm5pbmdcIiwgXCJDaGlsZFByb2Nlc3NFcnJvclwiLCBcIkNvbm5lY3Rpb25BYm9ydGVkRXJyb3JcIixcbiAgICBcIkNvbm5lY3Rpb25FcnJvclwiLCBcIkNvbm5lY3Rpb25SZWZ1c2VkRXJyb3JcIiwgXCJDb25uZWN0aW9uUmVzZXRFcnJvclwiLCBcIkRlcHJlY2F0aW9uV2FybmluZ1wiLFxuICAgIFwiRU9GRXJyb3JcIiwgXCJFbGxpcHNpc1wiLCBcIkVuY29kaW5nV2FybmluZ1wiLCBcIkVudmlyb25tZW50RXJyb3JcIiwgXCJFeGNlcHRpb25cIiwgXCJGaWxlRXhpc3RzRXJyb3JcIixcbiAgICBcIkZpbGVOb3RGb3VuZEVycm9yXCIsIFwiRmxvYXRpbmdQb2ludEVycm9yXCIsIFwiRnV0dXJlV2FybmluZ1wiLCBcIkdlbmVyYXRvckV4aXRcIiwgXCJJT0Vycm9yXCIsXG4gICAgXCJJbXBvcnRFcnJvclwiLCBcIkltcG9ydFdhcm5pbmdcIiwgXCJJbmRlbnRhdGlvbkVycm9yXCIsIFwiSW5kZXhFcnJvclwiLCBcIkludGVycnVwdGVkRXJyb3JcIixcbiAgICBcIklzQURpcmVjdG9yeUVycm9yXCIsIFwiS2V5RXJyb3JcIiwgXCJLZXlib2FyZEludGVycnVwdFwiLCBcIkxvb2t1cEVycm9yXCIsIFwiTWVtb3J5RXJyb3JcIixcbiAgICBcIk1vZHVsZU5vdEZvdW5kRXJyb3JcIiwgXCJOYW1lRXJyb3JcIiwgXCJOb3RBRGlyZWN0b3J5RXJyb3JcIiwgXCJOb3RJbXBsZW1lbnRlZFwiLCBcIk5vdEltcGxlbWVudGVkRXJyb3JcIixcbiAgICBcIk9TRXJyb3JcIiwgXCJPdmVyZmxvd0Vycm9yXCIsIFwiUGVuZGluZ0RlcHJlY2F0aW9uV2FybmluZ1wiLCBcIlBlcm1pc3Npb25FcnJvclwiLCBcIlByb2Nlc3NMb29rdXBFcnJvclwiLFxuICAgIFwiUmVjdXJzaW9uRXJyb3JcIiwgXCJSZWZlcmVuY2VFcnJvclwiLCBcIlJlc291cmNlV2FybmluZ1wiLCBcIlJ1bnRpbWVFcnJvclwiLCBcIlJ1bnRpbWVXYXJuaW5nXCIsXG4gICAgXCJTdG9wQXN5bmNJdGVyYXRpb25cIiwgXCJTdG9wSXRlcmF0aW9uXCIsIFwiU3ludGF4RXJyb3JcIiwgXCJTeW50YXhXYXJuaW5nXCIsIFwiU3lzdGVtRXJyb3JcIixcbiAgICBcIlN5c3RlbUV4aXRcIiwgXCJUYWJFcnJvclwiLCBcIlRpbWVvdXRFcnJvclwiLCBcIlR5cGVFcnJvclwiLCBcIlVuYm91bmRMb2NhbEVycm9yXCIsIFwiVW5pY29kZURlY29kZUVycm9yXCIsXG4gICAgXCJVbmljb2RlRW5jb2RlRXJyb3JcIiwgXCJVbmljb2RlRXJyb3JcIiwgXCJVbmljb2RlVHJhbnNsYXRlRXJyb3JcIiwgXCJVbmljb2RlV2FybmluZ1wiLCBcIlVzZXJXYXJuaW5nXCIsXG4gICAgXCJWYWx1ZUVycm9yXCIsIFwiV2FybmluZ1wiLCBcIlplcm9EaXZpc2lvbkVycm9yXCJcbl0ubWFwKG4gPT4gKHsgbGFiZWw6IG4sIHR5cGU6IFwidHlwZVwiIH0pKSkuY29uY2F0KC8qQF9fUFVSRV9fKi9bXG4gICAgXCJib29sXCIsIFwiYnl0ZWFycmF5XCIsIFwiYnl0ZXNcIiwgXCJjbGFzc21ldGhvZFwiLCBcImNvbXBsZXhcIiwgXCJmbG9hdFwiLCBcImZyb3plbnNldFwiLCBcImludFwiLCBcImxpc3RcIixcbiAgICBcIm1hcFwiLCBcIm1lbW9yeXZpZXdcIiwgXCJvYmplY3RcIiwgXCJyYW5nZVwiLCBcInNldFwiLCBcInN0YXRpY21ldGhvZFwiLCBcInN0clwiLCBcInN1cGVyXCIsIFwidHVwbGVcIiwgXCJ0eXBlXCJcbl0ubWFwKG4gPT4gKHsgbGFiZWw6IG4sIHR5cGU6IFwiY2xhc3NcIiB9KSkpLmNvbmNhdCgvKkBfX1BVUkVfXyovW1xuICAgIFwiYWJzXCIsIFwiYWl0ZXJcIiwgXCJhbGxcIiwgXCJhbmV4dFwiLCBcImFueVwiLCBcImFzY2lpXCIsIFwiYmluXCIsIFwiYnJlYWtwb2ludFwiLCBcImNhbGxhYmxlXCIsIFwiY2hyXCIsXG4gICAgXCJjb21waWxlXCIsIFwiZGVsYXR0clwiLCBcImRpY3RcIiwgXCJkaXJcIiwgXCJkaXZtb2RcIiwgXCJlbnVtZXJhdGVcIiwgXCJldmFsXCIsIFwiZXhlY1wiLCBcImV4aXRcIiwgXCJmaWx0ZXJcIixcbiAgICBcImZvcm1hdFwiLCBcImdldGF0dHJcIiwgXCJnbG9iYWxzXCIsIFwiaGFzYXR0clwiLCBcImhhc2hcIiwgXCJoZWxwXCIsIFwiaGV4XCIsIFwiaWRcIiwgXCJpbnB1dFwiLCBcImlzaW5zdGFuY2VcIixcbiAgICBcImlzc3ViY2xhc3NcIiwgXCJpdGVyXCIsIFwibGVuXCIsIFwibGljZW5zZVwiLCBcImxvY2Fsc1wiLCBcIm1heFwiLCBcIm1pblwiLCBcIm5leHRcIiwgXCJvY3RcIiwgXCJvcGVuXCIsXG4gICAgXCJvcmRcIiwgXCJwb3dcIiwgXCJwcmludFwiLCBcInByb3BlcnR5XCIsIFwicXVpdFwiLCBcInJlcHJcIiwgXCJyZXZlcnNlZFwiLCBcInJvdW5kXCIsIFwic2V0YXR0clwiLCBcInNsaWNlXCIsXG4gICAgXCJzb3J0ZWRcIiwgXCJzdW1cIiwgXCJ2YXJzXCIsIFwiemlwXCJcbl0ubWFwKG4gPT4gKHsgbGFiZWw6IG4sIHR5cGU6IFwiZnVuY3Rpb25cIiB9KSkpO1xuY29uc3Qgc25pcHBldHMgPSBbXG4gICAgLypAX19QVVJFX18qL3NuaXBwZXRDb21wbGV0aW9uKFwiZGVmICR7bmFtZX0oJHtwYXJhbXN9KTpcXG5cXHQke31cIiwge1xuICAgICAgICBsYWJlbDogXCJkZWZcIixcbiAgICAgICAgZGV0YWlsOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgIHR5cGU6IFwia2V5d29yZFwiXG4gICAgfSksXG4gICAgLypAX19QVVJFX18qL3NuaXBwZXRDb21wbGV0aW9uKFwiZm9yICR7bmFtZX0gaW4gJHtjb2xsZWN0aW9ufTpcXG5cXHQke31cIiwge1xuICAgICAgICBsYWJlbDogXCJmb3JcIixcbiAgICAgICAgZGV0YWlsOiBcImxvb3BcIixcbiAgICAgICAgdHlwZTogXCJrZXl3b3JkXCJcbiAgICB9KSxcbiAgICAvKkBfX1BVUkVfXyovc25pcHBldENvbXBsZXRpb24oXCJ3aGlsZSAke306XFxuXFx0JHt9XCIsIHtcbiAgICAgICAgbGFiZWw6IFwid2hpbGVcIixcbiAgICAgICAgZGV0YWlsOiBcImxvb3BcIixcbiAgICAgICAgdHlwZTogXCJrZXl3b3JkXCJcbiAgICB9KSxcbiAgICAvKkBfX1BVUkVfXyovc25pcHBldENvbXBsZXRpb24oXCJ0cnk6XFxuXFx0JHt9XFxuZXhjZXB0ICR7ZXJyb3J9OlxcblxcdCR7fVwiLCB7XG4gICAgICAgIGxhYmVsOiBcInRyeVwiLFxuICAgICAgICBkZXRhaWw6IFwiLyBleGNlcHQgYmxvY2tcIixcbiAgICAgICAgdHlwZTogXCJrZXl3b3JkXCJcbiAgICB9KSxcbiAgICAvKkBfX1BVUkVfXyovc25pcHBldENvbXBsZXRpb24oXCJpZiAke306XFxuXFx0XFxuXCIsIHtcbiAgICAgICAgbGFiZWw6IFwiaWZcIixcbiAgICAgICAgZGV0YWlsOiBcImJsb2NrXCIsXG4gICAgICAgIHR5cGU6IFwia2V5d29yZFwiXG4gICAgfSksXG4gICAgLypAX19QVVJFX18qL3NuaXBwZXRDb21wbGV0aW9uKFwiaWYgJHt9OlxcblxcdCR7fVxcbmVsc2U6XFxuXFx0JHt9XCIsIHtcbiAgICAgICAgbGFiZWw6IFwiaWZcIixcbiAgICAgICAgZGV0YWlsOiBcIi8gZWxzZSBibG9ja1wiLFxuICAgICAgICB0eXBlOiBcImtleXdvcmRcIlxuICAgIH0pLFxuICAgIC8qQF9fUFVSRV9fKi9zbmlwcGV0Q29tcGxldGlvbihcImNsYXNzICR7bmFtZX06XFxuXFx0ZGVmIF9faW5pdF9fKHNlbGYsICR7cGFyYW1zfSk6XFxuXFx0XFx0XFx0JHt9XCIsIHtcbiAgICAgICAgbGFiZWw6IFwiY2xhc3NcIixcbiAgICAgICAgZGV0YWlsOiBcImRlZmluaXRpb25cIixcbiAgICAgICAgdHlwZTogXCJrZXl3b3JkXCJcbiAgICB9KSxcbiAgICAvKkBfX1BVUkVfXyovc25pcHBldENvbXBsZXRpb24oXCJpbXBvcnQgJHttb2R1bGV9XCIsIHtcbiAgICAgICAgbGFiZWw6IFwiaW1wb3J0XCIsXG4gICAgICAgIGRldGFpbDogXCJzdGF0ZW1lbnRcIixcbiAgICAgICAgdHlwZTogXCJrZXl3b3JkXCJcbiAgICB9KSxcbiAgICAvKkBfX1BVUkVfXyovc25pcHBldENvbXBsZXRpb24oXCJmcm9tICR7bW9kdWxlfSBpbXBvcnQgJHtuYW1lc31cIiwge1xuICAgICAgICBsYWJlbDogXCJmcm9tXCIsXG4gICAgICAgIGRldGFpbDogXCJpbXBvcnRcIixcbiAgICAgICAgdHlwZTogXCJrZXl3b3JkXCJcbiAgICB9KVxuXTtcbi8qKlxuQXV0b2NvbXBsZXRpb24gZm9yIGJ1aWx0LWluIFB5dGhvbiBnbG9iYWxzIGFuZCBrZXl3b3Jkcy5cbiovXG5jb25zdCBnbG9iYWxDb21wbGV0aW9uID0gLypAX19QVVJFX18qL2lmTm90SW4oZG9udENvbXBsZXRlLCAvKkBfX1BVUkVfXyovY29tcGxldGVGcm9tTGlzdCgvKkBfX1BVUkVfXyovZ2xvYmFscy5jb25jYXQoc25pcHBldHMpKSk7XG5cbmZ1bmN0aW9uIGluZGVudEJvZHkoY29udGV4dCwgbm9kZSkge1xuICAgIGxldCBiYXNlID0gY29udGV4dC5iYXNlSW5kZW50Rm9yKG5vZGUpO1xuICAgIGxldCBsaW5lID0gY29udGV4dC5saW5lQXQoY29udGV4dC5wb3MsIC0xKSwgdG8gPSBsaW5lLmZyb20gKyBsaW5lLnRleHQubGVuZ3RoO1xuICAgIC8vIERvbid0IGNvbnNpZGVyIGJsYW5rLCBkZWluZGVudGVkIGxpbmVzIGF0IHRoZSBlbmQgb2YgdGhlXG4gICAgLy8gYmxvY2sgcGFydCBvZiB0aGUgYmxvY2tcbiAgICBpZiAoL15cXHMqKCR8IykvLnRlc3QobGluZS50ZXh0KSAmJlxuICAgICAgICBjb250ZXh0Lm5vZGUudG8gPCB0byArIDEwMCAmJlxuICAgICAgICAhL1xcUy8udGVzdChjb250ZXh0LnN0YXRlLnNsaWNlRG9jKHRvLCBjb250ZXh0Lm5vZGUudG8pKSAmJlxuICAgICAgICBjb250ZXh0LmxpbmVJbmRlbnQoY29udGV4dC5wb3MsIC0xKSA8PSBiYXNlKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAvLyBBIG5vcm1hbGx5IGRlaW5kZW50aW5nIGtleXdvcmQgdGhhdCBhcHBlYXJzIGF0IGEgaGlnaGVyXG4gICAgLy8gaW5kZW50YXRpb24gdGhhbiB0aGUgYmxvY2sgc2hvdWxkIHByb2JhYmx5IGJlIGhhbmRsZWQgYnkgdGhlIG5leHRcbiAgICAvLyBsZXZlbFxuICAgIGlmICgvXlxccyooZWxzZTp8ZWxpZiB8ZXhjZXB0IHxmaW5hbGx5OikvLnRlc3QoY29udGV4dC50ZXh0QWZ0ZXIpICYmIGNvbnRleHQubGluZUluZGVudChjb250ZXh0LnBvcywgLTEpID4gYmFzZSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIGJhc2UgKyBjb250ZXh0LnVuaXQ7XG59XG4vKipcbkEgbGFuZ3VhZ2UgcHJvdmlkZXIgYmFzZWQgb24gdGhlIFtMZXplciBQeXRob25cbnBhcnNlcl0oaHR0cHM6Ly9naXRodWIuY29tL2xlemVyLXBhcnNlci9weXRob24pLCBleHRlbmRlZCB3aXRoXG5oaWdobGlnaHRpbmcgYW5kIGluZGVudGF0aW9uIGluZm9ybWF0aW9uLlxuKi9cbmNvbnN0IHB5dGhvbkxhbmd1YWdlID0gLypAX19QVVJFX18qL0xSTGFuZ3VhZ2UuZGVmaW5lKHtcbiAgICBuYW1lOiBcInB5dGhvblwiLFxuICAgIHBhcnNlcjogLypAX19QVVJFX18qL3BhcnNlci5jb25maWd1cmUoe1xuICAgICAgICBwcm9wczogW1xuICAgICAgICAgICAgLypAX19QVVJFX18qL2luZGVudE5vZGVQcm9wLmFkZCh7XG4gICAgICAgICAgICAgICAgQm9keTogY29udGV4dCA9PiB7IHZhciBfYTsgcmV0dXJuIChfYSA9IGluZGVudEJvZHkoY29udGV4dCwgY29udGV4dC5ub2RlKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY29udGV4dC5jb250aW51ZSgpOyB9LFxuICAgICAgICAgICAgICAgIElmU3RhdGVtZW50OiBjeCA9PiAvXlxccyooZWxzZTp8ZWxpZiApLy50ZXN0KGN4LnRleHRBZnRlcikgPyBjeC5iYXNlSW5kZW50IDogY3guY29udGludWUoKSxcbiAgICAgICAgICAgICAgICBUcnlTdGF0ZW1lbnQ6IGN4ID0+IC9eXFxzKihleGNlcHQgfGZpbmFsbHk6fGVsc2U6KS8udGVzdChjeC50ZXh0QWZ0ZXIpID8gY3guYmFzZUluZGVudCA6IGN4LmNvbnRpbnVlKCksXG4gICAgICAgICAgICAgICAgXCJUdXBsZUV4cHJlc3Npb24gQ29tcHJlaGVuc2lvbkV4cHJlc3Npb24gUGFyYW1MaXN0IEFyZ0xpc3QgUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIjogLypAX19QVVJFX18qL2RlbGltaXRlZEluZGVudCh7IGNsb3Npbmc6IFwiKVwiIH0pLFxuICAgICAgICAgICAgICAgIFwiRGljdGlvbmFyeUV4cHJlc3Npb24gRGljdGlvbmFyeUNvbXByZWhlbnNpb25FeHByZXNzaW9uIFNldEV4cHJlc3Npb24gU2V0Q29tcHJlaGVuc2lvbkV4cHJlc3Npb25cIjogLypAX19QVVJFX18qL2RlbGltaXRlZEluZGVudCh7IGNsb3Npbmc6IFwifVwiIH0pLFxuICAgICAgICAgICAgICAgIFwiQXJyYXlFeHByZXNzaW9uIEFycmF5Q29tcHJlaGVuc2lvbkV4cHJlc3Npb25cIjogLypAX19QVVJFX18qL2RlbGltaXRlZEluZGVudCh7IGNsb3Npbmc6IFwiXVwiIH0pLFxuICAgICAgICAgICAgICAgIFwiU3RyaW5nIEZvcm1hdFN0cmluZ1wiOiAoKSA9PiBudWxsLFxuICAgICAgICAgICAgICAgIFNjcmlwdDogY29udGV4dCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250ZXh0LnBvcyArIC9cXHMqLy5leGVjKGNvbnRleHQudGV4dEFmdGVyKVswXS5sZW5ndGggPj0gY29udGV4dC5ub2RlLnRvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZW5kQm9keSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBjdXIgPSBjb250ZXh0Lm5vZGUsIHRvID0gY3VyLnRvOzspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXIgPSBjdXIubGFzdENoaWxkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY3VyIHx8IGN1ci50byAhPSB0bylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1ci50eXBlLm5hbWUgPT0gXCJCb2R5XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZEJvZHkgPSBjdXI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW5kQm9keSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBib2R5SW5kZW50ID0gaW5kZW50Qm9keShjb250ZXh0LCBlbmRCb2R5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYm9keUluZGVudCAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYm9keUluZGVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5jb250aW51ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgLypAX19QVVJFX18qL2ZvbGROb2RlUHJvcC5hZGQoe1xuICAgICAgICAgICAgICAgIFwiQXJyYXlFeHByZXNzaW9uIERpY3Rpb25hcnlFeHByZXNzaW9uIFNldEV4cHJlc3Npb24gVHVwbGVFeHByZXNzaW9uXCI6IGZvbGRJbnNpZGUsXG4gICAgICAgICAgICAgICAgQm9keTogKG5vZGUsIHN0YXRlKSA9PiAoeyBmcm9tOiBub2RlLmZyb20gKyAxLCB0bzogbm9kZS50byAtIChub2RlLnRvID09IHN0YXRlLmRvYy5sZW5ndGggPyAwIDogMSkgfSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgIF0sXG4gICAgfSksXG4gICAgbGFuZ3VhZ2VEYXRhOiB7XG4gICAgICAgIGNsb3NlQnJhY2tldHM6IHtcbiAgICAgICAgICAgIGJyYWNrZXRzOiBbXCIoXCIsIFwiW1wiLCBcIntcIiwgXCInXCIsICdcIicsIFwiJycnXCIsICdcIlwiXCInXSxcbiAgICAgICAgICAgIHN0cmluZ1ByZWZpeGVzOiBbXCJmXCIsIFwiZnJcIiwgXCJyZlwiLCBcInJcIiwgXCJ1XCIsIFwiYlwiLCBcImJyXCIsIFwicmJcIixcbiAgICAgICAgICAgICAgICBcIkZcIiwgXCJGUlwiLCBcIlJGXCIsIFwiUlwiLCBcIlVcIiwgXCJCXCIsIFwiQlJcIiwgXCJSQlwiXVxuICAgICAgICB9LFxuICAgICAgICBjb21tZW50VG9rZW5zOiB7IGxpbmU6IFwiI1wiIH0sXG4gICAgICAgIGluZGVudE9uSW5wdXQ6IC9eXFxzKihbXFx9XFxdXFwpXXxlbHNlOnxlbGlmIHxleGNlcHQgfGZpbmFsbHk6KSQvXG4gICAgfVxufSk7XG4vKipcblB5dGhvbiBsYW5ndWFnZSBzdXBwb3J0LlxuKi9cbmZ1bmN0aW9uIHB5dGhvbigpIHtcbiAgICByZXR1cm4gbmV3IExhbmd1YWdlU3VwcG9ydChweXRob25MYW5ndWFnZSwgW1xuICAgICAgICBweXRob25MYW5ndWFnZS5kYXRhLm9mKHsgYXV0b2NvbXBsZXRlOiBsb2NhbENvbXBsZXRpb25Tb3VyY2UgfSksXG4gICAgICAgIHB5dGhvbkxhbmd1YWdlLmRhdGEub2YoeyBhdXRvY29tcGxldGU6IGdsb2JhbENvbXBsZXRpb24gfSksXG4gICAgXSk7XG59XG5cbmV4cG9ydCB7IGdsb2JhbENvbXBsZXRpb24sIGxvY2FsQ29tcGxldGlvblNvdXJjZSwgcHl0aG9uLCBweXRob25MYW5ndWFnZSB9O1xuIl0sIm5hbWVzIjpbInBhcnNlciIsInN5bnRheFRyZWUiLCJMUkxhbmd1YWdlIiwiaW5kZW50Tm9kZVByb3AiLCJkZWxpbWl0ZWRJbmRlbnQiLCJmb2xkTm9kZVByb3AiLCJmb2xkSW5zaWRlIiwiTGFuZ3VhZ2VTdXBwb3J0IiwiTm9kZVdlYWtNYXAiLCJJdGVyTW9kZSIsInNuaXBwZXRDb21wbGV0aW9uIiwiaWZOb3RJbiIsImNvbXBsZXRlRnJvbUxpc3QiLCJjYWNoZSIsIlNjb3BlTm9kZXMiLCJTZXQiLCJkZWZJRCIsInR5cGUiLCJub2RlIiwiZGVmIiwib3V0ZXIiLCJpZCIsImdldENoaWxkIiwiZ2F0aGVyQ29tcGxldGlvbnMiLCJGdW5jdGlvbkRlZmluaXRpb24iLCJDbGFzc0RlZmluaXRpb24iLCJGb3JTdGF0ZW1lbnQiLCJjaGlsZCIsImZpcnN0Q2hpbGQiLCJuZXh0U2libGluZyIsIm5hbWUiLCJJbXBvcnRTdGF0ZW1lbnQiLCJfbm9kZSIsIl9hIiwiX2IiLCJpc0Zyb20iLCJjaCIsIkFzc2lnblN0YXRlbWVudCIsIlBhcmFtTGlzdCIsInByZXYiLCJ0ZXN0IiwiQ2FwdHVyZVBhdHRlcm4iLCJBc1BhdHRlcm4iLCJfX3Byb3RvX18iLCJnZXRTY29wZSIsImRvYyIsImNhY2hlZCIsImdldCIsImNvbXBsZXRpb25zIiwidG9wIiwic2xpY2VTdHJpbmciLCJmcm9tIiwidG8iLCJwdXNoIiwibGFiZWwiLCJjdXJzb3IiLCJJbmNsdWRlQW5vbnltb3VzIiwiaXRlcmF0ZSIsImdhdGhlciIsImhhcyIsImMiLCJzZXQiLCJJZGVudGlmaWVyIiwiZG9udENvbXBsZXRlIiwibG9jYWxDb21wbGV0aW9uU291cmNlIiwiY29udGV4dCIsImlubmVyIiwic3RhdGUiLCJyZXNvbHZlSW5uZXIiLCJwb3MiLCJpbmRleE9mIiwiaXNXb3JkIiwic2xpY2VEb2MiLCJleHBsaWNpdCIsIm9wdGlvbnMiLCJwYXJlbnQiLCJjb25jYXQiLCJ2YWxpZEZvciIsImdsb2JhbHMiLCJtYXAiLCJuIiwic25pcHBldHMiLCJkZXRhaWwiLCJnbG9iYWxDb21wbGV0aW9uIiwiaW5kZW50Qm9keSIsImJhc2UiLCJiYXNlSW5kZW50Rm9yIiwibGluZSIsImxpbmVBdCIsInRleHQiLCJsZW5ndGgiLCJsaW5lSW5kZW50IiwidGV4dEFmdGVyIiwidW5pdCIsInB5dGhvbkxhbmd1YWdlIiwiZGVmaW5lIiwiY29uZmlndXJlIiwicHJvcHMiLCJhZGQiLCJCb2R5IiwiY29udGludWUiLCJJZlN0YXRlbWVudCIsImN4IiwiYmFzZUluZGVudCIsIlRyeVN0YXRlbWVudCIsImNsb3NpbmciLCJTY3JpcHQiLCJleGVjIiwiZW5kQm9keSIsImN1ciIsImxhc3RDaGlsZCIsImJvZHlJbmRlbnQiLCJsYW5ndWFnZURhdGEiLCJjbG9zZUJyYWNrZXRzIiwiYnJhY2tldHMiLCJzdHJpbmdQcmVmaXhlcyIsImNvbW1lbnRUb2tlbnMiLCJpbmRlbnRPbklucHV0IiwicHl0aG9uIiwiZGF0YSIsIm9mIiwiYXV0b2NvbXBsZXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@codemirror/lang-python/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@codemirror/language/dist/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@codemirror/language/dist/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DocInput: () => (/* binding */ DocInput),\n/* harmony export */   HighlightStyle: () => (/* binding */ HighlightStyle),\n/* harmony export */   IndentContext: () => (/* binding */ IndentContext),\n/* harmony export */   LRLanguage: () => (/* binding */ LRLanguage),\n/* harmony export */   Language: () => (/* binding */ Language),\n/* harmony export */   LanguageDescription: () => (/* binding */ LanguageDescription),\n/* harmony export */   LanguageSupport: () => (/* binding */ LanguageSupport),\n/* harmony export */   ParseContext: () => (/* binding */ ParseContext),\n/* harmony export */   StreamLanguage: () => (/* binding */ StreamLanguage),\n/* harmony export */   StringStream: () => (/* binding */ StringStream),\n/* harmony export */   TreeIndentContext: () => (/* binding */ TreeIndentContext),\n/* harmony export */   bracketMatching: () => (/* binding */ bracketMatching),\n/* harmony export */   bracketMatchingHandle: () => (/* binding */ bracketMatchingHandle),\n/* harmony export */   codeFolding: () => (/* binding */ codeFolding),\n/* harmony export */   continuedIndent: () => (/* binding */ continuedIndent),\n/* harmony export */   defaultHighlightStyle: () => (/* binding */ defaultHighlightStyle),\n/* harmony export */   defineLanguageFacet: () => (/* binding */ defineLanguageFacet),\n/* harmony export */   delimitedIndent: () => (/* binding */ delimitedIndent),\n/* harmony export */   ensureSyntaxTree: () => (/* binding */ ensureSyntaxTree),\n/* harmony export */   flatIndent: () => (/* binding */ flatIndent),\n/* harmony export */   foldAll: () => (/* binding */ foldAll),\n/* harmony export */   foldCode: () => (/* binding */ foldCode),\n/* harmony export */   foldEffect: () => (/* binding */ foldEffect),\n/* harmony export */   foldGutter: () => (/* binding */ foldGutter),\n/* harmony export */   foldInside: () => (/* binding */ foldInside),\n/* harmony export */   foldKeymap: () => (/* binding */ foldKeymap),\n/* harmony export */   foldNodeProp: () => (/* binding */ foldNodeProp),\n/* harmony export */   foldService: () => (/* binding */ foldService),\n/* harmony export */   foldState: () => (/* binding */ foldState),\n/* harmony export */   foldable: () => (/* binding */ foldable),\n/* harmony export */   foldedRanges: () => (/* binding */ foldedRanges),\n/* harmony export */   forceParsing: () => (/* binding */ forceParsing),\n/* harmony export */   getIndentUnit: () => (/* binding */ getIndentUnit),\n/* harmony export */   getIndentation: () => (/* binding */ getIndentation),\n/* harmony export */   highlightingFor: () => (/* binding */ highlightingFor),\n/* harmony export */   indentNodeProp: () => (/* binding */ indentNodeProp),\n/* harmony export */   indentOnInput: () => (/* binding */ indentOnInput),\n/* harmony export */   indentRange: () => (/* binding */ indentRange),\n/* harmony export */   indentService: () => (/* binding */ indentService),\n/* harmony export */   indentString: () => (/* binding */ indentString),\n/* harmony export */   indentUnit: () => (/* binding */ indentUnit),\n/* harmony export */   language: () => (/* binding */ language),\n/* harmony export */   languageDataProp: () => (/* binding */ languageDataProp),\n/* harmony export */   matchBrackets: () => (/* binding */ matchBrackets),\n/* harmony export */   sublanguageProp: () => (/* binding */ sublanguageProp),\n/* harmony export */   syntaxHighlighting: () => (/* binding */ syntaxHighlighting),\n/* harmony export */   syntaxParserRunning: () => (/* binding */ syntaxParserRunning),\n/* harmony export */   syntaxTree: () => (/* binding */ syntaxTree),\n/* harmony export */   syntaxTreeAvailable: () => (/* binding */ syntaxTreeAvailable),\n/* harmony export */   toggleFold: () => (/* binding */ toggleFold),\n/* harmony export */   unfoldAll: () => (/* binding */ unfoldAll),\n/* harmony export */   unfoldCode: () => (/* binding */ unfoldCode),\n/* harmony export */   unfoldEffect: () => (/* binding */ unfoldEffect)\n/* harmony export */ });\n/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/common */ \"(ssr)/./node_modules/@lezer/common/dist/index.js\");\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @codemirror/state */ \"(ssr)/./node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @codemirror/view */ \"(ssr)/./node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lezer/highlight */ \"(ssr)/./node_modules/@lezer/highlight/dist/index.js\");\n/* harmony import */ var style_mod__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! style-mod */ \"(ssr)/./node_modules/style-mod/src/style-mod.js\");\n\n\n\n\n\nvar _a;\n/**\nNode prop stored in a parser's top syntax node to provide the\nfacet that stores language-specific data for that language.\n*/ const languageDataProp = /*@__PURE__*/ new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp();\n/**\nHelper function to define a facet (to be added to the top syntax\nnode(s) for a language via\n[`languageDataProp`](https://codemirror.net/6/docs/ref/#language.languageDataProp)), that will be\nused to associate language data with the language. You\nprobably only need this when subclassing\n[`Language`](https://codemirror.net/6/docs/ref/#language.Language).\n*/ function defineLanguageFacet(baseData) {\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n        combine: baseData ? (values)=>values.concat(baseData) : undefined\n    });\n}\n/**\nSyntax node prop used to register sublanguages. Should be added to\nthe top level node type for the language.\n*/ const sublanguageProp = /*@__PURE__*/ new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp();\n/**\nA language object manages parsing and per-language\n[metadata](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt). Parse data is\nmanaged as a [Lezer](https://lezer.codemirror.net) tree. The class\ncan be used directly, via the [`LRLanguage`](https://codemirror.net/6/docs/ref/#language.LRLanguage)\nsubclass for [Lezer](https://lezer.codemirror.net/) LR parsers, or\nvia the [`StreamLanguage`](https://codemirror.net/6/docs/ref/#language.StreamLanguage) subclass\nfor stream parsers.\n*/ class Language {\n    /**\n    Construct a language object. If you need to invoke this\n    directly, first define a data facet with\n    [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet), and then\n    configure your parser to [attach](https://codemirror.net/6/docs/ref/#language.languageDataProp) it\n    to the language's outer syntax node.\n    */ constructor(/**\n    The [language data](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt) facet\n    used for this language.\n    */ data, parser, extraExtensions = [], /**\n    A language name.\n    */ name = \"\"){\n        this.data = data;\n        this.name = name;\n        // Kludge to define EditorState.tree as a debugging helper,\n        // without the EditorState package actually knowing about\n        // languages and lezer trees.\n        if (!_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorState.prototype.hasOwnProperty(\"tree\")) Object.defineProperty(_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorState.prototype, \"tree\", {\n            get () {\n                return syntaxTree(this);\n            }\n        });\n        this.parser = parser;\n        this.extension = [\n            language.of(this),\n            _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorState.languageData.of((state, pos, side)=>{\n                let top = topNodeAt(state, pos, side), data = top.type.prop(languageDataProp);\n                if (!data) return [];\n                let base = state.facet(data), sub = top.type.prop(sublanguageProp);\n                if (sub) {\n                    let innerNode = top.resolve(pos - top.from, side);\n                    for (let sublang of sub)if (sublang.test(innerNode, state)) {\n                        let data = state.facet(sublang.facet);\n                        return sublang.type == \"replace\" ? data : data.concat(base);\n                    }\n                }\n                return base;\n            })\n        ].concat(extraExtensions);\n    }\n    /**\n    Query whether this language is active at the given position.\n    */ isActiveAt(state, pos, side = -1) {\n        return topNodeAt(state, pos, side).type.prop(languageDataProp) == this.data;\n    }\n    /**\n    Find the document regions that were parsed using this language.\n    The returned regions will _include_ any nested languages rooted\n    in this language, when those exist.\n    */ findRegions(state) {\n        let lang = state.facet(language);\n        if ((lang === null || lang === void 0 ? void 0 : lang.data) == this.data) return [\n            {\n                from: 0,\n                to: state.doc.length\n            }\n        ];\n        if (!lang || !lang.allowsNesting) return [];\n        let result = [];\n        let explore = (tree, from)=>{\n            if (tree.prop(languageDataProp) == this.data) {\n                result.push({\n                    from,\n                    to: from + tree.length\n                });\n                return;\n            }\n            let mount = tree.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.mounted);\n            if (mount) {\n                if (mount.tree.prop(languageDataProp) == this.data) {\n                    if (mount.overlay) for (let r of mount.overlay)result.push({\n                        from: r.from + from,\n                        to: r.to + from\n                    });\n                    else result.push({\n                        from: from,\n                        to: from + tree.length\n                    });\n                    return;\n                } else if (mount.overlay) {\n                    let size = result.length;\n                    explore(mount.tree, mount.overlay[0].from + from);\n                    if (result.length > size) return;\n                }\n            }\n            for(let i = 0; i < tree.children.length; i++){\n                let ch = tree.children[i];\n                if (ch instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree) explore(ch, tree.positions[i] + from);\n            }\n        };\n        explore(syntaxTree(state), 0);\n        return result;\n    }\n    /**\n    Indicates whether this language allows nested languages. The\n    default implementation returns true.\n    */ get allowsNesting() {\n        return true;\n    }\n}\n/**\n@internal\n*/ Language.setState = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateEffect.define();\nfunction topNodeAt(state, pos, side) {\n    let topLang = state.facet(language), tree = syntaxTree(state).topNode;\n    if (!topLang || topLang.allowsNesting) {\n        for(let node = tree; node; node = node.enter(pos, side, _lezer_common__WEBPACK_IMPORTED_MODULE_0__.IterMode.ExcludeBuffers))if (node.type.isTop) tree = node;\n    }\n    return tree;\n}\n/**\nA subclass of [`Language`](https://codemirror.net/6/docs/ref/#language.Language) for use with Lezer\n[LR parsers](https://lezer.codemirror.net/docs/ref#lr.LRParser)\nparsers.\n*/ class LRLanguage extends Language {\n    constructor(data, parser, name){\n        super(data, parser, [], name);\n        this.parser = parser;\n    }\n    /**\n    Define a language from a parser.\n    */ static define(spec) {\n        let data = defineLanguageFacet(spec.languageData);\n        return new LRLanguage(data, spec.parser.configure({\n            props: [\n                languageDataProp.add((type)=>type.isTop ? data : undefined)\n            ]\n        }), spec.name);\n    }\n    /**\n    Create a new instance of this language with a reconfigured\n    version of its parser and optionally a new name.\n    */ configure(options, name) {\n        return new LRLanguage(this.data, this.parser.configure(options), name || this.name);\n    }\n    get allowsNesting() {\n        return this.parser.hasWrappers();\n    }\n}\n/**\nGet the syntax tree for a state, which is the current (possibly\nincomplete) parse tree of the active\n[language](https://codemirror.net/6/docs/ref/#language.Language), or the empty tree if there is no\nlanguage available.\n*/ function syntaxTree(state) {\n    let field = state.field(Language.state, false);\n    return field ? field.tree : _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.empty;\n}\n/**\nTry to get a parse tree that spans at least up to `upto`. The\nmethod will do at most `timeout` milliseconds of work to parse\nup to that point if the tree isn't already available.\n*/ function ensureSyntaxTree(state, upto, timeout = 50) {\n    var _a;\n    let parse = (_a = state.field(Language.state, false)) === null || _a === void 0 ? void 0 : _a.context;\n    if (!parse) return null;\n    let oldVieport = parse.viewport;\n    parse.updateViewport({\n        from: 0,\n        to: upto\n    });\n    let result = parse.isDone(upto) || parse.work(timeout, upto) ? parse.tree : null;\n    parse.updateViewport(oldVieport);\n    return result;\n}\n/**\nQueries whether there is a full syntax tree available up to the\ngiven document position. If there isn't, the background parse\nprocess _might_ still be working and update the tree further, but\nthere is no guarantee of that—the parser will [stop\nworking](https://codemirror.net/6/docs/ref/#language.syntaxParserRunning) when it has spent a\ncertain amount of time or has moved beyond the visible viewport.\nAlways returns false if no language has been enabled.\n*/ function syntaxTreeAvailable(state, upto = state.doc.length) {\n    var _a;\n    return ((_a = state.field(Language.state, false)) === null || _a === void 0 ? void 0 : _a.context.isDone(upto)) || false;\n}\n/**\nMove parsing forward, and update the editor state afterwards to\nreflect the new tree. Will work for at most `timeout`\nmilliseconds. Returns true if the parser managed get to the given\nposition in that time.\n*/ function forceParsing(view, upto = view.viewport.to, timeout = 100) {\n    let success = ensureSyntaxTree(view.state, upto, timeout);\n    if (success != syntaxTree(view.state)) view.dispatch({});\n    return !!success;\n}\n/**\nTells you whether the language parser is planning to do more\nparsing work (in a `requestIdleCallback` pseudo-thread) or has\nstopped running, either because it parsed the entire document,\nbecause it spent too much time and was cut off, or because there\nis no language parser enabled.\n*/ function syntaxParserRunning(view) {\n    var _a;\n    return ((_a = view.plugin(parseWorker)) === null || _a === void 0 ? void 0 : _a.isWorking()) || false;\n}\n/**\nLezer-style\n[`Input`](https://lezer.codemirror.net/docs/ref#common.Input)\nobject for a [`Text`](https://codemirror.net/6/docs/ref/#state.Text) object.\n*/ class DocInput {\n    /**\n    Create an input object for the given document.\n    */ constructor(doc){\n        this.doc = doc;\n        this.cursorPos = 0;\n        this.string = \"\";\n        this.cursor = doc.iter();\n    }\n    get length() {\n        return this.doc.length;\n    }\n    syncTo(pos) {\n        this.string = this.cursor.next(pos - this.cursorPos).value;\n        this.cursorPos = pos + this.string.length;\n        return this.cursorPos - this.string.length;\n    }\n    chunk(pos) {\n        this.syncTo(pos);\n        return this.string;\n    }\n    get lineChunks() {\n        return true;\n    }\n    read(from, to) {\n        let stringStart = this.cursorPos - this.string.length;\n        if (from < stringStart || to >= this.cursorPos) return this.doc.sliceString(from, to);\n        else return this.string.slice(from - stringStart, to - stringStart);\n    }\n}\nlet currentContext = null;\n/**\nA parse context provided to parsers working on the editor content.\n*/ class ParseContext {\n    constructor(parser, /**\n    The current editor state.\n    */ state, /**\n    Tree fragments that can be reused by incremental re-parses.\n    */ fragments = [], /**\n    @internal\n    */ tree, /**\n    @internal\n    */ treeLen, /**\n    The current editor viewport (or some overapproximation\n    thereof). Intended to be used for opportunistically avoiding\n    work (in which case\n    [`skipUntilInView`](https://codemirror.net/6/docs/ref/#language.ParseContext.skipUntilInView)\n    should be called to make sure the parser is restarted when the\n    skipped region becomes visible).\n    */ viewport, /**\n    @internal\n    */ skipped, /**\n    This is where skipping parsers can register a promise that,\n    when resolved, will schedule a new parse. It is cleared when\n    the parse worker picks up the promise. @internal\n    */ scheduleOn){\n        this.parser = parser;\n        this.state = state;\n        this.fragments = fragments;\n        this.tree = tree;\n        this.treeLen = treeLen;\n        this.viewport = viewport;\n        this.skipped = skipped;\n        this.scheduleOn = scheduleOn;\n        this.parse = null;\n        /**\n        @internal\n        */ this.tempSkipped = [];\n    }\n    /**\n    @internal\n    */ static create(parser, state, viewport) {\n        return new ParseContext(parser, state, [], _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.empty, 0, viewport, [], null);\n    }\n    startParse() {\n        return this.parser.startParse(new DocInput(this.state.doc), this.fragments);\n    }\n    /**\n    @internal\n    */ work(until, upto) {\n        if (upto != null && upto >= this.state.doc.length) upto = undefined;\n        if (this.tree != _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.empty && this.isDone(upto !== null && upto !== void 0 ? upto : this.state.doc.length)) {\n            this.takeTree();\n            return true;\n        }\n        return this.withContext(()=>{\n            var _a;\n            if (typeof until == \"number\") {\n                let endTime = Date.now() + until;\n                until = ()=>Date.now() > endTime;\n            }\n            if (!this.parse) this.parse = this.startParse();\n            if (upto != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > upto) && upto < this.state.doc.length) this.parse.stopAt(upto);\n            for(;;){\n                let done = this.parse.advance();\n                if (done) {\n                    this.fragments = this.withoutTempSkipped(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.TreeFragment.addTree(done, this.fragments, this.parse.stoppedAt != null));\n                    this.treeLen = (_a = this.parse.stoppedAt) !== null && _a !== void 0 ? _a : this.state.doc.length;\n                    this.tree = done;\n                    this.parse = null;\n                    if (this.treeLen < (upto !== null && upto !== void 0 ? upto : this.state.doc.length)) this.parse = this.startParse();\n                    else return true;\n                }\n                if (until()) return false;\n            }\n        });\n    }\n    /**\n    @internal\n    */ takeTree() {\n        let pos, tree;\n        if (this.parse && (pos = this.parse.parsedPos) >= this.treeLen) {\n            if (this.parse.stoppedAt == null || this.parse.stoppedAt > pos) this.parse.stopAt(pos);\n            this.withContext(()=>{\n                while(!(tree = this.parse.advance())){}\n            });\n            this.treeLen = pos;\n            this.tree = tree;\n            this.fragments = this.withoutTempSkipped(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.TreeFragment.addTree(this.tree, this.fragments, true));\n            this.parse = null;\n        }\n    }\n    withContext(f) {\n        let prev = currentContext;\n        currentContext = this;\n        try {\n            return f();\n        } finally{\n            currentContext = prev;\n        }\n    }\n    withoutTempSkipped(fragments) {\n        for(let r; r = this.tempSkipped.pop();)fragments = cutFragments(fragments, r.from, r.to);\n        return fragments;\n    }\n    /**\n    @internal\n    */ changes(changes, newState) {\n        let { fragments, tree, treeLen, viewport, skipped } = this;\n        this.takeTree();\n        if (!changes.empty) {\n            let ranges = [];\n            changes.iterChangedRanges((fromA, toA, fromB, toB)=>ranges.push({\n                    fromA,\n                    toA,\n                    fromB,\n                    toB\n                }));\n            fragments = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.TreeFragment.applyChanges(fragments, ranges);\n            tree = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.empty;\n            treeLen = 0;\n            viewport = {\n                from: changes.mapPos(viewport.from, -1),\n                to: changes.mapPos(viewport.to, 1)\n            };\n            if (this.skipped.length) {\n                skipped = [];\n                for (let r of this.skipped){\n                    let from = changes.mapPos(r.from, 1), to = changes.mapPos(r.to, -1);\n                    if (from < to) skipped.push({\n                        from,\n                        to\n                    });\n                }\n            }\n        }\n        return new ParseContext(this.parser, newState, fragments, tree, treeLen, viewport, skipped, this.scheduleOn);\n    }\n    /**\n    @internal\n    */ updateViewport(viewport) {\n        if (this.viewport.from == viewport.from && this.viewport.to == viewport.to) return false;\n        this.viewport = viewport;\n        let startLen = this.skipped.length;\n        for(let i = 0; i < this.skipped.length; i++){\n            let { from, to } = this.skipped[i];\n            if (from < viewport.to && to > viewport.from) {\n                this.fragments = cutFragments(this.fragments, from, to);\n                this.skipped.splice(i--, 1);\n            }\n        }\n        if (this.skipped.length >= startLen) return false;\n        this.reset();\n        return true;\n    }\n    /**\n    @internal\n    */ reset() {\n        if (this.parse) {\n            this.takeTree();\n            this.parse = null;\n        }\n    }\n    /**\n    Notify the parse scheduler that the given region was skipped\n    because it wasn't in view, and the parse should be restarted\n    when it comes into view.\n    */ skipUntilInView(from, to) {\n        this.skipped.push({\n            from,\n            to\n        });\n    }\n    /**\n    Returns a parser intended to be used as placeholder when\n    asynchronously loading a nested parser. It'll skip its input and\n    mark it as not-really-parsed, so that the next update will parse\n    it again.\n    \n    When `until` is given, a reparse will be scheduled when that\n    promise resolves.\n    */ static getSkippingParser(until) {\n        return new class extends _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Parser {\n            createParse(input, fragments, ranges) {\n                let from = ranges[0].from, to = ranges[ranges.length - 1].to;\n                let parser = {\n                    parsedPos: from,\n                    advance () {\n                        let cx = currentContext;\n                        if (cx) {\n                            for (let r of ranges)cx.tempSkipped.push(r);\n                            if (until) cx.scheduleOn = cx.scheduleOn ? Promise.all([\n                                cx.scheduleOn,\n                                until\n                            ]) : until;\n                        }\n                        this.parsedPos = to;\n                        return new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeType.none, [], [], to - from);\n                    },\n                    stoppedAt: null,\n                    stopAt () {}\n                };\n                return parser;\n            }\n        };\n    }\n    /**\n    @internal\n    */ isDone(upto) {\n        upto = Math.min(upto, this.state.doc.length);\n        let frags = this.fragments;\n        return this.treeLen >= upto && frags.length && frags[0].from == 0 && frags[0].to >= upto;\n    }\n    /**\n    Get the context for the current parse, or `null` if no editor\n    parse is in progress.\n    */ static get() {\n        return currentContext;\n    }\n}\nfunction cutFragments(fragments, from, to) {\n    return _lezer_common__WEBPACK_IMPORTED_MODULE_0__.TreeFragment.applyChanges(fragments, [\n        {\n            fromA: from,\n            toA: to,\n            fromB: from,\n            toB: to\n        }\n    ]);\n}\nclass LanguageState {\n    constructor(// A mutable parse state that is used to preserve work done during\n    // the lifetime of a state when moving to the next state.\n    context){\n        this.context = context;\n        this.tree = context.tree;\n    }\n    apply(tr) {\n        if (!tr.docChanged && this.tree == this.context.tree) return this;\n        let newCx = this.context.changes(tr.changes, tr.state);\n        // If the previous parse wasn't done, go forward only up to its\n        // end position or the end of the viewport, to avoid slowing down\n        // state updates with parse work beyond the viewport.\n        let upto = this.context.treeLen == tr.startState.doc.length ? undefined : Math.max(tr.changes.mapPos(this.context.treeLen), newCx.viewport.to);\n        if (!newCx.work(20 /* Work.Apply */ , upto)) newCx.takeTree();\n        return new LanguageState(newCx);\n    }\n    static init(state) {\n        let vpTo = Math.min(3000 /* Work.InitViewport */ , state.doc.length);\n        let parseState = ParseContext.create(state.facet(language).parser, state, {\n            from: 0,\n            to: vpTo\n        });\n        if (!parseState.work(20 /* Work.Apply */ , vpTo)) parseState.takeTree();\n        return new LanguageState(parseState);\n    }\n}\nLanguage.state = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateField.define({\n    create: LanguageState.init,\n    update (value, tr) {\n        for (let e of tr.effects)if (e.is(Language.setState)) return e.value;\n        if (tr.startState.facet(language) != tr.state.facet(language)) return LanguageState.init(tr.state);\n        return value.apply(tr);\n    }\n});\nlet requestIdle = (callback)=>{\n    let timeout = setTimeout(()=>callback(), 500 /* Work.MaxPause */ );\n    return ()=>clearTimeout(timeout);\n};\nif (typeof requestIdleCallback != \"undefined\") requestIdle = (callback)=>{\n    let idle = -1, timeout = setTimeout(()=>{\n        idle = requestIdleCallback(callback, {\n            timeout: 500 /* Work.MaxPause */  - 100 /* Work.MinPause */ \n        });\n    }, 100 /* Work.MinPause */ );\n    return ()=>idle < 0 ? clearTimeout(timeout) : cancelIdleCallback(idle);\n};\nconst isInputPending = typeof navigator != \"undefined\" && ((_a = navigator.scheduling) === null || _a === void 0 ? void 0 : _a.isInputPending) ? ()=>navigator.scheduling.isInputPending() : null;\nconst parseWorker = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.ViewPlugin.fromClass(class ParseWorker {\n    constructor(view){\n        this.view = view;\n        this.working = null;\n        this.workScheduled = 0;\n        // End of the current time chunk\n        this.chunkEnd = -1;\n        // Milliseconds of budget left for this chunk\n        this.chunkBudget = -1;\n        this.work = this.work.bind(this);\n        this.scheduleWork();\n    }\n    update(update) {\n        let cx = this.view.state.field(Language.state).context;\n        if (cx.updateViewport(update.view.viewport) || this.view.viewport.to > cx.treeLen) this.scheduleWork();\n        if (update.docChanged || update.selectionSet) {\n            if (this.view.hasFocus) this.chunkBudget += 50 /* Work.ChangeBonus */ ;\n            this.scheduleWork();\n        }\n        this.checkAsyncSchedule(cx);\n    }\n    scheduleWork() {\n        if (this.working) return;\n        let { state } = this.view, field = state.field(Language.state);\n        if (field.tree != field.context.tree || !field.context.isDone(state.doc.length)) this.working = requestIdle(this.work);\n    }\n    work(deadline) {\n        this.working = null;\n        let now = Date.now();\n        if (this.chunkEnd < now && (this.chunkEnd < 0 || this.view.hasFocus)) {\n            this.chunkEnd = now + 30000 /* Work.ChunkTime */ ;\n            this.chunkBudget = 3000 /* Work.ChunkBudget */ ;\n        }\n        if (this.chunkBudget <= 0) return; // No more budget\n        let { state, viewport: { to: vpTo } } = this.view, field = state.field(Language.state);\n        if (field.tree == field.context.tree && field.context.isDone(vpTo + 100000 /* Work.MaxParseAhead */ )) return;\n        let endTime = Date.now() + Math.min(this.chunkBudget, 100 /* Work.Slice */ , deadline && !isInputPending ? Math.max(25 /* Work.MinSlice */ , deadline.timeRemaining() - 5) : 1e9);\n        let viewportFirst = field.context.treeLen < vpTo && state.doc.length > vpTo + 1000;\n        let done = field.context.work(()=>{\n            return isInputPending && isInputPending() || Date.now() > endTime;\n        }, vpTo + (viewportFirst ? 0 : 100000 /* Work.MaxParseAhead */ ));\n        this.chunkBudget -= Date.now() - now;\n        if (done || this.chunkBudget <= 0) {\n            field.context.takeTree();\n            this.view.dispatch({\n                effects: Language.setState.of(new LanguageState(field.context))\n            });\n        }\n        if (this.chunkBudget > 0 && !(done && !viewportFirst)) this.scheduleWork();\n        this.checkAsyncSchedule(field.context);\n    }\n    checkAsyncSchedule(cx) {\n        if (cx.scheduleOn) {\n            this.workScheduled++;\n            cx.scheduleOn.then(()=>this.scheduleWork()).catch((err)=>(0,_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.logException)(this.view.state, err)).then(()=>this.workScheduled--);\n            cx.scheduleOn = null;\n        }\n    }\n    destroy() {\n        if (this.working) this.working();\n    }\n    isWorking() {\n        return !!(this.working || this.workScheduled > 0);\n    }\n}, {\n    eventHandlers: {\n        focus () {\n            this.scheduleWork();\n        }\n    }\n});\n/**\nThe facet used to associate a language with an editor state. Used\nby `Language` object's `extension` property (so you don't need to\nmanually wrap your languages in this). Can be used to access the\ncurrent language on a state.\n*/ const language = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n    combine (languages) {\n        return languages.length ? languages[0] : null;\n    },\n    enables: (language)=>[\n            Language.state,\n            parseWorker,\n            _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.contentAttributes.compute([\n                language\n            ], (state)=>{\n                let lang = state.facet(language);\n                return lang && lang.name ? {\n                    \"data-language\": lang.name\n                } : {};\n            })\n        ]\n});\n/**\nThis class bundles a [language](https://codemirror.net/6/docs/ref/#language.Language) with an\noptional set of supporting extensions. Language packages are\nencouraged to export a function that optionally takes a\nconfiguration object and returns a `LanguageSupport` instance, as\nthe main way for client code to use the package.\n*/ class LanguageSupport {\n    /**\n    Create a language support object.\n    */ constructor(/**\n    The language object.\n    */ language, /**\n    An optional set of supporting extensions. When nesting a\n    language in another language, the outer language is encouraged\n    to include the supporting extensions for its inner languages\n    in its own set of support extensions.\n    */ support = []){\n        this.language = language;\n        this.support = support;\n        this.extension = [\n            language,\n            support\n        ];\n    }\n}\n/**\nLanguage descriptions are used to store metadata about languages\nand to dynamically load them. Their main role is finding the\nappropriate language for a filename or dynamically loading nested\nparsers.\n*/ class LanguageDescription {\n    constructor(/**\n    The name of this language.\n    */ name, /**\n    Alternative names for the mode (lowercased, includes `this.name`).\n    */ alias, /**\n    File extensions associated with this language.\n    */ extensions, /**\n    Optional filename pattern that should be associated with this\n    language.\n    */ filename, loadFunc, /**\n    If the language has been loaded, this will hold its value.\n    */ support = undefined){\n        this.name = name;\n        this.alias = alias;\n        this.extensions = extensions;\n        this.filename = filename;\n        this.loadFunc = loadFunc;\n        this.support = support;\n        this.loading = null;\n    }\n    /**\n    Start loading the the language. Will return a promise that\n    resolves to a [`LanguageSupport`](https://codemirror.net/6/docs/ref/#language.LanguageSupport)\n    object when the language successfully loads.\n    */ load() {\n        return this.loading || (this.loading = this.loadFunc().then((support)=>this.support = support, (err)=>{\n            this.loading = null;\n            throw err;\n        }));\n    }\n    /**\n    Create a language description.\n    */ static of(spec) {\n        let { load, support } = spec;\n        if (!load) {\n            if (!support) throw new RangeError(\"Must pass either 'load' or 'support' to LanguageDescription.of\");\n            load = ()=>Promise.resolve(support);\n        }\n        return new LanguageDescription(spec.name, (spec.alias || []).concat(spec.name).map((s)=>s.toLowerCase()), spec.extensions || [], spec.filename, load, support);\n    }\n    /**\n    Look for a language in the given array of descriptions that\n    matches the filename. Will first match\n    [`filename`](https://codemirror.net/6/docs/ref/#language.LanguageDescription.filename) patterns,\n    and then [extensions](https://codemirror.net/6/docs/ref/#language.LanguageDescription.extensions),\n    and return the first language that matches.\n    */ static matchFilename(descs, filename) {\n        for (let d of descs)if (d.filename && d.filename.test(filename)) return d;\n        let ext = /\\.([^.]+)$/.exec(filename);\n        if (ext) {\n            for (let d of descs)if (d.extensions.indexOf(ext[1]) > -1) return d;\n        }\n        return null;\n    }\n    /**\n    Look for a language whose name or alias matches the the given\n    name (case-insensitively). If `fuzzy` is true, and no direct\n    matchs is found, this'll also search for a language whose name\n    or alias occurs in the string (for names shorter than three\n    characters, only when surrounded by non-word characters).\n    */ static matchLanguageName(descs, name, fuzzy = true) {\n        name = name.toLowerCase();\n        for (let d of descs)if (d.alias.some((a)=>a == name)) return d;\n        if (fuzzy) for (let d of descs)for (let a of d.alias){\n            let found = name.indexOf(a);\n            if (found > -1 && (a.length > 2 || !/\\w/.test(name[found - 1]) && !/\\w/.test(name[found + a.length]))) return d;\n        }\n        return null;\n    }\n}\n/**\nFacet that defines a way to provide a function that computes the\nappropriate indentation depth, as a column number (see\n[`indentString`](https://codemirror.net/6/docs/ref/#language.indentString)), at the start of a given\nline. A return value of `null` indicates no indentation can be\ndetermined, and the line should inherit the indentation of the one\nabove it. A return value of `undefined` defers to the next indent\nservice.\n*/ const indentService = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();\n/**\nFacet for overriding the unit by which indentation happens. Should\nbe a string consisting either entirely of the same whitespace\ncharacter. When not set, this defaults to 2 spaces.\n*/ const indentUnit = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n    combine: (values)=>{\n        if (!values.length) return \"  \";\n        let unit = values[0];\n        if (!unit || /\\S/.test(unit) || Array.from(unit).some((e)=>e != unit[0])) throw new Error(\"Invalid indent unit: \" + JSON.stringify(values[0]));\n        return unit;\n    }\n});\n/**\nReturn the _column width_ of an indent unit in the state.\nDetermined by the [`indentUnit`](https://codemirror.net/6/docs/ref/#language.indentUnit)\nfacet, and [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) when that\ncontains tabs.\n*/ function getIndentUnit(state) {\n    let unit = state.facet(indentUnit);\n    return unit.charCodeAt(0) == 9 ? state.tabSize * unit.length : unit.length;\n}\n/**\nCreate an indentation string that covers columns 0 to `cols`.\nWill use tabs for as much of the columns as possible when the\n[`indentUnit`](https://codemirror.net/6/docs/ref/#language.indentUnit) facet contains\ntabs.\n*/ function indentString(state, cols) {\n    let result = \"\", ts = state.tabSize, ch = state.facet(indentUnit)[0];\n    if (ch == \"\t\") {\n        while(cols >= ts){\n            result += \"\t\";\n            cols -= ts;\n        }\n        ch = \" \";\n    }\n    for(let i = 0; i < cols; i++)result += ch;\n    return result;\n}\n/**\nGet the indentation, as a column number, at the given position.\nWill first consult any [indent services](https://codemirror.net/6/docs/ref/#language.indentService)\nthat are registered, and if none of those return an indentation,\nthis will check the syntax tree for the [indent node\nprop](https://codemirror.net/6/docs/ref/#language.indentNodeProp) and use that if found. Returns a\nnumber when an indentation could be determined, and null\notherwise.\n*/ function getIndentation(context, pos) {\n    if (context instanceof _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorState) context = new IndentContext(context);\n    for (let service of context.state.facet(indentService)){\n        let result = service(context, pos);\n        if (result !== undefined) return result;\n    }\n    let tree = syntaxTree(context.state);\n    return tree.length >= pos ? syntaxIndentation(context, tree, pos) : null;\n}\n/**\nCreate a change set that auto-indents all lines touched by the\ngiven document range.\n*/ function indentRange(state, from, to) {\n    let updated = Object.create(null);\n    let context = new IndentContext(state, {\n        overrideIndentation: (start)=>{\n            var _a;\n            return (_a = updated[start]) !== null && _a !== void 0 ? _a : -1;\n        }\n    });\n    let changes = [];\n    for(let pos = from; pos <= to;){\n        let line = state.doc.lineAt(pos);\n        pos = line.to + 1;\n        let indent = getIndentation(context, line.from);\n        if (indent == null) continue;\n        if (!/\\S/.test(line.text)) indent = 0;\n        let cur = /^\\s*/.exec(line.text)[0];\n        let norm = indentString(state, indent);\n        if (cur != norm) {\n            updated[line.from] = indent;\n            changes.push({\n                from: line.from,\n                to: line.from + cur.length,\n                insert: norm\n            });\n        }\n    }\n    return state.changes(changes);\n}\n/**\nIndentation contexts are used when calling [indentation\nservices](https://codemirror.net/6/docs/ref/#language.indentService). They provide helper utilities\nuseful in indentation logic, and can selectively override the\nindentation reported for some lines.\n*/ class IndentContext {\n    /**\n    Create an indent context.\n    */ constructor(/**\n    The editor state.\n    */ state, /**\n    @internal\n    */ options = {}){\n        this.state = state;\n        this.options = options;\n        this.unit = getIndentUnit(state);\n    }\n    /**\n    Get a description of the line at the given position, taking\n    [simulated line\n    breaks](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)\n    into account. If there is such a break at `pos`, the `bias`\n    argument determines whether the part of the line line before or\n    after the break is used.\n    */ lineAt(pos, bias = 1) {\n        let line = this.state.doc.lineAt(pos);\n        let { simulateBreak, simulateDoubleBreak } = this.options;\n        if (simulateBreak != null && simulateBreak >= line.from && simulateBreak <= line.to) {\n            if (simulateDoubleBreak && simulateBreak == pos) return {\n                text: \"\",\n                from: pos\n            };\n            else if (bias < 0 ? simulateBreak < pos : simulateBreak <= pos) return {\n                text: line.text.slice(simulateBreak - line.from),\n                from: simulateBreak\n            };\n            else return {\n                text: line.text.slice(0, simulateBreak - line.from),\n                from: line.from\n            };\n        }\n        return line;\n    }\n    /**\n    Get the text directly after `pos`, either the entire line\n    or the next 100 characters, whichever is shorter.\n    */ textAfterPos(pos, bias = 1) {\n        if (this.options.simulateDoubleBreak && pos == this.options.simulateBreak) return \"\";\n        let { text, from } = this.lineAt(pos, bias);\n        return text.slice(pos - from, Math.min(text.length, pos + 100 - from));\n    }\n    /**\n    Find the column for the given position.\n    */ column(pos, bias = 1) {\n        let { text, from } = this.lineAt(pos, bias);\n        let result = this.countColumn(text, pos - from);\n        let override = this.options.overrideIndentation ? this.options.overrideIndentation(from) : -1;\n        if (override > -1) result += override - this.countColumn(text, text.search(/\\S|$/));\n        return result;\n    }\n    /**\n    Find the column position (taking tabs into account) of the given\n    position in the given string.\n    */ countColumn(line, pos = line.length) {\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.countColumn)(line, this.state.tabSize, pos);\n    }\n    /**\n    Find the indentation column of the line at the given point.\n    */ lineIndent(pos, bias = 1) {\n        let { text, from } = this.lineAt(pos, bias);\n        let override = this.options.overrideIndentation;\n        if (override) {\n            let overriden = override(from);\n            if (overriden > -1) return overriden;\n        }\n        return this.countColumn(text, text.search(/\\S|$/));\n    }\n    /**\n    Returns the [simulated line\n    break](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)\n    for this context, if any.\n    */ get simulatedBreak() {\n        return this.options.simulateBreak || null;\n    }\n}\n/**\nA syntax tree node prop used to associate indentation strategies\nwith node types. Such a strategy is a function from an indentation\ncontext to a column number (see also\n[`indentString`](https://codemirror.net/6/docs/ref/#language.indentString)) or null, where null\nindicates that no definitive indentation can be determined.\n*/ const indentNodeProp = /*@__PURE__*/ new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp();\n// Compute the indentation for a given position from the syntax tree.\nfunction syntaxIndentation(cx, ast, pos) {\n    let stack = ast.resolveStack(pos);\n    let inner = stack.node.enterUnfinishedNodesBefore(pos);\n    if (inner != stack.node) {\n        let add = [];\n        for(let cur = inner; cur != stack.node; cur = cur.parent)add.push(cur);\n        for(let i = add.length - 1; i >= 0; i--)stack = {\n            node: add[i],\n            next: stack\n        };\n    }\n    return indentFor(stack, cx, pos);\n}\nfunction indentFor(stack, cx, pos) {\n    for(let cur = stack; cur; cur = cur.next){\n        let strategy = indentStrategy(cur.node);\n        if (strategy) return strategy(TreeIndentContext.create(cx, pos, cur));\n    }\n    return 0;\n}\nfunction ignoreClosed(cx) {\n    return cx.pos == cx.options.simulateBreak && cx.options.simulateDoubleBreak;\n}\nfunction indentStrategy(tree) {\n    let strategy = tree.type.prop(indentNodeProp);\n    if (strategy) return strategy;\n    let first = tree.firstChild, close;\n    if (first && (close = first.type.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.closedBy))) {\n        let last = tree.lastChild, closed = last && close.indexOf(last.name) > -1;\n        return (cx)=>delimitedStrategy(cx, true, 1, undefined, closed && !ignoreClosed(cx) ? last.from : undefined);\n    }\n    return tree.parent == null ? topIndent : null;\n}\nfunction topIndent() {\n    return 0;\n}\n/**\nObjects of this type provide context information and helper\nmethods to indentation functions registered on syntax nodes.\n*/ class TreeIndentContext extends IndentContext {\n    constructor(base, /**\n    The position at which indentation is being computed.\n    */ pos, /**\n    @internal\n    */ context){\n        super(base.state, base.options);\n        this.base = base;\n        this.pos = pos;\n        this.context = context;\n    }\n    /**\n    The syntax tree node to which the indentation strategy\n    applies.\n    */ get node() {\n        return this.context.node;\n    }\n    /**\n    @internal\n    */ static create(base, pos, context) {\n        return new TreeIndentContext(base, pos, context);\n    }\n    /**\n    Get the text directly after `this.pos`, either the entire line\n    or the next 100 characters, whichever is shorter.\n    */ get textAfter() {\n        return this.textAfterPos(this.pos);\n    }\n    /**\n    Get the indentation at the reference line for `this.node`, which\n    is the line on which it starts, unless there is a node that is\n    _not_ a parent of this node covering the start of that line. If\n    so, the line at the start of that node is tried, again skipping\n    on if it is covered by another such node.\n    */ get baseIndent() {\n        return this.baseIndentFor(this.node);\n    }\n    /**\n    Get the indentation for the reference line of the given node\n    (see [`baseIndent`](https://codemirror.net/6/docs/ref/#language.TreeIndentContext.baseIndent)).\n    */ baseIndentFor(node) {\n        let line = this.state.doc.lineAt(node.from);\n        // Skip line starts that are covered by a sibling (or cousin, etc)\n        for(;;){\n            let atBreak = node.resolve(line.from);\n            while(atBreak.parent && atBreak.parent.from == atBreak.from)atBreak = atBreak.parent;\n            if (isParent(atBreak, node)) break;\n            line = this.state.doc.lineAt(atBreak.from);\n        }\n        return this.lineIndent(line.from);\n    }\n    /**\n    Continue looking for indentations in the node's parent nodes,\n    and return the result of that.\n    */ continue() {\n        return indentFor(this.context.next, this.base, this.pos);\n    }\n}\nfunction isParent(parent, of) {\n    for(let cur = of; cur; cur = cur.parent)if (parent == cur) return true;\n    return false;\n}\n// Check whether a delimited node is aligned (meaning there are\n// non-skipped nodes on the same line as the opening delimiter). And\n// if so, return the opening token.\nfunction bracketedAligned(context) {\n    let tree = context.node;\n    let openToken = tree.childAfter(tree.from), last = tree.lastChild;\n    if (!openToken) return null;\n    let sim = context.options.simulateBreak;\n    let openLine = context.state.doc.lineAt(openToken.from);\n    let lineEnd = sim == null || sim <= openLine.from ? openLine.to : Math.min(openLine.to, sim);\n    for(let pos = openToken.to;;){\n        let next = tree.childAfter(pos);\n        if (!next || next == last) return null;\n        if (!next.type.isSkipped) return next.from < lineEnd ? openToken : null;\n        pos = next.to;\n    }\n}\n/**\nAn indentation strategy for delimited (usually bracketed) nodes.\nWill, by default, indent one unit more than the parent's base\nindent unless the line starts with a closing token. When `align`\nis true and there are non-skipped nodes on the node's opening\nline, the content of the node will be aligned with the end of the\nopening node, like this:\n\n    foo(bar,\n        baz)\n*/ function delimitedIndent({ closing, align = true, units = 1 }) {\n    return (context)=>delimitedStrategy(context, align, units, closing);\n}\nfunction delimitedStrategy(context, align, units, closing, closedAt) {\n    let after = context.textAfter, space = after.match(/^\\s*/)[0].length;\n    let closed = closing && after.slice(space, space + closing.length) == closing || closedAt == context.pos + space;\n    let aligned = align ? bracketedAligned(context) : null;\n    if (aligned) return closed ? context.column(aligned.from) : context.column(aligned.to);\n    return context.baseIndent + (closed ? 0 : context.unit * units);\n}\n/**\nAn indentation strategy that aligns a node's content to its base\nindentation.\n*/ const flatIndent = (context)=>context.baseIndent;\n/**\nCreates an indentation strategy that, by default, indents\ncontinued lines one unit more than the node's base indentation.\nYou can provide `except` to prevent indentation of lines that\nmatch a pattern (for example `/^else\\b/` in `if`/`else`\nconstructs), and you can change the amount of units used with the\n`units` option.\n*/ function continuedIndent({ except, units = 1 } = {}) {\n    return (context)=>{\n        let matchExcept = except && except.test(context.textAfter);\n        return context.baseIndent + (matchExcept ? 0 : units * context.unit);\n    };\n}\nconst DontIndentBeyond = 200;\n/**\nEnables reindentation on input. When a language defines an\n`indentOnInput` field in its [language\ndata](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt), which must hold a regular\nexpression, the line at the cursor will be reindented whenever new\ntext is typed and the input from the start of the line up to the\ncursor matches that regexp.\n\nTo avoid unneccesary reindents, it is recommended to start the\nregexp with `^` (usually followed by `\\s*`), and end it with `$`.\nFor example, `/^\\s*\\}$/` will reindent when a closing brace is\nadded at the start of a line.\n*/ function indentOnInput() {\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorState.transactionFilter.of((tr)=>{\n        if (!tr.docChanged || !tr.isUserEvent(\"input.type\") && !tr.isUserEvent(\"input.complete\")) return tr;\n        let rules = tr.startState.languageDataAt(\"indentOnInput\", tr.startState.selection.main.head);\n        if (!rules.length) return tr;\n        let doc = tr.newDoc, { head } = tr.newSelection.main, line = doc.lineAt(head);\n        if (head > line.from + DontIndentBeyond) return tr;\n        let lineStart = doc.sliceString(line.from, head);\n        if (!rules.some((r)=>r.test(lineStart))) return tr;\n        let { state } = tr, last = -1, changes = [];\n        for (let { head } of state.selection.ranges){\n            let line = state.doc.lineAt(head);\n            if (line.from == last) continue;\n            last = line.from;\n            let indent = getIndentation(state, line.from);\n            if (indent == null) continue;\n            let cur = /^\\s*/.exec(line.text)[0];\n            let norm = indentString(state, indent);\n            if (cur != norm) changes.push({\n                from: line.from,\n                to: line.from + cur.length,\n                insert: norm\n            });\n        }\n        return changes.length ? [\n            tr,\n            {\n                changes,\n                sequential: true\n            }\n        ] : tr;\n    });\n}\n/**\nA facet that registers a code folding service. When called with\nthe extent of a line, such a function should return a foldable\nrange that starts on that line (but continues beyond it), if one\ncan be found.\n*/ const foldService = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();\n/**\nThis node prop is used to associate folding information with\nsyntax node types. Given a syntax node, it should check whether\nthat tree is foldable and return the range that can be collapsed\nwhen it is.\n*/ const foldNodeProp = /*@__PURE__*/ new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp();\n/**\n[Fold](https://codemirror.net/6/docs/ref/#language.foldNodeProp) function that folds everything but\nthe first and the last child of a syntax node. Useful for nodes\nthat start and end with delimiters.\n*/ function foldInside(node) {\n    let first = node.firstChild, last = node.lastChild;\n    return first && first.to < last.from ? {\n        from: first.to,\n        to: last.type.isError ? node.to : last.from\n    } : null;\n}\nfunction syntaxFolding(state, start, end) {\n    let tree = syntaxTree(state);\n    if (tree.length < end) return null;\n    let stack = tree.resolveStack(end, 1);\n    let found = null;\n    for(let iter = stack; iter; iter = iter.next){\n        let cur = iter.node;\n        if (cur.to <= end || cur.from > end) continue;\n        if (found && cur.from < start) break;\n        let prop = cur.type.prop(foldNodeProp);\n        if (prop && (cur.to < tree.length - 50 || tree.length == state.doc.length || !isUnfinished(cur))) {\n            let value = prop(cur, state);\n            if (value && value.from <= end && value.from >= start && value.to > end) found = value;\n        }\n    }\n    return found;\n}\nfunction isUnfinished(node) {\n    let ch = node.lastChild;\n    return ch && ch.to == node.to && ch.type.isError;\n}\n/**\nCheck whether the given line is foldable. First asks any fold\nservices registered through\n[`foldService`](https://codemirror.net/6/docs/ref/#language.foldService), and if none of them return\na result, tries to query the [fold node\nprop](https://codemirror.net/6/docs/ref/#language.foldNodeProp) of syntax nodes that cover the end\nof the line.\n*/ function foldable(state, lineStart, lineEnd) {\n    for (let service of state.facet(foldService)){\n        let result = service(state, lineStart, lineEnd);\n        if (result) return result;\n    }\n    return syntaxFolding(state, lineStart, lineEnd);\n}\nfunction mapRange(range, mapping) {\n    let from = mapping.mapPos(range.from, 1), to = mapping.mapPos(range.to, -1);\n    return from >= to ? undefined : {\n        from,\n        to\n    };\n}\n/**\nState effect that can be attached to a transaction to fold the\ngiven range. (You probably only need this in exceptional\ncircumstances—usually you'll just want to let\n[`foldCode`](https://codemirror.net/6/docs/ref/#language.foldCode) and the [fold\ngutter](https://codemirror.net/6/docs/ref/#language.foldGutter) create the transactions.)\n*/ const foldEffect = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateEffect.define({\n    map: mapRange\n});\n/**\nState effect that unfolds the given range (if it was folded).\n*/ const unfoldEffect = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateEffect.define({\n    map: mapRange\n});\nfunction selectedLines(view) {\n    let lines = [];\n    for (let { head } of view.state.selection.ranges){\n        if (lines.some((l)=>l.from <= head && l.to >= head)) continue;\n        lines.push(view.lineBlockAt(head));\n    }\n    return lines;\n}\n/**\nThe state field that stores the folded ranges (as a [decoration\nset](https://codemirror.net/6/docs/ref/#view.DecorationSet)). Can be passed to\n[`EditorState.toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) and\n[`fromJSON`](https://codemirror.net/6/docs/ref/#state.EditorState^fromJSON) to serialize the fold\nstate.\n*/ const foldState = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateField.define({\n    create () {\n        return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.none;\n    },\n    update (folded, tr) {\n        folded = folded.map(tr.changes);\n        for (let e of tr.effects){\n            if (e.is(foldEffect) && !foldExists(folded, e.value.from, e.value.to)) {\n                let { preparePlaceholder } = tr.state.facet(foldConfig);\n                let widget = !preparePlaceholder ? foldWidget : _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.replace({\n                    widget: new PreparedFoldWidget(preparePlaceholder(tr.state, e.value))\n                });\n                folded = folded.update({\n                    add: [\n                        widget.range(e.value.from, e.value.to)\n                    ]\n                });\n            } else if (e.is(unfoldEffect)) {\n                folded = folded.update({\n                    filter: (from, to)=>e.value.from != from || e.value.to != to,\n                    filterFrom: e.value.from,\n                    filterTo: e.value.to\n                });\n            }\n        }\n        // Clear folded ranges that cover the selection head\n        if (tr.selection) {\n            let onSelection = false, { head } = tr.selection.main;\n            folded.between(head, head, (a, b)=>{\n                if (a < head && b > head) onSelection = true;\n            });\n            if (onSelection) folded = folded.update({\n                filterFrom: head,\n                filterTo: head,\n                filter: (a, b)=>b <= head || a >= head\n            });\n        }\n        return folded;\n    },\n    provide: (f)=>_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.decorations.from(f),\n    toJSON (folded, state) {\n        let ranges = [];\n        folded.between(0, state.doc.length, (from, to)=>{\n            ranges.push(from, to);\n        });\n        return ranges;\n    },\n    fromJSON (value) {\n        if (!Array.isArray(value) || value.length % 2) throw new RangeError(\"Invalid JSON for fold state\");\n        let ranges = [];\n        for(let i = 0; i < value.length;){\n            let from = value[i++], to = value[i++];\n            if (typeof from != \"number\" || typeof to != \"number\") throw new RangeError(\"Invalid JSON for fold state\");\n            ranges.push(foldWidget.range(from, to));\n        }\n        return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.set(ranges, true);\n    }\n});\n/**\nGet a [range set](https://codemirror.net/6/docs/ref/#state.RangeSet) containing the folded ranges\nin the given state.\n*/ function foldedRanges(state) {\n    return state.field(foldState, false) || _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSet.empty;\n}\nfunction findFold(state, from, to) {\n    var _a;\n    let found = null;\n    (_a = state.field(foldState, false)) === null || _a === void 0 ? void 0 : _a.between(from, to, (from, to)=>{\n        if (!found || found.from > from) found = {\n            from,\n            to\n        };\n    });\n    return found;\n}\nfunction foldExists(folded, from, to) {\n    let found = false;\n    folded.between(from, from, (a, b)=>{\n        if (a == from && b == to) found = true;\n    });\n    return found;\n}\nfunction maybeEnable(state, other) {\n    return state.field(foldState, false) ? other : other.concat(_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateEffect.appendConfig.of(codeFolding()));\n}\n/**\nFold the lines that are selected, if possible.\n*/ const foldCode = (view)=>{\n    for (let line of selectedLines(view)){\n        let range = foldable(view.state, line.from, line.to);\n        if (range) {\n            view.dispatch({\n                effects: maybeEnable(view.state, [\n                    foldEffect.of(range),\n                    announceFold(view, range)\n                ])\n            });\n            return true;\n        }\n    }\n    return false;\n};\n/**\nUnfold folded ranges on selected lines.\n*/ const unfoldCode = (view)=>{\n    if (!view.state.field(foldState, false)) return false;\n    let effects = [];\n    for (let line of selectedLines(view)){\n        let folded = findFold(view.state, line.from, line.to);\n        if (folded) effects.push(unfoldEffect.of(folded), announceFold(view, folded, false));\n    }\n    if (effects.length) view.dispatch({\n        effects\n    });\n    return effects.length > 0;\n};\nfunction announceFold(view, range, fold = true) {\n    let lineFrom = view.state.doc.lineAt(range.from).number, lineTo = view.state.doc.lineAt(range.to).number;\n    return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.announce.of(`${view.state.phrase(fold ? \"Folded lines\" : \"Unfolded lines\")} ${lineFrom} ${view.state.phrase(\"to\")} ${lineTo}.`);\n}\n/**\nFold all top-level foldable ranges. Note that, in most cases,\nfolding information will depend on the [syntax\ntree](https://codemirror.net/6/docs/ref/#language.syntaxTree), and folding everything may not work\nreliably when the document hasn't been fully parsed (either\nbecause the editor state was only just initialized, or because the\ndocument is so big that the parser decided not to parse it\nentirely).\n*/ const foldAll = (view)=>{\n    let { state } = view, effects = [];\n    for(let pos = 0; pos < state.doc.length;){\n        let line = view.lineBlockAt(pos), range = foldable(state, line.from, line.to);\n        if (range) effects.push(foldEffect.of(range));\n        pos = (range ? view.lineBlockAt(range.to) : line).to + 1;\n    }\n    if (effects.length) view.dispatch({\n        effects: maybeEnable(view.state, effects)\n    });\n    return !!effects.length;\n};\n/**\nUnfold all folded code.\n*/ const unfoldAll = (view)=>{\n    let field = view.state.field(foldState, false);\n    if (!field || !field.size) return false;\n    let effects = [];\n    field.between(0, view.state.doc.length, (from, to)=>{\n        effects.push(unfoldEffect.of({\n            from,\n            to\n        }));\n    });\n    view.dispatch({\n        effects\n    });\n    return true;\n};\n// Find the foldable region containing the given line, if one exists\nfunction foldableContainer(view, lineBlock) {\n    // Look backwards through line blocks until we find a foldable region that\n    // intersects with the line\n    for(let line = lineBlock;;){\n        let foldableRegion = foldable(view.state, line.from, line.to);\n        if (foldableRegion && foldableRegion.to > lineBlock.from) return foldableRegion;\n        if (!line.from) return null;\n        line = view.lineBlockAt(line.from - 1);\n    }\n}\n/**\nToggle folding at cursors. Unfolds if there is an existing fold\nstarting in that line, tries to find a foldable range around it\notherwise.\n*/ const toggleFold = (view)=>{\n    let effects = [];\n    for (let line of selectedLines(view)){\n        let folded = findFold(view.state, line.from, line.to);\n        if (folded) {\n            effects.push(unfoldEffect.of(folded), announceFold(view, folded, false));\n        } else {\n            let foldRange = foldableContainer(view, line);\n            if (foldRange) effects.push(foldEffect.of(foldRange), announceFold(view, foldRange));\n        }\n    }\n    if (effects.length > 0) view.dispatch({\n        effects: maybeEnable(view.state, effects)\n    });\n    return !!effects.length;\n};\n/**\nDefault fold-related key bindings.\n\n - Ctrl-Shift-[ (Cmd-Alt-[ on macOS): [`foldCode`](https://codemirror.net/6/docs/ref/#language.foldCode).\n - Ctrl-Shift-] (Cmd-Alt-] on macOS): [`unfoldCode`](https://codemirror.net/6/docs/ref/#language.unfoldCode).\n - Ctrl-Alt-[: [`foldAll`](https://codemirror.net/6/docs/ref/#language.foldAll).\n - Ctrl-Alt-]: [`unfoldAll`](https://codemirror.net/6/docs/ref/#language.unfoldAll).\n*/ const foldKeymap = [\n    {\n        key: \"Ctrl-Shift-[\",\n        mac: \"Cmd-Alt-[\",\n        run: foldCode\n    },\n    {\n        key: \"Ctrl-Shift-]\",\n        mac: \"Cmd-Alt-]\",\n        run: unfoldCode\n    },\n    {\n        key: \"Ctrl-Alt-[\",\n        run: foldAll\n    },\n    {\n        key: \"Ctrl-Alt-]\",\n        run: unfoldAll\n    }\n];\nconst defaultConfig = {\n    placeholderDOM: null,\n    preparePlaceholder: null,\n    placeholderText: \"…\"\n};\nconst foldConfig = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n    combine (values) {\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.combineConfig)(values, defaultConfig);\n    }\n});\n/**\nCreate an extension that configures code folding.\n*/ function codeFolding(config) {\n    let result = [\n        foldState,\n        baseTheme$1\n    ];\n    if (config) result.push(foldConfig.of(config));\n    return result;\n}\nfunction widgetToDOM(view, prepared) {\n    let { state } = view, conf = state.facet(foldConfig);\n    let onclick = (event)=>{\n        let line = view.lineBlockAt(view.posAtDOM(event.target));\n        let folded = findFold(view.state, line.from, line.to);\n        if (folded) view.dispatch({\n            effects: unfoldEffect.of(folded)\n        });\n        event.preventDefault();\n    };\n    if (conf.placeholderDOM) return conf.placeholderDOM(view, onclick, prepared);\n    let element = document.createElement(\"span\");\n    element.textContent = conf.placeholderText;\n    element.setAttribute(\"aria-label\", state.phrase(\"folded code\"));\n    element.title = state.phrase(\"unfold\");\n    element.className = \"cm-foldPlaceholder\";\n    element.onclick = onclick;\n    return element;\n}\nconst foldWidget = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.replace({\n    widget: /*@__PURE__*/ new class extends _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.WidgetType {\n        toDOM(view) {\n            return widgetToDOM(view, null);\n        }\n    }\n});\nclass PreparedFoldWidget extends _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.WidgetType {\n    constructor(value){\n        super();\n        this.value = value;\n    }\n    eq(other) {\n        return this.value == other.value;\n    }\n    toDOM(view) {\n        return widgetToDOM(view, this.value);\n    }\n}\nconst foldGutterDefaults = {\n    openText: \"⌄\",\n    closedText: \"›\",\n    markerDOM: null,\n    domEventHandlers: {},\n    foldingChanged: ()=>false\n};\nclass FoldMarker extends _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.GutterMarker {\n    constructor(config, open){\n        super();\n        this.config = config;\n        this.open = open;\n    }\n    eq(other) {\n        return this.config == other.config && this.open == other.open;\n    }\n    toDOM(view) {\n        if (this.config.markerDOM) return this.config.markerDOM(this.open);\n        let span = document.createElement(\"span\");\n        span.textContent = this.open ? this.config.openText : this.config.closedText;\n        span.title = view.state.phrase(this.open ? \"Fold line\" : \"Unfold line\");\n        return span;\n    }\n}\n/**\nCreate an extension that registers a fold gutter, which shows a\nfold status indicator before foldable lines (which can be clicked\nto fold or unfold the line).\n*/ function foldGutter(config = {}) {\n    let fullConfig = Object.assign(Object.assign({}, foldGutterDefaults), config);\n    let canFold = new FoldMarker(fullConfig, true), canUnfold = new FoldMarker(fullConfig, false);\n    let markers = _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.ViewPlugin.fromClass(class {\n        constructor(view){\n            this.from = view.viewport.from;\n            this.markers = this.buildMarkers(view);\n        }\n        update(update) {\n            if (update.docChanged || update.viewportChanged || update.startState.facet(language) != update.state.facet(language) || update.startState.field(foldState, false) != update.state.field(foldState, false) || syntaxTree(update.startState) != syntaxTree(update.state) || fullConfig.foldingChanged(update)) this.markers = this.buildMarkers(update.view);\n        }\n        buildMarkers(view) {\n            let builder = new _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSetBuilder();\n            for (let line of view.viewportLineBlocks){\n                let mark = findFold(view.state, line.from, line.to) ? canUnfold : foldable(view.state, line.from, line.to) ? canFold : null;\n                if (mark) builder.add(line.from, line.from, mark);\n            }\n            return builder.finish();\n        }\n    });\n    let { domEventHandlers } = fullConfig;\n    return [\n        markers,\n        (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.gutter)({\n            class: \"cm-foldGutter\",\n            markers (view) {\n                var _a;\n                return ((_a = view.plugin(markers)) === null || _a === void 0 ? void 0 : _a.markers) || _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSet.empty;\n            },\n            initialSpacer () {\n                return new FoldMarker(fullConfig, false);\n            },\n            domEventHandlers: Object.assign(Object.assign({}, domEventHandlers), {\n                click: (view, line, event)=>{\n                    if (domEventHandlers.click && domEventHandlers.click(view, line, event)) return true;\n                    let folded = findFold(view.state, line.from, line.to);\n                    if (folded) {\n                        view.dispatch({\n                            effects: unfoldEffect.of(folded)\n                        });\n                        return true;\n                    }\n                    let range = foldable(view.state, line.from, line.to);\n                    if (range) {\n                        view.dispatch({\n                            effects: foldEffect.of(range)\n                        });\n                        return true;\n                    }\n                    return false;\n                }\n            })\n        }),\n        codeFolding()\n    ];\n}\nconst baseTheme$1 = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.baseTheme({\n    \".cm-foldPlaceholder\": {\n        backgroundColor: \"#eee\",\n        border: \"1px solid #ddd\",\n        color: \"#888\",\n        borderRadius: \".2em\",\n        margin: \"0 1px\",\n        padding: \"0 1px\",\n        cursor: \"pointer\"\n    },\n    \".cm-foldGutter span\": {\n        padding: \"0 1px\",\n        cursor: \"pointer\"\n    }\n});\n/**\nA highlight style associates CSS styles with higlighting\n[tags](https://lezer.codemirror.net/docs/ref#highlight.Tag).\n*/ class HighlightStyle {\n    constructor(/**\n    The tag styles used to create this highlight style.\n    */ specs, options){\n        this.specs = specs;\n        let modSpec;\n        function def(spec) {\n            let cls = style_mod__WEBPACK_IMPORTED_MODULE_2__.StyleModule.newName();\n            (modSpec || (modSpec = Object.create(null)))[\".\" + cls] = spec;\n            return cls;\n        }\n        const all = typeof options.all == \"string\" ? options.all : options.all ? def(options.all) : undefined;\n        const scopeOpt = options.scope;\n        this.scope = scopeOpt instanceof Language ? (type)=>type.prop(languageDataProp) == scopeOpt.data : scopeOpt ? (type)=>type == scopeOpt : undefined;\n        this.style = (0,_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tagHighlighter)(specs.map((style)=>({\n                tag: style.tag,\n                class: style.class || def(Object.assign({}, style, {\n                    tag: null\n                }))\n            })), {\n            all\n        }).style;\n        this.module = modSpec ? new style_mod__WEBPACK_IMPORTED_MODULE_2__.StyleModule(modSpec) : null;\n        this.themeType = options.themeType;\n    }\n    /**\n    Create a highlighter style that associates the given styles to\n    the given tags. The specs must be objects that hold a style tag\n    or array of tags in their `tag` property, and either a single\n    `class` property providing a static CSS class (for highlighter\n    that rely on external styling), or a\n    [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style\n    set of CSS properties (which define the styling for those tags).\n    \n    The CSS rules created for a highlighter will be emitted in the\n    order of the spec's properties. That means that for elements that\n    have multiple tags associated with them, styles defined further\n    down in the list will have a higher CSS precedence than styles\n    defined earlier.\n    */ static define(specs, options) {\n        return new HighlightStyle(specs, options || {});\n    }\n}\nconst highlighterFacet = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();\nconst fallbackHighlighter = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n    combine (values) {\n        return values.length ? [\n            values[0]\n        ] : null;\n    }\n});\nfunction getHighlighters(state) {\n    let main = state.facet(highlighterFacet);\n    return main.length ? main : state.facet(fallbackHighlighter);\n}\n/**\nWrap a highlighter in an editor extension that uses it to apply\nsyntax highlighting to the editor content.\n\nWhen multiple (non-fallback) styles are provided, the styling\napplied is the union of the classes they emit.\n*/ function syntaxHighlighting(highlighter, options) {\n    let ext = [\n        treeHighlighter\n    ], themeType;\n    if (highlighter instanceof HighlightStyle) {\n        if (highlighter.module) ext.push(_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.styleModule.of(highlighter.module));\n        themeType = highlighter.themeType;\n    }\n    if (options === null || options === void 0 ? void 0 : options.fallback) ext.push(fallbackHighlighter.of(highlighter));\n    else if (themeType) ext.push(highlighterFacet.computeN([\n        _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.darkTheme\n    ], (state)=>{\n        return state.facet(_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.darkTheme) == (themeType == \"dark\") ? [\n            highlighter\n        ] : [];\n    }));\n    else ext.push(highlighterFacet.of(highlighter));\n    return ext;\n}\n/**\nReturns the CSS classes (if any) that the highlighters active in\nthe state would assign to the given style\n[tags](https://lezer.codemirror.net/docs/ref#highlight.Tag) and\n(optional) language\n[scope](https://codemirror.net/6/docs/ref/#language.HighlightStyle^define^options.scope).\n*/ function highlightingFor(state, tags, scope) {\n    let highlighters = getHighlighters(state);\n    let result = null;\n    if (highlighters) for (let highlighter of highlighters){\n        if (!highlighter.scope || scope && highlighter.scope(scope)) {\n            let cls = highlighter.style(tags);\n            if (cls) result = result ? result + \" \" + cls : cls;\n        }\n    }\n    return result;\n}\nclass TreeHighlighter {\n    constructor(view){\n        this.markCache = Object.create(null);\n        this.tree = syntaxTree(view.state);\n        this.decorations = this.buildDeco(view, getHighlighters(view.state));\n    }\n    update(update) {\n        let tree = syntaxTree(update.state), highlighters = getHighlighters(update.state);\n        let styleChange = highlighters != getHighlighters(update.startState);\n        if (tree.length < update.view.viewport.to && !styleChange && tree.type == this.tree.type) {\n            this.decorations = this.decorations.map(update.changes);\n        } else if (tree != this.tree || update.viewportChanged || styleChange) {\n            this.tree = tree;\n            this.decorations = this.buildDeco(update.view, highlighters);\n        }\n    }\n    buildDeco(view, highlighters) {\n        if (!highlighters || !this.tree.length) return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.none;\n        let builder = new _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSetBuilder();\n        for (let { from, to } of view.visibleRanges){\n            (0,_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.highlightTree)(this.tree, highlighters, (from, to, style)=>{\n                builder.add(from, to, this.markCache[style] || (this.markCache[style] = _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.mark({\n                    class: style\n                })));\n            }, from, to);\n        }\n        return builder.finish();\n    }\n}\nconst treeHighlighter = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Prec.high(/*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.ViewPlugin.fromClass(TreeHighlighter, {\n    decorations: (v)=>v.decorations\n}));\n/**\nA default highlight style (works well with light themes).\n*/ const defaultHighlightStyle = /*@__PURE__*/ HighlightStyle.define([\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.meta,\n        color: \"#404740\"\n    },\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.link,\n        textDecoration: \"underline\"\n    },\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.heading,\n        textDecoration: \"underline\",\n        fontWeight: \"bold\"\n    },\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.emphasis,\n        fontStyle: \"italic\"\n    },\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.strong,\n        fontWeight: \"bold\"\n    },\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.strikethrough,\n        textDecoration: \"line-through\"\n    },\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.keyword,\n        color: \"#708\"\n    },\n    {\n        tag: [\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.atom,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.bool,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.url,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.contentSeparator,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.labelName\n        ],\n        color: \"#219\"\n    },\n    {\n        tag: [\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.literal,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.inserted\n        ],\n        color: \"#164\"\n    },\n    {\n        tag: [\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.string,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.deleted\n        ],\n        color: \"#a11\"\n    },\n    {\n        tag: [\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.regexp,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.escape,\n            /*@__PURE__*/ _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.special(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.string)\n        ],\n        color: \"#e40\"\n    },\n    {\n        tag: /*@__PURE__*/ _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definition(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.variableName),\n        color: \"#00f\"\n    },\n    {\n        tag: /*@__PURE__*/ _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.local(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.variableName),\n        color: \"#30a\"\n    },\n    {\n        tag: [\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.typeName,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.namespace\n        ],\n        color: \"#085\"\n    },\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.className,\n        color: \"#167\"\n    },\n    {\n        tag: [\n            /*@__PURE__*/ _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.special(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.variableName),\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.macroName\n        ],\n        color: \"#256\"\n    },\n    {\n        tag: /*@__PURE__*/ _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definition(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.propertyName),\n        color: \"#00c\"\n    },\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.comment,\n        color: \"#940\"\n    },\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.invalid,\n        color: \"#f00\"\n    }\n]);\nconst baseTheme = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.baseTheme({\n    \"&.cm-focused .cm-matchingBracket\": {\n        backgroundColor: \"#328c8252\"\n    },\n    \"&.cm-focused .cm-nonmatchingBracket\": {\n        backgroundColor: \"#bb555544\"\n    }\n});\nconst DefaultScanDist = 10000, DefaultBrackets = \"()[]{}\";\nconst bracketMatchingConfig = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n    combine (configs) {\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.combineConfig)(configs, {\n            afterCursor: true,\n            brackets: DefaultBrackets,\n            maxScanDistance: DefaultScanDist,\n            renderMatch: defaultRenderMatch\n        });\n    }\n});\nconst matchingMark = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.mark({\n    class: \"cm-matchingBracket\"\n}), nonmatchingMark = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.mark({\n    class: \"cm-nonmatchingBracket\"\n});\nfunction defaultRenderMatch(match) {\n    let decorations = [];\n    let mark = match.matched ? matchingMark : nonmatchingMark;\n    decorations.push(mark.range(match.start.from, match.start.to));\n    if (match.end) decorations.push(mark.range(match.end.from, match.end.to));\n    return decorations;\n}\nconst bracketMatchingState = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateField.define({\n    create () {\n        return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.none;\n    },\n    update (deco, tr) {\n        if (!tr.docChanged && !tr.selection) return deco;\n        let decorations = [];\n        let config = tr.state.facet(bracketMatchingConfig);\n        for (let range of tr.state.selection.ranges){\n            if (!range.empty) continue;\n            let match = matchBrackets(tr.state, range.head, -1, config) || range.head > 0 && matchBrackets(tr.state, range.head - 1, 1, config) || config.afterCursor && (matchBrackets(tr.state, range.head, 1, config) || range.head < tr.state.doc.length && matchBrackets(tr.state, range.head + 1, -1, config));\n            if (match) decorations = decorations.concat(config.renderMatch(match, tr.state));\n        }\n        return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.set(decorations, true);\n    },\n    provide: (f)=>_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.decorations.from(f)\n});\nconst bracketMatchingUnique = [\n    bracketMatchingState,\n    baseTheme\n];\n/**\nCreate an extension that enables bracket matching. Whenever the\ncursor is next to a bracket, that bracket and the one it matches\nare highlighted. Or, when no matching bracket is found, another\nhighlighting style is used to indicate this.\n*/ function bracketMatching(config = {}) {\n    return [\n        bracketMatchingConfig.of(config),\n        bracketMatchingUnique\n    ];\n}\n/**\nWhen larger syntax nodes, such as HTML tags, are marked as\nopening/closing, it can be a bit messy to treat the whole node as\na matchable bracket. This node prop allows you to define, for such\na node, a ‘handle’—the part of the node that is highlighted, and\nthat the cursor must be on to activate highlighting in the first\nplace.\n*/ const bracketMatchingHandle = /*@__PURE__*/ new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp();\nfunction matchingNodes(node, dir, brackets) {\n    let byProp = node.prop(dir < 0 ? _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.openedBy : _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.closedBy);\n    if (byProp) return byProp;\n    if (node.name.length == 1) {\n        let index = brackets.indexOf(node.name);\n        if (index > -1 && index % 2 == (dir < 0 ? 1 : 0)) return [\n            brackets[index + dir]\n        ];\n    }\n    return null;\n}\nfunction findHandle(node) {\n    let hasHandle = node.type.prop(bracketMatchingHandle);\n    return hasHandle ? hasHandle(node.node) : node;\n}\n/**\nFind the matching bracket for the token at `pos`, scanning\ndirection `dir`. Only the `brackets` and `maxScanDistance`\nproperties are used from `config`, if given. Returns null if no\nbracket was found at `pos`, or a match result otherwise.\n*/ function matchBrackets(state, pos, dir, config = {}) {\n    let maxScanDistance = config.maxScanDistance || DefaultScanDist, brackets = config.brackets || DefaultBrackets;\n    let tree = syntaxTree(state), node = tree.resolveInner(pos, dir);\n    for(let cur = node; cur; cur = cur.parent){\n        let matches = matchingNodes(cur.type, dir, brackets);\n        if (matches && cur.from < cur.to) {\n            let handle = findHandle(cur);\n            if (handle && (dir > 0 ? pos >= handle.from && pos < handle.to : pos > handle.from && pos <= handle.to)) return matchMarkedBrackets(state, pos, dir, cur, handle, matches, brackets);\n        }\n    }\n    return matchPlainBrackets(state, pos, dir, tree, node.type, maxScanDistance, brackets);\n}\nfunction matchMarkedBrackets(_state, _pos, dir, token, handle, matching, brackets) {\n    let parent = token.parent, firstToken = {\n        from: handle.from,\n        to: handle.to\n    };\n    let depth = 0, cursor = parent === null || parent === void 0 ? void 0 : parent.cursor();\n    if (cursor && (dir < 0 ? cursor.childBefore(token.from) : cursor.childAfter(token.to))) do {\n        if (dir < 0 ? cursor.to <= token.from : cursor.from >= token.to) {\n            if (depth == 0 && matching.indexOf(cursor.type.name) > -1 && cursor.from < cursor.to) {\n                let endHandle = findHandle(cursor);\n                return {\n                    start: firstToken,\n                    end: endHandle ? {\n                        from: endHandle.from,\n                        to: endHandle.to\n                    } : undefined,\n                    matched: true\n                };\n            } else if (matchingNodes(cursor.type, dir, brackets)) {\n                depth++;\n            } else if (matchingNodes(cursor.type, -dir, brackets)) {\n                if (depth == 0) {\n                    let endHandle = findHandle(cursor);\n                    return {\n                        start: firstToken,\n                        end: endHandle && endHandle.from < endHandle.to ? {\n                            from: endHandle.from,\n                            to: endHandle.to\n                        } : undefined,\n                        matched: false\n                    };\n                }\n                depth--;\n            }\n        }\n    }while (dir < 0 ? cursor.prevSibling() : cursor.nextSibling());\n    return {\n        start: firstToken,\n        matched: false\n    };\n}\nfunction matchPlainBrackets(state, pos, dir, tree, tokenType, maxScanDistance, brackets) {\n    let startCh = dir < 0 ? state.sliceDoc(pos - 1, pos) : state.sliceDoc(pos, pos + 1);\n    let bracket = brackets.indexOf(startCh);\n    if (bracket < 0 || bracket % 2 == 0 != dir > 0) return null;\n    let startToken = {\n        from: dir < 0 ? pos - 1 : pos,\n        to: dir > 0 ? pos + 1 : pos\n    };\n    let iter = state.doc.iterRange(pos, dir > 0 ? state.doc.length : 0), depth = 0;\n    for(let distance = 0; !iter.next().done && distance <= maxScanDistance;){\n        let text = iter.value;\n        if (dir < 0) distance += text.length;\n        let basePos = pos + distance * dir;\n        for(let pos = dir > 0 ? 0 : text.length - 1, end = dir > 0 ? text.length : -1; pos != end; pos += dir){\n            let found = brackets.indexOf(text[pos]);\n            if (found < 0 || tree.resolveInner(basePos + pos, 1).type != tokenType) continue;\n            if (found % 2 == 0 == dir > 0) {\n                depth++;\n            } else if (depth == 1) {\n                return {\n                    start: startToken,\n                    end: {\n                        from: basePos + pos,\n                        to: basePos + pos + 1\n                    },\n                    matched: found >> 1 == bracket >> 1\n                };\n            } else {\n                depth--;\n            }\n        }\n        if (dir > 0) distance += text.length;\n    }\n    return iter.done ? {\n        start: startToken,\n        matched: false\n    } : null;\n}\n// Counts the column offset in a string, taking tabs into account.\n// Used mostly to find indentation.\nfunction countCol(string, end, tabSize, startIndex = 0, startValue = 0) {\n    if (end == null) {\n        end = string.search(/[^\\s\\u00a0]/);\n        if (end == -1) end = string.length;\n    }\n    let n = startValue;\n    for(let i = startIndex; i < end; i++){\n        if (string.charCodeAt(i) == 9) n += tabSize - n % tabSize;\n        else n++;\n    }\n    return n;\n}\n/**\nEncapsulates a single line of input. Given to stream syntax code,\nwhich uses it to tokenize the content.\n*/ class StringStream {\n    /**\n    Create a stream.\n    */ constructor(/**\n    The line.\n    */ string, tabSize, /**\n    The current indent unit size.\n    */ indentUnit, overrideIndent){\n        this.string = string;\n        this.tabSize = tabSize;\n        this.indentUnit = indentUnit;\n        this.overrideIndent = overrideIndent;\n        /**\n        The current position on the line.\n        */ this.pos = 0;\n        /**\n        The start position of the current token.\n        */ this.start = 0;\n        this.lastColumnPos = 0;\n        this.lastColumnValue = 0;\n    }\n    /**\n    True if we are at the end of the line.\n    */ eol() {\n        return this.pos >= this.string.length;\n    }\n    /**\n    True if we are at the start of the line.\n    */ sol() {\n        return this.pos == 0;\n    }\n    /**\n    Get the next code unit after the current position, or undefined\n    if we're at the end of the line.\n    */ peek() {\n        return this.string.charAt(this.pos) || undefined;\n    }\n    /**\n    Read the next code unit and advance `this.pos`.\n    */ next() {\n        if (this.pos < this.string.length) return this.string.charAt(this.pos++);\n    }\n    /**\n    Match the next character against the given string, regular\n    expression, or predicate. Consume and return it if it matches.\n    */ eat(match) {\n        let ch = this.string.charAt(this.pos);\n        let ok;\n        if (typeof match == \"string\") ok = ch == match;\n        else ok = ch && (match instanceof RegExp ? match.test(ch) : match(ch));\n        if (ok) {\n            ++this.pos;\n            return ch;\n        }\n    }\n    /**\n    Continue matching characters that match the given string,\n    regular expression, or predicate function. Return true if any\n    characters were consumed.\n    */ eatWhile(match) {\n        let start = this.pos;\n        while(this.eat(match)){}\n        return this.pos > start;\n    }\n    /**\n    Consume whitespace ahead of `this.pos`. Return true if any was\n    found.\n    */ eatSpace() {\n        let start = this.pos;\n        while(/[\\s\\u00a0]/.test(this.string.charAt(this.pos)))++this.pos;\n        return this.pos > start;\n    }\n    /**\n    Move to the end of the line.\n    */ skipToEnd() {\n        this.pos = this.string.length;\n    }\n    /**\n    Move to directly before the given character, if found on the\n    current line.\n    */ skipTo(ch) {\n        let found = this.string.indexOf(ch, this.pos);\n        if (found > -1) {\n            this.pos = found;\n            return true;\n        }\n    }\n    /**\n    Move back `n` characters.\n    */ backUp(n) {\n        this.pos -= n;\n    }\n    /**\n    Get the column position at `this.pos`.\n    */ column() {\n        if (this.lastColumnPos < this.start) {\n            this.lastColumnValue = countCol(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);\n            this.lastColumnPos = this.start;\n        }\n        return this.lastColumnValue;\n    }\n    /**\n    Get the indentation column of the current line.\n    */ indentation() {\n        var _a;\n        return (_a = this.overrideIndent) !== null && _a !== void 0 ? _a : countCol(this.string, null, this.tabSize);\n    }\n    /**\n    Match the input against the given string or regular expression\n    (which should start with a `^`). Return true or the regexp match\n    if it matches.\n    \n    Unless `consume` is set to `false`, this will move `this.pos`\n    past the matched text.\n    \n    When matching a string `caseInsensitive` can be set to true to\n    make the match case-insensitive.\n    */ match(pattern, consume, caseInsensitive) {\n        if (typeof pattern == \"string\") {\n            let cased = (str)=>caseInsensitive ? str.toLowerCase() : str;\n            let substr = this.string.substr(this.pos, pattern.length);\n            if (cased(substr) == cased(pattern)) {\n                if (consume !== false) this.pos += pattern.length;\n                return true;\n            } else return null;\n        } else {\n            let match = this.string.slice(this.pos).match(pattern);\n            if (match && match.index > 0) return null;\n            if (match && consume !== false) this.pos += match[0].length;\n            return match;\n        }\n    }\n    /**\n    Get the current token.\n    */ current() {\n        return this.string.slice(this.start, this.pos);\n    }\n}\nfunction fullParser(spec) {\n    return {\n        name: spec.name || \"\",\n        token: spec.token,\n        blankLine: spec.blankLine || (()=>{}),\n        startState: spec.startState || (()=>true),\n        copyState: spec.copyState || defaultCopyState,\n        indent: spec.indent || (()=>null),\n        languageData: spec.languageData || {},\n        tokenTable: spec.tokenTable || noTokens\n    };\n}\nfunction defaultCopyState(state) {\n    if (typeof state != \"object\") return state;\n    let newState = {};\n    for(let prop in state){\n        let val = state[prop];\n        newState[prop] = val instanceof Array ? val.slice() : val;\n    }\n    return newState;\n}\nconst IndentedFrom = /*@__PURE__*/ new WeakMap();\n/**\nA [language](https://codemirror.net/6/docs/ref/#language.Language) class based on a CodeMirror\n5-style [streaming parser](https://codemirror.net/6/docs/ref/#language.StreamParser).\n*/ class StreamLanguage extends Language {\n    constructor(parser){\n        let data = defineLanguageFacet(parser.languageData);\n        let p = fullParser(parser), self;\n        let impl = new class extends _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Parser {\n            createParse(input, fragments, ranges) {\n                return new Parse(self, input, fragments, ranges);\n            }\n        };\n        super(data, impl, [\n            indentService.of((cx, pos)=>this.getIndent(cx, pos))\n        ], parser.name);\n        this.topNode = docID(data);\n        self = this;\n        this.streamParser = p;\n        this.stateAfter = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp({\n            perNode: true\n        });\n        this.tokenTable = parser.tokenTable ? new TokenTable(p.tokenTable) : defaultTokenTable;\n    }\n    /**\n    Define a stream language.\n    */ static define(spec) {\n        return new StreamLanguage(spec);\n    }\n    getIndent(cx, pos) {\n        let tree = syntaxTree(cx.state), at = tree.resolve(pos);\n        while(at && at.type != this.topNode)at = at.parent;\n        if (!at) return null;\n        let from = undefined;\n        let { overrideIndentation } = cx.options;\n        if (overrideIndentation) {\n            from = IndentedFrom.get(cx.state);\n            if (from != null && from < pos - 1e4) from = undefined;\n        }\n        let start = findState(this, tree, 0, at.from, from !== null && from !== void 0 ? from : pos), statePos, state;\n        if (start) {\n            state = start.state;\n            statePos = start.pos + 1;\n        } else {\n            state = this.streamParser.startState(cx.unit);\n            statePos = 0;\n        }\n        if (pos - statePos > 10000 /* C.MaxIndentScanDist */ ) return null;\n        while(statePos < pos){\n            let line = cx.state.doc.lineAt(statePos), end = Math.min(pos, line.to);\n            if (line.length) {\n                let indentation = overrideIndentation ? overrideIndentation(line.from) : -1;\n                let stream = new StringStream(line.text, cx.state.tabSize, cx.unit, indentation < 0 ? undefined : indentation);\n                while(stream.pos < end - line.from)readToken(this.streamParser.token, stream, state);\n            } else {\n                this.streamParser.blankLine(state, cx.unit);\n            }\n            if (end == pos) break;\n            statePos = line.to + 1;\n        }\n        let line = cx.lineAt(pos);\n        if (overrideIndentation && from == null) IndentedFrom.set(cx.state, line.from);\n        return this.streamParser.indent(state, /^\\s*(.*)/.exec(line.text)[1], cx);\n    }\n    get allowsNesting() {\n        return false;\n    }\n}\nfunction findState(lang, tree, off, startPos, before) {\n    let state = off >= startPos && off + tree.length <= before && tree.prop(lang.stateAfter);\n    if (state) return {\n        state: lang.streamParser.copyState(state),\n        pos: off + tree.length\n    };\n    for(let i = tree.children.length - 1; i >= 0; i--){\n        let child = tree.children[i], pos = off + tree.positions[i];\n        let found = child instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree && pos < before && findState(lang, child, pos, startPos, before);\n        if (found) return found;\n    }\n    return null;\n}\nfunction cutTree(lang, tree, from, to, inside) {\n    if (inside && from <= 0 && to >= tree.length) return tree;\n    if (!inside && tree.type == lang.topNode) inside = true;\n    for(let i = tree.children.length - 1; i >= 0; i--){\n        let pos = tree.positions[i], child = tree.children[i], inner;\n        if (pos < to && child instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree) {\n            if (!(inner = cutTree(lang, child, from - pos, to - pos, inside))) break;\n            return !inside ? inner : new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree(tree.type, tree.children.slice(0, i).concat(inner), tree.positions.slice(0, i + 1), pos + inner.length);\n        }\n    }\n    return null;\n}\nfunction findStartInFragments(lang, fragments, startPos, editorState) {\n    for (let f of fragments){\n        let from = f.from + (f.openStart ? 25 : 0), to = f.to - (f.openEnd ? 25 : 0);\n        let found = from <= startPos && to > startPos && findState(lang, f.tree, 0 - f.offset, startPos, to), tree;\n        if (found && (tree = cutTree(lang, f.tree, startPos + f.offset, found.pos + f.offset, false))) return {\n            state: found.state,\n            tree\n        };\n    }\n    return {\n        state: lang.streamParser.startState(editorState ? getIndentUnit(editorState) : 4),\n        tree: _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.empty\n    };\n}\nclass Parse {\n    constructor(lang, input, fragments, ranges){\n        this.lang = lang;\n        this.input = input;\n        this.fragments = fragments;\n        this.ranges = ranges;\n        this.stoppedAt = null;\n        this.chunks = [];\n        this.chunkPos = [];\n        this.chunk = [];\n        this.chunkReused = undefined;\n        this.rangeIndex = 0;\n        this.to = ranges[ranges.length - 1].to;\n        let context = ParseContext.get(), from = ranges[0].from;\n        let { state, tree } = findStartInFragments(lang, fragments, from, context === null || context === void 0 ? void 0 : context.state);\n        this.state = state;\n        this.parsedPos = this.chunkStart = from + tree.length;\n        for(let i = 0; i < tree.children.length; i++){\n            this.chunks.push(tree.children[i]);\n            this.chunkPos.push(tree.positions[i]);\n        }\n        if (context && this.parsedPos < context.viewport.from - 100000 /* C.MaxDistanceBeforeViewport */ ) {\n            this.state = this.lang.streamParser.startState(getIndentUnit(context.state));\n            context.skipUntilInView(this.parsedPos, context.viewport.from);\n            this.parsedPos = context.viewport.from;\n        }\n        this.moveRangeIndex();\n    }\n    advance() {\n        let context = ParseContext.get();\n        let parseEnd = this.stoppedAt == null ? this.to : Math.min(this.to, this.stoppedAt);\n        let end = Math.min(parseEnd, this.chunkStart + 2048 /* C.ChunkSize */ );\n        if (context) end = Math.min(end, context.viewport.to);\n        while(this.parsedPos < end)this.parseLine(context);\n        if (this.chunkStart < this.parsedPos) this.finishChunk();\n        if (this.parsedPos >= parseEnd) return this.finish();\n        if (context && this.parsedPos >= context.viewport.to) {\n            context.skipUntilInView(this.parsedPos, parseEnd);\n            return this.finish();\n        }\n        return null;\n    }\n    stopAt(pos) {\n        this.stoppedAt = pos;\n    }\n    lineAfter(pos) {\n        let chunk = this.input.chunk(pos);\n        if (!this.input.lineChunks) {\n            let eol = chunk.indexOf(\"\\n\");\n            if (eol > -1) chunk = chunk.slice(0, eol);\n        } else if (chunk == \"\\n\") {\n            chunk = \"\";\n        }\n        return pos + chunk.length <= this.to ? chunk : chunk.slice(0, this.to - pos);\n    }\n    nextLine() {\n        let from = this.parsedPos, line = this.lineAfter(from), end = from + line.length;\n        for(let index = this.rangeIndex;;){\n            let rangeEnd = this.ranges[index].to;\n            if (rangeEnd >= end) break;\n            line = line.slice(0, rangeEnd - (end - line.length));\n            index++;\n            if (index == this.ranges.length) break;\n            let rangeStart = this.ranges[index].from;\n            let after = this.lineAfter(rangeStart);\n            line += after;\n            end = rangeStart + after.length;\n        }\n        return {\n            line,\n            end\n        };\n    }\n    skipGapsTo(pos, offset, side) {\n        for(;;){\n            let end = this.ranges[this.rangeIndex].to, offPos = pos + offset;\n            if (side > 0 ? end > offPos : end >= offPos) break;\n            let start = this.ranges[++this.rangeIndex].from;\n            offset += start - end;\n        }\n        return offset;\n    }\n    moveRangeIndex() {\n        while(this.ranges[this.rangeIndex].to < this.parsedPos)this.rangeIndex++;\n    }\n    emitToken(id, from, to, size, offset) {\n        if (this.ranges.length > 1) {\n            offset = this.skipGapsTo(from, offset, 1);\n            from += offset;\n            let len0 = this.chunk.length;\n            offset = this.skipGapsTo(to, offset, -1);\n            to += offset;\n            size += this.chunk.length - len0;\n        }\n        this.chunk.push(id, from, to, size);\n        return offset;\n    }\n    parseLine(context) {\n        let { line, end } = this.nextLine(), offset = 0, { streamParser } = this.lang;\n        let stream = new StringStream(line, context ? context.state.tabSize : 4, context ? getIndentUnit(context.state) : 2);\n        if (stream.eol()) {\n            streamParser.blankLine(this.state, stream.indentUnit);\n        } else {\n            while(!stream.eol()){\n                let token = readToken(streamParser.token, stream, this.state);\n                if (token) offset = this.emitToken(this.lang.tokenTable.resolve(token), this.parsedPos + stream.start, this.parsedPos + stream.pos, 4, offset);\n                if (stream.start > 10000 /* C.MaxLineLength */ ) break;\n            }\n        }\n        this.parsedPos = end;\n        this.moveRangeIndex();\n        if (this.parsedPos < this.to) this.parsedPos++;\n    }\n    finishChunk() {\n        let tree = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.build({\n            buffer: this.chunk,\n            start: this.chunkStart,\n            length: this.parsedPos - this.chunkStart,\n            nodeSet,\n            topID: 0,\n            maxBufferLength: 2048 /* C.ChunkSize */ ,\n            reused: this.chunkReused\n        });\n        tree = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree(tree.type, tree.children, tree.positions, tree.length, [\n            [\n                this.lang.stateAfter,\n                this.lang.streamParser.copyState(this.state)\n            ]\n        ]);\n        this.chunks.push(tree);\n        this.chunkPos.push(this.chunkStart - this.ranges[0].from);\n        this.chunk = [];\n        this.chunkReused = undefined;\n        this.chunkStart = this.parsedPos;\n    }\n    finish() {\n        return new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree(this.lang.topNode, this.chunks, this.chunkPos, this.parsedPos - this.ranges[0].from).balance();\n    }\n}\nfunction readToken(token, stream, state) {\n    stream.start = stream.pos;\n    for(let i = 0; i < 10; i++){\n        let result = token(stream, state);\n        if (stream.pos > stream.start) return result;\n    }\n    throw new Error(\"Stream parser failed to advance stream.\");\n}\nconst noTokens = /*@__PURE__*/ Object.create(null);\nconst typeArray = [\n    _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeType.none\n];\nconst nodeSet = /*@__PURE__*/ new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeSet(typeArray);\nconst warned = [];\n// Cache of node types by name and tags\nconst byTag = /*@__PURE__*/ Object.create(null);\nconst defaultTable = /*@__PURE__*/ Object.create(null);\nfor (let [legacyName, name] of [\n    [\n        \"variable\",\n        \"variableName\"\n    ],\n    [\n        \"variable-2\",\n        \"variableName.special\"\n    ],\n    [\n        \"string-2\",\n        \"string.special\"\n    ],\n    [\n        \"def\",\n        \"variableName.definition\"\n    ],\n    [\n        \"tag\",\n        \"tagName\"\n    ],\n    [\n        \"attribute\",\n        \"attributeName\"\n    ],\n    [\n        \"type\",\n        \"typeName\"\n    ],\n    [\n        \"builtin\",\n        \"variableName.standard\"\n    ],\n    [\n        \"qualifier\",\n        \"modifier\"\n    ],\n    [\n        \"error\",\n        \"invalid\"\n    ],\n    [\n        \"header\",\n        \"heading\"\n    ],\n    [\n        \"property\",\n        \"propertyName\"\n    ]\n])defaultTable[legacyName] = /*@__PURE__*/ createTokenType(noTokens, name);\nclass TokenTable {\n    constructor(extra){\n        this.extra = extra;\n        this.table = Object.assign(Object.create(null), defaultTable);\n    }\n    resolve(tag) {\n        return !tag ? 0 : this.table[tag] || (this.table[tag] = createTokenType(this.extra, tag));\n    }\n}\nconst defaultTokenTable = /*@__PURE__*/ new TokenTable(noTokens);\nfunction warnForPart(part, msg) {\n    if (warned.indexOf(part) > -1) return;\n    warned.push(part);\n    console.warn(msg);\n}\nfunction createTokenType(extra, tagStr) {\n    let tags$1 = [];\n    for (let name of tagStr.split(\" \")){\n        let found = [];\n        for (let part of name.split(\".\")){\n            let value = extra[part] || _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags[part];\n            if (!value) {\n                warnForPart(part, `Unknown highlighting tag ${part}`);\n            } else if (typeof value == \"function\") {\n                if (!found.length) warnForPart(part, `Modifier ${part} used at start of tag`);\n                else found = found.map(value);\n            } else {\n                if (found.length) warnForPart(part, `Tag ${part} used as modifier`);\n                else found = Array.isArray(value) ? value : [\n                    value\n                ];\n            }\n        }\n        for (let tag of found)tags$1.push(tag);\n    }\n    if (!tags$1.length) return 0;\n    let name = tagStr.replace(/ /g, \"_\"), key = name + \" \" + tags$1.map((t)=>t.id);\n    let known = byTag[key];\n    if (known) return known.id;\n    let type = byTag[key] = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeType.define({\n        id: typeArray.length,\n        name,\n        props: [\n            (0,_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.styleTags)({\n                [name]: tags$1\n            })\n        ]\n    });\n    typeArray.push(type);\n    return type.id;\n}\nfunction docID(data) {\n    let type = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeType.define({\n        id: typeArray.length,\n        name: \"Document\",\n        props: [\n            languageDataProp.add(()=>data)\n        ],\n        top: true\n    });\n    typeArray.push(type);\n    return type;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGFuZ3VhZ2UvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWtHO0FBQzJDO0FBQ3ZCO0FBQ3BDO0FBQzFDO0FBRXhDLElBQUk0QjtBQUNKOzs7QUFHQSxHQUNBLE1BQU1DLG1CQUFtQixXQUFXLEdBQUUsSUFBSTdCLG1EQUFRQTtBQUNsRDs7Ozs7OztBQU9BLEdBQ0EsU0FBUzhCLG9CQUFvQkMsUUFBUTtJQUNqQyxPQUFPdEIsb0RBQUtBLENBQUN1QixNQUFNLENBQUM7UUFDaEJDLFNBQVNGLFdBQVdHLENBQUFBLFNBQVVBLE9BQU9DLE1BQU0sQ0FBQ0osWUFBWUs7SUFDNUQ7QUFDSjtBQUNBOzs7QUFHQSxHQUNBLE1BQU1DLGtCQUFrQixXQUFXLEdBQUUsSUFBSXJDLG1EQUFRQTtBQUNqRDs7Ozs7Ozs7QUFRQSxHQUNBLE1BQU1zQztJQUNGOzs7Ozs7SUFNQSxHQUNBQyxZQUNBOzs7SUFHQSxHQUNBQyxJQUFJLEVBQUVDLE1BQU0sRUFBRUMsa0JBQWtCLEVBQUUsRUFDbEM7O0lBRUEsR0FDQUMsT0FBTyxFQUFFLENBQUU7UUFDUCxJQUFJLENBQUNILElBQUksR0FBR0E7UUFDWixJQUFJLENBQUNHLElBQUksR0FBR0E7UUFDWiwyREFBMkQ7UUFDM0QseURBQXlEO1FBQ3pELDZCQUE2QjtRQUM3QixJQUFJLENBQUNqQywwREFBV0EsQ0FBQ2tDLFNBQVMsQ0FBQ0MsY0FBYyxDQUFDLFNBQ3RDQyxPQUFPQyxjQUFjLENBQUNyQywwREFBV0EsQ0FBQ2tDLFNBQVMsRUFBRSxRQUFRO1lBQUVJO2dCQUFRLE9BQU9DLFdBQVcsSUFBSTtZQUFHO1FBQUU7UUFDOUYsSUFBSSxDQUFDUixNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDUyxTQUFTLEdBQUc7WUFDYkMsU0FBU0MsRUFBRSxDQUFDLElBQUk7WUFDaEIxQywwREFBV0EsQ0FBQzJDLFlBQVksQ0FBQ0QsRUFBRSxDQUFDLENBQUNFLE9BQU9DLEtBQUtDO2dCQUNyQyxJQUFJQyxNQUFNQyxVQUFVSixPQUFPQyxLQUFLQyxPQUFPaEIsT0FBT2lCLElBQUlFLElBQUksQ0FBQ0MsSUFBSSxDQUFDL0I7Z0JBQzVELElBQUksQ0FBQ1csTUFDRCxPQUFPLEVBQUU7Z0JBQ2IsSUFBSXFCLE9BQU9QLE1BQU1RLEtBQUssQ0FBQ3RCLE9BQU91QixNQUFNTixJQUFJRSxJQUFJLENBQUNDLElBQUksQ0FBQ3ZCO2dCQUNsRCxJQUFJMEIsS0FBSztvQkFDTCxJQUFJQyxZQUFZUCxJQUFJUSxPQUFPLENBQUNWLE1BQU1FLElBQUlTLElBQUksRUFBRVY7b0JBQzVDLEtBQUssSUFBSVcsV0FBV0osSUFDaEIsSUFBSUksUUFBUUMsSUFBSSxDQUFDSixXQUFXVixRQUFRO3dCQUNoQyxJQUFJZCxPQUFPYyxNQUFNUSxLQUFLLENBQUNLLFFBQVFMLEtBQUs7d0JBQ3BDLE9BQU9LLFFBQVFSLElBQUksSUFBSSxZQUFZbkIsT0FBT0EsS0FBS0wsTUFBTSxDQUFDMEI7b0JBQzFEO2dCQUNSO2dCQUNBLE9BQU9BO1lBQ1g7U0FDSCxDQUFDMUIsTUFBTSxDQUFDTztJQUNiO0lBQ0E7O0lBRUEsR0FDQTJCLFdBQVdmLEtBQUssRUFBRUMsR0FBRyxFQUFFQyxPQUFPLENBQUMsQ0FBQyxFQUFFO1FBQzlCLE9BQU9FLFVBQVVKLE9BQU9DLEtBQUtDLE1BQU1HLElBQUksQ0FBQ0MsSUFBSSxDQUFDL0IscUJBQXFCLElBQUksQ0FBQ1csSUFBSTtJQUMvRTtJQUNBOzs7O0lBSUEsR0FDQThCLFlBQVloQixLQUFLLEVBQUU7UUFDZixJQUFJaUIsT0FBT2pCLE1BQU1RLEtBQUssQ0FBQ1g7UUFDdkIsSUFBSSxDQUFDb0IsU0FBUyxRQUFRQSxTQUFTLEtBQUssSUFBSSxLQUFLLElBQUlBLEtBQUsvQixJQUFJLEtBQUssSUFBSSxDQUFDQSxJQUFJLEVBQ3BFLE9BQU87WUFBQztnQkFBRTBCLE1BQU07Z0JBQUdNLElBQUlsQixNQUFNbUIsR0FBRyxDQUFDQyxNQUFNO1lBQUM7U0FBRTtRQUM5QyxJQUFJLENBQUNILFFBQVEsQ0FBQ0EsS0FBS0ksYUFBYSxFQUM1QixPQUFPLEVBQUU7UUFDYixJQUFJQyxTQUFTLEVBQUU7UUFDZixJQUFJQyxVQUFVLENBQUNDLE1BQU1aO1lBQ2pCLElBQUlZLEtBQUtsQixJQUFJLENBQUMvQixxQkFBcUIsSUFBSSxDQUFDVyxJQUFJLEVBQUU7Z0JBQzFDb0MsT0FBT0csSUFBSSxDQUFDO29CQUFFYjtvQkFBTU0sSUFBSU4sT0FBT1ksS0FBS0osTUFBTTtnQkFBQztnQkFDM0M7WUFDSjtZQUNBLElBQUlNLFFBQVFGLEtBQUtsQixJQUFJLENBQUM1RCxtREFBUUEsQ0FBQ2lGLE9BQU87WUFDdEMsSUFBSUQsT0FBTztnQkFDUCxJQUFJQSxNQUFNRixJQUFJLENBQUNsQixJQUFJLENBQUMvQixxQkFBcUIsSUFBSSxDQUFDVyxJQUFJLEVBQUU7b0JBQ2hELElBQUl3QyxNQUFNRSxPQUFPLEVBQ2IsS0FBSyxJQUFJQyxLQUFLSCxNQUFNRSxPQUFPLENBQ3ZCTixPQUFPRyxJQUFJLENBQUM7d0JBQUViLE1BQU1pQixFQUFFakIsSUFBSSxHQUFHQTt3QkFBTU0sSUFBSVcsRUFBRVgsRUFBRSxHQUFHTjtvQkFBSzt5QkFFdkRVLE9BQU9HLElBQUksQ0FBQzt3QkFBRWIsTUFBTUE7d0JBQU1NLElBQUlOLE9BQU9ZLEtBQUtKLE1BQU07b0JBQUM7b0JBQ3JEO2dCQUNKLE9BQ0ssSUFBSU0sTUFBTUUsT0FBTyxFQUFFO29CQUNwQixJQUFJRSxPQUFPUixPQUFPRixNQUFNO29CQUN4QkcsUUFBUUcsTUFBTUYsSUFBSSxFQUFFRSxNQUFNRSxPQUFPLENBQUMsRUFBRSxDQUFDaEIsSUFBSSxHQUFHQTtvQkFDNUMsSUFBSVUsT0FBT0YsTUFBTSxHQUFHVSxNQUNoQjtnQkFDUjtZQUNKO1lBQ0EsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlQLEtBQUtRLFFBQVEsQ0FBQ1osTUFBTSxFQUFFVyxJQUFLO2dCQUMzQyxJQUFJRSxLQUFLVCxLQUFLUSxRQUFRLENBQUNELEVBQUU7Z0JBQ3pCLElBQUlFLGNBQWNyRiwrQ0FBSUEsRUFDbEIyRSxRQUFRVSxJQUFJVCxLQUFLVSxTQUFTLENBQUNILEVBQUUsR0FBR25CO1lBQ3hDO1FBQ0o7UUFDQVcsUUFBUTVCLFdBQVdLLFFBQVE7UUFDM0IsT0FBT3NCO0lBQ1g7SUFDQTs7O0lBR0EsR0FDQSxJQUFJRCxnQkFBZ0I7UUFBRSxPQUFPO0lBQU07QUFDdkM7QUFDQTs7QUFFQSxHQUNBckMsU0FBU21ELFFBQVEsR0FBRyxXQUFXLEdBQUVsRiwwREFBV0EsQ0FBQ3lCLE1BQU07QUFDbkQsU0FBUzBCLFVBQVVKLEtBQUssRUFBRUMsR0FBRyxFQUFFQyxJQUFJO0lBQy9CLElBQUlrQyxVQUFVcEMsTUFBTVEsS0FBSyxDQUFDWCxXQUFXMkIsT0FBTzdCLFdBQVdLLE9BQU9xQyxPQUFPO0lBQ3JFLElBQUksQ0FBQ0QsV0FBV0EsUUFBUWYsYUFBYSxFQUFFO1FBQ25DLElBQUssSUFBSWlCLE9BQU9kLE1BQU1jLE1BQU1BLE9BQU9BLEtBQUtDLEtBQUssQ0FBQ3RDLEtBQUtDLE1BQU12RCxtREFBUUEsQ0FBQzZGLGNBQWMsRUFDNUUsSUFBSUYsS0FBS2pDLElBQUksQ0FBQ29DLEtBQUssRUFDZmpCLE9BQU9jO0lBQ25CO0lBQ0EsT0FBT2Q7QUFDWDtBQUNBOzs7O0FBSUEsR0FDQSxNQUFNa0IsbUJBQW1CMUQ7SUFDckJDLFlBQVlDLElBQUksRUFBRUMsTUFBTSxFQUFFRSxJQUFJLENBQUU7UUFDNUIsS0FBSyxDQUFDSCxNQUFNQyxRQUFRLEVBQUUsRUFBRUU7UUFDeEIsSUFBSSxDQUFDRixNQUFNLEdBQUdBO0lBQ2xCO0lBQ0E7O0lBRUEsR0FDQSxPQUFPVCxPQUFPaUUsSUFBSSxFQUFFO1FBQ2hCLElBQUl6RCxPQUFPVixvQkFBb0JtRSxLQUFLNUMsWUFBWTtRQUNoRCxPQUFPLElBQUkyQyxXQUFXeEQsTUFBTXlELEtBQUt4RCxNQUFNLENBQUN5RCxTQUFTLENBQUM7WUFDOUNDLE9BQU87Z0JBQUN0RSxpQkFBaUJ1RSxHQUFHLENBQUN6QyxDQUFBQSxPQUFRQSxLQUFLb0MsS0FBSyxHQUFHdkQsT0FBT0o7YUFBVztRQUN4RSxJQUFJNkQsS0FBS3RELElBQUk7SUFDakI7SUFDQTs7O0lBR0EsR0FDQXVELFVBQVVHLE9BQU8sRUFBRTFELElBQUksRUFBRTtRQUNyQixPQUFPLElBQUlxRCxXQUFXLElBQUksQ0FBQ3hELElBQUksRUFBRSxJQUFJLENBQUNDLE1BQU0sQ0FBQ3lELFNBQVMsQ0FBQ0csVUFBVTFELFFBQVEsSUFBSSxDQUFDQSxJQUFJO0lBQ3RGO0lBQ0EsSUFBSWdDLGdCQUFnQjtRQUFFLE9BQU8sSUFBSSxDQUFDbEMsTUFBTSxDQUFDNkQsV0FBVztJQUFJO0FBQzVEO0FBQ0E7Ozs7O0FBS0EsR0FDQSxTQUFTckQsV0FBV0ssS0FBSztJQUNyQixJQUFJaUQsUUFBUWpELE1BQU1pRCxLQUFLLENBQUNqRSxTQUFTZ0IsS0FBSyxFQUFFO0lBQ3hDLE9BQU9pRCxRQUFRQSxNQUFNekIsSUFBSSxHQUFHNUUsK0NBQUlBLENBQUNzRyxLQUFLO0FBQzFDO0FBQ0E7Ozs7QUFJQSxHQUNBLFNBQVNDLGlCQUFpQm5ELEtBQUssRUFBRW9ELElBQUksRUFBRUMsVUFBVSxFQUFFO0lBQy9DLElBQUkvRTtJQUNKLElBQUlnRixRQUFRLENBQUNoRixLQUFLMEIsTUFBTWlELEtBQUssQ0FBQ2pFLFNBQVNnQixLQUFLLEVBQUUsTUFBSyxNQUFPLFFBQVExQixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdpRixPQUFPO0lBQ3JHLElBQUksQ0FBQ0QsT0FDRCxPQUFPO0lBQ1gsSUFBSUUsYUFBYUYsTUFBTUcsUUFBUTtJQUMvQkgsTUFBTUksY0FBYyxDQUFDO1FBQUU5QyxNQUFNO1FBQUdNLElBQUlrQztJQUFLO0lBQ3pDLElBQUk5QixTQUFTZ0MsTUFBTUssTUFBTSxDQUFDUCxTQUFTRSxNQUFNTSxJQUFJLENBQUNQLFNBQVNELFFBQVFFLE1BQU05QixJQUFJLEdBQUc7SUFDNUU4QixNQUFNSSxjQUFjLENBQUNGO0lBQ3JCLE9BQU9sQztBQUNYO0FBQ0E7Ozs7Ozs7O0FBUUEsR0FDQSxTQUFTdUMsb0JBQW9CN0QsS0FBSyxFQUFFb0QsT0FBT3BELE1BQU1tQixHQUFHLENBQUNDLE1BQU07SUFDdkQsSUFBSTlDO0lBQ0osT0FBTyxDQUFDLENBQUNBLEtBQUswQixNQUFNaUQsS0FBSyxDQUFDakUsU0FBU2dCLEtBQUssRUFBRSxNQUFLLE1BQU8sUUFBUTFCLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2lGLE9BQU8sQ0FBQ0ksTUFBTSxDQUFDUCxLQUFJLEtBQU07QUFDdkg7QUFDQTs7Ozs7QUFLQSxHQUNBLFNBQVNVLGFBQWFDLElBQUksRUFBRVgsT0FBT1csS0FBS04sUUFBUSxDQUFDdkMsRUFBRSxFQUFFbUMsVUFBVSxHQUFHO0lBQzlELElBQUlXLFVBQVViLGlCQUFpQlksS0FBSy9ELEtBQUssRUFBRW9ELE1BQU1DO0lBQ2pELElBQUlXLFdBQVdyRSxXQUFXb0UsS0FBSy9ELEtBQUssR0FDaEMrRCxLQUFLRSxRQUFRLENBQUMsQ0FBQztJQUNuQixPQUFPLENBQUMsQ0FBQ0Q7QUFDYjtBQUNBOzs7Ozs7QUFNQSxHQUNBLFNBQVNFLG9CQUFvQkgsSUFBSTtJQUM3QixJQUFJekY7SUFDSixPQUFPLENBQUMsQ0FBQ0EsS0FBS3lGLEtBQUtJLE1BQU0sQ0FBQ0MsWUFBVyxNQUFPLFFBQVE5RixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUcrRixTQUFTLEVBQUMsS0FBTTtBQUNwRztBQUNBOzs7O0FBSUEsR0FDQSxNQUFNQztJQUNGOztJQUVBLEdBQ0FyRixZQUFZa0MsR0FBRyxDQUFFO1FBQ2IsSUFBSSxDQUFDQSxHQUFHLEdBQUdBO1FBQ1gsSUFBSSxDQUFDb0QsU0FBUyxHQUFHO1FBQ2pCLElBQUksQ0FBQ0MsTUFBTSxHQUFHO1FBQ2QsSUFBSSxDQUFDQyxNQUFNLEdBQUd0RCxJQUFJdUQsSUFBSTtJQUMxQjtJQUNBLElBQUl0RCxTQUFTO1FBQUUsT0FBTyxJQUFJLENBQUNELEdBQUcsQ0FBQ0MsTUFBTTtJQUFFO0lBQ3ZDdUQsT0FBTzFFLEdBQUcsRUFBRTtRQUNSLElBQUksQ0FBQ3VFLE1BQU0sR0FBRyxJQUFJLENBQUNDLE1BQU0sQ0FBQ0csSUFBSSxDQUFDM0UsTUFBTSxJQUFJLENBQUNzRSxTQUFTLEVBQUVNLEtBQUs7UUFDMUQsSUFBSSxDQUFDTixTQUFTLEdBQUd0RSxNQUFNLElBQUksQ0FBQ3VFLE1BQU0sQ0FBQ3BELE1BQU07UUFDekMsT0FBTyxJQUFJLENBQUNtRCxTQUFTLEdBQUcsSUFBSSxDQUFDQyxNQUFNLENBQUNwRCxNQUFNO0lBQzlDO0lBQ0EwRCxNQUFNN0UsR0FBRyxFQUFFO1FBQ1AsSUFBSSxDQUFDMEUsTUFBTSxDQUFDMUU7UUFDWixPQUFPLElBQUksQ0FBQ3VFLE1BQU07SUFDdEI7SUFDQSxJQUFJTyxhQUFhO1FBQUUsT0FBTztJQUFNO0lBQ2hDQyxLQUFLcEUsSUFBSSxFQUFFTSxFQUFFLEVBQUU7UUFDWCxJQUFJK0QsY0FBYyxJQUFJLENBQUNWLFNBQVMsR0FBRyxJQUFJLENBQUNDLE1BQU0sQ0FBQ3BELE1BQU07UUFDckQsSUFBSVIsT0FBT3FFLGVBQWUvRCxNQUFNLElBQUksQ0FBQ3FELFNBQVMsRUFDMUMsT0FBTyxJQUFJLENBQUNwRCxHQUFHLENBQUMrRCxXQUFXLENBQUN0RSxNQUFNTTthQUVsQyxPQUFPLElBQUksQ0FBQ3NELE1BQU0sQ0FBQ1csS0FBSyxDQUFDdkUsT0FBT3FFLGFBQWEvRCxLQUFLK0Q7SUFDMUQ7QUFDSjtBQUNBLElBQUlHLGlCQUFpQjtBQUNyQjs7QUFFQSxHQUNBLE1BQU1DO0lBQ0ZwRyxZQUFZRSxNQUFNLEVBQ2xCOztJQUVBLEdBQ0FhLEtBQUssRUFDTDs7SUFFQSxHQUNBc0YsWUFBWSxFQUFFLEVBQ2Q7O0lBRUEsR0FDQTlELElBQUksRUFDSjs7SUFFQSxHQUNBK0QsT0FBTyxFQUNQOzs7Ozs7O0lBT0EsR0FDQTlCLFFBQVEsRUFDUjs7SUFFQSxHQUNBK0IsT0FBTyxFQUNQOzs7O0lBSUEsR0FDQUMsVUFBVSxDQUFFO1FBQ1IsSUFBSSxDQUFDdEcsTUFBTSxHQUFHQTtRQUNkLElBQUksQ0FBQ2EsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQ3NGLFNBQVMsR0FBR0E7UUFDakIsSUFBSSxDQUFDOUQsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQytELE9BQU8sR0FBR0E7UUFDZixJQUFJLENBQUM5QixRQUFRLEdBQUdBO1FBQ2hCLElBQUksQ0FBQytCLE9BQU8sR0FBR0E7UUFDZixJQUFJLENBQUNDLFVBQVUsR0FBR0E7UUFDbEIsSUFBSSxDQUFDbkMsS0FBSyxHQUFHO1FBQ2I7O1FBRUEsR0FDQSxJQUFJLENBQUNvQyxXQUFXLEdBQUcsRUFBRTtJQUN6QjtJQUNBOztJQUVBLEdBQ0EsT0FBT0MsT0FBT3hHLE1BQU0sRUFBRWEsS0FBSyxFQUFFeUQsUUFBUSxFQUFFO1FBQ25DLE9BQU8sSUFBSTRCLGFBQWFsRyxRQUFRYSxPQUFPLEVBQUUsRUFBRXBELCtDQUFJQSxDQUFDc0csS0FBSyxFQUFFLEdBQUdPLFVBQVUsRUFBRSxFQUFFO0lBQzVFO0lBQ0FtQyxhQUFhO1FBQ1QsT0FBTyxJQUFJLENBQUN6RyxNQUFNLENBQUN5RyxVQUFVLENBQUMsSUFBSXRCLFNBQVMsSUFBSSxDQUFDdEUsS0FBSyxDQUFDbUIsR0FBRyxHQUFHLElBQUksQ0FBQ21FLFNBQVM7SUFDOUU7SUFDQTs7SUFFQSxHQUNBMUIsS0FBS2lDLEtBQUssRUFBRXpDLElBQUksRUFBRTtRQUNkLElBQUlBLFFBQVEsUUFBUUEsUUFBUSxJQUFJLENBQUNwRCxLQUFLLENBQUNtQixHQUFHLENBQUNDLE1BQU0sRUFDN0NnQyxPQUFPdEU7UUFDWCxJQUFJLElBQUksQ0FBQzBDLElBQUksSUFBSTVFLCtDQUFJQSxDQUFDc0csS0FBSyxJQUFJLElBQUksQ0FBQ1MsTUFBTSxDQUFDUCxTQUFTLFFBQVFBLFNBQVMsS0FBSyxJQUFJQSxPQUFPLElBQUksQ0FBQ3BELEtBQUssQ0FBQ21CLEdBQUcsQ0FBQ0MsTUFBTSxHQUFHO1lBQ3pHLElBQUksQ0FBQzBFLFFBQVE7WUFDYixPQUFPO1FBQ1g7UUFDQSxPQUFPLElBQUksQ0FBQ0MsV0FBVyxDQUFDO1lBQ3BCLElBQUl6SDtZQUNKLElBQUksT0FBT3VILFNBQVMsVUFBVTtnQkFDMUIsSUFBSUcsVUFBVUMsS0FBS0MsR0FBRyxLQUFLTDtnQkFDM0JBLFFBQVEsSUFBTUksS0FBS0MsR0FBRyxLQUFLRjtZQUMvQjtZQUNBLElBQUksQ0FBQyxJQUFJLENBQUMxQyxLQUFLLEVBQ1gsSUFBSSxDQUFDQSxLQUFLLEdBQUcsSUFBSSxDQUFDc0MsVUFBVTtZQUNoQyxJQUFJeEMsUUFBUSxRQUFTLEtBQUksQ0FBQ0UsS0FBSyxDQUFDNkMsU0FBUyxJQUFJLFFBQVEsSUFBSSxDQUFDN0MsS0FBSyxDQUFDNkMsU0FBUyxHQUFHL0MsSUFBRyxLQUMzRUEsT0FBTyxJQUFJLENBQUNwRCxLQUFLLENBQUNtQixHQUFHLENBQUNDLE1BQU0sRUFDNUIsSUFBSSxDQUFDa0MsS0FBSyxDQUFDOEMsTUFBTSxDQUFDaEQ7WUFDdEIsT0FBUztnQkFDTCxJQUFJaUQsT0FBTyxJQUFJLENBQUMvQyxLQUFLLENBQUNnRCxPQUFPO2dCQUM3QixJQUFJRCxNQUFNO29CQUNOLElBQUksQ0FBQ2YsU0FBUyxHQUFHLElBQUksQ0FBQ2lCLGtCQUFrQixDQUFDMUosdURBQVlBLENBQUMySixPQUFPLENBQUNILE1BQU0sSUFBSSxDQUFDZixTQUFTLEVBQUUsSUFBSSxDQUFDaEMsS0FBSyxDQUFDNkMsU0FBUyxJQUFJO29CQUM1RyxJQUFJLENBQUNaLE9BQU8sR0FBRyxDQUFDakgsS0FBSyxJQUFJLENBQUNnRixLQUFLLENBQUM2QyxTQUFTLE1BQU0sUUFBUTdILE9BQU8sS0FBSyxJQUFJQSxLQUFLLElBQUksQ0FBQzBCLEtBQUssQ0FBQ21CLEdBQUcsQ0FBQ0MsTUFBTTtvQkFDakcsSUFBSSxDQUFDSSxJQUFJLEdBQUc2RTtvQkFDWixJQUFJLENBQUMvQyxLQUFLLEdBQUc7b0JBQ2IsSUFBSSxJQUFJLENBQUNpQyxPQUFPLEdBQUluQyxDQUFBQSxTQUFTLFFBQVFBLFNBQVMsS0FBSyxJQUFJQSxPQUFPLElBQUksQ0FBQ3BELEtBQUssQ0FBQ21CLEdBQUcsQ0FBQ0MsTUFBTSxHQUMvRSxJQUFJLENBQUNrQyxLQUFLLEdBQUcsSUFBSSxDQUFDc0MsVUFBVTt5QkFFNUIsT0FBTztnQkFDZjtnQkFDQSxJQUFJQyxTQUNBLE9BQU87WUFDZjtRQUNKO0lBQ0o7SUFDQTs7SUFFQSxHQUNBQyxXQUFXO1FBQ1AsSUFBSTdGLEtBQUt1QjtRQUNULElBQUksSUFBSSxDQUFDOEIsS0FBSyxJQUFJLENBQUNyRCxNQUFNLElBQUksQ0FBQ3FELEtBQUssQ0FBQ21ELFNBQVMsS0FBSyxJQUFJLENBQUNsQixPQUFPLEVBQUU7WUFDNUQsSUFBSSxJQUFJLENBQUNqQyxLQUFLLENBQUM2QyxTQUFTLElBQUksUUFBUSxJQUFJLENBQUM3QyxLQUFLLENBQUM2QyxTQUFTLEdBQUdsRyxLQUN2RCxJQUFJLENBQUNxRCxLQUFLLENBQUM4QyxNQUFNLENBQUNuRztZQUN0QixJQUFJLENBQUM4RixXQUFXLENBQUM7Z0JBQVEsTUFBTyxDQUFFdkUsQ0FBQUEsT0FBTyxJQUFJLENBQUM4QixLQUFLLENBQUNnRCxPQUFPLEVBQUMsRUFBSSxDQUFFO1lBQUU7WUFDcEUsSUFBSSxDQUFDZixPQUFPLEdBQUd0RjtZQUNmLElBQUksQ0FBQ3VCLElBQUksR0FBR0E7WUFDWixJQUFJLENBQUM4RCxTQUFTLEdBQUcsSUFBSSxDQUFDaUIsa0JBQWtCLENBQUMxSix1REFBWUEsQ0FBQzJKLE9BQU8sQ0FBQyxJQUFJLENBQUNoRixJQUFJLEVBQUUsSUFBSSxDQUFDOEQsU0FBUyxFQUFFO1lBQ3pGLElBQUksQ0FBQ2hDLEtBQUssR0FBRztRQUNqQjtJQUNKO0lBQ0F5QyxZQUFZVyxDQUFDLEVBQUU7UUFDWCxJQUFJQyxPQUFPdkI7UUFDWEEsaUJBQWlCLElBQUk7UUFDckIsSUFBSTtZQUNBLE9BQU9zQjtRQUNYLFNBQ1E7WUFDSnRCLGlCQUFpQnVCO1FBQ3JCO0lBQ0o7SUFDQUosbUJBQW1CakIsU0FBUyxFQUFFO1FBQzFCLElBQUssSUFBSXpELEdBQUdBLElBQUksSUFBSSxDQUFDNkQsV0FBVyxDQUFDa0IsR0FBRyxJQUNoQ3RCLFlBQVl1QixhQUFhdkIsV0FBV3pELEVBQUVqQixJQUFJLEVBQUVpQixFQUFFWCxFQUFFO1FBQ3BELE9BQU9vRTtJQUNYO0lBQ0E7O0lBRUEsR0FDQXdCLFFBQVFBLE9BQU8sRUFBRUMsUUFBUSxFQUFFO1FBQ3ZCLElBQUksRUFBRXpCLFNBQVMsRUFBRTlELElBQUksRUFBRStELE9BQU8sRUFBRTlCLFFBQVEsRUFBRStCLE9BQU8sRUFBRSxHQUFHLElBQUk7UUFDMUQsSUFBSSxDQUFDTSxRQUFRO1FBQ2IsSUFBSSxDQUFDZ0IsUUFBUTVELEtBQUssRUFBRTtZQUNoQixJQUFJOEQsU0FBUyxFQUFFO1lBQ2ZGLFFBQVFHLGlCQUFpQixDQUFDLENBQUNDLE9BQU9DLEtBQUtDLE9BQU9DLE1BQVFMLE9BQU92RixJQUFJLENBQUM7b0JBQUV5RjtvQkFBT0M7b0JBQUtDO29CQUFPQztnQkFBSTtZQUMzRi9CLFlBQVl6SSx1REFBWUEsQ0FBQ3lLLFlBQVksQ0FBQ2hDLFdBQVcwQjtZQUNqRHhGLE9BQU81RSwrQ0FBSUEsQ0FBQ3NHLEtBQUs7WUFDakJxQyxVQUFVO1lBQ1Y5QixXQUFXO2dCQUFFN0MsTUFBTWtHLFFBQVFTLE1BQU0sQ0FBQzlELFNBQVM3QyxJQUFJLEVBQUUsQ0FBQztnQkFBSU0sSUFBSTRGLFFBQVFTLE1BQU0sQ0FBQzlELFNBQVN2QyxFQUFFLEVBQUU7WUFBRztZQUN6RixJQUFJLElBQUksQ0FBQ3NFLE9BQU8sQ0FBQ3BFLE1BQU0sRUFBRTtnQkFDckJvRSxVQUFVLEVBQUU7Z0JBQ1osS0FBSyxJQUFJM0QsS0FBSyxJQUFJLENBQUMyRCxPQUFPLENBQUU7b0JBQ3hCLElBQUk1RSxPQUFPa0csUUFBUVMsTUFBTSxDQUFDMUYsRUFBRWpCLElBQUksRUFBRSxJQUFJTSxLQUFLNEYsUUFBUVMsTUFBTSxDQUFDMUYsRUFBRVgsRUFBRSxFQUFFLENBQUM7b0JBQ2pFLElBQUlOLE9BQU9NLElBQ1BzRSxRQUFRL0QsSUFBSSxDQUFDO3dCQUFFYjt3QkFBTU07b0JBQUc7Z0JBQ2hDO1lBQ0o7UUFDSjtRQUNBLE9BQU8sSUFBSW1FLGFBQWEsSUFBSSxDQUFDbEcsTUFBTSxFQUFFNEgsVUFBVXpCLFdBQVc5RCxNQUFNK0QsU0FBUzlCLFVBQVUrQixTQUFTLElBQUksQ0FBQ0MsVUFBVTtJQUMvRztJQUNBOztJQUVBLEdBQ0EvQixlQUFlRCxRQUFRLEVBQUU7UUFDckIsSUFBSSxJQUFJLENBQUNBLFFBQVEsQ0FBQzdDLElBQUksSUFBSTZDLFNBQVM3QyxJQUFJLElBQUksSUFBSSxDQUFDNkMsUUFBUSxDQUFDdkMsRUFBRSxJQUFJdUMsU0FBU3ZDLEVBQUUsRUFDdEUsT0FBTztRQUNYLElBQUksQ0FBQ3VDLFFBQVEsR0FBR0E7UUFDaEIsSUFBSStELFdBQVcsSUFBSSxDQUFDaEMsT0FBTyxDQUFDcEUsTUFBTTtRQUNsQyxJQUFLLElBQUlXLElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUN5RCxPQUFPLENBQUNwRSxNQUFNLEVBQUVXLElBQUs7WUFDMUMsSUFBSSxFQUFFbkIsSUFBSSxFQUFFTSxFQUFFLEVBQUUsR0FBRyxJQUFJLENBQUNzRSxPQUFPLENBQUN6RCxFQUFFO1lBQ2xDLElBQUluQixPQUFPNkMsU0FBU3ZDLEVBQUUsSUFBSUEsS0FBS3VDLFNBQVM3QyxJQUFJLEVBQUU7Z0JBQzFDLElBQUksQ0FBQzBFLFNBQVMsR0FBR3VCLGFBQWEsSUFBSSxDQUFDdkIsU0FBUyxFQUFFMUUsTUFBTU07Z0JBQ3BELElBQUksQ0FBQ3NFLE9BQU8sQ0FBQ2lDLE1BQU0sQ0FBQzFGLEtBQUs7WUFDN0I7UUFDSjtRQUNBLElBQUksSUFBSSxDQUFDeUQsT0FBTyxDQUFDcEUsTUFBTSxJQUFJb0csVUFDdkIsT0FBTztRQUNYLElBQUksQ0FBQ0UsS0FBSztRQUNWLE9BQU87SUFDWDtJQUNBOztJQUVBLEdBQ0FBLFFBQVE7UUFDSixJQUFJLElBQUksQ0FBQ3BFLEtBQUssRUFBRTtZQUNaLElBQUksQ0FBQ3dDLFFBQVE7WUFDYixJQUFJLENBQUN4QyxLQUFLLEdBQUc7UUFDakI7SUFDSjtJQUNBOzs7O0lBSUEsR0FDQXFFLGdCQUFnQi9HLElBQUksRUFBRU0sRUFBRSxFQUFFO1FBQ3RCLElBQUksQ0FBQ3NFLE9BQU8sQ0FBQy9ELElBQUksQ0FBQztZQUFFYjtZQUFNTTtRQUFHO0lBQ2pDO0lBQ0E7Ozs7Ozs7O0lBUUEsR0FDQSxPQUFPMEcsa0JBQWtCL0IsS0FBSyxFQUFFO1FBQzVCLE9BQU8sSUFBSSxjQUFjL0ksaURBQU1BO1lBQzNCK0ssWUFBWUMsS0FBSyxFQUFFeEMsU0FBUyxFQUFFMEIsTUFBTSxFQUFFO2dCQUNsQyxJQUFJcEcsT0FBT29HLE1BQU0sQ0FBQyxFQUFFLENBQUNwRyxJQUFJLEVBQUVNLEtBQUs4RixNQUFNLENBQUNBLE9BQU81RixNQUFNLEdBQUcsRUFBRSxDQUFDRixFQUFFO2dCQUM1RCxJQUFJL0IsU0FBUztvQkFDVHNILFdBQVc3RjtvQkFDWDBGO3dCQUNJLElBQUl5QixLQUFLM0M7d0JBQ1QsSUFBSTJDLElBQUk7NEJBQ0osS0FBSyxJQUFJbEcsS0FBS21GLE9BQ1ZlLEdBQUdyQyxXQUFXLENBQUNqRSxJQUFJLENBQUNJOzRCQUN4QixJQUFJZ0UsT0FDQWtDLEdBQUd0QyxVQUFVLEdBQUdzQyxHQUFHdEMsVUFBVSxHQUFHdUMsUUFBUUMsR0FBRyxDQUFDO2dDQUFDRixHQUFHdEMsVUFBVTtnQ0FBRUk7NkJBQU0sSUFBSUE7d0JBQzlFO3dCQUNBLElBQUksQ0FBQ1ksU0FBUyxHQUFHdkY7d0JBQ2pCLE9BQU8sSUFBSXRFLCtDQUFJQSxDQUFDRyxtREFBUUEsQ0FBQ21MLElBQUksRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFaEgsS0FBS047b0JBQ2hEO29CQUNBdUYsV0FBVztvQkFDWEMsV0FBVztnQkFDZjtnQkFDQSxPQUFPakg7WUFDWDtRQUNKO0lBQ0o7SUFDQTs7SUFFQSxHQUNBd0UsT0FBT1AsSUFBSSxFQUFFO1FBQ1RBLE9BQU8rRSxLQUFLQyxHQUFHLENBQUNoRixNQUFNLElBQUksQ0FBQ3BELEtBQUssQ0FBQ21CLEdBQUcsQ0FBQ0MsTUFBTTtRQUMzQyxJQUFJaUgsUUFBUSxJQUFJLENBQUMvQyxTQUFTO1FBQzFCLE9BQU8sSUFBSSxDQUFDQyxPQUFPLElBQUluQyxRQUFRaUYsTUFBTWpILE1BQU0sSUFBSWlILEtBQUssQ0FBQyxFQUFFLENBQUN6SCxJQUFJLElBQUksS0FBS3lILEtBQUssQ0FBQyxFQUFFLENBQUNuSCxFQUFFLElBQUlrQztJQUN4RjtJQUNBOzs7SUFHQSxHQUNBLE9BQU8xRCxNQUFNO1FBQUUsT0FBTzBGO0lBQWdCO0FBQzFDO0FBQ0EsU0FBU3lCLGFBQWF2QixTQUFTLEVBQUUxRSxJQUFJLEVBQUVNLEVBQUU7SUFDckMsT0FBT3JFLHVEQUFZQSxDQUFDeUssWUFBWSxDQUFDaEMsV0FBVztRQUFDO1lBQUU0QixPQUFPdEc7WUFBTXVHLEtBQUtqRztZQUFJa0csT0FBT3hHO1lBQU15RyxLQUFLbkc7UUFBRztLQUFFO0FBQ2hHO0FBQ0EsTUFBTW9IO0lBQ0ZySixZQUNBLGtFQUFrRTtJQUNsRSx5REFBeUQ7SUFDekRzRSxPQUFPLENBQUU7UUFDTCxJQUFJLENBQUNBLE9BQU8sR0FBR0E7UUFDZixJQUFJLENBQUMvQixJQUFJLEdBQUcrQixRQUFRL0IsSUFBSTtJQUM1QjtJQUNBK0csTUFBTUMsRUFBRSxFQUFFO1FBQ04sSUFBSSxDQUFDQSxHQUFHQyxVQUFVLElBQUksSUFBSSxDQUFDakgsSUFBSSxJQUFJLElBQUksQ0FBQytCLE9BQU8sQ0FBQy9CLElBQUksRUFDaEQsT0FBTyxJQUFJO1FBQ2YsSUFBSWtILFFBQVEsSUFBSSxDQUFDbkYsT0FBTyxDQUFDdUQsT0FBTyxDQUFDMEIsR0FBRzFCLE9BQU8sRUFBRTBCLEdBQUd4SSxLQUFLO1FBQ3JELCtEQUErRDtRQUMvRCxpRUFBaUU7UUFDakUscURBQXFEO1FBQ3JELElBQUlvRCxPQUFPLElBQUksQ0FBQ0csT0FBTyxDQUFDZ0MsT0FBTyxJQUFJaUQsR0FBR0csVUFBVSxDQUFDeEgsR0FBRyxDQUFDQyxNQUFNLEdBQUd0QyxZQUN4RHFKLEtBQUtTLEdBQUcsQ0FBQ0osR0FBRzFCLE9BQU8sQ0FBQ1MsTUFBTSxDQUFDLElBQUksQ0FBQ2hFLE9BQU8sQ0FBQ2dDLE9BQU8sR0FBR21ELE1BQU1qRixRQUFRLENBQUN2QyxFQUFFO1FBQ3pFLElBQUksQ0FBQ3dILE1BQU05RSxJQUFJLENBQUMsR0FBRyxjQUFjLEtBQUlSLE9BQ2pDc0YsTUFBTTVDLFFBQVE7UUFDbEIsT0FBTyxJQUFJd0MsY0FBY0k7SUFDN0I7SUFDQSxPQUFPRyxLQUFLN0ksS0FBSyxFQUFFO1FBQ2YsSUFBSThJLE9BQU9YLEtBQUtDLEdBQUcsQ0FBQyxLQUFLLHFCQUFxQixLQUFJcEksTUFBTW1CLEdBQUcsQ0FBQ0MsTUFBTTtRQUNsRSxJQUFJMkgsYUFBYTFELGFBQWFNLE1BQU0sQ0FBQzNGLE1BQU1RLEtBQUssQ0FBQ1gsVUFBVVYsTUFBTSxFQUFFYSxPQUFPO1lBQUVZLE1BQU07WUFBR00sSUFBSTRIO1FBQUs7UUFDOUYsSUFBSSxDQUFDQyxXQUFXbkYsSUFBSSxDQUFDLEdBQUcsY0FBYyxLQUFJa0YsT0FDdENDLFdBQVdqRCxRQUFRO1FBQ3ZCLE9BQU8sSUFBSXdDLGNBQWNTO0lBQzdCO0FBQ0o7QUFDQS9KLFNBQVNnQixLQUFLLEdBQUcsV0FBVyxHQUFFOUMseURBQVVBLENBQUN3QixNQUFNLENBQUM7SUFDNUNpSCxRQUFRMkMsY0FBY08sSUFBSTtJQUMxQkcsUUFBT25FLEtBQUssRUFBRTJELEVBQUU7UUFDWixLQUFLLElBQUlTLEtBQUtULEdBQUdVLE9BQU8sQ0FDcEIsSUFBSUQsRUFBRUUsRUFBRSxDQUFDbkssU0FBU21ELFFBQVEsR0FDdEIsT0FBTzhHLEVBQUVwRSxLQUFLO1FBQ3RCLElBQUkyRCxHQUFHRyxVQUFVLENBQUNuSSxLQUFLLENBQUNYLGFBQWEySSxHQUFHeEksS0FBSyxDQUFDUSxLQUFLLENBQUNYLFdBQ2hELE9BQU95SSxjQUFjTyxJQUFJLENBQUNMLEdBQUd4SSxLQUFLO1FBQ3RDLE9BQU82RSxNQUFNMEQsS0FBSyxDQUFDQztJQUN2QjtBQUNKO0FBQ0EsSUFBSVksY0FBYyxDQUFDQztJQUNmLElBQUloRyxVQUFVaUcsV0FBVyxJQUFNRCxZQUFZLElBQUksaUJBQWlCO0lBQ2hFLE9BQU8sSUFBTUUsYUFBYWxHO0FBQzlCO0FBQ0EsSUFBSSxPQUFPbUcsdUJBQXVCLGFBQzlCSixjQUFjLENBQUNDO0lBQ1gsSUFBSUksT0FBTyxDQUFDLEdBQUdwRyxVQUFVaUcsV0FBVztRQUNoQ0csT0FBT0Qsb0JBQW9CSCxVQUFVO1lBQUVoRyxTQUFTLElBQUksaUJBQWlCLE1BQUssSUFBSSxpQkFBaUI7UUFBRztJQUN0RyxHQUFHLElBQUksaUJBQWlCO0lBQ3hCLE9BQU8sSUFBTW9HLE9BQU8sSUFBSUYsYUFBYWxHLFdBQVdxRyxtQkFBbUJEO0FBQ3ZFO0FBQ0osTUFBTUUsaUJBQWlCLE9BQU9DLGFBQWEsZUFBZ0IsRUFBQ3RMLEtBQUtzTCxVQUFVQyxVQUFVLE1BQU0sUUFBUXZMLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR3FMLGNBQWMsSUFDdkksSUFBTUMsVUFBVUMsVUFBVSxDQUFDRixjQUFjLEtBQUs7QUFDcEQsTUFBTXZGLGNBQWMsV0FBVyxHQUFFMUcsd0RBQVVBLENBQUNvTSxTQUFTLENBQUMsTUFBTUM7SUFDeEQ5SyxZQUFZOEUsSUFBSSxDQUFFO1FBQ2QsSUFBSSxDQUFDQSxJQUFJLEdBQUdBO1FBQ1osSUFBSSxDQUFDaUcsT0FBTyxHQUFHO1FBQ2YsSUFBSSxDQUFDQyxhQUFhLEdBQUc7UUFDckIsZ0NBQWdDO1FBQ2hDLElBQUksQ0FBQ0MsUUFBUSxHQUFHLENBQUM7UUFDakIsNkNBQTZDO1FBQzdDLElBQUksQ0FBQ0MsV0FBVyxHQUFHLENBQUM7UUFDcEIsSUFBSSxDQUFDdkcsSUFBSSxHQUFHLElBQUksQ0FBQ0EsSUFBSSxDQUFDd0csSUFBSSxDQUFDLElBQUk7UUFDL0IsSUFBSSxDQUFDQyxZQUFZO0lBQ3JCO0lBQ0FyQixPQUFPQSxNQUFNLEVBQUU7UUFDWCxJQUFJakIsS0FBSyxJQUFJLENBQUNoRSxJQUFJLENBQUMvRCxLQUFLLENBQUNpRCxLQUFLLENBQUNqRSxTQUFTZ0IsS0FBSyxFQUFFdUQsT0FBTztRQUN0RCxJQUFJd0UsR0FBR3JFLGNBQWMsQ0FBQ3NGLE9BQU9qRixJQUFJLENBQUNOLFFBQVEsS0FBSyxJQUFJLENBQUNNLElBQUksQ0FBQ04sUUFBUSxDQUFDdkMsRUFBRSxHQUFHNkcsR0FBR3hDLE9BQU8sRUFDN0UsSUFBSSxDQUFDOEUsWUFBWTtRQUNyQixJQUFJckIsT0FBT1AsVUFBVSxJQUFJTyxPQUFPc0IsWUFBWSxFQUFFO1lBQzFDLElBQUksSUFBSSxDQUFDdkcsSUFBSSxDQUFDd0csUUFBUSxFQUNsQixJQUFJLENBQUNKLFdBQVcsSUFBSSxHQUFHLG9CQUFvQjtZQUMvQyxJQUFJLENBQUNFLFlBQVk7UUFDckI7UUFDQSxJQUFJLENBQUNHLGtCQUFrQixDQUFDekM7SUFDNUI7SUFDQXNDLGVBQWU7UUFDWCxJQUFJLElBQUksQ0FBQ0wsT0FBTyxFQUNaO1FBQ0osSUFBSSxFQUFFaEssS0FBSyxFQUFFLEdBQUcsSUFBSSxDQUFDK0QsSUFBSSxFQUFFZCxRQUFRakQsTUFBTWlELEtBQUssQ0FBQ2pFLFNBQVNnQixLQUFLO1FBQzdELElBQUlpRCxNQUFNekIsSUFBSSxJQUFJeUIsTUFBTU0sT0FBTyxDQUFDL0IsSUFBSSxJQUFJLENBQUN5QixNQUFNTSxPQUFPLENBQUNJLE1BQU0sQ0FBQzNELE1BQU1tQixHQUFHLENBQUNDLE1BQU0sR0FDMUUsSUFBSSxDQUFDNEksT0FBTyxHQUFHWixZQUFZLElBQUksQ0FBQ3hGLElBQUk7SUFDNUM7SUFDQUEsS0FBSzZHLFFBQVEsRUFBRTtRQUNYLElBQUksQ0FBQ1QsT0FBTyxHQUFHO1FBQ2YsSUFBSTlELE1BQU1ELEtBQUtDLEdBQUc7UUFDbEIsSUFBSSxJQUFJLENBQUNnRSxRQUFRLEdBQUdoRSxPQUFRLEtBQUksQ0FBQ2dFLFFBQVEsR0FBRyxLQUFLLElBQUksQ0FBQ25HLElBQUksQ0FBQ3dHLFFBQVEsR0FBRztZQUNsRSxJQUFJLENBQUNMLFFBQVEsR0FBR2hFLE1BQU0sTUFBTSxrQkFBa0I7WUFDOUMsSUFBSSxDQUFDaUUsV0FBVyxHQUFHLEtBQUssb0JBQW9CO1FBQ2hEO1FBQ0EsSUFBSSxJQUFJLENBQUNBLFdBQVcsSUFBSSxHQUNwQixRQUFRLGlCQUFpQjtRQUM3QixJQUFJLEVBQUVuSyxLQUFLLEVBQUV5RCxVQUFVLEVBQUV2QyxJQUFJNEgsSUFBSSxFQUFFLEVBQUUsR0FBRyxJQUFJLENBQUMvRSxJQUFJLEVBQUVkLFFBQVFqRCxNQUFNaUQsS0FBSyxDQUFDakUsU0FBU2dCLEtBQUs7UUFDckYsSUFBSWlELE1BQU16QixJQUFJLElBQUl5QixNQUFNTSxPQUFPLENBQUMvQixJQUFJLElBQUl5QixNQUFNTSxPQUFPLENBQUNJLE1BQU0sQ0FBQ21GLE9BQU8sT0FBTyxzQkFBc0IsTUFDN0Y7UUFDSixJQUFJOUMsVUFBVUMsS0FBS0MsR0FBRyxLQUFLaUMsS0FBS0MsR0FBRyxDQUFDLElBQUksQ0FBQytCLFdBQVcsRUFBRSxJQUFJLGNBQWMsS0FBSU0sWUFBWSxDQUFDZCxpQkFBaUJ4QixLQUFLUyxHQUFHLENBQUMsR0FBRyxpQkFBaUIsS0FBSTZCLFNBQVNDLGFBQWEsS0FBSyxLQUFLO1FBQzNLLElBQUlDLGdCQUFnQjFILE1BQU1NLE9BQU8sQ0FBQ2dDLE9BQU8sR0FBR3VELFFBQVE5SSxNQUFNbUIsR0FBRyxDQUFDQyxNQUFNLEdBQUcwSCxPQUFPO1FBQzlFLElBQUl6QyxPQUFPcEQsTUFBTU0sT0FBTyxDQUFDSyxJQUFJLENBQUM7WUFDMUIsT0FBTytGLGtCQUFrQkEsb0JBQW9CMUQsS0FBS0MsR0FBRyxLQUFLRjtRQUM5RCxHQUFHOEMsT0FBUTZCLENBQUFBLGdCQUFnQixJQUFJLE9BQU8sc0JBQXNCLEdBQXhCO1FBQ3BDLElBQUksQ0FBQ1IsV0FBVyxJQUFJbEUsS0FBS0MsR0FBRyxLQUFLQTtRQUNqQyxJQUFJRyxRQUFRLElBQUksQ0FBQzhELFdBQVcsSUFBSSxHQUFHO1lBQy9CbEgsTUFBTU0sT0FBTyxDQUFDdUMsUUFBUTtZQUN0QixJQUFJLENBQUMvQixJQUFJLENBQUNFLFFBQVEsQ0FBQztnQkFBRWlGLFNBQVNsSyxTQUFTbUQsUUFBUSxDQUFDckMsRUFBRSxDQUFDLElBQUl3SSxjQUFjckYsTUFBTU0sT0FBTztZQUFHO1FBQ3pGO1FBQ0EsSUFBSSxJQUFJLENBQUM0RyxXQUFXLEdBQUcsS0FBSyxDQUFFOUQsQ0FBQUEsUUFBUSxDQUFDc0UsYUFBWSxHQUMvQyxJQUFJLENBQUNOLFlBQVk7UUFDckIsSUFBSSxDQUFDRyxrQkFBa0IsQ0FBQ3ZILE1BQU1NLE9BQU87SUFDekM7SUFDQWlILG1CQUFtQnpDLEVBQUUsRUFBRTtRQUNuQixJQUFJQSxHQUFHdEMsVUFBVSxFQUFFO1lBQ2YsSUFBSSxDQUFDd0UsYUFBYTtZQUNsQmxDLEdBQUd0QyxVQUFVLENBQ1JtRixJQUFJLENBQUMsSUFBTSxJQUFJLENBQUNQLFlBQVksSUFDNUJRLEtBQUssQ0FBQ0MsQ0FBQUEsTUFBT25OLDhEQUFZQSxDQUFDLElBQUksQ0FBQ29HLElBQUksQ0FBQy9ELEtBQUssRUFBRThLLE1BQzNDRixJQUFJLENBQUMsSUFBTSxJQUFJLENBQUNYLGFBQWE7WUFDbENsQyxHQUFHdEMsVUFBVSxHQUFHO1FBQ3BCO0lBQ0o7SUFDQXNGLFVBQVU7UUFDTixJQUFJLElBQUksQ0FBQ2YsT0FBTyxFQUNaLElBQUksQ0FBQ0EsT0FBTztJQUNwQjtJQUNBM0YsWUFBWTtRQUNSLE9BQU8sQ0FBQyxDQUFFLEtBQUksQ0FBQzJGLE9BQU8sSUFBSSxJQUFJLENBQUNDLGFBQWEsR0FBRztJQUNuRDtBQUNKLEdBQUc7SUFDQ2UsZUFBZTtRQUFFQztZQUFVLElBQUksQ0FBQ1osWUFBWTtRQUFJO0lBQUU7QUFDdEQ7QUFDQTs7Ozs7QUFLQSxHQUNBLE1BQU14SyxXQUFXLFdBQVcsR0FBRTFDLG9EQUFLQSxDQUFDdUIsTUFBTSxDQUFDO0lBQ3ZDQyxTQUFRdU0sU0FBUztRQUFJLE9BQU9BLFVBQVU5SixNQUFNLEdBQUc4SixTQUFTLENBQUMsRUFBRSxHQUFHO0lBQU07SUFDcEVDLFNBQVN0TCxDQUFBQSxXQUFZO1lBQ2pCYixTQUFTZ0IsS0FBSztZQUNkb0U7WUFDQXhHLHdEQUFVQSxDQUFDd04saUJBQWlCLENBQUNDLE9BQU8sQ0FBQztnQkFBQ3hMO2FBQVMsRUFBRUcsQ0FBQUE7Z0JBQzdDLElBQUlpQixPQUFPakIsTUFBTVEsS0FBSyxDQUFDWDtnQkFDdkIsT0FBT29CLFFBQVFBLEtBQUs1QixJQUFJLEdBQUc7b0JBQUUsaUJBQWlCNEIsS0FBSzVCLElBQUk7Z0JBQUMsSUFBSSxDQUFDO1lBQ2pFO1NBQ0g7QUFDTDtBQUNBOzs7Ozs7QUFNQSxHQUNBLE1BQU1pTTtJQUNGOztJQUVBLEdBQ0FyTSxZQUNBOztJQUVBLEdBQ0FZLFFBQVEsRUFDUjs7Ozs7SUFLQSxHQUNBMEwsVUFBVSxFQUFFLENBQUU7UUFDVixJQUFJLENBQUMxTCxRQUFRLEdBQUdBO1FBQ2hCLElBQUksQ0FBQzBMLE9BQU8sR0FBR0E7UUFDZixJQUFJLENBQUMzTCxTQUFTLEdBQUc7WUFBQ0M7WUFBVTBMO1NBQVE7SUFDeEM7QUFDSjtBQUNBOzs7OztBQUtBLEdBQ0EsTUFBTUM7SUFDRnZNLFlBQ0E7O0lBRUEsR0FDQUksSUFBSSxFQUNKOztJQUVBLEdBQ0FvTSxLQUFLLEVBQ0w7O0lBRUEsR0FDQUMsVUFBVSxFQUNWOzs7SUFHQSxHQUNBQyxRQUFRLEVBQUVDLFFBQVEsRUFDbEI7O0lBRUEsR0FDQUwsVUFBVXpNLFNBQVMsQ0FBRTtRQUNqQixJQUFJLENBQUNPLElBQUksR0FBR0E7UUFDWixJQUFJLENBQUNvTSxLQUFLLEdBQUdBO1FBQ2IsSUFBSSxDQUFDQyxVQUFVLEdBQUdBO1FBQ2xCLElBQUksQ0FBQ0MsUUFBUSxHQUFHQTtRQUNoQixJQUFJLENBQUNDLFFBQVEsR0FBR0E7UUFDaEIsSUFBSSxDQUFDTCxPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDTSxPQUFPLEdBQUc7SUFDbkI7SUFDQTs7OztJQUlBLEdBQ0FDLE9BQU87UUFDSCxPQUFPLElBQUksQ0FBQ0QsT0FBTyxJQUFLLEtBQUksQ0FBQ0EsT0FBTyxHQUFHLElBQUksQ0FBQ0QsUUFBUSxHQUFHaEIsSUFBSSxDQUFDVyxDQUFBQSxVQUFXLElBQUksQ0FBQ0EsT0FBTyxHQUFHQSxTQUFTVCxDQUFBQTtZQUFTLElBQUksQ0FBQ2UsT0FBTyxHQUFHO1lBQU0sTUFBTWY7UUFBSyxFQUFDO0lBQzdJO0lBQ0E7O0lBRUEsR0FDQSxPQUFPaEwsR0FBRzZDLElBQUksRUFBRTtRQUNaLElBQUksRUFBRW1KLElBQUksRUFBRVAsT0FBTyxFQUFFLEdBQUc1STtRQUN4QixJQUFJLENBQUNtSixNQUFNO1lBQ1AsSUFBSSxDQUFDUCxTQUNELE1BQU0sSUFBSVEsV0FBVztZQUN6QkQsT0FBTyxJQUFNOUQsUUFBUXJILE9BQU8sQ0FBQzRLO1FBQ2pDO1FBQ0EsT0FBTyxJQUFJQyxvQkFBb0I3SSxLQUFLdEQsSUFBSSxFQUFFLENBQUNzRCxLQUFLOEksS0FBSyxJQUFJLEVBQUUsRUFBRTVNLE1BQU0sQ0FBQzhELEtBQUt0RCxJQUFJLEVBQUUyTSxHQUFHLENBQUNDLENBQUFBLElBQUtBLEVBQUVDLFdBQVcsS0FBS3ZKLEtBQUsrSSxVQUFVLElBQUksRUFBRSxFQUFFL0ksS0FBS2dKLFFBQVEsRUFBRUcsTUFBTVA7SUFDMUo7SUFDQTs7Ozs7O0lBTUEsR0FDQSxPQUFPWSxjQUFjQyxLQUFLLEVBQUVULFFBQVEsRUFBRTtRQUNsQyxLQUFLLElBQUlVLEtBQUtELE1BQ1YsSUFBSUMsRUFBRVYsUUFBUSxJQUFJVSxFQUFFVixRQUFRLENBQUM3SyxJQUFJLENBQUM2SyxXQUM5QixPQUFPVTtRQUNmLElBQUlDLE1BQU0sYUFBYUMsSUFBSSxDQUFDWjtRQUM1QixJQUFJVyxLQUNBO1lBQUEsS0FBSyxJQUFJRCxLQUFLRCxNQUNWLElBQUlDLEVBQUVYLFVBQVUsQ0FBQ2MsT0FBTyxDQUFDRixHQUFHLENBQUMsRUFBRSxJQUFJLENBQUMsR0FDaEMsT0FBT0Q7UUFBQztRQUNwQixPQUFPO0lBQ1g7SUFDQTs7Ozs7O0lBTUEsR0FDQSxPQUFPSSxrQkFBa0JMLEtBQUssRUFBRS9NLElBQUksRUFBRXFOLFFBQVEsSUFBSSxFQUFFO1FBQ2hEck4sT0FBT0EsS0FBSzZNLFdBQVc7UUFDdkIsS0FBSyxJQUFJRyxLQUFLRCxNQUNWLElBQUlDLEVBQUVaLEtBQUssQ0FBQ2tCLElBQUksQ0FBQ0MsQ0FBQUEsSUFBS0EsS0FBS3ZOLE9BQ3ZCLE9BQU9nTjtRQUNmLElBQUlLLE9BQ0EsS0FBSyxJQUFJTCxLQUFLRCxNQUNWLEtBQUssSUFBSVEsS0FBS1AsRUFBRVosS0FBSyxDQUFFO1lBQ25CLElBQUlvQixRQUFReE4sS0FBS21OLE9BQU8sQ0FBQ0k7WUFDekIsSUFBSUMsUUFBUSxDQUFDLEtBQU1ELENBQUFBLEVBQUV4TCxNQUFNLEdBQUcsS0FBSyxDQUFDLEtBQUtOLElBQUksQ0FBQ3pCLElBQUksQ0FBQ3dOLFFBQVEsRUFBRSxLQUFLLENBQUMsS0FBSy9MLElBQUksQ0FBQ3pCLElBQUksQ0FBQ3dOLFFBQVFELEVBQUV4TCxNQUFNLENBQUMsSUFDL0YsT0FBT2lMO1FBQ2Y7UUFDUixPQUFPO0lBQ1g7QUFDSjtBQUVBOzs7Ozs7OztBQVFBLEdBQ0EsTUFBTVMsZ0JBQWdCLFdBQVcsR0FBRTNQLG9EQUFLQSxDQUFDdUIsTUFBTTtBQUMvQzs7OztBQUlBLEdBQ0EsTUFBTXFPLGFBQWEsV0FBVyxHQUFFNVAsb0RBQUtBLENBQUN1QixNQUFNLENBQUM7SUFDekNDLFNBQVNDLENBQUFBO1FBQ0wsSUFBSSxDQUFDQSxPQUFPd0MsTUFBTSxFQUNkLE9BQU87UUFDWCxJQUFJNEwsT0FBT3BPLE1BQU0sQ0FBQyxFQUFFO1FBQ3BCLElBQUksQ0FBQ29PLFFBQVEsS0FBS2xNLElBQUksQ0FBQ2tNLFNBQVNDLE1BQU1yTSxJQUFJLENBQUNvTSxNQUFNTCxJQUFJLENBQUMxRCxDQUFBQSxJQUFLQSxLQUFLK0QsSUFBSSxDQUFDLEVBQUUsR0FDbkUsTUFBTSxJQUFJRSxNQUFNLDBCQUEwQkMsS0FBS0MsU0FBUyxDQUFDeE8sTUFBTSxDQUFDLEVBQUU7UUFDdEUsT0FBT29PO0lBQ1g7QUFDSjtBQUNBOzs7OztBQUtBLEdBQ0EsU0FBU0ssY0FBY3JOLEtBQUs7SUFDeEIsSUFBSWdOLE9BQU9oTixNQUFNUSxLQUFLLENBQUN1TTtJQUN2QixPQUFPQyxLQUFLTSxVQUFVLENBQUMsTUFBTSxJQUFJdE4sTUFBTXVOLE9BQU8sR0FBR1AsS0FBSzVMLE1BQU0sR0FBRzRMLEtBQUs1TCxNQUFNO0FBQzlFO0FBQ0E7Ozs7O0FBS0EsR0FDQSxTQUFTb00sYUFBYXhOLEtBQUssRUFBRXlOLElBQUk7SUFDN0IsSUFBSW5NLFNBQVMsSUFBSW9NLEtBQUsxTixNQUFNdU4sT0FBTyxFQUFFdEwsS0FBS2pDLE1BQU1RLEtBQUssQ0FBQ3VNLFdBQVcsQ0FBQyxFQUFFO0lBQ3BFLElBQUk5SyxNQUFNLEtBQU07UUFDWixNQUFPd0wsUUFBUUMsR0FBSTtZQUNmcE0sVUFBVTtZQUNWbU0sUUFBUUM7UUFDWjtRQUNBekwsS0FBSztJQUNUO0lBQ0EsSUFBSyxJQUFJRixJQUFJLEdBQUdBLElBQUkwTCxNQUFNMUwsSUFDdEJULFVBQVVXO0lBQ2QsT0FBT1g7QUFDWDtBQUNBOzs7Ozs7OztBQVFBLEdBQ0EsU0FBU3FNLGVBQWVwSyxPQUFPLEVBQUV0RCxHQUFHO0lBQ2hDLElBQUlzRCxtQkFBbUJuRywwREFBV0EsRUFDOUJtRyxVQUFVLElBQUlxSyxjQUFjcks7SUFDaEMsS0FBSyxJQUFJc0ssV0FBV3RLLFFBQVF2RCxLQUFLLENBQUNRLEtBQUssQ0FBQ3NNLGVBQWdCO1FBQ3BELElBQUl4TCxTQUFTdU0sUUFBUXRLLFNBQVN0RDtRQUM5QixJQUFJcUIsV0FBV3hDLFdBQ1gsT0FBT3dDO0lBQ2Y7SUFDQSxJQUFJRSxPQUFPN0IsV0FBVzRELFFBQVF2RCxLQUFLO0lBQ25DLE9BQU93QixLQUFLSixNQUFNLElBQUluQixNQUFNNk4sa0JBQWtCdkssU0FBUy9CLE1BQU12QixPQUFPO0FBQ3hFO0FBQ0E7OztBQUdBLEdBQ0EsU0FBUzhOLFlBQVkvTixLQUFLLEVBQUVZLElBQUksRUFBRU0sRUFBRTtJQUNoQyxJQUFJOE0sVUFBVXhPLE9BQU9tRyxNQUFNLENBQUM7SUFDNUIsSUFBSXBDLFVBQVUsSUFBSXFLLGNBQWM1TixPQUFPO1FBQUVpTyxxQkFBcUJDLENBQUFBO1lBQVcsSUFBSTVQO1lBQUksT0FBTyxDQUFDQSxLQUFLMFAsT0FBTyxDQUFDRSxNQUFNLE1BQU0sUUFBUTVQLE9BQU8sS0FBSyxJQUFJQSxLQUFLLENBQUM7UUFBRztJQUFFO0lBQ3JKLElBQUl3SSxVQUFVLEVBQUU7SUFDaEIsSUFBSyxJQUFJN0csTUFBTVcsTUFBTVgsT0FBT2lCLElBQUs7UUFDN0IsSUFBSWlOLE9BQU9uTyxNQUFNbUIsR0FBRyxDQUFDaU4sTUFBTSxDQUFDbk87UUFDNUJBLE1BQU1rTyxLQUFLak4sRUFBRSxHQUFHO1FBQ2hCLElBQUltTixTQUFTVixlQUFlcEssU0FBUzRLLEtBQUt2TixJQUFJO1FBQzlDLElBQUl5TixVQUFVLE1BQ1Y7UUFDSixJQUFJLENBQUMsS0FBS3ZOLElBQUksQ0FBQ3FOLEtBQUtHLElBQUksR0FDcEJELFNBQVM7UUFDYixJQUFJRSxNQUFNLE9BQU9oQyxJQUFJLENBQUM0QixLQUFLRyxJQUFJLENBQUMsQ0FBQyxFQUFFO1FBQ25DLElBQUlFLE9BQU9oQixhQUFheE4sT0FBT3FPO1FBQy9CLElBQUlFLE9BQU9DLE1BQU07WUFDYlIsT0FBTyxDQUFDRyxLQUFLdk4sSUFBSSxDQUFDLEdBQUd5TjtZQUNyQnZILFFBQVFyRixJQUFJLENBQUM7Z0JBQUViLE1BQU11TixLQUFLdk4sSUFBSTtnQkFBRU0sSUFBSWlOLEtBQUt2TixJQUFJLEdBQUcyTixJQUFJbk4sTUFBTTtnQkFBRXFOLFFBQVFEO1lBQUs7UUFDN0U7SUFDSjtJQUNBLE9BQU94TyxNQUFNOEcsT0FBTyxDQUFDQTtBQUN6QjtBQUNBOzs7OztBQUtBLEdBQ0EsTUFBTThHO0lBQ0Y7O0lBRUEsR0FDQTNPLFlBQ0E7O0lBRUEsR0FDQWUsS0FBSyxFQUNMOztJQUVBLEdBQ0ErQyxVQUFVLENBQUMsQ0FBQyxDQUFFO1FBQ1YsSUFBSSxDQUFDL0MsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQytDLE9BQU8sR0FBR0E7UUFDZixJQUFJLENBQUNpSyxJQUFJLEdBQUdLLGNBQWNyTjtJQUM5QjtJQUNBOzs7Ozs7O0lBT0EsR0FDQW9PLE9BQU9uTyxHQUFHLEVBQUV5TyxPQUFPLENBQUMsRUFBRTtRQUNsQixJQUFJUCxPQUFPLElBQUksQ0FBQ25PLEtBQUssQ0FBQ21CLEdBQUcsQ0FBQ2lOLE1BQU0sQ0FBQ25PO1FBQ2pDLElBQUksRUFBRTBPLGFBQWEsRUFBRUMsbUJBQW1CLEVBQUUsR0FBRyxJQUFJLENBQUM3TCxPQUFPO1FBQ3pELElBQUk0TCxpQkFBaUIsUUFBUUEsaUJBQWlCUixLQUFLdk4sSUFBSSxJQUFJK04saUJBQWlCUixLQUFLak4sRUFBRSxFQUFFO1lBQ2pGLElBQUkwTix1QkFBdUJELGlCQUFpQjFPLEtBQ3hDLE9BQU87Z0JBQUVxTyxNQUFNO2dCQUFJMU4sTUFBTVg7WUFBSTtpQkFDNUIsSUFBSXlPLE9BQU8sSUFBSUMsZ0JBQWdCMU8sTUFBTTBPLGlCQUFpQjFPLEtBQ3ZELE9BQU87Z0JBQUVxTyxNQUFNSCxLQUFLRyxJQUFJLENBQUNuSixLQUFLLENBQUN3SixnQkFBZ0JSLEtBQUt2TixJQUFJO2dCQUFHQSxNQUFNK047WUFBYztpQkFFL0UsT0FBTztnQkFBRUwsTUFBTUgsS0FBS0csSUFBSSxDQUFDbkosS0FBSyxDQUFDLEdBQUd3SixnQkFBZ0JSLEtBQUt2TixJQUFJO2dCQUFHQSxNQUFNdU4sS0FBS3ZOLElBQUk7WUFBQztRQUN0RjtRQUNBLE9BQU91TjtJQUNYO0lBQ0E7OztJQUdBLEdBQ0FVLGFBQWE1TyxHQUFHLEVBQUV5TyxPQUFPLENBQUMsRUFBRTtRQUN4QixJQUFJLElBQUksQ0FBQzNMLE9BQU8sQ0FBQzZMLG1CQUFtQixJQUFJM08sT0FBTyxJQUFJLENBQUM4QyxPQUFPLENBQUM0TCxhQUFhLEVBQ3JFLE9BQU87UUFDWCxJQUFJLEVBQUVMLElBQUksRUFBRTFOLElBQUksRUFBRSxHQUFHLElBQUksQ0FBQ3dOLE1BQU0sQ0FBQ25PLEtBQUt5TztRQUN0QyxPQUFPSixLQUFLbkosS0FBSyxDQUFDbEYsTUFBTVcsTUFBTXVILEtBQUtDLEdBQUcsQ0FBQ2tHLEtBQUtsTixNQUFNLEVBQUVuQixNQUFNLE1BQU1XO0lBQ3BFO0lBQ0E7O0lBRUEsR0FDQWtPLE9BQU83TyxHQUFHLEVBQUV5TyxPQUFPLENBQUMsRUFBRTtRQUNsQixJQUFJLEVBQUVKLElBQUksRUFBRTFOLElBQUksRUFBRSxHQUFHLElBQUksQ0FBQ3dOLE1BQU0sQ0FBQ25PLEtBQUt5TztRQUN0QyxJQUFJcE4sU0FBUyxJQUFJLENBQUNqRSxXQUFXLENBQUNpUixNQUFNck8sTUFBTVc7UUFDMUMsSUFBSW1PLFdBQVcsSUFBSSxDQUFDaE0sT0FBTyxDQUFDa0wsbUJBQW1CLEdBQUcsSUFBSSxDQUFDbEwsT0FBTyxDQUFDa0wsbUJBQW1CLENBQUNyTixRQUFRLENBQUM7UUFDNUYsSUFBSW1PLFdBQVcsQ0FBQyxHQUNaek4sVUFBVXlOLFdBQVcsSUFBSSxDQUFDMVIsV0FBVyxDQUFDaVIsTUFBTUEsS0FBS1UsTUFBTSxDQUFDO1FBQzVELE9BQU8xTjtJQUNYO0lBQ0E7OztJQUdBLEdBQ0FqRSxZQUFZOFEsSUFBSSxFQUFFbE8sTUFBTWtPLEtBQUsvTSxNQUFNLEVBQUU7UUFDakMsT0FBTy9ELDhEQUFXQSxDQUFDOFEsTUFBTSxJQUFJLENBQUNuTyxLQUFLLENBQUN1TixPQUFPLEVBQUV0TjtJQUNqRDtJQUNBOztJQUVBLEdBQ0FnUCxXQUFXaFAsR0FBRyxFQUFFeU8sT0FBTyxDQUFDLEVBQUU7UUFDdEIsSUFBSSxFQUFFSixJQUFJLEVBQUUxTixJQUFJLEVBQUUsR0FBRyxJQUFJLENBQUN3TixNQUFNLENBQUNuTyxLQUFLeU87UUFDdEMsSUFBSUssV0FBVyxJQUFJLENBQUNoTSxPQUFPLENBQUNrTCxtQkFBbUI7UUFDL0MsSUFBSWMsVUFBVTtZQUNWLElBQUlHLFlBQVlILFNBQVNuTztZQUN6QixJQUFJc08sWUFBWSxDQUFDLEdBQ2IsT0FBT0E7UUFDZjtRQUNBLE9BQU8sSUFBSSxDQUFDN1IsV0FBVyxDQUFDaVIsTUFBTUEsS0FBS1UsTUFBTSxDQUFDO0lBQzlDO0lBQ0E7Ozs7SUFJQSxHQUNBLElBQUlHLGlCQUFpQjtRQUNqQixPQUFPLElBQUksQ0FBQ3BNLE9BQU8sQ0FBQzRMLGFBQWEsSUFBSTtJQUN6QztBQUNKO0FBQ0E7Ozs7OztBQU1BLEdBQ0EsTUFBTVMsaUJBQWlCLFdBQVcsR0FBRSxJQUFJMVMsbURBQVFBO0FBQ2hELHFFQUFxRTtBQUNyRSxTQUFTb1Isa0JBQWtCL0YsRUFBRSxFQUFFc0gsR0FBRyxFQUFFcFAsR0FBRztJQUNuQyxJQUFJcVAsUUFBUUQsSUFBSUUsWUFBWSxDQUFDdFA7SUFDN0IsSUFBSXVQLFFBQVFGLE1BQU1oTixJQUFJLENBQUNtTiwwQkFBMEIsQ0FBQ3hQO0lBQ2xELElBQUl1UCxTQUFTRixNQUFNaE4sSUFBSSxFQUFFO1FBQ3JCLElBQUlRLE1BQU0sRUFBRTtRQUNaLElBQUssSUFBSXlMLE1BQU1pQixPQUFPakIsT0FBT2UsTUFBTWhOLElBQUksRUFBRWlNLE1BQU1BLElBQUltQixNQUFNLENBQ3JENU0sSUFBSXJCLElBQUksQ0FBQzhNO1FBQ2IsSUFBSyxJQUFJeE0sSUFBSWUsSUFBSTFCLE1BQU0sR0FBRyxHQUFHVyxLQUFLLEdBQUdBLElBQ2pDdU4sUUFBUTtZQUFFaE4sTUFBTVEsR0FBRyxDQUFDZixFQUFFO1lBQUU2QyxNQUFNMEs7UUFBTTtJQUM1QztJQUNBLE9BQU9LLFVBQVVMLE9BQU92SCxJQUFJOUg7QUFDaEM7QUFDQSxTQUFTMFAsVUFBVUwsS0FBSyxFQUFFdkgsRUFBRSxFQUFFOUgsR0FBRztJQUM3QixJQUFLLElBQUlzTyxNQUFNZSxPQUFPZixLQUFLQSxNQUFNQSxJQUFJM0osSUFBSSxDQUFFO1FBQ3ZDLElBQUlnTCxXQUFXQyxlQUFldEIsSUFBSWpNLElBQUk7UUFDdEMsSUFBSXNOLFVBQ0EsT0FBT0EsU0FBU0Usa0JBQWtCbkssTUFBTSxDQUFDb0MsSUFBSTlILEtBQUtzTztJQUMxRDtJQUNBLE9BQU87QUFDWDtBQUNBLFNBQVN3QixhQUFhaEksRUFBRTtJQUNwQixPQUFPQSxHQUFHOUgsR0FBRyxJQUFJOEgsR0FBR2hGLE9BQU8sQ0FBQzRMLGFBQWEsSUFBSTVHLEdBQUdoRixPQUFPLENBQUM2TCxtQkFBbUI7QUFDL0U7QUFDQSxTQUFTaUIsZUFBZXJPLElBQUk7SUFDeEIsSUFBSW9PLFdBQVdwTyxLQUFLbkIsSUFBSSxDQUFDQyxJQUFJLENBQUM4TztJQUM5QixJQUFJUSxVQUNBLE9BQU9BO0lBQ1gsSUFBSUksUUFBUXhPLEtBQUt5TyxVQUFVLEVBQUVDO0lBQzdCLElBQUlGLFNBQVVFLENBQUFBLFFBQVFGLE1BQU0zUCxJQUFJLENBQUNDLElBQUksQ0FBQzVELG1EQUFRQSxDQUFDeVQsUUFBUSxJQUFJO1FBQ3ZELElBQUlDLE9BQU81TyxLQUFLNk8sU0FBUyxFQUFFQyxTQUFTRixRQUFRRixNQUFNMUQsT0FBTyxDQUFDNEQsS0FBSy9RLElBQUksSUFBSSxDQUFDO1FBQ3hFLE9BQU8wSSxDQUFBQSxLQUFNd0ksa0JBQWtCeEksSUFBSSxNQUFNLEdBQUdqSixXQUFXd1IsVUFBVSxDQUFDUCxhQUFhaEksTUFBTXFJLEtBQUt4UCxJQUFJLEdBQUc5QjtJQUNyRztJQUNBLE9BQU8wQyxLQUFLa08sTUFBTSxJQUFJLE9BQU9jLFlBQVk7QUFDN0M7QUFDQSxTQUFTQTtJQUFjLE9BQU87QUFBRztBQUNqQzs7O0FBR0EsR0FDQSxNQUFNViwwQkFBMEJsQztJQUM1QjNPLFlBQVlzQixJQUFJLEVBQ2hCOztJQUVBLEdBQ0FOLEdBQUcsRUFDSDs7SUFFQSxHQUNBc0QsT0FBTyxDQUFFO1FBQ0wsS0FBSyxDQUFDaEQsS0FBS1AsS0FBSyxFQUFFTyxLQUFLd0MsT0FBTztRQUM5QixJQUFJLENBQUN4QyxJQUFJLEdBQUdBO1FBQ1osSUFBSSxDQUFDTixHQUFHLEdBQUdBO1FBQ1gsSUFBSSxDQUFDc0QsT0FBTyxHQUFHQTtJQUNuQjtJQUNBOzs7SUFHQSxHQUNBLElBQUlqQixPQUFPO1FBQUUsT0FBTyxJQUFJLENBQUNpQixPQUFPLENBQUNqQixJQUFJO0lBQUU7SUFDdkM7O0lBRUEsR0FDQSxPQUFPcUQsT0FBT3BGLElBQUksRUFBRU4sR0FBRyxFQUFFc0QsT0FBTyxFQUFFO1FBQzlCLE9BQU8sSUFBSXVNLGtCQUFrQnZQLE1BQU1OLEtBQUtzRDtJQUM1QztJQUNBOzs7SUFHQSxHQUNBLElBQUlrTixZQUFZO1FBQ1osT0FBTyxJQUFJLENBQUM1QixZQUFZLENBQUMsSUFBSSxDQUFDNU8sR0FBRztJQUNyQztJQUNBOzs7Ozs7SUFNQSxHQUNBLElBQUl5USxhQUFhO1FBQ2IsT0FBTyxJQUFJLENBQUNDLGFBQWEsQ0FBQyxJQUFJLENBQUNyTyxJQUFJO0lBQ3ZDO0lBQ0E7OztJQUdBLEdBQ0FxTyxjQUFjck8sSUFBSSxFQUFFO1FBQ2hCLElBQUk2TCxPQUFPLElBQUksQ0FBQ25PLEtBQUssQ0FBQ21CLEdBQUcsQ0FBQ2lOLE1BQU0sQ0FBQzlMLEtBQUsxQixJQUFJO1FBQzFDLGtFQUFrRTtRQUNsRSxPQUFTO1lBQ0wsSUFBSWdRLFVBQVV0TyxLQUFLM0IsT0FBTyxDQUFDd04sS0FBS3ZOLElBQUk7WUFDcEMsTUFBT2dRLFFBQVFsQixNQUFNLElBQUlrQixRQUFRbEIsTUFBTSxDQUFDOU8sSUFBSSxJQUFJZ1EsUUFBUWhRLElBQUksQ0FDeERnUSxVQUFVQSxRQUFRbEIsTUFBTTtZQUM1QixJQUFJbUIsU0FBU0QsU0FBU3RPLE9BQ2xCO1lBQ0o2TCxPQUFPLElBQUksQ0FBQ25PLEtBQUssQ0FBQ21CLEdBQUcsQ0FBQ2lOLE1BQU0sQ0FBQ3dDLFFBQVFoUSxJQUFJO1FBQzdDO1FBQ0EsT0FBTyxJQUFJLENBQUNxTyxVQUFVLENBQUNkLEtBQUt2TixJQUFJO0lBQ3BDO0lBQ0E7OztJQUdBLEdBQ0FrUSxXQUFXO1FBQ1AsT0FBT25CLFVBQVUsSUFBSSxDQUFDcE0sT0FBTyxDQUFDcUIsSUFBSSxFQUFFLElBQUksQ0FBQ3JFLElBQUksRUFBRSxJQUFJLENBQUNOLEdBQUc7SUFDM0Q7QUFDSjtBQUNBLFNBQVM0USxTQUFTbkIsTUFBTSxFQUFFNVAsRUFBRTtJQUN4QixJQUFLLElBQUl5TyxNQUFNek8sSUFBSXlPLEtBQUtBLE1BQU1BLElBQUltQixNQUFNLENBQ3BDLElBQUlBLFVBQVVuQixLQUNWLE9BQU87SUFDZixPQUFPO0FBQ1g7QUFDQSwrREFBK0Q7QUFDL0Qsb0VBQW9FO0FBQ3BFLG1DQUFtQztBQUNuQyxTQUFTd0MsaUJBQWlCeE4sT0FBTztJQUM3QixJQUFJL0IsT0FBTytCLFFBQVFqQixJQUFJO0lBQ3ZCLElBQUkwTyxZQUFZeFAsS0FBS3lQLFVBQVUsQ0FBQ3pQLEtBQUtaLElBQUksR0FBR3dQLE9BQU81TyxLQUFLNk8sU0FBUztJQUNqRSxJQUFJLENBQUNXLFdBQ0QsT0FBTztJQUNYLElBQUlFLE1BQU0zTixRQUFRUixPQUFPLENBQUM0TCxhQUFhO0lBQ3ZDLElBQUl3QyxXQUFXNU4sUUFBUXZELEtBQUssQ0FBQ21CLEdBQUcsQ0FBQ2lOLE1BQU0sQ0FBQzRDLFVBQVVwUSxJQUFJO0lBQ3RELElBQUl3USxVQUFVRixPQUFPLFFBQVFBLE9BQU9DLFNBQVN2USxJQUFJLEdBQUd1USxTQUFTalEsRUFBRSxHQUFHaUgsS0FBS0MsR0FBRyxDQUFDK0ksU0FBU2pRLEVBQUUsRUFBRWdRO0lBQ3hGLElBQUssSUFBSWpSLE1BQU0rUSxVQUFVOVAsRUFBRSxHQUFJO1FBQzNCLElBQUkwRCxPQUFPcEQsS0FBS3lQLFVBQVUsQ0FBQ2hSO1FBQzNCLElBQUksQ0FBQzJFLFFBQVFBLFFBQVF3TCxNQUNqQixPQUFPO1FBQ1gsSUFBSSxDQUFDeEwsS0FBS3ZFLElBQUksQ0FBQ2dSLFNBQVMsRUFDcEIsT0FBT3pNLEtBQUtoRSxJQUFJLEdBQUd3USxVQUFVSixZQUFZO1FBQzdDL1EsTUFBTTJFLEtBQUsxRCxFQUFFO0lBQ2pCO0FBQ0o7QUFDQTs7Ozs7Ozs7OztBQVVBLEdBQ0EsU0FBU29RLGdCQUFnQixFQUFFQyxPQUFPLEVBQUVDLFFBQVEsSUFBSSxFQUFFQyxRQUFRLENBQUMsRUFBRTtJQUN6RCxPQUFPLENBQUNsTyxVQUFZZ04sa0JBQWtCaE4sU0FBU2lPLE9BQU9DLE9BQU9GO0FBQ2pFO0FBQ0EsU0FBU2hCLGtCQUFrQmhOLE9BQU8sRUFBRWlPLEtBQUssRUFBRUMsS0FBSyxFQUFFRixPQUFPLEVBQUVHLFFBQVE7SUFDL0QsSUFBSUMsUUFBUXBPLFFBQVFrTixTQUFTLEVBQUVtQixRQUFRRCxNQUFNRSxLQUFLLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQ3pRLE1BQU07SUFDcEUsSUFBSWtQLFNBQVNpQixXQUFXSSxNQUFNeE0sS0FBSyxDQUFDeU0sT0FBT0EsUUFBUUwsUUFBUW5RLE1BQU0sS0FBS21RLFdBQVdHLFlBQVluTyxRQUFRdEQsR0FBRyxHQUFHMlI7SUFDM0csSUFBSUUsVUFBVU4sUUFBUVQsaUJBQWlCeE4sV0FBVztJQUNsRCxJQUFJdU8sU0FDQSxPQUFPeEIsU0FBUy9NLFFBQVF1TCxNQUFNLENBQUNnRCxRQUFRbFIsSUFBSSxJQUFJMkMsUUFBUXVMLE1BQU0sQ0FBQ2dELFFBQVE1USxFQUFFO0lBQzVFLE9BQU9xQyxRQUFRbU4sVUFBVSxHQUFJSixDQUFBQSxTQUFTLElBQUkvTSxRQUFReUosSUFBSSxHQUFHeUUsS0FBSTtBQUNqRTtBQUNBOzs7QUFHQSxHQUNBLE1BQU1NLGFBQWEsQ0FBQ3hPLFVBQVlBLFFBQVFtTixVQUFVO0FBQ2xEOzs7Ozs7O0FBT0EsR0FDQSxTQUFTc0IsZ0JBQWdCLEVBQUVDLE1BQU0sRUFBRVIsUUFBUSxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUM7SUFDL0MsT0FBTyxDQUFDbE87UUFDSixJQUFJMk8sY0FBY0QsVUFBVUEsT0FBT25SLElBQUksQ0FBQ3lDLFFBQVFrTixTQUFTO1FBQ3pELE9BQU9sTixRQUFRbU4sVUFBVSxHQUFJd0IsQ0FBQUEsY0FBYyxJQUFJVCxRQUFRbE8sUUFBUXlKLElBQUk7SUFDdkU7QUFDSjtBQUNBLE1BQU1tRixtQkFBbUI7QUFDekI7Ozs7Ozs7Ozs7OztBQVlBLEdBQ0EsU0FBU0M7SUFDTCxPQUFPaFYsMERBQVdBLENBQUNpVixpQkFBaUIsQ0FBQ3ZTLEVBQUUsQ0FBQzBJLENBQUFBO1FBQ3BDLElBQUksQ0FBQ0EsR0FBR0MsVUFBVSxJQUFJLENBQUNELEdBQUc4SixXQUFXLENBQUMsaUJBQWlCLENBQUM5SixHQUFHOEosV0FBVyxDQUFDLG1CQUNuRSxPQUFPOUo7UUFDWCxJQUFJK0osUUFBUS9KLEdBQUdHLFVBQVUsQ0FBQzZKLGNBQWMsQ0FBQyxpQkFBaUJoSyxHQUFHRyxVQUFVLENBQUM4SixTQUFTLENBQUNDLElBQUksQ0FBQ0MsSUFBSTtRQUMzRixJQUFJLENBQUNKLE1BQU1uUixNQUFNLEVBQ2IsT0FBT29IO1FBQ1gsSUFBSXJILE1BQU1xSCxHQUFHb0ssTUFBTSxFQUFFLEVBQUVELElBQUksRUFBRSxHQUFHbkssR0FBR3FLLFlBQVksQ0FBQ0gsSUFBSSxFQUFFdkUsT0FBT2hOLElBQUlpTixNQUFNLENBQUN1RTtRQUN4RSxJQUFJQSxPQUFPeEUsS0FBS3ZOLElBQUksR0FBR3VSLGtCQUNuQixPQUFPM0o7UUFDWCxJQUFJc0ssWUFBWTNSLElBQUkrRCxXQUFXLENBQUNpSixLQUFLdk4sSUFBSSxFQUFFK1I7UUFDM0MsSUFBSSxDQUFDSixNQUFNNUYsSUFBSSxDQUFDOUssQ0FBQUEsSUFBS0EsRUFBRWYsSUFBSSxDQUFDZ1MsYUFDeEIsT0FBT3RLO1FBQ1gsSUFBSSxFQUFFeEksS0FBSyxFQUFFLEdBQUd3SSxJQUFJNEgsT0FBTyxDQUFDLEdBQUd0SixVQUFVLEVBQUU7UUFDM0MsS0FBSyxJQUFJLEVBQUU2TCxJQUFJLEVBQUUsSUFBSTNTLE1BQU15UyxTQUFTLENBQUN6TCxNQUFNLENBQUU7WUFDekMsSUFBSW1ILE9BQU9uTyxNQUFNbUIsR0FBRyxDQUFDaU4sTUFBTSxDQUFDdUU7WUFDNUIsSUFBSXhFLEtBQUt2TixJQUFJLElBQUl3UCxNQUNiO1lBQ0pBLE9BQU9qQyxLQUFLdk4sSUFBSTtZQUNoQixJQUFJeU4sU0FBU1YsZUFBZTNOLE9BQU9tTyxLQUFLdk4sSUFBSTtZQUM1QyxJQUFJeU4sVUFBVSxNQUNWO1lBQ0osSUFBSUUsTUFBTSxPQUFPaEMsSUFBSSxDQUFDNEIsS0FBS0csSUFBSSxDQUFDLENBQUMsRUFBRTtZQUNuQyxJQUFJRSxPQUFPaEIsYUFBYXhOLE9BQU9xTztZQUMvQixJQUFJRSxPQUFPQyxNQUNQMUgsUUFBUXJGLElBQUksQ0FBQztnQkFBRWIsTUFBTXVOLEtBQUt2TixJQUFJO2dCQUFFTSxJQUFJaU4sS0FBS3ZOLElBQUksR0FBRzJOLElBQUluTixNQUFNO2dCQUFFcU4sUUFBUUQ7WUFBSztRQUNqRjtRQUNBLE9BQU8xSCxRQUFRMUYsTUFBTSxHQUFHO1lBQUNvSDtZQUFJO2dCQUFFMUI7Z0JBQVNpTSxZQUFZO1lBQUs7U0FBRSxHQUFHdks7SUFDbEU7QUFDSjtBQUVBOzs7OztBQUtBLEdBQ0EsTUFBTXdLLGNBQWMsV0FBVyxHQUFFN1Ysb0RBQUtBLENBQUN1QixNQUFNO0FBQzdDOzs7OztBQUtBLEdBQ0EsTUFBTXVVLGVBQWUsV0FBVyxHQUFFLElBQUl2VyxtREFBUUE7QUFDOUM7Ozs7QUFJQSxHQUNBLFNBQVN3VyxXQUFXNVEsSUFBSTtJQUNwQixJQUFJME4sUUFBUTFOLEtBQUsyTixVQUFVLEVBQUVHLE9BQU85TixLQUFLK04sU0FBUztJQUNsRCxPQUFPTCxTQUFTQSxNQUFNOU8sRUFBRSxHQUFHa1AsS0FBS3hQLElBQUksR0FBRztRQUFFQSxNQUFNb1AsTUFBTTlPLEVBQUU7UUFBRUEsSUFBSWtQLEtBQUsvUCxJQUFJLENBQUM4UyxPQUFPLEdBQUc3USxLQUFLcEIsRUFBRSxHQUFHa1AsS0FBS3hQLElBQUk7SUFBQyxJQUFJO0FBQzdHO0FBQ0EsU0FBU3dTLGNBQWNwVCxLQUFLLEVBQUVrTyxLQUFLLEVBQUVtRixHQUFHO0lBQ3BDLElBQUk3UixPQUFPN0IsV0FBV0s7SUFDdEIsSUFBSXdCLEtBQUtKLE1BQU0sR0FBR2lTLEtBQ2QsT0FBTztJQUNYLElBQUkvRCxRQUFROU4sS0FBSytOLFlBQVksQ0FBQzhELEtBQUs7SUFDbkMsSUFBSXhHLFFBQVE7SUFDWixJQUFLLElBQUluSSxPQUFPNEssT0FBTzVLLE1BQU1BLE9BQU9BLEtBQUtFLElBQUksQ0FBRTtRQUMzQyxJQUFJMkosTUFBTTdKLEtBQUtwQyxJQUFJO1FBQ25CLElBQUlpTSxJQUFJck4sRUFBRSxJQUFJbVMsT0FBTzlFLElBQUkzTixJQUFJLEdBQUd5UyxLQUM1QjtRQUNKLElBQUl4RyxTQUFTMEIsSUFBSTNOLElBQUksR0FBR3NOLE9BQ3BCO1FBQ0osSUFBSTVOLE9BQU9pTyxJQUFJbE8sSUFBSSxDQUFDQyxJQUFJLENBQUMyUztRQUN6QixJQUFJM1MsUUFBU2lPLENBQUFBLElBQUlyTixFQUFFLEdBQUdNLEtBQUtKLE1BQU0sR0FBRyxNQUFNSSxLQUFLSixNQUFNLElBQUlwQixNQUFNbUIsR0FBRyxDQUFDQyxNQUFNLElBQUksQ0FBQ2tTLGFBQWEvRSxJQUFHLEdBQUk7WUFDOUYsSUFBSTFKLFFBQVF2RSxLQUFLaU8sS0FBS3ZPO1lBQ3RCLElBQUk2RSxTQUFTQSxNQUFNakUsSUFBSSxJQUFJeVMsT0FBT3hPLE1BQU1qRSxJQUFJLElBQUlzTixTQUFTckosTUFBTTNELEVBQUUsR0FBR21TLEtBQ2hFeEcsUUFBUWhJO1FBQ2hCO0lBQ0o7SUFDQSxPQUFPZ0k7QUFDWDtBQUNBLFNBQVN5RyxhQUFhaFIsSUFBSTtJQUN0QixJQUFJTCxLQUFLSyxLQUFLK04sU0FBUztJQUN2QixPQUFPcE8sTUFBTUEsR0FBR2YsRUFBRSxJQUFJb0IsS0FBS3BCLEVBQUUsSUFBSWUsR0FBRzVCLElBQUksQ0FBQzhTLE9BQU87QUFDcEQ7QUFDQTs7Ozs7OztBQU9BLEdBQ0EsU0FBU0ksU0FBU3ZULEtBQUssRUFBRThTLFNBQVMsRUFBRTFCLE9BQU87SUFDdkMsS0FBSyxJQUFJdkQsV0FBVzdOLE1BQU1RLEtBQUssQ0FBQ3dTLGFBQWM7UUFDMUMsSUFBSTFSLFNBQVN1TSxRQUFRN04sT0FBTzhTLFdBQVcxQjtRQUN2QyxJQUFJOVAsUUFDQSxPQUFPQTtJQUNmO0lBQ0EsT0FBTzhSLGNBQWNwVCxPQUFPOFMsV0FBVzFCO0FBQzNDO0FBQ0EsU0FBU29DLFNBQVNDLEtBQUssRUFBRUMsT0FBTztJQUM1QixJQUFJOVMsT0FBTzhTLFFBQVFuTSxNQUFNLENBQUNrTSxNQUFNN1MsSUFBSSxFQUFFLElBQUlNLEtBQUt3UyxRQUFRbk0sTUFBTSxDQUFDa00sTUFBTXZTLEVBQUUsRUFBRSxDQUFDO0lBQ3pFLE9BQU9OLFFBQVFNLEtBQUtwQyxZQUFZO1FBQUU4QjtRQUFNTTtJQUFHO0FBQy9DO0FBQ0E7Ozs7OztBQU1BLEdBQ0EsTUFBTXlTLGFBQWEsV0FBVyxHQUFFMVcsMERBQVdBLENBQUN5QixNQUFNLENBQUM7SUFBRXNOLEtBQUt3SDtBQUFTO0FBQ25FOztBQUVBLEdBQ0EsTUFBTUksZUFBZSxXQUFXLEdBQUUzVywwREFBV0EsQ0FBQ3lCLE1BQU0sQ0FBQztJQUFFc04sS0FBS3dIO0FBQVM7QUFDckUsU0FBU0ssY0FBYzlQLElBQUk7SUFDdkIsSUFBSStQLFFBQVEsRUFBRTtJQUNkLEtBQUssSUFBSSxFQUFFbkIsSUFBSSxFQUFFLElBQUk1TyxLQUFLL0QsS0FBSyxDQUFDeVMsU0FBUyxDQUFDekwsTUFBTSxDQUFFO1FBQzlDLElBQUk4TSxNQUFNbkgsSUFBSSxDQUFDb0gsQ0FBQUEsSUFBS0EsRUFBRW5ULElBQUksSUFBSStSLFFBQVFvQixFQUFFN1MsRUFBRSxJQUFJeVIsT0FDMUM7UUFDSm1CLE1BQU1yUyxJQUFJLENBQUNzQyxLQUFLaVEsV0FBVyxDQUFDckI7SUFDaEM7SUFDQSxPQUFPbUI7QUFDWDtBQUNBOzs7Ozs7QUFNQSxHQUNBLE1BQU1HLFlBQVksV0FBVyxHQUFFL1cseURBQVVBLENBQUN3QixNQUFNLENBQUM7SUFDN0NpSDtRQUNJLE9BQU85SCx3REFBVUEsQ0FBQ3FLLElBQUk7SUFDMUI7SUFDQWMsUUFBT2tMLE1BQU0sRUFBRTFMLEVBQUU7UUFDYjBMLFNBQVNBLE9BQU9sSSxHQUFHLENBQUN4RCxHQUFHMUIsT0FBTztRQUM5QixLQUFLLElBQUltQyxLQUFLVCxHQUFHVSxPQUFPLENBQUU7WUFDdEIsSUFBSUQsRUFBRUUsRUFBRSxDQUFDd0ssZUFBZSxDQUFDUSxXQUFXRCxRQUFRakwsRUFBRXBFLEtBQUssQ0FBQ2pFLElBQUksRUFBRXFJLEVBQUVwRSxLQUFLLENBQUMzRCxFQUFFLEdBQUc7Z0JBQ25FLElBQUksRUFBRWtULGtCQUFrQixFQUFFLEdBQUc1TCxHQUFHeEksS0FBSyxDQUFDUSxLQUFLLENBQUM2VDtnQkFDNUMsSUFBSUMsU0FBUyxDQUFDRixxQkFBcUJHLGFBQy9CMVcsd0RBQVVBLENBQUMyVyxPQUFPLENBQUM7b0JBQUVGLFFBQVEsSUFBSUcsbUJBQW1CTCxtQkFBbUI1TCxHQUFHeEksS0FBSyxFQUFFaUosRUFBRXBFLEtBQUs7Z0JBQUc7Z0JBQy9GcVAsU0FBU0EsT0FBT2xMLE1BQU0sQ0FBQztvQkFBRWxHLEtBQUs7d0JBQUN3UixPQUFPYixLQUFLLENBQUN4SyxFQUFFcEUsS0FBSyxDQUFDakUsSUFBSSxFQUFFcUksRUFBRXBFLEtBQUssQ0FBQzNELEVBQUU7cUJBQUU7Z0JBQUM7WUFDM0UsT0FDSyxJQUFJK0gsRUFBRUUsRUFBRSxDQUFDeUssZUFBZTtnQkFDekJNLFNBQVNBLE9BQU9sTCxNQUFNLENBQUM7b0JBQUUwTCxRQUFRLENBQUM5VCxNQUFNTSxLQUFPK0gsRUFBRXBFLEtBQUssQ0FBQ2pFLElBQUksSUFBSUEsUUFBUXFJLEVBQUVwRSxLQUFLLENBQUMzRCxFQUFFLElBQUlBO29CQUNqRnlULFlBQVkxTCxFQUFFcEUsS0FBSyxDQUFDakUsSUFBSTtvQkFBRWdVLFVBQVUzTCxFQUFFcEUsS0FBSyxDQUFDM0QsRUFBRTtnQkFBQztZQUN2RDtRQUNKO1FBQ0Esb0RBQW9EO1FBQ3BELElBQUlzSCxHQUFHaUssU0FBUyxFQUFFO1lBQ2QsSUFBSW9DLGNBQWMsT0FBTyxFQUFFbEMsSUFBSSxFQUFFLEdBQUduSyxHQUFHaUssU0FBUyxDQUFDQyxJQUFJO1lBQ3JEd0IsT0FBT1ksT0FBTyxDQUFDbkMsTUFBTUEsTUFBTSxDQUFDL0YsR0FBR21JO2dCQUFRLElBQUluSSxJQUFJK0YsUUFBUW9DLElBQUlwQyxNQUN2RGtDLGNBQWM7WUFBTTtZQUN4QixJQUFJQSxhQUNBWCxTQUFTQSxPQUFPbEwsTUFBTSxDQUFDO2dCQUNuQjJMLFlBQVloQztnQkFDWmlDLFVBQVVqQztnQkFDVitCLFFBQVEsQ0FBQzlILEdBQUdtSSxJQUFNQSxLQUFLcEMsUUFBUS9GLEtBQUsrRjtZQUN4QztRQUNSO1FBQ0EsT0FBT3VCO0lBQ1g7SUFDQWMsU0FBU3RPLENBQUFBLElBQUs5SSx3REFBVUEsQ0FBQ3FYLFdBQVcsQ0FBQ3JVLElBQUksQ0FBQzhGO0lBQzFDd08sUUFBT2hCLE1BQU0sRUFBRWxVLEtBQUs7UUFDaEIsSUFBSWdILFNBQVMsRUFBRTtRQUNma04sT0FBT1ksT0FBTyxDQUFDLEdBQUc5VSxNQUFNbUIsR0FBRyxDQUFDQyxNQUFNLEVBQUUsQ0FBQ1IsTUFBTU07WUFBUzhGLE9BQU92RixJQUFJLENBQUNiLE1BQU1NO1FBQUs7UUFDM0UsT0FBTzhGO0lBQ1g7SUFDQW1PLFVBQVN0USxLQUFLO1FBQ1YsSUFBSSxDQUFDb0ksTUFBTW1JLE9BQU8sQ0FBQ3ZRLFVBQVVBLE1BQU16RCxNQUFNLEdBQUcsR0FDeEMsTUFBTSxJQUFJMkssV0FBVztRQUN6QixJQUFJL0UsU0FBUyxFQUFFO1FBQ2YsSUFBSyxJQUFJakYsSUFBSSxHQUFHQSxJQUFJOEMsTUFBTXpELE1BQU0sRUFBRztZQUMvQixJQUFJUixPQUFPaUUsS0FBSyxDQUFDOUMsSUFBSSxFQUFFYixLQUFLMkQsS0FBSyxDQUFDOUMsSUFBSTtZQUN0QyxJQUFJLE9BQU9uQixRQUFRLFlBQVksT0FBT00sTUFBTSxVQUN4QyxNQUFNLElBQUk2SyxXQUFXO1lBQ3pCL0UsT0FBT3ZGLElBQUksQ0FBQzhTLFdBQVdkLEtBQUssQ0FBQzdTLE1BQU1NO1FBQ3ZDO1FBQ0EsT0FBT3JELHdEQUFVQSxDQUFDd1gsR0FBRyxDQUFDck8sUUFBUTtJQUNsQztBQUNKO0FBQ0E7OztBQUdBLEdBQ0EsU0FBU3NPLGFBQWF0VixLQUFLO0lBQ3ZCLE9BQU9BLE1BQU1pRCxLQUFLLENBQUNnUixXQUFXLFVBQVUxVyx1REFBUUEsQ0FBQzJGLEtBQUs7QUFDMUQ7QUFDQSxTQUFTcVMsU0FBU3ZWLEtBQUssRUFBRVksSUFBSSxFQUFFTSxFQUFFO0lBQzdCLElBQUk1QztJQUNKLElBQUl1TyxRQUFRO0lBQ1h2TyxDQUFBQSxLQUFLMEIsTUFBTWlELEtBQUssQ0FBQ2dSLFdBQVcsTUFBSyxNQUFPLFFBQVEzVixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUd3VyxPQUFPLENBQUNsVSxNQUFNTSxJQUFJLENBQUNOLE1BQU1NO1FBQ2xHLElBQUksQ0FBQzJMLFNBQVNBLE1BQU1qTSxJQUFJLEdBQUdBLE1BQ3ZCaU0sUUFBUTtZQUFFak07WUFBTU07UUFBRztJQUMzQjtJQUNBLE9BQU8yTDtBQUNYO0FBQ0EsU0FBU3NILFdBQVdELE1BQU0sRUFBRXRULElBQUksRUFBRU0sRUFBRTtJQUNoQyxJQUFJMkwsUUFBUTtJQUNacUgsT0FBT1ksT0FBTyxDQUFDbFUsTUFBTUEsTUFBTSxDQUFDZ00sR0FBR21JO1FBQVEsSUFBSW5JLEtBQUtoTSxRQUFRbVUsS0FBSzdULElBQ3pEMkwsUUFBUTtJQUFNO0lBQ2xCLE9BQU9BO0FBQ1g7QUFDQSxTQUFTMkksWUFBWXhWLEtBQUssRUFBRXlWLEtBQUs7SUFDN0IsT0FBT3pWLE1BQU1pRCxLQUFLLENBQUNnUixXQUFXLFNBQVN3QixRQUFRQSxNQUFNNVcsTUFBTSxDQUFDNUIsMERBQVdBLENBQUN5WSxZQUFZLENBQUM1VixFQUFFLENBQUM2VjtBQUM1RjtBQUNBOztBQUVBLEdBQ0EsTUFBTUMsV0FBVzdSLENBQUFBO0lBQ2IsS0FBSyxJQUFJb0ssUUFBUTBGLGNBQWM5UCxNQUFPO1FBQ2xDLElBQUkwUCxRQUFRRixTQUFTeFAsS0FBSy9ELEtBQUssRUFBRW1PLEtBQUt2TixJQUFJLEVBQUV1TixLQUFLak4sRUFBRTtRQUNuRCxJQUFJdVMsT0FBTztZQUNQMVAsS0FBS0UsUUFBUSxDQUFDO2dCQUFFaUYsU0FBU3NNLFlBQVl6UixLQUFLL0QsS0FBSyxFQUFFO29CQUFDMlQsV0FBVzdULEVBQUUsQ0FBQzJUO29CQUFRb0MsYUFBYTlSLE1BQU0wUDtpQkFBTztZQUFFO1lBQ3BHLE9BQU87UUFDWDtJQUNKO0lBQ0EsT0FBTztBQUNYO0FBQ0E7O0FBRUEsR0FDQSxNQUFNcUMsYUFBYS9SLENBQUFBO0lBQ2YsSUFBSSxDQUFDQSxLQUFLL0QsS0FBSyxDQUFDaUQsS0FBSyxDQUFDZ1IsV0FBVyxRQUM3QixPQUFPO0lBQ1gsSUFBSS9LLFVBQVUsRUFBRTtJQUNoQixLQUFLLElBQUlpRixRQUFRMEYsY0FBYzlQLE1BQU87UUFDbEMsSUFBSW1RLFNBQVNxQixTQUFTeFIsS0FBSy9ELEtBQUssRUFBRW1PLEtBQUt2TixJQUFJLEVBQUV1TixLQUFLak4sRUFBRTtRQUNwRCxJQUFJZ1QsUUFDQWhMLFFBQVF6SCxJQUFJLENBQUNtUyxhQUFhOVQsRUFBRSxDQUFDb1UsU0FBUzJCLGFBQWE5UixNQUFNbVEsUUFBUTtJQUN6RTtJQUNBLElBQUloTCxRQUFROUgsTUFBTSxFQUNkMkMsS0FBS0UsUUFBUSxDQUFDO1FBQUVpRjtJQUFRO0lBQzVCLE9BQU9BLFFBQVE5SCxNQUFNLEdBQUc7QUFDNUI7QUFDQSxTQUFTeVUsYUFBYTlSLElBQUksRUFBRTBQLEtBQUssRUFBRXNDLE9BQU8sSUFBSTtJQUMxQyxJQUFJQyxXQUFXalMsS0FBSy9ELEtBQUssQ0FBQ21CLEdBQUcsQ0FBQ2lOLE1BQU0sQ0FBQ3FGLE1BQU03UyxJQUFJLEVBQUVxVixNQUFNLEVBQUVDLFNBQVNuUyxLQUFLL0QsS0FBSyxDQUFDbUIsR0FBRyxDQUFDaU4sTUFBTSxDQUFDcUYsTUFBTXZTLEVBQUUsRUFBRStVLE1BQU07SUFDeEcsT0FBT3JZLHdEQUFVQSxDQUFDdVksUUFBUSxDQUFDclcsRUFBRSxDQUFDLENBQUMsRUFBRWlFLEtBQUsvRCxLQUFLLENBQUNvVyxNQUFNLENBQUNMLE9BQU8saUJBQWlCLGtCQUFrQixDQUFDLEVBQUVDLFNBQVMsQ0FBQyxFQUFFalMsS0FBSy9ELEtBQUssQ0FBQ29XLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRUYsT0FBTyxDQUFDLENBQUM7QUFDcEo7QUFDQTs7Ozs7Ozs7QUFRQSxHQUNBLE1BQU1HLFVBQVV0UyxDQUFBQTtJQUNaLElBQUksRUFBRS9ELEtBQUssRUFBRSxHQUFHK0QsTUFBTW1GLFVBQVUsRUFBRTtJQUNsQyxJQUFLLElBQUlqSixNQUFNLEdBQUdBLE1BQU1ELE1BQU1tQixHQUFHLENBQUNDLE1BQU0sRUFBRztRQUN2QyxJQUFJK00sT0FBT3BLLEtBQUtpUSxXQUFXLENBQUMvVCxNQUFNd1QsUUFBUUYsU0FBU3ZULE9BQU9tTyxLQUFLdk4sSUFBSSxFQUFFdU4sS0FBS2pOLEVBQUU7UUFDNUUsSUFBSXVTLE9BQ0F2SyxRQUFRekgsSUFBSSxDQUFDa1MsV0FBVzdULEVBQUUsQ0FBQzJUO1FBQy9CeFQsTUFBTSxDQUFDd1QsUUFBUTFQLEtBQUtpUSxXQUFXLENBQUNQLE1BQU12UyxFQUFFLElBQUlpTixJQUFHLEVBQUdqTixFQUFFLEdBQUc7SUFDM0Q7SUFDQSxJQUFJZ0ksUUFBUTlILE1BQU0sRUFDZDJDLEtBQUtFLFFBQVEsQ0FBQztRQUFFaUYsU0FBU3NNLFlBQVl6UixLQUFLL0QsS0FBSyxFQUFFa0o7SUFBUztJQUM5RCxPQUFPLENBQUMsQ0FBQ0EsUUFBUTlILE1BQU07QUFDM0I7QUFDQTs7QUFFQSxHQUNBLE1BQU1rVixZQUFZdlMsQ0FBQUE7SUFDZCxJQUFJZCxRQUFRYyxLQUFLL0QsS0FBSyxDQUFDaUQsS0FBSyxDQUFDZ1IsV0FBVztJQUN4QyxJQUFJLENBQUNoUixTQUFTLENBQUNBLE1BQU1uQixJQUFJLEVBQ3JCLE9BQU87SUFDWCxJQUFJb0gsVUFBVSxFQUFFO0lBQ2hCakcsTUFBTTZSLE9BQU8sQ0FBQyxHQUFHL1EsS0FBSy9ELEtBQUssQ0FBQ21CLEdBQUcsQ0FBQ0MsTUFBTSxFQUFFLENBQUNSLE1BQU1NO1FBQVNnSSxRQUFRekgsSUFBSSxDQUFDbVMsYUFBYTlULEVBQUUsQ0FBQztZQUFFYztZQUFNTTtRQUFHO0lBQUs7SUFDckc2QyxLQUFLRSxRQUFRLENBQUM7UUFBRWlGO0lBQVE7SUFDeEIsT0FBTztBQUNYO0FBQ0Esb0VBQW9FO0FBQ3BFLFNBQVNxTixrQkFBa0J4UyxJQUFJLEVBQUV5UyxTQUFTO0lBQ3RDLDBFQUEwRTtJQUMxRSwyQkFBMkI7SUFDM0IsSUFBSyxJQUFJckksT0FBT3FJLFlBQWE7UUFDekIsSUFBSUMsaUJBQWlCbEQsU0FBU3hQLEtBQUsvRCxLQUFLLEVBQUVtTyxLQUFLdk4sSUFBSSxFQUFFdU4sS0FBS2pOLEVBQUU7UUFDNUQsSUFBSXVWLGtCQUFrQkEsZUFBZXZWLEVBQUUsR0FBR3NWLFVBQVU1VixJQUFJLEVBQ3BELE9BQU82VjtRQUNYLElBQUksQ0FBQ3RJLEtBQUt2TixJQUFJLEVBQ1YsT0FBTztRQUNYdU4sT0FBT3BLLEtBQUtpUSxXQUFXLENBQUM3RixLQUFLdk4sSUFBSSxHQUFHO0lBQ3hDO0FBQ0o7QUFDQTs7OztBQUlBLEdBQ0EsTUFBTThWLGFBQWEsQ0FBQzNTO0lBQ2hCLElBQUltRixVQUFVLEVBQUU7SUFDaEIsS0FBSyxJQUFJaUYsUUFBUTBGLGNBQWM5UCxNQUFPO1FBQ2xDLElBQUltUSxTQUFTcUIsU0FBU3hSLEtBQUsvRCxLQUFLLEVBQUVtTyxLQUFLdk4sSUFBSSxFQUFFdU4sS0FBS2pOLEVBQUU7UUFDcEQsSUFBSWdULFFBQVE7WUFDUmhMLFFBQVF6SCxJQUFJLENBQUNtUyxhQUFhOVQsRUFBRSxDQUFDb1UsU0FBUzJCLGFBQWE5UixNQUFNbVEsUUFBUTtRQUNyRSxPQUNLO1lBQ0QsSUFBSXlDLFlBQVlKLGtCQUFrQnhTLE1BQU1vSztZQUN4QyxJQUFJd0ksV0FDQXpOLFFBQVF6SCxJQUFJLENBQUNrUyxXQUFXN1QsRUFBRSxDQUFDNlcsWUFBWWQsYUFBYTlSLE1BQU00UztRQUNsRTtJQUNKO0lBQ0EsSUFBSXpOLFFBQVE5SCxNQUFNLEdBQUcsR0FDakIyQyxLQUFLRSxRQUFRLENBQUM7UUFBRWlGLFNBQVNzTSxZQUFZelIsS0FBSy9ELEtBQUssRUFBRWtKO0lBQVM7SUFDOUQsT0FBTyxDQUFDLENBQUNBLFFBQVE5SCxNQUFNO0FBQzNCO0FBQ0E7Ozs7Ozs7QUFPQSxHQUNBLE1BQU13VixhQUFhO0lBQ2Y7UUFBRUMsS0FBSztRQUFnQkMsS0FBSztRQUFhQyxLQUFLbkI7SUFBUztJQUN2RDtRQUFFaUIsS0FBSztRQUFnQkMsS0FBSztRQUFhQyxLQUFLakI7SUFBVztJQUN6RDtRQUFFZSxLQUFLO1FBQWNFLEtBQUtWO0lBQVE7SUFDbEM7UUFBRVEsS0FBSztRQUFjRSxLQUFLVDtJQUFVO0NBQ3ZDO0FBQ0QsTUFBTVUsZ0JBQWdCO0lBQ2xCQyxnQkFBZ0I7SUFDaEI3QyxvQkFBb0I7SUFDcEI4QyxpQkFBaUI7QUFDckI7QUFDQSxNQUFNN0MsYUFBYSxXQUFXLEdBQUVsWCxvREFBS0EsQ0FBQ3VCLE1BQU0sQ0FBQztJQUN6Q0MsU0FBUUMsTUFBTTtRQUFJLE9BQU90QixnRUFBYUEsQ0FBQ3NCLFFBQVFvWTtJQUFnQjtBQUNuRTtBQUNBOztBQUVBLEdBQ0EsU0FBU3JCLFlBQVl3QixNQUFNO0lBQ3ZCLElBQUk3VixTQUFTO1FBQUMyUztRQUFXbUQ7S0FBWTtJQUNyQyxJQUFJRCxRQUNBN1YsT0FBT0csSUFBSSxDQUFDNFMsV0FBV3ZVLEVBQUUsQ0FBQ3FYO0lBQzlCLE9BQU83VjtBQUNYO0FBQ0EsU0FBUytWLFlBQVl0VCxJQUFJLEVBQUV1VCxRQUFRO0lBQy9CLElBQUksRUFBRXRYLEtBQUssRUFBRSxHQUFHK0QsTUFBTXdULE9BQU92WCxNQUFNUSxLQUFLLENBQUM2VDtJQUN6QyxJQUFJbUQsVUFBVSxDQUFDQztRQUNYLElBQUl0SixPQUFPcEssS0FBS2lRLFdBQVcsQ0FBQ2pRLEtBQUsyVCxRQUFRLENBQUNELE1BQU1FLE1BQU07UUFDdEQsSUFBSXpELFNBQVNxQixTQUFTeFIsS0FBSy9ELEtBQUssRUFBRW1PLEtBQUt2TixJQUFJLEVBQUV1TixLQUFLak4sRUFBRTtRQUNwRCxJQUFJZ1QsUUFDQW5RLEtBQUtFLFFBQVEsQ0FBQztZQUFFaUYsU0FBUzBLLGFBQWE5VCxFQUFFLENBQUNvVTtRQUFRO1FBQ3JEdUQsTUFBTUcsY0FBYztJQUN4QjtJQUNBLElBQUlMLEtBQUtOLGNBQWMsRUFDbkIsT0FBT00sS0FBS04sY0FBYyxDQUFDbFQsTUFBTXlULFNBQVNGO0lBQzlDLElBQUlPLFVBQVVDLFNBQVNDLGFBQWEsQ0FBQztJQUNyQ0YsUUFBUUcsV0FBVyxHQUFHVCxLQUFLTCxlQUFlO0lBQzFDVyxRQUFRSSxZQUFZLENBQUMsY0FBY2pZLE1BQU1vVyxNQUFNLENBQUM7SUFDaER5QixRQUFRSyxLQUFLLEdBQUdsWSxNQUFNb1csTUFBTSxDQUFDO0lBQzdCeUIsUUFBUU0sU0FBUyxHQUFHO0lBQ3BCTixRQUFRTCxPQUFPLEdBQUdBO0lBQ2xCLE9BQU9LO0FBQ1g7QUFDQSxNQUFNdEQsYUFBYSxXQUFXLEdBQUUxVyx3REFBVUEsQ0FBQzJXLE9BQU8sQ0FBQztJQUFFRixRQUFRLFdBQVcsR0FBRSxJQUFJLGNBQWN4Vyx3REFBVUE7UUFDOUZzYSxNQUFNclUsSUFBSSxFQUFFO1lBQUUsT0FBT3NULFlBQVl0VCxNQUFNO1FBQU87SUFDbEQ7QUFBRTtBQUNOLE1BQU0wUSwyQkFBMkIzVyx3REFBVUE7SUFDdkNtQixZQUFZNEYsS0FBSyxDQUFFO1FBQ2YsS0FBSztRQUNMLElBQUksQ0FBQ0EsS0FBSyxHQUFHQTtJQUNqQjtJQUNBd1QsR0FBRzVDLEtBQUssRUFBRTtRQUFFLE9BQU8sSUFBSSxDQUFDNVEsS0FBSyxJQUFJNFEsTUFBTTVRLEtBQUs7SUFBRTtJQUM5Q3VULE1BQU1yVSxJQUFJLEVBQUU7UUFBRSxPQUFPc1QsWUFBWXRULE1BQU0sSUFBSSxDQUFDYyxLQUFLO0lBQUc7QUFDeEQ7QUFDQSxNQUFNeVQscUJBQXFCO0lBQ3ZCQyxVQUFVO0lBQ1ZDLFlBQVk7SUFDWkMsV0FBVztJQUNYQyxrQkFBa0IsQ0FBQztJQUNuQkMsZ0JBQWdCLElBQU07QUFDMUI7QUFDQSxNQUFNQyxtQkFBbUI1YSwwREFBWUE7SUFDakNpQixZQUFZa1ksTUFBTSxFQUFFMEIsSUFBSSxDQUFFO1FBQ3RCLEtBQUs7UUFDTCxJQUFJLENBQUMxQixNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDMEIsSUFBSSxHQUFHQTtJQUNoQjtJQUNBUixHQUFHNUMsS0FBSyxFQUFFO1FBQUUsT0FBTyxJQUFJLENBQUMwQixNQUFNLElBQUkxQixNQUFNMEIsTUFBTSxJQUFJLElBQUksQ0FBQzBCLElBQUksSUFBSXBELE1BQU1vRCxJQUFJO0lBQUU7SUFDM0VULE1BQU1yVSxJQUFJLEVBQUU7UUFDUixJQUFJLElBQUksQ0FBQ29ULE1BQU0sQ0FBQ3NCLFNBQVMsRUFDckIsT0FBTyxJQUFJLENBQUN0QixNQUFNLENBQUNzQixTQUFTLENBQUMsSUFBSSxDQUFDSSxJQUFJO1FBQzFDLElBQUlDLE9BQU9oQixTQUFTQyxhQUFhLENBQUM7UUFDbENlLEtBQUtkLFdBQVcsR0FBRyxJQUFJLENBQUNhLElBQUksR0FBRyxJQUFJLENBQUMxQixNQUFNLENBQUNvQixRQUFRLEdBQUcsSUFBSSxDQUFDcEIsTUFBTSxDQUFDcUIsVUFBVTtRQUM1RU0sS0FBS1osS0FBSyxHQUFHblUsS0FBSy9ELEtBQUssQ0FBQ29XLE1BQU0sQ0FBQyxJQUFJLENBQUN5QyxJQUFJLEdBQUcsY0FBYztRQUN6RCxPQUFPQztJQUNYO0FBQ0o7QUFDQTs7OztBQUlBLEdBQ0EsU0FBU0MsV0FBVzVCLFNBQVMsQ0FBQyxDQUFDO0lBQzNCLElBQUk2QixhQUFheFosT0FBT3laLE1BQU0sQ0FBQ3paLE9BQU95WixNQUFNLENBQUMsQ0FBQyxHQUFHWCxxQkFBcUJuQjtJQUN0RSxJQUFJK0IsVUFBVSxJQUFJTixXQUFXSSxZQUFZLE9BQU9HLFlBQVksSUFBSVAsV0FBV0ksWUFBWTtJQUN2RixJQUFJSSxVQUFVMWIsd0RBQVVBLENBQUNvTSxTQUFTLENBQUM7UUFDL0I3SyxZQUFZOEUsSUFBSSxDQUFFO1lBQ2QsSUFBSSxDQUFDbkQsSUFBSSxHQUFHbUQsS0FBS04sUUFBUSxDQUFDN0MsSUFBSTtZQUM5QixJQUFJLENBQUN3WSxPQUFPLEdBQUcsSUFBSSxDQUFDQyxZQUFZLENBQUN0VjtRQUNyQztRQUNBaUYsT0FBT0EsTUFBTSxFQUFFO1lBQ1gsSUFBSUEsT0FBT1AsVUFBVSxJQUFJTyxPQUFPc1EsZUFBZSxJQUMzQ3RRLE9BQU9MLFVBQVUsQ0FBQ25JLEtBQUssQ0FBQ1gsYUFBYW1KLE9BQU9oSixLQUFLLENBQUNRLEtBQUssQ0FBQ1gsYUFDeERtSixPQUFPTCxVQUFVLENBQUMxRixLQUFLLENBQUNnUixXQUFXLFVBQVVqTCxPQUFPaEosS0FBSyxDQUFDaUQsS0FBSyxDQUFDZ1IsV0FBVyxVQUMzRXRVLFdBQVdxSixPQUFPTCxVQUFVLEtBQUtoSixXQUFXcUosT0FBT2hKLEtBQUssS0FDeERnWixXQUFXTCxjQUFjLENBQUMzUCxTQUMxQixJQUFJLENBQUNvUSxPQUFPLEdBQUcsSUFBSSxDQUFDQyxZQUFZLENBQUNyUSxPQUFPakYsSUFBSTtRQUNwRDtRQUNBc1YsYUFBYXRWLElBQUksRUFBRTtZQUNmLElBQUl3VixVQUFVLElBQUkvYiw4REFBZUE7WUFDakMsS0FBSyxJQUFJMlEsUUFBUXBLLEtBQUt5VixrQkFBa0IsQ0FBRTtnQkFDdEMsSUFBSUMsT0FBT2xFLFNBQVN4UixLQUFLL0QsS0FBSyxFQUFFbU8sS0FBS3ZOLElBQUksRUFBRXVOLEtBQUtqTixFQUFFLElBQUlpWSxZQUNoRDVGLFNBQVN4UCxLQUFLL0QsS0FBSyxFQUFFbU8sS0FBS3ZOLElBQUksRUFBRXVOLEtBQUtqTixFQUFFLElBQUlnWSxVQUFVO2dCQUMzRCxJQUFJTyxNQUNBRixRQUFRelcsR0FBRyxDQUFDcUwsS0FBS3ZOLElBQUksRUFBRXVOLEtBQUt2TixJQUFJLEVBQUU2WTtZQUMxQztZQUNBLE9BQU9GLFFBQVFHLE1BQU07UUFDekI7SUFDSjtJQUNBLElBQUksRUFBRWhCLGdCQUFnQixFQUFFLEdBQUdNO0lBQzNCLE9BQU87UUFDSEk7UUFDQXJiLHdEQUFNQSxDQUFDO1lBQ0g0YixPQUFPO1lBQ1BQLFNBQVFyVixJQUFJO2dCQUFJLElBQUl6RjtnQkFBSSxPQUFPLENBQUMsQ0FBQ0EsS0FBS3lGLEtBQUtJLE1BQU0sQ0FBQ2lWLFFBQU8sTUFBTyxRQUFROWEsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHOGEsT0FBTyxLQUFLN2IsdURBQVFBLENBQUMyRixLQUFLO1lBQUU7WUFDaEkwVztnQkFDSSxPQUFPLElBQUloQixXQUFXSSxZQUFZO1lBQ3RDO1lBQ0FOLGtCQUFrQmxaLE9BQU95WixNQUFNLENBQUN6WixPQUFPeVosTUFBTSxDQUFDLENBQUMsR0FBR1AsbUJBQW1CO2dCQUFFbUIsT0FBTyxDQUFDOVYsTUFBTW9LLE1BQU1zSjtvQkFDbkYsSUFBSWlCLGlCQUFpQm1CLEtBQUssSUFBSW5CLGlCQUFpQm1CLEtBQUssQ0FBQzlWLE1BQU1vSyxNQUFNc0osUUFDN0QsT0FBTztvQkFDWCxJQUFJdkQsU0FBU3FCLFNBQVN4UixLQUFLL0QsS0FBSyxFQUFFbU8sS0FBS3ZOLElBQUksRUFBRXVOLEtBQUtqTixFQUFFO29CQUNwRCxJQUFJZ1QsUUFBUTt3QkFDUm5RLEtBQUtFLFFBQVEsQ0FBQzs0QkFBRWlGLFNBQVMwSyxhQUFhOVQsRUFBRSxDQUFDb1U7d0JBQVE7d0JBQ2pELE9BQU87b0JBQ1g7b0JBQ0EsSUFBSVQsUUFBUUYsU0FBU3hQLEtBQUsvRCxLQUFLLEVBQUVtTyxLQUFLdk4sSUFBSSxFQUFFdU4sS0FBS2pOLEVBQUU7b0JBQ25ELElBQUl1UyxPQUFPO3dCQUNQMVAsS0FBS0UsUUFBUSxDQUFDOzRCQUFFaUYsU0FBU3lLLFdBQVc3VCxFQUFFLENBQUMyVDt3QkFBTzt3QkFDOUMsT0FBTztvQkFDWDtvQkFDQSxPQUFPO2dCQUNYO1lBQUU7UUFDVjtRQUNBa0M7S0FDSDtBQUNMO0FBQ0EsTUFBTXlCLGNBQWMsV0FBVyxHQUFFeFosd0RBQVVBLENBQUNrYyxTQUFTLENBQUM7SUFDbEQsdUJBQXVCO1FBQ25CQyxpQkFBaUI7UUFDakJDLFFBQVE7UUFDUkMsT0FBTztRQUNQQyxjQUFjO1FBQ2RDLFFBQVE7UUFDUkMsU0FBUztRQUNUM1YsUUFBUTtJQUNaO0lBQ0EsdUJBQXVCO1FBQ25CMlYsU0FBUztRQUNUM1YsUUFBUTtJQUNaO0FBQ0o7QUFFQTs7O0FBR0EsR0FDQSxNQUFNNFY7SUFDRnBiLFlBQ0E7O0lBRUEsR0FDQXFiLEtBQUssRUFBRXZYLE9BQU8sQ0FBRTtRQUNaLElBQUksQ0FBQ3VYLEtBQUssR0FBR0E7UUFDYixJQUFJQztRQUNKLFNBQVNDLElBQUk3WCxJQUFJO1lBQ2IsSUFBSThYLE1BQU1wYyxrREFBV0EsQ0FBQ3FjLE9BQU87WUFDNUJILENBQUFBLFdBQVlBLENBQUFBLFVBQVUvYSxPQUFPbUcsTUFBTSxDQUFDLEtBQUksQ0FBQyxDQUFFLENBQUMsTUFBTThVLElBQUksR0FBRzlYO1lBQzFELE9BQU84WDtRQUNYO1FBQ0EsTUFBTXhTLE1BQU0sT0FBT2xGLFFBQVFrRixHQUFHLElBQUksV0FBV2xGLFFBQVFrRixHQUFHLEdBQUdsRixRQUFRa0YsR0FBRyxHQUFHdVMsSUFBSXpYLFFBQVFrRixHQUFHLElBQUluSjtRQUM1RixNQUFNNmIsV0FBVzVYLFFBQVE2WCxLQUFLO1FBQzlCLElBQUksQ0FBQ0EsS0FBSyxHQUFHRCxvQkFBb0IzYixXQUFXLENBQUNxQixPQUFTQSxLQUFLQyxJQUFJLENBQUMvQixxQkFBcUJvYyxTQUFTemIsSUFBSSxHQUM1RnliLFdBQVcsQ0FBQ3RhLE9BQVNBLFFBQVFzYSxXQUFXN2I7UUFDOUMsSUFBSSxDQUFDK2IsS0FBSyxHQUFHM2MsZ0VBQWNBLENBQUNvYyxNQUFNdE8sR0FBRyxDQUFDNk8sQ0FBQUEsUUFBVTtnQkFDNUNDLEtBQUtELE1BQU1DLEdBQUc7Z0JBQ2RuQixPQUFPa0IsTUFBTWxCLEtBQUssSUFBSWEsSUFBSWhiLE9BQU95WixNQUFNLENBQUMsQ0FBQyxHQUFHNEIsT0FBTztvQkFBRUMsS0FBSztnQkFBSztZQUNuRSxLQUFLO1lBQ0Q3UztRQUNKLEdBQUc0UyxLQUFLO1FBQ1IsSUFBSSxDQUFDRSxNQUFNLEdBQUdSLFVBQVUsSUFBSWxjLGtEQUFXQSxDQUFDa2MsV0FBVztRQUNuRCxJQUFJLENBQUNTLFNBQVMsR0FBR2pZLFFBQVFpWSxTQUFTO0lBQ3RDO0lBQ0E7Ozs7Ozs7Ozs7Ozs7O0lBY0EsR0FDQSxPQUFPdGMsT0FBTzRiLEtBQUssRUFBRXZYLE9BQU8sRUFBRTtRQUMxQixPQUFPLElBQUlzWCxlQUFlQyxPQUFPdlgsV0FBVyxDQUFDO0lBQ2pEO0FBQ0o7QUFDQSxNQUFNa1ksbUJBQW1CLFdBQVcsR0FBRTlkLG9EQUFLQSxDQUFDdUIsTUFBTTtBQUNsRCxNQUFNd2Msc0JBQXNCLFdBQVcsR0FBRS9kLG9EQUFLQSxDQUFDdUIsTUFBTSxDQUFDO0lBQ2xEQyxTQUFRQyxNQUFNO1FBQUksT0FBT0EsT0FBT3dDLE1BQU0sR0FBRztZQUFDeEMsTUFBTSxDQUFDLEVBQUU7U0FBQyxHQUFHO0lBQU07QUFDakU7QUFDQSxTQUFTdWMsZ0JBQWdCbmIsS0FBSztJQUMxQixJQUFJMFMsT0FBTzFTLE1BQU1RLEtBQUssQ0FBQ3lhO0lBQ3ZCLE9BQU92SSxLQUFLdFIsTUFBTSxHQUFHc1IsT0FBTzFTLE1BQU1RLEtBQUssQ0FBQzBhO0FBQzVDO0FBQ0E7Ozs7OztBQU1BLEdBQ0EsU0FBU0UsbUJBQW1CQyxXQUFXLEVBQUV0WSxPQUFPO0lBQzVDLElBQUl1SixNQUFNO1FBQUNnUDtLQUFnQixFQUFFTjtJQUM3QixJQUFJSyx1QkFBdUJoQixnQkFBZ0I7UUFDdkMsSUFBSWdCLFlBQVlOLE1BQU0sRUFDbEJ6TyxJQUFJN0ssSUFBSSxDQUFDN0Qsd0RBQVVBLENBQUMyZCxXQUFXLENBQUN6YixFQUFFLENBQUN1YixZQUFZTixNQUFNO1FBQ3pEQyxZQUFZSyxZQUFZTCxTQUFTO0lBQ3JDO0lBQ0EsSUFBSWpZLFlBQVksUUFBUUEsWUFBWSxLQUFLLElBQUksS0FBSyxJQUFJQSxRQUFReVksUUFBUSxFQUNsRWxQLElBQUk3SyxJQUFJLENBQUN5WixvQkFBb0JwYixFQUFFLENBQUN1YjtTQUMvQixJQUFJTCxXQUNMMU8sSUFBSTdLLElBQUksQ0FBQ3daLGlCQUFpQlEsUUFBUSxDQUFDO1FBQUM3ZCx3REFBVUEsQ0FBQzhkLFNBQVM7S0FBQyxFQUFFMWIsQ0FBQUE7UUFDdkQsT0FBT0EsTUFBTVEsS0FBSyxDQUFDNUMsd0RBQVVBLENBQUM4ZCxTQUFTLEtBQU1WLENBQUFBLGFBQWEsTUFBSyxJQUFLO1lBQUNLO1NBQVksR0FBRyxFQUFFO0lBQzFGO1NBRUEvTyxJQUFJN0ssSUFBSSxDQUFDd1osaUJBQWlCbmIsRUFBRSxDQUFDdWI7SUFDakMsT0FBTy9PO0FBQ1g7QUFDQTs7Ozs7O0FBTUEsR0FDQSxTQUFTcVAsZ0JBQWdCM2IsS0FBSyxFQUFFL0IsSUFBSSxFQUFFMmMsS0FBSztJQUN2QyxJQUFJZ0IsZUFBZVQsZ0JBQWdCbmI7SUFDbkMsSUFBSXNCLFNBQVM7SUFDYixJQUFJc2EsY0FDQSxLQUFLLElBQUlQLGVBQWVPLGFBQWM7UUFDbEMsSUFBSSxDQUFDUCxZQUFZVCxLQUFLLElBQUlBLFNBQVNTLFlBQVlULEtBQUssQ0FBQ0EsUUFBUTtZQUN6RCxJQUFJSCxNQUFNWSxZQUFZUixLQUFLLENBQUM1YztZQUM1QixJQUFJd2MsS0FDQW5aLFNBQVNBLFNBQVNBLFNBQVMsTUFBTW1aLE1BQU1BO1FBQy9DO0lBQ0o7SUFDSixPQUFPblo7QUFDWDtBQUNBLE1BQU11YTtJQUNGNWMsWUFBWThFLElBQUksQ0FBRTtRQUNkLElBQUksQ0FBQytYLFNBQVMsR0FBR3RjLE9BQU9tRyxNQUFNLENBQUM7UUFDL0IsSUFBSSxDQUFDbkUsSUFBSSxHQUFHN0IsV0FBV29FLEtBQUsvRCxLQUFLO1FBQ2pDLElBQUksQ0FBQ2lWLFdBQVcsR0FBRyxJQUFJLENBQUM4RyxTQUFTLENBQUNoWSxNQUFNb1gsZ0JBQWdCcFgsS0FBSy9ELEtBQUs7SUFDdEU7SUFDQWdKLE9BQU9BLE1BQU0sRUFBRTtRQUNYLElBQUl4SCxPQUFPN0IsV0FBV3FKLE9BQU9oSixLQUFLLEdBQUc0YixlQUFlVCxnQkFBZ0JuUyxPQUFPaEosS0FBSztRQUNoRixJQUFJZ2MsY0FBY0osZ0JBQWdCVCxnQkFBZ0JuUyxPQUFPTCxVQUFVO1FBQ25FLElBQUluSCxLQUFLSixNQUFNLEdBQUc0SCxPQUFPakYsSUFBSSxDQUFDTixRQUFRLENBQUN2QyxFQUFFLElBQUksQ0FBQzhhLGVBQWV4YSxLQUFLbkIsSUFBSSxJQUFJLElBQUksQ0FBQ21CLElBQUksQ0FBQ25CLElBQUksRUFBRTtZQUN0RixJQUFJLENBQUM0VSxXQUFXLEdBQUcsSUFBSSxDQUFDQSxXQUFXLENBQUNqSixHQUFHLENBQUNoRCxPQUFPbEMsT0FBTztRQUMxRCxPQUNLLElBQUl0RixRQUFRLElBQUksQ0FBQ0EsSUFBSSxJQUFJd0gsT0FBT3NRLGVBQWUsSUFBSTBDLGFBQWE7WUFDakUsSUFBSSxDQUFDeGEsSUFBSSxHQUFHQTtZQUNaLElBQUksQ0FBQ3lULFdBQVcsR0FBRyxJQUFJLENBQUM4RyxTQUFTLENBQUMvUyxPQUFPakYsSUFBSSxFQUFFNlg7UUFDbkQ7SUFDSjtJQUNBRyxVQUFVaFksSUFBSSxFQUFFNlgsWUFBWSxFQUFFO1FBQzFCLElBQUksQ0FBQ0EsZ0JBQWdCLENBQUMsSUFBSSxDQUFDcGEsSUFBSSxDQUFDSixNQUFNLEVBQ2xDLE9BQU92RCx3REFBVUEsQ0FBQ3FLLElBQUk7UUFDMUIsSUFBSXFSLFVBQVUsSUFBSS9iLDhEQUFlQTtRQUNqQyxLQUFLLElBQUksRUFBRW9ELElBQUksRUFBRU0sRUFBRSxFQUFFLElBQUk2QyxLQUFLa1ksYUFBYSxDQUFFO1lBQ3pDOWQsK0RBQWFBLENBQUMsSUFBSSxDQUFDcUQsSUFBSSxFQUFFb2EsY0FBYyxDQUFDaGIsTUFBTU0sSUFBSTJaO2dCQUM5Q3RCLFFBQVF6VyxHQUFHLENBQUNsQyxNQUFNTSxJQUFJLElBQUksQ0FBQzRhLFNBQVMsQ0FBQ2pCLE1BQU0sSUFBSyxLQUFJLENBQUNpQixTQUFTLENBQUNqQixNQUFNLEdBQUdoZCx3REFBVUEsQ0FBQzRiLElBQUksQ0FBQztvQkFBRUUsT0FBT2tCO2dCQUFNLEVBQUM7WUFDNUcsR0FBR2phLE1BQU1NO1FBQ2I7UUFDQSxPQUFPcVksUUFBUUcsTUFBTTtJQUN6QjtBQUNKO0FBQ0EsTUFBTTRCLGtCQUFrQixXQUFXLEdBQUU3ZCxtREFBSUEsQ0FBQ3llLElBQUksQ0FBQyxXQUFXLEdBQUV4ZSx3REFBVUEsQ0FBQ29NLFNBQVMsQ0FBQytSLGlCQUFpQjtJQUM5RjVHLGFBQWFrSCxDQUFBQSxJQUFLQSxFQUFFbEgsV0FBVztBQUNuQztBQUNBOztBQUVBLEdBQ0EsTUFBTW1ILHdCQUF3QixXQUFXLEdBQUUvQixlQUFlM2IsTUFBTSxDQUFDO0lBQzdEO1FBQUVvYyxLQUFLN2Msa0RBQUlBLENBQUNvZSxJQUFJO1FBQ1pwQyxPQUFPO0lBQVU7SUFDckI7UUFBRWEsS0FBSzdjLGtEQUFJQSxDQUFDcWUsSUFBSTtRQUNaQyxnQkFBZ0I7SUFBWTtJQUNoQztRQUFFekIsS0FBSzdjLGtEQUFJQSxDQUFDdWUsT0FBTztRQUNmRCxnQkFBZ0I7UUFDaEJFLFlBQVk7SUFBTztJQUN2QjtRQUFFM0IsS0FBSzdjLGtEQUFJQSxDQUFDeWUsUUFBUTtRQUNoQkMsV0FBVztJQUFTO0lBQ3hCO1FBQUU3QixLQUFLN2Msa0RBQUlBLENBQUMyZSxNQUFNO1FBQ2RILFlBQVk7SUFBTztJQUN2QjtRQUFFM0IsS0FBSzdjLGtEQUFJQSxDQUFDNGUsYUFBYTtRQUNyQk4sZ0JBQWdCO0lBQWU7SUFDbkM7UUFBRXpCLEtBQUs3YyxrREFBSUEsQ0FBQzZlLE9BQU87UUFDZjdDLE9BQU87SUFBTztJQUNsQjtRQUFFYSxLQUFLO1lBQUM3YyxrREFBSUEsQ0FBQzhlLElBQUk7WUFBRTllLGtEQUFJQSxDQUFDK2UsSUFBSTtZQUFFL2Usa0RBQUlBLENBQUNnZixHQUFHO1lBQUVoZixrREFBSUEsQ0FBQ2lmLGdCQUFnQjtZQUFFamYsa0RBQUlBLENBQUNrZixTQUFTO1NBQUM7UUFDMUVsRCxPQUFPO0lBQU87SUFDbEI7UUFBRWEsS0FBSztZQUFDN2Msa0RBQUlBLENBQUNtZixPQUFPO1lBQUVuZixrREFBSUEsQ0FBQ29mLFFBQVE7U0FBQztRQUNoQ3BELE9BQU87SUFBTztJQUNsQjtRQUFFYSxLQUFLO1lBQUM3YyxrREFBSUEsQ0FBQ3VHLE1BQU07WUFBRXZHLGtEQUFJQSxDQUFDcWYsT0FBTztTQUFDO1FBQzlCckQsT0FBTztJQUFPO0lBQ2xCO1FBQUVhLEtBQUs7WUFBQzdjLGtEQUFJQSxDQUFDc2YsTUFBTTtZQUFFdGYsa0RBQUlBLENBQUN1ZixNQUFNO1lBQUUsV0FBVyxHQUFFdmYsa0RBQUlBLENBQUN3ZixPQUFPLENBQUN4ZixrREFBSUEsQ0FBQ3VHLE1BQU07U0FBRTtRQUNyRXlWLE9BQU87SUFBTztJQUNsQjtRQUFFYSxLQUFLLFdBQVcsR0FBRTdjLGtEQUFJQSxDQUFDeWYsVUFBVSxDQUFDemYsa0RBQUlBLENBQUMwZixZQUFZO1FBQ2pEMUQsT0FBTztJQUFPO0lBQ2xCO1FBQUVhLEtBQUssV0FBVyxHQUFFN2Msa0RBQUlBLENBQUMyZixLQUFLLENBQUMzZixrREFBSUEsQ0FBQzBmLFlBQVk7UUFDNUMxRCxPQUFPO0lBQU87SUFDbEI7UUFBRWEsS0FBSztZQUFDN2Msa0RBQUlBLENBQUM0ZixRQUFRO1lBQUU1ZixrREFBSUEsQ0FBQzZmLFNBQVM7U0FBQztRQUNsQzdELE9BQU87SUFBTztJQUNsQjtRQUFFYSxLQUFLN2Msa0RBQUlBLENBQUNrYSxTQUFTO1FBQ2pCOEIsT0FBTztJQUFPO0lBQ2xCO1FBQUVhLEtBQUs7WUFBQyxXQUFXLEdBQUU3YyxrREFBSUEsQ0FBQ3dmLE9BQU8sQ0FBQ3hmLGtEQUFJQSxDQUFDMGYsWUFBWTtZQUFHMWYsa0RBQUlBLENBQUM4ZixTQUFTO1NBQUM7UUFDakU5RCxPQUFPO0lBQU87SUFDbEI7UUFBRWEsS0FBSyxXQUFXLEdBQUU3YyxrREFBSUEsQ0FBQ3lmLFVBQVUsQ0FBQ3pmLGtEQUFJQSxDQUFDK2YsWUFBWTtRQUNqRC9ELE9BQU87SUFBTztJQUNsQjtRQUFFYSxLQUFLN2Msa0RBQUlBLENBQUNnZ0IsT0FBTztRQUNmaEUsT0FBTztJQUFPO0lBQ2xCO1FBQUVhLEtBQUs3YyxrREFBSUEsQ0FBQ2lnQixPQUFPO1FBQ2ZqRSxPQUFPO0lBQU87Q0FDckI7QUFFRCxNQUFNSCxZQUFZLFdBQVcsR0FBRWxjLHdEQUFVQSxDQUFDa2MsU0FBUyxDQUFDO0lBQ2hELG9DQUFvQztRQUFFQyxpQkFBaUI7SUFBWTtJQUNuRSx1Q0FBdUM7UUFBRUEsaUJBQWlCO0lBQVk7QUFDMUU7QUFDQSxNQUFNb0Usa0JBQWtCLE9BQU9DLGtCQUFrQjtBQUNqRCxNQUFNQyx3QkFBd0IsV0FBVyxHQUFFbGhCLG9EQUFLQSxDQUFDdUIsTUFBTSxDQUFDO0lBQ3BEQyxTQUFRMmYsT0FBTztRQUNYLE9BQU9oaEIsZ0VBQWFBLENBQUNnaEIsU0FBUztZQUMxQkMsYUFBYTtZQUNiQyxVQUFVSjtZQUNWSyxpQkFBaUJOO1lBQ2pCTyxhQUFhQztRQUNqQjtJQUNKO0FBQ0o7QUFDQSxNQUFNQyxlQUFlLFdBQVcsR0FBRS9nQix3REFBVUEsQ0FBQzRiLElBQUksQ0FBQztJQUFFRSxPQUFPO0FBQXFCLElBQUlrRixrQkFBa0IsV0FBVyxHQUFFaGhCLHdEQUFVQSxDQUFDNGIsSUFBSSxDQUFDO0lBQUVFLE9BQU87QUFBd0I7QUFDcEssU0FBU2dGLG1CQUFtQjlNLEtBQUs7SUFDN0IsSUFBSW9ELGNBQWMsRUFBRTtJQUNwQixJQUFJd0UsT0FBTzVILE1BQU1pTixPQUFPLEdBQUdGLGVBQWVDO0lBQzFDNUosWUFBWXhULElBQUksQ0FBQ2dZLEtBQUtoRyxLQUFLLENBQUM1QixNQUFNM0QsS0FBSyxDQUFDdE4sSUFBSSxFQUFFaVIsTUFBTTNELEtBQUssQ0FBQ2hOLEVBQUU7SUFDNUQsSUFBSTJRLE1BQU13QixHQUFHLEVBQ1Q0QixZQUFZeFQsSUFBSSxDQUFDZ1ksS0FBS2hHLEtBQUssQ0FBQzVCLE1BQU13QixHQUFHLENBQUN6UyxJQUFJLEVBQUVpUixNQUFNd0IsR0FBRyxDQUFDblMsRUFBRTtJQUM1RCxPQUFPK1Q7QUFDWDtBQUNBLE1BQU04Six1QkFBdUIsV0FBVyxHQUFFN2hCLHlEQUFVQSxDQUFDd0IsTUFBTSxDQUFDO0lBQ3hEaUg7UUFBVyxPQUFPOUgsd0RBQVVBLENBQUNxSyxJQUFJO0lBQUU7SUFDbkNjLFFBQU9nVyxJQUFJLEVBQUV4VyxFQUFFO1FBQ1gsSUFBSSxDQUFDQSxHQUFHQyxVQUFVLElBQUksQ0FBQ0QsR0FBR2lLLFNBQVMsRUFDL0IsT0FBT3VNO1FBQ1gsSUFBSS9KLGNBQWMsRUFBRTtRQUNwQixJQUFJa0MsU0FBUzNPLEdBQUd4SSxLQUFLLENBQUNRLEtBQUssQ0FBQzZkO1FBQzVCLEtBQUssSUFBSTVLLFNBQVNqTCxHQUFHeEksS0FBSyxDQUFDeVMsU0FBUyxDQUFDekwsTUFBTSxDQUFFO1lBQ3pDLElBQUksQ0FBQ3lNLE1BQU12USxLQUFLLEVBQ1o7WUFDSixJQUFJMk8sUUFBUW9OLGNBQWN6VyxHQUFHeEksS0FBSyxFQUFFeVQsTUFBTWQsSUFBSSxFQUFFLENBQUMsR0FBR3dFLFdBQzVDMUQsTUFBTWQsSUFBSSxHQUFHLEtBQUtzTSxjQUFjelcsR0FBR3hJLEtBQUssRUFBRXlULE1BQU1kLElBQUksR0FBRyxHQUFHLEdBQUd3RSxXQUM3REEsT0FBT29ILFdBQVcsSUFDakJVLENBQUFBLGNBQWN6VyxHQUFHeEksS0FBSyxFQUFFeVQsTUFBTWQsSUFBSSxFQUFFLEdBQUd3RSxXQUNuQzFELE1BQU1kLElBQUksR0FBR25LLEdBQUd4SSxLQUFLLENBQUNtQixHQUFHLENBQUNDLE1BQU0sSUFBSTZkLGNBQWN6VyxHQUFHeEksS0FBSyxFQUFFeVQsTUFBTWQsSUFBSSxHQUFHLEdBQUcsQ0FBQyxHQUFHd0UsT0FBTztZQUNwRyxJQUFJdEYsT0FDQW9ELGNBQWNBLFlBQVlwVyxNQUFNLENBQUNzWSxPQUFPdUgsV0FBVyxDQUFDN00sT0FBT3JKLEdBQUd4SSxLQUFLO1FBQzNFO1FBQ0EsT0FBT25DLHdEQUFVQSxDQUFDd1gsR0FBRyxDQUFDSixhQUFhO0lBQ3ZDO0lBQ0FELFNBQVN0TyxDQUFBQSxJQUFLOUksd0RBQVVBLENBQUNxWCxXQUFXLENBQUNyVSxJQUFJLENBQUM4RjtBQUM5QztBQUNBLE1BQU13WSx3QkFBd0I7SUFDMUJIO0lBQ0FqRjtDQUNIO0FBQ0Q7Ozs7O0FBS0EsR0FDQSxTQUFTcUYsZ0JBQWdCaEksU0FBUyxDQUFDLENBQUM7SUFDaEMsT0FBTztRQUFDa0gsc0JBQXNCdmUsRUFBRSxDQUFDcVg7UUFBUytIO0tBQXNCO0FBQ3BFO0FBQ0E7Ozs7Ozs7QUFPQSxHQUNBLE1BQU1FLHdCQUF3QixXQUFXLEdBQUUsSUFBSTFpQixtREFBUUE7QUFDdkQsU0FBUzJpQixjQUFjL2MsSUFBSSxFQUFFZ2QsR0FBRyxFQUFFZCxRQUFRO0lBQ3RDLElBQUllLFNBQVNqZCxLQUFLaEMsSUFBSSxDQUFDZ2YsTUFBTSxJQUFJNWlCLG1EQUFRQSxDQUFDOGlCLFFBQVEsR0FBRzlpQixtREFBUUEsQ0FBQ3lULFFBQVE7SUFDdEUsSUFBSW9QLFFBQ0EsT0FBT0E7SUFDWCxJQUFJamQsS0FBS2pELElBQUksQ0FBQytCLE1BQU0sSUFBSSxHQUFHO1FBQ3ZCLElBQUlxZSxRQUFRakIsU0FBU2hTLE9BQU8sQ0FBQ2xLLEtBQUtqRCxJQUFJO1FBQ3RDLElBQUlvZ0IsUUFBUSxDQUFDLEtBQUtBLFFBQVEsS0FBTUgsQ0FBQUEsTUFBTSxJQUFJLElBQUksSUFDMUMsT0FBTztZQUFDZCxRQUFRLENBQUNpQixRQUFRSCxJQUFJO1NBQUM7SUFDdEM7SUFDQSxPQUFPO0FBQ1g7QUFDQSxTQUFTSSxXQUFXcGQsSUFBSTtJQUNwQixJQUFJcWQsWUFBWXJkLEtBQUtqQyxJQUFJLENBQUNDLElBQUksQ0FBQzhlO0lBQy9CLE9BQU9PLFlBQVlBLFVBQVVyZCxLQUFLQSxJQUFJLElBQUlBO0FBQzlDO0FBQ0E7Ozs7O0FBS0EsR0FDQSxTQUFTMmMsY0FBY2pmLEtBQUssRUFBRUMsR0FBRyxFQUFFcWYsR0FBRyxFQUFFbkksU0FBUyxDQUFDLENBQUM7SUFDL0MsSUFBSXNILGtCQUFrQnRILE9BQU9zSCxlQUFlLElBQUlOLGlCQUFpQkssV0FBV3JILE9BQU9xSCxRQUFRLElBQUlKO0lBQy9GLElBQUk1YyxPQUFPN0IsV0FBV0ssUUFBUXNDLE9BQU9kLEtBQUtvZSxZQUFZLENBQUMzZixLQUFLcWY7SUFDNUQsSUFBSyxJQUFJL1EsTUFBTWpNLE1BQU1pTSxLQUFLQSxNQUFNQSxJQUFJbUIsTUFBTSxDQUFFO1FBQ3hDLElBQUltUSxVQUFVUixjQUFjOVEsSUFBSWxPLElBQUksRUFBRWlmLEtBQUtkO1FBQzNDLElBQUlxQixXQUFXdFIsSUFBSTNOLElBQUksR0FBRzJOLElBQUlyTixFQUFFLEVBQUU7WUFDOUIsSUFBSTRlLFNBQVNKLFdBQVduUjtZQUN4QixJQUFJdVIsVUFBV1IsQ0FBQUEsTUFBTSxJQUFJcmYsT0FBTzZmLE9BQU9sZixJQUFJLElBQUlYLE1BQU02ZixPQUFPNWUsRUFBRSxHQUFHakIsTUFBTTZmLE9BQU9sZixJQUFJLElBQUlYLE9BQU82ZixPQUFPNWUsRUFBRSxHQUNsRyxPQUFPNmUsb0JBQW9CL2YsT0FBT0MsS0FBS3FmLEtBQUsvUSxLQUFLdVIsUUFBUUQsU0FBU3JCO1FBQzFFO0lBQ0o7SUFDQSxPQUFPd0IsbUJBQW1CaGdCLE9BQU9DLEtBQUtxZixLQUFLOWQsTUFBTWMsS0FBS2pDLElBQUksRUFBRW9lLGlCQUFpQkQ7QUFDakY7QUFDQSxTQUFTdUIsb0JBQW9CRSxNQUFNLEVBQUVDLElBQUksRUFBRVosR0FBRyxFQUFFYSxLQUFLLEVBQUVMLE1BQU0sRUFBRU0sUUFBUSxFQUFFNUIsUUFBUTtJQUM3RSxJQUFJOU8sU0FBU3lRLE1BQU16USxNQUFNLEVBQUUyUSxhQUFhO1FBQUV6ZixNQUFNa2YsT0FBT2xmLElBQUk7UUFBRU0sSUFBSTRlLE9BQU81ZSxFQUFFO0lBQUM7SUFDM0UsSUFBSW9mLFFBQVEsR0FBRzdiLFNBQVNpTCxXQUFXLFFBQVFBLFdBQVcsS0FBSyxJQUFJLEtBQUssSUFBSUEsT0FBT2pMLE1BQU07SUFDckYsSUFBSUEsVUFBVzZhLENBQUFBLE1BQU0sSUFBSTdhLE9BQU84YixXQUFXLENBQUNKLE1BQU12ZixJQUFJLElBQUk2RCxPQUFPd00sVUFBVSxDQUFDa1AsTUFBTWpmLEVBQUUsSUFDaEYsR0FBRztRQUNDLElBQUlvZSxNQUFNLElBQUk3YSxPQUFPdkQsRUFBRSxJQUFJaWYsTUFBTXZmLElBQUksR0FBRzZELE9BQU83RCxJQUFJLElBQUl1ZixNQUFNamYsRUFBRSxFQUFFO1lBQzdELElBQUlvZixTQUFTLEtBQUtGLFNBQVM1VCxPQUFPLENBQUMvSCxPQUFPcEUsSUFBSSxDQUFDaEIsSUFBSSxJQUFJLENBQUMsS0FBS29GLE9BQU83RCxJQUFJLEdBQUc2RCxPQUFPdkQsRUFBRSxFQUFFO2dCQUNsRixJQUFJc2YsWUFBWWQsV0FBV2piO2dCQUMzQixPQUFPO29CQUFFeUosT0FBT21TO29CQUFZaE4sS0FBS21OLFlBQVk7d0JBQUU1ZixNQUFNNGYsVUFBVTVmLElBQUk7d0JBQUVNLElBQUlzZixVQUFVdGYsRUFBRTtvQkFBQyxJQUFJcEM7b0JBQVdnZ0IsU0FBUztnQkFBSztZQUN2SCxPQUNLLElBQUlPLGNBQWM1YSxPQUFPcEUsSUFBSSxFQUFFaWYsS0FBS2QsV0FBVztnQkFDaEQ4QjtZQUNKLE9BQ0ssSUFBSWpCLGNBQWM1YSxPQUFPcEUsSUFBSSxFQUFFLENBQUNpZixLQUFLZCxXQUFXO2dCQUNqRCxJQUFJOEIsU0FBUyxHQUFHO29CQUNaLElBQUlFLFlBQVlkLFdBQVdqYjtvQkFDM0IsT0FBTzt3QkFDSHlKLE9BQU9tUzt3QkFDUGhOLEtBQUttTixhQUFhQSxVQUFVNWYsSUFBSSxHQUFHNGYsVUFBVXRmLEVBQUUsR0FBRzs0QkFBRU4sTUFBTTRmLFVBQVU1ZixJQUFJOzRCQUFFTSxJQUFJc2YsVUFBVXRmLEVBQUU7d0JBQUMsSUFBSXBDO3dCQUMvRmdnQixTQUFTO29CQUNiO2dCQUNKO2dCQUNBd0I7WUFDSjtRQUNKO0lBQ0osUUFBU2hCLE1BQU0sSUFBSTdhLE9BQU9nYyxXQUFXLEtBQUtoYyxPQUFPaWMsV0FBVyxJQUFJO0lBQ3BFLE9BQU87UUFBRXhTLE9BQU9tUztRQUFZdkIsU0FBUztJQUFNO0FBQy9DO0FBQ0EsU0FBU2tCLG1CQUFtQmhnQixLQUFLLEVBQUVDLEdBQUcsRUFBRXFmLEdBQUcsRUFBRTlkLElBQUksRUFBRW1mLFNBQVMsRUFBRWxDLGVBQWUsRUFBRUQsUUFBUTtJQUNuRixJQUFJb0MsVUFBVXRCLE1BQU0sSUFBSXRmLE1BQU02Z0IsUUFBUSxDQUFDNWdCLE1BQU0sR0FBR0EsT0FBT0QsTUFBTTZnQixRQUFRLENBQUM1Z0IsS0FBS0EsTUFBTTtJQUNqRixJQUFJNmdCLFVBQVV0QyxTQUFTaFMsT0FBTyxDQUFDb1U7SUFDL0IsSUFBSUUsVUFBVSxLQUFLLFVBQVcsS0FBSyxLQUFPeEIsTUFBTSxHQUM1QyxPQUFPO0lBQ1gsSUFBSXlCLGFBQWE7UUFBRW5nQixNQUFNMGUsTUFBTSxJQUFJcmYsTUFBTSxJQUFJQTtRQUFLaUIsSUFBSW9lLE1BQU0sSUFBSXJmLE1BQU0sSUFBSUE7SUFBSTtJQUM5RSxJQUFJeUUsT0FBTzFFLE1BQU1tQixHQUFHLENBQUM2ZixTQUFTLENBQUMvZ0IsS0FBS3FmLE1BQU0sSUFBSXRmLE1BQU1tQixHQUFHLENBQUNDLE1BQU0sR0FBRyxJQUFJa2YsUUFBUTtJQUM3RSxJQUFLLElBQUlXLFdBQVcsR0FBRyxDQUFDLEtBQU1yYyxJQUFJLEdBQUl5QixJQUFJLElBQUk0YSxZQUFZeEMsaUJBQWtCO1FBQ3hFLElBQUluUSxPQUFPNUosS0FBS0csS0FBSztRQUNyQixJQUFJeWEsTUFBTSxHQUNOMkIsWUFBWTNTLEtBQUtsTixNQUFNO1FBQzNCLElBQUk4ZixVQUFVamhCLE1BQU1naEIsV0FBVzNCO1FBQy9CLElBQUssSUFBSXJmLE1BQU1xZixNQUFNLElBQUksSUFBSWhSLEtBQUtsTixNQUFNLEdBQUcsR0FBR2lTLE1BQU1pTSxNQUFNLElBQUloUixLQUFLbE4sTUFBTSxHQUFHLENBQUMsR0FBR25CLE9BQU9vVCxLQUFLcFQsT0FBT3FmLElBQUs7WUFDcEcsSUFBSXpTLFFBQVEyUixTQUFTaFMsT0FBTyxDQUFDOEIsSUFBSSxDQUFDck8sSUFBSTtZQUN0QyxJQUFJNE0sUUFBUSxLQUFLckwsS0FBS29lLFlBQVksQ0FBQ3NCLFVBQVVqaEIsS0FBSyxHQUFHSSxJQUFJLElBQUlzZ0IsV0FDekQ7WUFDSixJQUFJLFFBQVMsS0FBSyxLQUFPckIsTUFBTSxHQUFJO2dCQUMvQmdCO1lBQ0osT0FDSyxJQUFJQSxTQUFTLEdBQUc7Z0JBQ2pCLE9BQU87b0JBQUVwUyxPQUFPNlM7b0JBQVkxTixLQUFLO3dCQUFFelMsTUFBTXNnQixVQUFVamhCO3dCQUFLaUIsSUFBSWdnQixVQUFVamhCLE1BQU07b0JBQUU7b0JBQUc2ZSxTQUFTLFNBQVUsS0FBT2dDLFdBQVc7Z0JBQUc7WUFDN0gsT0FDSztnQkFDRFI7WUFDSjtRQUNKO1FBQ0EsSUFBSWhCLE1BQU0sR0FDTjJCLFlBQVkzUyxLQUFLbE4sTUFBTTtJQUMvQjtJQUNBLE9BQU9zRCxLQUFLMkIsSUFBSSxHQUFHO1FBQUU2SCxPQUFPNlM7UUFBWWpDLFNBQVM7SUFBTSxJQUFJO0FBQy9EO0FBRUEsa0VBQWtFO0FBQ2xFLG1DQUFtQztBQUNuQyxTQUFTcUMsU0FBUzNjLE1BQU0sRUFBRTZPLEdBQUcsRUFBRTlGLE9BQU8sRUFBRTZULGFBQWEsQ0FBQyxFQUFFQyxhQUFhLENBQUM7SUFDbEUsSUFBSWhPLE9BQU8sTUFBTTtRQUNiQSxNQUFNN08sT0FBT3dLLE1BQU0sQ0FBQztRQUNwQixJQUFJcUUsT0FBTyxDQUFDLEdBQ1JBLE1BQU03TyxPQUFPcEQsTUFBTTtJQUMzQjtJQUNBLElBQUlrZ0IsSUFBSUQ7SUFDUixJQUFLLElBQUl0ZixJQUFJcWYsWUFBWXJmLElBQUlzUixLQUFLdFIsSUFBSztRQUNuQyxJQUFJeUMsT0FBTzhJLFVBQVUsQ0FBQ3ZMLE1BQU0sR0FDeEJ1ZixLQUFLL1QsVUFBVytULElBQUkvVDthQUVwQitUO0lBQ1I7SUFDQSxPQUFPQTtBQUNYO0FBQ0E7OztBQUdBLEdBQ0EsTUFBTUM7SUFDRjs7SUFFQSxHQUNBdGlCLFlBQ0E7O0lBRUEsR0FDQXVGLE1BQU0sRUFBRStJLE9BQU8sRUFDZjs7SUFFQSxHQUNBUixVQUFVLEVBQUV5VSxjQUFjLENBQUU7UUFDeEIsSUFBSSxDQUFDaGQsTUFBTSxHQUFHQTtRQUNkLElBQUksQ0FBQytJLE9BQU8sR0FBR0E7UUFDZixJQUFJLENBQUNSLFVBQVUsR0FBR0E7UUFDbEIsSUFBSSxDQUFDeVUsY0FBYyxHQUFHQTtRQUN0Qjs7UUFFQSxHQUNBLElBQUksQ0FBQ3ZoQixHQUFHLEdBQUc7UUFDWDs7UUFFQSxHQUNBLElBQUksQ0FBQ2lPLEtBQUssR0FBRztRQUNiLElBQUksQ0FBQ3VULGFBQWEsR0FBRztRQUNyQixJQUFJLENBQUNDLGVBQWUsR0FBRztJQUMzQjtJQUNBOztJQUVBLEdBQ0FDLE1BQU07UUFBRSxPQUFPLElBQUksQ0FBQzFoQixHQUFHLElBQUksSUFBSSxDQUFDdUUsTUFBTSxDQUFDcEQsTUFBTTtJQUFFO0lBQy9DOztJQUVBLEdBQ0F3Z0IsTUFBTTtRQUFFLE9BQU8sSUFBSSxDQUFDM2hCLEdBQUcsSUFBSTtJQUFHO0lBQzlCOzs7SUFHQSxHQUNBNGhCLE9BQU87UUFBRSxPQUFPLElBQUksQ0FBQ3JkLE1BQU0sQ0FBQ3NkLE1BQU0sQ0FBQyxJQUFJLENBQUM3aEIsR0FBRyxLQUFLbkI7SUFBVztJQUMzRDs7SUFFQSxHQUNBOEYsT0FBTztRQUNILElBQUksSUFBSSxDQUFDM0UsR0FBRyxHQUFHLElBQUksQ0FBQ3VFLE1BQU0sQ0FBQ3BELE1BQU0sRUFDN0IsT0FBTyxJQUFJLENBQUNvRCxNQUFNLENBQUNzZCxNQUFNLENBQUMsSUFBSSxDQUFDN2hCLEdBQUc7SUFDMUM7SUFDQTs7O0lBR0EsR0FDQThoQixJQUFJbFEsS0FBSyxFQUFFO1FBQ1AsSUFBSTVQLEtBQUssSUFBSSxDQUFDdUMsTUFBTSxDQUFDc2QsTUFBTSxDQUFDLElBQUksQ0FBQzdoQixHQUFHO1FBQ3BDLElBQUkraEI7UUFDSixJQUFJLE9BQU9uUSxTQUFTLFVBQ2hCbVEsS0FBSy9mLE1BQU00UDthQUVYbVEsS0FBSy9mLE1BQU80UCxDQUFBQSxpQkFBaUJvUSxTQUFTcFEsTUFBTS9RLElBQUksQ0FBQ21CLE1BQU00UCxNQUFNNVAsR0FBRTtRQUNuRSxJQUFJK2YsSUFBSTtZQUNKLEVBQUUsSUFBSSxDQUFDL2hCLEdBQUc7WUFDVixPQUFPZ0M7UUFDWDtJQUNKO0lBQ0E7Ozs7SUFJQSxHQUNBaWdCLFNBQVNyUSxLQUFLLEVBQUU7UUFDWixJQUFJM0QsUUFBUSxJQUFJLENBQUNqTyxHQUFHO1FBQ3BCLE1BQU8sSUFBSSxDQUFDOGhCLEdBQUcsQ0FBQ2xRLE9BQVEsQ0FBRTtRQUMxQixPQUFPLElBQUksQ0FBQzVSLEdBQUcsR0FBR2lPO0lBQ3RCO0lBQ0E7OztJQUdBLEdBQ0FpVSxXQUFXO1FBQ1AsSUFBSWpVLFFBQVEsSUFBSSxDQUFDak8sR0FBRztRQUNwQixNQUFPLGFBQWFhLElBQUksQ0FBQyxJQUFJLENBQUMwRCxNQUFNLENBQUNzZCxNQUFNLENBQUMsSUFBSSxDQUFDN2hCLEdBQUcsR0FDaEQsRUFBRSxJQUFJLENBQUNBLEdBQUc7UUFDZCxPQUFPLElBQUksQ0FBQ0EsR0FBRyxHQUFHaU87SUFDdEI7SUFDQTs7SUFFQSxHQUNBa1UsWUFBWTtRQUFFLElBQUksQ0FBQ25pQixHQUFHLEdBQUcsSUFBSSxDQUFDdUUsTUFBTSxDQUFDcEQsTUFBTTtJQUFFO0lBQzdDOzs7SUFHQSxHQUNBaWhCLE9BQU9wZ0IsRUFBRSxFQUFFO1FBQ1AsSUFBSTRLLFFBQVEsSUFBSSxDQUFDckksTUFBTSxDQUFDZ0ksT0FBTyxDQUFDdkssSUFBSSxJQUFJLENBQUNoQyxHQUFHO1FBQzVDLElBQUk0TSxRQUFRLENBQUMsR0FBRztZQUNaLElBQUksQ0FBQzVNLEdBQUcsR0FBRzRNO1lBQ1gsT0FBTztRQUNYO0lBQ0o7SUFDQTs7SUFFQSxHQUNBeVYsT0FBT2hCLENBQUMsRUFBRTtRQUFFLElBQUksQ0FBQ3JoQixHQUFHLElBQUlxaEI7SUFBRztJQUMzQjs7SUFFQSxHQUNBeFMsU0FBUztRQUNMLElBQUksSUFBSSxDQUFDMlMsYUFBYSxHQUFHLElBQUksQ0FBQ3ZULEtBQUssRUFBRTtZQUNqQyxJQUFJLENBQUN3VCxlQUFlLEdBQUdQLFNBQVMsSUFBSSxDQUFDM2MsTUFBTSxFQUFFLElBQUksQ0FBQzBKLEtBQUssRUFBRSxJQUFJLENBQUNYLE9BQU8sRUFBRSxJQUFJLENBQUNrVSxhQUFhLEVBQUUsSUFBSSxDQUFDQyxlQUFlO1lBQy9HLElBQUksQ0FBQ0QsYUFBYSxHQUFHLElBQUksQ0FBQ3ZULEtBQUs7UUFDbkM7UUFDQSxPQUFPLElBQUksQ0FBQ3dULGVBQWU7SUFDL0I7SUFDQTs7SUFFQSxHQUNBYSxjQUFjO1FBQ1YsSUFBSWprQjtRQUNKLE9BQU8sQ0FBQ0EsS0FBSyxJQUFJLENBQUNrakIsY0FBYyxNQUFNLFFBQVFsakIsT0FBTyxLQUFLLElBQUlBLEtBQUs2aUIsU0FBUyxJQUFJLENBQUMzYyxNQUFNLEVBQUUsTUFBTSxJQUFJLENBQUMrSSxPQUFPO0lBQy9HO0lBQ0E7Ozs7Ozs7Ozs7SUFVQSxHQUNBc0UsTUFBTTJRLE9BQU8sRUFBRUMsT0FBTyxFQUFFQyxlQUFlLEVBQUU7UUFDckMsSUFBSSxPQUFPRixXQUFXLFVBQVU7WUFDNUIsSUFBSUcsUUFBUSxDQUFDQyxNQUFRRixrQkFBa0JFLElBQUkxVyxXQUFXLEtBQUswVztZQUMzRCxJQUFJQyxTQUFTLElBQUksQ0FBQ3JlLE1BQU0sQ0FBQ3FlLE1BQU0sQ0FBQyxJQUFJLENBQUM1aUIsR0FBRyxFQUFFdWlCLFFBQVFwaEIsTUFBTTtZQUN4RCxJQUFJdWhCLE1BQU1FLFdBQVdGLE1BQU1ILFVBQVU7Z0JBQ2pDLElBQUlDLFlBQVksT0FDWixJQUFJLENBQUN4aUIsR0FBRyxJQUFJdWlCLFFBQVFwaEIsTUFBTTtnQkFDOUIsT0FBTztZQUNYLE9BRUksT0FBTztRQUNmLE9BQ0s7WUFDRCxJQUFJeVEsUUFBUSxJQUFJLENBQUNyTixNQUFNLENBQUNXLEtBQUssQ0FBQyxJQUFJLENBQUNsRixHQUFHLEVBQUU0UixLQUFLLENBQUMyUTtZQUM5QyxJQUFJM1EsU0FBU0EsTUFBTTROLEtBQUssR0FBRyxHQUN2QixPQUFPO1lBQ1gsSUFBSTVOLFNBQVM0USxZQUFZLE9BQ3JCLElBQUksQ0FBQ3hpQixHQUFHLElBQUk0UixLQUFLLENBQUMsRUFBRSxDQUFDelEsTUFBTTtZQUMvQixPQUFPeVE7UUFDWDtJQUNKO0lBQ0E7O0lBRUEsR0FDQWlSLFVBQVU7UUFBRSxPQUFPLElBQUksQ0FBQ3RlLE1BQU0sQ0FBQ1csS0FBSyxDQUFDLElBQUksQ0FBQytJLEtBQUssRUFBRSxJQUFJLENBQUNqTyxHQUFHO0lBQUc7QUFDaEU7QUFFQSxTQUFTOGlCLFdBQVdwZ0IsSUFBSTtJQUNwQixPQUFPO1FBQ0h0RCxNQUFNc0QsS0FBS3RELElBQUksSUFBSTtRQUNuQjhnQixPQUFPeGQsS0FBS3dkLEtBQUs7UUFDakI2QyxXQUFXcmdCLEtBQUtxZ0IsU0FBUyxJQUFLLE1BQVE7UUFDdENyYSxZQUFZaEcsS0FBS2dHLFVBQVUsSUFBSyxLQUFNLElBQUc7UUFDekNzYSxXQUFXdGdCLEtBQUtzZ0IsU0FBUyxJQUFJQztRQUM3QjdVLFFBQVExTCxLQUFLMEwsTUFBTSxJQUFLLEtBQU0sSUFBRztRQUNqQ3RPLGNBQWM0QyxLQUFLNUMsWUFBWSxJQUFJLENBQUM7UUFDcENvakIsWUFBWXhnQixLQUFLd2dCLFVBQVUsSUFBSUM7SUFDbkM7QUFDSjtBQUNBLFNBQVNGLGlCQUFpQmxqQixLQUFLO0lBQzNCLElBQUksT0FBT0EsU0FBUyxVQUNoQixPQUFPQTtJQUNYLElBQUkrRyxXQUFXLENBQUM7SUFDaEIsSUFBSyxJQUFJekcsUUFBUU4sTUFBTztRQUNwQixJQUFJcWpCLE1BQU1yakIsS0FBSyxDQUFDTSxLQUFLO1FBQ3JCeUcsUUFBUSxDQUFDekcsS0FBSyxHQUFJK2lCLGVBQWVwVyxRQUFRb1csSUFBSWxlLEtBQUssS0FBS2tlO0lBQzNEO0lBQ0EsT0FBT3RjO0FBQ1g7QUFDQSxNQUFNdWMsZUFBZSxXQUFXLEdBQUUsSUFBSUM7QUFDdEM7OztBQUdBLEdBQ0EsTUFBTUMsdUJBQXVCeGtCO0lBQ3pCQyxZQUFZRSxNQUFNLENBQUU7UUFDaEIsSUFBSUQsT0FBT1Ysb0JBQW9CVyxPQUFPWSxZQUFZO1FBQ2xELElBQUkwakIsSUFBSVYsV0FBVzVqQixTQUFTdWtCO1FBQzVCLElBQUlDLE9BQU8sSUFBSSxjQUFjN21CLGlEQUFNQTtZQUMvQitLLFlBQVlDLEtBQUssRUFBRXhDLFNBQVMsRUFBRTBCLE1BQU0sRUFBRTtnQkFDbEMsT0FBTyxJQUFJNGMsTUFBTUYsTUFBTTViLE9BQU94QyxXQUFXMEI7WUFDN0M7UUFDSjtRQUNBLEtBQUssQ0FBQzlILE1BQU15a0IsTUFBTTtZQUFDN1csY0FBY2hOLEVBQUUsQ0FBQyxDQUFDaUksSUFBSTlILE1BQVEsSUFBSSxDQUFDNGpCLFNBQVMsQ0FBQzliLElBQUk5SDtTQUFNLEVBQUVkLE9BQU9FLElBQUk7UUFDdkYsSUFBSSxDQUFDZ0QsT0FBTyxHQUFHeWhCLE1BQU01a0I7UUFDckJ3a0IsT0FBTyxJQUFJO1FBQ1gsSUFBSSxDQUFDSyxZQUFZLEdBQUdOO1FBQ3BCLElBQUksQ0FBQ08sVUFBVSxHQUFHLElBQUl0bkIsbURBQVFBLENBQUM7WUFBRXVuQixTQUFTO1FBQUs7UUFDL0MsSUFBSSxDQUFDZCxVQUFVLEdBQUdoa0IsT0FBT2drQixVQUFVLEdBQUcsSUFBSWUsV0FBV1QsRUFBRU4sVUFBVSxJQUFJZ0I7SUFDekU7SUFDQTs7SUFFQSxHQUNBLE9BQU96bEIsT0FBT2lFLElBQUksRUFBRTtRQUFFLE9BQU8sSUFBSTZnQixlQUFlN2dCO0lBQU87SUFDdkRraEIsVUFBVTliLEVBQUUsRUFBRTlILEdBQUcsRUFBRTtRQUNmLElBQUl1QixPQUFPN0IsV0FBV29JLEdBQUcvSCxLQUFLLEdBQUdva0IsS0FBSzVpQixLQUFLYixPQUFPLENBQUNWO1FBQ25ELE1BQU9ta0IsTUFBTUEsR0FBRy9qQixJQUFJLElBQUksSUFBSSxDQUFDZ0MsT0FBTyxDQUNoQytoQixLQUFLQSxHQUFHMVUsTUFBTTtRQUNsQixJQUFJLENBQUMwVSxJQUNELE9BQU87UUFDWCxJQUFJeGpCLE9BQU85QjtRQUNYLElBQUksRUFBRW1QLG1CQUFtQixFQUFFLEdBQUdsRyxHQUFHaEYsT0FBTztRQUN4QyxJQUFJa0wscUJBQXFCO1lBQ3JCck4sT0FBTzBpQixhQUFhNWpCLEdBQUcsQ0FBQ3FJLEdBQUcvSCxLQUFLO1lBQ2hDLElBQUlZLFFBQVEsUUFBUUEsT0FBT1gsTUFBTSxLQUM3QlcsT0FBTzlCO1FBQ2Y7UUFDQSxJQUFJb1AsUUFBUW1XLFVBQVUsSUFBSSxFQUFFN2lCLE1BQU0sR0FBRzRpQixHQUFHeGpCLElBQUksRUFBRUEsU0FBUyxRQUFRQSxTQUFTLEtBQUssSUFBSUEsT0FBT1gsTUFBTXFrQixVQUFVdGtCO1FBQ3hHLElBQUlrTyxPQUFPO1lBQ1BsTyxRQUFRa08sTUFBTWxPLEtBQUs7WUFDbkJza0IsV0FBV3BXLE1BQU1qTyxHQUFHLEdBQUc7UUFDM0IsT0FDSztZQUNERCxRQUFRLElBQUksQ0FBQytqQixZQUFZLENBQUNwYixVQUFVLENBQUNaLEdBQUdpRixJQUFJO1lBQzVDc1gsV0FBVztRQUNmO1FBQ0EsSUFBSXJrQixNQUFNcWtCLFdBQVcsTUFBTSx1QkFBdUIsS0FDOUMsT0FBTztRQUNYLE1BQU9BLFdBQVdya0IsSUFBSztZQUNuQixJQUFJa08sT0FBT3BHLEdBQUcvSCxLQUFLLENBQUNtQixHQUFHLENBQUNpTixNQUFNLENBQUNrVyxXQUFXalIsTUFBTWxMLEtBQUtDLEdBQUcsQ0FBQ25JLEtBQUtrTyxLQUFLak4sRUFBRTtZQUNyRSxJQUFJaU4sS0FBSy9NLE1BQU0sRUFBRTtnQkFDYixJQUFJbWhCLGNBQWN0VSxzQkFBc0JBLG9CQUFvQkUsS0FBS3ZOLElBQUksSUFBSSxDQUFDO2dCQUMxRSxJQUFJMmpCLFNBQVMsSUFBSWhELGFBQWFwVCxLQUFLRyxJQUFJLEVBQUV2RyxHQUFHL0gsS0FBSyxDQUFDdU4sT0FBTyxFQUFFeEYsR0FBR2lGLElBQUksRUFBRXVWLGNBQWMsSUFBSXpqQixZQUFZeWpCO2dCQUNsRyxNQUFPZ0MsT0FBT3RrQixHQUFHLEdBQUdvVCxNQUFNbEYsS0FBS3ZOLElBQUksQ0FDL0I0akIsVUFBVSxJQUFJLENBQUNULFlBQVksQ0FBQzVELEtBQUssRUFBRW9FLFFBQVF2a0I7WUFDbkQsT0FDSztnQkFDRCxJQUFJLENBQUMrakIsWUFBWSxDQUFDZixTQUFTLENBQUNoakIsT0FBTytILEdBQUdpRixJQUFJO1lBQzlDO1lBQ0EsSUFBSXFHLE9BQU9wVCxLQUNQO1lBQ0pxa0IsV0FBV25XLEtBQUtqTixFQUFFLEdBQUc7UUFDekI7UUFDQSxJQUFJaU4sT0FBT3BHLEdBQUdxRyxNQUFNLENBQUNuTztRQUNyQixJQUFJZ08sdUJBQXVCck4sUUFBUSxNQUMvQjBpQixhQUFhak8sR0FBRyxDQUFDdE4sR0FBRy9ILEtBQUssRUFBRW1PLEtBQUt2TixJQUFJO1FBQ3hDLE9BQU8sSUFBSSxDQUFDbWpCLFlBQVksQ0FBQzFWLE1BQU0sQ0FBQ3JPLE9BQU8sV0FBV3VNLElBQUksQ0FBQzRCLEtBQUtHLElBQUksQ0FBQyxDQUFDLEVBQUUsRUFBRXZHO0lBQzFFO0lBQ0EsSUFBSTFHLGdCQUFnQjtRQUFFLE9BQU87SUFBTztBQUN4QztBQUNBLFNBQVNnakIsVUFBVXBqQixJQUFJLEVBQUVPLElBQUksRUFBRWlqQixHQUFHLEVBQUVDLFFBQVEsRUFBRUMsTUFBTTtJQUNoRCxJQUFJM2tCLFFBQVF5a0IsT0FBT0MsWUFBWUQsTUFBTWpqQixLQUFLSixNQUFNLElBQUl1akIsVUFBVW5qQixLQUFLbEIsSUFBSSxDQUFDVyxLQUFLK2lCLFVBQVU7SUFDdkYsSUFBSWhrQixPQUNBLE9BQU87UUFBRUEsT0FBT2lCLEtBQUs4aUIsWUFBWSxDQUFDZCxTQUFTLENBQUNqakI7UUFBUUMsS0FBS3drQixNQUFNampCLEtBQUtKLE1BQU07SUFBQztJQUMvRSxJQUFLLElBQUlXLElBQUlQLEtBQUtRLFFBQVEsQ0FBQ1osTUFBTSxHQUFHLEdBQUdXLEtBQUssR0FBR0EsSUFBSztRQUNoRCxJQUFJNmlCLFFBQVFwakIsS0FBS1EsUUFBUSxDQUFDRCxFQUFFLEVBQUU5QixNQUFNd2tCLE1BQU1qakIsS0FBS1UsU0FBUyxDQUFDSCxFQUFFO1FBQzNELElBQUk4SyxRQUFRK1gsaUJBQWlCaG9CLCtDQUFJQSxJQUFJcUQsTUFBTTBrQixVQUFVTixVQUFVcGpCLE1BQU0yakIsT0FBTzNrQixLQUFLeWtCLFVBQVVDO1FBQzNGLElBQUk5WCxPQUNBLE9BQU9BO0lBQ2Y7SUFDQSxPQUFPO0FBQ1g7QUFDQSxTQUFTZ1ksUUFBUTVqQixJQUFJLEVBQUVPLElBQUksRUFBRVosSUFBSSxFQUFFTSxFQUFFLEVBQUU0akIsTUFBTTtJQUN6QyxJQUFJQSxVQUFVbGtCLFFBQVEsS0FBS00sTUFBTU0sS0FBS0osTUFBTSxFQUN4QyxPQUFPSTtJQUNYLElBQUksQ0FBQ3NqQixVQUFVdGpCLEtBQUtuQixJQUFJLElBQUlZLEtBQUtvQixPQUFPLEVBQ3BDeWlCLFNBQVM7SUFDYixJQUFLLElBQUkvaUIsSUFBSVAsS0FBS1EsUUFBUSxDQUFDWixNQUFNLEdBQUcsR0FBR1csS0FBSyxHQUFHQSxJQUFLO1FBQ2hELElBQUk5QixNQUFNdUIsS0FBS1UsU0FBUyxDQUFDSCxFQUFFLEVBQUU2aUIsUUFBUXBqQixLQUFLUSxRQUFRLENBQUNELEVBQUUsRUFBRXlOO1FBQ3ZELElBQUl2UCxNQUFNaUIsTUFBTTBqQixpQkFBaUJob0IsK0NBQUlBLEVBQUU7WUFDbkMsSUFBSSxDQUFFNFMsQ0FBQUEsUUFBUXFWLFFBQVE1akIsTUFBTTJqQixPQUFPaGtCLE9BQU9YLEtBQUtpQixLQUFLakIsS0FBSzZrQixPQUFNLEdBQzNEO1lBQ0osT0FBTyxDQUFDQSxTQUFTdFYsUUFDWCxJQUFJNVMsK0NBQUlBLENBQUM0RSxLQUFLbkIsSUFBSSxFQUFFbUIsS0FBS1EsUUFBUSxDQUFDbUQsS0FBSyxDQUFDLEdBQUdwRCxHQUFHbEQsTUFBTSxDQUFDMlEsUUFBUWhPLEtBQUtVLFNBQVMsQ0FBQ2lELEtBQUssQ0FBQyxHQUFHcEQsSUFBSSxJQUFJOUIsTUFBTXVQLE1BQU1wTyxNQUFNO1FBQ3pIO0lBQ0o7SUFDQSxPQUFPO0FBQ1g7QUFDQSxTQUFTMmpCLHFCQUFxQjlqQixJQUFJLEVBQUVxRSxTQUFTLEVBQUVvZixRQUFRLEVBQUVNLFdBQVc7SUFDaEUsS0FBSyxJQUFJdGUsS0FBS3BCLFVBQVc7UUFDckIsSUFBSTFFLE9BQU84RixFQUFFOUYsSUFBSSxHQUFJOEYsQ0FBQUEsRUFBRXVlLFNBQVMsR0FBRyxLQUFLLElBQUkvakIsS0FBS3dGLEVBQUV4RixFQUFFLEdBQUl3RixDQUFBQSxFQUFFd2UsT0FBTyxHQUFHLEtBQUs7UUFDMUUsSUFBSXJZLFFBQVFqTSxRQUFROGpCLFlBQVl4akIsS0FBS3dqQixZQUFZTCxVQUFVcGpCLE1BQU15RixFQUFFbEYsSUFBSSxFQUFFLElBQUlrRixFQUFFeWUsTUFBTSxFQUFFVCxVQUFVeGpCLEtBQUtNO1FBQ3RHLElBQUlxTCxTQUFVckwsQ0FBQUEsT0FBT3FqQixRQUFRNWpCLE1BQU15RixFQUFFbEYsSUFBSSxFQUFFa2pCLFdBQVdoZSxFQUFFeWUsTUFBTSxFQUFFdFksTUFBTTVNLEdBQUcsR0FBR3lHLEVBQUV5ZSxNQUFNLEVBQUUsTUFBSyxHQUN2RixPQUFPO1lBQUVubEIsT0FBTzZNLE1BQU03TSxLQUFLO1lBQUV3QjtRQUFLO0lBQzFDO0lBQ0EsT0FBTztRQUFFeEIsT0FBT2lCLEtBQUs4aUIsWUFBWSxDQUFDcGIsVUFBVSxDQUFDcWMsY0FBYzNYLGNBQWMyWCxlQUFlO1FBQUl4akIsTUFBTTVFLCtDQUFJQSxDQUFDc0csS0FBSztJQUFDO0FBQ2pIO0FBQ0EsTUFBTTBnQjtJQUNGM2tCLFlBQVlnQyxJQUFJLEVBQUU2RyxLQUFLLEVBQUV4QyxTQUFTLEVBQUUwQixNQUFNLENBQUU7UUFDeEMsSUFBSSxDQUFDL0YsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQzZHLEtBQUssR0FBR0E7UUFDYixJQUFJLENBQUN4QyxTQUFTLEdBQUdBO1FBQ2pCLElBQUksQ0FBQzBCLE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUNiLFNBQVMsR0FBRztRQUNqQixJQUFJLENBQUNpZixNQUFNLEdBQUcsRUFBRTtRQUNoQixJQUFJLENBQUNDLFFBQVEsR0FBRyxFQUFFO1FBQ2xCLElBQUksQ0FBQ3ZnQixLQUFLLEdBQUcsRUFBRTtRQUNmLElBQUksQ0FBQ3dnQixXQUFXLEdBQUd4bUI7UUFDbkIsSUFBSSxDQUFDeW1CLFVBQVUsR0FBRztRQUNsQixJQUFJLENBQUNya0IsRUFBRSxHQUFHOEYsTUFBTSxDQUFDQSxPQUFPNUYsTUFBTSxHQUFHLEVBQUUsQ0FBQ0YsRUFBRTtRQUN0QyxJQUFJcUMsVUFBVThCLGFBQWEzRixHQUFHLElBQUlrQixPQUFPb0csTUFBTSxDQUFDLEVBQUUsQ0FBQ3BHLElBQUk7UUFDdkQsSUFBSSxFQUFFWixLQUFLLEVBQUV3QixJQUFJLEVBQUUsR0FBR3VqQixxQkFBcUI5akIsTUFBTXFFLFdBQVcxRSxNQUFNMkMsWUFBWSxRQUFRQSxZQUFZLEtBQUssSUFBSSxLQUFLLElBQUlBLFFBQVF2RCxLQUFLO1FBQ2pJLElBQUksQ0FBQ0EsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQ3lHLFNBQVMsR0FBRyxJQUFJLENBQUMrZSxVQUFVLEdBQUc1a0IsT0FBT1ksS0FBS0osTUFBTTtRQUNyRCxJQUFLLElBQUlXLElBQUksR0FBR0EsSUFBSVAsS0FBS1EsUUFBUSxDQUFDWixNQUFNLEVBQUVXLElBQUs7WUFDM0MsSUFBSSxDQUFDcWpCLE1BQU0sQ0FBQzNqQixJQUFJLENBQUNELEtBQUtRLFFBQVEsQ0FBQ0QsRUFBRTtZQUNqQyxJQUFJLENBQUNzakIsUUFBUSxDQUFDNWpCLElBQUksQ0FBQ0QsS0FBS1UsU0FBUyxDQUFDSCxFQUFFO1FBQ3hDO1FBQ0EsSUFBSXdCLFdBQVcsSUFBSSxDQUFDa0QsU0FBUyxHQUFHbEQsUUFBUUUsUUFBUSxDQUFDN0MsSUFBSSxHQUFHLE9BQU8sK0JBQStCLEtBQUk7WUFDOUYsSUFBSSxDQUFDWixLQUFLLEdBQUcsSUFBSSxDQUFDaUIsSUFBSSxDQUFDOGlCLFlBQVksQ0FBQ3BiLFVBQVUsQ0FBQzBFLGNBQWM5SixRQUFRdkQsS0FBSztZQUMxRXVELFFBQVFvRSxlQUFlLENBQUMsSUFBSSxDQUFDbEIsU0FBUyxFQUFFbEQsUUFBUUUsUUFBUSxDQUFDN0MsSUFBSTtZQUM3RCxJQUFJLENBQUM2RixTQUFTLEdBQUdsRCxRQUFRRSxRQUFRLENBQUM3QyxJQUFJO1FBQzFDO1FBQ0EsSUFBSSxDQUFDNmtCLGNBQWM7SUFDdkI7SUFDQW5mLFVBQVU7UUFDTixJQUFJL0MsVUFBVThCLGFBQWEzRixHQUFHO1FBQzlCLElBQUlnbUIsV0FBVyxJQUFJLENBQUN2ZixTQUFTLElBQUksT0FBTyxJQUFJLENBQUNqRixFQUFFLEdBQUdpSCxLQUFLQyxHQUFHLENBQUMsSUFBSSxDQUFDbEgsRUFBRSxFQUFFLElBQUksQ0FBQ2lGLFNBQVM7UUFDbEYsSUFBSWtOLE1BQU1sTCxLQUFLQyxHQUFHLENBQUNzZCxVQUFVLElBQUksQ0FBQ0YsVUFBVSxHQUFHLEtBQUssZUFBZTtRQUNuRSxJQUFJamlCLFNBQ0E4UCxNQUFNbEwsS0FBS0MsR0FBRyxDQUFDaUwsS0FBSzlQLFFBQVFFLFFBQVEsQ0FBQ3ZDLEVBQUU7UUFDM0MsTUFBTyxJQUFJLENBQUN1RixTQUFTLEdBQUc0TSxJQUNwQixJQUFJLENBQUNzUyxTQUFTLENBQUNwaUI7UUFDbkIsSUFBSSxJQUFJLENBQUNpaUIsVUFBVSxHQUFHLElBQUksQ0FBQy9lLFNBQVMsRUFDaEMsSUFBSSxDQUFDbWYsV0FBVztRQUNwQixJQUFJLElBQUksQ0FBQ25mLFNBQVMsSUFBSWlmLFVBQ2xCLE9BQU8sSUFBSSxDQUFDaE0sTUFBTTtRQUN0QixJQUFJblcsV0FBVyxJQUFJLENBQUNrRCxTQUFTLElBQUlsRCxRQUFRRSxRQUFRLENBQUN2QyxFQUFFLEVBQUU7WUFDbERxQyxRQUFRb0UsZUFBZSxDQUFDLElBQUksQ0FBQ2xCLFNBQVMsRUFBRWlmO1lBQ3hDLE9BQU8sSUFBSSxDQUFDaE0sTUFBTTtRQUN0QjtRQUNBLE9BQU87SUFDWDtJQUNBdFQsT0FBT25HLEdBQUcsRUFBRTtRQUNSLElBQUksQ0FBQ2tHLFNBQVMsR0FBR2xHO0lBQ3JCO0lBQ0E0bEIsVUFBVTVsQixHQUFHLEVBQUU7UUFDWCxJQUFJNkUsUUFBUSxJQUFJLENBQUNnRCxLQUFLLENBQUNoRCxLQUFLLENBQUM3RTtRQUM3QixJQUFJLENBQUMsSUFBSSxDQUFDNkgsS0FBSyxDQUFDL0MsVUFBVSxFQUFFO1lBQ3hCLElBQUk0YyxNQUFNN2MsTUFBTTBILE9BQU8sQ0FBQztZQUN4QixJQUFJbVYsTUFBTSxDQUFDLEdBQ1A3YyxRQUFRQSxNQUFNSyxLQUFLLENBQUMsR0FBR3djO1FBQy9CLE9BQ0ssSUFBSTdjLFNBQVMsTUFBTTtZQUNwQkEsUUFBUTtRQUNaO1FBQ0EsT0FBTzdFLE1BQU02RSxNQUFNMUQsTUFBTSxJQUFJLElBQUksQ0FBQ0YsRUFBRSxHQUFHNEQsUUFBUUEsTUFBTUssS0FBSyxDQUFDLEdBQUcsSUFBSSxDQUFDakUsRUFBRSxHQUFHakI7SUFDNUU7SUFDQTZsQixXQUFXO1FBQ1AsSUFBSWxsQixPQUFPLElBQUksQ0FBQzZGLFNBQVMsRUFBRTBILE9BQU8sSUFBSSxDQUFDMFgsU0FBUyxDQUFDamxCLE9BQU95UyxNQUFNelMsT0FBT3VOLEtBQUsvTSxNQUFNO1FBQ2hGLElBQUssSUFBSXFlLFFBQVEsSUFBSSxDQUFDOEYsVUFBVSxHQUFJO1lBQ2hDLElBQUlRLFdBQVcsSUFBSSxDQUFDL2UsTUFBTSxDQUFDeVksTUFBTSxDQUFDdmUsRUFBRTtZQUNwQyxJQUFJNmtCLFlBQVkxUyxLQUNaO1lBQ0psRixPQUFPQSxLQUFLaEosS0FBSyxDQUFDLEdBQUc0Z0IsV0FBWTFTLENBQUFBLE1BQU1sRixLQUFLL00sTUFBTTtZQUNsRHFlO1lBQ0EsSUFBSUEsU0FBUyxJQUFJLENBQUN6WSxNQUFNLENBQUM1RixNQUFNLEVBQzNCO1lBQ0osSUFBSTRrQixhQUFhLElBQUksQ0FBQ2hmLE1BQU0sQ0FBQ3lZLE1BQU0sQ0FBQzdlLElBQUk7WUFDeEMsSUFBSStRLFFBQVEsSUFBSSxDQUFDa1UsU0FBUyxDQUFDRztZQUMzQjdYLFFBQVF3RDtZQUNSMEIsTUFBTTJTLGFBQWFyVSxNQUFNdlEsTUFBTTtRQUNuQztRQUNBLE9BQU87WUFBRStNO1lBQU1rRjtRQUFJO0lBQ3ZCO0lBQ0E0UyxXQUFXaG1CLEdBQUcsRUFBRWtsQixNQUFNLEVBQUVqbEIsSUFBSSxFQUFFO1FBQzFCLE9BQVM7WUFDTCxJQUFJbVQsTUFBTSxJQUFJLENBQUNyTSxNQUFNLENBQUMsSUFBSSxDQUFDdWUsVUFBVSxDQUFDLENBQUNya0IsRUFBRSxFQUFFZ2xCLFNBQVNqbUIsTUFBTWtsQjtZQUMxRCxJQUFJamxCLE9BQU8sSUFBSW1ULE1BQU02UyxTQUFTN1MsT0FBTzZTLFFBQ2pDO1lBQ0osSUFBSWhZLFFBQVEsSUFBSSxDQUFDbEgsTUFBTSxDQUFDLEVBQUUsSUFBSSxDQUFDdWUsVUFBVSxDQUFDLENBQUMza0IsSUFBSTtZQUMvQ3VrQixVQUFValgsUUFBUW1GO1FBQ3RCO1FBQ0EsT0FBTzhSO0lBQ1g7SUFDQU0saUJBQWlCO1FBQ2IsTUFBTyxJQUFJLENBQUN6ZSxNQUFNLENBQUMsSUFBSSxDQUFDdWUsVUFBVSxDQUFDLENBQUNya0IsRUFBRSxHQUFHLElBQUksQ0FBQ3VGLFNBQVMsQ0FDbkQsSUFBSSxDQUFDOGUsVUFBVTtJQUN2QjtJQUNBWSxVQUFVQyxFQUFFLEVBQUV4bEIsSUFBSSxFQUFFTSxFQUFFLEVBQUVZLElBQUksRUFBRXFqQixNQUFNLEVBQUU7UUFDbEMsSUFBSSxJQUFJLENBQUNuZSxNQUFNLENBQUM1RixNQUFNLEdBQUcsR0FBRztZQUN4QitqQixTQUFTLElBQUksQ0FBQ2MsVUFBVSxDQUFDcmxCLE1BQU11a0IsUUFBUTtZQUN2Q3ZrQixRQUFRdWtCO1lBQ1IsSUFBSWtCLE9BQU8sSUFBSSxDQUFDdmhCLEtBQUssQ0FBQzFELE1BQU07WUFDNUIrakIsU0FBUyxJQUFJLENBQUNjLFVBQVUsQ0FBQy9rQixJQUFJaWtCLFFBQVEsQ0FBQztZQUN0Q2prQixNQUFNaWtCO1lBQ05yakIsUUFBUSxJQUFJLENBQUNnRCxLQUFLLENBQUMxRCxNQUFNLEdBQUdpbEI7UUFDaEM7UUFDQSxJQUFJLENBQUN2aEIsS0FBSyxDQUFDckQsSUFBSSxDQUFDMmtCLElBQUl4bEIsTUFBTU0sSUFBSVk7UUFDOUIsT0FBT3FqQjtJQUNYO0lBQ0FRLFVBQVVwaUIsT0FBTyxFQUFFO1FBQ2YsSUFBSSxFQUFFNEssSUFBSSxFQUFFa0YsR0FBRyxFQUFFLEdBQUcsSUFBSSxDQUFDeVMsUUFBUSxJQUFJWCxTQUFTLEdBQUcsRUFBRXBCLFlBQVksRUFBRSxHQUFHLElBQUksQ0FBQzlpQixJQUFJO1FBQzdFLElBQUlzakIsU0FBUyxJQUFJaEQsYUFBYXBULE1BQU01SyxVQUFVQSxRQUFRdkQsS0FBSyxDQUFDdU4sT0FBTyxHQUFHLEdBQUdoSyxVQUFVOEosY0FBYzlKLFFBQVF2RCxLQUFLLElBQUk7UUFDbEgsSUFBSXVrQixPQUFPNUMsR0FBRyxJQUFJO1lBQ2RvQyxhQUFhZixTQUFTLENBQUMsSUFBSSxDQUFDaGpCLEtBQUssRUFBRXVrQixPQUFPeFgsVUFBVTtRQUN4RCxPQUNLO1lBQ0QsTUFBTyxDQUFDd1gsT0FBTzVDLEdBQUcsR0FBSTtnQkFDbEIsSUFBSXhCLFFBQVFxRSxVQUFVVCxhQUFhNUQsS0FBSyxFQUFFb0UsUUFBUSxJQUFJLENBQUN2a0IsS0FBSztnQkFDNUQsSUFBSW1nQixPQUNBZ0YsU0FBUyxJQUFJLENBQUNnQixTQUFTLENBQUMsSUFBSSxDQUFDbGxCLElBQUksQ0FBQ2tpQixVQUFVLENBQUN4aUIsT0FBTyxDQUFDd2YsUUFBUSxJQUFJLENBQUMxWixTQUFTLEdBQUc4ZCxPQUFPclcsS0FBSyxFQUFFLElBQUksQ0FBQ3pILFNBQVMsR0FBRzhkLE9BQU90a0IsR0FBRyxFQUFFLEdBQUdrbEI7Z0JBQ2hJLElBQUlaLE9BQU9yVyxLQUFLLEdBQUcsTUFBTSxtQkFBbUIsS0FDeEM7WUFDUjtRQUNKO1FBQ0EsSUFBSSxDQUFDekgsU0FBUyxHQUFHNE07UUFDakIsSUFBSSxDQUFDb1MsY0FBYztRQUNuQixJQUFJLElBQUksQ0FBQ2hmLFNBQVMsR0FBRyxJQUFJLENBQUN2RixFQUFFLEVBQ3hCLElBQUksQ0FBQ3VGLFNBQVM7SUFDdEI7SUFDQW1mLGNBQWM7UUFDVixJQUFJcGtCLE9BQU81RSwrQ0FBSUEsQ0FBQzBwQixLQUFLLENBQUM7WUFDbEJDLFFBQVEsSUFBSSxDQUFDemhCLEtBQUs7WUFDbEJvSixPQUFPLElBQUksQ0FBQ3NYLFVBQVU7WUFDdEJwa0IsUUFBUSxJQUFJLENBQUNxRixTQUFTLEdBQUcsSUFBSSxDQUFDK2UsVUFBVTtZQUN4Q2dCO1lBQ0FDLE9BQU87WUFDUEMsaUJBQWlCLEtBQUssZUFBZTtZQUNyQ0MsUUFBUSxJQUFJLENBQUNyQixXQUFXO1FBQzVCO1FBQ0E5akIsT0FBTyxJQUFJNUUsK0NBQUlBLENBQUM0RSxLQUFLbkIsSUFBSSxFQUFFbUIsS0FBS1EsUUFBUSxFQUFFUixLQUFLVSxTQUFTLEVBQUVWLEtBQUtKLE1BQU0sRUFBRTtZQUFDO2dCQUFDLElBQUksQ0FBQ0gsSUFBSSxDQUFDK2lCLFVBQVU7Z0JBQUUsSUFBSSxDQUFDL2lCLElBQUksQ0FBQzhpQixZQUFZLENBQUNkLFNBQVMsQ0FBQyxJQUFJLENBQUNqakIsS0FBSzthQUFFO1NBQUM7UUFDN0ksSUFBSSxDQUFDb2xCLE1BQU0sQ0FBQzNqQixJQUFJLENBQUNEO1FBQ2pCLElBQUksQ0FBQzZqQixRQUFRLENBQUM1akIsSUFBSSxDQUFDLElBQUksQ0FBQytqQixVQUFVLEdBQUcsSUFBSSxDQUFDeGUsTUFBTSxDQUFDLEVBQUUsQ0FBQ3BHLElBQUk7UUFDeEQsSUFBSSxDQUFDa0UsS0FBSyxHQUFHLEVBQUU7UUFDZixJQUFJLENBQUN3Z0IsV0FBVyxHQUFHeG1CO1FBQ25CLElBQUksQ0FBQzBtQixVQUFVLEdBQUcsSUFBSSxDQUFDL2UsU0FBUztJQUNwQztJQUNBaVQsU0FBUztRQUNMLE9BQU8sSUFBSTljLCtDQUFJQSxDQUFDLElBQUksQ0FBQ3FFLElBQUksQ0FBQ29CLE9BQU8sRUFBRSxJQUFJLENBQUMraUIsTUFBTSxFQUFFLElBQUksQ0FBQ0MsUUFBUSxFQUFFLElBQUksQ0FBQzVlLFNBQVMsR0FBRyxJQUFJLENBQUNPLE1BQU0sQ0FBQyxFQUFFLENBQUNwRyxJQUFJLEVBQUVnbUIsT0FBTztJQUNoSDtBQUNKO0FBQ0EsU0FBU3BDLFVBQVVyRSxLQUFLLEVBQUVvRSxNQUFNLEVBQUV2a0IsS0FBSztJQUNuQ3VrQixPQUFPclcsS0FBSyxHQUFHcVcsT0FBT3RrQixHQUFHO0lBQ3pCLElBQUssSUFBSThCLElBQUksR0FBR0EsSUFBSSxJQUFJQSxJQUFLO1FBQ3pCLElBQUlULFNBQVM2ZSxNQUFNb0UsUUFBUXZrQjtRQUMzQixJQUFJdWtCLE9BQU90a0IsR0FBRyxHQUFHc2tCLE9BQU9yVyxLQUFLLEVBQ3pCLE9BQU81TTtJQUNmO0lBQ0EsTUFBTSxJQUFJNEwsTUFBTTtBQUNwQjtBQUNBLE1BQU1rVyxXQUFXLFdBQVcsR0FBRTVqQixPQUFPbUcsTUFBTSxDQUFDO0FBQzVDLE1BQU1raEIsWUFBWTtJQUFDOXBCLG1EQUFRQSxDQUFDbUwsSUFBSTtDQUFDO0FBQ2pDLE1BQU1zZSxVQUFVLFdBQVcsR0FBRSxJQUFJeHBCLGtEQUFPQSxDQUFDNnBCO0FBQ3pDLE1BQU1DLFNBQVMsRUFBRTtBQUNqQix1Q0FBdUM7QUFDdkMsTUFBTUMsUUFBUSxXQUFXLEdBQUV2bkIsT0FBT21HLE1BQU0sQ0FBQztBQUN6QyxNQUFNcWhCLGVBQWUsV0FBVyxHQUFFeG5CLE9BQU9tRyxNQUFNLENBQUM7QUFDaEQsS0FBSyxJQUFJLENBQUNzaEIsWUFBWTVuQixLQUFLLElBQUk7SUFDM0I7UUFBQztRQUFZO0tBQWU7SUFDNUI7UUFBQztRQUFjO0tBQXVCO0lBQ3RDO1FBQUM7UUFBWTtLQUFpQjtJQUM5QjtRQUFDO1FBQU87S0FBMEI7SUFDbEM7UUFBQztRQUFPO0tBQVU7SUFDbEI7UUFBQztRQUFhO0tBQWdCO0lBQzlCO1FBQUM7UUFBUTtLQUFXO0lBQ3BCO1FBQUM7UUFBVztLQUF3QjtJQUNwQztRQUFDO1FBQWE7S0FBVztJQUN6QjtRQUFDO1FBQVM7S0FBVTtJQUNwQjtRQUFDO1FBQVU7S0FBVTtJQUNyQjtRQUFDO1FBQVk7S0FBZTtDQUMvQixDQUNHMm5CLFlBQVksQ0FBQ0MsV0FBVyxHQUFHLFdBQVcsR0FBRUMsZ0JBQWdCOUQsVUFBVS9qQjtBQUN0RSxNQUFNNmtCO0lBQ0ZqbEIsWUFBWWtvQixLQUFLLENBQUU7UUFDZixJQUFJLENBQUNBLEtBQUssR0FBR0E7UUFDYixJQUFJLENBQUNDLEtBQUssR0FBRzVuQixPQUFPeVosTUFBTSxDQUFDelosT0FBT21HLE1BQU0sQ0FBQyxPQUFPcWhCO0lBQ3BEO0lBQ0FybUIsUUFBUW1hLEdBQUcsRUFBRTtRQUNULE9BQU8sQ0FBQ0EsTUFBTSxJQUFJLElBQUksQ0FBQ3NNLEtBQUssQ0FBQ3RNLElBQUksSUFBSyxLQUFJLENBQUNzTSxLQUFLLENBQUN0TSxJQUFJLEdBQUdvTSxnQkFBZ0IsSUFBSSxDQUFDQyxLQUFLLEVBQUVyTSxJQUFHO0lBQzNGO0FBQ0o7QUFDQSxNQUFNcUosb0JBQW9CLFdBQVcsR0FBRSxJQUFJRCxXQUFXZDtBQUN0RCxTQUFTaUUsWUFBWUMsSUFBSSxFQUFFQyxHQUFHO0lBQzFCLElBQUlULE9BQU90YSxPQUFPLENBQUM4YSxRQUFRLENBQUMsR0FDeEI7SUFDSlIsT0FBT3JsQixJQUFJLENBQUM2bEI7SUFDWkUsUUFBUUMsSUFBSSxDQUFDRjtBQUNqQjtBQUNBLFNBQVNMLGdCQUFnQkMsS0FBSyxFQUFFTyxNQUFNO0lBQ2xDLElBQUlDLFNBQVMsRUFBRTtJQUNmLEtBQUssSUFBSXRvQixRQUFRcW9CLE9BQU9FLEtBQUssQ0FBQyxLQUFNO1FBQ2hDLElBQUkvYSxRQUFRLEVBQUU7UUFDZCxLQUFLLElBQUl5YSxRQUFRam9CLEtBQUt1b0IsS0FBSyxDQUFDLEtBQU07WUFDOUIsSUFBSS9pQixRQUFTc2lCLEtBQUssQ0FBQ0csS0FBSyxJQUFJcnBCLGtEQUFJLENBQUNxcEIsS0FBSztZQUN0QyxJQUFJLENBQUN6aUIsT0FBTztnQkFDUndpQixZQUFZQyxNQUFNLENBQUMseUJBQXlCLEVBQUVBLEtBQUssQ0FBQztZQUN4RCxPQUNLLElBQUksT0FBT3ppQixTQUFTLFlBQVk7Z0JBQ2pDLElBQUksQ0FBQ2dJLE1BQU16TCxNQUFNLEVBQ2JpbUIsWUFBWUMsTUFBTSxDQUFDLFNBQVMsRUFBRUEsS0FBSyxxQkFBcUIsQ0FBQztxQkFFekR6YSxRQUFRQSxNQUFNYixHQUFHLENBQUNuSDtZQUMxQixPQUNLO2dCQUNELElBQUlnSSxNQUFNekwsTUFBTSxFQUNaaW1CLFlBQVlDLE1BQU0sQ0FBQyxJQUFJLEVBQUVBLEtBQUssaUJBQWlCLENBQUM7cUJBRWhEemEsUUFBUUksTUFBTW1JLE9BQU8sQ0FBQ3ZRLFNBQVNBLFFBQVE7b0JBQUNBO2lCQUFNO1lBQ3REO1FBQ0o7UUFDQSxLQUFLLElBQUlpVyxPQUFPak8sTUFDWjhhLE9BQU9sbUIsSUFBSSxDQUFDcVo7SUFDcEI7SUFDQSxJQUFJLENBQUM2TSxPQUFPdm1CLE1BQU0sRUFDZCxPQUFPO0lBQ1gsSUFBSS9CLE9BQU9xb0IsT0FBT2xULE9BQU8sQ0FBQyxNQUFNLE1BQU1xQyxNQUFNeFgsT0FBTyxNQUFNc29CLE9BQU8zYixHQUFHLENBQUM2YixDQUFBQSxJQUFLQSxFQUFFekIsRUFBRTtJQUM3RSxJQUFJMEIsUUFBUWYsS0FBSyxDQUFDbFEsSUFBSTtJQUN0QixJQUFJaVIsT0FDQSxPQUFPQSxNQUFNMUIsRUFBRTtJQUNuQixJQUFJL2xCLE9BQU8wbUIsS0FBSyxDQUFDbFEsSUFBSSxHQUFHOVosbURBQVFBLENBQUMyQixNQUFNLENBQUM7UUFDcEMwbkIsSUFBSVMsVUFBVXpsQixNQUFNO1FBQ3BCL0I7UUFDQXdELE9BQU87WUFBQ3pFLDJEQUFTQSxDQUFDO2dCQUFFLENBQUNpQixLQUFLLEVBQUVzb0I7WUFBTztTQUFHO0lBQzFDO0lBQ0FkLFVBQVVwbEIsSUFBSSxDQUFDcEI7SUFDZixPQUFPQSxLQUFLK2xCLEVBQUU7QUFDbEI7QUFDQSxTQUFTdEMsTUFBTTVrQixJQUFJO0lBQ2YsSUFBSW1CLE9BQU90RCxtREFBUUEsQ0FBQzJCLE1BQU0sQ0FBQztRQUFFMG5CLElBQUlTLFVBQVV6bEIsTUFBTTtRQUFFL0IsTUFBTTtRQUFZd0QsT0FBTztZQUFDdEUsaUJBQWlCdUUsR0FBRyxDQUFDLElBQU01RDtTQUFNO1FBQUVpQixLQUFLO0lBQUs7SUFDMUgwbUIsVUFBVXBsQixJQUFJLENBQUNwQjtJQUNmLE9BQU9BO0FBQ1g7QUFFMHhCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHl0aG9uLW9ubGluZS1lZGl0b3IvLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGFuZ3VhZ2UvZGlzdC9pbmRleC5qcz9kNzNkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE5vZGVQcm9wLCBJdGVyTW9kZSwgVHJlZSwgVHJlZUZyYWdtZW50LCBQYXJzZXIsIE5vZGVUeXBlLCBOb2RlU2V0IH0gZnJvbSAnQGxlemVyL2NvbW1vbic7XG5pbXBvcnQgeyBTdGF0ZUVmZmVjdCwgU3RhdGVGaWVsZCwgRmFjZXQsIEVkaXRvclN0YXRlLCBjb3VudENvbHVtbiwgY29tYmluZUNvbmZpZywgUmFuZ2VTZXQsIFJhbmdlU2V0QnVpbGRlciwgUHJlYyB9IGZyb20gJ0Bjb2RlbWlycm9yL3N0YXRlJztcbmltcG9ydCB7IFZpZXdQbHVnaW4sIGxvZ0V4Y2VwdGlvbiwgRWRpdG9yVmlldywgRGVjb3JhdGlvbiwgV2lkZ2V0VHlwZSwgZ3V0dGVyLCBHdXR0ZXJNYXJrZXIgfSBmcm9tICdAY29kZW1pcnJvci92aWV3JztcbmltcG9ydCB7IHRhZ3MsIHRhZ0hpZ2hsaWdodGVyLCBoaWdobGlnaHRUcmVlLCBzdHlsZVRhZ3MgfSBmcm9tICdAbGV6ZXIvaGlnaGxpZ2h0JztcbmltcG9ydCB7IFN0eWxlTW9kdWxlIH0gZnJvbSAnc3R5bGUtbW9kJztcblxudmFyIF9hO1xuLyoqXG5Ob2RlIHByb3Agc3RvcmVkIGluIGEgcGFyc2VyJ3MgdG9wIHN5bnRheCBub2RlIHRvIHByb3ZpZGUgdGhlXG5mYWNldCB0aGF0IHN0b3JlcyBsYW5ndWFnZS1zcGVjaWZpYyBkYXRhIGZvciB0aGF0IGxhbmd1YWdlLlxuKi9cbmNvbnN0IGxhbmd1YWdlRGF0YVByb3AgPSAvKkBfX1BVUkVfXyovbmV3IE5vZGVQcm9wKCk7XG4vKipcbkhlbHBlciBmdW5jdGlvbiB0byBkZWZpbmUgYSBmYWNldCAodG8gYmUgYWRkZWQgdG8gdGhlIHRvcCBzeW50YXhcbm5vZGUocykgZm9yIGEgbGFuZ3VhZ2UgdmlhXG5bYGxhbmd1YWdlRGF0YVByb3BgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmxhbmd1YWdlRGF0YVByb3ApKSwgdGhhdCB3aWxsIGJlXG51c2VkIHRvIGFzc29jaWF0ZSBsYW5ndWFnZSBkYXRhIHdpdGggdGhlIGxhbmd1YWdlLiBZb3VcbnByb2JhYmx5IG9ubHkgbmVlZCB0aGlzIHdoZW4gc3ViY2xhc3NpbmdcbltgTGFuZ3VhZ2VgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLkxhbmd1YWdlKS5cbiovXG5mdW5jdGlvbiBkZWZpbmVMYW5ndWFnZUZhY2V0KGJhc2VEYXRhKSB7XG4gICAgcmV0dXJuIEZhY2V0LmRlZmluZSh7XG4gICAgICAgIGNvbWJpbmU6IGJhc2VEYXRhID8gdmFsdWVzID0+IHZhbHVlcy5jb25jYXQoYmFzZURhdGEpIDogdW5kZWZpbmVkXG4gICAgfSk7XG59XG4vKipcblN5bnRheCBub2RlIHByb3AgdXNlZCB0byByZWdpc3RlciBzdWJsYW5ndWFnZXMuIFNob3VsZCBiZSBhZGRlZCB0b1xudGhlIHRvcCBsZXZlbCBub2RlIHR5cGUgZm9yIHRoZSBsYW5ndWFnZS5cbiovXG5jb25zdCBzdWJsYW5ndWFnZVByb3AgPSAvKkBfX1BVUkVfXyovbmV3IE5vZGVQcm9wKCk7XG4vKipcbkEgbGFuZ3VhZ2Ugb2JqZWN0IG1hbmFnZXMgcGFyc2luZyBhbmQgcGVyLWxhbmd1YWdlXG5bbWV0YWRhdGFdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUubGFuZ3VhZ2VEYXRhQXQpLiBQYXJzZSBkYXRhIGlzXG5tYW5hZ2VkIGFzIGEgW0xlemVyXShodHRwczovL2xlemVyLmNvZGVtaXJyb3IubmV0KSB0cmVlLiBUaGUgY2xhc3NcbmNhbiBiZSB1c2VkIGRpcmVjdGx5LCB2aWEgdGhlIFtgTFJMYW5ndWFnZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuTFJMYW5ndWFnZSlcbnN1YmNsYXNzIGZvciBbTGV6ZXJdKGh0dHBzOi8vbGV6ZXIuY29kZW1pcnJvci5uZXQvKSBMUiBwYXJzZXJzLCBvclxudmlhIHRoZSBbYFN0cmVhbUxhbmd1YWdlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5TdHJlYW1MYW5ndWFnZSkgc3ViY2xhc3NcbmZvciBzdHJlYW0gcGFyc2Vycy5cbiovXG5jbGFzcyBMYW5ndWFnZSB7XG4gICAgLyoqXG4gICAgQ29uc3RydWN0IGEgbGFuZ3VhZ2Ugb2JqZWN0LiBJZiB5b3UgbmVlZCB0byBpbnZva2UgdGhpc1xuICAgIGRpcmVjdGx5LCBmaXJzdCBkZWZpbmUgYSBkYXRhIGZhY2V0IHdpdGhcbiAgICBbYGRlZmluZUxhbmd1YWdlRmFjZXRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmRlZmluZUxhbmd1YWdlRmFjZXQpLCBhbmQgdGhlblxuICAgIGNvbmZpZ3VyZSB5b3VyIHBhcnNlciB0byBbYXR0YWNoXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmxhbmd1YWdlRGF0YVByb3ApIGl0XG4gICAgdG8gdGhlIGxhbmd1YWdlJ3Mgb3V0ZXIgc3ludGF4IG5vZGUuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgW2xhbmd1YWdlIGRhdGFdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUubGFuZ3VhZ2VEYXRhQXQpIGZhY2V0XG4gICAgdXNlZCBmb3IgdGhpcyBsYW5ndWFnZS5cbiAgICAqL1xuICAgIGRhdGEsIHBhcnNlciwgZXh0cmFFeHRlbnNpb25zID0gW10sIFxuICAgIC8qKlxuICAgIEEgbGFuZ3VhZ2UgbmFtZS5cbiAgICAqL1xuICAgIG5hbWUgPSBcIlwiKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIC8vIEtsdWRnZSB0byBkZWZpbmUgRWRpdG9yU3RhdGUudHJlZSBhcyBhIGRlYnVnZ2luZyBoZWxwZXIsXG4gICAgICAgIC8vIHdpdGhvdXQgdGhlIEVkaXRvclN0YXRlIHBhY2thZ2UgYWN0dWFsbHkga25vd2luZyBhYm91dFxuICAgICAgICAvLyBsYW5ndWFnZXMgYW5kIGxlemVyIHRyZWVzLlxuICAgICAgICBpZiAoIUVkaXRvclN0YXRlLnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eShcInRyZWVcIikpXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRWRpdG9yU3RhdGUucHJvdG90eXBlLCBcInRyZWVcIiwgeyBnZXQoKSB7IHJldHVybiBzeW50YXhUcmVlKHRoaXMpOyB9IH0pO1xuICAgICAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICAgICAgdGhpcy5leHRlbnNpb24gPSBbXG4gICAgICAgICAgICBsYW5ndWFnZS5vZih0aGlzKSxcbiAgICAgICAgICAgIEVkaXRvclN0YXRlLmxhbmd1YWdlRGF0YS5vZigoc3RhdGUsIHBvcywgc2lkZSkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCB0b3AgPSB0b3BOb2RlQXQoc3RhdGUsIHBvcywgc2lkZSksIGRhdGEgPSB0b3AudHlwZS5wcm9wKGxhbmd1YWdlRGF0YVByb3ApO1xuICAgICAgICAgICAgICAgIGlmICghZGF0YSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICAgIGxldCBiYXNlID0gc3RhdGUuZmFjZXQoZGF0YSksIHN1YiA9IHRvcC50eXBlLnByb3Aoc3VibGFuZ3VhZ2VQcm9wKTtcbiAgICAgICAgICAgICAgICBpZiAoc3ViKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpbm5lck5vZGUgPSB0b3AucmVzb2x2ZShwb3MgLSB0b3AuZnJvbSwgc2lkZSk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHN1Ymxhbmcgb2Ygc3ViKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN1YmxhbmcudGVzdChpbm5lck5vZGUsIHN0YXRlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkYXRhID0gc3RhdGUuZmFjZXQoc3VibGFuZy5mYWNldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1YmxhbmcudHlwZSA9PSBcInJlcGxhY2VcIiA/IGRhdGEgOiBkYXRhLmNvbmNhdChiYXNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgICAgICAgICB9KVxuICAgICAgICBdLmNvbmNhdChleHRyYUV4dGVuc2lvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICBRdWVyeSB3aGV0aGVyIHRoaXMgbGFuZ3VhZ2UgaXMgYWN0aXZlIGF0IHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAgICAqL1xuICAgIGlzQWN0aXZlQXQoc3RhdGUsIHBvcywgc2lkZSA9IC0xKSB7XG4gICAgICAgIHJldHVybiB0b3BOb2RlQXQoc3RhdGUsIHBvcywgc2lkZSkudHlwZS5wcm9wKGxhbmd1YWdlRGF0YVByb3ApID09IHRoaXMuZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgZG9jdW1lbnQgcmVnaW9ucyB0aGF0IHdlcmUgcGFyc2VkIHVzaW5nIHRoaXMgbGFuZ3VhZ2UuXG4gICAgVGhlIHJldHVybmVkIHJlZ2lvbnMgd2lsbCBfaW5jbHVkZV8gYW55IG5lc3RlZCBsYW5ndWFnZXMgcm9vdGVkXG4gICAgaW4gdGhpcyBsYW5ndWFnZSwgd2hlbiB0aG9zZSBleGlzdC5cbiAgICAqL1xuICAgIGZpbmRSZWdpb25zKHN0YXRlKSB7XG4gICAgICAgIGxldCBsYW5nID0gc3RhdGUuZmFjZXQobGFuZ3VhZ2UpO1xuICAgICAgICBpZiAoKGxhbmcgPT09IG51bGwgfHwgbGFuZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGFuZy5kYXRhKSA9PSB0aGlzLmRhdGEpXG4gICAgICAgICAgICByZXR1cm4gW3sgZnJvbTogMCwgdG86IHN0YXRlLmRvYy5sZW5ndGggfV07XG4gICAgICAgIGlmICghbGFuZyB8fCAhbGFuZy5hbGxvd3NOZXN0aW5nKVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGxldCBleHBsb3JlID0gKHRyZWUsIGZyb20pID0+IHtcbiAgICAgICAgICAgIGlmICh0cmVlLnByb3AobGFuZ3VhZ2VEYXRhUHJvcCkgPT0gdGhpcy5kYXRhKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goeyBmcm9tLCB0bzogZnJvbSArIHRyZWUubGVuZ3RoIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBtb3VudCA9IHRyZWUucHJvcChOb2RlUHJvcC5tb3VudGVkKTtcbiAgICAgICAgICAgIGlmIChtb3VudCkge1xuICAgICAgICAgICAgICAgIGlmIChtb3VudC50cmVlLnByb3AobGFuZ3VhZ2VEYXRhUHJvcCkgPT0gdGhpcy5kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb3VudC5vdmVybGF5KVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgciBvZiBtb3VudC5vdmVybGF5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHsgZnJvbTogci5mcm9tICsgZnJvbSwgdG86IHIudG8gKyBmcm9tIH0pO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7IGZyb206IGZyb20sIHRvOiBmcm9tICsgdHJlZS5sZW5ndGggfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobW91bnQub3ZlcmxheSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgc2l6ZSA9IHJlc3VsdC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGV4cGxvcmUobW91bnQudHJlZSwgbW91bnQub3ZlcmxheVswXS5mcm9tICsgZnJvbSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID4gc2l6ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRyZWUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgY2ggPSB0cmVlLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGlmIChjaCBpbnN0YW5jZW9mIFRyZWUpXG4gICAgICAgICAgICAgICAgICAgIGV4cGxvcmUoY2gsIHRyZWUucG9zaXRpb25zW2ldICsgZnJvbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGV4cGxvcmUoc3ludGF4VHJlZShzdGF0ZSksIDApO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICBJbmRpY2F0ZXMgd2hldGhlciB0aGlzIGxhbmd1YWdlIGFsbG93cyBuZXN0ZWQgbGFuZ3VhZ2VzLiBUaGVcbiAgICBkZWZhdWx0IGltcGxlbWVudGF0aW9uIHJldHVybnMgdHJ1ZS5cbiAgICAqL1xuICAgIGdldCBhbGxvd3NOZXN0aW5nKCkgeyByZXR1cm4gdHJ1ZTsgfVxufVxuLyoqXG5AaW50ZXJuYWxcbiovXG5MYW5ndWFnZS5zZXRTdGF0ZSA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcbmZ1bmN0aW9uIHRvcE5vZGVBdChzdGF0ZSwgcG9zLCBzaWRlKSB7XG4gICAgbGV0IHRvcExhbmcgPSBzdGF0ZS5mYWNldChsYW5ndWFnZSksIHRyZWUgPSBzeW50YXhUcmVlKHN0YXRlKS50b3BOb2RlO1xuICAgIGlmICghdG9wTGFuZyB8fCB0b3BMYW5nLmFsbG93c05lc3RpbmcpIHtcbiAgICAgICAgZm9yIChsZXQgbm9kZSA9IHRyZWU7IG5vZGU7IG5vZGUgPSBub2RlLmVudGVyKHBvcywgc2lkZSwgSXRlck1vZGUuRXhjbHVkZUJ1ZmZlcnMpKVxuICAgICAgICAgICAgaWYgKG5vZGUudHlwZS5pc1RvcClcbiAgICAgICAgICAgICAgICB0cmVlID0gbm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIHRyZWU7XG59XG4vKipcbkEgc3ViY2xhc3Mgb2YgW2BMYW5ndWFnZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuTGFuZ3VhZ2UpIGZvciB1c2Ugd2l0aCBMZXplclxuW0xSIHBhcnNlcnNdKGh0dHBzOi8vbGV6ZXIuY29kZW1pcnJvci5uZXQvZG9jcy9yZWYjbHIuTFJQYXJzZXIpXG5wYXJzZXJzLlxuKi9cbmNsYXNzIExSTGFuZ3VhZ2UgZXh0ZW5kcyBMYW5ndWFnZSB7XG4gICAgY29uc3RydWN0b3IoZGF0YSwgcGFyc2VyLCBuYW1lKSB7XG4gICAgICAgIHN1cGVyKGRhdGEsIHBhcnNlciwgW10sIG5hbWUpO1xuICAgICAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgRGVmaW5lIGEgbGFuZ3VhZ2UgZnJvbSBhIHBhcnNlci5cbiAgICAqL1xuICAgIHN0YXRpYyBkZWZpbmUoc3BlYykge1xuICAgICAgICBsZXQgZGF0YSA9IGRlZmluZUxhbmd1YWdlRmFjZXQoc3BlYy5sYW5ndWFnZURhdGEpO1xuICAgICAgICByZXR1cm4gbmV3IExSTGFuZ3VhZ2UoZGF0YSwgc3BlYy5wYXJzZXIuY29uZmlndXJlKHtcbiAgICAgICAgICAgIHByb3BzOiBbbGFuZ3VhZ2VEYXRhUHJvcC5hZGQodHlwZSA9PiB0eXBlLmlzVG9wID8gZGF0YSA6IHVuZGVmaW5lZCldXG4gICAgICAgIH0pLCBzcGVjLm5hbWUpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgdGhpcyBsYW5ndWFnZSB3aXRoIGEgcmVjb25maWd1cmVkXG4gICAgdmVyc2lvbiBvZiBpdHMgcGFyc2VyIGFuZCBvcHRpb25hbGx5IGEgbmV3IG5hbWUuXG4gICAgKi9cbiAgICBjb25maWd1cmUob3B0aW9ucywgbmFtZSkge1xuICAgICAgICByZXR1cm4gbmV3IExSTGFuZ3VhZ2UodGhpcy5kYXRhLCB0aGlzLnBhcnNlci5jb25maWd1cmUob3B0aW9ucyksIG5hbWUgfHwgdGhpcy5uYW1lKTtcbiAgICB9XG4gICAgZ2V0IGFsbG93c05lc3RpbmcoKSB7IHJldHVybiB0aGlzLnBhcnNlci5oYXNXcmFwcGVycygpOyB9XG59XG4vKipcbkdldCB0aGUgc3ludGF4IHRyZWUgZm9yIGEgc3RhdGUsIHdoaWNoIGlzIHRoZSBjdXJyZW50IChwb3NzaWJseVxuaW5jb21wbGV0ZSkgcGFyc2UgdHJlZSBvZiB0aGUgYWN0aXZlXG5bbGFuZ3VhZ2VdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuTGFuZ3VhZ2UpLCBvciB0aGUgZW1wdHkgdHJlZSBpZiB0aGVyZSBpcyBub1xubGFuZ3VhZ2UgYXZhaWxhYmxlLlxuKi9cbmZ1bmN0aW9uIHN5bnRheFRyZWUoc3RhdGUpIHtcbiAgICBsZXQgZmllbGQgPSBzdGF0ZS5maWVsZChMYW5ndWFnZS5zdGF0ZSwgZmFsc2UpO1xuICAgIHJldHVybiBmaWVsZCA/IGZpZWxkLnRyZWUgOiBUcmVlLmVtcHR5O1xufVxuLyoqXG5UcnkgdG8gZ2V0IGEgcGFyc2UgdHJlZSB0aGF0IHNwYW5zIGF0IGxlYXN0IHVwIHRvIGB1cHRvYC4gVGhlXG5tZXRob2Qgd2lsbCBkbyBhdCBtb3N0IGB0aW1lb3V0YCBtaWxsaXNlY29uZHMgb2Ygd29yayB0byBwYXJzZVxudXAgdG8gdGhhdCBwb2ludCBpZiB0aGUgdHJlZSBpc24ndCBhbHJlYWR5IGF2YWlsYWJsZS5cbiovXG5mdW5jdGlvbiBlbnN1cmVTeW50YXhUcmVlKHN0YXRlLCB1cHRvLCB0aW1lb3V0ID0gNTApIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IHBhcnNlID0gKF9hID0gc3RhdGUuZmllbGQoTGFuZ3VhZ2Uuc3RhdGUsIGZhbHNlKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbnRleHQ7XG4gICAgaWYgKCFwYXJzZSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IG9sZFZpZXBvcnQgPSBwYXJzZS52aWV3cG9ydDtcbiAgICBwYXJzZS51cGRhdGVWaWV3cG9ydCh7IGZyb206IDAsIHRvOiB1cHRvIH0pO1xuICAgIGxldCByZXN1bHQgPSBwYXJzZS5pc0RvbmUodXB0bykgfHwgcGFyc2Uud29yayh0aW1lb3V0LCB1cHRvKSA/IHBhcnNlLnRyZWUgOiBudWxsO1xuICAgIHBhcnNlLnVwZGF0ZVZpZXdwb3J0KG9sZFZpZXBvcnQpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcblF1ZXJpZXMgd2hldGhlciB0aGVyZSBpcyBhIGZ1bGwgc3ludGF4IHRyZWUgYXZhaWxhYmxlIHVwIHRvIHRoZVxuZ2l2ZW4gZG9jdW1lbnQgcG9zaXRpb24uIElmIHRoZXJlIGlzbid0LCB0aGUgYmFja2dyb3VuZCBwYXJzZVxucHJvY2VzcyBfbWlnaHRfIHN0aWxsIGJlIHdvcmtpbmcgYW5kIHVwZGF0ZSB0aGUgdHJlZSBmdXJ0aGVyLCBidXRcbnRoZXJlIGlzIG5vIGd1YXJhbnRlZSBvZiB0aGF04oCUdGhlIHBhcnNlciB3aWxsIFtzdG9wXG53b3JraW5nXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLnN5bnRheFBhcnNlclJ1bm5pbmcpIHdoZW4gaXQgaGFzIHNwZW50IGFcbmNlcnRhaW4gYW1vdW50IG9mIHRpbWUgb3IgaGFzIG1vdmVkIGJleW9uZCB0aGUgdmlzaWJsZSB2aWV3cG9ydC5cbkFsd2F5cyByZXR1cm5zIGZhbHNlIGlmIG5vIGxhbmd1YWdlIGhhcyBiZWVuIGVuYWJsZWQuXG4qL1xuZnVuY3Rpb24gc3ludGF4VHJlZUF2YWlsYWJsZShzdGF0ZSwgdXB0byA9IHN0YXRlLmRvYy5sZW5ndGgpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuICgoX2EgPSBzdGF0ZS5maWVsZChMYW5ndWFnZS5zdGF0ZSwgZmFsc2UpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29udGV4dC5pc0RvbmUodXB0bykpIHx8IGZhbHNlO1xufVxuLyoqXG5Nb3ZlIHBhcnNpbmcgZm9yd2FyZCwgYW5kIHVwZGF0ZSB0aGUgZWRpdG9yIHN0YXRlIGFmdGVyd2FyZHMgdG9cbnJlZmxlY3QgdGhlIG5ldyB0cmVlLiBXaWxsIHdvcmsgZm9yIGF0IG1vc3QgYHRpbWVvdXRgXG5taWxsaXNlY29uZHMuIFJldHVybnMgdHJ1ZSBpZiB0aGUgcGFyc2VyIG1hbmFnZWQgZ2V0IHRvIHRoZSBnaXZlblxucG9zaXRpb24gaW4gdGhhdCB0aW1lLlxuKi9cbmZ1bmN0aW9uIGZvcmNlUGFyc2luZyh2aWV3LCB1cHRvID0gdmlldy52aWV3cG9ydC50bywgdGltZW91dCA9IDEwMCkge1xuICAgIGxldCBzdWNjZXNzID0gZW5zdXJlU3ludGF4VHJlZSh2aWV3LnN0YXRlLCB1cHRvLCB0aW1lb3V0KTtcbiAgICBpZiAoc3VjY2VzcyAhPSBzeW50YXhUcmVlKHZpZXcuc3RhdGUpKVxuICAgICAgICB2aWV3LmRpc3BhdGNoKHt9KTtcbiAgICByZXR1cm4gISFzdWNjZXNzO1xufVxuLyoqXG5UZWxscyB5b3Ugd2hldGhlciB0aGUgbGFuZ3VhZ2UgcGFyc2VyIGlzIHBsYW5uaW5nIHRvIGRvIG1vcmVcbnBhcnNpbmcgd29yayAoaW4gYSBgcmVxdWVzdElkbGVDYWxsYmFja2AgcHNldWRvLXRocmVhZCkgb3IgaGFzXG5zdG9wcGVkIHJ1bm5pbmcsIGVpdGhlciBiZWNhdXNlIGl0IHBhcnNlZCB0aGUgZW50aXJlIGRvY3VtZW50LFxuYmVjYXVzZSBpdCBzcGVudCB0b28gbXVjaCB0aW1lIGFuZCB3YXMgY3V0IG9mZiwgb3IgYmVjYXVzZSB0aGVyZVxuaXMgbm8gbGFuZ3VhZ2UgcGFyc2VyIGVuYWJsZWQuXG4qL1xuZnVuY3Rpb24gc3ludGF4UGFyc2VyUnVubmluZyh2aWV3KSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoKF9hID0gdmlldy5wbHVnaW4ocGFyc2VXb3JrZXIpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaXNXb3JraW5nKCkpIHx8IGZhbHNlO1xufVxuLyoqXG5MZXplci1zdHlsZVxuW2BJbnB1dGBdKGh0dHBzOi8vbGV6ZXIuY29kZW1pcnJvci5uZXQvZG9jcy9yZWYjY29tbW9uLklucHV0KVxub2JqZWN0IGZvciBhIFtgVGV4dGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVGV4dCkgb2JqZWN0LlxuKi9cbmNsYXNzIERvY0lucHV0IHtcbiAgICAvKipcbiAgICBDcmVhdGUgYW4gaW5wdXQgb2JqZWN0IGZvciB0aGUgZ2l2ZW4gZG9jdW1lbnQuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihkb2MpIHtcbiAgICAgICAgdGhpcy5kb2MgPSBkb2M7XG4gICAgICAgIHRoaXMuY3Vyc29yUG9zID0gMDtcbiAgICAgICAgdGhpcy5zdHJpbmcgPSBcIlwiO1xuICAgICAgICB0aGlzLmN1cnNvciA9IGRvYy5pdGVyKCk7XG4gICAgfVxuICAgIGdldCBsZW5ndGgoKSB7IHJldHVybiB0aGlzLmRvYy5sZW5ndGg7IH1cbiAgICBzeW5jVG8ocG9zKSB7XG4gICAgICAgIHRoaXMuc3RyaW5nID0gdGhpcy5jdXJzb3IubmV4dChwb3MgLSB0aGlzLmN1cnNvclBvcykudmFsdWU7XG4gICAgICAgIHRoaXMuY3Vyc29yUG9zID0gcG9zICsgdGhpcy5zdHJpbmcubGVuZ3RoO1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJzb3JQb3MgLSB0aGlzLnN0cmluZy5sZW5ndGg7XG4gICAgfVxuICAgIGNodW5rKHBvcykge1xuICAgICAgICB0aGlzLnN5bmNUbyhwb3MpO1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJpbmc7XG4gICAgfVxuICAgIGdldCBsaW5lQ2h1bmtzKCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgIHJlYWQoZnJvbSwgdG8pIHtcbiAgICAgICAgbGV0IHN0cmluZ1N0YXJ0ID0gdGhpcy5jdXJzb3JQb3MgLSB0aGlzLnN0cmluZy5sZW5ndGg7XG4gICAgICAgIGlmIChmcm9tIDwgc3RyaW5nU3RhcnQgfHwgdG8gPj0gdGhpcy5jdXJzb3JQb3MpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kb2Muc2xpY2VTdHJpbmcoZnJvbSwgdG8pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJpbmcuc2xpY2UoZnJvbSAtIHN0cmluZ1N0YXJ0LCB0byAtIHN0cmluZ1N0YXJ0KTtcbiAgICB9XG59XG5sZXQgY3VycmVudENvbnRleHQgPSBudWxsO1xuLyoqXG5BIHBhcnNlIGNvbnRleHQgcHJvdmlkZWQgdG8gcGFyc2VycyB3b3JraW5nIG9uIHRoZSBlZGl0b3IgY29udGVudC5cbiovXG5jbGFzcyBQYXJzZUNvbnRleHQge1xuICAgIGNvbnN0cnVjdG9yKHBhcnNlciwgXG4gICAgLyoqXG4gICAgVGhlIGN1cnJlbnQgZWRpdG9yIHN0YXRlLlxuICAgICovXG4gICAgc3RhdGUsIFxuICAgIC8qKlxuICAgIFRyZWUgZnJhZ21lbnRzIHRoYXQgY2FuIGJlIHJldXNlZCBieSBpbmNyZW1lbnRhbCByZS1wYXJzZXMuXG4gICAgKi9cbiAgICBmcmFnbWVudHMgPSBbXSwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0cmVlLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHRyZWVMZW4sIFxuICAgIC8qKlxuICAgIFRoZSBjdXJyZW50IGVkaXRvciB2aWV3cG9ydCAob3Igc29tZSBvdmVyYXBwcm94aW1hdGlvblxuICAgIHRoZXJlb2YpLiBJbnRlbmRlZCB0byBiZSB1c2VkIGZvciBvcHBvcnR1bmlzdGljYWxseSBhdm9pZGluZ1xuICAgIHdvcmsgKGluIHdoaWNoIGNhc2VcbiAgICBbYHNraXBVbnRpbEluVmlld2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuUGFyc2VDb250ZXh0LnNraXBVbnRpbEluVmlldylcbiAgICBzaG91bGQgYmUgY2FsbGVkIHRvIG1ha2Ugc3VyZSB0aGUgcGFyc2VyIGlzIHJlc3RhcnRlZCB3aGVuIHRoZVxuICAgIHNraXBwZWQgcmVnaW9uIGJlY29tZXMgdmlzaWJsZSkuXG4gICAgKi9cbiAgICB2aWV3cG9ydCwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBza2lwcGVkLCBcbiAgICAvKipcbiAgICBUaGlzIGlzIHdoZXJlIHNraXBwaW5nIHBhcnNlcnMgY2FuIHJlZ2lzdGVyIGEgcHJvbWlzZSB0aGF0LFxuICAgIHdoZW4gcmVzb2x2ZWQsIHdpbGwgc2NoZWR1bGUgYSBuZXcgcGFyc2UuIEl0IGlzIGNsZWFyZWQgd2hlblxuICAgIHRoZSBwYXJzZSB3b3JrZXIgcGlja3MgdXAgdGhlIHByb21pc2UuIEBpbnRlcm5hbFxuICAgICovXG4gICAgc2NoZWR1bGVPbikge1xuICAgICAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICB0aGlzLmZyYWdtZW50cyA9IGZyYWdtZW50cztcbiAgICAgICAgdGhpcy50cmVlID0gdHJlZTtcbiAgICAgICAgdGhpcy50cmVlTGVuID0gdHJlZUxlbjtcbiAgICAgICAgdGhpcy52aWV3cG9ydCA9IHZpZXdwb3J0O1xuICAgICAgICB0aGlzLnNraXBwZWQgPSBza2lwcGVkO1xuICAgICAgICB0aGlzLnNjaGVkdWxlT24gPSBzY2hlZHVsZU9uO1xuICAgICAgICB0aGlzLnBhcnNlID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnRlbXBTa2lwcGVkID0gW107XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShwYXJzZXIsIHN0YXRlLCB2aWV3cG9ydCkge1xuICAgICAgICByZXR1cm4gbmV3IFBhcnNlQ29udGV4dChwYXJzZXIsIHN0YXRlLCBbXSwgVHJlZS5lbXB0eSwgMCwgdmlld3BvcnQsIFtdLCBudWxsKTtcbiAgICB9XG4gICAgc3RhcnRQYXJzZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VyLnN0YXJ0UGFyc2UobmV3IERvY0lucHV0KHRoaXMuc3RhdGUuZG9jKSwgdGhpcy5mcmFnbWVudHMpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHdvcmsodW50aWwsIHVwdG8pIHtcbiAgICAgICAgaWYgKHVwdG8gIT0gbnVsbCAmJiB1cHRvID49IHRoaXMuc3RhdGUuZG9jLmxlbmd0aClcbiAgICAgICAgICAgIHVwdG8gPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICh0aGlzLnRyZWUgIT0gVHJlZS5lbXB0eSAmJiB0aGlzLmlzRG9uZSh1cHRvICE9PSBudWxsICYmIHVwdG8gIT09IHZvaWQgMCA/IHVwdG8gOiB0aGlzLnN0YXRlLmRvYy5sZW5ndGgpKSB7XG4gICAgICAgICAgICB0aGlzLnRha2VUcmVlKCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy53aXRoQ29udGV4dCgoKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHVudGlsID09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBsZXQgZW5kVGltZSA9IERhdGUubm93KCkgKyB1bnRpbDtcbiAgICAgICAgICAgICAgICB1bnRpbCA9ICgpID0+IERhdGUubm93KCkgPiBlbmRUaW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLnBhcnNlKVxuICAgICAgICAgICAgICAgIHRoaXMucGFyc2UgPSB0aGlzLnN0YXJ0UGFyc2UoKTtcbiAgICAgICAgICAgIGlmICh1cHRvICE9IG51bGwgJiYgKHRoaXMucGFyc2Uuc3RvcHBlZEF0ID09IG51bGwgfHwgdGhpcy5wYXJzZS5zdG9wcGVkQXQgPiB1cHRvKSAmJlxuICAgICAgICAgICAgICAgIHVwdG8gPCB0aGlzLnN0YXRlLmRvYy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJzZS5zdG9wQXQodXB0byk7XG4gICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgbGV0IGRvbmUgPSB0aGlzLnBhcnNlLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZyYWdtZW50cyA9IHRoaXMud2l0aG91dFRlbXBTa2lwcGVkKFRyZWVGcmFnbWVudC5hZGRUcmVlKGRvbmUsIHRoaXMuZnJhZ21lbnRzLCB0aGlzLnBhcnNlLnN0b3BwZWRBdCAhPSBudWxsKSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJlZUxlbiA9IChfYSA9IHRoaXMucGFyc2Uuc3RvcHBlZEF0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLnN0YXRlLmRvYy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJlZSA9IGRvbmU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyc2UgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50cmVlTGVuIDwgKHVwdG8gIT09IG51bGwgJiYgdXB0byAhPT0gdm9pZCAwID8gdXB0byA6IHRoaXMuc3RhdGUuZG9jLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcnNlID0gdGhpcy5zdGFydFBhcnNlKCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodW50aWwoKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0YWtlVHJlZSgpIHtcbiAgICAgICAgbGV0IHBvcywgdHJlZTtcbiAgICAgICAgaWYgKHRoaXMucGFyc2UgJiYgKHBvcyA9IHRoaXMucGFyc2UucGFyc2VkUG9zKSA+PSB0aGlzLnRyZWVMZW4pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcnNlLnN0b3BwZWRBdCA9PSBudWxsIHx8IHRoaXMucGFyc2Uuc3RvcHBlZEF0ID4gcG9zKVxuICAgICAgICAgICAgICAgIHRoaXMucGFyc2Uuc3RvcEF0KHBvcyk7XG4gICAgICAgICAgICB0aGlzLndpdGhDb250ZXh0KCgpID0+IHsgd2hpbGUgKCEodHJlZSA9IHRoaXMucGFyc2UuYWR2YW5jZSgpKSkgeyB9IH0pO1xuICAgICAgICAgICAgdGhpcy50cmVlTGVuID0gcG9zO1xuICAgICAgICAgICAgdGhpcy50cmVlID0gdHJlZTtcbiAgICAgICAgICAgIHRoaXMuZnJhZ21lbnRzID0gdGhpcy53aXRob3V0VGVtcFNraXBwZWQoVHJlZUZyYWdtZW50LmFkZFRyZWUodGhpcy50cmVlLCB0aGlzLmZyYWdtZW50cywgdHJ1ZSkpO1xuICAgICAgICAgICAgdGhpcy5wYXJzZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgd2l0aENvbnRleHQoZikge1xuICAgICAgICBsZXQgcHJldiA9IGN1cnJlbnRDb250ZXh0O1xuICAgICAgICBjdXJyZW50Q29udGV4dCA9IHRoaXM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZigpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgY3VycmVudENvbnRleHQgPSBwcmV2O1xuICAgICAgICB9XG4gICAgfVxuICAgIHdpdGhvdXRUZW1wU2tpcHBlZChmcmFnbWVudHMpIHtcbiAgICAgICAgZm9yIChsZXQgcjsgciA9IHRoaXMudGVtcFNraXBwZWQucG9wKCk7KVxuICAgICAgICAgICAgZnJhZ21lbnRzID0gY3V0RnJhZ21lbnRzKGZyYWdtZW50cywgci5mcm9tLCByLnRvKTtcbiAgICAgICAgcmV0dXJuIGZyYWdtZW50cztcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjaGFuZ2VzKGNoYW5nZXMsIG5ld1N0YXRlKSB7XG4gICAgICAgIGxldCB7IGZyYWdtZW50cywgdHJlZSwgdHJlZUxlbiwgdmlld3BvcnQsIHNraXBwZWQgfSA9IHRoaXM7XG4gICAgICAgIHRoaXMudGFrZVRyZWUoKTtcbiAgICAgICAgaWYgKCFjaGFuZ2VzLmVtcHR5KSB7XG4gICAgICAgICAgICBsZXQgcmFuZ2VzID0gW107XG4gICAgICAgICAgICBjaGFuZ2VzLml0ZXJDaGFuZ2VkUmFuZ2VzKChmcm9tQSwgdG9BLCBmcm9tQiwgdG9CKSA9PiByYW5nZXMucHVzaCh7IGZyb21BLCB0b0EsIGZyb21CLCB0b0IgfSkpO1xuICAgICAgICAgICAgZnJhZ21lbnRzID0gVHJlZUZyYWdtZW50LmFwcGx5Q2hhbmdlcyhmcmFnbWVudHMsIHJhbmdlcyk7XG4gICAgICAgICAgICB0cmVlID0gVHJlZS5lbXB0eTtcbiAgICAgICAgICAgIHRyZWVMZW4gPSAwO1xuICAgICAgICAgICAgdmlld3BvcnQgPSB7IGZyb206IGNoYW5nZXMubWFwUG9zKHZpZXdwb3J0LmZyb20sIC0xKSwgdG86IGNoYW5nZXMubWFwUG9zKHZpZXdwb3J0LnRvLCAxKSB9O1xuICAgICAgICAgICAgaWYgKHRoaXMuc2tpcHBlZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBza2lwcGVkID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgciBvZiB0aGlzLnNraXBwZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZyb20gPSBjaGFuZ2VzLm1hcFBvcyhyLmZyb20sIDEpLCB0byA9IGNoYW5nZXMubWFwUG9zKHIudG8sIC0xKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZyb20gPCB0bylcbiAgICAgICAgICAgICAgICAgICAgICAgIHNraXBwZWQucHVzaCh7IGZyb20sIHRvIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFBhcnNlQ29udGV4dCh0aGlzLnBhcnNlciwgbmV3U3RhdGUsIGZyYWdtZW50cywgdHJlZSwgdHJlZUxlbiwgdmlld3BvcnQsIHNraXBwZWQsIHRoaXMuc2NoZWR1bGVPbik7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdXBkYXRlVmlld3BvcnQodmlld3BvcnQpIHtcbiAgICAgICAgaWYgKHRoaXMudmlld3BvcnQuZnJvbSA9PSB2aWV3cG9ydC5mcm9tICYmIHRoaXMudmlld3BvcnQudG8gPT0gdmlld3BvcnQudG8pXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMudmlld3BvcnQgPSB2aWV3cG9ydDtcbiAgICAgICAgbGV0IHN0YXJ0TGVuID0gdGhpcy5za2lwcGVkLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNraXBwZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB7IGZyb20sIHRvIH0gPSB0aGlzLnNraXBwZWRbaV07XG4gICAgICAgICAgICBpZiAoZnJvbSA8IHZpZXdwb3J0LnRvICYmIHRvID4gdmlld3BvcnQuZnJvbSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZnJhZ21lbnRzID0gY3V0RnJhZ21lbnRzKHRoaXMuZnJhZ21lbnRzLCBmcm9tLCB0byk7XG4gICAgICAgICAgICAgICAgdGhpcy5za2lwcGVkLnNwbGljZShpLS0sIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNraXBwZWQubGVuZ3RoID49IHN0YXJ0TGVuKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHJlc2V0KCkge1xuICAgICAgICBpZiAodGhpcy5wYXJzZSkge1xuICAgICAgICAgICAgdGhpcy50YWtlVHJlZSgpO1xuICAgICAgICAgICAgdGhpcy5wYXJzZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgTm90aWZ5IHRoZSBwYXJzZSBzY2hlZHVsZXIgdGhhdCB0aGUgZ2l2ZW4gcmVnaW9uIHdhcyBza2lwcGVkXG4gICAgYmVjYXVzZSBpdCB3YXNuJ3QgaW4gdmlldywgYW5kIHRoZSBwYXJzZSBzaG91bGQgYmUgcmVzdGFydGVkXG4gICAgd2hlbiBpdCBjb21lcyBpbnRvIHZpZXcuXG4gICAgKi9cbiAgICBza2lwVW50aWxJblZpZXcoZnJvbSwgdG8pIHtcbiAgICAgICAgdGhpcy5za2lwcGVkLnB1c2goeyBmcm9tLCB0byB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJucyBhIHBhcnNlciBpbnRlbmRlZCB0byBiZSB1c2VkIGFzIHBsYWNlaG9sZGVyIHdoZW5cbiAgICBhc3luY2hyb25vdXNseSBsb2FkaW5nIGEgbmVzdGVkIHBhcnNlci4gSXQnbGwgc2tpcCBpdHMgaW5wdXQgYW5kXG4gICAgbWFyayBpdCBhcyBub3QtcmVhbGx5LXBhcnNlZCwgc28gdGhhdCB0aGUgbmV4dCB1cGRhdGUgd2lsbCBwYXJzZVxuICAgIGl0IGFnYWluLlxuICAgIFxuICAgIFdoZW4gYHVudGlsYCBpcyBnaXZlbiwgYSByZXBhcnNlIHdpbGwgYmUgc2NoZWR1bGVkIHdoZW4gdGhhdFxuICAgIHByb21pc2UgcmVzb2x2ZXMuXG4gICAgKi9cbiAgICBzdGF0aWMgZ2V0U2tpcHBpbmdQYXJzZXIodW50aWwpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBjbGFzcyBleHRlbmRzIFBhcnNlciB7XG4gICAgICAgICAgICBjcmVhdGVQYXJzZShpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpIHtcbiAgICAgICAgICAgICAgICBsZXQgZnJvbSA9IHJhbmdlc1swXS5mcm9tLCB0byA9IHJhbmdlc1tyYW5nZXMubGVuZ3RoIC0gMV0udG87XG4gICAgICAgICAgICAgICAgbGV0IHBhcnNlciA9IHtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkUG9zOiBmcm9tLFxuICAgICAgICAgICAgICAgICAgICBhZHZhbmNlKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGN4ID0gY3VycmVudENvbnRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCByIG9mIHJhbmdlcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3gudGVtcFNraXBwZWQucHVzaChyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodW50aWwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN4LnNjaGVkdWxlT24gPSBjeC5zY2hlZHVsZU9uID8gUHJvbWlzZS5hbGwoW2N4LnNjaGVkdWxlT24sIHVudGlsXSkgOiB1bnRpbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFyc2VkUG9zID0gdG87XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFRyZWUoTm9kZVR5cGUubm9uZSwgW10sIFtdLCB0byAtIGZyb20pO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBzdG9wcGVkQXQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHN0b3BBdCgpIHsgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBpc0RvbmUodXB0bykge1xuICAgICAgICB1cHRvID0gTWF0aC5taW4odXB0bywgdGhpcy5zdGF0ZS5kb2MubGVuZ3RoKTtcbiAgICAgICAgbGV0IGZyYWdzID0gdGhpcy5mcmFnbWVudHM7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWVMZW4gPj0gdXB0byAmJiBmcmFncy5sZW5ndGggJiYgZnJhZ3NbMF0uZnJvbSA9PSAwICYmIGZyYWdzWzBdLnRvID49IHVwdG87XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgY29udGV4dCBmb3IgdGhlIGN1cnJlbnQgcGFyc2UsIG9yIGBudWxsYCBpZiBubyBlZGl0b3JcbiAgICBwYXJzZSBpcyBpbiBwcm9ncmVzcy5cbiAgICAqL1xuICAgIHN0YXRpYyBnZXQoKSB7IHJldHVybiBjdXJyZW50Q29udGV4dDsgfVxufVxuZnVuY3Rpb24gY3V0RnJhZ21lbnRzKGZyYWdtZW50cywgZnJvbSwgdG8pIHtcbiAgICByZXR1cm4gVHJlZUZyYWdtZW50LmFwcGx5Q2hhbmdlcyhmcmFnbWVudHMsIFt7IGZyb21BOiBmcm9tLCB0b0E6IHRvLCBmcm9tQjogZnJvbSwgdG9COiB0byB9XSk7XG59XG5jbGFzcyBMYW5ndWFnZVN0YXRlIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLyBBIG11dGFibGUgcGFyc2Ugc3RhdGUgdGhhdCBpcyB1c2VkIHRvIHByZXNlcnZlIHdvcmsgZG9uZSBkdXJpbmdcbiAgICAvLyB0aGUgbGlmZXRpbWUgb2YgYSBzdGF0ZSB3aGVuIG1vdmluZyB0byB0aGUgbmV4dCBzdGF0ZS5cbiAgICBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMudHJlZSA9IGNvbnRleHQudHJlZTtcbiAgICB9XG4gICAgYXBwbHkodHIpIHtcbiAgICAgICAgaWYgKCF0ci5kb2NDaGFuZ2VkICYmIHRoaXMudHJlZSA9PSB0aGlzLmNvbnRleHQudHJlZSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBsZXQgbmV3Q3ggPSB0aGlzLmNvbnRleHQuY2hhbmdlcyh0ci5jaGFuZ2VzLCB0ci5zdGF0ZSk7XG4gICAgICAgIC8vIElmIHRoZSBwcmV2aW91cyBwYXJzZSB3YXNuJ3QgZG9uZSwgZ28gZm9yd2FyZCBvbmx5IHVwIHRvIGl0c1xuICAgICAgICAvLyBlbmQgcG9zaXRpb24gb3IgdGhlIGVuZCBvZiB0aGUgdmlld3BvcnQsIHRvIGF2b2lkIHNsb3dpbmcgZG93blxuICAgICAgICAvLyBzdGF0ZSB1cGRhdGVzIHdpdGggcGFyc2Ugd29yayBiZXlvbmQgdGhlIHZpZXdwb3J0LlxuICAgICAgICBsZXQgdXB0byA9IHRoaXMuY29udGV4dC50cmVlTGVuID09IHRyLnN0YXJ0U3RhdGUuZG9jLmxlbmd0aCA/IHVuZGVmaW5lZFxuICAgICAgICAgICAgOiBNYXRoLm1heCh0ci5jaGFuZ2VzLm1hcFBvcyh0aGlzLmNvbnRleHQudHJlZUxlbiksIG5ld0N4LnZpZXdwb3J0LnRvKTtcbiAgICAgICAgaWYgKCFuZXdDeC53b3JrKDIwIC8qIFdvcmsuQXBwbHkgKi8sIHVwdG8pKVxuICAgICAgICAgICAgbmV3Q3gudGFrZVRyZWUoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBMYW5ndWFnZVN0YXRlKG5ld0N4KTtcbiAgICB9XG4gICAgc3RhdGljIGluaXQoc3RhdGUpIHtcbiAgICAgICAgbGV0IHZwVG8gPSBNYXRoLm1pbigzMDAwIC8qIFdvcmsuSW5pdFZpZXdwb3J0ICovLCBzdGF0ZS5kb2MubGVuZ3RoKTtcbiAgICAgICAgbGV0IHBhcnNlU3RhdGUgPSBQYXJzZUNvbnRleHQuY3JlYXRlKHN0YXRlLmZhY2V0KGxhbmd1YWdlKS5wYXJzZXIsIHN0YXRlLCB7IGZyb206IDAsIHRvOiB2cFRvIH0pO1xuICAgICAgICBpZiAoIXBhcnNlU3RhdGUud29yaygyMCAvKiBXb3JrLkFwcGx5ICovLCB2cFRvKSlcbiAgICAgICAgICAgIHBhcnNlU3RhdGUudGFrZVRyZWUoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBMYW5ndWFnZVN0YXRlKHBhcnNlU3RhdGUpO1xuICAgIH1cbn1cbkxhbmd1YWdlLnN0YXRlID0gLypAX19QVVJFX18qL1N0YXRlRmllbGQuZGVmaW5lKHtcbiAgICBjcmVhdGU6IExhbmd1YWdlU3RhdGUuaW5pdCxcbiAgICB1cGRhdGUodmFsdWUsIHRyKSB7XG4gICAgICAgIGZvciAobGV0IGUgb2YgdHIuZWZmZWN0cylcbiAgICAgICAgICAgIGlmIChlLmlzKExhbmd1YWdlLnNldFN0YXRlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZS52YWx1ZTtcbiAgICAgICAgaWYgKHRyLnN0YXJ0U3RhdGUuZmFjZXQobGFuZ3VhZ2UpICE9IHRyLnN0YXRlLmZhY2V0KGxhbmd1YWdlKSlcbiAgICAgICAgICAgIHJldHVybiBMYW5ndWFnZVN0YXRlLmluaXQodHIuc3RhdGUpO1xuICAgICAgICByZXR1cm4gdmFsdWUuYXBwbHkodHIpO1xuICAgIH1cbn0pO1xubGV0IHJlcXVlc3RJZGxlID0gKGNhbGxiYWNrKSA9PiB7XG4gICAgbGV0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IGNhbGxiYWNrKCksIDUwMCAvKiBXb3JrLk1heFBhdXNlICovKTtcbiAgICByZXR1cm4gKCkgPT4gY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufTtcbmlmICh0eXBlb2YgcmVxdWVzdElkbGVDYWxsYmFjayAhPSBcInVuZGVmaW5lZFwiKVxuICAgIHJlcXVlc3RJZGxlID0gKGNhbGxiYWNrKSA9PiB7XG4gICAgICAgIGxldCBpZGxlID0gLTEsIHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlkbGUgPSByZXF1ZXN0SWRsZUNhbGxiYWNrKGNhbGxiYWNrLCB7IHRpbWVvdXQ6IDUwMCAvKiBXb3JrLk1heFBhdXNlICovIC0gMTAwIC8qIFdvcmsuTWluUGF1c2UgKi8gfSk7XG4gICAgICAgIH0sIDEwMCAvKiBXb3JrLk1pblBhdXNlICovKTtcbiAgICAgICAgcmV0dXJuICgpID0+IGlkbGUgPCAwID8gY2xlYXJUaW1lb3V0KHRpbWVvdXQpIDogY2FuY2VsSWRsZUNhbGxiYWNrKGlkbGUpO1xuICAgIH07XG5jb25zdCBpc0lucHV0UGVuZGluZyA9IHR5cGVvZiBuYXZpZ2F0b3IgIT0gXCJ1bmRlZmluZWRcIiAmJiAoKF9hID0gbmF2aWdhdG9yLnNjaGVkdWxpbmcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pc0lucHV0UGVuZGluZylcbiAgICA/ICgpID0+IG5hdmlnYXRvci5zY2hlZHVsaW5nLmlzSW5wdXRQZW5kaW5nKCkgOiBudWxsO1xuY29uc3QgcGFyc2VXb3JrZXIgPSAvKkBfX1BVUkVfXyovVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3MgUGFyc2VXb3JrZXIge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy53b3JraW5nID0gbnVsbDtcbiAgICAgICAgdGhpcy53b3JrU2NoZWR1bGVkID0gMDtcbiAgICAgICAgLy8gRW5kIG9mIHRoZSBjdXJyZW50IHRpbWUgY2h1bmtcbiAgICAgICAgdGhpcy5jaHVua0VuZCA9IC0xO1xuICAgICAgICAvLyBNaWxsaXNlY29uZHMgb2YgYnVkZ2V0IGxlZnQgZm9yIHRoaXMgY2h1bmtcbiAgICAgICAgdGhpcy5jaHVua0J1ZGdldCA9IC0xO1xuICAgICAgICB0aGlzLndvcmsgPSB0aGlzLndvcmsuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZVdvcmsoKTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBsZXQgY3ggPSB0aGlzLnZpZXcuc3RhdGUuZmllbGQoTGFuZ3VhZ2Uuc3RhdGUpLmNvbnRleHQ7XG4gICAgICAgIGlmIChjeC51cGRhdGVWaWV3cG9ydCh1cGRhdGUudmlldy52aWV3cG9ydCkgfHwgdGhpcy52aWV3LnZpZXdwb3J0LnRvID4gY3gudHJlZUxlbilcbiAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVXb3JrKCk7XG4gICAgICAgIGlmICh1cGRhdGUuZG9jQ2hhbmdlZCB8fCB1cGRhdGUuc2VsZWN0aW9uU2V0KSB7XG4gICAgICAgICAgICBpZiAodGhpcy52aWV3Lmhhc0ZvY3VzKVxuICAgICAgICAgICAgICAgIHRoaXMuY2h1bmtCdWRnZXQgKz0gNTAgLyogV29yay5DaGFuZ2VCb251cyAqLztcbiAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVXb3JrKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGVja0FzeW5jU2NoZWR1bGUoY3gpO1xuICAgIH1cbiAgICBzY2hlZHVsZVdvcmsoKSB7XG4gICAgICAgIGlmICh0aGlzLndvcmtpbmcpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCB7IHN0YXRlIH0gPSB0aGlzLnZpZXcsIGZpZWxkID0gc3RhdGUuZmllbGQoTGFuZ3VhZ2Uuc3RhdGUpO1xuICAgICAgICBpZiAoZmllbGQudHJlZSAhPSBmaWVsZC5jb250ZXh0LnRyZWUgfHwgIWZpZWxkLmNvbnRleHQuaXNEb25lKHN0YXRlLmRvYy5sZW5ndGgpKVxuICAgICAgICAgICAgdGhpcy53b3JraW5nID0gcmVxdWVzdElkbGUodGhpcy53b3JrKTtcbiAgICB9XG4gICAgd29yayhkZWFkbGluZSkge1xuICAgICAgICB0aGlzLndvcmtpbmcgPSBudWxsO1xuICAgICAgICBsZXQgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgaWYgKHRoaXMuY2h1bmtFbmQgPCBub3cgJiYgKHRoaXMuY2h1bmtFbmQgPCAwIHx8IHRoaXMudmlldy5oYXNGb2N1cykpIHsgLy8gU3RhcnQgYSBuZXcgY2h1bmtcbiAgICAgICAgICAgIHRoaXMuY2h1bmtFbmQgPSBub3cgKyAzMDAwMCAvKiBXb3JrLkNodW5rVGltZSAqLztcbiAgICAgICAgICAgIHRoaXMuY2h1bmtCdWRnZXQgPSAzMDAwIC8qIFdvcmsuQ2h1bmtCdWRnZXQgKi87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2h1bmtCdWRnZXQgPD0gMClcbiAgICAgICAgICAgIHJldHVybjsgLy8gTm8gbW9yZSBidWRnZXRcbiAgICAgICAgbGV0IHsgc3RhdGUsIHZpZXdwb3J0OiB7IHRvOiB2cFRvIH0gfSA9IHRoaXMudmlldywgZmllbGQgPSBzdGF0ZS5maWVsZChMYW5ndWFnZS5zdGF0ZSk7XG4gICAgICAgIGlmIChmaWVsZC50cmVlID09IGZpZWxkLmNvbnRleHQudHJlZSAmJiBmaWVsZC5jb250ZXh0LmlzRG9uZSh2cFRvICsgMTAwMDAwIC8qIFdvcmsuTWF4UGFyc2VBaGVhZCAqLykpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBlbmRUaW1lID0gRGF0ZS5ub3coKSArIE1hdGgubWluKHRoaXMuY2h1bmtCdWRnZXQsIDEwMCAvKiBXb3JrLlNsaWNlICovLCBkZWFkbGluZSAmJiAhaXNJbnB1dFBlbmRpbmcgPyBNYXRoLm1heCgyNSAvKiBXb3JrLk1pblNsaWNlICovLCBkZWFkbGluZS50aW1lUmVtYWluaW5nKCkgLSA1KSA6IDFlOSk7XG4gICAgICAgIGxldCB2aWV3cG9ydEZpcnN0ID0gZmllbGQuY29udGV4dC50cmVlTGVuIDwgdnBUbyAmJiBzdGF0ZS5kb2MubGVuZ3RoID4gdnBUbyArIDEwMDA7XG4gICAgICAgIGxldCBkb25lID0gZmllbGQuY29udGV4dC53b3JrKCgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBpc0lucHV0UGVuZGluZyAmJiBpc0lucHV0UGVuZGluZygpIHx8IERhdGUubm93KCkgPiBlbmRUaW1lO1xuICAgICAgICB9LCB2cFRvICsgKHZpZXdwb3J0Rmlyc3QgPyAwIDogMTAwMDAwIC8qIFdvcmsuTWF4UGFyc2VBaGVhZCAqLykpO1xuICAgICAgICB0aGlzLmNodW5rQnVkZ2V0IC09IERhdGUubm93KCkgLSBub3c7XG4gICAgICAgIGlmIChkb25lIHx8IHRoaXMuY2h1bmtCdWRnZXQgPD0gMCkge1xuICAgICAgICAgICAgZmllbGQuY29udGV4dC50YWtlVHJlZSgpO1xuICAgICAgICAgICAgdGhpcy52aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogTGFuZ3VhZ2Uuc2V0U3RhdGUub2YobmV3IExhbmd1YWdlU3RhdGUoZmllbGQuY29udGV4dCkpIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNodW5rQnVkZ2V0ID4gMCAmJiAhKGRvbmUgJiYgIXZpZXdwb3J0Rmlyc3QpKVxuICAgICAgICAgICAgdGhpcy5zY2hlZHVsZVdvcmsoKTtcbiAgICAgICAgdGhpcy5jaGVja0FzeW5jU2NoZWR1bGUoZmllbGQuY29udGV4dCk7XG4gICAgfVxuICAgIGNoZWNrQXN5bmNTY2hlZHVsZShjeCkge1xuICAgICAgICBpZiAoY3guc2NoZWR1bGVPbikge1xuICAgICAgICAgICAgdGhpcy53b3JrU2NoZWR1bGVkKys7XG4gICAgICAgICAgICBjeC5zY2hlZHVsZU9uXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4gdGhpcy5zY2hlZHVsZVdvcmsoKSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goZXJyID0+IGxvZ0V4Y2VwdGlvbih0aGlzLnZpZXcuc3RhdGUsIGVycikpXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4gdGhpcy53b3JrU2NoZWR1bGVkLS0pO1xuICAgICAgICAgICAgY3guc2NoZWR1bGVPbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMud29ya2luZylcbiAgICAgICAgICAgIHRoaXMud29ya2luZygpO1xuICAgIH1cbiAgICBpc1dvcmtpbmcoKSB7XG4gICAgICAgIHJldHVybiAhISh0aGlzLndvcmtpbmcgfHwgdGhpcy53b3JrU2NoZWR1bGVkID4gMCk7XG4gICAgfVxufSwge1xuICAgIGV2ZW50SGFuZGxlcnM6IHsgZm9jdXMoKSB7IHRoaXMuc2NoZWR1bGVXb3JrKCk7IH0gfVxufSk7XG4vKipcblRoZSBmYWNldCB1c2VkIHRvIGFzc29jaWF0ZSBhIGxhbmd1YWdlIHdpdGggYW4gZWRpdG9yIHN0YXRlLiBVc2VkXG5ieSBgTGFuZ3VhZ2VgIG9iamVjdCdzIGBleHRlbnNpb25gIHByb3BlcnR5IChzbyB5b3UgZG9uJ3QgbmVlZCB0b1xubWFudWFsbHkgd3JhcCB5b3VyIGxhbmd1YWdlcyBpbiB0aGlzKS4gQ2FuIGJlIHVzZWQgdG8gYWNjZXNzIHRoZVxuY3VycmVudCBsYW5ndWFnZSBvbiBhIHN0YXRlLlxuKi9cbmNvbnN0IGxhbmd1YWdlID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZShsYW5ndWFnZXMpIHsgcmV0dXJuIGxhbmd1YWdlcy5sZW5ndGggPyBsYW5ndWFnZXNbMF0gOiBudWxsOyB9LFxuICAgIGVuYWJsZXM6IGxhbmd1YWdlID0+IFtcbiAgICAgICAgTGFuZ3VhZ2Uuc3RhdGUsXG4gICAgICAgIHBhcnNlV29ya2VyLFxuICAgICAgICBFZGl0b3JWaWV3LmNvbnRlbnRBdHRyaWJ1dGVzLmNvbXB1dGUoW2xhbmd1YWdlXSwgc3RhdGUgPT4ge1xuICAgICAgICAgICAgbGV0IGxhbmcgPSBzdGF0ZS5mYWNldChsYW5ndWFnZSk7XG4gICAgICAgICAgICByZXR1cm4gbGFuZyAmJiBsYW5nLm5hbWUgPyB7IFwiZGF0YS1sYW5ndWFnZVwiOiBsYW5nLm5hbWUgfSA6IHt9O1xuICAgICAgICB9KVxuICAgIF1cbn0pO1xuLyoqXG5UaGlzIGNsYXNzIGJ1bmRsZXMgYSBbbGFuZ3VhZ2VdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuTGFuZ3VhZ2UpIHdpdGggYW5cbm9wdGlvbmFsIHNldCBvZiBzdXBwb3J0aW5nIGV4dGVuc2lvbnMuIExhbmd1YWdlIHBhY2thZ2VzIGFyZVxuZW5jb3VyYWdlZCB0byBleHBvcnQgYSBmdW5jdGlvbiB0aGF0IG9wdGlvbmFsbHkgdGFrZXMgYVxuY29uZmlndXJhdGlvbiBvYmplY3QgYW5kIHJldHVybnMgYSBgTGFuZ3VhZ2VTdXBwb3J0YCBpbnN0YW5jZSwgYXNcbnRoZSBtYWluIHdheSBmb3IgY2xpZW50IGNvZGUgdG8gdXNlIHRoZSBwYWNrYWdlLlxuKi9cbmNsYXNzIExhbmd1YWdlU3VwcG9ydCB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbGFuZ3VhZ2Ugc3VwcG9ydCBvYmplY3QuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgbGFuZ3VhZ2Ugb2JqZWN0LlxuICAgICovXG4gICAgbGFuZ3VhZ2UsIFxuICAgIC8qKlxuICAgIEFuIG9wdGlvbmFsIHNldCBvZiBzdXBwb3J0aW5nIGV4dGVuc2lvbnMuIFdoZW4gbmVzdGluZyBhXG4gICAgbGFuZ3VhZ2UgaW4gYW5vdGhlciBsYW5ndWFnZSwgdGhlIG91dGVyIGxhbmd1YWdlIGlzIGVuY291cmFnZWRcbiAgICB0byBpbmNsdWRlIHRoZSBzdXBwb3J0aW5nIGV4dGVuc2lvbnMgZm9yIGl0cyBpbm5lciBsYW5ndWFnZXNcbiAgICBpbiBpdHMgb3duIHNldCBvZiBzdXBwb3J0IGV4dGVuc2lvbnMuXG4gICAgKi9cbiAgICBzdXBwb3J0ID0gW10pIHtcbiAgICAgICAgdGhpcy5sYW5ndWFnZSA9IGxhbmd1YWdlO1xuICAgICAgICB0aGlzLnN1cHBvcnQgPSBzdXBwb3J0O1xuICAgICAgICB0aGlzLmV4dGVuc2lvbiA9IFtsYW5ndWFnZSwgc3VwcG9ydF07XG4gICAgfVxufVxuLyoqXG5MYW5ndWFnZSBkZXNjcmlwdGlvbnMgYXJlIHVzZWQgdG8gc3RvcmUgbWV0YWRhdGEgYWJvdXQgbGFuZ3VhZ2VzXG5hbmQgdG8gZHluYW1pY2FsbHkgbG9hZCB0aGVtLiBUaGVpciBtYWluIHJvbGUgaXMgZmluZGluZyB0aGVcbmFwcHJvcHJpYXRlIGxhbmd1YWdlIGZvciBhIGZpbGVuYW1lIG9yIGR5bmFtaWNhbGx5IGxvYWRpbmcgbmVzdGVkXG5wYXJzZXJzLlxuKi9cbmNsYXNzIExhbmd1YWdlRGVzY3JpcHRpb24ge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBuYW1lIG9mIHRoaXMgbGFuZ3VhZ2UuXG4gICAgKi9cbiAgICBuYW1lLCBcbiAgICAvKipcbiAgICBBbHRlcm5hdGl2ZSBuYW1lcyBmb3IgdGhlIG1vZGUgKGxvd2VyY2FzZWQsIGluY2x1ZGVzIGB0aGlzLm5hbWVgKS5cbiAgICAqL1xuICAgIGFsaWFzLCBcbiAgICAvKipcbiAgICBGaWxlIGV4dGVuc2lvbnMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgbGFuZ3VhZ2UuXG4gICAgKi9cbiAgICBleHRlbnNpb25zLCBcbiAgICAvKipcbiAgICBPcHRpb25hbCBmaWxlbmFtZSBwYXR0ZXJuIHRoYXQgc2hvdWxkIGJlIGFzc29jaWF0ZWQgd2l0aCB0aGlzXG4gICAgbGFuZ3VhZ2UuXG4gICAgKi9cbiAgICBmaWxlbmFtZSwgbG9hZEZ1bmMsIFxuICAgIC8qKlxuICAgIElmIHRoZSBsYW5ndWFnZSBoYXMgYmVlbiBsb2FkZWQsIHRoaXMgd2lsbCBob2xkIGl0cyB2YWx1ZS5cbiAgICAqL1xuICAgIHN1cHBvcnQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5hbGlhcyA9IGFsaWFzO1xuICAgICAgICB0aGlzLmV4dGVuc2lvbnMgPSBleHRlbnNpb25zO1xuICAgICAgICB0aGlzLmZpbGVuYW1lID0gZmlsZW5hbWU7XG4gICAgICAgIHRoaXMubG9hZEZ1bmMgPSBsb2FkRnVuYztcbiAgICAgICAgdGhpcy5zdXBwb3J0ID0gc3VwcG9ydDtcbiAgICAgICAgdGhpcy5sb2FkaW5nID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgU3RhcnQgbG9hZGluZyB0aGUgdGhlIGxhbmd1YWdlLiBXaWxsIHJldHVybiBhIHByb21pc2UgdGhhdFxuICAgIHJlc29sdmVzIHRvIGEgW2BMYW5ndWFnZVN1cHBvcnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLkxhbmd1YWdlU3VwcG9ydClcbiAgICBvYmplY3Qgd2hlbiB0aGUgbGFuZ3VhZ2Ugc3VjY2Vzc2Z1bGx5IGxvYWRzLlxuICAgICovXG4gICAgbG9hZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9hZGluZyB8fCAodGhpcy5sb2FkaW5nID0gdGhpcy5sb2FkRnVuYygpLnRoZW4oc3VwcG9ydCA9PiB0aGlzLnN1cHBvcnQgPSBzdXBwb3J0LCBlcnIgPT4geyB0aGlzLmxvYWRpbmcgPSBudWxsOyB0aHJvdyBlcnI7IH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbGFuZ3VhZ2UgZGVzY3JpcHRpb24uXG4gICAgKi9cbiAgICBzdGF0aWMgb2Yoc3BlYykge1xuICAgICAgICBsZXQgeyBsb2FkLCBzdXBwb3J0IH0gPSBzcGVjO1xuICAgICAgICBpZiAoIWxvYWQpIHtcbiAgICAgICAgICAgIGlmICghc3VwcG9ydClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk11c3QgcGFzcyBlaXRoZXIgJ2xvYWQnIG9yICdzdXBwb3J0JyB0byBMYW5ndWFnZURlc2NyaXB0aW9uLm9mXCIpO1xuICAgICAgICAgICAgbG9hZCA9ICgpID0+IFByb21pc2UucmVzb2x2ZShzdXBwb3J0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IExhbmd1YWdlRGVzY3JpcHRpb24oc3BlYy5uYW1lLCAoc3BlYy5hbGlhcyB8fCBbXSkuY29uY2F0KHNwZWMubmFtZSkubWFwKHMgPT4gcy50b0xvd2VyQ2FzZSgpKSwgc3BlYy5leHRlbnNpb25zIHx8IFtdLCBzcGVjLmZpbGVuYW1lLCBsb2FkLCBzdXBwb3J0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgTG9vayBmb3IgYSBsYW5ndWFnZSBpbiB0aGUgZ2l2ZW4gYXJyYXkgb2YgZGVzY3JpcHRpb25zIHRoYXRcbiAgICBtYXRjaGVzIHRoZSBmaWxlbmFtZS4gV2lsbCBmaXJzdCBtYXRjaFxuICAgIFtgZmlsZW5hbWVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLkxhbmd1YWdlRGVzY3JpcHRpb24uZmlsZW5hbWUpIHBhdHRlcm5zLFxuICAgIGFuZCB0aGVuIFtleHRlbnNpb25zXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLkxhbmd1YWdlRGVzY3JpcHRpb24uZXh0ZW5zaW9ucyksXG4gICAgYW5kIHJldHVybiB0aGUgZmlyc3QgbGFuZ3VhZ2UgdGhhdCBtYXRjaGVzLlxuICAgICovXG4gICAgc3RhdGljIG1hdGNoRmlsZW5hbWUoZGVzY3MsIGZpbGVuYW1lKSB7XG4gICAgICAgIGZvciAobGV0IGQgb2YgZGVzY3MpXG4gICAgICAgICAgICBpZiAoZC5maWxlbmFtZSAmJiBkLmZpbGVuYW1lLnRlc3QoZmlsZW5hbWUpKVxuICAgICAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICBsZXQgZXh0ID0gL1xcLihbXi5dKykkLy5leGVjKGZpbGVuYW1lKTtcbiAgICAgICAgaWYgKGV4dClcbiAgICAgICAgICAgIGZvciAobGV0IGQgb2YgZGVzY3MpXG4gICAgICAgICAgICAgICAgaWYgKGQuZXh0ZW5zaW9ucy5pbmRleE9mKGV4dFsxXSkgPiAtMSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICBMb29rIGZvciBhIGxhbmd1YWdlIHdob3NlIG5hbWUgb3IgYWxpYXMgbWF0Y2hlcyB0aGUgdGhlIGdpdmVuXG4gICAgbmFtZSAoY2FzZS1pbnNlbnNpdGl2ZWx5KS4gSWYgYGZ1enp5YCBpcyB0cnVlLCBhbmQgbm8gZGlyZWN0XG4gICAgbWF0Y2hzIGlzIGZvdW5kLCB0aGlzJ2xsIGFsc28gc2VhcmNoIGZvciBhIGxhbmd1YWdlIHdob3NlIG5hbWVcbiAgICBvciBhbGlhcyBvY2N1cnMgaW4gdGhlIHN0cmluZyAoZm9yIG5hbWVzIHNob3J0ZXIgdGhhbiB0aHJlZVxuICAgIGNoYXJhY3RlcnMsIG9ubHkgd2hlbiBzdXJyb3VuZGVkIGJ5IG5vbi13b3JkIGNoYXJhY3RlcnMpLlxuICAgICovXG4gICAgc3RhdGljIG1hdGNoTGFuZ3VhZ2VOYW1lKGRlc2NzLCBuYW1lLCBmdXp6eSA9IHRydWUpIHtcbiAgICAgICAgbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgZm9yIChsZXQgZCBvZiBkZXNjcylcbiAgICAgICAgICAgIGlmIChkLmFsaWFzLnNvbWUoYSA9PiBhID09IG5hbWUpKVxuICAgICAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICBpZiAoZnV6enkpXG4gICAgICAgICAgICBmb3IgKGxldCBkIG9mIGRlc2NzKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGEgb2YgZC5hbGlhcykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZm91bmQgPSBuYW1lLmluZGV4T2YoYSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmb3VuZCA+IC0xICYmIChhLmxlbmd0aCA+IDIgfHwgIS9cXHcvLnRlc3QobmFtZVtmb3VuZCAtIDFdKSAmJiAhL1xcdy8udGVzdChuYW1lW2ZvdW5kICsgYS5sZW5ndGhdKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cblxuLyoqXG5GYWNldCB0aGF0IGRlZmluZXMgYSB3YXkgdG8gcHJvdmlkZSBhIGZ1bmN0aW9uIHRoYXQgY29tcHV0ZXMgdGhlXG5hcHByb3ByaWF0ZSBpbmRlbnRhdGlvbiBkZXB0aCwgYXMgYSBjb2x1bW4gbnVtYmVyIChzZWVcbltgaW5kZW50U3RyaW5nYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5pbmRlbnRTdHJpbmcpKSwgYXQgdGhlIHN0YXJ0IG9mIGEgZ2l2ZW5cbmxpbmUuIEEgcmV0dXJuIHZhbHVlIG9mIGBudWxsYCBpbmRpY2F0ZXMgbm8gaW5kZW50YXRpb24gY2FuIGJlXG5kZXRlcm1pbmVkLCBhbmQgdGhlIGxpbmUgc2hvdWxkIGluaGVyaXQgdGhlIGluZGVudGF0aW9uIG9mIHRoZSBvbmVcbmFib3ZlIGl0LiBBIHJldHVybiB2YWx1ZSBvZiBgdW5kZWZpbmVkYCBkZWZlcnMgdG8gdGhlIG5leHQgaW5kZW50XG5zZXJ2aWNlLlxuKi9cbmNvbnN0IGluZGVudFNlcnZpY2UgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG4vKipcbkZhY2V0IGZvciBvdmVycmlkaW5nIHRoZSB1bml0IGJ5IHdoaWNoIGluZGVudGF0aW9uIGhhcHBlbnMuIFNob3VsZFxuYmUgYSBzdHJpbmcgY29uc2lzdGluZyBlaXRoZXIgZW50aXJlbHkgb2YgdGhlIHNhbWUgd2hpdGVzcGFjZVxuY2hhcmFjdGVyLiBXaGVuIG5vdCBzZXQsIHRoaXMgZGVmYXVsdHMgdG8gMiBzcGFjZXMuXG4qL1xuY29uc3QgaW5kZW50VW5pdCA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmU6IHZhbHVlcyA9PiB7XG4gICAgICAgIGlmICghdmFsdWVzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBcIiAgXCI7XG4gICAgICAgIGxldCB1bml0ID0gdmFsdWVzWzBdO1xuICAgICAgICBpZiAoIXVuaXQgfHwgL1xcUy8udGVzdCh1bml0KSB8fCBBcnJheS5mcm9tKHVuaXQpLnNvbWUoZSA9PiBlICE9IHVuaXRbMF0pKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbmRlbnQgdW5pdDogXCIgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZXNbMF0pKTtcbiAgICAgICAgcmV0dXJuIHVuaXQ7XG4gICAgfVxufSk7XG4vKipcblJldHVybiB0aGUgX2NvbHVtbiB3aWR0aF8gb2YgYW4gaW5kZW50IHVuaXQgaW4gdGhlIHN0YXRlLlxuRGV0ZXJtaW5lZCBieSB0aGUgW2BpbmRlbnRVbml0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5pbmRlbnRVbml0KVxuZmFjZXQsIGFuZCBbYHRhYlNpemVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlXnRhYlNpemUpIHdoZW4gdGhhdFxuY29udGFpbnMgdGFicy5cbiovXG5mdW5jdGlvbiBnZXRJbmRlbnRVbml0KHN0YXRlKSB7XG4gICAgbGV0IHVuaXQgPSBzdGF0ZS5mYWNldChpbmRlbnRVbml0KTtcbiAgICByZXR1cm4gdW5pdC5jaGFyQ29kZUF0KDApID09IDkgPyBzdGF0ZS50YWJTaXplICogdW5pdC5sZW5ndGggOiB1bml0Lmxlbmd0aDtcbn1cbi8qKlxuQ3JlYXRlIGFuIGluZGVudGF0aW9uIHN0cmluZyB0aGF0IGNvdmVycyBjb2x1bW5zIDAgdG8gYGNvbHNgLlxuV2lsbCB1c2UgdGFicyBmb3IgYXMgbXVjaCBvZiB0aGUgY29sdW1ucyBhcyBwb3NzaWJsZSB3aGVuIHRoZVxuW2BpbmRlbnRVbml0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5pbmRlbnRVbml0KSBmYWNldCBjb250YWluc1xudGFicy5cbiovXG5mdW5jdGlvbiBpbmRlbnRTdHJpbmcoc3RhdGUsIGNvbHMpIHtcbiAgICBsZXQgcmVzdWx0ID0gXCJcIiwgdHMgPSBzdGF0ZS50YWJTaXplLCBjaCA9IHN0YXRlLmZhY2V0KGluZGVudFVuaXQpWzBdO1xuICAgIGlmIChjaCA9PSBcIlxcdFwiKSB7XG4gICAgICAgIHdoaWxlIChjb2xzID49IHRzKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gXCJcXHRcIjtcbiAgICAgICAgICAgIGNvbHMgLT0gdHM7XG4gICAgICAgIH1cbiAgICAgICAgY2ggPSBcIiBcIjtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2xzOyBpKyspXG4gICAgICAgIHJlc3VsdCArPSBjaDtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG5HZXQgdGhlIGluZGVudGF0aW9uLCBhcyBhIGNvbHVtbiBudW1iZXIsIGF0IHRoZSBnaXZlbiBwb3NpdGlvbi5cbldpbGwgZmlyc3QgY29uc3VsdCBhbnkgW2luZGVudCBzZXJ2aWNlc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5pbmRlbnRTZXJ2aWNlKVxudGhhdCBhcmUgcmVnaXN0ZXJlZCwgYW5kIGlmIG5vbmUgb2YgdGhvc2UgcmV0dXJuIGFuIGluZGVudGF0aW9uLFxudGhpcyB3aWxsIGNoZWNrIHRoZSBzeW50YXggdHJlZSBmb3IgdGhlIFtpbmRlbnQgbm9kZVxucHJvcF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5pbmRlbnROb2RlUHJvcCkgYW5kIHVzZSB0aGF0IGlmIGZvdW5kLiBSZXR1cm5zIGFcbm51bWJlciB3aGVuIGFuIGluZGVudGF0aW9uIGNvdWxkIGJlIGRldGVybWluZWQsIGFuZCBudWxsXG5vdGhlcndpc2UuXG4qL1xuZnVuY3Rpb24gZ2V0SW5kZW50YXRpb24oY29udGV4dCwgcG9zKSB7XG4gICAgaWYgKGNvbnRleHQgaW5zdGFuY2VvZiBFZGl0b3JTdGF0ZSlcbiAgICAgICAgY29udGV4dCA9IG5ldyBJbmRlbnRDb250ZXh0KGNvbnRleHQpO1xuICAgIGZvciAobGV0IHNlcnZpY2Ugb2YgY29udGV4dC5zdGF0ZS5mYWNldChpbmRlbnRTZXJ2aWNlKSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gc2VydmljZShjb250ZXh0LCBwb3MpO1xuICAgICAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBsZXQgdHJlZSA9IHN5bnRheFRyZWUoY29udGV4dC5zdGF0ZSk7XG4gICAgcmV0dXJuIHRyZWUubGVuZ3RoID49IHBvcyA/IHN5bnRheEluZGVudGF0aW9uKGNvbnRleHQsIHRyZWUsIHBvcykgOiBudWxsO1xufVxuLyoqXG5DcmVhdGUgYSBjaGFuZ2Ugc2V0IHRoYXQgYXV0by1pbmRlbnRzIGFsbCBsaW5lcyB0b3VjaGVkIGJ5IHRoZVxuZ2l2ZW4gZG9jdW1lbnQgcmFuZ2UuXG4qL1xuZnVuY3Rpb24gaW5kZW50UmFuZ2Uoc3RhdGUsIGZyb20sIHRvKSB7XG4gICAgbGV0IHVwZGF0ZWQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGxldCBjb250ZXh0ID0gbmV3IEluZGVudENvbnRleHQoc3RhdGUsIHsgb3ZlcnJpZGVJbmRlbnRhdGlvbjogc3RhcnQgPT4geyB2YXIgX2E7IHJldHVybiAoX2EgPSB1cGRhdGVkW3N0YXJ0XSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogLTE7IH0gfSk7XG4gICAgbGV0IGNoYW5nZXMgPSBbXTtcbiAgICBmb3IgKGxldCBwb3MgPSBmcm9tOyBwb3MgPD0gdG87KSB7XG4gICAgICAgIGxldCBsaW5lID0gc3RhdGUuZG9jLmxpbmVBdChwb3MpO1xuICAgICAgICBwb3MgPSBsaW5lLnRvICsgMTtcbiAgICAgICAgbGV0IGluZGVudCA9IGdldEluZGVudGF0aW9uKGNvbnRleHQsIGxpbmUuZnJvbSk7XG4gICAgICAgIGlmIChpbmRlbnQgPT0gbnVsbClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIS9cXFMvLnRlc3QobGluZS50ZXh0KSlcbiAgICAgICAgICAgIGluZGVudCA9IDA7XG4gICAgICAgIGxldCBjdXIgPSAvXlxccyovLmV4ZWMobGluZS50ZXh0KVswXTtcbiAgICAgICAgbGV0IG5vcm0gPSBpbmRlbnRTdHJpbmcoc3RhdGUsIGluZGVudCk7XG4gICAgICAgIGlmIChjdXIgIT0gbm9ybSkge1xuICAgICAgICAgICAgdXBkYXRlZFtsaW5lLmZyb21dID0gaW5kZW50O1xuICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHsgZnJvbTogbGluZS5mcm9tLCB0bzogbGluZS5mcm9tICsgY3VyLmxlbmd0aCwgaW5zZXJ0OiBub3JtIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZS5jaGFuZ2VzKGNoYW5nZXMpO1xufVxuLyoqXG5JbmRlbnRhdGlvbiBjb250ZXh0cyBhcmUgdXNlZCB3aGVuIGNhbGxpbmcgW2luZGVudGF0aW9uXG5zZXJ2aWNlc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5pbmRlbnRTZXJ2aWNlKS4gVGhleSBwcm92aWRlIGhlbHBlciB1dGlsaXRpZXNcbnVzZWZ1bCBpbiBpbmRlbnRhdGlvbiBsb2dpYywgYW5kIGNhbiBzZWxlY3RpdmVseSBvdmVycmlkZSB0aGVcbmluZGVudGF0aW9uIHJlcG9ydGVkIGZvciBzb21lIGxpbmVzLlxuKi9cbmNsYXNzIEluZGVudENvbnRleHQge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhbiBpbmRlbnQgY29udGV4dC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBlZGl0b3Igc3RhdGUuXG4gICAgKi9cbiAgICBzdGF0ZSwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBvcHRpb25zID0ge30pIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLnVuaXQgPSBnZXRJbmRlbnRVbml0KHN0YXRlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IGEgZGVzY3JpcHRpb24gb2YgdGhlIGxpbmUgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLCB0YWtpbmdcbiAgICBbc2ltdWxhdGVkIGxpbmVcbiAgICBicmVha3NdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuSW5kZW50Q29udGV4dC5jb25zdHJ1Y3Rvcl5vcHRpb25zLnNpbXVsYXRlQnJlYWspXG4gICAgaW50byBhY2NvdW50LiBJZiB0aGVyZSBpcyBzdWNoIGEgYnJlYWsgYXQgYHBvc2AsIHRoZSBgYmlhc2BcbiAgICBhcmd1bWVudCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHBhcnQgb2YgdGhlIGxpbmUgbGluZSBiZWZvcmUgb3JcbiAgICBhZnRlciB0aGUgYnJlYWsgaXMgdXNlZC5cbiAgICAqL1xuICAgIGxpbmVBdChwb3MsIGJpYXMgPSAxKSB7XG4gICAgICAgIGxldCBsaW5lID0gdGhpcy5zdGF0ZS5kb2MubGluZUF0KHBvcyk7XG4gICAgICAgIGxldCB7IHNpbXVsYXRlQnJlYWssIHNpbXVsYXRlRG91YmxlQnJlYWsgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgaWYgKHNpbXVsYXRlQnJlYWsgIT0gbnVsbCAmJiBzaW11bGF0ZUJyZWFrID49IGxpbmUuZnJvbSAmJiBzaW11bGF0ZUJyZWFrIDw9IGxpbmUudG8pIHtcbiAgICAgICAgICAgIGlmIChzaW11bGF0ZURvdWJsZUJyZWFrICYmIHNpbXVsYXRlQnJlYWsgPT0gcG9zKVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHRleHQ6IFwiXCIsIGZyb206IHBvcyB9O1xuICAgICAgICAgICAgZWxzZSBpZiAoYmlhcyA8IDAgPyBzaW11bGF0ZUJyZWFrIDwgcG9zIDogc2ltdWxhdGVCcmVhayA8PSBwb3MpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdGV4dDogbGluZS50ZXh0LnNsaWNlKHNpbXVsYXRlQnJlYWsgLSBsaW5lLmZyb20pLCBmcm9tOiBzaW11bGF0ZUJyZWFrIH07XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdGV4dDogbGluZS50ZXh0LnNsaWNlKDAsIHNpbXVsYXRlQnJlYWsgLSBsaW5lLmZyb20pLCBmcm9tOiBsaW5lLmZyb20gfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGluZTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSB0ZXh0IGRpcmVjdGx5IGFmdGVyIGBwb3NgLCBlaXRoZXIgdGhlIGVudGlyZSBsaW5lXG4gICAgb3IgdGhlIG5leHQgMTAwIGNoYXJhY3RlcnMsIHdoaWNoZXZlciBpcyBzaG9ydGVyLlxuICAgICovXG4gICAgdGV4dEFmdGVyUG9zKHBvcywgYmlhcyA9IDEpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaW11bGF0ZURvdWJsZUJyZWFrICYmIHBvcyA9PSB0aGlzLm9wdGlvbnMuc2ltdWxhdGVCcmVhaylcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICBsZXQgeyB0ZXh0LCBmcm9tIH0gPSB0aGlzLmxpbmVBdChwb3MsIGJpYXMpO1xuICAgICAgICByZXR1cm4gdGV4dC5zbGljZShwb3MgLSBmcm9tLCBNYXRoLm1pbih0ZXh0Lmxlbmd0aCwgcG9zICsgMTAwIC0gZnJvbSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBjb2x1bW4gZm9yIHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAgICAqL1xuICAgIGNvbHVtbihwb3MsIGJpYXMgPSAxKSB7XG4gICAgICAgIGxldCB7IHRleHQsIGZyb20gfSA9IHRoaXMubGluZUF0KHBvcywgYmlhcyk7XG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzLmNvdW50Q29sdW1uKHRleHQsIHBvcyAtIGZyb20pO1xuICAgICAgICBsZXQgb3ZlcnJpZGUgPSB0aGlzLm9wdGlvbnMub3ZlcnJpZGVJbmRlbnRhdGlvbiA/IHRoaXMub3B0aW9ucy5vdmVycmlkZUluZGVudGF0aW9uKGZyb20pIDogLTE7XG4gICAgICAgIGlmIChvdmVycmlkZSA+IC0xKVxuICAgICAgICAgICAgcmVzdWx0ICs9IG92ZXJyaWRlIC0gdGhpcy5jb3VudENvbHVtbih0ZXh0LCB0ZXh0LnNlYXJjaCgvXFxTfCQvKSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIGNvbHVtbiBwb3NpdGlvbiAodGFraW5nIHRhYnMgaW50byBhY2NvdW50KSBvZiB0aGUgZ2l2ZW5cbiAgICBwb3NpdGlvbiBpbiB0aGUgZ2l2ZW4gc3RyaW5nLlxuICAgICovXG4gICAgY291bnRDb2x1bW4obGluZSwgcG9zID0gbGluZS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGNvdW50Q29sdW1uKGxpbmUsIHRoaXMuc3RhdGUudGFiU2l6ZSwgcG9zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgaW5kZW50YXRpb24gY29sdW1uIG9mIHRoZSBsaW5lIGF0IHRoZSBnaXZlbiBwb2ludC5cbiAgICAqL1xuICAgIGxpbmVJbmRlbnQocG9zLCBiaWFzID0gMSkge1xuICAgICAgICBsZXQgeyB0ZXh0LCBmcm9tIH0gPSB0aGlzLmxpbmVBdChwb3MsIGJpYXMpO1xuICAgICAgICBsZXQgb3ZlcnJpZGUgPSB0aGlzLm9wdGlvbnMub3ZlcnJpZGVJbmRlbnRhdGlvbjtcbiAgICAgICAgaWYgKG92ZXJyaWRlKSB7XG4gICAgICAgICAgICBsZXQgb3ZlcnJpZGVuID0gb3ZlcnJpZGUoZnJvbSk7XG4gICAgICAgICAgICBpZiAob3ZlcnJpZGVuID4gLTEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG92ZXJyaWRlbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jb3VudENvbHVtbih0ZXh0LCB0ZXh0LnNlYXJjaCgvXFxTfCQvKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybnMgdGhlIFtzaW11bGF0ZWQgbGluZVxuICAgIGJyZWFrXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLkluZGVudENvbnRleHQuY29uc3RydWN0b3Jeb3B0aW9ucy5zaW11bGF0ZUJyZWFrKVxuICAgIGZvciB0aGlzIGNvbnRleHQsIGlmIGFueS5cbiAgICAqL1xuICAgIGdldCBzaW11bGF0ZWRCcmVhaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5zaW11bGF0ZUJyZWFrIHx8IG51bGw7XG4gICAgfVxufVxuLyoqXG5BIHN5bnRheCB0cmVlIG5vZGUgcHJvcCB1c2VkIHRvIGFzc29jaWF0ZSBpbmRlbnRhdGlvbiBzdHJhdGVnaWVzXG53aXRoIG5vZGUgdHlwZXMuIFN1Y2ggYSBzdHJhdGVneSBpcyBhIGZ1bmN0aW9uIGZyb20gYW4gaW5kZW50YXRpb25cbmNvbnRleHQgdG8gYSBjb2x1bW4gbnVtYmVyIChzZWUgYWxzb1xuW2BpbmRlbnRTdHJpbmdgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmluZGVudFN0cmluZykpIG9yIG51bGwsIHdoZXJlIG51bGxcbmluZGljYXRlcyB0aGF0IG5vIGRlZmluaXRpdmUgaW5kZW50YXRpb24gY2FuIGJlIGRldGVybWluZWQuXG4qL1xuY29uc3QgaW5kZW50Tm9kZVByb3AgPSAvKkBfX1BVUkVfXyovbmV3IE5vZGVQcm9wKCk7XG4vLyBDb21wdXRlIHRoZSBpbmRlbnRhdGlvbiBmb3IgYSBnaXZlbiBwb3NpdGlvbiBmcm9tIHRoZSBzeW50YXggdHJlZS5cbmZ1bmN0aW9uIHN5bnRheEluZGVudGF0aW9uKGN4LCBhc3QsIHBvcykge1xuICAgIGxldCBzdGFjayA9IGFzdC5yZXNvbHZlU3RhY2socG9zKTtcbiAgICBsZXQgaW5uZXIgPSBzdGFjay5ub2RlLmVudGVyVW5maW5pc2hlZE5vZGVzQmVmb3JlKHBvcyk7XG4gICAgaWYgKGlubmVyICE9IHN0YWNrLm5vZGUpIHtcbiAgICAgICAgbGV0IGFkZCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBjdXIgPSBpbm5lcjsgY3VyICE9IHN0YWNrLm5vZGU7IGN1ciA9IGN1ci5wYXJlbnQpXG4gICAgICAgICAgICBhZGQucHVzaChjdXIpO1xuICAgICAgICBmb3IgKGxldCBpID0gYWRkLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICAgICAgc3RhY2sgPSB7IG5vZGU6IGFkZFtpXSwgbmV4dDogc3RhY2sgfTtcbiAgICB9XG4gICAgcmV0dXJuIGluZGVudEZvcihzdGFjaywgY3gsIHBvcyk7XG59XG5mdW5jdGlvbiBpbmRlbnRGb3Ioc3RhY2ssIGN4LCBwb3MpIHtcbiAgICBmb3IgKGxldCBjdXIgPSBzdGFjazsgY3VyOyBjdXIgPSBjdXIubmV4dCkge1xuICAgICAgICBsZXQgc3RyYXRlZ3kgPSBpbmRlbnRTdHJhdGVneShjdXIubm9kZSk7XG4gICAgICAgIGlmIChzdHJhdGVneSlcbiAgICAgICAgICAgIHJldHVybiBzdHJhdGVneShUcmVlSW5kZW50Q29udGV4dC5jcmVhdGUoY3gsIHBvcywgY3VyKSk7XG4gICAgfVxuICAgIHJldHVybiAwO1xufVxuZnVuY3Rpb24gaWdub3JlQ2xvc2VkKGN4KSB7XG4gICAgcmV0dXJuIGN4LnBvcyA9PSBjeC5vcHRpb25zLnNpbXVsYXRlQnJlYWsgJiYgY3gub3B0aW9ucy5zaW11bGF0ZURvdWJsZUJyZWFrO1xufVxuZnVuY3Rpb24gaW5kZW50U3RyYXRlZ3kodHJlZSkge1xuICAgIGxldCBzdHJhdGVneSA9IHRyZWUudHlwZS5wcm9wKGluZGVudE5vZGVQcm9wKTtcbiAgICBpZiAoc3RyYXRlZ3kpXG4gICAgICAgIHJldHVybiBzdHJhdGVneTtcbiAgICBsZXQgZmlyc3QgPSB0cmVlLmZpcnN0Q2hpbGQsIGNsb3NlO1xuICAgIGlmIChmaXJzdCAmJiAoY2xvc2UgPSBmaXJzdC50eXBlLnByb3AoTm9kZVByb3AuY2xvc2VkQnkpKSkge1xuICAgICAgICBsZXQgbGFzdCA9IHRyZWUubGFzdENoaWxkLCBjbG9zZWQgPSBsYXN0ICYmIGNsb3NlLmluZGV4T2YobGFzdC5uYW1lKSA+IC0xO1xuICAgICAgICByZXR1cm4gY3ggPT4gZGVsaW1pdGVkU3RyYXRlZ3koY3gsIHRydWUsIDEsIHVuZGVmaW5lZCwgY2xvc2VkICYmICFpZ25vcmVDbG9zZWQoY3gpID8gbGFzdC5mcm9tIDogdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgcmV0dXJuIHRyZWUucGFyZW50ID09IG51bGwgPyB0b3BJbmRlbnQgOiBudWxsO1xufVxuZnVuY3Rpb24gdG9wSW5kZW50KCkgeyByZXR1cm4gMDsgfVxuLyoqXG5PYmplY3RzIG9mIHRoaXMgdHlwZSBwcm92aWRlIGNvbnRleHQgaW5mb3JtYXRpb24gYW5kIGhlbHBlclxubWV0aG9kcyB0byBpbmRlbnRhdGlvbiBmdW5jdGlvbnMgcmVnaXN0ZXJlZCBvbiBzeW50YXggbm9kZXMuXG4qL1xuY2xhc3MgVHJlZUluZGVudENvbnRleHQgZXh0ZW5kcyBJbmRlbnRDb250ZXh0IHtcbiAgICBjb25zdHJ1Y3RvcihiYXNlLCBcbiAgICAvKipcbiAgICBUaGUgcG9zaXRpb24gYXQgd2hpY2ggaW5kZW50YXRpb24gaXMgYmVpbmcgY29tcHV0ZWQuXG4gICAgKi9cbiAgICBwb3MsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29udGV4dCkge1xuICAgICAgICBzdXBlcihiYXNlLnN0YXRlLCBiYXNlLm9wdGlvbnMpO1xuICAgICAgICB0aGlzLmJhc2UgPSBiYXNlO1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIHN5bnRheCB0cmVlIG5vZGUgdG8gd2hpY2ggdGhlIGluZGVudGF0aW9uIHN0cmF0ZWd5XG4gICAgYXBwbGllcy5cbiAgICAqL1xuICAgIGdldCBub2RlKCkgeyByZXR1cm4gdGhpcy5jb250ZXh0Lm5vZGU7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUoYmFzZSwgcG9zLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgVHJlZUluZGVudENvbnRleHQoYmFzZSwgcG9zLCBjb250ZXh0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSB0ZXh0IGRpcmVjdGx5IGFmdGVyIGB0aGlzLnBvc2AsIGVpdGhlciB0aGUgZW50aXJlIGxpbmVcbiAgICBvciB0aGUgbmV4dCAxMDAgY2hhcmFjdGVycywgd2hpY2hldmVyIGlzIHNob3J0ZXIuXG4gICAgKi9cbiAgICBnZXQgdGV4dEFmdGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZXh0QWZ0ZXJQb3ModGhpcy5wb3MpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGluZGVudGF0aW9uIGF0IHRoZSByZWZlcmVuY2UgbGluZSBmb3IgYHRoaXMubm9kZWAsIHdoaWNoXG4gICAgaXMgdGhlIGxpbmUgb24gd2hpY2ggaXQgc3RhcnRzLCB1bmxlc3MgdGhlcmUgaXMgYSBub2RlIHRoYXQgaXNcbiAgICBfbm90XyBhIHBhcmVudCBvZiB0aGlzIG5vZGUgY292ZXJpbmcgdGhlIHN0YXJ0IG9mIHRoYXQgbGluZS4gSWZcbiAgICBzbywgdGhlIGxpbmUgYXQgdGhlIHN0YXJ0IG9mIHRoYXQgbm9kZSBpcyB0cmllZCwgYWdhaW4gc2tpcHBpbmdcbiAgICBvbiBpZiBpdCBpcyBjb3ZlcmVkIGJ5IGFub3RoZXIgc3VjaCBub2RlLlxuICAgICovXG4gICAgZ2V0IGJhc2VJbmRlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJhc2VJbmRlbnRGb3IodGhpcy5ub2RlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBpbmRlbnRhdGlvbiBmb3IgdGhlIHJlZmVyZW5jZSBsaW5lIG9mIHRoZSBnaXZlbiBub2RlXG4gICAgKHNlZSBbYGJhc2VJbmRlbnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLlRyZWVJbmRlbnRDb250ZXh0LmJhc2VJbmRlbnQpKS5cbiAgICAqL1xuICAgIGJhc2VJbmRlbnRGb3Iobm9kZSkge1xuICAgICAgICBsZXQgbGluZSA9IHRoaXMuc3RhdGUuZG9jLmxpbmVBdChub2RlLmZyb20pO1xuICAgICAgICAvLyBTa2lwIGxpbmUgc3RhcnRzIHRoYXQgYXJlIGNvdmVyZWQgYnkgYSBzaWJsaW5nIChvciBjb3VzaW4sIGV0YylcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IGF0QnJlYWsgPSBub2RlLnJlc29sdmUobGluZS5mcm9tKTtcbiAgICAgICAgICAgIHdoaWxlIChhdEJyZWFrLnBhcmVudCAmJiBhdEJyZWFrLnBhcmVudC5mcm9tID09IGF0QnJlYWsuZnJvbSlcbiAgICAgICAgICAgICAgICBhdEJyZWFrID0gYXRCcmVhay5wYXJlbnQ7XG4gICAgICAgICAgICBpZiAoaXNQYXJlbnQoYXRCcmVhaywgbm9kZSkpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBsaW5lID0gdGhpcy5zdGF0ZS5kb2MubGluZUF0KGF0QnJlYWsuZnJvbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubGluZUluZGVudChsaW5lLmZyb20pO1xuICAgIH1cbiAgICAvKipcbiAgICBDb250aW51ZSBsb29raW5nIGZvciBpbmRlbnRhdGlvbnMgaW4gdGhlIG5vZGUncyBwYXJlbnQgbm9kZXMsXG4gICAgYW5kIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoYXQuXG4gICAgKi9cbiAgICBjb250aW51ZSgpIHtcbiAgICAgICAgcmV0dXJuIGluZGVudEZvcih0aGlzLmNvbnRleHQubmV4dCwgdGhpcy5iYXNlLCB0aGlzLnBvcyk7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNQYXJlbnQocGFyZW50LCBvZikge1xuICAgIGZvciAobGV0IGN1ciA9IG9mOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnQpXG4gICAgICAgIGlmIChwYXJlbnQgPT0gY3VyKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLy8gQ2hlY2sgd2hldGhlciBhIGRlbGltaXRlZCBub2RlIGlzIGFsaWduZWQgKG1lYW5pbmcgdGhlcmUgYXJlXG4vLyBub24tc2tpcHBlZCBub2RlcyBvbiB0aGUgc2FtZSBsaW5lIGFzIHRoZSBvcGVuaW5nIGRlbGltaXRlcikuIEFuZFxuLy8gaWYgc28sIHJldHVybiB0aGUgb3BlbmluZyB0b2tlbi5cbmZ1bmN0aW9uIGJyYWNrZXRlZEFsaWduZWQoY29udGV4dCkge1xuICAgIGxldCB0cmVlID0gY29udGV4dC5ub2RlO1xuICAgIGxldCBvcGVuVG9rZW4gPSB0cmVlLmNoaWxkQWZ0ZXIodHJlZS5mcm9tKSwgbGFzdCA9IHRyZWUubGFzdENoaWxkO1xuICAgIGlmICghb3BlblRva2VuKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgc2ltID0gY29udGV4dC5vcHRpb25zLnNpbXVsYXRlQnJlYWs7XG4gICAgbGV0IG9wZW5MaW5lID0gY29udGV4dC5zdGF0ZS5kb2MubGluZUF0KG9wZW5Ub2tlbi5mcm9tKTtcbiAgICBsZXQgbGluZUVuZCA9IHNpbSA9PSBudWxsIHx8IHNpbSA8PSBvcGVuTGluZS5mcm9tID8gb3BlbkxpbmUudG8gOiBNYXRoLm1pbihvcGVuTGluZS50bywgc2ltKTtcbiAgICBmb3IgKGxldCBwb3MgPSBvcGVuVG9rZW4udG87Oykge1xuICAgICAgICBsZXQgbmV4dCA9IHRyZWUuY2hpbGRBZnRlcihwb3MpO1xuICAgICAgICBpZiAoIW5leHQgfHwgbmV4dCA9PSBsYXN0KVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmICghbmV4dC50eXBlLmlzU2tpcHBlZClcbiAgICAgICAgICAgIHJldHVybiBuZXh0LmZyb20gPCBsaW5lRW5kID8gb3BlblRva2VuIDogbnVsbDtcbiAgICAgICAgcG9zID0gbmV4dC50bztcbiAgICB9XG59XG4vKipcbkFuIGluZGVudGF0aW9uIHN0cmF0ZWd5IGZvciBkZWxpbWl0ZWQgKHVzdWFsbHkgYnJhY2tldGVkKSBub2Rlcy5cbldpbGwsIGJ5IGRlZmF1bHQsIGluZGVudCBvbmUgdW5pdCBtb3JlIHRoYW4gdGhlIHBhcmVudCdzIGJhc2VcbmluZGVudCB1bmxlc3MgdGhlIGxpbmUgc3RhcnRzIHdpdGggYSBjbG9zaW5nIHRva2VuLiBXaGVuIGBhbGlnbmBcbmlzIHRydWUgYW5kIHRoZXJlIGFyZSBub24tc2tpcHBlZCBub2RlcyBvbiB0aGUgbm9kZSdzIG9wZW5pbmdcbmxpbmUsIHRoZSBjb250ZW50IG9mIHRoZSBub2RlIHdpbGwgYmUgYWxpZ25lZCB3aXRoIHRoZSBlbmQgb2YgdGhlXG5vcGVuaW5nIG5vZGUsIGxpa2UgdGhpczpcblxuICAgIGZvbyhiYXIsXG4gICAgICAgIGJheilcbiovXG5mdW5jdGlvbiBkZWxpbWl0ZWRJbmRlbnQoeyBjbG9zaW5nLCBhbGlnbiA9IHRydWUsIHVuaXRzID0gMSB9KSB7XG4gICAgcmV0dXJuIChjb250ZXh0KSA9PiBkZWxpbWl0ZWRTdHJhdGVneShjb250ZXh0LCBhbGlnbiwgdW5pdHMsIGNsb3NpbmcpO1xufVxuZnVuY3Rpb24gZGVsaW1pdGVkU3RyYXRlZ3koY29udGV4dCwgYWxpZ24sIHVuaXRzLCBjbG9zaW5nLCBjbG9zZWRBdCkge1xuICAgIGxldCBhZnRlciA9IGNvbnRleHQudGV4dEFmdGVyLCBzcGFjZSA9IGFmdGVyLm1hdGNoKC9eXFxzKi8pWzBdLmxlbmd0aDtcbiAgICBsZXQgY2xvc2VkID0gY2xvc2luZyAmJiBhZnRlci5zbGljZShzcGFjZSwgc3BhY2UgKyBjbG9zaW5nLmxlbmd0aCkgPT0gY2xvc2luZyB8fCBjbG9zZWRBdCA9PSBjb250ZXh0LnBvcyArIHNwYWNlO1xuICAgIGxldCBhbGlnbmVkID0gYWxpZ24gPyBicmFja2V0ZWRBbGlnbmVkKGNvbnRleHQpIDogbnVsbDtcbiAgICBpZiAoYWxpZ25lZClcbiAgICAgICAgcmV0dXJuIGNsb3NlZCA/IGNvbnRleHQuY29sdW1uKGFsaWduZWQuZnJvbSkgOiBjb250ZXh0LmNvbHVtbihhbGlnbmVkLnRvKTtcbiAgICByZXR1cm4gY29udGV4dC5iYXNlSW5kZW50ICsgKGNsb3NlZCA/IDAgOiBjb250ZXh0LnVuaXQgKiB1bml0cyk7XG59XG4vKipcbkFuIGluZGVudGF0aW9uIHN0cmF0ZWd5IHRoYXQgYWxpZ25zIGEgbm9kZSdzIGNvbnRlbnQgdG8gaXRzIGJhc2VcbmluZGVudGF0aW9uLlxuKi9cbmNvbnN0IGZsYXRJbmRlbnQgPSAoY29udGV4dCkgPT4gY29udGV4dC5iYXNlSW5kZW50O1xuLyoqXG5DcmVhdGVzIGFuIGluZGVudGF0aW9uIHN0cmF0ZWd5IHRoYXQsIGJ5IGRlZmF1bHQsIGluZGVudHNcbmNvbnRpbnVlZCBsaW5lcyBvbmUgdW5pdCBtb3JlIHRoYW4gdGhlIG5vZGUncyBiYXNlIGluZGVudGF0aW9uLlxuWW91IGNhbiBwcm92aWRlIGBleGNlcHRgIHRvIHByZXZlbnQgaW5kZW50YXRpb24gb2YgbGluZXMgdGhhdFxubWF0Y2ggYSBwYXR0ZXJuIChmb3IgZXhhbXBsZSBgL15lbHNlXFxiL2AgaW4gYGlmYC9gZWxzZWBcbmNvbnN0cnVjdHMpLCBhbmQgeW91IGNhbiBjaGFuZ2UgdGhlIGFtb3VudCBvZiB1bml0cyB1c2VkIHdpdGggdGhlXG5gdW5pdHNgIG9wdGlvbi5cbiovXG5mdW5jdGlvbiBjb250aW51ZWRJbmRlbnQoeyBleGNlcHQsIHVuaXRzID0gMSB9ID0ge30pIHtcbiAgICByZXR1cm4gKGNvbnRleHQpID0+IHtcbiAgICAgICAgbGV0IG1hdGNoRXhjZXB0ID0gZXhjZXB0ICYmIGV4Y2VwdC50ZXN0KGNvbnRleHQudGV4dEFmdGVyKTtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuYmFzZUluZGVudCArIChtYXRjaEV4Y2VwdCA/IDAgOiB1bml0cyAqIGNvbnRleHQudW5pdCk7XG4gICAgfTtcbn1cbmNvbnN0IERvbnRJbmRlbnRCZXlvbmQgPSAyMDA7XG4vKipcbkVuYWJsZXMgcmVpbmRlbnRhdGlvbiBvbiBpbnB1dC4gV2hlbiBhIGxhbmd1YWdlIGRlZmluZXMgYW5cbmBpbmRlbnRPbklucHV0YCBmaWVsZCBpbiBpdHMgW2xhbmd1YWdlXG5kYXRhXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLmxhbmd1YWdlRGF0YUF0KSwgd2hpY2ggbXVzdCBob2xkIGEgcmVndWxhclxuZXhwcmVzc2lvbiwgdGhlIGxpbmUgYXQgdGhlIGN1cnNvciB3aWxsIGJlIHJlaW5kZW50ZWQgd2hlbmV2ZXIgbmV3XG50ZXh0IGlzIHR5cGVkIGFuZCB0aGUgaW5wdXQgZnJvbSB0aGUgc3RhcnQgb2YgdGhlIGxpbmUgdXAgdG8gdGhlXG5jdXJzb3IgbWF0Y2hlcyB0aGF0IHJlZ2V4cC5cblxuVG8gYXZvaWQgdW5uZWNjZXNhcnkgcmVpbmRlbnRzLCBpdCBpcyByZWNvbW1lbmRlZCB0byBzdGFydCB0aGVcbnJlZ2V4cCB3aXRoIGBeYCAodXN1YWxseSBmb2xsb3dlZCBieSBgXFxzKmApLCBhbmQgZW5kIGl0IHdpdGggYCRgLlxuRm9yIGV4YW1wbGUsIGAvXlxccypcXH0kL2Agd2lsbCByZWluZGVudCB3aGVuIGEgY2xvc2luZyBicmFjZSBpc1xuYWRkZWQgYXQgdGhlIHN0YXJ0IG9mIGEgbGluZS5cbiovXG5mdW5jdGlvbiBpbmRlbnRPbklucHV0KCkge1xuICAgIHJldHVybiBFZGl0b3JTdGF0ZS50cmFuc2FjdGlvbkZpbHRlci5vZih0ciA9PiB7XG4gICAgICAgIGlmICghdHIuZG9jQ2hhbmdlZCB8fCAhdHIuaXNVc2VyRXZlbnQoXCJpbnB1dC50eXBlXCIpICYmICF0ci5pc1VzZXJFdmVudChcImlucHV0LmNvbXBsZXRlXCIpKVxuICAgICAgICAgICAgcmV0dXJuIHRyO1xuICAgICAgICBsZXQgcnVsZXMgPSB0ci5zdGFydFN0YXRlLmxhbmd1YWdlRGF0YUF0KFwiaW5kZW50T25JbnB1dFwiLCB0ci5zdGFydFN0YXRlLnNlbGVjdGlvbi5tYWluLmhlYWQpO1xuICAgICAgICBpZiAoIXJ1bGVzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0cjtcbiAgICAgICAgbGV0IGRvYyA9IHRyLm5ld0RvYywgeyBoZWFkIH0gPSB0ci5uZXdTZWxlY3Rpb24ubWFpbiwgbGluZSA9IGRvYy5saW5lQXQoaGVhZCk7XG4gICAgICAgIGlmIChoZWFkID4gbGluZS5mcm9tICsgRG9udEluZGVudEJleW9uZClcbiAgICAgICAgICAgIHJldHVybiB0cjtcbiAgICAgICAgbGV0IGxpbmVTdGFydCA9IGRvYy5zbGljZVN0cmluZyhsaW5lLmZyb20sIGhlYWQpO1xuICAgICAgICBpZiAoIXJ1bGVzLnNvbWUociA9PiByLnRlc3QobGluZVN0YXJ0KSkpXG4gICAgICAgICAgICByZXR1cm4gdHI7XG4gICAgICAgIGxldCB7IHN0YXRlIH0gPSB0ciwgbGFzdCA9IC0xLCBjaGFuZ2VzID0gW107XG4gICAgICAgIGZvciAobGV0IHsgaGVhZCB9IG9mIHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMpIHtcbiAgICAgICAgICAgIGxldCBsaW5lID0gc3RhdGUuZG9jLmxpbmVBdChoZWFkKTtcbiAgICAgICAgICAgIGlmIChsaW5lLmZyb20gPT0gbGFzdClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGxhc3QgPSBsaW5lLmZyb207XG4gICAgICAgICAgICBsZXQgaW5kZW50ID0gZ2V0SW5kZW50YXRpb24oc3RhdGUsIGxpbmUuZnJvbSk7XG4gICAgICAgICAgICBpZiAoaW5kZW50ID09IG51bGwpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBsZXQgY3VyID0gL15cXHMqLy5leGVjKGxpbmUudGV4dClbMF07XG4gICAgICAgICAgICBsZXQgbm9ybSA9IGluZGVudFN0cmluZyhzdGF0ZSwgaW5kZW50KTtcbiAgICAgICAgICAgIGlmIChjdXIgIT0gbm9ybSlcbiAgICAgICAgICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tOiBsaW5lLmZyb20sIHRvOiBsaW5lLmZyb20gKyBjdXIubGVuZ3RoLCBpbnNlcnQ6IG5vcm0gfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoYW5nZXMubGVuZ3RoID8gW3RyLCB7IGNoYW5nZXMsIHNlcXVlbnRpYWw6IHRydWUgfV0gOiB0cjtcbiAgICB9KTtcbn1cblxuLyoqXG5BIGZhY2V0IHRoYXQgcmVnaXN0ZXJzIGEgY29kZSBmb2xkaW5nIHNlcnZpY2UuIFdoZW4gY2FsbGVkIHdpdGhcbnRoZSBleHRlbnQgb2YgYSBsaW5lLCBzdWNoIGEgZnVuY3Rpb24gc2hvdWxkIHJldHVybiBhIGZvbGRhYmxlXG5yYW5nZSB0aGF0IHN0YXJ0cyBvbiB0aGF0IGxpbmUgKGJ1dCBjb250aW51ZXMgYmV5b25kIGl0KSwgaWYgb25lXG5jYW4gYmUgZm91bmQuXG4qL1xuY29uc3QgZm9sZFNlcnZpY2UgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG4vKipcblRoaXMgbm9kZSBwcm9wIGlzIHVzZWQgdG8gYXNzb2NpYXRlIGZvbGRpbmcgaW5mb3JtYXRpb24gd2l0aFxuc3ludGF4IG5vZGUgdHlwZXMuIEdpdmVuIGEgc3ludGF4IG5vZGUsIGl0IHNob3VsZCBjaGVjayB3aGV0aGVyXG50aGF0IHRyZWUgaXMgZm9sZGFibGUgYW5kIHJldHVybiB0aGUgcmFuZ2UgdGhhdCBjYW4gYmUgY29sbGFwc2VkXG53aGVuIGl0IGlzLlxuKi9cbmNvbnN0IGZvbGROb2RlUHJvcCA9IC8qQF9fUFVSRV9fKi9uZXcgTm9kZVByb3AoKTtcbi8qKlxuW0ZvbGRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuZm9sZE5vZGVQcm9wKSBmdW5jdGlvbiB0aGF0IGZvbGRzIGV2ZXJ5dGhpbmcgYnV0XG50aGUgZmlyc3QgYW5kIHRoZSBsYXN0IGNoaWxkIG9mIGEgc3ludGF4IG5vZGUuIFVzZWZ1bCBmb3Igbm9kZXNcbnRoYXQgc3RhcnQgYW5kIGVuZCB3aXRoIGRlbGltaXRlcnMuXG4qL1xuZnVuY3Rpb24gZm9sZEluc2lkZShub2RlKSB7XG4gICAgbGV0IGZpcnN0ID0gbm9kZS5maXJzdENoaWxkLCBsYXN0ID0gbm9kZS5sYXN0Q2hpbGQ7XG4gICAgcmV0dXJuIGZpcnN0ICYmIGZpcnN0LnRvIDwgbGFzdC5mcm9tID8geyBmcm9tOiBmaXJzdC50bywgdG86IGxhc3QudHlwZS5pc0Vycm9yID8gbm9kZS50byA6IGxhc3QuZnJvbSB9IDogbnVsbDtcbn1cbmZ1bmN0aW9uIHN5bnRheEZvbGRpbmcoc3RhdGUsIHN0YXJ0LCBlbmQpIHtcbiAgICBsZXQgdHJlZSA9IHN5bnRheFRyZWUoc3RhdGUpO1xuICAgIGlmICh0cmVlLmxlbmd0aCA8IGVuZClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IHN0YWNrID0gdHJlZS5yZXNvbHZlU3RhY2soZW5kLCAxKTtcbiAgICBsZXQgZm91bmQgPSBudWxsO1xuICAgIGZvciAobGV0IGl0ZXIgPSBzdGFjazsgaXRlcjsgaXRlciA9IGl0ZXIubmV4dCkge1xuICAgICAgICBsZXQgY3VyID0gaXRlci5ub2RlO1xuICAgICAgICBpZiAoY3VyLnRvIDw9IGVuZCB8fCBjdXIuZnJvbSA+IGVuZClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAoZm91bmQgJiYgY3VyLmZyb20gPCBzdGFydClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBsZXQgcHJvcCA9IGN1ci50eXBlLnByb3AoZm9sZE5vZGVQcm9wKTtcbiAgICAgICAgaWYgKHByb3AgJiYgKGN1ci50byA8IHRyZWUubGVuZ3RoIC0gNTAgfHwgdHJlZS5sZW5ndGggPT0gc3RhdGUuZG9jLmxlbmd0aCB8fCAhaXNVbmZpbmlzaGVkKGN1cikpKSB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBwcm9wKGN1ciwgc3RhdGUpO1xuICAgICAgICAgICAgaWYgKHZhbHVlICYmIHZhbHVlLmZyb20gPD0gZW5kICYmIHZhbHVlLmZyb20gPj0gc3RhcnQgJiYgdmFsdWUudG8gPiBlbmQpXG4gICAgICAgICAgICAgICAgZm91bmQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZm91bmQ7XG59XG5mdW5jdGlvbiBpc1VuZmluaXNoZWQobm9kZSkge1xuICAgIGxldCBjaCA9IG5vZGUubGFzdENoaWxkO1xuICAgIHJldHVybiBjaCAmJiBjaC50byA9PSBub2RlLnRvICYmIGNoLnR5cGUuaXNFcnJvcjtcbn1cbi8qKlxuQ2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gbGluZSBpcyBmb2xkYWJsZS4gRmlyc3QgYXNrcyBhbnkgZm9sZFxuc2VydmljZXMgcmVnaXN0ZXJlZCB0aHJvdWdoXG5bYGZvbGRTZXJ2aWNlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5mb2xkU2VydmljZSksIGFuZCBpZiBub25lIG9mIHRoZW0gcmV0dXJuXG5hIHJlc3VsdCwgdHJpZXMgdG8gcXVlcnkgdGhlIFtmb2xkIG5vZGVcbnByb3BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuZm9sZE5vZGVQcm9wKSBvZiBzeW50YXggbm9kZXMgdGhhdCBjb3ZlciB0aGUgZW5kXG5vZiB0aGUgbGluZS5cbiovXG5mdW5jdGlvbiBmb2xkYWJsZShzdGF0ZSwgbGluZVN0YXJ0LCBsaW5lRW5kKSB7XG4gICAgZm9yIChsZXQgc2VydmljZSBvZiBzdGF0ZS5mYWNldChmb2xkU2VydmljZSkpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHNlcnZpY2Uoc3RhdGUsIGxpbmVTdGFydCwgbGluZUVuZCk7XG4gICAgICAgIGlmIChyZXN1bHQpXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gc3ludGF4Rm9sZGluZyhzdGF0ZSwgbGluZVN0YXJ0LCBsaW5lRW5kKTtcbn1cbmZ1bmN0aW9uIG1hcFJhbmdlKHJhbmdlLCBtYXBwaW5nKSB7XG4gICAgbGV0IGZyb20gPSBtYXBwaW5nLm1hcFBvcyhyYW5nZS5mcm9tLCAxKSwgdG8gPSBtYXBwaW5nLm1hcFBvcyhyYW5nZS50bywgLTEpO1xuICAgIHJldHVybiBmcm9tID49IHRvID8gdW5kZWZpbmVkIDogeyBmcm9tLCB0byB9O1xufVxuLyoqXG5TdGF0ZSBlZmZlY3QgdGhhdCBjYW4gYmUgYXR0YWNoZWQgdG8gYSB0cmFuc2FjdGlvbiB0byBmb2xkIHRoZVxuZ2l2ZW4gcmFuZ2UuIChZb3UgcHJvYmFibHkgb25seSBuZWVkIHRoaXMgaW4gZXhjZXB0aW9uYWxcbmNpcmN1bXN0YW5jZXPigJR1c3VhbGx5IHlvdSdsbCBqdXN0IHdhbnQgdG8gbGV0XG5bYGZvbGRDb2RlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5mb2xkQ29kZSkgYW5kIHRoZSBbZm9sZFxuZ3V0dGVyXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmZvbGRHdXR0ZXIpIGNyZWF0ZSB0aGUgdHJhbnNhY3Rpb25zLilcbiovXG5jb25zdCBmb2xkRWZmZWN0ID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSh7IG1hcDogbWFwUmFuZ2UgfSk7XG4vKipcblN0YXRlIGVmZmVjdCB0aGF0IHVuZm9sZHMgdGhlIGdpdmVuIHJhbmdlIChpZiBpdCB3YXMgZm9sZGVkKS5cbiovXG5jb25zdCB1bmZvbGRFZmZlY3QgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKHsgbWFwOiBtYXBSYW5nZSB9KTtcbmZ1bmN0aW9uIHNlbGVjdGVkTGluZXModmlldykge1xuICAgIGxldCBsaW5lcyA9IFtdO1xuICAgIGZvciAobGV0IHsgaGVhZCB9IG9mIHZpZXcuc3RhdGUuc2VsZWN0aW9uLnJhbmdlcykge1xuICAgICAgICBpZiAobGluZXMuc29tZShsID0+IGwuZnJvbSA8PSBoZWFkICYmIGwudG8gPj0gaGVhZCkpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgbGluZXMucHVzaCh2aWV3LmxpbmVCbG9ja0F0KGhlYWQpKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpbmVzO1xufVxuLyoqXG5UaGUgc3RhdGUgZmllbGQgdGhhdCBzdG9yZXMgdGhlIGZvbGRlZCByYW5nZXMgKGFzIGEgW2RlY29yYXRpb25cbnNldF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkRlY29yYXRpb25TZXQpKS4gQ2FuIGJlIHBhc3NlZCB0b1xuW2BFZGl0b3JTdGF0ZS50b0pTT05gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLnRvSlNPTikgYW5kXG5bYGZyb21KU09OYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV5mcm9tSlNPTikgdG8gc2VyaWFsaXplIHRoZSBmb2xkXG5zdGF0ZS5cbiovXG5jb25zdCBmb2xkU3RhdGUgPSAvKkBfX1BVUkVfXyovU3RhdGVGaWVsZC5kZWZpbmUoe1xuICAgIGNyZWF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIERlY29yYXRpb24ubm9uZTtcbiAgICB9LFxuICAgIHVwZGF0ZShmb2xkZWQsIHRyKSB7XG4gICAgICAgIGZvbGRlZCA9IGZvbGRlZC5tYXAodHIuY2hhbmdlcyk7XG4gICAgICAgIGZvciAobGV0IGUgb2YgdHIuZWZmZWN0cykge1xuICAgICAgICAgICAgaWYgKGUuaXMoZm9sZEVmZmVjdCkgJiYgIWZvbGRFeGlzdHMoZm9sZGVkLCBlLnZhbHVlLmZyb20sIGUudmFsdWUudG8pKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgcHJlcGFyZVBsYWNlaG9sZGVyIH0gPSB0ci5zdGF0ZS5mYWNldChmb2xkQ29uZmlnKTtcbiAgICAgICAgICAgICAgICBsZXQgd2lkZ2V0ID0gIXByZXBhcmVQbGFjZWhvbGRlciA/IGZvbGRXaWRnZXQgOlxuICAgICAgICAgICAgICAgICAgICBEZWNvcmF0aW9uLnJlcGxhY2UoeyB3aWRnZXQ6IG5ldyBQcmVwYXJlZEZvbGRXaWRnZXQocHJlcGFyZVBsYWNlaG9sZGVyKHRyLnN0YXRlLCBlLnZhbHVlKSkgfSk7XG4gICAgICAgICAgICAgICAgZm9sZGVkID0gZm9sZGVkLnVwZGF0ZSh7IGFkZDogW3dpZGdldC5yYW5nZShlLnZhbHVlLmZyb20sIGUudmFsdWUudG8pXSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGUuaXModW5mb2xkRWZmZWN0KSkge1xuICAgICAgICAgICAgICAgIGZvbGRlZCA9IGZvbGRlZC51cGRhdGUoeyBmaWx0ZXI6IChmcm9tLCB0bykgPT4gZS52YWx1ZS5mcm9tICE9IGZyb20gfHwgZS52YWx1ZS50byAhPSB0byxcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyRnJvbTogZS52YWx1ZS5mcm9tLCBmaWx0ZXJUbzogZS52YWx1ZS50byB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBDbGVhciBmb2xkZWQgcmFuZ2VzIHRoYXQgY292ZXIgdGhlIHNlbGVjdGlvbiBoZWFkXG4gICAgICAgIGlmICh0ci5zZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIGxldCBvblNlbGVjdGlvbiA9IGZhbHNlLCB7IGhlYWQgfSA9IHRyLnNlbGVjdGlvbi5tYWluO1xuICAgICAgICAgICAgZm9sZGVkLmJldHdlZW4oaGVhZCwgaGVhZCwgKGEsIGIpID0+IHsgaWYgKGEgPCBoZWFkICYmIGIgPiBoZWFkKVxuICAgICAgICAgICAgICAgIG9uU2VsZWN0aW9uID0gdHJ1ZTsgfSk7XG4gICAgICAgICAgICBpZiAob25TZWxlY3Rpb24pXG4gICAgICAgICAgICAgICAgZm9sZGVkID0gZm9sZGVkLnVwZGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlckZyb206IGhlYWQsXG4gICAgICAgICAgICAgICAgICAgIGZpbHRlclRvOiBoZWFkLFxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXI6IChhLCBiKSA9PiBiIDw9IGhlYWQgfHwgYSA+PSBoZWFkXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvbGRlZDtcbiAgICB9LFxuICAgIHByb3ZpZGU6IGYgPT4gRWRpdG9yVmlldy5kZWNvcmF0aW9ucy5mcm9tKGYpLFxuICAgIHRvSlNPTihmb2xkZWQsIHN0YXRlKSB7XG4gICAgICAgIGxldCByYW5nZXMgPSBbXTtcbiAgICAgICAgZm9sZGVkLmJldHdlZW4oMCwgc3RhdGUuZG9jLmxlbmd0aCwgKGZyb20sIHRvKSA9PiB7IHJhbmdlcy5wdXNoKGZyb20sIHRvKTsgfSk7XG4gICAgICAgIHJldHVybiByYW5nZXM7XG4gICAgfSxcbiAgICBmcm9tSlNPTih2YWx1ZSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpIHx8IHZhbHVlLmxlbmd0aCAlIDIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgSlNPTiBmb3IgZm9sZCBzdGF0ZVwiKTtcbiAgICAgICAgbGV0IHJhbmdlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDspIHtcbiAgICAgICAgICAgIGxldCBmcm9tID0gdmFsdWVbaSsrXSwgdG8gPSB2YWx1ZVtpKytdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBmcm9tICE9IFwibnVtYmVyXCIgfHwgdHlwZW9mIHRvICE9IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIEpTT04gZm9yIGZvbGQgc3RhdGVcIik7XG4gICAgICAgICAgICByYW5nZXMucHVzaChmb2xkV2lkZ2V0LnJhbmdlKGZyb20sIHRvKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIERlY29yYXRpb24uc2V0KHJhbmdlcywgdHJ1ZSk7XG4gICAgfVxufSk7XG4vKipcbkdldCBhIFtyYW5nZSBzZXRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuUmFuZ2VTZXQpIGNvbnRhaW5pbmcgdGhlIGZvbGRlZCByYW5nZXNcbmluIHRoZSBnaXZlbiBzdGF0ZS5cbiovXG5mdW5jdGlvbiBmb2xkZWRSYW5nZXMoc3RhdGUpIHtcbiAgICByZXR1cm4gc3RhdGUuZmllbGQoZm9sZFN0YXRlLCBmYWxzZSkgfHwgUmFuZ2VTZXQuZW1wdHk7XG59XG5mdW5jdGlvbiBmaW5kRm9sZChzdGF0ZSwgZnJvbSwgdG8pIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IGZvdW5kID0gbnVsbDtcbiAgICAoX2EgPSBzdGF0ZS5maWVsZChmb2xkU3RhdGUsIGZhbHNlKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmJldHdlZW4oZnJvbSwgdG8sIChmcm9tLCB0bykgPT4ge1xuICAgICAgICBpZiAoIWZvdW5kIHx8IGZvdW5kLmZyb20gPiBmcm9tKVxuICAgICAgICAgICAgZm91bmQgPSB7IGZyb20sIHRvIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIGZvdW5kO1xufVxuZnVuY3Rpb24gZm9sZEV4aXN0cyhmb2xkZWQsIGZyb20sIHRvKSB7XG4gICAgbGV0IGZvdW5kID0gZmFsc2U7XG4gICAgZm9sZGVkLmJldHdlZW4oZnJvbSwgZnJvbSwgKGEsIGIpID0+IHsgaWYgKGEgPT0gZnJvbSAmJiBiID09IHRvKVxuICAgICAgICBmb3VuZCA9IHRydWU7IH0pO1xuICAgIHJldHVybiBmb3VuZDtcbn1cbmZ1bmN0aW9uIG1heWJlRW5hYmxlKHN0YXRlLCBvdGhlcikge1xuICAgIHJldHVybiBzdGF0ZS5maWVsZChmb2xkU3RhdGUsIGZhbHNlKSA/IG90aGVyIDogb3RoZXIuY29uY2F0KFN0YXRlRWZmZWN0LmFwcGVuZENvbmZpZy5vZihjb2RlRm9sZGluZygpKSk7XG59XG4vKipcbkZvbGQgdGhlIGxpbmVzIHRoYXQgYXJlIHNlbGVjdGVkLCBpZiBwb3NzaWJsZS5cbiovXG5jb25zdCBmb2xkQ29kZSA9IHZpZXcgPT4ge1xuICAgIGZvciAobGV0IGxpbmUgb2Ygc2VsZWN0ZWRMaW5lcyh2aWV3KSkge1xuICAgICAgICBsZXQgcmFuZ2UgPSBmb2xkYWJsZSh2aWV3LnN0YXRlLCBsaW5lLmZyb20sIGxpbmUudG8pO1xuICAgICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBtYXliZUVuYWJsZSh2aWV3LnN0YXRlLCBbZm9sZEVmZmVjdC5vZihyYW5nZSksIGFubm91bmNlRm9sZCh2aWV3LCByYW5nZSldKSB9KTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG4vKipcblVuZm9sZCBmb2xkZWQgcmFuZ2VzIG9uIHNlbGVjdGVkIGxpbmVzLlxuKi9cbmNvbnN0IHVuZm9sZENvZGUgPSB2aWV3ID0+IHtcbiAgICBpZiAoIXZpZXcuc3RhdGUuZmllbGQoZm9sZFN0YXRlLCBmYWxzZSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgZWZmZWN0cyA9IFtdO1xuICAgIGZvciAobGV0IGxpbmUgb2Ygc2VsZWN0ZWRMaW5lcyh2aWV3KSkge1xuICAgICAgICBsZXQgZm9sZGVkID0gZmluZEZvbGQodmlldy5zdGF0ZSwgbGluZS5mcm9tLCBsaW5lLnRvKTtcbiAgICAgICAgaWYgKGZvbGRlZClcbiAgICAgICAgICAgIGVmZmVjdHMucHVzaCh1bmZvbGRFZmZlY3Qub2YoZm9sZGVkKSwgYW5ub3VuY2VGb2xkKHZpZXcsIGZvbGRlZCwgZmFsc2UpKTtcbiAgICB9XG4gICAgaWYgKGVmZmVjdHMubGVuZ3RoKVxuICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0cyB9KTtcbiAgICByZXR1cm4gZWZmZWN0cy5sZW5ndGggPiAwO1xufTtcbmZ1bmN0aW9uIGFubm91bmNlRm9sZCh2aWV3LCByYW5nZSwgZm9sZCA9IHRydWUpIHtcbiAgICBsZXQgbGluZUZyb20gPSB2aWV3LnN0YXRlLmRvYy5saW5lQXQocmFuZ2UuZnJvbSkubnVtYmVyLCBsaW5lVG8gPSB2aWV3LnN0YXRlLmRvYy5saW5lQXQocmFuZ2UudG8pLm51bWJlcjtcbiAgICByZXR1cm4gRWRpdG9yVmlldy5hbm5vdW5jZS5vZihgJHt2aWV3LnN0YXRlLnBocmFzZShmb2xkID8gXCJGb2xkZWQgbGluZXNcIiA6IFwiVW5mb2xkZWQgbGluZXNcIil9ICR7bGluZUZyb219ICR7dmlldy5zdGF0ZS5waHJhc2UoXCJ0b1wiKX0gJHtsaW5lVG99LmApO1xufVxuLyoqXG5Gb2xkIGFsbCB0b3AtbGV2ZWwgZm9sZGFibGUgcmFuZ2VzLiBOb3RlIHRoYXQsIGluIG1vc3QgY2FzZXMsXG5mb2xkaW5nIGluZm9ybWF0aW9uIHdpbGwgZGVwZW5kIG9uIHRoZSBbc3ludGF4XG50cmVlXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLnN5bnRheFRyZWUpLCBhbmQgZm9sZGluZyBldmVyeXRoaW5nIG1heSBub3Qgd29ya1xucmVsaWFibHkgd2hlbiB0aGUgZG9jdW1lbnQgaGFzbid0IGJlZW4gZnVsbHkgcGFyc2VkIChlaXRoZXJcbmJlY2F1c2UgdGhlIGVkaXRvciBzdGF0ZSB3YXMgb25seSBqdXN0IGluaXRpYWxpemVkLCBvciBiZWNhdXNlIHRoZVxuZG9jdW1lbnQgaXMgc28gYmlnIHRoYXQgdGhlIHBhcnNlciBkZWNpZGVkIG5vdCB0byBwYXJzZSBpdFxuZW50aXJlbHkpLlxuKi9cbmNvbnN0IGZvbGRBbGwgPSB2aWV3ID0+IHtcbiAgICBsZXQgeyBzdGF0ZSB9ID0gdmlldywgZWZmZWN0cyA9IFtdO1xuICAgIGZvciAobGV0IHBvcyA9IDA7IHBvcyA8IHN0YXRlLmRvYy5sZW5ndGg7KSB7XG4gICAgICAgIGxldCBsaW5lID0gdmlldy5saW5lQmxvY2tBdChwb3MpLCByYW5nZSA9IGZvbGRhYmxlKHN0YXRlLCBsaW5lLmZyb20sIGxpbmUudG8pO1xuICAgICAgICBpZiAocmFuZ2UpXG4gICAgICAgICAgICBlZmZlY3RzLnB1c2goZm9sZEVmZmVjdC5vZihyYW5nZSkpO1xuICAgICAgICBwb3MgPSAocmFuZ2UgPyB2aWV3LmxpbmVCbG9ja0F0KHJhbmdlLnRvKSA6IGxpbmUpLnRvICsgMTtcbiAgICB9XG4gICAgaWYgKGVmZmVjdHMubGVuZ3RoKVxuICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogbWF5YmVFbmFibGUodmlldy5zdGF0ZSwgZWZmZWN0cykgfSk7XG4gICAgcmV0dXJuICEhZWZmZWN0cy5sZW5ndGg7XG59O1xuLyoqXG5VbmZvbGQgYWxsIGZvbGRlZCBjb2RlLlxuKi9cbmNvbnN0IHVuZm9sZEFsbCA9IHZpZXcgPT4ge1xuICAgIGxldCBmaWVsZCA9IHZpZXcuc3RhdGUuZmllbGQoZm9sZFN0YXRlLCBmYWxzZSk7XG4gICAgaWYgKCFmaWVsZCB8fCAhZmllbGQuc2l6ZSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBlZmZlY3RzID0gW107XG4gICAgZmllbGQuYmV0d2VlbigwLCB2aWV3LnN0YXRlLmRvYy5sZW5ndGgsIChmcm9tLCB0bykgPT4geyBlZmZlY3RzLnB1c2godW5mb2xkRWZmZWN0Lm9mKHsgZnJvbSwgdG8gfSkpOyB9KTtcbiAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0cyB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vLyBGaW5kIHRoZSBmb2xkYWJsZSByZWdpb24gY29udGFpbmluZyB0aGUgZ2l2ZW4gbGluZSwgaWYgb25lIGV4aXN0c1xuZnVuY3Rpb24gZm9sZGFibGVDb250YWluZXIodmlldywgbGluZUJsb2NrKSB7XG4gICAgLy8gTG9vayBiYWNrd2FyZHMgdGhyb3VnaCBsaW5lIGJsb2NrcyB1bnRpbCB3ZSBmaW5kIGEgZm9sZGFibGUgcmVnaW9uIHRoYXRcbiAgICAvLyBpbnRlcnNlY3RzIHdpdGggdGhlIGxpbmVcbiAgICBmb3IgKGxldCBsaW5lID0gbGluZUJsb2NrOzspIHtcbiAgICAgICAgbGV0IGZvbGRhYmxlUmVnaW9uID0gZm9sZGFibGUodmlldy5zdGF0ZSwgbGluZS5mcm9tLCBsaW5lLnRvKTtcbiAgICAgICAgaWYgKGZvbGRhYmxlUmVnaW9uICYmIGZvbGRhYmxlUmVnaW9uLnRvID4gbGluZUJsb2NrLmZyb20pXG4gICAgICAgICAgICByZXR1cm4gZm9sZGFibGVSZWdpb247XG4gICAgICAgIGlmICghbGluZS5mcm9tKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxpbmUgPSB2aWV3LmxpbmVCbG9ja0F0KGxpbmUuZnJvbSAtIDEpO1xuICAgIH1cbn1cbi8qKlxuVG9nZ2xlIGZvbGRpbmcgYXQgY3Vyc29ycy4gVW5mb2xkcyBpZiB0aGVyZSBpcyBhbiBleGlzdGluZyBmb2xkXG5zdGFydGluZyBpbiB0aGF0IGxpbmUsIHRyaWVzIHRvIGZpbmQgYSBmb2xkYWJsZSByYW5nZSBhcm91bmQgaXRcbm90aGVyd2lzZS5cbiovXG5jb25zdCB0b2dnbGVGb2xkID0gKHZpZXcpID0+IHtcbiAgICBsZXQgZWZmZWN0cyA9IFtdO1xuICAgIGZvciAobGV0IGxpbmUgb2Ygc2VsZWN0ZWRMaW5lcyh2aWV3KSkge1xuICAgICAgICBsZXQgZm9sZGVkID0gZmluZEZvbGQodmlldy5zdGF0ZSwgbGluZS5mcm9tLCBsaW5lLnRvKTtcbiAgICAgICAgaWYgKGZvbGRlZCkge1xuICAgICAgICAgICAgZWZmZWN0cy5wdXNoKHVuZm9sZEVmZmVjdC5vZihmb2xkZWQpLCBhbm5vdW5jZUZvbGQodmlldywgZm9sZGVkLCBmYWxzZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGZvbGRSYW5nZSA9IGZvbGRhYmxlQ29udGFpbmVyKHZpZXcsIGxpbmUpO1xuICAgICAgICAgICAgaWYgKGZvbGRSYW5nZSlcbiAgICAgICAgICAgICAgICBlZmZlY3RzLnB1c2goZm9sZEVmZmVjdC5vZihmb2xkUmFuZ2UpLCBhbm5vdW5jZUZvbGQodmlldywgZm9sZFJhbmdlKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVmZmVjdHMubGVuZ3RoID4gMClcbiAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IG1heWJlRW5hYmxlKHZpZXcuc3RhdGUsIGVmZmVjdHMpIH0pO1xuICAgIHJldHVybiAhIWVmZmVjdHMubGVuZ3RoO1xufTtcbi8qKlxuRGVmYXVsdCBmb2xkLXJlbGF0ZWQga2V5IGJpbmRpbmdzLlxuXG4gLSBDdHJsLVNoaWZ0LVsgKENtZC1BbHQtWyBvbiBtYWNPUyk6IFtgZm9sZENvZGVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmZvbGRDb2RlKS5cbiAtIEN0cmwtU2hpZnQtXSAoQ21kLUFsdC1dIG9uIG1hY09TKTogW2B1bmZvbGRDb2RlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS51bmZvbGRDb2RlKS5cbiAtIEN0cmwtQWx0LVs6IFtgZm9sZEFsbGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuZm9sZEFsbCkuXG4gLSBDdHJsLUFsdC1dOiBbYHVuZm9sZEFsbGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UudW5mb2xkQWxsKS5cbiovXG5jb25zdCBmb2xkS2V5bWFwID0gW1xuICAgIHsga2V5OiBcIkN0cmwtU2hpZnQtW1wiLCBtYWM6IFwiQ21kLUFsdC1bXCIsIHJ1bjogZm9sZENvZGUgfSxcbiAgICB7IGtleTogXCJDdHJsLVNoaWZ0LV1cIiwgbWFjOiBcIkNtZC1BbHQtXVwiLCBydW46IHVuZm9sZENvZGUgfSxcbiAgICB7IGtleTogXCJDdHJsLUFsdC1bXCIsIHJ1bjogZm9sZEFsbCB9LFxuICAgIHsga2V5OiBcIkN0cmwtQWx0LV1cIiwgcnVuOiB1bmZvbGRBbGwgfVxuXTtcbmNvbnN0IGRlZmF1bHRDb25maWcgPSB7XG4gICAgcGxhY2Vob2xkZXJET006IG51bGwsXG4gICAgcHJlcGFyZVBsYWNlaG9sZGVyOiBudWxsLFxuICAgIHBsYWNlaG9sZGVyVGV4dDogXCLigKZcIlxufTtcbmNvbnN0IGZvbGRDb25maWcgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lKHZhbHVlcykgeyByZXR1cm4gY29tYmluZUNvbmZpZyh2YWx1ZXMsIGRlZmF1bHRDb25maWcpOyB9XG59KTtcbi8qKlxuQ3JlYXRlIGFuIGV4dGVuc2lvbiB0aGF0IGNvbmZpZ3VyZXMgY29kZSBmb2xkaW5nLlxuKi9cbmZ1bmN0aW9uIGNvZGVGb2xkaW5nKGNvbmZpZykge1xuICAgIGxldCByZXN1bHQgPSBbZm9sZFN0YXRlLCBiYXNlVGhlbWUkMV07XG4gICAgaWYgKGNvbmZpZylcbiAgICAgICAgcmVzdWx0LnB1c2goZm9sZENvbmZpZy5vZihjb25maWcpKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gd2lkZ2V0VG9ET00odmlldywgcHJlcGFyZWQpIHtcbiAgICBsZXQgeyBzdGF0ZSB9ID0gdmlldywgY29uZiA9IHN0YXRlLmZhY2V0KGZvbGRDb25maWcpO1xuICAgIGxldCBvbmNsaWNrID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGxldCBsaW5lID0gdmlldy5saW5lQmxvY2tBdCh2aWV3LnBvc0F0RE9NKGV2ZW50LnRhcmdldCkpO1xuICAgICAgICBsZXQgZm9sZGVkID0gZmluZEZvbGQodmlldy5zdGF0ZSwgbGluZS5mcm9tLCBsaW5lLnRvKTtcbiAgICAgICAgaWYgKGZvbGRlZClcbiAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiB1bmZvbGRFZmZlY3Qub2YoZm9sZGVkKSB9KTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9O1xuICAgIGlmIChjb25mLnBsYWNlaG9sZGVyRE9NKVxuICAgICAgICByZXR1cm4gY29uZi5wbGFjZWhvbGRlckRPTSh2aWV3LCBvbmNsaWNrLCBwcmVwYXJlZCk7XG4gICAgbGV0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICBlbGVtZW50LnRleHRDb250ZW50ID0gY29uZi5wbGFjZWhvbGRlclRleHQ7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIHN0YXRlLnBocmFzZShcImZvbGRlZCBjb2RlXCIpKTtcbiAgICBlbGVtZW50LnRpdGxlID0gc3RhdGUucGhyYXNlKFwidW5mb2xkXCIpO1xuICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gXCJjbS1mb2xkUGxhY2Vob2xkZXJcIjtcbiAgICBlbGVtZW50Lm9uY2xpY2sgPSBvbmNsaWNrO1xuICAgIHJldHVybiBlbGVtZW50O1xufVxuY29uc3QgZm9sZFdpZGdldCA9IC8qQF9fUFVSRV9fKi9EZWNvcmF0aW9uLnJlcGxhY2UoeyB3aWRnZXQ6IC8qQF9fUFVSRV9fKi9uZXcgY2xhc3MgZXh0ZW5kcyBXaWRnZXRUeXBlIHtcbiAgICAgICAgdG9ET00odmlldykgeyByZXR1cm4gd2lkZ2V0VG9ET00odmlldywgbnVsbCk7IH1cbiAgICB9IH0pO1xuY2xhc3MgUHJlcGFyZWRGb2xkV2lkZ2V0IGV4dGVuZHMgV2lkZ2V0VHlwZSB7XG4gICAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBlcShvdGhlcikgeyByZXR1cm4gdGhpcy52YWx1ZSA9PSBvdGhlci52YWx1ZTsgfVxuICAgIHRvRE9NKHZpZXcpIHsgcmV0dXJuIHdpZGdldFRvRE9NKHZpZXcsIHRoaXMudmFsdWUpOyB9XG59XG5jb25zdCBmb2xkR3V0dGVyRGVmYXVsdHMgPSB7XG4gICAgb3BlblRleHQ6IFwi4oyEXCIsXG4gICAgY2xvc2VkVGV4dDogXCLigLpcIixcbiAgICBtYXJrZXJET006IG51bGwsXG4gICAgZG9tRXZlbnRIYW5kbGVyczoge30sXG4gICAgZm9sZGluZ0NoYW5nZWQ6ICgpID0+IGZhbHNlXG59O1xuY2xhc3MgRm9sZE1hcmtlciBleHRlbmRzIEd1dHRlck1hcmtlciB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnLCBvcGVuKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICB0aGlzLm9wZW4gPSBvcGVuO1xuICAgIH1cbiAgICBlcShvdGhlcikgeyByZXR1cm4gdGhpcy5jb25maWcgPT0gb3RoZXIuY29uZmlnICYmIHRoaXMub3BlbiA9PSBvdGhlci5vcGVuOyB9XG4gICAgdG9ET00odmlldykge1xuICAgICAgICBpZiAodGhpcy5jb25maWcubWFya2VyRE9NKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLm1hcmtlckRPTSh0aGlzLm9wZW4pO1xuICAgICAgICBsZXQgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICBzcGFuLnRleHRDb250ZW50ID0gdGhpcy5vcGVuID8gdGhpcy5jb25maWcub3BlblRleHQgOiB0aGlzLmNvbmZpZy5jbG9zZWRUZXh0O1xuICAgICAgICBzcGFuLnRpdGxlID0gdmlldy5zdGF0ZS5waHJhc2UodGhpcy5vcGVuID8gXCJGb2xkIGxpbmVcIiA6IFwiVW5mb2xkIGxpbmVcIik7XG4gICAgICAgIHJldHVybiBzcGFuO1xuICAgIH1cbn1cbi8qKlxuQ3JlYXRlIGFuIGV4dGVuc2lvbiB0aGF0IHJlZ2lzdGVycyBhIGZvbGQgZ3V0dGVyLCB3aGljaCBzaG93cyBhXG5mb2xkIHN0YXR1cyBpbmRpY2F0b3IgYmVmb3JlIGZvbGRhYmxlIGxpbmVzICh3aGljaCBjYW4gYmUgY2xpY2tlZFxudG8gZm9sZCBvciB1bmZvbGQgdGhlIGxpbmUpLlxuKi9cbmZ1bmN0aW9uIGZvbGRHdXR0ZXIoY29uZmlnID0ge30pIHtcbiAgICBsZXQgZnVsbENvbmZpZyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZm9sZEd1dHRlckRlZmF1bHRzKSwgY29uZmlnKTtcbiAgICBsZXQgY2FuRm9sZCA9IG5ldyBGb2xkTWFya2VyKGZ1bGxDb25maWcsIHRydWUpLCBjYW5VbmZvbGQgPSBuZXcgRm9sZE1hcmtlcihmdWxsQ29uZmlnLCBmYWxzZSk7XG4gICAgbGV0IG1hcmtlcnMgPSBWaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgICAgIHRoaXMuZnJvbSA9IHZpZXcudmlld3BvcnQuZnJvbTtcbiAgICAgICAgICAgIHRoaXMubWFya2VycyA9IHRoaXMuYnVpbGRNYXJrZXJzKHZpZXcpO1xuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgICAgIGlmICh1cGRhdGUuZG9jQ2hhbmdlZCB8fCB1cGRhdGUudmlld3BvcnRDaGFuZ2VkIHx8XG4gICAgICAgICAgICAgICAgdXBkYXRlLnN0YXJ0U3RhdGUuZmFjZXQobGFuZ3VhZ2UpICE9IHVwZGF0ZS5zdGF0ZS5mYWNldChsYW5ndWFnZSkgfHxcbiAgICAgICAgICAgICAgICB1cGRhdGUuc3RhcnRTdGF0ZS5maWVsZChmb2xkU3RhdGUsIGZhbHNlKSAhPSB1cGRhdGUuc3RhdGUuZmllbGQoZm9sZFN0YXRlLCBmYWxzZSkgfHxcbiAgICAgICAgICAgICAgICBzeW50YXhUcmVlKHVwZGF0ZS5zdGFydFN0YXRlKSAhPSBzeW50YXhUcmVlKHVwZGF0ZS5zdGF0ZSkgfHxcbiAgICAgICAgICAgICAgICBmdWxsQ29uZmlnLmZvbGRpbmdDaGFuZ2VkKHVwZGF0ZSkpXG4gICAgICAgICAgICAgICAgdGhpcy5tYXJrZXJzID0gdGhpcy5idWlsZE1hcmtlcnModXBkYXRlLnZpZXcpO1xuICAgICAgICB9XG4gICAgICAgIGJ1aWxkTWFya2Vycyh2aWV3KSB7XG4gICAgICAgICAgICBsZXQgYnVpbGRlciA9IG5ldyBSYW5nZVNldEJ1aWxkZXIoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGxpbmUgb2Ygdmlldy52aWV3cG9ydExpbmVCbG9ja3MpIHtcbiAgICAgICAgICAgICAgICBsZXQgbWFyayA9IGZpbmRGb2xkKHZpZXcuc3RhdGUsIGxpbmUuZnJvbSwgbGluZS50bykgPyBjYW5VbmZvbGRcbiAgICAgICAgICAgICAgICAgICAgOiBmb2xkYWJsZSh2aWV3LnN0YXRlLCBsaW5lLmZyb20sIGxpbmUudG8pID8gY2FuRm9sZCA6IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKG1hcmspXG4gICAgICAgICAgICAgICAgICAgIGJ1aWxkZXIuYWRkKGxpbmUuZnJvbSwgbGluZS5mcm9tLCBtYXJrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBidWlsZGVyLmZpbmlzaCgpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgbGV0IHsgZG9tRXZlbnRIYW5kbGVycyB9ID0gZnVsbENvbmZpZztcbiAgICByZXR1cm4gW1xuICAgICAgICBtYXJrZXJzLFxuICAgICAgICBndXR0ZXIoe1xuICAgICAgICAgICAgY2xhc3M6IFwiY20tZm9sZEd1dHRlclwiLFxuICAgICAgICAgICAgbWFya2Vycyh2aWV3KSB7IHZhciBfYTsgcmV0dXJuICgoX2EgPSB2aWV3LnBsdWdpbihtYXJrZXJzKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1hcmtlcnMpIHx8IFJhbmdlU2V0LmVtcHR5OyB9LFxuICAgICAgICAgICAgaW5pdGlhbFNwYWNlcigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEZvbGRNYXJrZXIoZnVsbENvbmZpZywgZmFsc2UpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRvbUV2ZW50SGFuZGxlcnM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZG9tRXZlbnRIYW5kbGVycyksIHsgY2xpY2s6ICh2aWV3LCBsaW5lLCBldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG9tRXZlbnRIYW5kbGVycy5jbGljayAmJiBkb21FdmVudEhhbmRsZXJzLmNsaWNrKHZpZXcsIGxpbmUsIGV2ZW50KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZm9sZGVkID0gZmluZEZvbGQodmlldy5zdGF0ZSwgbGluZS5mcm9tLCBsaW5lLnRvKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvbGRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHVuZm9sZEVmZmVjdC5vZihmb2xkZWQpIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGV0IHJhbmdlID0gZm9sZGFibGUodmlldy5zdGF0ZSwgbGluZS5mcm9tLCBsaW5lLnRvKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogZm9sZEVmZmVjdC5vZihyYW5nZSkgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSB9KVxuICAgICAgICB9KSxcbiAgICAgICAgY29kZUZvbGRpbmcoKVxuICAgIF07XG59XG5jb25zdCBiYXNlVGhlbWUkMSA9IC8qQF9fUFVSRV9fKi9FZGl0b3JWaWV3LmJhc2VUaGVtZSh7XG4gICAgXCIuY20tZm9sZFBsYWNlaG9sZGVyXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiNlZWVcIixcbiAgICAgICAgYm9yZGVyOiBcIjFweCBzb2xpZCAjZGRkXCIsXG4gICAgICAgIGNvbG9yOiBcIiM4ODhcIixcbiAgICAgICAgYm9yZGVyUmFkaXVzOiBcIi4yZW1cIixcbiAgICAgICAgbWFyZ2luOiBcIjAgMXB4XCIsXG4gICAgICAgIHBhZGRpbmc6IFwiMCAxcHhcIixcbiAgICAgICAgY3Vyc29yOiBcInBvaW50ZXJcIlxuICAgIH0sXG4gICAgXCIuY20tZm9sZEd1dHRlciBzcGFuXCI6IHtcbiAgICAgICAgcGFkZGluZzogXCIwIDFweFwiLFxuICAgICAgICBjdXJzb3I6IFwicG9pbnRlclwiXG4gICAgfVxufSk7XG5cbi8qKlxuQSBoaWdobGlnaHQgc3R5bGUgYXNzb2NpYXRlcyBDU1Mgc3R5bGVzIHdpdGggaGlnbGlnaHRpbmdcblt0YWdzXShodHRwczovL2xlemVyLmNvZGVtaXJyb3IubmV0L2RvY3MvcmVmI2hpZ2hsaWdodC5UYWcpLlxuKi9cbmNsYXNzIEhpZ2hsaWdodFN0eWxlIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgdGFnIHN0eWxlcyB1c2VkIHRvIGNyZWF0ZSB0aGlzIGhpZ2hsaWdodCBzdHlsZS5cbiAgICAqL1xuICAgIHNwZWNzLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuc3BlY3MgPSBzcGVjcztcbiAgICAgICAgbGV0IG1vZFNwZWM7XG4gICAgICAgIGZ1bmN0aW9uIGRlZihzcGVjKSB7XG4gICAgICAgICAgICBsZXQgY2xzID0gU3R5bGVNb2R1bGUubmV3TmFtZSgpO1xuICAgICAgICAgICAgKG1vZFNwZWMgfHwgKG1vZFNwZWMgPSBPYmplY3QuY3JlYXRlKG51bGwpKSlbXCIuXCIgKyBjbHNdID0gc3BlYztcbiAgICAgICAgICAgIHJldHVybiBjbHM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWxsID0gdHlwZW9mIG9wdGlvbnMuYWxsID09IFwic3RyaW5nXCIgPyBvcHRpb25zLmFsbCA6IG9wdGlvbnMuYWxsID8gZGVmKG9wdGlvbnMuYWxsKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3Qgc2NvcGVPcHQgPSBvcHRpb25zLnNjb3BlO1xuICAgICAgICB0aGlzLnNjb3BlID0gc2NvcGVPcHQgaW5zdGFuY2VvZiBMYW5ndWFnZSA/ICh0eXBlKSA9PiB0eXBlLnByb3AobGFuZ3VhZ2VEYXRhUHJvcCkgPT0gc2NvcGVPcHQuZGF0YVxuICAgICAgICAgICAgOiBzY29wZU9wdCA/ICh0eXBlKSA9PiB0eXBlID09IHNjb3BlT3B0IDogdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnN0eWxlID0gdGFnSGlnaGxpZ2h0ZXIoc3BlY3MubWFwKHN0eWxlID0+ICh7XG4gICAgICAgICAgICB0YWc6IHN0eWxlLnRhZyxcbiAgICAgICAgICAgIGNsYXNzOiBzdHlsZS5jbGFzcyB8fCBkZWYoT2JqZWN0LmFzc2lnbih7fSwgc3R5bGUsIHsgdGFnOiBudWxsIH0pKVxuICAgICAgICB9KSksIHtcbiAgICAgICAgICAgIGFsbCxcbiAgICAgICAgfSkuc3R5bGU7XG4gICAgICAgIHRoaXMubW9kdWxlID0gbW9kU3BlYyA/IG5ldyBTdHlsZU1vZHVsZShtb2RTcGVjKSA6IG51bGw7XG4gICAgICAgIHRoaXMudGhlbWVUeXBlID0gb3B0aW9ucy50aGVtZVR5cGU7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIGhpZ2hsaWdodGVyIHN0eWxlIHRoYXQgYXNzb2NpYXRlcyB0aGUgZ2l2ZW4gc3R5bGVzIHRvXG4gICAgdGhlIGdpdmVuIHRhZ3MuIFRoZSBzcGVjcyBtdXN0IGJlIG9iamVjdHMgdGhhdCBob2xkIGEgc3R5bGUgdGFnXG4gICAgb3IgYXJyYXkgb2YgdGFncyBpbiB0aGVpciBgdGFnYCBwcm9wZXJ0eSwgYW5kIGVpdGhlciBhIHNpbmdsZVxuICAgIGBjbGFzc2AgcHJvcGVydHkgcHJvdmlkaW5nIGEgc3RhdGljIENTUyBjbGFzcyAoZm9yIGhpZ2hsaWdodGVyXG4gICAgdGhhdCByZWx5IG9uIGV4dGVybmFsIHN0eWxpbmcpLCBvciBhXG4gICAgW2BzdHlsZS1tb2RgXShodHRwczovL2dpdGh1Yi5jb20vbWFyaWpuaC9zdHlsZS1tb2QjZG9jdW1lbnRhdGlvbiktc3R5bGVcbiAgICBzZXQgb2YgQ1NTIHByb3BlcnRpZXMgKHdoaWNoIGRlZmluZSB0aGUgc3R5bGluZyBmb3IgdGhvc2UgdGFncykuXG4gICAgXG4gICAgVGhlIENTUyBydWxlcyBjcmVhdGVkIGZvciBhIGhpZ2hsaWdodGVyIHdpbGwgYmUgZW1pdHRlZCBpbiB0aGVcbiAgICBvcmRlciBvZiB0aGUgc3BlYydzIHByb3BlcnRpZXMuIFRoYXQgbWVhbnMgdGhhdCBmb3IgZWxlbWVudHMgdGhhdFxuICAgIGhhdmUgbXVsdGlwbGUgdGFncyBhc3NvY2lhdGVkIHdpdGggdGhlbSwgc3R5bGVzIGRlZmluZWQgZnVydGhlclxuICAgIGRvd24gaW4gdGhlIGxpc3Qgd2lsbCBoYXZlIGEgaGlnaGVyIENTUyBwcmVjZWRlbmNlIHRoYW4gc3R5bGVzXG4gICAgZGVmaW5lZCBlYXJsaWVyLlxuICAgICovXG4gICAgc3RhdGljIGRlZmluZShzcGVjcywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IEhpZ2hsaWdodFN0eWxlKHNwZWNzLCBvcHRpb25zIHx8IHt9KTtcbiAgICB9XG59XG5jb25zdCBoaWdobGlnaHRlckZhY2V0ID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgZmFsbGJhY2tIaWdobGlnaHRlciA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmUodmFsdWVzKSB7IHJldHVybiB2YWx1ZXMubGVuZ3RoID8gW3ZhbHVlc1swXV0gOiBudWxsOyB9XG59KTtcbmZ1bmN0aW9uIGdldEhpZ2hsaWdodGVycyhzdGF0ZSkge1xuICAgIGxldCBtYWluID0gc3RhdGUuZmFjZXQoaGlnaGxpZ2h0ZXJGYWNldCk7XG4gICAgcmV0dXJuIG1haW4ubGVuZ3RoID8gbWFpbiA6IHN0YXRlLmZhY2V0KGZhbGxiYWNrSGlnaGxpZ2h0ZXIpO1xufVxuLyoqXG5XcmFwIGEgaGlnaGxpZ2h0ZXIgaW4gYW4gZWRpdG9yIGV4dGVuc2lvbiB0aGF0IHVzZXMgaXQgdG8gYXBwbHlcbnN5bnRheCBoaWdobGlnaHRpbmcgdG8gdGhlIGVkaXRvciBjb250ZW50LlxuXG5XaGVuIG11bHRpcGxlIChub24tZmFsbGJhY2spIHN0eWxlcyBhcmUgcHJvdmlkZWQsIHRoZSBzdHlsaW5nXG5hcHBsaWVkIGlzIHRoZSB1bmlvbiBvZiB0aGUgY2xhc3NlcyB0aGV5IGVtaXQuXG4qL1xuZnVuY3Rpb24gc3ludGF4SGlnaGxpZ2h0aW5nKGhpZ2hsaWdodGVyLCBvcHRpb25zKSB7XG4gICAgbGV0IGV4dCA9IFt0cmVlSGlnaGxpZ2h0ZXJdLCB0aGVtZVR5cGU7XG4gICAgaWYgKGhpZ2hsaWdodGVyIGluc3RhbmNlb2YgSGlnaGxpZ2h0U3R5bGUpIHtcbiAgICAgICAgaWYgKGhpZ2hsaWdodGVyLm1vZHVsZSlcbiAgICAgICAgICAgIGV4dC5wdXNoKEVkaXRvclZpZXcuc3R5bGVNb2R1bGUub2YoaGlnaGxpZ2h0ZXIubW9kdWxlKSk7XG4gICAgICAgIHRoZW1lVHlwZSA9IGhpZ2hsaWdodGVyLnRoZW1lVHlwZTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5mYWxsYmFjaylcbiAgICAgICAgZXh0LnB1c2goZmFsbGJhY2tIaWdobGlnaHRlci5vZihoaWdobGlnaHRlcikpO1xuICAgIGVsc2UgaWYgKHRoZW1lVHlwZSlcbiAgICAgICAgZXh0LnB1c2goaGlnaGxpZ2h0ZXJGYWNldC5jb21wdXRlTihbRWRpdG9yVmlldy5kYXJrVGhlbWVdLCBzdGF0ZSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gc3RhdGUuZmFjZXQoRWRpdG9yVmlldy5kYXJrVGhlbWUpID09ICh0aGVtZVR5cGUgPT0gXCJkYXJrXCIpID8gW2hpZ2hsaWdodGVyXSA6IFtdO1xuICAgICAgICB9KSk7XG4gICAgZWxzZVxuICAgICAgICBleHQucHVzaChoaWdobGlnaHRlckZhY2V0Lm9mKGhpZ2hsaWdodGVyKSk7XG4gICAgcmV0dXJuIGV4dDtcbn1cbi8qKlxuUmV0dXJucyB0aGUgQ1NTIGNsYXNzZXMgKGlmIGFueSkgdGhhdCB0aGUgaGlnaGxpZ2h0ZXJzIGFjdGl2ZSBpblxudGhlIHN0YXRlIHdvdWxkIGFzc2lnbiB0byB0aGUgZ2l2ZW4gc3R5bGVcblt0YWdzXShodHRwczovL2xlemVyLmNvZGVtaXJyb3IubmV0L2RvY3MvcmVmI2hpZ2hsaWdodC5UYWcpIGFuZFxuKG9wdGlvbmFsKSBsYW5ndWFnZVxuW3Njb3BlXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLkhpZ2hsaWdodFN0eWxlXmRlZmluZV5vcHRpb25zLnNjb3BlKS5cbiovXG5mdW5jdGlvbiBoaWdobGlnaHRpbmdGb3Ioc3RhdGUsIHRhZ3MsIHNjb3BlKSB7XG4gICAgbGV0IGhpZ2hsaWdodGVycyA9IGdldEhpZ2hsaWdodGVycyhzdGF0ZSk7XG4gICAgbGV0IHJlc3VsdCA9IG51bGw7XG4gICAgaWYgKGhpZ2hsaWdodGVycylcbiAgICAgICAgZm9yIChsZXQgaGlnaGxpZ2h0ZXIgb2YgaGlnaGxpZ2h0ZXJzKSB7XG4gICAgICAgICAgICBpZiAoIWhpZ2hsaWdodGVyLnNjb3BlIHx8IHNjb3BlICYmIGhpZ2hsaWdodGVyLnNjb3BlKHNjb3BlKSkge1xuICAgICAgICAgICAgICAgIGxldCBjbHMgPSBoaWdobGlnaHRlci5zdHlsZSh0YWdzKTtcbiAgICAgICAgICAgICAgICBpZiAoY2xzKVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQgPyByZXN1bHQgKyBcIiBcIiArIGNscyA6IGNscztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5jbGFzcyBUcmVlSGlnaGxpZ2h0ZXIge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy5tYXJrQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLnRyZWUgPSBzeW50YXhUcmVlKHZpZXcuc3RhdGUpO1xuICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gdGhpcy5idWlsZERlY28odmlldywgZ2V0SGlnaGxpZ2h0ZXJzKHZpZXcuc3RhdGUpKTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBsZXQgdHJlZSA9IHN5bnRheFRyZWUodXBkYXRlLnN0YXRlKSwgaGlnaGxpZ2h0ZXJzID0gZ2V0SGlnaGxpZ2h0ZXJzKHVwZGF0ZS5zdGF0ZSk7XG4gICAgICAgIGxldCBzdHlsZUNoYW5nZSA9IGhpZ2hsaWdodGVycyAhPSBnZXRIaWdobGlnaHRlcnModXBkYXRlLnN0YXJ0U3RhdGUpO1xuICAgICAgICBpZiAodHJlZS5sZW5ndGggPCB1cGRhdGUudmlldy52aWV3cG9ydC50byAmJiAhc3R5bGVDaGFuZ2UgJiYgdHJlZS50eXBlID09IHRoaXMudHJlZS50eXBlKSB7XG4gICAgICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gdGhpcy5kZWNvcmF0aW9ucy5tYXAodXBkYXRlLmNoYW5nZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRyZWUgIT0gdGhpcy50cmVlIHx8IHVwZGF0ZS52aWV3cG9ydENoYW5nZWQgfHwgc3R5bGVDaGFuZ2UpIHtcbiAgICAgICAgICAgIHRoaXMudHJlZSA9IHRyZWU7XG4gICAgICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gdGhpcy5idWlsZERlY28odXBkYXRlLnZpZXcsIGhpZ2hsaWdodGVycyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYnVpbGREZWNvKHZpZXcsIGhpZ2hsaWdodGVycykge1xuICAgICAgICBpZiAoIWhpZ2hsaWdodGVycyB8fCAhdGhpcy50cmVlLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uLm5vbmU7XG4gICAgICAgIGxldCBidWlsZGVyID0gbmV3IFJhbmdlU2V0QnVpbGRlcigpO1xuICAgICAgICBmb3IgKGxldCB7IGZyb20sIHRvIH0gb2Ygdmlldy52aXNpYmxlUmFuZ2VzKSB7XG4gICAgICAgICAgICBoaWdobGlnaHRUcmVlKHRoaXMudHJlZSwgaGlnaGxpZ2h0ZXJzLCAoZnJvbSwgdG8sIHN0eWxlKSA9PiB7XG4gICAgICAgICAgICAgICAgYnVpbGRlci5hZGQoZnJvbSwgdG8sIHRoaXMubWFya0NhY2hlW3N0eWxlXSB8fCAodGhpcy5tYXJrQ2FjaGVbc3R5bGVdID0gRGVjb3JhdGlvbi5tYXJrKHsgY2xhc3M6IHN0eWxlIH0pKSk7XG4gICAgICAgICAgICB9LCBmcm9tLCB0byk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1aWxkZXIuZmluaXNoKCk7XG4gICAgfVxufVxuY29uc3QgdHJlZUhpZ2hsaWdodGVyID0gLypAX19QVVJFX18qL1ByZWMuaGlnaCgvKkBfX1BVUkVfXyovVmlld1BsdWdpbi5mcm9tQ2xhc3MoVHJlZUhpZ2hsaWdodGVyLCB7XG4gICAgZGVjb3JhdGlvbnM6IHYgPT4gdi5kZWNvcmF0aW9uc1xufSkpO1xuLyoqXG5BIGRlZmF1bHQgaGlnaGxpZ2h0IHN0eWxlICh3b3JrcyB3ZWxsIHdpdGggbGlnaHQgdGhlbWVzKS5cbiovXG5jb25zdCBkZWZhdWx0SGlnaGxpZ2h0U3R5bGUgPSAvKkBfX1BVUkVfXyovSGlnaGxpZ2h0U3R5bGUuZGVmaW5lKFtcbiAgICB7IHRhZzogdGFncy5tZXRhLFxuICAgICAgICBjb2xvcjogXCIjNDA0NzQwXCIgfSxcbiAgICB7IHRhZzogdGFncy5saW5rLFxuICAgICAgICB0ZXh0RGVjb3JhdGlvbjogXCJ1bmRlcmxpbmVcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmhlYWRpbmcsXG4gICAgICAgIHRleHREZWNvcmF0aW9uOiBcInVuZGVybGluZVwiLFxuICAgICAgICBmb250V2VpZ2h0OiBcImJvbGRcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmVtcGhhc2lzLFxuICAgICAgICBmb250U3R5bGU6IFwiaXRhbGljXCIgfSxcbiAgICB7IHRhZzogdGFncy5zdHJvbmcsXG4gICAgICAgIGZvbnRXZWlnaHQ6IFwiYm9sZFwiIH0sXG4gICAgeyB0YWc6IHRhZ3Muc3RyaWtldGhyb3VnaCxcbiAgICAgICAgdGV4dERlY29yYXRpb246IFwibGluZS10aHJvdWdoXCIgfSxcbiAgICB7IHRhZzogdGFncy5rZXl3b3JkLFxuICAgICAgICBjb2xvcjogXCIjNzA4XCIgfSxcbiAgICB7IHRhZzogW3RhZ3MuYXRvbSwgdGFncy5ib29sLCB0YWdzLnVybCwgdGFncy5jb250ZW50U2VwYXJhdG9yLCB0YWdzLmxhYmVsTmFtZV0sXG4gICAgICAgIGNvbG9yOiBcIiMyMTlcIiB9LFxuICAgIHsgdGFnOiBbdGFncy5saXRlcmFsLCB0YWdzLmluc2VydGVkXSxcbiAgICAgICAgY29sb3I6IFwiIzE2NFwiIH0sXG4gICAgeyB0YWc6IFt0YWdzLnN0cmluZywgdGFncy5kZWxldGVkXSxcbiAgICAgICAgY29sb3I6IFwiI2ExMVwiIH0sXG4gICAgeyB0YWc6IFt0YWdzLnJlZ2V4cCwgdGFncy5lc2NhcGUsIC8qQF9fUFVSRV9fKi90YWdzLnNwZWNpYWwodGFncy5zdHJpbmcpXSxcbiAgICAgICAgY29sb3I6IFwiI2U0MFwiIH0sXG4gICAgeyB0YWc6IC8qQF9fUFVSRV9fKi90YWdzLmRlZmluaXRpb24odGFncy52YXJpYWJsZU5hbWUpLFxuICAgICAgICBjb2xvcjogXCIjMDBmXCIgfSxcbiAgICB7IHRhZzogLypAX19QVVJFX18qL3RhZ3MubG9jYWwodGFncy52YXJpYWJsZU5hbWUpLFxuICAgICAgICBjb2xvcjogXCIjMzBhXCIgfSxcbiAgICB7IHRhZzogW3RhZ3MudHlwZU5hbWUsIHRhZ3MubmFtZXNwYWNlXSxcbiAgICAgICAgY29sb3I6IFwiIzA4NVwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuY2xhc3NOYW1lLFxuICAgICAgICBjb2xvcjogXCIjMTY3XCIgfSxcbiAgICB7IHRhZzogWy8qQF9fUFVSRV9fKi90YWdzLnNwZWNpYWwodGFncy52YXJpYWJsZU5hbWUpLCB0YWdzLm1hY3JvTmFtZV0sXG4gICAgICAgIGNvbG9yOiBcIiMyNTZcIiB9LFxuICAgIHsgdGFnOiAvKkBfX1BVUkVfXyovdGFncy5kZWZpbml0aW9uKHRhZ3MucHJvcGVydHlOYW1lKSxcbiAgICAgICAgY29sb3I6IFwiIzAwY1wiIH0sXG4gICAgeyB0YWc6IHRhZ3MuY29tbWVudCxcbiAgICAgICAgY29sb3I6IFwiIzk0MFwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuaW52YWxpZCxcbiAgICAgICAgY29sb3I6IFwiI2YwMFwiIH1cbl0pO1xuXG5jb25zdCBiYXNlVGhlbWUgPSAvKkBfX1BVUkVfXyovRWRpdG9yVmlldy5iYXNlVGhlbWUoe1xuICAgIFwiJi5jbS1mb2N1c2VkIC5jbS1tYXRjaGluZ0JyYWNrZXRcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwiIzMyOGM4MjUyXCIgfSxcbiAgICBcIiYuY20tZm9jdXNlZCAuY20tbm9ubWF0Y2hpbmdCcmFja2V0XCI6IHsgYmFja2dyb3VuZENvbG9yOiBcIiNiYjU1NTU0NFwiIH1cbn0pO1xuY29uc3QgRGVmYXVsdFNjYW5EaXN0ID0gMTAwMDAsIERlZmF1bHRCcmFja2V0cyA9IFwiKClbXXt9XCI7XG5jb25zdCBicmFja2V0TWF0Y2hpbmdDb25maWcgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lKGNvbmZpZ3MpIHtcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVDb25maWcoY29uZmlncywge1xuICAgICAgICAgICAgYWZ0ZXJDdXJzb3I6IHRydWUsXG4gICAgICAgICAgICBicmFja2V0czogRGVmYXVsdEJyYWNrZXRzLFxuICAgICAgICAgICAgbWF4U2NhbkRpc3RhbmNlOiBEZWZhdWx0U2NhbkRpc3QsXG4gICAgICAgICAgICByZW5kZXJNYXRjaDogZGVmYXVsdFJlbmRlck1hdGNoXG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuY29uc3QgbWF0Y2hpbmdNYXJrID0gLypAX19QVVJFX18qL0RlY29yYXRpb24ubWFyayh7IGNsYXNzOiBcImNtLW1hdGNoaW5nQnJhY2tldFwiIH0pLCBub25tYXRjaGluZ01hcmsgPSAvKkBfX1BVUkVfXyovRGVjb3JhdGlvbi5tYXJrKHsgY2xhc3M6IFwiY20tbm9ubWF0Y2hpbmdCcmFja2V0XCIgfSk7XG5mdW5jdGlvbiBkZWZhdWx0UmVuZGVyTWF0Y2gobWF0Y2gpIHtcbiAgICBsZXQgZGVjb3JhdGlvbnMgPSBbXTtcbiAgICBsZXQgbWFyayA9IG1hdGNoLm1hdGNoZWQgPyBtYXRjaGluZ01hcmsgOiBub25tYXRjaGluZ01hcms7XG4gICAgZGVjb3JhdGlvbnMucHVzaChtYXJrLnJhbmdlKG1hdGNoLnN0YXJ0LmZyb20sIG1hdGNoLnN0YXJ0LnRvKSk7XG4gICAgaWYgKG1hdGNoLmVuZClcbiAgICAgICAgZGVjb3JhdGlvbnMucHVzaChtYXJrLnJhbmdlKG1hdGNoLmVuZC5mcm9tLCBtYXRjaC5lbmQudG8pKTtcbiAgICByZXR1cm4gZGVjb3JhdGlvbnM7XG59XG5jb25zdCBicmFja2V0TWF0Y2hpbmdTdGF0ZSA9IC8qQF9fUFVSRV9fKi9TdGF0ZUZpZWxkLmRlZmluZSh7XG4gICAgY3JlYXRlKCkgeyByZXR1cm4gRGVjb3JhdGlvbi5ub25lOyB9LFxuICAgIHVwZGF0ZShkZWNvLCB0cikge1xuICAgICAgICBpZiAoIXRyLmRvY0NoYW5nZWQgJiYgIXRyLnNlbGVjdGlvbilcbiAgICAgICAgICAgIHJldHVybiBkZWNvO1xuICAgICAgICBsZXQgZGVjb3JhdGlvbnMgPSBbXTtcbiAgICAgICAgbGV0IGNvbmZpZyA9IHRyLnN0YXRlLmZhY2V0KGJyYWNrZXRNYXRjaGluZ0NvbmZpZyk7XG4gICAgICAgIGZvciAobGV0IHJhbmdlIG9mIHRyLnN0YXRlLnNlbGVjdGlvbi5yYW5nZXMpIHtcbiAgICAgICAgICAgIGlmICghcmFuZ2UuZW1wdHkpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBsZXQgbWF0Y2ggPSBtYXRjaEJyYWNrZXRzKHRyLnN0YXRlLCByYW5nZS5oZWFkLCAtMSwgY29uZmlnKVxuICAgICAgICAgICAgICAgIHx8IChyYW5nZS5oZWFkID4gMCAmJiBtYXRjaEJyYWNrZXRzKHRyLnN0YXRlLCByYW5nZS5oZWFkIC0gMSwgMSwgY29uZmlnKSlcbiAgICAgICAgICAgICAgICB8fCAoY29uZmlnLmFmdGVyQ3Vyc29yICYmXG4gICAgICAgICAgICAgICAgICAgIChtYXRjaEJyYWNrZXRzKHRyLnN0YXRlLCByYW5nZS5oZWFkLCAxLCBjb25maWcpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAocmFuZ2UuaGVhZCA8IHRyLnN0YXRlLmRvYy5sZW5ndGggJiYgbWF0Y2hCcmFja2V0cyh0ci5zdGF0ZSwgcmFuZ2UuaGVhZCArIDEsIC0xLCBjb25maWcpKSkpO1xuICAgICAgICAgICAgaWYgKG1hdGNoKVxuICAgICAgICAgICAgICAgIGRlY29yYXRpb25zID0gZGVjb3JhdGlvbnMuY29uY2F0KGNvbmZpZy5yZW5kZXJNYXRjaChtYXRjaCwgdHIuc3RhdGUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5zZXQoZGVjb3JhdGlvbnMsIHRydWUpO1xuICAgIH0sXG4gICAgcHJvdmlkZTogZiA9PiBFZGl0b3JWaWV3LmRlY29yYXRpb25zLmZyb20oZilcbn0pO1xuY29uc3QgYnJhY2tldE1hdGNoaW5nVW5pcXVlID0gW1xuICAgIGJyYWNrZXRNYXRjaGluZ1N0YXRlLFxuICAgIGJhc2VUaGVtZVxuXTtcbi8qKlxuQ3JlYXRlIGFuIGV4dGVuc2lvbiB0aGF0IGVuYWJsZXMgYnJhY2tldCBtYXRjaGluZy4gV2hlbmV2ZXIgdGhlXG5jdXJzb3IgaXMgbmV4dCB0byBhIGJyYWNrZXQsIHRoYXQgYnJhY2tldCBhbmQgdGhlIG9uZSBpdCBtYXRjaGVzXG5hcmUgaGlnaGxpZ2h0ZWQuIE9yLCB3aGVuIG5vIG1hdGNoaW5nIGJyYWNrZXQgaXMgZm91bmQsIGFub3RoZXJcbmhpZ2hsaWdodGluZyBzdHlsZSBpcyB1c2VkIHRvIGluZGljYXRlIHRoaXMuXG4qL1xuZnVuY3Rpb24gYnJhY2tldE1hdGNoaW5nKGNvbmZpZyA9IHt9KSB7XG4gICAgcmV0dXJuIFticmFja2V0TWF0Y2hpbmdDb25maWcub2YoY29uZmlnKSwgYnJhY2tldE1hdGNoaW5nVW5pcXVlXTtcbn1cbi8qKlxuV2hlbiBsYXJnZXIgc3ludGF4IG5vZGVzLCBzdWNoIGFzIEhUTUwgdGFncywgYXJlIG1hcmtlZCBhc1xub3BlbmluZy9jbG9zaW5nLCBpdCBjYW4gYmUgYSBiaXQgbWVzc3kgdG8gdHJlYXQgdGhlIHdob2xlIG5vZGUgYXNcbmEgbWF0Y2hhYmxlIGJyYWNrZXQuIFRoaXMgbm9kZSBwcm9wIGFsbG93cyB5b3UgdG8gZGVmaW5lLCBmb3Igc3VjaFxuYSBub2RlLCBhIOKAmGhhbmRsZeKAmeKAlHRoZSBwYXJ0IG9mIHRoZSBub2RlIHRoYXQgaXMgaGlnaGxpZ2h0ZWQsIGFuZFxudGhhdCB0aGUgY3Vyc29yIG11c3QgYmUgb24gdG8gYWN0aXZhdGUgaGlnaGxpZ2h0aW5nIGluIHRoZSBmaXJzdFxucGxhY2UuXG4qL1xuY29uc3QgYnJhY2tldE1hdGNoaW5nSGFuZGxlID0gLypAX19QVVJFX18qL25ldyBOb2RlUHJvcCgpO1xuZnVuY3Rpb24gbWF0Y2hpbmdOb2Rlcyhub2RlLCBkaXIsIGJyYWNrZXRzKSB7XG4gICAgbGV0IGJ5UHJvcCA9IG5vZGUucHJvcChkaXIgPCAwID8gTm9kZVByb3Aub3BlbmVkQnkgOiBOb2RlUHJvcC5jbG9zZWRCeSk7XG4gICAgaWYgKGJ5UHJvcClcbiAgICAgICAgcmV0dXJuIGJ5UHJvcDtcbiAgICBpZiAobm9kZS5uYW1lLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgIGxldCBpbmRleCA9IGJyYWNrZXRzLmluZGV4T2Yobm9kZS5uYW1lKTtcbiAgICAgICAgaWYgKGluZGV4ID4gLTEgJiYgaW5kZXggJSAyID09IChkaXIgPCAwID8gMSA6IDApKVxuICAgICAgICAgICAgcmV0dXJuIFticmFja2V0c1tpbmRleCArIGRpcl1dO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGZpbmRIYW5kbGUobm9kZSkge1xuICAgIGxldCBoYXNIYW5kbGUgPSBub2RlLnR5cGUucHJvcChicmFja2V0TWF0Y2hpbmdIYW5kbGUpO1xuICAgIHJldHVybiBoYXNIYW5kbGUgPyBoYXNIYW5kbGUobm9kZS5ub2RlKSA6IG5vZGU7XG59XG4vKipcbkZpbmQgdGhlIG1hdGNoaW5nIGJyYWNrZXQgZm9yIHRoZSB0b2tlbiBhdCBgcG9zYCwgc2Nhbm5pbmdcbmRpcmVjdGlvbiBgZGlyYC4gT25seSB0aGUgYGJyYWNrZXRzYCBhbmQgYG1heFNjYW5EaXN0YW5jZWBcbnByb3BlcnRpZXMgYXJlIHVzZWQgZnJvbSBgY29uZmlnYCwgaWYgZ2l2ZW4uIFJldHVybnMgbnVsbCBpZiBub1xuYnJhY2tldCB3YXMgZm91bmQgYXQgYHBvc2AsIG9yIGEgbWF0Y2ggcmVzdWx0IG90aGVyd2lzZS5cbiovXG5mdW5jdGlvbiBtYXRjaEJyYWNrZXRzKHN0YXRlLCBwb3MsIGRpciwgY29uZmlnID0ge30pIHtcbiAgICBsZXQgbWF4U2NhbkRpc3RhbmNlID0gY29uZmlnLm1heFNjYW5EaXN0YW5jZSB8fCBEZWZhdWx0U2NhbkRpc3QsIGJyYWNrZXRzID0gY29uZmlnLmJyYWNrZXRzIHx8IERlZmF1bHRCcmFja2V0cztcbiAgICBsZXQgdHJlZSA9IHN5bnRheFRyZWUoc3RhdGUpLCBub2RlID0gdHJlZS5yZXNvbHZlSW5uZXIocG9zLCBkaXIpO1xuICAgIGZvciAobGV0IGN1ciA9IG5vZGU7IGN1cjsgY3VyID0gY3VyLnBhcmVudCkge1xuICAgICAgICBsZXQgbWF0Y2hlcyA9IG1hdGNoaW5nTm9kZXMoY3VyLnR5cGUsIGRpciwgYnJhY2tldHMpO1xuICAgICAgICBpZiAobWF0Y2hlcyAmJiBjdXIuZnJvbSA8IGN1ci50bykge1xuICAgICAgICAgICAgbGV0IGhhbmRsZSA9IGZpbmRIYW5kbGUoY3VyKTtcbiAgICAgICAgICAgIGlmIChoYW5kbGUgJiYgKGRpciA+IDAgPyBwb3MgPj0gaGFuZGxlLmZyb20gJiYgcG9zIDwgaGFuZGxlLnRvIDogcG9zID4gaGFuZGxlLmZyb20gJiYgcG9zIDw9IGhhbmRsZS50bykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoTWFya2VkQnJhY2tldHMoc3RhdGUsIHBvcywgZGlyLCBjdXIsIGhhbmRsZSwgbWF0Y2hlcywgYnJhY2tldHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYXRjaFBsYWluQnJhY2tldHMoc3RhdGUsIHBvcywgZGlyLCB0cmVlLCBub2RlLnR5cGUsIG1heFNjYW5EaXN0YW5jZSwgYnJhY2tldHMpO1xufVxuZnVuY3Rpb24gbWF0Y2hNYXJrZWRCcmFja2V0cyhfc3RhdGUsIF9wb3MsIGRpciwgdG9rZW4sIGhhbmRsZSwgbWF0Y2hpbmcsIGJyYWNrZXRzKSB7XG4gICAgbGV0IHBhcmVudCA9IHRva2VuLnBhcmVudCwgZmlyc3RUb2tlbiA9IHsgZnJvbTogaGFuZGxlLmZyb20sIHRvOiBoYW5kbGUudG8gfTtcbiAgICBsZXQgZGVwdGggPSAwLCBjdXJzb3IgPSBwYXJlbnQgPT09IG51bGwgfHwgcGFyZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJlbnQuY3Vyc29yKCk7XG4gICAgaWYgKGN1cnNvciAmJiAoZGlyIDwgMCA/IGN1cnNvci5jaGlsZEJlZm9yZSh0b2tlbi5mcm9tKSA6IGN1cnNvci5jaGlsZEFmdGVyKHRva2VuLnRvKSkpXG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGlmIChkaXIgPCAwID8gY3Vyc29yLnRvIDw9IHRva2VuLmZyb20gOiBjdXJzb3IuZnJvbSA+PSB0b2tlbi50bykge1xuICAgICAgICAgICAgICAgIGlmIChkZXB0aCA9PSAwICYmIG1hdGNoaW5nLmluZGV4T2YoY3Vyc29yLnR5cGUubmFtZSkgPiAtMSAmJiBjdXJzb3IuZnJvbSA8IGN1cnNvci50bykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZW5kSGFuZGxlID0gZmluZEhhbmRsZShjdXJzb3IpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBzdGFydDogZmlyc3RUb2tlbiwgZW5kOiBlbmRIYW5kbGUgPyB7IGZyb206IGVuZEhhbmRsZS5mcm9tLCB0bzogZW5kSGFuZGxlLnRvIH0gOiB1bmRlZmluZWQsIG1hdGNoZWQ6IHRydWUgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobWF0Y2hpbmdOb2RlcyhjdXJzb3IudHlwZSwgZGlyLCBicmFja2V0cykpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVwdGgrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobWF0Y2hpbmdOb2RlcyhjdXJzb3IudHlwZSwgLWRpciwgYnJhY2tldHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZXB0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZW5kSGFuZGxlID0gZmluZEhhbmRsZShjdXJzb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogZmlyc3RUb2tlbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IGVuZEhhbmRsZSAmJiBlbmRIYW5kbGUuZnJvbSA8IGVuZEhhbmRsZS50byA/IHsgZnJvbTogZW5kSGFuZGxlLmZyb20sIHRvOiBlbmRIYW5kbGUudG8gfSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVkOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkZXB0aC0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAoZGlyIDwgMCA/IGN1cnNvci5wcmV2U2libGluZygpIDogY3Vyc29yLm5leHRTaWJsaW5nKCkpO1xuICAgIHJldHVybiB7IHN0YXJ0OiBmaXJzdFRva2VuLCBtYXRjaGVkOiBmYWxzZSB9O1xufVxuZnVuY3Rpb24gbWF0Y2hQbGFpbkJyYWNrZXRzKHN0YXRlLCBwb3MsIGRpciwgdHJlZSwgdG9rZW5UeXBlLCBtYXhTY2FuRGlzdGFuY2UsIGJyYWNrZXRzKSB7XG4gICAgbGV0IHN0YXJ0Q2ggPSBkaXIgPCAwID8gc3RhdGUuc2xpY2VEb2MocG9zIC0gMSwgcG9zKSA6IHN0YXRlLnNsaWNlRG9jKHBvcywgcG9zICsgMSk7XG4gICAgbGV0IGJyYWNrZXQgPSBicmFja2V0cy5pbmRleE9mKHN0YXJ0Q2gpO1xuICAgIGlmIChicmFja2V0IDwgMCB8fCAoYnJhY2tldCAlIDIgPT0gMCkgIT0gKGRpciA+IDApKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgc3RhcnRUb2tlbiA9IHsgZnJvbTogZGlyIDwgMCA/IHBvcyAtIDEgOiBwb3MsIHRvOiBkaXIgPiAwID8gcG9zICsgMSA6IHBvcyB9O1xuICAgIGxldCBpdGVyID0gc3RhdGUuZG9jLml0ZXJSYW5nZShwb3MsIGRpciA+IDAgPyBzdGF0ZS5kb2MubGVuZ3RoIDogMCksIGRlcHRoID0gMDtcbiAgICBmb3IgKGxldCBkaXN0YW5jZSA9IDA7ICEoaXRlci5uZXh0KCkpLmRvbmUgJiYgZGlzdGFuY2UgPD0gbWF4U2NhbkRpc3RhbmNlOykge1xuICAgICAgICBsZXQgdGV4dCA9IGl0ZXIudmFsdWU7XG4gICAgICAgIGlmIChkaXIgPCAwKVxuICAgICAgICAgICAgZGlzdGFuY2UgKz0gdGV4dC5sZW5ndGg7XG4gICAgICAgIGxldCBiYXNlUG9zID0gcG9zICsgZGlzdGFuY2UgKiBkaXI7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IGRpciA+IDAgPyAwIDogdGV4dC5sZW5ndGggLSAxLCBlbmQgPSBkaXIgPiAwID8gdGV4dC5sZW5ndGggOiAtMTsgcG9zICE9IGVuZDsgcG9zICs9IGRpcikge1xuICAgICAgICAgICAgbGV0IGZvdW5kID0gYnJhY2tldHMuaW5kZXhPZih0ZXh0W3Bvc10pO1xuICAgICAgICAgICAgaWYgKGZvdW5kIDwgMCB8fCB0cmVlLnJlc29sdmVJbm5lcihiYXNlUG9zICsgcG9zLCAxKS50eXBlICE9IHRva2VuVHlwZSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmICgoZm91bmQgJSAyID09IDApID09IChkaXIgPiAwKSkge1xuICAgICAgICAgICAgICAgIGRlcHRoKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkZXB0aCA9PSAxKSB7IC8vIENsb3NpbmdcbiAgICAgICAgICAgICAgICByZXR1cm4geyBzdGFydDogc3RhcnRUb2tlbiwgZW5kOiB7IGZyb206IGJhc2VQb3MgKyBwb3MsIHRvOiBiYXNlUG9zICsgcG9zICsgMSB9LCBtYXRjaGVkOiAoZm91bmQgPj4gMSkgPT0gKGJyYWNrZXQgPj4gMSkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlcHRoLS07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpciA+IDApXG4gICAgICAgICAgICBkaXN0YW5jZSArPSB0ZXh0Lmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIGl0ZXIuZG9uZSA/IHsgc3RhcnQ6IHN0YXJ0VG9rZW4sIG1hdGNoZWQ6IGZhbHNlIH0gOiBudWxsO1xufVxuXG4vLyBDb3VudHMgdGhlIGNvbHVtbiBvZmZzZXQgaW4gYSBzdHJpbmcsIHRha2luZyB0YWJzIGludG8gYWNjb3VudC5cbi8vIFVzZWQgbW9zdGx5IHRvIGZpbmQgaW5kZW50YXRpb24uXG5mdW5jdGlvbiBjb3VudENvbChzdHJpbmcsIGVuZCwgdGFiU2l6ZSwgc3RhcnRJbmRleCA9IDAsIHN0YXJ0VmFsdWUgPSAwKSB7XG4gICAgaWYgKGVuZCA9PSBudWxsKSB7XG4gICAgICAgIGVuZCA9IHN0cmluZy5zZWFyY2goL1teXFxzXFx1MDBhMF0vKTtcbiAgICAgICAgaWYgKGVuZCA9PSAtMSlcbiAgICAgICAgICAgIGVuZCA9IHN0cmluZy5sZW5ndGg7XG4gICAgfVxuICAgIGxldCBuID0gc3RhcnRWYWx1ZTtcbiAgICBmb3IgKGxldCBpID0gc3RhcnRJbmRleDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAgIGlmIChzdHJpbmcuY2hhckNvZGVBdChpKSA9PSA5KVxuICAgICAgICAgICAgbiArPSB0YWJTaXplIC0gKG4gJSB0YWJTaXplKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgbisrO1xuICAgIH1cbiAgICByZXR1cm4gbjtcbn1cbi8qKlxuRW5jYXBzdWxhdGVzIGEgc2luZ2xlIGxpbmUgb2YgaW5wdXQuIEdpdmVuIHRvIHN0cmVhbSBzeW50YXggY29kZSxcbndoaWNoIHVzZXMgaXQgdG8gdG9rZW5pemUgdGhlIGNvbnRlbnQuXG4qL1xuY2xhc3MgU3RyaW5nU3RyZWFtIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBzdHJlYW0uXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgbGluZS5cbiAgICAqL1xuICAgIHN0cmluZywgdGFiU2l6ZSwgXG4gICAgLyoqXG4gICAgVGhlIGN1cnJlbnQgaW5kZW50IHVuaXQgc2l6ZS5cbiAgICAqL1xuICAgIGluZGVudFVuaXQsIG92ZXJyaWRlSW5kZW50KSB7XG4gICAgICAgIHRoaXMuc3RyaW5nID0gc3RyaW5nO1xuICAgICAgICB0aGlzLnRhYlNpemUgPSB0YWJTaXplO1xuICAgICAgICB0aGlzLmluZGVudFVuaXQgPSBpbmRlbnRVbml0O1xuICAgICAgICB0aGlzLm92ZXJyaWRlSW5kZW50ID0gb3ZlcnJpZGVJbmRlbnQ7XG4gICAgICAgIC8qKlxuICAgICAgICBUaGUgY3VycmVudCBwb3NpdGlvbiBvbiB0aGUgbGluZS5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSBjdXJyZW50IHRva2VuLlxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YXJ0ID0gMDtcbiAgICAgICAgdGhpcy5sYXN0Q29sdW1uUG9zID0gMDtcbiAgICAgICAgdGhpcy5sYXN0Q29sdW1uVmFsdWUgPSAwO1xuICAgIH1cbiAgICAvKipcbiAgICBUcnVlIGlmIHdlIGFyZSBhdCB0aGUgZW5kIG9mIHRoZSBsaW5lLlxuICAgICovXG4gICAgZW9sKCkgeyByZXR1cm4gdGhpcy5wb3MgPj0gdGhpcy5zdHJpbmcubGVuZ3RoOyB9XG4gICAgLyoqXG4gICAgVHJ1ZSBpZiB3ZSBhcmUgYXQgdGhlIHN0YXJ0IG9mIHRoZSBsaW5lLlxuICAgICovXG4gICAgc29sKCkgeyByZXR1cm4gdGhpcy5wb3MgPT0gMDsgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgbmV4dCBjb2RlIHVuaXQgYWZ0ZXIgdGhlIGN1cnJlbnQgcG9zaXRpb24sIG9yIHVuZGVmaW5lZFxuICAgIGlmIHdlJ3JlIGF0IHRoZSBlbmQgb2YgdGhlIGxpbmUuXG4gICAgKi9cbiAgICBwZWVrKCkgeyByZXR1cm4gdGhpcy5zdHJpbmcuY2hhckF0KHRoaXMucG9zKSB8fCB1bmRlZmluZWQ7IH1cbiAgICAvKipcbiAgICBSZWFkIHRoZSBuZXh0IGNvZGUgdW5pdCBhbmQgYWR2YW5jZSBgdGhpcy5wb3NgLlxuICAgICovXG4gICAgbmV4dCgpIHtcbiAgICAgICAgaWYgKHRoaXMucG9zIDwgdGhpcy5zdHJpbmcubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyaW5nLmNoYXJBdCh0aGlzLnBvcysrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgTWF0Y2ggdGhlIG5leHQgY2hhcmFjdGVyIGFnYWluc3QgdGhlIGdpdmVuIHN0cmluZywgcmVndWxhclxuICAgIGV4cHJlc3Npb24sIG9yIHByZWRpY2F0ZS4gQ29uc3VtZSBhbmQgcmV0dXJuIGl0IGlmIGl0IG1hdGNoZXMuXG4gICAgKi9cbiAgICBlYXQobWF0Y2gpIHtcbiAgICAgICAgbGV0IGNoID0gdGhpcy5zdHJpbmcuY2hhckF0KHRoaXMucG9zKTtcbiAgICAgICAgbGV0IG9rO1xuICAgICAgICBpZiAodHlwZW9mIG1hdGNoID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICBvayA9IGNoID09IG1hdGNoO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBvayA9IGNoICYmIChtYXRjaCBpbnN0YW5jZW9mIFJlZ0V4cCA/IG1hdGNoLnRlc3QoY2gpIDogbWF0Y2goY2gpKTtcbiAgICAgICAgaWYgKG9rKSB7XG4gICAgICAgICAgICArK3RoaXMucG9zO1xuICAgICAgICAgICAgcmV0dXJuIGNoO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIENvbnRpbnVlIG1hdGNoaW5nIGNoYXJhY3RlcnMgdGhhdCBtYXRjaCB0aGUgZ2l2ZW4gc3RyaW5nLFxuICAgIHJlZ3VsYXIgZXhwcmVzc2lvbiwgb3IgcHJlZGljYXRlIGZ1bmN0aW9uLiBSZXR1cm4gdHJ1ZSBpZiBhbnlcbiAgICBjaGFyYWN0ZXJzIHdlcmUgY29uc3VtZWQuXG4gICAgKi9cbiAgICBlYXRXaGlsZShtYXRjaCkge1xuICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLnBvcztcbiAgICAgICAgd2hpbGUgKHRoaXMuZWF0KG1hdGNoKSkgeyB9XG4gICAgICAgIHJldHVybiB0aGlzLnBvcyA+IHN0YXJ0O1xuICAgIH1cbiAgICAvKipcbiAgICBDb25zdW1lIHdoaXRlc3BhY2UgYWhlYWQgb2YgYHRoaXMucG9zYC4gUmV0dXJuIHRydWUgaWYgYW55IHdhc1xuICAgIGZvdW5kLlxuICAgICovXG4gICAgZWF0U3BhY2UoKSB7XG4gICAgICAgIGxldCBzdGFydCA9IHRoaXMucG9zO1xuICAgICAgICB3aGlsZSAoL1tcXHNcXHUwMGEwXS8udGVzdCh0aGlzLnN0cmluZy5jaGFyQXQodGhpcy5wb3MpKSlcbiAgICAgICAgICAgICsrdGhpcy5wb3M7XG4gICAgICAgIHJldHVybiB0aGlzLnBvcyA+IHN0YXJ0O1xuICAgIH1cbiAgICAvKipcbiAgICBNb3ZlIHRvIHRoZSBlbmQgb2YgdGhlIGxpbmUuXG4gICAgKi9cbiAgICBza2lwVG9FbmQoKSB7IHRoaXMucG9zID0gdGhpcy5zdHJpbmcubGVuZ3RoOyB9XG4gICAgLyoqXG4gICAgTW92ZSB0byBkaXJlY3RseSBiZWZvcmUgdGhlIGdpdmVuIGNoYXJhY3RlciwgaWYgZm91bmQgb24gdGhlXG4gICAgY3VycmVudCBsaW5lLlxuICAgICovXG4gICAgc2tpcFRvKGNoKSB7XG4gICAgICAgIGxldCBmb3VuZCA9IHRoaXMuc3RyaW5nLmluZGV4T2YoY2gsIHRoaXMucG9zKTtcbiAgICAgICAgaWYgKGZvdW5kID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMucG9zID0gZm91bmQ7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBNb3ZlIGJhY2sgYG5gIGNoYXJhY3RlcnMuXG4gICAgKi9cbiAgICBiYWNrVXAobikgeyB0aGlzLnBvcyAtPSBuOyB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBjb2x1bW4gcG9zaXRpb24gYXQgYHRoaXMucG9zYC5cbiAgICAqL1xuICAgIGNvbHVtbigpIHtcbiAgICAgICAgaWYgKHRoaXMubGFzdENvbHVtblBvcyA8IHRoaXMuc3RhcnQpIHtcbiAgICAgICAgICAgIHRoaXMubGFzdENvbHVtblZhbHVlID0gY291bnRDb2wodGhpcy5zdHJpbmcsIHRoaXMuc3RhcnQsIHRoaXMudGFiU2l6ZSwgdGhpcy5sYXN0Q29sdW1uUG9zLCB0aGlzLmxhc3RDb2x1bW5WYWx1ZSk7XG4gICAgICAgICAgICB0aGlzLmxhc3RDb2x1bW5Qb3MgPSB0aGlzLnN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmxhc3RDb2x1bW5WYWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBpbmRlbnRhdGlvbiBjb2x1bW4gb2YgdGhlIGN1cnJlbnQgbGluZS5cbiAgICAqL1xuICAgIGluZGVudGF0aW9uKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoX2EgPSB0aGlzLm92ZXJyaWRlSW5kZW50KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjb3VudENvbCh0aGlzLnN0cmluZywgbnVsbCwgdGhpcy50YWJTaXplKTtcbiAgICB9XG4gICAgLyoqXG4gICAgTWF0Y2ggdGhlIGlucHV0IGFnYWluc3QgdGhlIGdpdmVuIHN0cmluZyBvciByZWd1bGFyIGV4cHJlc3Npb25cbiAgICAod2hpY2ggc2hvdWxkIHN0YXJ0IHdpdGggYSBgXmApLiBSZXR1cm4gdHJ1ZSBvciB0aGUgcmVnZXhwIG1hdGNoXG4gICAgaWYgaXQgbWF0Y2hlcy5cbiAgICBcbiAgICBVbmxlc3MgYGNvbnN1bWVgIGlzIHNldCB0byBgZmFsc2VgLCB0aGlzIHdpbGwgbW92ZSBgdGhpcy5wb3NgXG4gICAgcGFzdCB0aGUgbWF0Y2hlZCB0ZXh0LlxuICAgIFxuICAgIFdoZW4gbWF0Y2hpbmcgYSBzdHJpbmcgYGNhc2VJbnNlbnNpdGl2ZWAgY2FuIGJlIHNldCB0byB0cnVlIHRvXG4gICAgbWFrZSB0aGUgbWF0Y2ggY2FzZS1pbnNlbnNpdGl2ZS5cbiAgICAqL1xuICAgIG1hdGNoKHBhdHRlcm4sIGNvbnN1bWUsIGNhc2VJbnNlbnNpdGl2ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHBhdHRlcm4gPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgbGV0IGNhc2VkID0gKHN0cikgPT4gY2FzZUluc2Vuc2l0aXZlID8gc3RyLnRvTG93ZXJDYXNlKCkgOiBzdHI7XG4gICAgICAgICAgICBsZXQgc3Vic3RyID0gdGhpcy5zdHJpbmcuc3Vic3RyKHRoaXMucG9zLCBwYXR0ZXJuLmxlbmd0aCk7XG4gICAgICAgICAgICBpZiAoY2FzZWQoc3Vic3RyKSA9PSBjYXNlZChwYXR0ZXJuKSkge1xuICAgICAgICAgICAgICAgIGlmIChjb25zdW1lICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3MgKz0gcGF0dGVybi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgbWF0Y2ggPSB0aGlzLnN0cmluZy5zbGljZSh0aGlzLnBvcykubWF0Y2gocGF0dGVybik7XG4gICAgICAgICAgICBpZiAobWF0Y2ggJiYgbWF0Y2guaW5kZXggPiAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgaWYgKG1hdGNoICYmIGNvbnN1bWUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgIHRoaXMucG9zICs9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGN1cnJlbnQgdG9rZW4uXG4gICAgKi9cbiAgICBjdXJyZW50KCkgeyByZXR1cm4gdGhpcy5zdHJpbmcuc2xpY2UodGhpcy5zdGFydCwgdGhpcy5wb3MpOyB9XG59XG5cbmZ1bmN0aW9uIGZ1bGxQYXJzZXIoc3BlYykge1xuICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IHNwZWMubmFtZSB8fCBcIlwiLFxuICAgICAgICB0b2tlbjogc3BlYy50b2tlbixcbiAgICAgICAgYmxhbmtMaW5lOiBzcGVjLmJsYW5rTGluZSB8fCAoKCkgPT4geyB9KSxcbiAgICAgICAgc3RhcnRTdGF0ZTogc3BlYy5zdGFydFN0YXRlIHx8ICgoKSA9PiB0cnVlKSxcbiAgICAgICAgY29weVN0YXRlOiBzcGVjLmNvcHlTdGF0ZSB8fCBkZWZhdWx0Q29weVN0YXRlLFxuICAgICAgICBpbmRlbnQ6IHNwZWMuaW5kZW50IHx8ICgoKSA9PiBudWxsKSxcbiAgICAgICAgbGFuZ3VhZ2VEYXRhOiBzcGVjLmxhbmd1YWdlRGF0YSB8fCB7fSxcbiAgICAgICAgdG9rZW5UYWJsZTogc3BlYy50b2tlblRhYmxlIHx8IG5vVG9rZW5zXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDb3B5U3RhdGUoc3RhdGUpIHtcbiAgICBpZiAodHlwZW9mIHN0YXRlICE9IFwib2JqZWN0XCIpXG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICBsZXQgbmV3U3RhdGUgPSB7fTtcbiAgICBmb3IgKGxldCBwcm9wIGluIHN0YXRlKSB7XG4gICAgICAgIGxldCB2YWwgPSBzdGF0ZVtwcm9wXTtcbiAgICAgICAgbmV3U3RhdGVbcHJvcF0gPSAodmFsIGluc3RhbmNlb2YgQXJyYXkgPyB2YWwuc2xpY2UoKSA6IHZhbCk7XG4gICAgfVxuICAgIHJldHVybiBuZXdTdGF0ZTtcbn1cbmNvbnN0IEluZGVudGVkRnJvbSA9IC8qQF9fUFVSRV9fKi9uZXcgV2Vha01hcCgpO1xuLyoqXG5BIFtsYW5ndWFnZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5MYW5ndWFnZSkgY2xhc3MgYmFzZWQgb24gYSBDb2RlTWlycm9yXG41LXN0eWxlIFtzdHJlYW1pbmcgcGFyc2VyXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLlN0cmVhbVBhcnNlcikuXG4qL1xuY2xhc3MgU3RyZWFtTGFuZ3VhZ2UgZXh0ZW5kcyBMYW5ndWFnZSB7XG4gICAgY29uc3RydWN0b3IocGFyc2VyKSB7XG4gICAgICAgIGxldCBkYXRhID0gZGVmaW5lTGFuZ3VhZ2VGYWNldChwYXJzZXIubGFuZ3VhZ2VEYXRhKTtcbiAgICAgICAgbGV0IHAgPSBmdWxsUGFyc2VyKHBhcnNlciksIHNlbGY7XG4gICAgICAgIGxldCBpbXBsID0gbmV3IGNsYXNzIGV4dGVuZHMgUGFyc2VyIHtcbiAgICAgICAgICAgIGNyZWF0ZVBhcnNlKGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUGFyc2Uoc2VsZiwgaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgc3VwZXIoZGF0YSwgaW1wbCwgW2luZGVudFNlcnZpY2Uub2YoKGN4LCBwb3MpID0+IHRoaXMuZ2V0SW5kZW50KGN4LCBwb3MpKV0sIHBhcnNlci5uYW1lKTtcbiAgICAgICAgdGhpcy50b3BOb2RlID0gZG9jSUQoZGF0YSk7XG4gICAgICAgIHNlbGYgPSB0aGlzO1xuICAgICAgICB0aGlzLnN0cmVhbVBhcnNlciA9IHA7XG4gICAgICAgIHRoaXMuc3RhdGVBZnRlciA9IG5ldyBOb2RlUHJvcCh7IHBlck5vZGU6IHRydWUgfSk7XG4gICAgICAgIHRoaXMudG9rZW5UYWJsZSA9IHBhcnNlci50b2tlblRhYmxlID8gbmV3IFRva2VuVGFibGUocC50b2tlblRhYmxlKSA6IGRlZmF1bHRUb2tlblRhYmxlO1xuICAgIH1cbiAgICAvKipcbiAgICBEZWZpbmUgYSBzdHJlYW0gbGFuZ3VhZ2UuXG4gICAgKi9cbiAgICBzdGF0aWMgZGVmaW5lKHNwZWMpIHsgcmV0dXJuIG5ldyBTdHJlYW1MYW5ndWFnZShzcGVjKTsgfVxuICAgIGdldEluZGVudChjeCwgcG9zKSB7XG4gICAgICAgIGxldCB0cmVlID0gc3ludGF4VHJlZShjeC5zdGF0ZSksIGF0ID0gdHJlZS5yZXNvbHZlKHBvcyk7XG4gICAgICAgIHdoaWxlIChhdCAmJiBhdC50eXBlICE9IHRoaXMudG9wTm9kZSlcbiAgICAgICAgICAgIGF0ID0gYXQucGFyZW50O1xuICAgICAgICBpZiAoIWF0KVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCBmcm9tID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgeyBvdmVycmlkZUluZGVudGF0aW9uIH0gPSBjeC5vcHRpb25zO1xuICAgICAgICBpZiAob3ZlcnJpZGVJbmRlbnRhdGlvbikge1xuICAgICAgICAgICAgZnJvbSA9IEluZGVudGVkRnJvbS5nZXQoY3guc3RhdGUpO1xuICAgICAgICAgICAgaWYgKGZyb20gIT0gbnVsbCAmJiBmcm9tIDwgcG9zIC0gMWU0KVxuICAgICAgICAgICAgICAgIGZyb20gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0YXJ0ID0gZmluZFN0YXRlKHRoaXMsIHRyZWUsIDAsIGF0LmZyb20sIGZyb20gIT09IG51bGwgJiYgZnJvbSAhPT0gdm9pZCAwID8gZnJvbSA6IHBvcyksIHN0YXRlUG9zLCBzdGF0ZTtcbiAgICAgICAgaWYgKHN0YXJ0KSB7XG4gICAgICAgICAgICBzdGF0ZSA9IHN0YXJ0LnN0YXRlO1xuICAgICAgICAgICAgc3RhdGVQb3MgPSBzdGFydC5wb3MgKyAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUgPSB0aGlzLnN0cmVhbVBhcnNlci5zdGFydFN0YXRlKGN4LnVuaXQpO1xuICAgICAgICAgICAgc3RhdGVQb3MgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3MgLSBzdGF0ZVBvcyA+IDEwMDAwIC8qIEMuTWF4SW5kZW50U2NhbkRpc3QgKi8pXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgd2hpbGUgKHN0YXRlUG9zIDwgcG9zKSB7XG4gICAgICAgICAgICBsZXQgbGluZSA9IGN4LnN0YXRlLmRvYy5saW5lQXQoc3RhdGVQb3MpLCBlbmQgPSBNYXRoLm1pbihwb3MsIGxpbmUudG8pO1xuICAgICAgICAgICAgaWYgKGxpbmUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbGV0IGluZGVudGF0aW9uID0gb3ZlcnJpZGVJbmRlbnRhdGlvbiA/IG92ZXJyaWRlSW5kZW50YXRpb24obGluZS5mcm9tKSA6IC0xO1xuICAgICAgICAgICAgICAgIGxldCBzdHJlYW0gPSBuZXcgU3RyaW5nU3RyZWFtKGxpbmUudGV4dCwgY3guc3RhdGUudGFiU2l6ZSwgY3gudW5pdCwgaW5kZW50YXRpb24gPCAwID8gdW5kZWZpbmVkIDogaW5kZW50YXRpb24pO1xuICAgICAgICAgICAgICAgIHdoaWxlIChzdHJlYW0ucG9zIDwgZW5kIC0gbGluZS5mcm9tKVxuICAgICAgICAgICAgICAgICAgICByZWFkVG9rZW4odGhpcy5zdHJlYW1QYXJzZXIudG9rZW4sIHN0cmVhbSwgc3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdHJlYW1QYXJzZXIuYmxhbmtMaW5lKHN0YXRlLCBjeC51bml0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbmQgPT0gcG9zKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgc3RhdGVQb3MgPSBsaW5lLnRvICsgMTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbGluZSA9IGN4LmxpbmVBdChwb3MpO1xuICAgICAgICBpZiAob3ZlcnJpZGVJbmRlbnRhdGlvbiAmJiBmcm9tID09IG51bGwpXG4gICAgICAgICAgICBJbmRlbnRlZEZyb20uc2V0KGN4LnN0YXRlLCBsaW5lLmZyb20pO1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW1QYXJzZXIuaW5kZW50KHN0YXRlLCAvXlxccyooLiopLy5leGVjKGxpbmUudGV4dClbMV0sIGN4KTtcbiAgICB9XG4gICAgZ2V0IGFsbG93c05lc3RpbmcoKSB7IHJldHVybiBmYWxzZTsgfVxufVxuZnVuY3Rpb24gZmluZFN0YXRlKGxhbmcsIHRyZWUsIG9mZiwgc3RhcnRQb3MsIGJlZm9yZSkge1xuICAgIGxldCBzdGF0ZSA9IG9mZiA+PSBzdGFydFBvcyAmJiBvZmYgKyB0cmVlLmxlbmd0aCA8PSBiZWZvcmUgJiYgdHJlZS5wcm9wKGxhbmcuc3RhdGVBZnRlcik7XG4gICAgaWYgKHN0YXRlKVxuICAgICAgICByZXR1cm4geyBzdGF0ZTogbGFuZy5zdHJlYW1QYXJzZXIuY29weVN0YXRlKHN0YXRlKSwgcG9zOiBvZmYgKyB0cmVlLmxlbmd0aCB9O1xuICAgIGZvciAobGV0IGkgPSB0cmVlLmNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGxldCBjaGlsZCA9IHRyZWUuY2hpbGRyZW5baV0sIHBvcyA9IG9mZiArIHRyZWUucG9zaXRpb25zW2ldO1xuICAgICAgICBsZXQgZm91bmQgPSBjaGlsZCBpbnN0YW5jZW9mIFRyZWUgJiYgcG9zIDwgYmVmb3JlICYmIGZpbmRTdGF0ZShsYW5nLCBjaGlsZCwgcG9zLCBzdGFydFBvcywgYmVmb3JlKTtcbiAgICAgICAgaWYgKGZvdW5kKVxuICAgICAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGN1dFRyZWUobGFuZywgdHJlZSwgZnJvbSwgdG8sIGluc2lkZSkge1xuICAgIGlmIChpbnNpZGUgJiYgZnJvbSA8PSAwICYmIHRvID49IHRyZWUubGVuZ3RoKVxuICAgICAgICByZXR1cm4gdHJlZTtcbiAgICBpZiAoIWluc2lkZSAmJiB0cmVlLnR5cGUgPT0gbGFuZy50b3BOb2RlKVxuICAgICAgICBpbnNpZGUgPSB0cnVlO1xuICAgIGZvciAobGV0IGkgPSB0cmVlLmNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGxldCBwb3MgPSB0cmVlLnBvc2l0aW9uc1tpXSwgY2hpbGQgPSB0cmVlLmNoaWxkcmVuW2ldLCBpbm5lcjtcbiAgICAgICAgaWYgKHBvcyA8IHRvICYmIGNoaWxkIGluc3RhbmNlb2YgVHJlZSkge1xuICAgICAgICAgICAgaWYgKCEoaW5uZXIgPSBjdXRUcmVlKGxhbmcsIGNoaWxkLCBmcm9tIC0gcG9zLCB0byAtIHBvcywgaW5zaWRlKSkpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICByZXR1cm4gIWluc2lkZSA/IGlubmVyXG4gICAgICAgICAgICAgICAgOiBuZXcgVHJlZSh0cmVlLnR5cGUsIHRyZWUuY2hpbGRyZW4uc2xpY2UoMCwgaSkuY29uY2F0KGlubmVyKSwgdHJlZS5wb3NpdGlvbnMuc2xpY2UoMCwgaSArIDEpLCBwb3MgKyBpbm5lci5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZmluZFN0YXJ0SW5GcmFnbWVudHMobGFuZywgZnJhZ21lbnRzLCBzdGFydFBvcywgZWRpdG9yU3RhdGUpIHtcbiAgICBmb3IgKGxldCBmIG9mIGZyYWdtZW50cykge1xuICAgICAgICBsZXQgZnJvbSA9IGYuZnJvbSArIChmLm9wZW5TdGFydCA/IDI1IDogMCksIHRvID0gZi50byAtIChmLm9wZW5FbmQgPyAyNSA6IDApO1xuICAgICAgICBsZXQgZm91bmQgPSBmcm9tIDw9IHN0YXJ0UG9zICYmIHRvID4gc3RhcnRQb3MgJiYgZmluZFN0YXRlKGxhbmcsIGYudHJlZSwgMCAtIGYub2Zmc2V0LCBzdGFydFBvcywgdG8pLCB0cmVlO1xuICAgICAgICBpZiAoZm91bmQgJiYgKHRyZWUgPSBjdXRUcmVlKGxhbmcsIGYudHJlZSwgc3RhcnRQb3MgKyBmLm9mZnNldCwgZm91bmQucG9zICsgZi5vZmZzZXQsIGZhbHNlKSkpXG4gICAgICAgICAgICByZXR1cm4geyBzdGF0ZTogZm91bmQuc3RhdGUsIHRyZWUgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgc3RhdGU6IGxhbmcuc3RyZWFtUGFyc2VyLnN0YXJ0U3RhdGUoZWRpdG9yU3RhdGUgPyBnZXRJbmRlbnRVbml0KGVkaXRvclN0YXRlKSA6IDQpLCB0cmVlOiBUcmVlLmVtcHR5IH07XG59XG5jbGFzcyBQYXJzZSB7XG4gICAgY29uc3RydWN0b3IobGFuZywgaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKSB7XG4gICAgICAgIHRoaXMubGFuZyA9IGxhbmc7XG4gICAgICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICAgICAgdGhpcy5mcmFnbWVudHMgPSBmcmFnbWVudHM7XG4gICAgICAgIHRoaXMucmFuZ2VzID0gcmFuZ2VzO1xuICAgICAgICB0aGlzLnN0b3BwZWRBdCA9IG51bGw7XG4gICAgICAgIHRoaXMuY2h1bmtzID0gW107XG4gICAgICAgIHRoaXMuY2h1bmtQb3MgPSBbXTtcbiAgICAgICAgdGhpcy5jaHVuayA9IFtdO1xuICAgICAgICB0aGlzLmNodW5rUmV1c2VkID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnJhbmdlSW5kZXggPSAwO1xuICAgICAgICB0aGlzLnRvID0gcmFuZ2VzW3Jhbmdlcy5sZW5ndGggLSAxXS50bztcbiAgICAgICAgbGV0IGNvbnRleHQgPSBQYXJzZUNvbnRleHQuZ2V0KCksIGZyb20gPSByYW5nZXNbMF0uZnJvbTtcbiAgICAgICAgbGV0IHsgc3RhdGUsIHRyZWUgfSA9IGZpbmRTdGFydEluRnJhZ21lbnRzKGxhbmcsIGZyYWdtZW50cywgZnJvbSwgY29udGV4dCA9PT0gbnVsbCB8fCBjb250ZXh0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb250ZXh0LnN0YXRlKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICB0aGlzLnBhcnNlZFBvcyA9IHRoaXMuY2h1bmtTdGFydCA9IGZyb20gKyB0cmVlLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmVlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmNodW5rcy5wdXNoKHRyZWUuY2hpbGRyZW5baV0pO1xuICAgICAgICAgICAgdGhpcy5jaHVua1Bvcy5wdXNoKHRyZWUucG9zaXRpb25zW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udGV4dCAmJiB0aGlzLnBhcnNlZFBvcyA8IGNvbnRleHQudmlld3BvcnQuZnJvbSAtIDEwMDAwMCAvKiBDLk1heERpc3RhbmNlQmVmb3JlVmlld3BvcnQgKi8pIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLmxhbmcuc3RyZWFtUGFyc2VyLnN0YXJ0U3RhdGUoZ2V0SW5kZW50VW5pdChjb250ZXh0LnN0YXRlKSk7XG4gICAgICAgICAgICBjb250ZXh0LnNraXBVbnRpbEluVmlldyh0aGlzLnBhcnNlZFBvcywgY29udGV4dC52aWV3cG9ydC5mcm9tKTtcbiAgICAgICAgICAgIHRoaXMucGFyc2VkUG9zID0gY29udGV4dC52aWV3cG9ydC5mcm9tO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW92ZVJhbmdlSW5kZXgoKTtcbiAgICB9XG4gICAgYWR2YW5jZSgpIHtcbiAgICAgICAgbGV0IGNvbnRleHQgPSBQYXJzZUNvbnRleHQuZ2V0KCk7XG4gICAgICAgIGxldCBwYXJzZUVuZCA9IHRoaXMuc3RvcHBlZEF0ID09IG51bGwgPyB0aGlzLnRvIDogTWF0aC5taW4odGhpcy50bywgdGhpcy5zdG9wcGVkQXQpO1xuICAgICAgICBsZXQgZW5kID0gTWF0aC5taW4ocGFyc2VFbmQsIHRoaXMuY2h1bmtTdGFydCArIDIwNDggLyogQy5DaHVua1NpemUgKi8pO1xuICAgICAgICBpZiAoY29udGV4dClcbiAgICAgICAgICAgIGVuZCA9IE1hdGgubWluKGVuZCwgY29udGV4dC52aWV3cG9ydC50byk7XG4gICAgICAgIHdoaWxlICh0aGlzLnBhcnNlZFBvcyA8IGVuZClcbiAgICAgICAgICAgIHRoaXMucGFyc2VMaW5lKGNvbnRleHQpO1xuICAgICAgICBpZiAodGhpcy5jaHVua1N0YXJ0IDwgdGhpcy5wYXJzZWRQb3MpXG4gICAgICAgICAgICB0aGlzLmZpbmlzaENodW5rKCk7XG4gICAgICAgIGlmICh0aGlzLnBhcnNlZFBvcyA+PSBwYXJzZUVuZClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaCgpO1xuICAgICAgICBpZiAoY29udGV4dCAmJiB0aGlzLnBhcnNlZFBvcyA+PSBjb250ZXh0LnZpZXdwb3J0LnRvKSB7XG4gICAgICAgICAgICBjb250ZXh0LnNraXBVbnRpbEluVmlldyh0aGlzLnBhcnNlZFBvcywgcGFyc2VFbmQpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHN0b3BBdChwb3MpIHtcbiAgICAgICAgdGhpcy5zdG9wcGVkQXQgPSBwb3M7XG4gICAgfVxuICAgIGxpbmVBZnRlcihwb3MpIHtcbiAgICAgICAgbGV0IGNodW5rID0gdGhpcy5pbnB1dC5jaHVuayhwb3MpO1xuICAgICAgICBpZiAoIXRoaXMuaW5wdXQubGluZUNodW5rcykge1xuICAgICAgICAgICAgbGV0IGVvbCA9IGNodW5rLmluZGV4T2YoXCJcXG5cIik7XG4gICAgICAgICAgICBpZiAoZW9sID4gLTEpXG4gICAgICAgICAgICAgICAgY2h1bmsgPSBjaHVuay5zbGljZSgwLCBlb2wpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNodW5rID09IFwiXFxuXCIpIHtcbiAgICAgICAgICAgIGNodW5rID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcG9zICsgY2h1bmsubGVuZ3RoIDw9IHRoaXMudG8gPyBjaHVuayA6IGNodW5rLnNsaWNlKDAsIHRoaXMudG8gLSBwb3MpO1xuICAgIH1cbiAgICBuZXh0TGluZSgpIHtcbiAgICAgICAgbGV0IGZyb20gPSB0aGlzLnBhcnNlZFBvcywgbGluZSA9IHRoaXMubGluZUFmdGVyKGZyb20pLCBlbmQgPSBmcm9tICsgbGluZS5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gdGhpcy5yYW5nZUluZGV4OzspIHtcbiAgICAgICAgICAgIGxldCByYW5nZUVuZCA9IHRoaXMucmFuZ2VzW2luZGV4XS50bztcbiAgICAgICAgICAgIGlmIChyYW5nZUVuZCA+PSBlbmQpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBsaW5lID0gbGluZS5zbGljZSgwLCByYW5nZUVuZCAtIChlbmQgLSBsaW5lLmxlbmd0aCkpO1xuICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgIGlmIChpbmRleCA9PSB0aGlzLnJhbmdlcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBsZXQgcmFuZ2VTdGFydCA9IHRoaXMucmFuZ2VzW2luZGV4XS5mcm9tO1xuICAgICAgICAgICAgbGV0IGFmdGVyID0gdGhpcy5saW5lQWZ0ZXIocmFuZ2VTdGFydCk7XG4gICAgICAgICAgICBsaW5lICs9IGFmdGVyO1xuICAgICAgICAgICAgZW5kID0gcmFuZ2VTdGFydCArIGFmdGVyLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBsaW5lLCBlbmQgfTtcbiAgICB9XG4gICAgc2tpcEdhcHNUbyhwb3MsIG9mZnNldCwgc2lkZSkge1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgZW5kID0gdGhpcy5yYW5nZXNbdGhpcy5yYW5nZUluZGV4XS50bywgb2ZmUG9zID0gcG9zICsgb2Zmc2V0O1xuICAgICAgICAgICAgaWYgKHNpZGUgPiAwID8gZW5kID4gb2ZmUG9zIDogZW5kID49IG9mZlBvcylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGxldCBzdGFydCA9IHRoaXMucmFuZ2VzWysrdGhpcy5yYW5nZUluZGV4XS5mcm9tO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IHN0YXJ0IC0gZW5kO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuICAgIG1vdmVSYW5nZUluZGV4KCkge1xuICAgICAgICB3aGlsZSAodGhpcy5yYW5nZXNbdGhpcy5yYW5nZUluZGV4XS50byA8IHRoaXMucGFyc2VkUG9zKVxuICAgICAgICAgICAgdGhpcy5yYW5nZUluZGV4Kys7XG4gICAgfVxuICAgIGVtaXRUb2tlbihpZCwgZnJvbSwgdG8sIHNpemUsIG9mZnNldCkge1xuICAgICAgICBpZiAodGhpcy5yYW5nZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5za2lwR2Fwc1RvKGZyb20sIG9mZnNldCwgMSk7XG4gICAgICAgICAgICBmcm9tICs9IG9mZnNldDtcbiAgICAgICAgICAgIGxldCBsZW4wID0gdGhpcy5jaHVuay5sZW5ndGg7XG4gICAgICAgICAgICBvZmZzZXQgPSB0aGlzLnNraXBHYXBzVG8odG8sIG9mZnNldCwgLTEpO1xuICAgICAgICAgICAgdG8gKz0gb2Zmc2V0O1xuICAgICAgICAgICAgc2l6ZSArPSB0aGlzLmNodW5rLmxlbmd0aCAtIGxlbjA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaHVuay5wdXNoKGlkLCBmcm9tLCB0bywgc2l6ZSk7XG4gICAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuICAgIHBhcnNlTGluZShjb250ZXh0KSB7XG4gICAgICAgIGxldCB7IGxpbmUsIGVuZCB9ID0gdGhpcy5uZXh0TGluZSgpLCBvZmZzZXQgPSAwLCB7IHN0cmVhbVBhcnNlciB9ID0gdGhpcy5sYW5nO1xuICAgICAgICBsZXQgc3RyZWFtID0gbmV3IFN0cmluZ1N0cmVhbShsaW5lLCBjb250ZXh0ID8gY29udGV4dC5zdGF0ZS50YWJTaXplIDogNCwgY29udGV4dCA/IGdldEluZGVudFVuaXQoY29udGV4dC5zdGF0ZSkgOiAyKTtcbiAgICAgICAgaWYgKHN0cmVhbS5lb2woKSkge1xuICAgICAgICAgICAgc3RyZWFtUGFyc2VyLmJsYW5rTGluZSh0aGlzLnN0YXRlLCBzdHJlYW0uaW5kZW50VW5pdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB3aGlsZSAoIXN0cmVhbS5lb2woKSkge1xuICAgICAgICAgICAgICAgIGxldCB0b2tlbiA9IHJlYWRUb2tlbihzdHJlYW1QYXJzZXIudG9rZW4sIHN0cmVhbSwgdGhpcy5zdGF0ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuKVxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSB0aGlzLmVtaXRUb2tlbih0aGlzLmxhbmcudG9rZW5UYWJsZS5yZXNvbHZlKHRva2VuKSwgdGhpcy5wYXJzZWRQb3MgKyBzdHJlYW0uc3RhcnQsIHRoaXMucGFyc2VkUG9zICsgc3RyZWFtLnBvcywgNCwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBpZiAoc3RyZWFtLnN0YXJ0ID4gMTAwMDAgLyogQy5NYXhMaW5lTGVuZ3RoICovKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhcnNlZFBvcyA9IGVuZDtcbiAgICAgICAgdGhpcy5tb3ZlUmFuZ2VJbmRleCgpO1xuICAgICAgICBpZiAodGhpcy5wYXJzZWRQb3MgPCB0aGlzLnRvKVxuICAgICAgICAgICAgdGhpcy5wYXJzZWRQb3MrKztcbiAgICB9XG4gICAgZmluaXNoQ2h1bmsoKSB7XG4gICAgICAgIGxldCB0cmVlID0gVHJlZS5idWlsZCh7XG4gICAgICAgICAgICBidWZmZXI6IHRoaXMuY2h1bmssXG4gICAgICAgICAgICBzdGFydDogdGhpcy5jaHVua1N0YXJ0LFxuICAgICAgICAgICAgbGVuZ3RoOiB0aGlzLnBhcnNlZFBvcyAtIHRoaXMuY2h1bmtTdGFydCxcbiAgICAgICAgICAgIG5vZGVTZXQsXG4gICAgICAgICAgICB0b3BJRDogMCxcbiAgICAgICAgICAgIG1heEJ1ZmZlckxlbmd0aDogMjA0OCAvKiBDLkNodW5rU2l6ZSAqLyxcbiAgICAgICAgICAgIHJldXNlZDogdGhpcy5jaHVua1JldXNlZFxuICAgICAgICB9KTtcbiAgICAgICAgdHJlZSA9IG5ldyBUcmVlKHRyZWUudHlwZSwgdHJlZS5jaGlsZHJlbiwgdHJlZS5wb3NpdGlvbnMsIHRyZWUubGVuZ3RoLCBbW3RoaXMubGFuZy5zdGF0ZUFmdGVyLCB0aGlzLmxhbmcuc3RyZWFtUGFyc2VyLmNvcHlTdGF0ZSh0aGlzLnN0YXRlKV1dKTtcbiAgICAgICAgdGhpcy5jaHVua3MucHVzaCh0cmVlKTtcbiAgICAgICAgdGhpcy5jaHVua1Bvcy5wdXNoKHRoaXMuY2h1bmtTdGFydCAtIHRoaXMucmFuZ2VzWzBdLmZyb20pO1xuICAgICAgICB0aGlzLmNodW5rID0gW107XG4gICAgICAgIHRoaXMuY2h1bmtSZXVzZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuY2h1bmtTdGFydCA9IHRoaXMucGFyc2VkUG9zO1xuICAgIH1cbiAgICBmaW5pc2goKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHJlZSh0aGlzLmxhbmcudG9wTm9kZSwgdGhpcy5jaHVua3MsIHRoaXMuY2h1bmtQb3MsIHRoaXMucGFyc2VkUG9zIC0gdGhpcy5yYW5nZXNbMF0uZnJvbSkuYmFsYW5jZSgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlYWRUb2tlbih0b2tlbiwgc3RyZWFtLCBzdGF0ZSkge1xuICAgIHN0cmVhbS5zdGFydCA9IHN0cmVhbS5wb3M7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSB0b2tlbihzdHJlYW0sIHN0YXRlKTtcbiAgICAgICAgaWYgKHN0cmVhbS5wb3MgPiBzdHJlYW0uc3RhcnQpXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdHJlYW0gcGFyc2VyIGZhaWxlZCB0byBhZHZhbmNlIHN0cmVhbS5cIik7XG59XG5jb25zdCBub1Rva2VucyA9IC8qQF9fUFVSRV9fKi9PYmplY3QuY3JlYXRlKG51bGwpO1xuY29uc3QgdHlwZUFycmF5ID0gW05vZGVUeXBlLm5vbmVdO1xuY29uc3Qgbm9kZVNldCA9IC8qQF9fUFVSRV9fKi9uZXcgTm9kZVNldCh0eXBlQXJyYXkpO1xuY29uc3Qgd2FybmVkID0gW107XG4vLyBDYWNoZSBvZiBub2RlIHR5cGVzIGJ5IG5hbWUgYW5kIHRhZ3NcbmNvbnN0IGJ5VGFnID0gLypAX19QVVJFX18qL09iamVjdC5jcmVhdGUobnVsbCk7XG5jb25zdCBkZWZhdWx0VGFibGUgPSAvKkBfX1BVUkVfXyovT2JqZWN0LmNyZWF0ZShudWxsKTtcbmZvciAobGV0IFtsZWdhY3lOYW1lLCBuYW1lXSBvZiBbXG4gICAgW1widmFyaWFibGVcIiwgXCJ2YXJpYWJsZU5hbWVcIl0sXG4gICAgW1widmFyaWFibGUtMlwiLCBcInZhcmlhYmxlTmFtZS5zcGVjaWFsXCJdLFxuICAgIFtcInN0cmluZy0yXCIsIFwic3RyaW5nLnNwZWNpYWxcIl0sXG4gICAgW1wiZGVmXCIsIFwidmFyaWFibGVOYW1lLmRlZmluaXRpb25cIl0sXG4gICAgW1widGFnXCIsIFwidGFnTmFtZVwiXSxcbiAgICBbXCJhdHRyaWJ1dGVcIiwgXCJhdHRyaWJ1dGVOYW1lXCJdLFxuICAgIFtcInR5cGVcIiwgXCJ0eXBlTmFtZVwiXSxcbiAgICBbXCJidWlsdGluXCIsIFwidmFyaWFibGVOYW1lLnN0YW5kYXJkXCJdLFxuICAgIFtcInF1YWxpZmllclwiLCBcIm1vZGlmaWVyXCJdLFxuICAgIFtcImVycm9yXCIsIFwiaW52YWxpZFwiXSxcbiAgICBbXCJoZWFkZXJcIiwgXCJoZWFkaW5nXCJdLFxuICAgIFtcInByb3BlcnR5XCIsIFwicHJvcGVydHlOYW1lXCJdXG5dKVxuICAgIGRlZmF1bHRUYWJsZVtsZWdhY3lOYW1lXSA9IC8qQF9fUFVSRV9fKi9jcmVhdGVUb2tlblR5cGUobm9Ub2tlbnMsIG5hbWUpO1xuY2xhc3MgVG9rZW5UYWJsZSB7XG4gICAgY29uc3RydWN0b3IoZXh0cmEpIHtcbiAgICAgICAgdGhpcy5leHRyYSA9IGV4dHJhO1xuICAgICAgICB0aGlzLnRhYmxlID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCBkZWZhdWx0VGFibGUpO1xuICAgIH1cbiAgICByZXNvbHZlKHRhZykge1xuICAgICAgICByZXR1cm4gIXRhZyA/IDAgOiB0aGlzLnRhYmxlW3RhZ10gfHwgKHRoaXMudGFibGVbdGFnXSA9IGNyZWF0ZVRva2VuVHlwZSh0aGlzLmV4dHJhLCB0YWcpKTtcbiAgICB9XG59XG5jb25zdCBkZWZhdWx0VG9rZW5UYWJsZSA9IC8qQF9fUFVSRV9fKi9uZXcgVG9rZW5UYWJsZShub1Rva2Vucyk7XG5mdW5jdGlvbiB3YXJuRm9yUGFydChwYXJ0LCBtc2cpIHtcbiAgICBpZiAod2FybmVkLmluZGV4T2YocGFydCkgPiAtMSlcbiAgICAgICAgcmV0dXJuO1xuICAgIHdhcm5lZC5wdXNoKHBhcnQpO1xuICAgIGNvbnNvbGUud2Fybihtc2cpO1xufVxuZnVuY3Rpb24gY3JlYXRlVG9rZW5UeXBlKGV4dHJhLCB0YWdTdHIpIHtcbiAgICBsZXQgdGFncyQxID0gW107XG4gICAgZm9yIChsZXQgbmFtZSBvZiB0YWdTdHIuc3BsaXQoXCIgXCIpKSB7XG4gICAgICAgIGxldCBmb3VuZCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBwYXJ0IG9mIG5hbWUuc3BsaXQoXCIuXCIpKSB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSAoZXh0cmFbcGFydF0gfHwgdGFnc1twYXJ0XSk7XG4gICAgICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICAgICAgd2FybkZvclBhcnQocGFydCwgYFVua25vd24gaGlnaGxpZ2h0aW5nIHRhZyAke3BhcnR9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFmb3VuZC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHdhcm5Gb3JQYXJ0KHBhcnQsIGBNb2RpZmllciAke3BhcnR9IHVzZWQgYXQgc3RhcnQgb2YgdGFnYCk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IGZvdW5kLm1hcCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoZm91bmQubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICB3YXJuRm9yUGFydChwYXJ0LCBgVGFnICR7cGFydH0gdXNlZCBhcyBtb2RpZmllcmApO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW3ZhbHVlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCB0YWcgb2YgZm91bmQpXG4gICAgICAgICAgICB0YWdzJDEucHVzaCh0YWcpO1xuICAgIH1cbiAgICBpZiAoIXRhZ3MkMS5sZW5ndGgpXG4gICAgICAgIHJldHVybiAwO1xuICAgIGxldCBuYW1lID0gdGFnU3RyLnJlcGxhY2UoLyAvZywgXCJfXCIpLCBrZXkgPSBuYW1lICsgXCIgXCIgKyB0YWdzJDEubWFwKHQgPT4gdC5pZCk7XG4gICAgbGV0IGtub3duID0gYnlUYWdba2V5XTtcbiAgICBpZiAoa25vd24pXG4gICAgICAgIHJldHVybiBrbm93bi5pZDtcbiAgICBsZXQgdHlwZSA9IGJ5VGFnW2tleV0gPSBOb2RlVHlwZS5kZWZpbmUoe1xuICAgICAgICBpZDogdHlwZUFycmF5Lmxlbmd0aCxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgcHJvcHM6IFtzdHlsZVRhZ3MoeyBbbmFtZV06IHRhZ3MkMSB9KV1cbiAgICB9KTtcbiAgICB0eXBlQXJyYXkucHVzaCh0eXBlKTtcbiAgICByZXR1cm4gdHlwZS5pZDtcbn1cbmZ1bmN0aW9uIGRvY0lEKGRhdGEpIHtcbiAgICBsZXQgdHlwZSA9IE5vZGVUeXBlLmRlZmluZSh7IGlkOiB0eXBlQXJyYXkubGVuZ3RoLCBuYW1lOiBcIkRvY3VtZW50XCIsIHByb3BzOiBbbGFuZ3VhZ2VEYXRhUHJvcC5hZGQoKCkgPT4gZGF0YSldLCB0b3A6IHRydWUgfSk7XG4gICAgdHlwZUFycmF5LnB1c2godHlwZSk7XG4gICAgcmV0dXJuIHR5cGU7XG59XG5cbmV4cG9ydCB7IERvY0lucHV0LCBIaWdobGlnaHRTdHlsZSwgSW5kZW50Q29udGV4dCwgTFJMYW5ndWFnZSwgTGFuZ3VhZ2UsIExhbmd1YWdlRGVzY3JpcHRpb24sIExhbmd1YWdlU3VwcG9ydCwgUGFyc2VDb250ZXh0LCBTdHJlYW1MYW5ndWFnZSwgU3RyaW5nU3RyZWFtLCBUcmVlSW5kZW50Q29udGV4dCwgYnJhY2tldE1hdGNoaW5nLCBicmFja2V0TWF0Y2hpbmdIYW5kbGUsIGNvZGVGb2xkaW5nLCBjb250aW51ZWRJbmRlbnQsIGRlZmF1bHRIaWdobGlnaHRTdHlsZSwgZGVmaW5lTGFuZ3VhZ2VGYWNldCwgZGVsaW1pdGVkSW5kZW50LCBlbnN1cmVTeW50YXhUcmVlLCBmbGF0SW5kZW50LCBmb2xkQWxsLCBmb2xkQ29kZSwgZm9sZEVmZmVjdCwgZm9sZEd1dHRlciwgZm9sZEluc2lkZSwgZm9sZEtleW1hcCwgZm9sZE5vZGVQcm9wLCBmb2xkU2VydmljZSwgZm9sZFN0YXRlLCBmb2xkYWJsZSwgZm9sZGVkUmFuZ2VzLCBmb3JjZVBhcnNpbmcsIGdldEluZGVudFVuaXQsIGdldEluZGVudGF0aW9uLCBoaWdobGlnaHRpbmdGb3IsIGluZGVudE5vZGVQcm9wLCBpbmRlbnRPbklucHV0LCBpbmRlbnRSYW5nZSwgaW5kZW50U2VydmljZSwgaW5kZW50U3RyaW5nLCBpbmRlbnRVbml0LCBsYW5ndWFnZSwgbGFuZ3VhZ2VEYXRhUHJvcCwgbWF0Y2hCcmFja2V0cywgc3VibGFuZ3VhZ2VQcm9wLCBzeW50YXhIaWdobGlnaHRpbmcsIHN5bnRheFBhcnNlclJ1bm5pbmcsIHN5bnRheFRyZWUsIHN5bnRheFRyZWVBdmFpbGFibGUsIHRvZ2dsZUZvbGQsIHVuZm9sZEFsbCwgdW5mb2xkQ29kZSwgdW5mb2xkRWZmZWN0IH07XG4iXSwibmFtZXMiOlsiTm9kZVByb3AiLCJJdGVyTW9kZSIsIlRyZWUiLCJUcmVlRnJhZ21lbnQiLCJQYXJzZXIiLCJOb2RlVHlwZSIsIk5vZGVTZXQiLCJTdGF0ZUVmZmVjdCIsIlN0YXRlRmllbGQiLCJGYWNldCIsIkVkaXRvclN0YXRlIiwiY291bnRDb2x1bW4iLCJjb21iaW5lQ29uZmlnIiwiUmFuZ2VTZXQiLCJSYW5nZVNldEJ1aWxkZXIiLCJQcmVjIiwiVmlld1BsdWdpbiIsImxvZ0V4Y2VwdGlvbiIsIkVkaXRvclZpZXciLCJEZWNvcmF0aW9uIiwiV2lkZ2V0VHlwZSIsImd1dHRlciIsIkd1dHRlck1hcmtlciIsInRhZ3MiLCJ0YWdIaWdobGlnaHRlciIsImhpZ2hsaWdodFRyZWUiLCJzdHlsZVRhZ3MiLCJTdHlsZU1vZHVsZSIsIl9hIiwibGFuZ3VhZ2VEYXRhUHJvcCIsImRlZmluZUxhbmd1YWdlRmFjZXQiLCJiYXNlRGF0YSIsImRlZmluZSIsImNvbWJpbmUiLCJ2YWx1ZXMiLCJjb25jYXQiLCJ1bmRlZmluZWQiLCJzdWJsYW5ndWFnZVByb3AiLCJMYW5ndWFnZSIsImNvbnN0cnVjdG9yIiwiZGF0YSIsInBhcnNlciIsImV4dHJhRXh0ZW5zaW9ucyIsIm5hbWUiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZ2V0Iiwic3ludGF4VHJlZSIsImV4dGVuc2lvbiIsImxhbmd1YWdlIiwib2YiLCJsYW5ndWFnZURhdGEiLCJzdGF0ZSIsInBvcyIsInNpZGUiLCJ0b3AiLCJ0b3BOb2RlQXQiLCJ0eXBlIiwicHJvcCIsImJhc2UiLCJmYWNldCIsInN1YiIsImlubmVyTm9kZSIsInJlc29sdmUiLCJmcm9tIiwic3VibGFuZyIsInRlc3QiLCJpc0FjdGl2ZUF0IiwiZmluZFJlZ2lvbnMiLCJsYW5nIiwidG8iLCJkb2MiLCJsZW5ndGgiLCJhbGxvd3NOZXN0aW5nIiwicmVzdWx0IiwiZXhwbG9yZSIsInRyZWUiLCJwdXNoIiwibW91bnQiLCJtb3VudGVkIiwib3ZlcmxheSIsInIiLCJzaXplIiwiaSIsImNoaWxkcmVuIiwiY2giLCJwb3NpdGlvbnMiLCJzZXRTdGF0ZSIsInRvcExhbmciLCJ0b3BOb2RlIiwibm9kZSIsImVudGVyIiwiRXhjbHVkZUJ1ZmZlcnMiLCJpc1RvcCIsIkxSTGFuZ3VhZ2UiLCJzcGVjIiwiY29uZmlndXJlIiwicHJvcHMiLCJhZGQiLCJvcHRpb25zIiwiaGFzV3JhcHBlcnMiLCJmaWVsZCIsImVtcHR5IiwiZW5zdXJlU3ludGF4VHJlZSIsInVwdG8iLCJ0aW1lb3V0IiwicGFyc2UiLCJjb250ZXh0Iiwib2xkVmllcG9ydCIsInZpZXdwb3J0IiwidXBkYXRlVmlld3BvcnQiLCJpc0RvbmUiLCJ3b3JrIiwic3ludGF4VHJlZUF2YWlsYWJsZSIsImZvcmNlUGFyc2luZyIsInZpZXciLCJzdWNjZXNzIiwiZGlzcGF0Y2giLCJzeW50YXhQYXJzZXJSdW5uaW5nIiwicGx1Z2luIiwicGFyc2VXb3JrZXIiLCJpc1dvcmtpbmciLCJEb2NJbnB1dCIsImN1cnNvclBvcyIsInN0cmluZyIsImN1cnNvciIsIml0ZXIiLCJzeW5jVG8iLCJuZXh0IiwidmFsdWUiLCJjaHVuayIsImxpbmVDaHVua3MiLCJyZWFkIiwic3RyaW5nU3RhcnQiLCJzbGljZVN0cmluZyIsInNsaWNlIiwiY3VycmVudENvbnRleHQiLCJQYXJzZUNvbnRleHQiLCJmcmFnbWVudHMiLCJ0cmVlTGVuIiwic2tpcHBlZCIsInNjaGVkdWxlT24iLCJ0ZW1wU2tpcHBlZCIsImNyZWF0ZSIsInN0YXJ0UGFyc2UiLCJ1bnRpbCIsInRha2VUcmVlIiwid2l0aENvbnRleHQiLCJlbmRUaW1lIiwiRGF0ZSIsIm5vdyIsInN0b3BwZWRBdCIsInN0b3BBdCIsImRvbmUiLCJhZHZhbmNlIiwid2l0aG91dFRlbXBTa2lwcGVkIiwiYWRkVHJlZSIsInBhcnNlZFBvcyIsImYiLCJwcmV2IiwicG9wIiwiY3V0RnJhZ21lbnRzIiwiY2hhbmdlcyIsIm5ld1N0YXRlIiwicmFuZ2VzIiwiaXRlckNoYW5nZWRSYW5nZXMiLCJmcm9tQSIsInRvQSIsImZyb21CIiwidG9CIiwiYXBwbHlDaGFuZ2VzIiwibWFwUG9zIiwic3RhcnRMZW4iLCJzcGxpY2UiLCJyZXNldCIsInNraXBVbnRpbEluVmlldyIsImdldFNraXBwaW5nUGFyc2VyIiwiY3JlYXRlUGFyc2UiLCJpbnB1dCIsImN4IiwiUHJvbWlzZSIsImFsbCIsIm5vbmUiLCJNYXRoIiwibWluIiwiZnJhZ3MiLCJMYW5ndWFnZVN0YXRlIiwiYXBwbHkiLCJ0ciIsImRvY0NoYW5nZWQiLCJuZXdDeCIsInN0YXJ0U3RhdGUiLCJtYXgiLCJpbml0IiwidnBUbyIsInBhcnNlU3RhdGUiLCJ1cGRhdGUiLCJlIiwiZWZmZWN0cyIsImlzIiwicmVxdWVzdElkbGUiLCJjYWxsYmFjayIsInNldFRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJyZXF1ZXN0SWRsZUNhbGxiYWNrIiwiaWRsZSIsImNhbmNlbElkbGVDYWxsYmFjayIsImlzSW5wdXRQZW5kaW5nIiwibmF2aWdhdG9yIiwic2NoZWR1bGluZyIsImZyb21DbGFzcyIsIlBhcnNlV29ya2VyIiwid29ya2luZyIsIndvcmtTY2hlZHVsZWQiLCJjaHVua0VuZCIsImNodW5rQnVkZ2V0IiwiYmluZCIsInNjaGVkdWxlV29yayIsInNlbGVjdGlvblNldCIsImhhc0ZvY3VzIiwiY2hlY2tBc3luY1NjaGVkdWxlIiwiZGVhZGxpbmUiLCJ0aW1lUmVtYWluaW5nIiwidmlld3BvcnRGaXJzdCIsInRoZW4iLCJjYXRjaCIsImVyciIsImRlc3Ryb3kiLCJldmVudEhhbmRsZXJzIiwiZm9jdXMiLCJsYW5ndWFnZXMiLCJlbmFibGVzIiwiY29udGVudEF0dHJpYnV0ZXMiLCJjb21wdXRlIiwiTGFuZ3VhZ2VTdXBwb3J0Iiwic3VwcG9ydCIsIkxhbmd1YWdlRGVzY3JpcHRpb24iLCJhbGlhcyIsImV4dGVuc2lvbnMiLCJmaWxlbmFtZSIsImxvYWRGdW5jIiwibG9hZGluZyIsImxvYWQiLCJSYW5nZUVycm9yIiwibWFwIiwicyIsInRvTG93ZXJDYXNlIiwibWF0Y2hGaWxlbmFtZSIsImRlc2NzIiwiZCIsImV4dCIsImV4ZWMiLCJpbmRleE9mIiwibWF0Y2hMYW5ndWFnZU5hbWUiLCJmdXp6eSIsInNvbWUiLCJhIiwiZm91bmQiLCJpbmRlbnRTZXJ2aWNlIiwiaW5kZW50VW5pdCIsInVuaXQiLCJBcnJheSIsIkVycm9yIiwiSlNPTiIsInN0cmluZ2lmeSIsImdldEluZGVudFVuaXQiLCJjaGFyQ29kZUF0IiwidGFiU2l6ZSIsImluZGVudFN0cmluZyIsImNvbHMiLCJ0cyIsImdldEluZGVudGF0aW9uIiwiSW5kZW50Q29udGV4dCIsInNlcnZpY2UiLCJzeW50YXhJbmRlbnRhdGlvbiIsImluZGVudFJhbmdlIiwidXBkYXRlZCIsIm92ZXJyaWRlSW5kZW50YXRpb24iLCJzdGFydCIsImxpbmUiLCJsaW5lQXQiLCJpbmRlbnQiLCJ0ZXh0IiwiY3VyIiwibm9ybSIsImluc2VydCIsImJpYXMiLCJzaW11bGF0ZUJyZWFrIiwic2ltdWxhdGVEb3VibGVCcmVhayIsInRleHRBZnRlclBvcyIsImNvbHVtbiIsIm92ZXJyaWRlIiwic2VhcmNoIiwibGluZUluZGVudCIsIm92ZXJyaWRlbiIsInNpbXVsYXRlZEJyZWFrIiwiaW5kZW50Tm9kZVByb3AiLCJhc3QiLCJzdGFjayIsInJlc29sdmVTdGFjayIsImlubmVyIiwiZW50ZXJVbmZpbmlzaGVkTm9kZXNCZWZvcmUiLCJwYXJlbnQiLCJpbmRlbnRGb3IiLCJzdHJhdGVneSIsImluZGVudFN0cmF0ZWd5IiwiVHJlZUluZGVudENvbnRleHQiLCJpZ25vcmVDbG9zZWQiLCJmaXJzdCIsImZpcnN0Q2hpbGQiLCJjbG9zZSIsImNsb3NlZEJ5IiwibGFzdCIsImxhc3RDaGlsZCIsImNsb3NlZCIsImRlbGltaXRlZFN0cmF0ZWd5IiwidG9wSW5kZW50IiwidGV4dEFmdGVyIiwiYmFzZUluZGVudCIsImJhc2VJbmRlbnRGb3IiLCJhdEJyZWFrIiwiaXNQYXJlbnQiLCJjb250aW51ZSIsImJyYWNrZXRlZEFsaWduZWQiLCJvcGVuVG9rZW4iLCJjaGlsZEFmdGVyIiwic2ltIiwib3BlbkxpbmUiLCJsaW5lRW5kIiwiaXNTa2lwcGVkIiwiZGVsaW1pdGVkSW5kZW50IiwiY2xvc2luZyIsImFsaWduIiwidW5pdHMiLCJjbG9zZWRBdCIsImFmdGVyIiwic3BhY2UiLCJtYXRjaCIsImFsaWduZWQiLCJmbGF0SW5kZW50IiwiY29udGludWVkSW5kZW50IiwiZXhjZXB0IiwibWF0Y2hFeGNlcHQiLCJEb250SW5kZW50QmV5b25kIiwiaW5kZW50T25JbnB1dCIsInRyYW5zYWN0aW9uRmlsdGVyIiwiaXNVc2VyRXZlbnQiLCJydWxlcyIsImxhbmd1YWdlRGF0YUF0Iiwic2VsZWN0aW9uIiwibWFpbiIsImhlYWQiLCJuZXdEb2MiLCJuZXdTZWxlY3Rpb24iLCJsaW5lU3RhcnQiLCJzZXF1ZW50aWFsIiwiZm9sZFNlcnZpY2UiLCJmb2xkTm9kZVByb3AiLCJmb2xkSW5zaWRlIiwiaXNFcnJvciIsInN5bnRheEZvbGRpbmciLCJlbmQiLCJpc1VuZmluaXNoZWQiLCJmb2xkYWJsZSIsIm1hcFJhbmdlIiwicmFuZ2UiLCJtYXBwaW5nIiwiZm9sZEVmZmVjdCIsInVuZm9sZEVmZmVjdCIsInNlbGVjdGVkTGluZXMiLCJsaW5lcyIsImwiLCJsaW5lQmxvY2tBdCIsImZvbGRTdGF0ZSIsImZvbGRlZCIsImZvbGRFeGlzdHMiLCJwcmVwYXJlUGxhY2Vob2xkZXIiLCJmb2xkQ29uZmlnIiwid2lkZ2V0IiwiZm9sZFdpZGdldCIsInJlcGxhY2UiLCJQcmVwYXJlZEZvbGRXaWRnZXQiLCJmaWx0ZXIiLCJmaWx0ZXJGcm9tIiwiZmlsdGVyVG8iLCJvblNlbGVjdGlvbiIsImJldHdlZW4iLCJiIiwicHJvdmlkZSIsImRlY29yYXRpb25zIiwidG9KU09OIiwiZnJvbUpTT04iLCJpc0FycmF5Iiwic2V0IiwiZm9sZGVkUmFuZ2VzIiwiZmluZEZvbGQiLCJtYXliZUVuYWJsZSIsIm90aGVyIiwiYXBwZW5kQ29uZmlnIiwiY29kZUZvbGRpbmciLCJmb2xkQ29kZSIsImFubm91bmNlRm9sZCIsInVuZm9sZENvZGUiLCJmb2xkIiwibGluZUZyb20iLCJudW1iZXIiLCJsaW5lVG8iLCJhbm5vdW5jZSIsInBocmFzZSIsImZvbGRBbGwiLCJ1bmZvbGRBbGwiLCJmb2xkYWJsZUNvbnRhaW5lciIsImxpbmVCbG9jayIsImZvbGRhYmxlUmVnaW9uIiwidG9nZ2xlRm9sZCIsImZvbGRSYW5nZSIsImZvbGRLZXltYXAiLCJrZXkiLCJtYWMiLCJydW4iLCJkZWZhdWx0Q29uZmlnIiwicGxhY2Vob2xkZXJET00iLCJwbGFjZWhvbGRlclRleHQiLCJjb25maWciLCJiYXNlVGhlbWUkMSIsIndpZGdldFRvRE9NIiwicHJlcGFyZWQiLCJjb25mIiwib25jbGljayIsImV2ZW50IiwicG9zQXRET00iLCJ0YXJnZXQiLCJwcmV2ZW50RGVmYXVsdCIsImVsZW1lbnQiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJ0ZXh0Q29udGVudCIsInNldEF0dHJpYnV0ZSIsInRpdGxlIiwiY2xhc3NOYW1lIiwidG9ET00iLCJlcSIsImZvbGRHdXR0ZXJEZWZhdWx0cyIsIm9wZW5UZXh0IiwiY2xvc2VkVGV4dCIsIm1hcmtlckRPTSIsImRvbUV2ZW50SGFuZGxlcnMiLCJmb2xkaW5nQ2hhbmdlZCIsIkZvbGRNYXJrZXIiLCJvcGVuIiwic3BhbiIsImZvbGRHdXR0ZXIiLCJmdWxsQ29uZmlnIiwiYXNzaWduIiwiY2FuRm9sZCIsImNhblVuZm9sZCIsIm1hcmtlcnMiLCJidWlsZE1hcmtlcnMiLCJ2aWV3cG9ydENoYW5nZWQiLCJidWlsZGVyIiwidmlld3BvcnRMaW5lQmxvY2tzIiwibWFyayIsImZpbmlzaCIsImNsYXNzIiwiaW5pdGlhbFNwYWNlciIsImNsaWNrIiwiYmFzZVRoZW1lIiwiYmFja2dyb3VuZENvbG9yIiwiYm9yZGVyIiwiY29sb3IiLCJib3JkZXJSYWRpdXMiLCJtYXJnaW4iLCJwYWRkaW5nIiwiSGlnaGxpZ2h0U3R5bGUiLCJzcGVjcyIsIm1vZFNwZWMiLCJkZWYiLCJjbHMiLCJuZXdOYW1lIiwic2NvcGVPcHQiLCJzY29wZSIsInN0eWxlIiwidGFnIiwibW9kdWxlIiwidGhlbWVUeXBlIiwiaGlnaGxpZ2h0ZXJGYWNldCIsImZhbGxiYWNrSGlnaGxpZ2h0ZXIiLCJnZXRIaWdobGlnaHRlcnMiLCJzeW50YXhIaWdobGlnaHRpbmciLCJoaWdobGlnaHRlciIsInRyZWVIaWdobGlnaHRlciIsInN0eWxlTW9kdWxlIiwiZmFsbGJhY2siLCJjb21wdXRlTiIsImRhcmtUaGVtZSIsImhpZ2hsaWdodGluZ0ZvciIsImhpZ2hsaWdodGVycyIsIlRyZWVIaWdobGlnaHRlciIsIm1hcmtDYWNoZSIsImJ1aWxkRGVjbyIsInN0eWxlQ2hhbmdlIiwidmlzaWJsZVJhbmdlcyIsImhpZ2giLCJ2IiwiZGVmYXVsdEhpZ2hsaWdodFN0eWxlIiwibWV0YSIsImxpbmsiLCJ0ZXh0RGVjb3JhdGlvbiIsImhlYWRpbmciLCJmb250V2VpZ2h0IiwiZW1waGFzaXMiLCJmb250U3R5bGUiLCJzdHJvbmciLCJzdHJpa2V0aHJvdWdoIiwia2V5d29yZCIsImF0b20iLCJib29sIiwidXJsIiwiY29udGVudFNlcGFyYXRvciIsImxhYmVsTmFtZSIsImxpdGVyYWwiLCJpbnNlcnRlZCIsImRlbGV0ZWQiLCJyZWdleHAiLCJlc2NhcGUiLCJzcGVjaWFsIiwiZGVmaW5pdGlvbiIsInZhcmlhYmxlTmFtZSIsImxvY2FsIiwidHlwZU5hbWUiLCJuYW1lc3BhY2UiLCJtYWNyb05hbWUiLCJwcm9wZXJ0eU5hbWUiLCJjb21tZW50IiwiaW52YWxpZCIsIkRlZmF1bHRTY2FuRGlzdCIsIkRlZmF1bHRCcmFja2V0cyIsImJyYWNrZXRNYXRjaGluZ0NvbmZpZyIsImNvbmZpZ3MiLCJhZnRlckN1cnNvciIsImJyYWNrZXRzIiwibWF4U2NhbkRpc3RhbmNlIiwicmVuZGVyTWF0Y2giLCJkZWZhdWx0UmVuZGVyTWF0Y2giLCJtYXRjaGluZ01hcmsiLCJub25tYXRjaGluZ01hcmsiLCJtYXRjaGVkIiwiYnJhY2tldE1hdGNoaW5nU3RhdGUiLCJkZWNvIiwibWF0Y2hCcmFja2V0cyIsImJyYWNrZXRNYXRjaGluZ1VuaXF1ZSIsImJyYWNrZXRNYXRjaGluZyIsImJyYWNrZXRNYXRjaGluZ0hhbmRsZSIsIm1hdGNoaW5nTm9kZXMiLCJkaXIiLCJieVByb3AiLCJvcGVuZWRCeSIsImluZGV4IiwiZmluZEhhbmRsZSIsImhhc0hhbmRsZSIsInJlc29sdmVJbm5lciIsIm1hdGNoZXMiLCJoYW5kbGUiLCJtYXRjaE1hcmtlZEJyYWNrZXRzIiwibWF0Y2hQbGFpbkJyYWNrZXRzIiwiX3N0YXRlIiwiX3BvcyIsInRva2VuIiwibWF0Y2hpbmciLCJmaXJzdFRva2VuIiwiZGVwdGgiLCJjaGlsZEJlZm9yZSIsImVuZEhhbmRsZSIsInByZXZTaWJsaW5nIiwibmV4dFNpYmxpbmciLCJ0b2tlblR5cGUiLCJzdGFydENoIiwic2xpY2VEb2MiLCJicmFja2V0Iiwic3RhcnRUb2tlbiIsIml0ZXJSYW5nZSIsImRpc3RhbmNlIiwiYmFzZVBvcyIsImNvdW50Q29sIiwic3RhcnRJbmRleCIsInN0YXJ0VmFsdWUiLCJuIiwiU3RyaW5nU3RyZWFtIiwib3ZlcnJpZGVJbmRlbnQiLCJsYXN0Q29sdW1uUG9zIiwibGFzdENvbHVtblZhbHVlIiwiZW9sIiwic29sIiwicGVlayIsImNoYXJBdCIsImVhdCIsIm9rIiwiUmVnRXhwIiwiZWF0V2hpbGUiLCJlYXRTcGFjZSIsInNraXBUb0VuZCIsInNraXBUbyIsImJhY2tVcCIsImluZGVudGF0aW9uIiwicGF0dGVybiIsImNvbnN1bWUiLCJjYXNlSW5zZW5zaXRpdmUiLCJjYXNlZCIsInN0ciIsInN1YnN0ciIsImN1cnJlbnQiLCJmdWxsUGFyc2VyIiwiYmxhbmtMaW5lIiwiY29weVN0YXRlIiwiZGVmYXVsdENvcHlTdGF0ZSIsInRva2VuVGFibGUiLCJub1Rva2VucyIsInZhbCIsIkluZGVudGVkRnJvbSIsIldlYWtNYXAiLCJTdHJlYW1MYW5ndWFnZSIsInAiLCJzZWxmIiwiaW1wbCIsIlBhcnNlIiwiZ2V0SW5kZW50IiwiZG9jSUQiLCJzdHJlYW1QYXJzZXIiLCJzdGF0ZUFmdGVyIiwicGVyTm9kZSIsIlRva2VuVGFibGUiLCJkZWZhdWx0VG9rZW5UYWJsZSIsImF0IiwiZmluZFN0YXRlIiwic3RhdGVQb3MiLCJzdHJlYW0iLCJyZWFkVG9rZW4iLCJvZmYiLCJzdGFydFBvcyIsImJlZm9yZSIsImNoaWxkIiwiY3V0VHJlZSIsImluc2lkZSIsImZpbmRTdGFydEluRnJhZ21lbnRzIiwiZWRpdG9yU3RhdGUiLCJvcGVuU3RhcnQiLCJvcGVuRW5kIiwib2Zmc2V0IiwiY2h1bmtzIiwiY2h1bmtQb3MiLCJjaHVua1JldXNlZCIsInJhbmdlSW5kZXgiLCJjaHVua1N0YXJ0IiwibW92ZVJhbmdlSW5kZXgiLCJwYXJzZUVuZCIsInBhcnNlTGluZSIsImZpbmlzaENodW5rIiwibGluZUFmdGVyIiwibmV4dExpbmUiLCJyYW5nZUVuZCIsInJhbmdlU3RhcnQiLCJza2lwR2Fwc1RvIiwib2ZmUG9zIiwiZW1pdFRva2VuIiwiaWQiLCJsZW4wIiwiYnVpbGQiLCJidWZmZXIiLCJub2RlU2V0IiwidG9wSUQiLCJtYXhCdWZmZXJMZW5ndGgiLCJyZXVzZWQiLCJiYWxhbmNlIiwidHlwZUFycmF5Iiwid2FybmVkIiwiYnlUYWciLCJkZWZhdWx0VGFibGUiLCJsZWdhY3lOYW1lIiwiY3JlYXRlVG9rZW5UeXBlIiwiZXh0cmEiLCJ0YWJsZSIsIndhcm5Gb3JQYXJ0IiwicGFydCIsIm1zZyIsImNvbnNvbGUiLCJ3YXJuIiwidGFnU3RyIiwidGFncyQxIiwic3BsaXQiLCJ0Iiwia25vd24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@codemirror/language/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@codemirror/lint/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@codemirror/lint/dist/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   closeLintPanel: () => (/* binding */ closeLintPanel),\n/* harmony export */   diagnosticCount: () => (/* binding */ diagnosticCount),\n/* harmony export */   forEachDiagnostic: () => (/* binding */ forEachDiagnostic),\n/* harmony export */   forceLinting: () => (/* binding */ forceLinting),\n/* harmony export */   lintGutter: () => (/* binding */ lintGutter),\n/* harmony export */   lintKeymap: () => (/* binding */ lintKeymap),\n/* harmony export */   linter: () => (/* binding */ linter),\n/* harmony export */   nextDiagnostic: () => (/* binding */ nextDiagnostic),\n/* harmony export */   openLintPanel: () => (/* binding */ openLintPanel),\n/* harmony export */   previousDiagnostic: () => (/* binding */ previousDiagnostic),\n/* harmony export */   setDiagnostics: () => (/* binding */ setDiagnostics),\n/* harmony export */   setDiagnosticsEffect: () => (/* binding */ setDiagnosticsEffect)\n/* harmony export */ });\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/view */ \"(ssr)/./node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/state */ \"(ssr)/./node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var crelt__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crelt */ \"(ssr)/./node_modules/crelt/index.js\");\n\n\n\nclass SelectedDiagnostic {\n    constructor(from, to, diagnostic){\n        this.from = from;\n        this.to = to;\n        this.diagnostic = diagnostic;\n    }\n}\nclass LintState {\n    constructor(diagnostics, panel, selected){\n        this.diagnostics = diagnostics;\n        this.panel = panel;\n        this.selected = selected;\n    }\n    static init(diagnostics, panel, state) {\n        // Filter the list of diagnostics for which to create markers\n        let markedDiagnostics = diagnostics;\n        let diagnosticFilter = state.facet(lintConfig).markerFilter;\n        if (diagnosticFilter) markedDiagnostics = diagnosticFilter(markedDiagnostics);\n        let ranges = _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.Decoration.set(markedDiagnostics.map((d)=>{\n            // For zero-length ranges or ranges covering only a line break, create a widget\n            return d.from == d.to || d.from == d.to - 1 && state.doc.lineAt(d.from).to == d.from ? _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.Decoration.widget({\n                widget: new DiagnosticWidget(d),\n                diagnostic: d\n            }).range(d.from) : _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.Decoration.mark({\n                attributes: {\n                    class: \"cm-lintRange cm-lintRange-\" + d.severity + (d.markClass ? \" \" + d.markClass : \"\")\n                },\n                diagnostic: d\n            }).range(d.from, d.to);\n        }), true);\n        return new LintState(ranges, panel, findDiagnostic(ranges));\n    }\n}\nfunction findDiagnostic(diagnostics, diagnostic = null, after = 0) {\n    let found = null;\n    diagnostics.between(after, 1e9, (from, to, { spec })=>{\n        if (diagnostic && spec.diagnostic != diagnostic) return;\n        found = new SelectedDiagnostic(from, to, spec.diagnostic);\n        return false;\n    });\n    return found;\n}\nfunction hideTooltip(tr, tooltip) {\n    let line = tr.startState.doc.lineAt(tooltip.pos);\n    return !!(tr.effects.some((e)=>e.is(setDiagnosticsEffect)) || tr.changes.touchesRange(line.from, line.to));\n}\nfunction maybeEnableLint(state, effects) {\n    return state.field(lintState, false) ? effects : effects.concat(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.appendConfig.of(lintExtensions));\n}\n/**\nReturns a transaction spec which updates the current set of\ndiagnostics, and enables the lint extension if if wasn't already\nactive.\n*/ function setDiagnostics(state, diagnostics) {\n    return {\n        effects: maybeEnableLint(state, [\n            setDiagnosticsEffect.of(diagnostics)\n        ])\n    };\n}\n/**\nThe state effect that updates the set of active diagnostics. Can\nbe useful when writing an extension that needs to track these.\n*/ const setDiagnosticsEffect = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.define();\nconst togglePanel = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.define();\nconst movePanelSelection = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.define();\nconst lintState = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateField.define({\n    create () {\n        return new LintState(_codemirror_view__WEBPACK_IMPORTED_MODULE_1__.Decoration.none, null, null);\n    },\n    update (value, tr) {\n        if (tr.docChanged) {\n            let mapped = value.diagnostics.map(tr.changes), selected = null;\n            if (value.selected) {\n                let selPos = tr.changes.mapPos(value.selected.from, 1);\n                selected = findDiagnostic(mapped, value.selected.diagnostic, selPos) || findDiagnostic(mapped, null, selPos);\n            }\n            value = new LintState(mapped, value.panel, selected);\n        }\n        for (let effect of tr.effects){\n            if (effect.is(setDiagnosticsEffect)) {\n                value = LintState.init(effect.value, value.panel, tr.state);\n            } else if (effect.is(togglePanel)) {\n                value = new LintState(value.diagnostics, effect.value ? LintPanel.open : null, value.selected);\n            } else if (effect.is(movePanelSelection)) {\n                value = new LintState(value.diagnostics, value.panel, effect.value);\n            }\n        }\n        return value;\n    },\n    provide: (f)=>[\n            _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.showPanel.from(f, (val)=>val.panel),\n            _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.EditorView.decorations.from(f, (s)=>s.diagnostics)\n        ]\n});\n/**\nReturns the number of active lint diagnostics in the given state.\n*/ function diagnosticCount(state) {\n    let lint = state.field(lintState, false);\n    return lint ? lint.diagnostics.size : 0;\n}\nconst activeMark = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.Decoration.mark({\n    class: \"cm-lintRange cm-lintRange-active\"\n});\nfunction lintTooltip(view, pos, side) {\n    let { diagnostics } = view.state.field(lintState);\n    let found = [], stackStart = 2e8, stackEnd = 0;\n    diagnostics.between(pos - (side < 0 ? 1 : 0), pos + (side > 0 ? 1 : 0), (from, to, { spec })=>{\n        if (pos >= from && pos <= to && (from == to || (pos > from || side > 0) && (pos < to || side < 0))) {\n            found.push(spec.diagnostic);\n            stackStart = Math.min(from, stackStart);\n            stackEnd = Math.max(to, stackEnd);\n        }\n    });\n    let diagnosticFilter = view.state.facet(lintConfig).tooltipFilter;\n    if (diagnosticFilter) found = diagnosticFilter(found);\n    if (!found.length) return null;\n    return {\n        pos: stackStart,\n        end: stackEnd,\n        above: view.state.doc.lineAt(stackStart).to < stackEnd,\n        create () {\n            return {\n                dom: diagnosticsTooltip(view, found)\n            };\n        }\n    };\n}\nfunction diagnosticsTooltip(view, diagnostics) {\n    return (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"ul\", {\n        class: \"cm-tooltip-lint\"\n    }, diagnostics.map((d)=>renderDiagnostic(view, d, false)));\n}\n/**\nCommand to open and focus the lint panel.\n*/ const openLintPanel = (view)=>{\n    let field = view.state.field(lintState, false);\n    if (!field || !field.panel) view.dispatch({\n        effects: maybeEnableLint(view.state, [\n            togglePanel.of(true)\n        ])\n    });\n    let panel = (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_1__.getPanel)(view, LintPanel.open);\n    if (panel) panel.dom.querySelector(\".cm-panel-lint ul\").focus();\n    return true;\n};\n/**\nCommand to close the lint panel, when open.\n*/ const closeLintPanel = (view)=>{\n    let field = view.state.field(lintState, false);\n    if (!field || !field.panel) return false;\n    view.dispatch({\n        effects: togglePanel.of(false)\n    });\n    return true;\n};\n/**\nMove the selection to the next diagnostic.\n*/ const nextDiagnostic = (view)=>{\n    let field = view.state.field(lintState, false);\n    if (!field) return false;\n    let sel = view.state.selection.main, next = field.diagnostics.iter(sel.to + 1);\n    if (!next.value) {\n        next = field.diagnostics.iter(0);\n        if (!next.value || next.from == sel.from && next.to == sel.to) return false;\n    }\n    view.dispatch({\n        selection: {\n            anchor: next.from,\n            head: next.to\n        },\n        scrollIntoView: true\n    });\n    return true;\n};\n/**\nMove the selection to the previous diagnostic.\n*/ const previousDiagnostic = (view)=>{\n    let { state } = view, field = state.field(lintState, false);\n    if (!field) return false;\n    let sel = state.selection.main;\n    let prevFrom, prevTo, lastFrom, lastTo;\n    field.diagnostics.between(0, state.doc.length, (from, to)=>{\n        if (to < sel.to && (prevFrom == null || prevFrom < from)) {\n            prevFrom = from;\n            prevTo = to;\n        }\n        if (lastFrom == null || from > lastFrom) {\n            lastFrom = from;\n            lastTo = to;\n        }\n    });\n    if (lastFrom == null || prevFrom == null && lastFrom == sel.from) return false;\n    view.dispatch({\n        selection: {\n            anchor: prevFrom !== null && prevFrom !== void 0 ? prevFrom : lastFrom,\n            head: prevTo !== null && prevTo !== void 0 ? prevTo : lastTo\n        },\n        scrollIntoView: true\n    });\n    return true;\n};\n/**\nA set of default key bindings for the lint functionality.\n\n- Ctrl-Shift-m (Cmd-Shift-m on macOS): [`openLintPanel`](https://codemirror.net/6/docs/ref/#lint.openLintPanel)\n- F8: [`nextDiagnostic`](https://codemirror.net/6/docs/ref/#lint.nextDiagnostic)\n*/ const lintKeymap = [\n    {\n        key: \"Mod-Shift-m\",\n        run: openLintPanel,\n        preventDefault: true\n    },\n    {\n        key: \"F8\",\n        run: nextDiagnostic\n    }\n];\nconst lintPlugin = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.ViewPlugin.fromClass(class {\n    constructor(view){\n        this.view = view;\n        this.timeout = -1;\n        this.set = true;\n        let { delay } = view.state.facet(lintConfig);\n        this.lintTime = Date.now() + delay;\n        this.run = this.run.bind(this);\n        this.timeout = setTimeout(this.run, delay);\n    }\n    run() {\n        let now = Date.now();\n        if (now < this.lintTime - 10) {\n            this.timeout = setTimeout(this.run, this.lintTime - now);\n        } else {\n            this.set = false;\n            let { state } = this.view, { sources } = state.facet(lintConfig);\n            Promise.all(sources.map((source)=>Promise.resolve(source(this.view)))).then((annotations)=>{\n                let all = annotations.reduce((a, b)=>a.concat(b));\n                if (this.view.state.doc == state.doc) this.view.dispatch(setDiagnostics(this.view.state, all));\n            }, (error)=>{\n                (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_1__.logException)(this.view.state, error);\n            });\n        }\n    }\n    update(update) {\n        let config = update.state.facet(lintConfig);\n        if (update.docChanged || config != update.startState.facet(lintConfig) || config.needsRefresh && config.needsRefresh(update)) {\n            this.lintTime = Date.now() + config.delay;\n            if (!this.set) {\n                this.set = true;\n                this.timeout = setTimeout(this.run, config.delay);\n            }\n        }\n    }\n    force() {\n        if (this.set) {\n            this.lintTime = Date.now();\n            this.run();\n        }\n    }\n    destroy() {\n        clearTimeout(this.timeout);\n    }\n});\nconst lintConfig = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    combine (input) {\n        return Object.assign({\n            sources: input.map((i)=>i.source)\n        }, (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.combineConfig)(input.map((i)=>i.config), {\n            delay: 750,\n            markerFilter: null,\n            tooltipFilter: null,\n            needsRefresh: null\n        }, {\n            needsRefresh: (a, b)=>!a ? b : !b ? a : (u)=>a(u) || b(u)\n        }));\n    }\n});\n/**\nGiven a diagnostic source, this function returns an extension that\nenables linting with that source. It will be called whenever the\neditor is idle (after its content changed).\n*/ function linter(source, config = {}) {\n    return [\n        lintConfig.of({\n            source,\n            config\n        }),\n        lintPlugin,\n        lintExtensions\n    ];\n}\n/**\nForces any linters [configured](https://codemirror.net/6/docs/ref/#lint.linter) to run when the\neditor is idle to run right away.\n*/ function forceLinting(view) {\n    let plugin = view.plugin(lintPlugin);\n    if (plugin) plugin.force();\n}\nfunction assignKeys(actions) {\n    let assigned = [];\n    if (actions) actions: for (let { name } of actions){\n        for(let i = 0; i < name.length; i++){\n            let ch = name[i];\n            if (/[a-zA-Z]/.test(ch) && !assigned.some((c)=>c.toLowerCase() == ch.toLowerCase())) {\n                assigned.push(ch);\n                continue actions;\n            }\n        }\n        assigned.push(\"\");\n    }\n    return assigned;\n}\nfunction renderDiagnostic(view, diagnostic, inPanel) {\n    var _a;\n    let keys = inPanel ? assignKeys(diagnostic.actions) : [];\n    return (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"li\", {\n        class: \"cm-diagnostic cm-diagnostic-\" + diagnostic.severity\n    }, (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"span\", {\n        class: \"cm-diagnosticText\"\n    }, diagnostic.renderMessage ? diagnostic.renderMessage() : diagnostic.message), (_a = diagnostic.actions) === null || _a === void 0 ? void 0 : _a.map((action, i)=>{\n        let fired = false, click = (e)=>{\n            e.preventDefault();\n            if (fired) return;\n            fired = true;\n            let found = findDiagnostic(view.state.field(lintState).diagnostics, diagnostic);\n            if (found) action.apply(view, found.from, found.to);\n        };\n        let { name } = action, keyIndex = keys[i] ? name.indexOf(keys[i]) : -1;\n        let nameElt = keyIndex < 0 ? name : [\n            name.slice(0, keyIndex),\n            (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"u\", name.slice(keyIndex, keyIndex + 1)),\n            name.slice(keyIndex + 1)\n        ];\n        return (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"button\", {\n            type: \"button\",\n            class: \"cm-diagnosticAction\",\n            onclick: click,\n            onmousedown: click,\n            \"aria-label\": ` Action: ${name}${keyIndex < 0 ? \"\" : ` (access key \"${keys[i]})\"`}.`\n        }, nameElt);\n    }), diagnostic.source && (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"div\", {\n        class: \"cm-diagnosticSource\"\n    }, diagnostic.source));\n}\nclass DiagnosticWidget extends _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.WidgetType {\n    constructor(diagnostic){\n        super();\n        this.diagnostic = diagnostic;\n    }\n    eq(other) {\n        return other.diagnostic == this.diagnostic;\n    }\n    toDOM() {\n        return (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"span\", {\n            class: \"cm-lintPoint cm-lintPoint-\" + this.diagnostic.severity\n        });\n    }\n}\nclass PanelItem {\n    constructor(view, diagnostic){\n        this.diagnostic = diagnostic;\n        this.id = \"item_\" + Math.floor(Math.random() * 0xffffffff).toString(16);\n        this.dom = renderDiagnostic(view, diagnostic, true);\n        this.dom.id = this.id;\n        this.dom.setAttribute(\"role\", \"option\");\n    }\n}\nclass LintPanel {\n    constructor(view){\n        this.view = view;\n        this.items = [];\n        let onkeydown = (event)=>{\n            if (event.keyCode == 27) {\n                closeLintPanel(this.view);\n                this.view.focus();\n            } else if (event.keyCode == 38 || event.keyCode == 33) {\n                this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);\n            } else if (event.keyCode == 40 || event.keyCode == 34) {\n                this.moveSelection((this.selectedIndex + 1) % this.items.length);\n            } else if (event.keyCode == 36) {\n                this.moveSelection(0);\n            } else if (event.keyCode == 35) {\n                this.moveSelection(this.items.length - 1);\n            } else if (event.keyCode == 13) {\n                this.view.focus();\n            } else if (event.keyCode >= 65 && event.keyCode <= 90 && this.selectedIndex >= 0) {\n                let { diagnostic } = this.items[this.selectedIndex], keys = assignKeys(diagnostic.actions);\n                for(let i = 0; i < keys.length; i++)if (keys[i].toUpperCase().charCodeAt(0) == event.keyCode) {\n                    let found = findDiagnostic(this.view.state.field(lintState).diagnostics, diagnostic);\n                    if (found) diagnostic.actions[i].apply(view, found.from, found.to);\n                }\n            } else {\n                return;\n            }\n            event.preventDefault();\n        };\n        let onclick = (event)=>{\n            for(let i = 0; i < this.items.length; i++){\n                if (this.items[i].dom.contains(event.target)) this.moveSelection(i);\n            }\n        };\n        this.list = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"ul\", {\n            tabIndex: 0,\n            role: \"listbox\",\n            \"aria-label\": this.view.state.phrase(\"Diagnostics\"),\n            onkeydown,\n            onclick\n        });\n        this.dom = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"div\", {\n            class: \"cm-panel-lint\"\n        }, this.list, (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"button\", {\n            type: \"button\",\n            name: \"close\",\n            \"aria-label\": this.view.state.phrase(\"close\"),\n            onclick: ()=>closeLintPanel(this.view)\n        }, \"\\xd7\"));\n        this.update();\n    }\n    get selectedIndex() {\n        let selected = this.view.state.field(lintState).selected;\n        if (!selected) return -1;\n        for(let i = 0; i < this.items.length; i++)if (this.items[i].diagnostic == selected.diagnostic) return i;\n        return -1;\n    }\n    update() {\n        let { diagnostics, selected } = this.view.state.field(lintState);\n        let i = 0, needsSync = false, newSelectedItem = null;\n        diagnostics.between(0, this.view.state.doc.length, (_start, _end, { spec })=>{\n            let found = -1, item;\n            for(let j = i; j < this.items.length; j++)if (this.items[j].diagnostic == spec.diagnostic) {\n                found = j;\n                break;\n            }\n            if (found < 0) {\n                item = new PanelItem(this.view, spec.diagnostic);\n                this.items.splice(i, 0, item);\n                needsSync = true;\n            } else {\n                item = this.items[found];\n                if (found > i) {\n                    this.items.splice(i, found - i);\n                    needsSync = true;\n                }\n            }\n            if (selected && item.diagnostic == selected.diagnostic) {\n                if (!item.dom.hasAttribute(\"aria-selected\")) {\n                    item.dom.setAttribute(\"aria-selected\", \"true\");\n                    newSelectedItem = item;\n                }\n            } else if (item.dom.hasAttribute(\"aria-selected\")) {\n                item.dom.removeAttribute(\"aria-selected\");\n            }\n            i++;\n        });\n        while(i < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0)){\n            needsSync = true;\n            this.items.pop();\n        }\n        if (this.items.length == 0) {\n            this.items.push(new PanelItem(this.view, {\n                from: -1,\n                to: -1,\n                severity: \"info\",\n                message: this.view.state.phrase(\"No diagnostics\")\n            }));\n            needsSync = true;\n        }\n        if (newSelectedItem) {\n            this.list.setAttribute(\"aria-activedescendant\", newSelectedItem.id);\n            this.view.requestMeasure({\n                key: this,\n                read: ()=>({\n                        sel: newSelectedItem.dom.getBoundingClientRect(),\n                        panel: this.list.getBoundingClientRect()\n                    }),\n                write: ({ sel, panel })=>{\n                    let scaleY = panel.height / this.list.offsetHeight;\n                    if (sel.top < panel.top) this.list.scrollTop -= (panel.top - sel.top) / scaleY;\n                    else if (sel.bottom > panel.bottom) this.list.scrollTop += (sel.bottom - panel.bottom) / scaleY;\n                }\n            });\n        } else if (this.selectedIndex < 0) {\n            this.list.removeAttribute(\"aria-activedescendant\");\n        }\n        if (needsSync) this.sync();\n    }\n    sync() {\n        let domPos = this.list.firstChild;\n        function rm() {\n            let prev = domPos;\n            domPos = prev.nextSibling;\n            prev.remove();\n        }\n        for (let item of this.items){\n            if (item.dom.parentNode == this.list) {\n                while(domPos != item.dom)rm();\n                domPos = item.dom.nextSibling;\n            } else {\n                this.list.insertBefore(item.dom, domPos);\n            }\n        }\n        while(domPos)rm();\n    }\n    moveSelection(selectedIndex) {\n        if (this.selectedIndex < 0) return;\n        let field = this.view.state.field(lintState);\n        let selection = findDiagnostic(field.diagnostics, this.items[selectedIndex].diagnostic);\n        if (!selection) return;\n        this.view.dispatch({\n            selection: {\n                anchor: selection.from,\n                head: selection.to\n            },\n            scrollIntoView: true,\n            effects: movePanelSelection.of(selection)\n        });\n    }\n    static open(view) {\n        return new LintPanel(view);\n    }\n}\nfunction svg(content, attrs = `viewBox=\"0 0 40 40\"`) {\n    return `url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" ${attrs}>${encodeURIComponent(content)}</svg>')`;\n}\nfunction underline(color) {\n    return svg(`<path d=\"m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0\" stroke=\"${color}\" fill=\"none\" stroke-width=\".7\"/>`, `width=\"6\" height=\"3\"`);\n}\nconst baseTheme = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.EditorView.baseTheme({\n    \".cm-diagnostic\": {\n        padding: \"3px 6px 3px 8px\",\n        marginLeft: \"-1px\",\n        display: \"block\",\n        whiteSpace: \"pre-wrap\"\n    },\n    \".cm-diagnostic-error\": {\n        borderLeft: \"5px solid #d11\"\n    },\n    \".cm-diagnostic-warning\": {\n        borderLeft: \"5px solid orange\"\n    },\n    \".cm-diagnostic-info\": {\n        borderLeft: \"5px solid #999\"\n    },\n    \".cm-diagnostic-hint\": {\n        borderLeft: \"5px solid #66d\"\n    },\n    \".cm-diagnosticAction\": {\n        font: \"inherit\",\n        border: \"none\",\n        padding: \"2px 4px\",\n        backgroundColor: \"#444\",\n        color: \"white\",\n        borderRadius: \"3px\",\n        marginLeft: \"8px\",\n        cursor: \"pointer\"\n    },\n    \".cm-diagnosticSource\": {\n        fontSize: \"70%\",\n        opacity: .7\n    },\n    \".cm-lintRange\": {\n        backgroundPosition: \"left bottom\",\n        backgroundRepeat: \"repeat-x\",\n        paddingBottom: \"0.7px\"\n    },\n    \".cm-lintRange-error\": {\n        backgroundImage: /*@__PURE__*/ underline(\"#d11\")\n    },\n    \".cm-lintRange-warning\": {\n        backgroundImage: /*@__PURE__*/ underline(\"orange\")\n    },\n    \".cm-lintRange-info\": {\n        backgroundImage: /*@__PURE__*/ underline(\"#999\")\n    },\n    \".cm-lintRange-hint\": {\n        backgroundImage: /*@__PURE__*/ underline(\"#66d\")\n    },\n    \".cm-lintRange-active\": {\n        backgroundColor: \"#ffdd9980\"\n    },\n    \".cm-tooltip-lint\": {\n        padding: 0,\n        margin: 0\n    },\n    \".cm-lintPoint\": {\n        position: \"relative\",\n        \"&:after\": {\n            content: '\"\"',\n            position: \"absolute\",\n            bottom: 0,\n            left: \"-2px\",\n            borderLeft: \"3px solid transparent\",\n            borderRight: \"3px solid transparent\",\n            borderBottom: \"4px solid #d11\"\n        }\n    },\n    \".cm-lintPoint-warning\": {\n        \"&:after\": {\n            borderBottomColor: \"orange\"\n        }\n    },\n    \".cm-lintPoint-info\": {\n        \"&:after\": {\n            borderBottomColor: \"#999\"\n        }\n    },\n    \".cm-lintPoint-hint\": {\n        \"&:after\": {\n            borderBottomColor: \"#66d\"\n        }\n    },\n    \".cm-panel.cm-panel-lint\": {\n        position: \"relative\",\n        \"& ul\": {\n            maxHeight: \"100px\",\n            overflowY: \"auto\",\n            \"& [aria-selected]\": {\n                backgroundColor: \"#ddd\",\n                \"& u\": {\n                    textDecoration: \"underline\"\n                }\n            },\n            \"&:focus [aria-selected]\": {\n                background_fallback: \"#bdf\",\n                backgroundColor: \"Highlight\",\n                color_fallback: \"white\",\n                color: \"HighlightText\"\n            },\n            \"& u\": {\n                textDecoration: \"none\"\n            },\n            padding: 0,\n            margin: 0\n        },\n        \"& [name=close]\": {\n            position: \"absolute\",\n            top: \"0\",\n            right: \"2px\",\n            background: \"inherit\",\n            border: \"none\",\n            font: \"inherit\",\n            padding: 0,\n            margin: 0\n        }\n    }\n});\nfunction severityWeight(sev) {\n    return sev == \"error\" ? 4 : sev == \"warning\" ? 3 : sev == \"info\" ? 2 : 1;\n}\nclass LintGutterMarker extends _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.GutterMarker {\n    constructor(diagnostics){\n        super();\n        this.diagnostics = diagnostics;\n        this.severity = diagnostics.reduce((max, d)=>severityWeight(max) < severityWeight(d.severity) ? d.severity : max, \"hint\");\n    }\n    toDOM(view) {\n        let elt = document.createElement(\"div\");\n        elt.className = \"cm-lint-marker cm-lint-marker-\" + this.severity;\n        let diagnostics = this.diagnostics;\n        let diagnosticsFilter = view.state.facet(lintGutterConfig).tooltipFilter;\n        if (diagnosticsFilter) diagnostics = diagnosticsFilter(diagnostics);\n        if (diagnostics.length) elt.onmouseover = ()=>gutterMarkerMouseOver(view, elt, diagnostics);\n        return elt;\n    }\n}\nfunction trackHoverOn(view, marker) {\n    let mousemove = (event)=>{\n        let rect = marker.getBoundingClientRect();\n        if (event.clientX > rect.left - 10 /* Hover.Margin */  && event.clientX < rect.right + 10 /* Hover.Margin */  && event.clientY > rect.top - 10 /* Hover.Margin */  && event.clientY < rect.bottom + 10 /* Hover.Margin */ ) return;\n        for(let target = event.target; target; target = target.parentNode){\n            if (target.nodeType == 1 && target.classList.contains(\"cm-tooltip-lint\")) return;\n        }\n        window.removeEventListener(\"mousemove\", mousemove);\n        if (view.state.field(lintGutterTooltip)) view.dispatch({\n            effects: setLintGutterTooltip.of(null)\n        });\n    };\n    window.addEventListener(\"mousemove\", mousemove);\n}\nfunction gutterMarkerMouseOver(view, marker, diagnostics) {\n    function hovered() {\n        let line = view.elementAtHeight(marker.getBoundingClientRect().top + 5 - view.documentTop);\n        const linePos = view.coordsAtPos(line.from);\n        if (linePos) {\n            view.dispatch({\n                effects: setLintGutterTooltip.of({\n                    pos: line.from,\n                    above: false,\n                    create () {\n                        return {\n                            dom: diagnosticsTooltip(view, diagnostics),\n                            getCoords: ()=>marker.getBoundingClientRect()\n                        };\n                    }\n                })\n            });\n        }\n        marker.onmouseout = marker.onmousemove = null;\n        trackHoverOn(view, marker);\n    }\n    let { hoverTime } = view.state.facet(lintGutterConfig);\n    let hoverTimeout = setTimeout(hovered, hoverTime);\n    marker.onmouseout = ()=>{\n        clearTimeout(hoverTimeout);\n        marker.onmouseout = marker.onmousemove = null;\n    };\n    marker.onmousemove = ()=>{\n        clearTimeout(hoverTimeout);\n        hoverTimeout = setTimeout(hovered, hoverTime);\n    };\n}\nfunction markersForDiagnostics(doc, diagnostics) {\n    let byLine = Object.create(null);\n    for (let diagnostic of diagnostics){\n        let line = doc.lineAt(diagnostic.from);\n        (byLine[line.from] || (byLine[line.from] = [])).push(diagnostic);\n    }\n    let markers = [];\n    for(let line in byLine){\n        markers.push(new LintGutterMarker(byLine[line]).range(+line));\n    }\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.of(markers, true);\n}\nconst lintGutterExtension = /*@__PURE__*/ (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_1__.gutter)({\n    class: \"cm-gutter-lint\",\n    markers: (view)=>view.state.field(lintGutterMarkers)\n});\nconst lintGutterMarkers = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateField.define({\n    create () {\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.empty;\n    },\n    update (markers, tr) {\n        markers = markers.map(tr.changes);\n        let diagnosticFilter = tr.state.facet(lintGutterConfig).markerFilter;\n        for (let effect of tr.effects){\n            if (effect.is(setDiagnosticsEffect)) {\n                let diagnostics = effect.value;\n                if (diagnosticFilter) diagnostics = diagnosticFilter(diagnostics || []);\n                markers = markersForDiagnostics(tr.state.doc, diagnostics.slice(0));\n            }\n        }\n        return markers;\n    }\n});\nconst setLintGutterTooltip = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.define();\nconst lintGutterTooltip = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateField.define({\n    create () {\n        return null;\n    },\n    update (tooltip, tr) {\n        if (tooltip && tr.docChanged) tooltip = hideTooltip(tr, tooltip) ? null : Object.assign(Object.assign({}, tooltip), {\n            pos: tr.changes.mapPos(tooltip.pos)\n        });\n        return tr.effects.reduce((t, e)=>e.is(setLintGutterTooltip) ? e.value : t, tooltip);\n    },\n    provide: (field)=>_codemirror_view__WEBPACK_IMPORTED_MODULE_1__.showTooltip.from(field)\n});\nconst lintGutterTheme = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.EditorView.baseTheme({\n    \".cm-gutter-lint\": {\n        width: \"1.4em\",\n        \"& .cm-gutterElement\": {\n            padding: \".2em\"\n        }\n    },\n    \".cm-lint-marker\": {\n        width: \"1em\",\n        height: \"1em\"\n    },\n    \".cm-lint-marker-info\": {\n        content: /*@__PURE__*/ svg(`<path fill=\"#aaf\" stroke=\"#77e\" stroke-width=\"6\" stroke-linejoin=\"round\" d=\"M5 5L35 5L35 35L5 35Z\"/>`)\n    },\n    \".cm-lint-marker-warning\": {\n        content: /*@__PURE__*/ svg(`<path fill=\"#fe8\" stroke=\"#fd7\" stroke-width=\"6\" stroke-linejoin=\"round\" d=\"M20 6L37 35L3 35Z\"/>`)\n    },\n    \".cm-lint-marker-error\": {\n        content: /*@__PURE__*/ svg(`<circle cx=\"20\" cy=\"20\" r=\"15\" fill=\"#f87\" stroke=\"#f43\" stroke-width=\"6\"/>`)\n    }\n});\nconst lintExtensions = [\n    lintState,\n    /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.EditorView.decorations.compute([\n        lintState\n    ], (state)=>{\n        let { selected, panel } = state.field(lintState);\n        return !selected || !panel || selected.from == selected.to ? _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.Decoration.none : _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.Decoration.set([\n            activeMark.range(selected.from, selected.to)\n        ]);\n    }),\n    /*@__PURE__*/ (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_1__.hoverTooltip)(lintTooltip, {\n        hideOn: hideTooltip\n    }),\n    baseTheme\n];\nconst lintGutterConfig = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    combine (configs) {\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.combineConfig)(configs, {\n            hoverTime: 300 /* Hover.Time */ ,\n            markerFilter: null,\n            tooltipFilter: null\n        });\n    }\n});\n/**\nReturns an extension that installs a gutter showing markers for\neach line that has diagnostics, which can be hovered over to see\nthe diagnostics.\n*/ function lintGutter(config = {}) {\n    return [\n        lintGutterConfig.of(config),\n        lintGutterMarkers,\n        lintGutterExtension,\n        lintGutterTheme,\n        lintGutterTooltip\n    ];\n}\n/**\nIterate over the marked diagnostics for the given editor state,\ncalling `f` for each of them. Note that, if the document changed\nsince the diagnostics were created, the `Diagnostic` object will\nhold the original outdated position, whereas the `to` and `from`\narguments hold the diagnostic's current position.\n*/ function forEachDiagnostic(state, f) {\n    let lState = state.field(lintState, false);\n    if (lState && lState.diagnostics.size) for(let iter = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.iter([\n        lState.diagnostics\n    ]); iter.value; iter.next())f(iter.value.spec.diagnostic, iter.from, iter.to);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGludC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFzSztBQUMxRTtBQUNwRTtBQUV4QixNQUFNaUI7SUFDRkMsWUFBWUMsSUFBSSxFQUFFQyxFQUFFLEVBQUVDLFVBQVUsQ0FBRTtRQUM5QixJQUFJLENBQUNGLElBQUksR0FBR0E7UUFDWixJQUFJLENBQUNDLEVBQUUsR0FBR0E7UUFDVixJQUFJLENBQUNDLFVBQVUsR0FBR0E7SUFDdEI7QUFDSjtBQUNBLE1BQU1DO0lBQ0ZKLFlBQVlLLFdBQVcsRUFBRUMsS0FBSyxFQUFFQyxRQUFRLENBQUU7UUFDdEMsSUFBSSxDQUFDRixXQUFXLEdBQUdBO1FBQ25CLElBQUksQ0FBQ0MsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQ0MsUUFBUSxHQUFHQTtJQUNwQjtJQUNBLE9BQU9DLEtBQUtILFdBQVcsRUFBRUMsS0FBSyxFQUFFRyxLQUFLLEVBQUU7UUFDbkMsNkRBQTZEO1FBQzdELElBQUlDLG9CQUFvQkw7UUFDeEIsSUFBSU0sbUJBQW1CRixNQUFNRyxLQUFLLENBQUNDLFlBQVlDLFlBQVk7UUFDM0QsSUFBSUgsa0JBQ0FELG9CQUFvQkMsaUJBQWlCRDtRQUN6QyxJQUFJSyxTQUFTakMsd0RBQVVBLENBQUNrQyxHQUFHLENBQUNOLGtCQUFrQk8sR0FBRyxDQUFDLENBQUNDO1lBQy9DLCtFQUErRTtZQUMvRSxPQUFPQSxFQUFFakIsSUFBSSxJQUFJaUIsRUFBRWhCLEVBQUUsSUFBS2dCLEVBQUVqQixJQUFJLElBQUlpQixFQUFFaEIsRUFBRSxHQUFHLEtBQUtPLE1BQU1VLEdBQUcsQ0FBQ0MsTUFBTSxDQUFDRixFQUFFakIsSUFBSSxFQUFFQyxFQUFFLElBQUlnQixFQUFFakIsSUFBSSxHQUMvRW5CLHdEQUFVQSxDQUFDdUMsTUFBTSxDQUFDO2dCQUNoQkEsUUFBUSxJQUFJQyxpQkFBaUJKO2dCQUM3QmYsWUFBWWU7WUFD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Y0FBYztZQUM3QnhSLGNBQWM7WUFDZHlFLGVBQWU7UUFDbkI7SUFDSjtBQUNKO0FBQ0E7Ozs7QUFJQSxHQUNBLFNBQVM2TixXQUFXM0ssU0FBUyxDQUFDLENBQUM7SUFDM0IsT0FBTztRQUFDcUksaUJBQWlCMU4sRUFBRSxDQUFDcUY7UUFBU21LO1FBQW1CRDtRQUFxQkk7UUFBaUJwQjtLQUFrQjtBQUNwSDtBQUNBOzs7Ozs7QUFNQSxHQUNBLFNBQVMwQixrQkFBa0I1UyxLQUFLLEVBQUU2RCxDQUFDO0lBQy9CLElBQUlnUCxTQUFTN1MsTUFBTXVDLEtBQUssQ0FBQ0MsV0FBVztJQUNwQyxJQUFJcVEsVUFBVUEsT0FBT2pULFdBQVcsQ0FBQ3VFLElBQUksRUFDakMsSUFBSyxJQUFJNEIsT0FBTzNHLHVEQUFRQSxDQUFDMkcsSUFBSSxDQUFDO1FBQUM4TSxPQUFPalQsV0FBVztLQUFDLEdBQUdtRyxLQUFLM0MsS0FBSyxFQUFFMkMsS0FBS0QsSUFBSSxHQUN0RWpDLEVBQUVrQyxLQUFLM0MsS0FBSyxDQUFDNUIsSUFBSSxDQUFDOUIsVUFBVSxFQUFFcUcsS0FBS3ZHLElBQUksRUFBRXVHLEtBQUt0RyxFQUFFO0FBQzVEO0FBRXFNIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHl0aG9uLW9ubGluZS1lZGl0b3IvLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGludC9kaXN0L2luZGV4LmpzP2Y5ZGMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGVjb3JhdGlvbiwgc2hvd1BhbmVsLCBFZGl0b3JWaWV3LCBWaWV3UGx1Z2luLCBsb2dFeGNlcHRpb24sIGd1dHRlciwgc2hvd1Rvb2x0aXAsIGhvdmVyVG9vbHRpcCwgZ2V0UGFuZWwsIFdpZGdldFR5cGUsIEd1dHRlck1hcmtlciB9IGZyb20gJ0Bjb2RlbWlycm9yL3ZpZXcnO1xuaW1wb3J0IHsgU3RhdGVFZmZlY3QsIFN0YXRlRmllbGQsIEZhY2V0LCBjb21iaW5lQ29uZmlnLCBSYW5nZVNldCB9IGZyb20gJ0Bjb2RlbWlycm9yL3N0YXRlJztcbmltcG9ydCBlbHQgZnJvbSAnY3JlbHQnO1xuXG5jbGFzcyBTZWxlY3RlZERpYWdub3N0aWMge1xuICAgIGNvbnN0cnVjdG9yKGZyb20sIHRvLCBkaWFnbm9zdGljKSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy5kaWFnbm9zdGljID0gZGlhZ25vc3RpYztcbiAgICB9XG59XG5jbGFzcyBMaW50U3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKGRpYWdub3N0aWNzLCBwYW5lbCwgc2VsZWN0ZWQpIHtcbiAgICAgICAgdGhpcy5kaWFnbm9zdGljcyA9IGRpYWdub3N0aWNzO1xuICAgICAgICB0aGlzLnBhbmVsID0gcGFuZWw7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWQgPSBzZWxlY3RlZDtcbiAgICB9XG4gICAgc3RhdGljIGluaXQoZGlhZ25vc3RpY3MsIHBhbmVsLCBzdGF0ZSkge1xuICAgICAgICAvLyBGaWx0ZXIgdGhlIGxpc3Qgb2YgZGlhZ25vc3RpY3MgZm9yIHdoaWNoIHRvIGNyZWF0ZSBtYXJrZXJzXG4gICAgICAgIGxldCBtYXJrZWREaWFnbm9zdGljcyA9IGRpYWdub3N0aWNzO1xuICAgICAgICBsZXQgZGlhZ25vc3RpY0ZpbHRlciA9IHN0YXRlLmZhY2V0KGxpbnRDb25maWcpLm1hcmtlckZpbHRlcjtcbiAgICAgICAgaWYgKGRpYWdub3N0aWNGaWx0ZXIpXG4gICAgICAgICAgICBtYXJrZWREaWFnbm9zdGljcyA9IGRpYWdub3N0aWNGaWx0ZXIobWFya2VkRGlhZ25vc3RpY3MpO1xuICAgICAgICBsZXQgcmFuZ2VzID0gRGVjb3JhdGlvbi5zZXQobWFya2VkRGlhZ25vc3RpY3MubWFwKChkKSA9PiB7XG4gICAgICAgICAgICAvLyBGb3IgemVyby1sZW5ndGggcmFuZ2VzIG9yIHJhbmdlcyBjb3ZlcmluZyBvbmx5IGEgbGluZSBicmVhaywgY3JlYXRlIGEgd2lkZ2V0XG4gICAgICAgICAgICByZXR1cm4gZC5mcm9tID09IGQudG8gfHwgKGQuZnJvbSA9PSBkLnRvIC0gMSAmJiBzdGF0ZS5kb2MubGluZUF0KGQuZnJvbSkudG8gPT0gZC5mcm9tKVxuICAgICAgICAgICAgICAgID8gRGVjb3JhdGlvbi53aWRnZXQoe1xuICAgICAgICAgICAgICAgICAgICB3aWRnZXQ6IG5ldyBEaWFnbm9zdGljV2lkZ2V0KGQpLFxuICAgICAgICAgICAgICAgICAgICBkaWFnbm9zdGljOiBkXG4gICAgICAgICAgICAgICAgfSkucmFuZ2UoZC5mcm9tKVxuICAgICAgICAgICAgICAgIDogRGVjb3JhdGlvbi5tYXJrKHtcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczogeyBjbGFzczogXCJjbS1saW50UmFuZ2UgY20tbGludFJhbmdlLVwiICsgZC5zZXZlcml0eSArIChkLm1hcmtDbGFzcyA/IFwiIFwiICsgZC5tYXJrQ2xhc3MgOiBcIlwiKSB9LFxuICAgICAgICAgICAgICAgICAgICBkaWFnbm9zdGljOiBkXG4gICAgICAgICAgICAgICAgfSkucmFuZ2UoZC5mcm9tLCBkLnRvKTtcbiAgICAgICAgfSksIHRydWUpO1xuICAgICAgICByZXR1cm4gbmV3IExpbnRTdGF0ZShyYW5nZXMsIHBhbmVsLCBmaW5kRGlhZ25vc3RpYyhyYW5nZXMpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBmaW5kRGlhZ25vc3RpYyhkaWFnbm9zdGljcywgZGlhZ25vc3RpYyA9IG51bGwsIGFmdGVyID0gMCkge1xuICAgIGxldCBmb3VuZCA9IG51bGw7XG4gICAgZGlhZ25vc3RpY3MuYmV0d2VlbihhZnRlciwgMWU5LCAoZnJvbSwgdG8sIHsgc3BlYyB9KSA9PiB7XG4gICAgICAgIGlmIChkaWFnbm9zdGljICYmIHNwZWMuZGlhZ25vc3RpYyAhPSBkaWFnbm9zdGljKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBmb3VuZCA9IG5ldyBTZWxlY3RlZERpYWdub3N0aWMoZnJvbSwgdG8sIHNwZWMuZGlhZ25vc3RpYyk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KTtcbiAgICByZXR1cm4gZm91bmQ7XG59XG5mdW5jdGlvbiBoaWRlVG9vbHRpcCh0ciwgdG9vbHRpcCkge1xuICAgIGxldCBsaW5lID0gdHIuc3RhcnRTdGF0ZS5kb2MubGluZUF0KHRvb2x0aXAucG9zKTtcbiAgICByZXR1cm4gISEodHIuZWZmZWN0cy5zb21lKGUgPT4gZS5pcyhzZXREaWFnbm9zdGljc0VmZmVjdCkpIHx8IHRyLmNoYW5nZXMudG91Y2hlc1JhbmdlKGxpbmUuZnJvbSwgbGluZS50bykpO1xufVxuZnVuY3Rpb24gbWF5YmVFbmFibGVMaW50KHN0YXRlLCBlZmZlY3RzKSB7XG4gICAgcmV0dXJuIHN0YXRlLmZpZWxkKGxpbnRTdGF0ZSwgZmFsc2UpID8gZWZmZWN0cyA6IGVmZmVjdHMuY29uY2F0KFN0YXRlRWZmZWN0LmFwcGVuZENvbmZpZy5vZihsaW50RXh0ZW5zaW9ucykpO1xufVxuLyoqXG5SZXR1cm5zIGEgdHJhbnNhY3Rpb24gc3BlYyB3aGljaCB1cGRhdGVzIHRoZSBjdXJyZW50IHNldCBvZlxuZGlhZ25vc3RpY3MsIGFuZCBlbmFibGVzIHRoZSBsaW50IGV4dGVuc2lvbiBpZiBpZiB3YXNuJ3QgYWxyZWFkeVxuYWN0aXZlLlxuKi9cbmZ1bmN0aW9uIHNldERpYWdub3N0aWNzKHN0YXRlLCBkaWFnbm9zdGljcykge1xuICAgIHJldHVybiB7XG4gICAgICAgIGVmZmVjdHM6IG1heWJlRW5hYmxlTGludChzdGF0ZSwgW3NldERpYWdub3N0aWNzRWZmZWN0Lm9mKGRpYWdub3N0aWNzKV0pXG4gICAgfTtcbn1cbi8qKlxuVGhlIHN0YXRlIGVmZmVjdCB0aGF0IHVwZGF0ZXMgdGhlIHNldCBvZiBhY3RpdmUgZGlhZ25vc3RpY3MuIENhblxuYmUgdXNlZnVsIHdoZW4gd3JpdGluZyBhbiBleHRlbnNpb24gdGhhdCBuZWVkcyB0byB0cmFjayB0aGVzZS5cbiovXG5jb25zdCBzZXREaWFnbm9zdGljc0VmZmVjdCA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcbmNvbnN0IHRvZ2dsZVBhbmVsID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSgpO1xuY29uc3QgbW92ZVBhbmVsU2VsZWN0aW9uID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSgpO1xuY29uc3QgbGludFN0YXRlID0gLypAX19QVVJFX18qL1N0YXRlRmllbGQuZGVmaW5lKHtcbiAgICBjcmVhdGUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgTGludFN0YXRlKERlY29yYXRpb24ubm9uZSwgbnVsbCwgbnVsbCk7XG4gICAgfSxcbiAgICB1cGRhdGUodmFsdWUsIHRyKSB7XG4gICAgICAgIGlmICh0ci5kb2NDaGFuZ2VkKSB7XG4gICAgICAgICAgICBsZXQgbWFwcGVkID0gdmFsdWUuZGlhZ25vc3RpY3MubWFwKHRyLmNoYW5nZXMpLCBzZWxlY3RlZCA9IG51bGw7XG4gICAgICAgICAgICBpZiAodmFsdWUuc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBsZXQgc2VsUG9zID0gdHIuY2hhbmdlcy5tYXBQb3ModmFsdWUuc2VsZWN0ZWQuZnJvbSwgMSk7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWQgPSBmaW5kRGlhZ25vc3RpYyhtYXBwZWQsIHZhbHVlLnNlbGVjdGVkLmRpYWdub3N0aWMsIHNlbFBvcykgfHwgZmluZERpYWdub3N0aWMobWFwcGVkLCBudWxsLCBzZWxQb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWUgPSBuZXcgTGludFN0YXRlKG1hcHBlZCwgdmFsdWUucGFuZWwsIHNlbGVjdGVkKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgdHIuZWZmZWN0cykge1xuICAgICAgICAgICAgaWYgKGVmZmVjdC5pcyhzZXREaWFnbm9zdGljc0VmZmVjdCkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IExpbnRTdGF0ZS5pbml0KGVmZmVjdC52YWx1ZSwgdmFsdWUucGFuZWwsIHRyLnN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGVmZmVjdC5pcyh0b2dnbGVQYW5lbCkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyBMaW50U3RhdGUodmFsdWUuZGlhZ25vc3RpY3MsIGVmZmVjdC52YWx1ZSA/IExpbnRQYW5lbC5vcGVuIDogbnVsbCwgdmFsdWUuc2VsZWN0ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZWZmZWN0LmlzKG1vdmVQYW5lbFNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyBMaW50U3RhdGUodmFsdWUuZGlhZ25vc3RpY3MsIHZhbHVlLnBhbmVsLCBlZmZlY3QudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIHByb3ZpZGU6IGYgPT4gW3Nob3dQYW5lbC5mcm9tKGYsIHZhbCA9PiB2YWwucGFuZWwpLFxuICAgICAgICBFZGl0b3JWaWV3LmRlY29yYXRpb25zLmZyb20oZiwgcyA9PiBzLmRpYWdub3N0aWNzKV1cbn0pO1xuLyoqXG5SZXR1cm5zIHRoZSBudW1iZXIgb2YgYWN0aXZlIGxpbnQgZGlhZ25vc3RpY3MgaW4gdGhlIGdpdmVuIHN0YXRlLlxuKi9cbmZ1bmN0aW9uIGRpYWdub3N0aWNDb3VudChzdGF0ZSkge1xuICAgIGxldCBsaW50ID0gc3RhdGUuZmllbGQobGludFN0YXRlLCBmYWxzZSk7XG4gICAgcmV0dXJuIGxpbnQgPyBsaW50LmRpYWdub3N0aWNzLnNpemUgOiAwO1xufVxuY29uc3QgYWN0aXZlTWFyayA9IC8qQF9fUFVSRV9fKi9EZWNvcmF0aW9uLm1hcmsoeyBjbGFzczogXCJjbS1saW50UmFuZ2UgY20tbGludFJhbmdlLWFjdGl2ZVwiIH0pO1xuZnVuY3Rpb24gbGludFRvb2x0aXAodmlldywgcG9zLCBzaWRlKSB7XG4gICAgbGV0IHsgZGlhZ25vc3RpY3MgfSA9IHZpZXcuc3RhdGUuZmllbGQobGludFN0YXRlKTtcbiAgICBsZXQgZm91bmQgPSBbXSwgc3RhY2tTdGFydCA9IDJlOCwgc3RhY2tFbmQgPSAwO1xuICAgIGRpYWdub3N0aWNzLmJldHdlZW4ocG9zIC0gKHNpZGUgPCAwID8gMSA6IDApLCBwb3MgKyAoc2lkZSA+IDAgPyAxIDogMCksIChmcm9tLCB0bywgeyBzcGVjIH0pID0+IHtcbiAgICAgICAgaWYgKHBvcyA+PSBmcm9tICYmIHBvcyA8PSB0byAmJlxuICAgICAgICAgICAgKGZyb20gPT0gdG8gfHwgKChwb3MgPiBmcm9tIHx8IHNpZGUgPiAwKSAmJiAocG9zIDwgdG8gfHwgc2lkZSA8IDApKSkpIHtcbiAgICAgICAgICAgIGZvdW5kLnB1c2goc3BlYy5kaWFnbm9zdGljKTtcbiAgICAgICAgICAgIHN0YWNrU3RhcnQgPSBNYXRoLm1pbihmcm9tLCBzdGFja1N0YXJ0KTtcbiAgICAgICAgICAgIHN0YWNrRW5kID0gTWF0aC5tYXgodG8sIHN0YWNrRW5kKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGxldCBkaWFnbm9zdGljRmlsdGVyID0gdmlldy5zdGF0ZS5mYWNldChsaW50Q29uZmlnKS50b29sdGlwRmlsdGVyO1xuICAgIGlmIChkaWFnbm9zdGljRmlsdGVyKVxuICAgICAgICBmb3VuZCA9IGRpYWdub3N0aWNGaWx0ZXIoZm91bmQpO1xuICAgIGlmICghZm91bmQubGVuZ3RoKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4ge1xuICAgICAgICBwb3M6IHN0YWNrU3RhcnQsXG4gICAgICAgIGVuZDogc3RhY2tFbmQsXG4gICAgICAgIGFib3ZlOiB2aWV3LnN0YXRlLmRvYy5saW5lQXQoc3RhY2tTdGFydCkudG8gPCBzdGFja0VuZCxcbiAgICAgICAgY3JlYXRlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgZG9tOiBkaWFnbm9zdGljc1Rvb2x0aXAodmlldywgZm91bmQpIH07XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gZGlhZ25vc3RpY3NUb29sdGlwKHZpZXcsIGRpYWdub3N0aWNzKSB7XG4gICAgcmV0dXJuIGVsdChcInVsXCIsIHsgY2xhc3M6IFwiY20tdG9vbHRpcC1saW50XCIgfSwgZGlhZ25vc3RpY3MubWFwKGQgPT4gcmVuZGVyRGlhZ25vc3RpYyh2aWV3LCBkLCBmYWxzZSkpKTtcbn1cbi8qKlxuQ29tbWFuZCB0byBvcGVuIGFuZCBmb2N1cyB0aGUgbGludCBwYW5lbC5cbiovXG5jb25zdCBvcGVuTGludFBhbmVsID0gKHZpZXcpID0+IHtcbiAgICBsZXQgZmllbGQgPSB2aWV3LnN0YXRlLmZpZWxkKGxpbnRTdGF0ZSwgZmFsc2UpO1xuICAgIGlmICghZmllbGQgfHwgIWZpZWxkLnBhbmVsKVxuICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogbWF5YmVFbmFibGVMaW50KHZpZXcuc3RhdGUsIFt0b2dnbGVQYW5lbC5vZih0cnVlKV0pIH0pO1xuICAgIGxldCBwYW5lbCA9IGdldFBhbmVsKHZpZXcsIExpbnRQYW5lbC5vcGVuKTtcbiAgICBpZiAocGFuZWwpXG4gICAgICAgIHBhbmVsLmRvbS5xdWVyeVNlbGVjdG9yKFwiLmNtLXBhbmVsLWxpbnQgdWxcIikuZm9jdXMoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbkNvbW1hbmQgdG8gY2xvc2UgdGhlIGxpbnQgcGFuZWwsIHdoZW4gb3Blbi5cbiovXG5jb25zdCBjbG9zZUxpbnRQYW5lbCA9ICh2aWV3KSA9PiB7XG4gICAgbGV0IGZpZWxkID0gdmlldy5zdGF0ZS5maWVsZChsaW50U3RhdGUsIGZhbHNlKTtcbiAgICBpZiAoIWZpZWxkIHx8ICFmaWVsZC5wYW5lbClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiB0b2dnbGVQYW5lbC5vZihmYWxzZSkgfSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gdG8gdGhlIG5leHQgZGlhZ25vc3RpYy5cbiovXG5jb25zdCBuZXh0RGlhZ25vc3RpYyA9ICh2aWV3KSA9PiB7XG4gICAgbGV0IGZpZWxkID0gdmlldy5zdGF0ZS5maWVsZChsaW50U3RhdGUsIGZhbHNlKTtcbiAgICBpZiAoIWZpZWxkKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW4sIG5leHQgPSBmaWVsZC5kaWFnbm9zdGljcy5pdGVyKHNlbC50byArIDEpO1xuICAgIGlmICghbmV4dC52YWx1ZSkge1xuICAgICAgICBuZXh0ID0gZmllbGQuZGlhZ25vc3RpY3MuaXRlcigwKTtcbiAgICAgICAgaWYgKCFuZXh0LnZhbHVlIHx8IG5leHQuZnJvbSA9PSBzZWwuZnJvbSAmJiBuZXh0LnRvID09IHNlbC50bylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmlldy5kaXNwYXRjaCh7IHNlbGVjdGlvbjogeyBhbmNob3I6IG5leHQuZnJvbSwgaGVhZDogbmV4dC50byB9LCBzY3JvbGxJbnRvVmlldzogdHJ1ZSB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiB0byB0aGUgcHJldmlvdXMgZGlhZ25vc3RpYy5cbiovXG5jb25zdCBwcmV2aW91c0RpYWdub3N0aWMgPSAodmlldykgPT4ge1xuICAgIGxldCB7IHN0YXRlIH0gPSB2aWV3LCBmaWVsZCA9IHN0YXRlLmZpZWxkKGxpbnRTdGF0ZSwgZmFsc2UpO1xuICAgIGlmICghZmllbGQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgc2VsID0gc3RhdGUuc2VsZWN0aW9uLm1haW47XG4gICAgbGV0IHByZXZGcm9tLCBwcmV2VG8sIGxhc3RGcm9tLCBsYXN0VG87XG4gICAgZmllbGQuZGlhZ25vc3RpY3MuYmV0d2VlbigwLCBzdGF0ZS5kb2MubGVuZ3RoLCAoZnJvbSwgdG8pID0+IHtcbiAgICAgICAgaWYgKHRvIDwgc2VsLnRvICYmIChwcmV2RnJvbSA9PSBudWxsIHx8IHByZXZGcm9tIDwgZnJvbSkpIHtcbiAgICAgICAgICAgIHByZXZGcm9tID0gZnJvbTtcbiAgICAgICAgICAgIHByZXZUbyA9IHRvO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXN0RnJvbSA9PSBudWxsIHx8IGZyb20gPiBsYXN0RnJvbSkge1xuICAgICAgICAgICAgbGFzdEZyb20gPSBmcm9tO1xuICAgICAgICAgICAgbGFzdFRvID0gdG87XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAobGFzdEZyb20gPT0gbnVsbCB8fCBwcmV2RnJvbSA9PSBudWxsICYmIGxhc3RGcm9tID09IHNlbC5mcm9tKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdmlldy5kaXNwYXRjaCh7IHNlbGVjdGlvbjogeyBhbmNob3I6IHByZXZGcm9tICE9PSBudWxsICYmIHByZXZGcm9tICE9PSB2b2lkIDAgPyBwcmV2RnJvbSA6IGxhc3RGcm9tLCBoZWFkOiBwcmV2VG8gIT09IG51bGwgJiYgcHJldlRvICE9PSB2b2lkIDAgPyBwcmV2VG8gOiBsYXN0VG8gfSwgc2Nyb2xsSW50b1ZpZXc6IHRydWUgfSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5BIHNldCBvZiBkZWZhdWx0IGtleSBiaW5kaW5ncyBmb3IgdGhlIGxpbnQgZnVuY3Rpb25hbGl0eS5cblxuLSBDdHJsLVNoaWZ0LW0gKENtZC1TaGlmdC1tIG9uIG1hY09TKTogW2BvcGVuTGludFBhbmVsYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsaW50Lm9wZW5MaW50UGFuZWwpXG4tIEY4OiBbYG5leHREaWFnbm9zdGljYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsaW50Lm5leHREaWFnbm9zdGljKVxuKi9cbmNvbnN0IGxpbnRLZXltYXAgPSBbXG4gICAgeyBrZXk6IFwiTW9kLVNoaWZ0LW1cIiwgcnVuOiBvcGVuTGludFBhbmVsLCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsga2V5OiBcIkY4XCIsIHJ1bjogbmV4dERpYWdub3N0aWMgfVxuXTtcbmNvbnN0IGxpbnRQbHVnaW4gPSAvKkBfX1BVUkVfXyovVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy50aW1lb3V0ID0gLTE7XG4gICAgICAgIHRoaXMuc2V0ID0gdHJ1ZTtcbiAgICAgICAgbGV0IHsgZGVsYXkgfSA9IHZpZXcuc3RhdGUuZmFjZXQobGludENvbmZpZyk7XG4gICAgICAgIHRoaXMubGludFRpbWUgPSBEYXRlLm5vdygpICsgZGVsYXk7XG4gICAgICAgIHRoaXMucnVuID0gdGhpcy5ydW4uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy50aW1lb3V0ID0gc2V0VGltZW91dCh0aGlzLnJ1biwgZGVsYXkpO1xuICAgIH1cbiAgICBydW4oKSB7XG4gICAgICAgIGxldCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICBpZiAobm93IDwgdGhpcy5saW50VGltZSAtIDEwKSB7XG4gICAgICAgICAgICB0aGlzLnRpbWVvdXQgPSBzZXRUaW1lb3V0KHRoaXMucnVuLCB0aGlzLmxpbnRUaW1lIC0gbm93KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2V0ID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgeyBzdGF0ZSB9ID0gdGhpcy52aWV3LCB7IHNvdXJjZXMgfSA9IHN0YXRlLmZhY2V0KGxpbnRDb25maWcpO1xuICAgICAgICAgICAgUHJvbWlzZS5hbGwoc291cmNlcy5tYXAoc291cmNlID0+IFByb21pc2UucmVzb2x2ZShzb3VyY2UodGhpcy52aWV3KSkpKS50aGVuKGFubm90YXRpb25zID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgYWxsID0gYW5ub3RhdGlvbnMucmVkdWNlKChhLCBiKSA9PiBhLmNvbmNhdChiKSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudmlldy5zdGF0ZS5kb2MgPT0gc3RhdGUuZG9jKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2goc2V0RGlhZ25vc3RpY3ModGhpcy52aWV3LnN0YXRlLCBhbGwpKTtcbiAgICAgICAgICAgIH0sIGVycm9yID0+IHsgbG9nRXhjZXB0aW9uKHRoaXMudmlldy5zdGF0ZSwgZXJyb3IpOyB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIGxldCBjb25maWcgPSB1cGRhdGUuc3RhdGUuZmFjZXQobGludENvbmZpZyk7XG4gICAgICAgIGlmICh1cGRhdGUuZG9jQ2hhbmdlZCB8fCBjb25maWcgIT0gdXBkYXRlLnN0YXJ0U3RhdGUuZmFjZXQobGludENvbmZpZykgfHxcbiAgICAgICAgICAgIGNvbmZpZy5uZWVkc1JlZnJlc2ggJiYgY29uZmlnLm5lZWRzUmVmcmVzaCh1cGRhdGUpKSB7XG4gICAgICAgICAgICB0aGlzLmxpbnRUaW1lID0gRGF0ZS5ub3coKSArIGNvbmZpZy5kZWxheTtcbiAgICAgICAgICAgIGlmICghdGhpcy5zZXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy50aW1lb3V0ID0gc2V0VGltZW91dCh0aGlzLnJ1biwgY29uZmlnLmRlbGF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3JjZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2V0KSB7XG4gICAgICAgICAgICB0aGlzLmxpbnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIHRoaXMucnVuKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dCk7XG4gICAgfVxufSk7XG5jb25zdCBsaW50Q29uZmlnID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZShpbnB1dCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7IHNvdXJjZXM6IGlucHV0Lm1hcChpID0+IGkuc291cmNlKSB9LCBjb21iaW5lQ29uZmlnKGlucHV0Lm1hcChpID0+IGkuY29uZmlnKSwge1xuICAgICAgICAgICAgZGVsYXk6IDc1MCxcbiAgICAgICAgICAgIG1hcmtlckZpbHRlcjogbnVsbCxcbiAgICAgICAgICAgIHRvb2x0aXBGaWx0ZXI6IG51bGwsXG4gICAgICAgICAgICBuZWVkc1JlZnJlc2g6IG51bGxcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbmVlZHNSZWZyZXNoOiAoYSwgYikgPT4gIWEgPyBiIDogIWIgPyBhIDogdSA9PiBhKHUpIHx8IGIodSlcbiAgICAgICAgfSkpO1xuICAgIH1cbn0pO1xuLyoqXG5HaXZlbiBhIGRpYWdub3N0aWMgc291cmNlLCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgYW4gZXh0ZW5zaW9uIHRoYXRcbmVuYWJsZXMgbGludGluZyB3aXRoIHRoYXQgc291cmNlLiBJdCB3aWxsIGJlIGNhbGxlZCB3aGVuZXZlciB0aGVcbmVkaXRvciBpcyBpZGxlIChhZnRlciBpdHMgY29udGVudCBjaGFuZ2VkKS5cbiovXG5mdW5jdGlvbiBsaW50ZXIoc291cmNlLCBjb25maWcgPSB7fSkge1xuICAgIHJldHVybiBbXG4gICAgICAgIGxpbnRDb25maWcub2YoeyBzb3VyY2UsIGNvbmZpZyB9KSxcbiAgICAgICAgbGludFBsdWdpbixcbiAgICAgICAgbGludEV4dGVuc2lvbnNcbiAgICBdO1xufVxuLyoqXG5Gb3JjZXMgYW55IGxpbnRlcnMgW2NvbmZpZ3VyZWRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGludC5saW50ZXIpIHRvIHJ1biB3aGVuIHRoZVxuZWRpdG9yIGlzIGlkbGUgdG8gcnVuIHJpZ2h0IGF3YXkuXG4qL1xuZnVuY3Rpb24gZm9yY2VMaW50aW5nKHZpZXcpIHtcbiAgICBsZXQgcGx1Z2luID0gdmlldy5wbHVnaW4obGludFBsdWdpbik7XG4gICAgaWYgKHBsdWdpbilcbiAgICAgICAgcGx1Z2luLmZvcmNlKCk7XG59XG5mdW5jdGlvbiBhc3NpZ25LZXlzKGFjdGlvbnMpIHtcbiAgICBsZXQgYXNzaWduZWQgPSBbXTtcbiAgICBpZiAoYWN0aW9ucylcbiAgICAgICAgYWN0aW9uczogZm9yIChsZXQgeyBuYW1lIH0gb2YgYWN0aW9ucykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNoID0gbmFtZVtpXTtcbiAgICAgICAgICAgICAgICBpZiAoL1thLXpBLVpdLy50ZXN0KGNoKSAmJiAhYXNzaWduZWQuc29tZShjID0+IGMudG9Mb3dlckNhc2UoKSA9PSBjaC50b0xvd2VyQ2FzZSgpKSkge1xuICAgICAgICAgICAgICAgICAgICBhc3NpZ25lZC5wdXNoKGNoKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWUgYWN0aW9ucztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NpZ25lZC5wdXNoKFwiXCIpO1xuICAgICAgICB9XG4gICAgcmV0dXJuIGFzc2lnbmVkO1xufVxuZnVuY3Rpb24gcmVuZGVyRGlhZ25vc3RpYyh2aWV3LCBkaWFnbm9zdGljLCBpblBhbmVsKSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCBrZXlzID0gaW5QYW5lbCA/IGFzc2lnbktleXMoZGlhZ25vc3RpYy5hY3Rpb25zKSA6IFtdO1xuICAgIHJldHVybiBlbHQoXCJsaVwiLCB7IGNsYXNzOiBcImNtLWRpYWdub3N0aWMgY20tZGlhZ25vc3RpYy1cIiArIGRpYWdub3N0aWMuc2V2ZXJpdHkgfSwgZWx0KFwic3BhblwiLCB7IGNsYXNzOiBcImNtLWRpYWdub3N0aWNUZXh0XCIgfSwgZGlhZ25vc3RpYy5yZW5kZXJNZXNzYWdlID8gZGlhZ25vc3RpYy5yZW5kZXJNZXNzYWdlKCkgOiBkaWFnbm9zdGljLm1lc3NhZ2UpLCAoX2EgPSBkaWFnbm9zdGljLmFjdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXAoKGFjdGlvbiwgaSkgPT4ge1xuICAgICAgICBsZXQgZmlyZWQgPSBmYWxzZSwgY2xpY2sgPSAoZSkgPT4ge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgaWYgKGZpcmVkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGZpcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGxldCBmb3VuZCA9IGZpbmREaWFnbm9zdGljKHZpZXcuc3RhdGUuZmllbGQobGludFN0YXRlKS5kaWFnbm9zdGljcywgZGlhZ25vc3RpYyk7XG4gICAgICAgICAgICBpZiAoZm91bmQpXG4gICAgICAgICAgICAgICAgYWN0aW9uLmFwcGx5KHZpZXcsIGZvdW5kLmZyb20sIGZvdW5kLnRvKTtcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHsgbmFtZSB9ID0gYWN0aW9uLCBrZXlJbmRleCA9IGtleXNbaV0gPyBuYW1lLmluZGV4T2Yoa2V5c1tpXSkgOiAtMTtcbiAgICAgICAgbGV0IG5hbWVFbHQgPSBrZXlJbmRleCA8IDAgPyBuYW1lIDogW25hbWUuc2xpY2UoMCwga2V5SW5kZXgpLFxuICAgICAgICAgICAgZWx0KFwidVwiLCBuYW1lLnNsaWNlKGtleUluZGV4LCBrZXlJbmRleCArIDEpKSxcbiAgICAgICAgICAgIG5hbWUuc2xpY2Uoa2V5SW5kZXggKyAxKV07XG4gICAgICAgIHJldHVybiBlbHQoXCJidXR0b25cIiwge1xuICAgICAgICAgICAgdHlwZTogXCJidXR0b25cIixcbiAgICAgICAgICAgIGNsYXNzOiBcImNtLWRpYWdub3N0aWNBY3Rpb25cIixcbiAgICAgICAgICAgIG9uY2xpY2s6IGNsaWNrLFxuICAgICAgICAgICAgb25tb3VzZWRvd246IGNsaWNrLFxuICAgICAgICAgICAgXCJhcmlhLWxhYmVsXCI6IGAgQWN0aW9uOiAke25hbWV9JHtrZXlJbmRleCA8IDAgPyBcIlwiIDogYCAoYWNjZXNzIGtleSBcIiR7a2V5c1tpXX0pXCJgfS5gXG4gICAgICAgIH0sIG5hbWVFbHQpO1xuICAgIH0pLCBkaWFnbm9zdGljLnNvdXJjZSAmJiBlbHQoXCJkaXZcIiwgeyBjbGFzczogXCJjbS1kaWFnbm9zdGljU291cmNlXCIgfSwgZGlhZ25vc3RpYy5zb3VyY2UpKTtcbn1cbmNsYXNzIERpYWdub3N0aWNXaWRnZXQgZXh0ZW5kcyBXaWRnZXRUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcihkaWFnbm9zdGljKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZGlhZ25vc3RpYyA9IGRpYWdub3N0aWM7XG4gICAgfVxuICAgIGVxKG90aGVyKSB7IHJldHVybiBvdGhlci5kaWFnbm9zdGljID09IHRoaXMuZGlhZ25vc3RpYzsgfVxuICAgIHRvRE9NKCkge1xuICAgICAgICByZXR1cm4gZWx0KFwic3BhblwiLCB7IGNsYXNzOiBcImNtLWxpbnRQb2ludCBjbS1saW50UG9pbnQtXCIgKyB0aGlzLmRpYWdub3N0aWMuc2V2ZXJpdHkgfSk7XG4gICAgfVxufVxuY2xhc3MgUGFuZWxJdGVtIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3LCBkaWFnbm9zdGljKSB7XG4gICAgICAgIHRoaXMuZGlhZ25vc3RpYyA9IGRpYWdub3N0aWM7XG4gICAgICAgIHRoaXMuaWQgPSBcIml0ZW1fXCIgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZmZmKS50b1N0cmluZygxNik7XG4gICAgICAgIHRoaXMuZG9tID0gcmVuZGVyRGlhZ25vc3RpYyh2aWV3LCBkaWFnbm9zdGljLCB0cnVlKTtcbiAgICAgICAgdGhpcy5kb20uaWQgPSB0aGlzLmlkO1xuICAgICAgICB0aGlzLmRvbS5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwib3B0aW9uXCIpO1xuICAgIH1cbn1cbmNsYXNzIExpbnRQYW5lbCB7XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLml0ZW1zID0gW107XG4gICAgICAgIGxldCBvbmtleWRvd24gPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudC5rZXlDb2RlID09IDI3KSB7IC8vIEVzY2FwZVxuICAgICAgICAgICAgICAgIGNsb3NlTGludFBhbmVsKHRoaXMudmlldyk7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3LmZvY3VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChldmVudC5rZXlDb2RlID09IDM4IHx8IGV2ZW50LmtleUNvZGUgPT0gMzMpIHsgLy8gQXJyb3dVcCwgUGFnZVVwXG4gICAgICAgICAgICAgICAgdGhpcy5tb3ZlU2VsZWN0aW9uKCh0aGlzLnNlbGVjdGVkSW5kZXggLSAxICsgdGhpcy5pdGVtcy5sZW5ndGgpICUgdGhpcy5pdGVtcy5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnQua2V5Q29kZSA9PSA0MCB8fCBldmVudC5rZXlDb2RlID09IDM0KSB7IC8vIEFycm93RG93biwgUGFnZURvd25cbiAgICAgICAgICAgICAgICB0aGlzLm1vdmVTZWxlY3Rpb24oKHRoaXMuc2VsZWN0ZWRJbmRleCArIDEpICUgdGhpcy5pdGVtcy5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnQua2V5Q29kZSA9PSAzNikgeyAvLyBIb21lXG4gICAgICAgICAgICAgICAgdGhpcy5tb3ZlU2VsZWN0aW9uKDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnQua2V5Q29kZSA9PSAzNSkgeyAvLyBFbmRcbiAgICAgICAgICAgICAgICB0aGlzLm1vdmVTZWxlY3Rpb24odGhpcy5pdGVtcy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50LmtleUNvZGUgPT0gMTMpIHsgLy8gRW50ZXJcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXcuZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50LmtleUNvZGUgPj0gNjUgJiYgZXZlbnQua2V5Q29kZSA8PSA5MCAmJiB0aGlzLnNlbGVjdGVkSW5kZXggPj0gMCkgeyAvLyBBLVpcbiAgICAgICAgICAgICAgICBsZXQgeyBkaWFnbm9zdGljIH0gPSB0aGlzLml0ZW1zW3RoaXMuc2VsZWN0ZWRJbmRleF0sIGtleXMgPSBhc3NpZ25LZXlzKGRpYWdub3N0aWMuYWN0aW9ucyk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5c1tpXS50b1VwcGVyQ2FzZSgpLmNoYXJDb2RlQXQoMCkgPT0gZXZlbnQua2V5Q29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZvdW5kID0gZmluZERpYWdub3N0aWModGhpcy52aWV3LnN0YXRlLmZpZWxkKGxpbnRTdGF0ZSkuZGlhZ25vc3RpY3MsIGRpYWdub3N0aWMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZvdW5kKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpYWdub3N0aWMuYWN0aW9uc1tpXS5hcHBseSh2aWV3LCBmb3VuZC5mcm9tLCBmb3VuZC50byk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH07XG4gICAgICAgIGxldCBvbmNsaWNrID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pdGVtc1tpXS5kb20uY29udGFpbnMoZXZlbnQudGFyZ2V0KSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb3ZlU2VsZWN0aW9uKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmxpc3QgPSBlbHQoXCJ1bFwiLCB7XG4gICAgICAgICAgICB0YWJJbmRleDogMCxcbiAgICAgICAgICAgIHJvbGU6IFwibGlzdGJveFwiLFxuICAgICAgICAgICAgXCJhcmlhLWxhYmVsXCI6IHRoaXMudmlldy5zdGF0ZS5waHJhc2UoXCJEaWFnbm9zdGljc1wiKSxcbiAgICAgICAgICAgIG9ua2V5ZG93bixcbiAgICAgICAgICAgIG9uY2xpY2tcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZG9tID0gZWx0KFwiZGl2XCIsIHsgY2xhc3M6IFwiY20tcGFuZWwtbGludFwiIH0sIHRoaXMubGlzdCwgZWx0KFwiYnV0dG9uXCIsIHtcbiAgICAgICAgICAgIHR5cGU6IFwiYnV0dG9uXCIsXG4gICAgICAgICAgICBuYW1lOiBcImNsb3NlXCIsXG4gICAgICAgICAgICBcImFyaWEtbGFiZWxcIjogdGhpcy52aWV3LnN0YXRlLnBocmFzZShcImNsb3NlXCIpLFxuICAgICAgICAgICAgb25jbGljazogKCkgPT4gY2xvc2VMaW50UGFuZWwodGhpcy52aWV3KVxuICAgICAgICB9LCBcIsOXXCIpKTtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9XG4gICAgZ2V0IHNlbGVjdGVkSW5kZXgoKSB7XG4gICAgICAgIGxldCBzZWxlY3RlZCA9IHRoaXMudmlldy5zdGF0ZS5maWVsZChsaW50U3RhdGUpLnNlbGVjdGVkO1xuICAgICAgICBpZiAoIXNlbGVjdGVkKVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuaXRlbXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAodGhpcy5pdGVtc1tpXS5kaWFnbm9zdGljID09IHNlbGVjdGVkLmRpYWdub3N0aWMpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgdXBkYXRlKCkge1xuICAgICAgICBsZXQgeyBkaWFnbm9zdGljcywgc2VsZWN0ZWQgfSA9IHRoaXMudmlldy5zdGF0ZS5maWVsZChsaW50U3RhdGUpO1xuICAgICAgICBsZXQgaSA9IDAsIG5lZWRzU3luYyA9IGZhbHNlLCBuZXdTZWxlY3RlZEl0ZW0gPSBudWxsO1xuICAgICAgICBkaWFnbm9zdGljcy5iZXR3ZWVuKDAsIHRoaXMudmlldy5zdGF0ZS5kb2MubGVuZ3RoLCAoX3N0YXJ0LCBfZW5kLCB7IHNwZWMgfSkgPT4ge1xuICAgICAgICAgICAgbGV0IGZvdW5kID0gLTEsIGl0ZW07XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gaTsgaiA8IHRoaXMuaXRlbXMubGVuZ3RoOyBqKyspXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXRlbXNbal0uZGlhZ25vc3RpYyA9PSBzcGVjLmRpYWdub3N0aWMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSBqO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZm91bmQgPCAwKSB7XG4gICAgICAgICAgICAgICAgaXRlbSA9IG5ldyBQYW5lbEl0ZW0odGhpcy52aWV3LCBzcGVjLmRpYWdub3N0aWMpO1xuICAgICAgICAgICAgICAgIHRoaXMuaXRlbXMuc3BsaWNlKGksIDAsIGl0ZW0pO1xuICAgICAgICAgICAgICAgIG5lZWRzU3luYyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpdGVtID0gdGhpcy5pdGVtc1tmb3VuZF07XG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kID4gaSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLml0ZW1zLnNwbGljZShpLCBmb3VuZCAtIGkpO1xuICAgICAgICAgICAgICAgICAgICBuZWVkc1N5bmMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxlY3RlZCAmJiBpdGVtLmRpYWdub3N0aWMgPT0gc2VsZWN0ZWQuZGlhZ25vc3RpYykge1xuICAgICAgICAgICAgICAgIGlmICghaXRlbS5kb20uaGFzQXR0cmlidXRlKFwiYXJpYS1zZWxlY3RlZFwiKSkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLmRvbS5zZXRBdHRyaWJ1dGUoXCJhcmlhLXNlbGVjdGVkXCIsIFwidHJ1ZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgbmV3U2VsZWN0ZWRJdGVtID0gaXRlbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpdGVtLmRvbS5oYXNBdHRyaWJ1dGUoXCJhcmlhLXNlbGVjdGVkXCIpKSB7XG4gICAgICAgICAgICAgICAgaXRlbS5kb20ucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1zZWxlY3RlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfSk7XG4gICAgICAgIHdoaWxlIChpIDwgdGhpcy5pdGVtcy5sZW5ndGggJiYgISh0aGlzLml0ZW1zLmxlbmd0aCA9PSAxICYmIHRoaXMuaXRlbXNbMF0uZGlhZ25vc3RpYy5mcm9tIDwgMCkpIHtcbiAgICAgICAgICAgIG5lZWRzU3luYyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLml0ZW1zLnBvcCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLml0ZW1zLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICB0aGlzLml0ZW1zLnB1c2gobmV3IFBhbmVsSXRlbSh0aGlzLnZpZXcsIHtcbiAgICAgICAgICAgICAgICBmcm9tOiAtMSwgdG86IC0xLFxuICAgICAgICAgICAgICAgIHNldmVyaXR5OiBcImluZm9cIixcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiB0aGlzLnZpZXcuc3RhdGUucGhyYXNlKFwiTm8gZGlhZ25vc3RpY3NcIilcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIG5lZWRzU3luYyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld1NlbGVjdGVkSXRlbSkge1xuICAgICAgICAgICAgdGhpcy5saXN0LnNldEF0dHJpYnV0ZShcImFyaWEtYWN0aXZlZGVzY2VuZGFudFwiLCBuZXdTZWxlY3RlZEl0ZW0uaWQpO1xuICAgICAgICAgICAgdGhpcy52aWV3LnJlcXVlc3RNZWFzdXJlKHtcbiAgICAgICAgICAgICAgICBrZXk6IHRoaXMsXG4gICAgICAgICAgICAgICAgcmVhZDogKCkgPT4gKHsgc2VsOiBuZXdTZWxlY3RlZEl0ZW0uZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBwYW5lbDogdGhpcy5saXN0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIH0pLFxuICAgICAgICAgICAgICAgIHdyaXRlOiAoeyBzZWwsIHBhbmVsIH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNjYWxlWSA9IHBhbmVsLmhlaWdodCAvIHRoaXMubGlzdC5vZmZzZXRIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWwudG9wIDwgcGFuZWwudG9wKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0LnNjcm9sbFRvcCAtPSAocGFuZWwudG9wIC0gc2VsLnRvcCkgLyBzY2FsZVk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNlbC5ib3R0b20gPiBwYW5lbC5ib3R0b20pXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxpc3Quc2Nyb2xsVG9wICs9IChzZWwuYm90dG9tIC0gcGFuZWwuYm90dG9tKSAvIHNjYWxlWTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnNlbGVjdGVkSW5kZXggPCAwKSB7XG4gICAgICAgICAgICB0aGlzLmxpc3QucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1hY3RpdmVkZXNjZW5kYW50XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZWVkc1N5bmMpXG4gICAgICAgICAgICB0aGlzLnN5bmMoKTtcbiAgICB9XG4gICAgc3luYygpIHtcbiAgICAgICAgbGV0IGRvbVBvcyA9IHRoaXMubGlzdC5maXJzdENoaWxkO1xuICAgICAgICBmdW5jdGlvbiBybSgpIHtcbiAgICAgICAgICAgIGxldCBwcmV2ID0gZG9tUG9zO1xuICAgICAgICAgICAgZG9tUG9zID0gcHJldi5uZXh0U2libGluZztcbiAgICAgICAgICAgIHByZXYucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaXRlbSBvZiB0aGlzLml0ZW1zKSB7XG4gICAgICAgICAgICBpZiAoaXRlbS5kb20ucGFyZW50Tm9kZSA9PSB0aGlzLmxpc3QpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoZG9tUG9zICE9IGl0ZW0uZG9tKVxuICAgICAgICAgICAgICAgICAgICBybSgpO1xuICAgICAgICAgICAgICAgIGRvbVBvcyA9IGl0ZW0uZG9tLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5saXN0Lmluc2VydEJlZm9yZShpdGVtLmRvbSwgZG9tUG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoZG9tUG9zKVxuICAgICAgICAgICAgcm0oKTtcbiAgICB9XG4gICAgbW92ZVNlbGVjdGlvbihzZWxlY3RlZEluZGV4KSB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGVkSW5kZXggPCAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgZmllbGQgPSB0aGlzLnZpZXcuc3RhdGUuZmllbGQobGludFN0YXRlKTtcbiAgICAgICAgbGV0IHNlbGVjdGlvbiA9IGZpbmREaWFnbm9zdGljKGZpZWxkLmRpYWdub3N0aWNzLCB0aGlzLml0ZW1zW3NlbGVjdGVkSW5kZXhdLmRpYWdub3N0aWMpO1xuICAgICAgICBpZiAoIXNlbGVjdGlvbilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy52aWV3LmRpc3BhdGNoKHtcbiAgICAgICAgICAgIHNlbGVjdGlvbjogeyBhbmNob3I6IHNlbGVjdGlvbi5mcm9tLCBoZWFkOiBzZWxlY3Rpb24udG8gfSxcbiAgICAgICAgICAgIHNjcm9sbEludG9WaWV3OiB0cnVlLFxuICAgICAgICAgICAgZWZmZWN0czogbW92ZVBhbmVsU2VsZWN0aW9uLm9mKHNlbGVjdGlvbilcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBvcGVuKHZpZXcpIHsgcmV0dXJuIG5ldyBMaW50UGFuZWwodmlldyk7IH1cbn1cbmZ1bmN0aW9uIHN2Zyhjb250ZW50LCBhdHRycyA9IGB2aWV3Qm94PVwiMCAwIDQwIDQwXCJgKSB7XG4gICAgcmV0dXJuIGB1cmwoJ2RhdGE6aW1hZ2Uvc3ZnK3htbCw8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiAke2F0dHJzfT4ke2VuY29kZVVSSUNvbXBvbmVudChjb250ZW50KX08L3N2Zz4nKWA7XG59XG5mdW5jdGlvbiB1bmRlcmxpbmUoY29sb3IpIHtcbiAgICByZXR1cm4gc3ZnKGA8cGF0aCBkPVwibTAgMi41IGwyIC0xLjUgbDEgMCBsMiAxLjUgbDEgMFwiIHN0cm9rZT1cIiR7Y29sb3J9XCIgZmlsbD1cIm5vbmVcIiBzdHJva2Utd2lkdGg9XCIuN1wiLz5gLCBgd2lkdGg9XCI2XCIgaGVpZ2h0PVwiM1wiYCk7XG59XG5jb25zdCBiYXNlVGhlbWUgPSAvKkBfX1BVUkVfXyovRWRpdG9yVmlldy5iYXNlVGhlbWUoe1xuICAgIFwiLmNtLWRpYWdub3N0aWNcIjoge1xuICAgICAgICBwYWRkaW5nOiBcIjNweCA2cHggM3B4IDhweFwiLFxuICAgICAgICBtYXJnaW5MZWZ0OiBcIi0xcHhcIixcbiAgICAgICAgZGlzcGxheTogXCJibG9ja1wiLFxuICAgICAgICB3aGl0ZVNwYWNlOiBcInByZS13cmFwXCJcbiAgICB9LFxuICAgIFwiLmNtLWRpYWdub3N0aWMtZXJyb3JcIjogeyBib3JkZXJMZWZ0OiBcIjVweCBzb2xpZCAjZDExXCIgfSxcbiAgICBcIi5jbS1kaWFnbm9zdGljLXdhcm5pbmdcIjogeyBib3JkZXJMZWZ0OiBcIjVweCBzb2xpZCBvcmFuZ2VcIiB9LFxuICAgIFwiLmNtLWRpYWdub3N0aWMtaW5mb1wiOiB7IGJvcmRlckxlZnQ6IFwiNXB4IHNvbGlkICM5OTlcIiB9LFxuICAgIFwiLmNtLWRpYWdub3N0aWMtaGludFwiOiB7IGJvcmRlckxlZnQ6IFwiNXB4IHNvbGlkICM2NmRcIiB9LFxuICAgIFwiLmNtLWRpYWdub3N0aWNBY3Rpb25cIjoge1xuICAgICAgICBmb250OiBcImluaGVyaXRcIixcbiAgICAgICAgYm9yZGVyOiBcIm5vbmVcIixcbiAgICAgICAgcGFkZGluZzogXCIycHggNHB4XCIsXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjNDQ0XCIsXG4gICAgICAgIGNvbG9yOiBcIndoaXRlXCIsXG4gICAgICAgIGJvcmRlclJhZGl1czogXCIzcHhcIixcbiAgICAgICAgbWFyZ2luTGVmdDogXCI4cHhcIixcbiAgICAgICAgY3Vyc29yOiBcInBvaW50ZXJcIlxuICAgIH0sXG4gICAgXCIuY20tZGlhZ25vc3RpY1NvdXJjZVwiOiB7XG4gICAgICAgIGZvbnRTaXplOiBcIjcwJVwiLFxuICAgICAgICBvcGFjaXR5OiAuN1xuICAgIH0sXG4gICAgXCIuY20tbGludFJhbmdlXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZFBvc2l0aW9uOiBcImxlZnQgYm90dG9tXCIsXG4gICAgICAgIGJhY2tncm91bmRSZXBlYXQ6IFwicmVwZWF0LXhcIixcbiAgICAgICAgcGFkZGluZ0JvdHRvbTogXCIwLjdweFwiLFxuICAgIH0sXG4gICAgXCIuY20tbGludFJhbmdlLWVycm9yXCI6IHsgYmFja2dyb3VuZEltYWdlOiAvKkBfX1BVUkVfXyovdW5kZXJsaW5lKFwiI2QxMVwiKSB9LFxuICAgIFwiLmNtLWxpbnRSYW5nZS13YXJuaW5nXCI6IHsgYmFja2dyb3VuZEltYWdlOiAvKkBfX1BVUkVfXyovdW5kZXJsaW5lKFwib3JhbmdlXCIpIH0sXG4gICAgXCIuY20tbGludFJhbmdlLWluZm9cIjogeyBiYWNrZ3JvdW5kSW1hZ2U6IC8qQF9fUFVSRV9fKi91bmRlcmxpbmUoXCIjOTk5XCIpIH0sXG4gICAgXCIuY20tbGludFJhbmdlLWhpbnRcIjogeyBiYWNrZ3JvdW5kSW1hZ2U6IC8qQF9fUFVSRV9fKi91bmRlcmxpbmUoXCIjNjZkXCIpIH0sXG4gICAgXCIuY20tbGludFJhbmdlLWFjdGl2ZVwiOiB7IGJhY2tncm91bmRDb2xvcjogXCIjZmZkZDk5ODBcIiB9LFxuICAgIFwiLmNtLXRvb2x0aXAtbGludFwiOiB7XG4gICAgICAgIHBhZGRpbmc6IDAsXG4gICAgICAgIG1hcmdpbjogMFxuICAgIH0sXG4gICAgXCIuY20tbGludFBvaW50XCI6IHtcbiAgICAgICAgcG9zaXRpb246IFwicmVsYXRpdmVcIixcbiAgICAgICAgXCImOmFmdGVyXCI6IHtcbiAgICAgICAgICAgIGNvbnRlbnQ6ICdcIlwiJyxcbiAgICAgICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICAgICAgICBib3R0b206IDAsXG4gICAgICAgICAgICBsZWZ0OiBcIi0ycHhcIixcbiAgICAgICAgICAgIGJvcmRlckxlZnQ6IFwiM3B4IHNvbGlkIHRyYW5zcGFyZW50XCIsXG4gICAgICAgICAgICBib3JkZXJSaWdodDogXCIzcHggc29saWQgdHJhbnNwYXJlbnRcIixcbiAgICAgICAgICAgIGJvcmRlckJvdHRvbTogXCI0cHggc29saWQgI2QxMVwiXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFwiLmNtLWxpbnRQb2ludC13YXJuaW5nXCI6IHtcbiAgICAgICAgXCImOmFmdGVyXCI6IHsgYm9yZGVyQm90dG9tQ29sb3I6IFwib3JhbmdlXCIgfVxuICAgIH0sXG4gICAgXCIuY20tbGludFBvaW50LWluZm9cIjoge1xuICAgICAgICBcIiY6YWZ0ZXJcIjogeyBib3JkZXJCb3R0b21Db2xvcjogXCIjOTk5XCIgfVxuICAgIH0sXG4gICAgXCIuY20tbGludFBvaW50LWhpbnRcIjoge1xuICAgICAgICBcIiY6YWZ0ZXJcIjogeyBib3JkZXJCb3R0b21Db2xvcjogXCIjNjZkXCIgfVxuICAgIH0sXG4gICAgXCIuY20tcGFuZWwuY20tcGFuZWwtbGludFwiOiB7XG4gICAgICAgIHBvc2l0aW9uOiBcInJlbGF0aXZlXCIsXG4gICAgICAgIFwiJiB1bFwiOiB7XG4gICAgICAgICAgICBtYXhIZWlnaHQ6IFwiMTAwcHhcIixcbiAgICAgICAgICAgIG92ZXJmbG93WTogXCJhdXRvXCIsXG4gICAgICAgICAgICBcIiYgW2FyaWEtc2VsZWN0ZWRdXCI6IHtcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiI2RkZFwiLFxuICAgICAgICAgICAgICAgIFwiJiB1XCI6IHsgdGV4dERlY29yYXRpb246IFwidW5kZXJsaW5lXCIgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiJjpmb2N1cyBbYXJpYS1zZWxlY3RlZF1cIjoge1xuICAgICAgICAgICAgICAgIGJhY2tncm91bmRfZmFsbGJhY2s6IFwiI2JkZlwiLFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCJIaWdobGlnaHRcIixcbiAgICAgICAgICAgICAgICBjb2xvcl9mYWxsYmFjazogXCJ3aGl0ZVwiLFxuICAgICAgICAgICAgICAgIGNvbG9yOiBcIkhpZ2hsaWdodFRleHRcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiJiB1XCI6IHsgdGV4dERlY29yYXRpb246IFwibm9uZVwiIH0sXG4gICAgICAgICAgICBwYWRkaW5nOiAwLFxuICAgICAgICAgICAgbWFyZ2luOiAwXG4gICAgICAgIH0sXG4gICAgICAgIFwiJiBbbmFtZT1jbG9zZV1cIjoge1xuICAgICAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgICAgIHRvcDogXCIwXCIsXG4gICAgICAgICAgICByaWdodDogXCIycHhcIixcbiAgICAgICAgICAgIGJhY2tncm91bmQ6IFwiaW5oZXJpdFwiLFxuICAgICAgICAgICAgYm9yZGVyOiBcIm5vbmVcIixcbiAgICAgICAgICAgIGZvbnQ6IFwiaW5oZXJpdFwiLFxuICAgICAgICAgICAgcGFkZGluZzogMCxcbiAgICAgICAgICAgIG1hcmdpbjogMFxuICAgICAgICB9XG4gICAgfVxufSk7XG5mdW5jdGlvbiBzZXZlcml0eVdlaWdodChzZXYpIHtcbiAgICByZXR1cm4gc2V2ID09IFwiZXJyb3JcIiA/IDQgOiBzZXYgPT0gXCJ3YXJuaW5nXCIgPyAzIDogc2V2ID09IFwiaW5mb1wiID8gMiA6IDE7XG59XG5jbGFzcyBMaW50R3V0dGVyTWFya2VyIGV4dGVuZHMgR3V0dGVyTWFya2VyIHtcbiAgICBjb25zdHJ1Y3RvcihkaWFnbm9zdGljcykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmRpYWdub3N0aWNzID0gZGlhZ25vc3RpY3M7XG4gICAgICAgIHRoaXMuc2V2ZXJpdHkgPSBkaWFnbm9zdGljcy5yZWR1Y2UoKG1heCwgZCkgPT4gc2V2ZXJpdHlXZWlnaHQobWF4KSA8IHNldmVyaXR5V2VpZ2h0KGQuc2V2ZXJpdHkpID8gZC5zZXZlcml0eSA6IG1heCwgXCJoaW50XCIpO1xuICAgIH1cbiAgICB0b0RPTSh2aWV3KSB7XG4gICAgICAgIGxldCBlbHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBlbHQuY2xhc3NOYW1lID0gXCJjbS1saW50LW1hcmtlciBjbS1saW50LW1hcmtlci1cIiArIHRoaXMuc2V2ZXJpdHk7XG4gICAgICAgIGxldCBkaWFnbm9zdGljcyA9IHRoaXMuZGlhZ25vc3RpY3M7XG4gICAgICAgIGxldCBkaWFnbm9zdGljc0ZpbHRlciA9IHZpZXcuc3RhdGUuZmFjZXQobGludEd1dHRlckNvbmZpZykudG9vbHRpcEZpbHRlcjtcbiAgICAgICAgaWYgKGRpYWdub3N0aWNzRmlsdGVyKVxuICAgICAgICAgICAgZGlhZ25vc3RpY3MgPSBkaWFnbm9zdGljc0ZpbHRlcihkaWFnbm9zdGljcyk7XG4gICAgICAgIGlmIChkaWFnbm9zdGljcy5sZW5ndGgpXG4gICAgICAgICAgICBlbHQub25tb3VzZW92ZXIgPSAoKSA9PiBndXR0ZXJNYXJrZXJNb3VzZU92ZXIodmlldywgZWx0LCBkaWFnbm9zdGljcyk7XG4gICAgICAgIHJldHVybiBlbHQ7XG4gICAgfVxufVxuZnVuY3Rpb24gdHJhY2tIb3Zlck9uKHZpZXcsIG1hcmtlcikge1xuICAgIGxldCBtb3VzZW1vdmUgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgbGV0IHJlY3QgPSBtYXJrZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGlmIChldmVudC5jbGllbnRYID4gcmVjdC5sZWZ0IC0gMTAgLyogSG92ZXIuTWFyZ2luICovICYmIGV2ZW50LmNsaWVudFggPCByZWN0LnJpZ2h0ICsgMTAgLyogSG92ZXIuTWFyZ2luICovICYmXG4gICAgICAgICAgICBldmVudC5jbGllbnRZID4gcmVjdC50b3AgLSAxMCAvKiBIb3Zlci5NYXJnaW4gKi8gJiYgZXZlbnQuY2xpZW50WSA8IHJlY3QuYm90dG9tICsgMTAgLyogSG92ZXIuTWFyZ2luICovKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBmb3IgKGxldCB0YXJnZXQgPSBldmVudC50YXJnZXQ7IHRhcmdldDsgdGFyZ2V0ID0gdGFyZ2V0LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIGlmICh0YXJnZXQubm9kZVR5cGUgPT0gMSAmJiB0YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKFwiY20tdG9vbHRpcC1saW50XCIpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBtb3VzZW1vdmUpO1xuICAgICAgICBpZiAodmlldy5zdGF0ZS5maWVsZChsaW50R3V0dGVyVG9vbHRpcCkpXG4gICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogc2V0TGludEd1dHRlclRvb2x0aXAub2YobnVsbCkgfSk7XG4gICAgfTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBtb3VzZW1vdmUpO1xufVxuZnVuY3Rpb24gZ3V0dGVyTWFya2VyTW91c2VPdmVyKHZpZXcsIG1hcmtlciwgZGlhZ25vc3RpY3MpIHtcbiAgICBmdW5jdGlvbiBob3ZlcmVkKCkge1xuICAgICAgICBsZXQgbGluZSA9IHZpZXcuZWxlbWVudEF0SGVpZ2h0KG1hcmtlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgKyA1IC0gdmlldy5kb2N1bWVudFRvcCk7XG4gICAgICAgIGNvbnN0IGxpbmVQb3MgPSB2aWV3LmNvb3Jkc0F0UG9zKGxpbmUuZnJvbSk7XG4gICAgICAgIGlmIChsaW5lUG9zKSB7XG4gICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogc2V0TGludEd1dHRlclRvb2x0aXAub2Yoe1xuICAgICAgICAgICAgICAgICAgICBwb3M6IGxpbmUuZnJvbSxcbiAgICAgICAgICAgICAgICAgICAgYWJvdmU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGUoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbTogZGlhZ25vc3RpY3NUb29sdGlwKHZpZXcsIGRpYWdub3N0aWNzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRDb29yZHM6ICgpID0+IG1hcmtlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pIH0pO1xuICAgICAgICB9XG4gICAgICAgIG1hcmtlci5vbm1vdXNlb3V0ID0gbWFya2VyLm9ubW91c2Vtb3ZlID0gbnVsbDtcbiAgICAgICAgdHJhY2tIb3Zlck9uKHZpZXcsIG1hcmtlcik7XG4gICAgfVxuICAgIGxldCB7IGhvdmVyVGltZSB9ID0gdmlldy5zdGF0ZS5mYWNldChsaW50R3V0dGVyQ29uZmlnKTtcbiAgICBsZXQgaG92ZXJUaW1lb3V0ID0gc2V0VGltZW91dChob3ZlcmVkLCBob3ZlclRpbWUpO1xuICAgIG1hcmtlci5vbm1vdXNlb3V0ID0gKCkgPT4ge1xuICAgICAgICBjbGVhclRpbWVvdXQoaG92ZXJUaW1lb3V0KTtcbiAgICAgICAgbWFya2VyLm9ubW91c2VvdXQgPSBtYXJrZXIub25tb3VzZW1vdmUgPSBudWxsO1xuICAgIH07XG4gICAgbWFya2VyLm9ubW91c2Vtb3ZlID0gKCkgPT4ge1xuICAgICAgICBjbGVhclRpbWVvdXQoaG92ZXJUaW1lb3V0KTtcbiAgICAgICAgaG92ZXJUaW1lb3V0ID0gc2V0VGltZW91dChob3ZlcmVkLCBob3ZlclRpbWUpO1xuICAgIH07XG59XG5mdW5jdGlvbiBtYXJrZXJzRm9yRGlhZ25vc3RpY3MoZG9jLCBkaWFnbm9zdGljcykge1xuICAgIGxldCBieUxpbmUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGZvciAobGV0IGRpYWdub3N0aWMgb2YgZGlhZ25vc3RpY3MpIHtcbiAgICAgICAgbGV0IGxpbmUgPSBkb2MubGluZUF0KGRpYWdub3N0aWMuZnJvbSk7XG4gICAgICAgIChieUxpbmVbbGluZS5mcm9tXSB8fCAoYnlMaW5lW2xpbmUuZnJvbV0gPSBbXSkpLnB1c2goZGlhZ25vc3RpYyk7XG4gICAgfVxuICAgIGxldCBtYXJrZXJzID0gW107XG4gICAgZm9yIChsZXQgbGluZSBpbiBieUxpbmUpIHtcbiAgICAgICAgbWFya2Vycy5wdXNoKG5ldyBMaW50R3V0dGVyTWFya2VyKGJ5TGluZVtsaW5lXSkucmFuZ2UoK2xpbmUpKTtcbiAgICB9XG4gICAgcmV0dXJuIFJhbmdlU2V0Lm9mKG1hcmtlcnMsIHRydWUpO1xufVxuY29uc3QgbGludEd1dHRlckV4dGVuc2lvbiA9IC8qQF9fUFVSRV9fKi9ndXR0ZXIoe1xuICAgIGNsYXNzOiBcImNtLWd1dHRlci1saW50XCIsXG4gICAgbWFya2VyczogdmlldyA9PiB2aWV3LnN0YXRlLmZpZWxkKGxpbnRHdXR0ZXJNYXJrZXJzKSxcbn0pO1xuY29uc3QgbGludEd1dHRlck1hcmtlcnMgPSAvKkBfX1BVUkVfXyovU3RhdGVGaWVsZC5kZWZpbmUoe1xuICAgIGNyZWF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIFJhbmdlU2V0LmVtcHR5O1xuICAgIH0sXG4gICAgdXBkYXRlKG1hcmtlcnMsIHRyKSB7XG4gICAgICAgIG1hcmtlcnMgPSBtYXJrZXJzLm1hcCh0ci5jaGFuZ2VzKTtcbiAgICAgICAgbGV0IGRpYWdub3N0aWNGaWx0ZXIgPSB0ci5zdGF0ZS5mYWNldChsaW50R3V0dGVyQ29uZmlnKS5tYXJrZXJGaWx0ZXI7XG4gICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiB0ci5lZmZlY3RzKSB7XG4gICAgICAgICAgICBpZiAoZWZmZWN0LmlzKHNldERpYWdub3N0aWNzRWZmZWN0KSkge1xuICAgICAgICAgICAgICAgIGxldCBkaWFnbm9zdGljcyA9IGVmZmVjdC52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoZGlhZ25vc3RpY0ZpbHRlcilcbiAgICAgICAgICAgICAgICAgICAgZGlhZ25vc3RpY3MgPSBkaWFnbm9zdGljRmlsdGVyKGRpYWdub3N0aWNzIHx8IFtdKTtcbiAgICAgICAgICAgICAgICBtYXJrZXJzID0gbWFya2Vyc0ZvckRpYWdub3N0aWNzKHRyLnN0YXRlLmRvYywgZGlhZ25vc3RpY3Muc2xpY2UoMCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXJrZXJzO1xuICAgIH1cbn0pO1xuY29uc3Qgc2V0TGludEd1dHRlclRvb2x0aXAgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG5jb25zdCBsaW50R3V0dGVyVG9vbHRpcCA9IC8qQF9fUFVSRV9fKi9TdGF0ZUZpZWxkLmRlZmluZSh7XG4gICAgY3JlYXRlKCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICB1cGRhdGUodG9vbHRpcCwgdHIpIHtcbiAgICAgICAgaWYgKHRvb2x0aXAgJiYgdHIuZG9jQ2hhbmdlZClcbiAgICAgICAgICAgIHRvb2x0aXAgPSBoaWRlVG9vbHRpcCh0ciwgdG9vbHRpcCkgPyBudWxsIDogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0b29sdGlwKSwgeyBwb3M6IHRyLmNoYW5nZXMubWFwUG9zKHRvb2x0aXAucG9zKSB9KTtcbiAgICAgICAgcmV0dXJuIHRyLmVmZmVjdHMucmVkdWNlKCh0LCBlKSA9PiBlLmlzKHNldExpbnRHdXR0ZXJUb29sdGlwKSA/IGUudmFsdWUgOiB0LCB0b29sdGlwKTtcbiAgICB9LFxuICAgIHByb3ZpZGU6IGZpZWxkID0+IHNob3dUb29sdGlwLmZyb20oZmllbGQpXG59KTtcbmNvbnN0IGxpbnRHdXR0ZXJUaGVtZSA9IC8qQF9fUFVSRV9fKi9FZGl0b3JWaWV3LmJhc2VUaGVtZSh7XG4gICAgXCIuY20tZ3V0dGVyLWxpbnRcIjoge1xuICAgICAgICB3aWR0aDogXCIxLjRlbVwiLFxuICAgICAgICBcIiYgLmNtLWd1dHRlckVsZW1lbnRcIjoge1xuICAgICAgICAgICAgcGFkZGluZzogXCIuMmVtXCJcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXCIuY20tbGludC1tYXJrZXJcIjoge1xuICAgICAgICB3aWR0aDogXCIxZW1cIixcbiAgICAgICAgaGVpZ2h0OiBcIjFlbVwiXG4gICAgfSxcbiAgICBcIi5jbS1saW50LW1hcmtlci1pbmZvXCI6IHtcbiAgICAgICAgY29udGVudDogLypAX19QVVJFX18qL3N2ZyhgPHBhdGggZmlsbD1cIiNhYWZcIiBzdHJva2U9XCIjNzdlXCIgc3Ryb2tlLXdpZHRoPVwiNlwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgZD1cIk01IDVMMzUgNUwzNSAzNUw1IDM1WlwiLz5gKVxuICAgIH0sXG4gICAgXCIuY20tbGludC1tYXJrZXItd2FybmluZ1wiOiB7XG4gICAgICAgIGNvbnRlbnQ6IC8qQF9fUFVSRV9fKi9zdmcoYDxwYXRoIGZpbGw9XCIjZmU4XCIgc3Ryb2tlPVwiI2ZkN1wiIHN0cm9rZS13aWR0aD1cIjZcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIGQ9XCJNMjAgNkwzNyAzNUwzIDM1WlwiLz5gKSxcbiAgICB9LFxuICAgIFwiLmNtLWxpbnQtbWFya2VyLWVycm9yXCI6IHtcbiAgICAgICAgY29udGVudDogLypAX19QVVJFX18qL3N2ZyhgPGNpcmNsZSBjeD1cIjIwXCIgY3k9XCIyMFwiIHI9XCIxNVwiIGZpbGw9XCIjZjg3XCIgc3Ryb2tlPVwiI2Y0M1wiIHN0cm9rZS13aWR0aD1cIjZcIi8+YClcbiAgICB9LFxufSk7XG5jb25zdCBsaW50RXh0ZW5zaW9ucyA9IFtcbiAgICBsaW50U3RhdGUsXG4gICAgLypAX19QVVJFX18qL0VkaXRvclZpZXcuZGVjb3JhdGlvbnMuY29tcHV0ZShbbGludFN0YXRlXSwgc3RhdGUgPT4ge1xuICAgICAgICBsZXQgeyBzZWxlY3RlZCwgcGFuZWwgfSA9IHN0YXRlLmZpZWxkKGxpbnRTdGF0ZSk7XG4gICAgICAgIHJldHVybiAhc2VsZWN0ZWQgfHwgIXBhbmVsIHx8IHNlbGVjdGVkLmZyb20gPT0gc2VsZWN0ZWQudG8gPyBEZWNvcmF0aW9uLm5vbmUgOiBEZWNvcmF0aW9uLnNldChbXG4gICAgICAgICAgICBhY3RpdmVNYXJrLnJhbmdlKHNlbGVjdGVkLmZyb20sIHNlbGVjdGVkLnRvKVxuICAgICAgICBdKTtcbiAgICB9KSxcbiAgICAvKkBfX1BVUkVfXyovaG92ZXJUb29sdGlwKGxpbnRUb29sdGlwLCB7IGhpZGVPbjogaGlkZVRvb2x0aXAgfSksXG4gICAgYmFzZVRoZW1lXG5dO1xuY29uc3QgbGludEd1dHRlckNvbmZpZyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmUoY29uZmlncykge1xuICAgICAgICByZXR1cm4gY29tYmluZUNvbmZpZyhjb25maWdzLCB7XG4gICAgICAgICAgICBob3ZlclRpbWU6IDMwMCAvKiBIb3Zlci5UaW1lICovLFxuICAgICAgICAgICAgbWFya2VyRmlsdGVyOiBudWxsLFxuICAgICAgICAgICAgdG9vbHRpcEZpbHRlcjogbnVsbFxuICAgICAgICB9KTtcbiAgICB9XG59KTtcbi8qKlxuUmV0dXJucyBhbiBleHRlbnNpb24gdGhhdCBpbnN0YWxscyBhIGd1dHRlciBzaG93aW5nIG1hcmtlcnMgZm9yXG5lYWNoIGxpbmUgdGhhdCBoYXMgZGlhZ25vc3RpY3MsIHdoaWNoIGNhbiBiZSBob3ZlcmVkIG92ZXIgdG8gc2VlXG50aGUgZGlhZ25vc3RpY3MuXG4qL1xuZnVuY3Rpb24gbGludEd1dHRlcihjb25maWcgPSB7fSkge1xuICAgIHJldHVybiBbbGludEd1dHRlckNvbmZpZy5vZihjb25maWcpLCBsaW50R3V0dGVyTWFya2VycywgbGludEd1dHRlckV4dGVuc2lvbiwgbGludEd1dHRlclRoZW1lLCBsaW50R3V0dGVyVG9vbHRpcF07XG59XG4vKipcbkl0ZXJhdGUgb3ZlciB0aGUgbWFya2VkIGRpYWdub3N0aWNzIGZvciB0aGUgZ2l2ZW4gZWRpdG9yIHN0YXRlLFxuY2FsbGluZyBgZmAgZm9yIGVhY2ggb2YgdGhlbS4gTm90ZSB0aGF0LCBpZiB0aGUgZG9jdW1lbnQgY2hhbmdlZFxuc2luY2UgdGhlIGRpYWdub3N0aWNzIHdlcmUgY3JlYXRlZCwgdGhlIGBEaWFnbm9zdGljYCBvYmplY3Qgd2lsbFxuaG9sZCB0aGUgb3JpZ2luYWwgb3V0ZGF0ZWQgcG9zaXRpb24sIHdoZXJlYXMgdGhlIGB0b2AgYW5kIGBmcm9tYFxuYXJndW1lbnRzIGhvbGQgdGhlIGRpYWdub3N0aWMncyBjdXJyZW50IHBvc2l0aW9uLlxuKi9cbmZ1bmN0aW9uIGZvckVhY2hEaWFnbm9zdGljKHN0YXRlLCBmKSB7XG4gICAgbGV0IGxTdGF0ZSA9IHN0YXRlLmZpZWxkKGxpbnRTdGF0ZSwgZmFsc2UpO1xuICAgIGlmIChsU3RhdGUgJiYgbFN0YXRlLmRpYWdub3N0aWNzLnNpemUpXG4gICAgICAgIGZvciAobGV0IGl0ZXIgPSBSYW5nZVNldC5pdGVyKFtsU3RhdGUuZGlhZ25vc3RpY3NdKTsgaXRlci52YWx1ZTsgaXRlci5uZXh0KCkpXG4gICAgICAgICAgICBmKGl0ZXIudmFsdWUuc3BlYy5kaWFnbm9zdGljLCBpdGVyLmZyb20sIGl0ZXIudG8pO1xufVxuXG5leHBvcnQgeyBjbG9zZUxpbnRQYW5lbCwgZGlhZ25vc3RpY0NvdW50LCBmb3JFYWNoRGlhZ25vc3RpYywgZm9yY2VMaW50aW5nLCBsaW50R3V0dGVyLCBsaW50S2V5bWFwLCBsaW50ZXIsIG5leHREaWFnbm9zdGljLCBvcGVuTGludFBhbmVsLCBwcmV2aW91c0RpYWdub3N0aWMsIHNldERpYWdub3N0aWNzLCBzZXREaWFnbm9zdGljc0VmZmVjdCB9O1xuIl0sIm5hbWVzIjpbIkRlY29yYXRpb24iLCJzaG93UGFuZWwiLCJFZGl0b3JWaWV3IiwiVmlld1BsdWdpbiIsImxvZ0V4Y2VwdGlvbiIsImd1dHRlciIsInNob3dUb29sdGlwIiwiaG92ZXJUb29sdGlwIiwiZ2V0UGFuZWwiLCJXaWRnZXRUeXBlIiwiR3V0dGVyTWFya2VyIiwiU3RhdGVFZmZlY3QiLCJTdGF0ZUZpZWxkIiwiRmFjZXQiLCJjb21iaW5lQ29uZmlnIiwiUmFuZ2VTZXQiLCJlbHQiLCJTZWxlY3RlZERpYWdub3N0aWMiLCJjb25zdHJ1Y3RvciIsImZyb20iLCJ0byIsImRpYWdub3N0aWMiLCJMaW50U3RhdGUiLCJkaWFnbm9zdGljcyIsInBhbmVsIiwic2VsZWN0ZWQiLCJpbml0Iiwic3RhdGUiLCJtYXJrZWREaWFnbm9zdGljcyIsImRpYWdub3N0aWNGaWx0ZXIiLCJmYWNldCIsImxpbnRDb25maWciLCJtYXJrZXJGaWx0ZXIiLCJyYW5nZXMiLCJzZXQiLCJtYXAiLCJkIiwiZG9jIiwibGluZUF0Iiwid2lkZ2V0IiwiRGlhZ25vc3RpY1dpZGdldCIsInJhbmdlIiwibWFyayIsImF0dHJpYnV0ZXMiLCJjbGFzcyIsInNldmVyaXR5IiwibWFya0NsYXNzIiwiZmluZERpYWdub3N0aWMiLCJhZnRlciIsImZvdW5kIiwiYmV0d2VlbiIsInNwZWMiLCJoaWRlVG9vbHRpcCIsInRyIiwidG9vbHRpcCIsImxpbmUiLCJzdGFydFN0YXRlIiwicG9zIiwiZWZmZWN0cyIsInNvbWUiLCJlIiwiaXMiLCJzZXREaWFnbm9zdGljc0VmZmVjdCIsImNoYW5nZXMiLCJ0b3VjaGVzUmFuZ2UiLCJtYXliZUVuYWJsZUxpbnQiLCJmaWVsZCIsImxpbnRTdGF0ZSIsImNvbmNhdCIsImFwcGVuZENvbmZpZyIsIm9mIiwibGludEV4dGVuc2lvbnMiLCJzZXREaWFnbm9zdGljcyIsImRlZmluZSIsInRvZ2dsZVBhbmVsIiwibW92ZVBhbmVsU2VsZWN0aW9uIiwiY3JlYXRlIiwibm9uZSIsInVwZGF0ZSIsInZhbHVlIiwiZG9jQ2hhbmdlZCIsIm1hcHBlZCIsInNlbFBvcyIsIm1hcFBvcyIsImVmZmVjdCIsIkxpbnRQYW5lbCIsIm9wZW4iLCJwcm92aWRlIiwiZiIsInZhbCIsImRlY29yYXRpb25zIiwicyIsImRpYWdub3N0aWNDb3VudCIsImxpbnQiLCJzaXplIiwiYWN0aXZlTWFyayIsImxpbnRUb29sdGlwIiwidmlldyIsInNpZGUiLCJzdGFja1N0YXJ0Iiwic3RhY2tFbmQiLCJwdXNoIiwiTWF0aCIsIm1pbiIsIm1heCIsInRvb2x0aXBGaWx0ZXIiLCJsZW5ndGgiLCJlbmQiLCJhYm92ZSIsImRvbSIsImRpYWdub3N0aWNzVG9vbHRpcCIsInJlbmRlckRpYWdub3N0aWMiLCJvcGVuTGludFBhbmVsIiwiZGlzcGF0Y2giLCJxdWVyeVNlbGVjdG9yIiwiZm9jdXMiLCJjbG9zZUxpbnRQYW5lbCIsIm5leHREaWFnbm9zdGljIiwic2VsIiwic2VsZWN0aW9uIiwibWFpbiIsIm5leHQiLCJpdGVyIiwiYW5jaG9yIiwiaGVhZCIsInNjcm9sbEludG9WaWV3IiwicHJldmlvdXNEaWFnbm9zdGljIiwicHJldkZyb20iLCJwcmV2VG8iLCJsYXN0RnJvbSIsImxhc3RUbyIsImxpbnRLZXltYXAiLCJrZXkiLCJydW4iLCJwcmV2ZW50RGVmYXVsdCIsImxpbnRQbHVnaW4iLCJmcm9tQ2xhc3MiLCJ0aW1lb3V0IiwiZGVsYXkiLCJsaW50VGltZSIsIkRhdGUiLCJub3ciLCJiaW5kIiwic2V0VGltZW91dCIsInNvdXJjZXMiLCJQcm9taXNlIiwiYWxsIiwic291cmNlIiwicmVzb2x2ZSIsInRoZW4iLCJhbm5vdGF0aW9ucyIsInJlZHVjZSIsImEiLCJiIiwiZXJyb3IiLCJjb25maWciLCJuZWVkc1JlZnJlc2giLCJmb3JjZSIsImRlc3Ryb3kiLCJjbGVhclRpbWVvdXQiLCJjb21iaW5lIiwiaW5wdXQiLCJPYmplY3QiLCJhc3NpZ24iLCJpIiwidSIsImxpbnRlciIsImZvcmNlTGludGluZyIsInBsdWdpbiIsImFzc2lnbktleXMiLCJhY3Rpb25zIiwiYXNzaWduZWQiLCJuYW1lIiwiY2giLCJ0ZXN0IiwiYyIsInRvTG93ZXJDYXNlIiwiaW5QYW5lbCIsIl9hIiwia2V5cyIsInJlbmRlck1lc3NhZ2UiLCJtZXNzYWdlIiwiYWN0aW9uIiwiZmlyZWQiLCJjbGljayIsImFwcGx5Iiwia2V5SW5kZXgiLCJpbmRleE9mIiwibmFtZUVsdCIsInNsaWNlIiwidHlwZSIsIm9uY2xpY2siLCJvbm1vdXNlZG93biIsImVxIiwib3RoZXIiLCJ0b0RPTSIsIlBhbmVsSXRlbSIsImlkIiwiZmxvb3IiLCJyYW5kb20iLCJ0b1N0cmluZyIsInNldEF0dHJpYnV0ZSIsIml0ZW1zIiwib25rZXlkb3duIiwiZXZlbnQiLCJrZXlDb2RlIiwibW92ZVNlbGVjdGlvbiIsInNlbGVjdGVkSW5kZXgiLCJ0b1VwcGVyQ2FzZSIsImNoYXJDb2RlQXQiLCJjb250YWlucyIsInRhcmdldCIsImxpc3QiLCJ0YWJJbmRleCIsInJvbGUiLCJwaHJhc2UiLCJuZWVkc1N5bmMiLCJuZXdTZWxlY3RlZEl0ZW0iLCJfc3RhcnQiLCJfZW5kIiwiaXRlbSIsImoiLCJzcGxpY2UiLCJoYXNBdHRyaWJ1dGUiLCJyZW1vdmVBdHRyaWJ1dGUiLCJwb3AiLCJyZXF1ZXN0TWVhc3VyZSIsInJlYWQiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ3cml0ZSIsInNjYWxlWSIsImhlaWdodCIsIm9mZnNldEhlaWdodCIsInRvcCIsInNjcm9sbFRvcCIsImJvdHRvbSIsInN5bmMiLCJkb21Qb3MiLCJmaXJzdENoaWxkIiwicm0iLCJwcmV2IiwibmV4dFNpYmxpbmciLCJyZW1vdmUiLCJwYXJlbnROb2RlIiwiaW5zZXJ0QmVmb3JlIiwic3ZnIiwiY29udGVudCIsImF0dHJzIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwidW5kZXJsaW5lIiwiY29sb3IiLCJiYXNlVGhlbWUiLCJwYWRkaW5nIiwibWFyZ2luTGVmdCIsImRpc3BsYXkiLCJ3aGl0ZVNwYWNlIiwiYm9yZGVyTGVmdCIsImZvbnQiLCJib3JkZXIiLCJiYWNrZ3JvdW5kQ29sb3IiLCJib3JkZXJSYWRpdXMiLCJjdXJzb3IiLCJmb250U2l6ZSIsIm9wYWNpdHkiLCJiYWNrZ3JvdW5kUG9zaXRpb24iLCJiYWNrZ3JvdW5kUmVwZWF0IiwicGFkZGluZ0JvdHRvbSIsImJhY2tncm91bmRJbWFnZSIsIm1hcmdpbiIsInBvc2l0aW9uIiwibGVmdCIsImJvcmRlclJpZ2h0IiwiYm9yZGVyQm90dG9tIiwiYm9yZGVyQm90dG9tQ29sb3IiLCJtYXhIZWlnaHQiLCJvdmVyZmxvd1kiLCJ0ZXh0RGVjb3JhdGlvbiIsImJhY2tncm91bmRfZmFsbGJhY2siLCJjb2xvcl9mYWxsYmFjayIsInJpZ2h0IiwiYmFja2dyb3VuZCIsInNldmVyaXR5V2VpZ2h0Iiwic2V2IiwiTGludEd1dHRlck1hcmtlciIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImNsYXNzTmFtZSIsImRpYWdub3N0aWNzRmlsdGVyIiwibGludEd1dHRlckNvbmZpZyIsIm9ubW91c2VvdmVyIiwiZ3V0dGVyTWFya2VyTW91c2VPdmVyIiwidHJhY2tIb3Zlck9uIiwibWFya2VyIiwibW91c2Vtb3ZlIiwicmVjdCIsImNsaWVudFgiLCJjbGllbnRZIiwibm9kZVR5cGUiLCJjbGFzc0xpc3QiLCJ3aW5kb3ciLCJyZW1vdmVFdmVudExpc3RlbmVyIiwibGludEd1dHRlclRvb2x0aXAiLCJzZXRMaW50R3V0dGVyVG9vbHRpcCIsImFkZEV2ZW50TGlzdGVuZXIiLCJob3ZlcmVkIiwiZWxlbWVudEF0SGVpZ2h0IiwiZG9jdW1lbnRUb3AiLCJsaW5lUG9zIiwiY29vcmRzQXRQb3MiLCJnZXRDb29yZHMiLCJvbm1vdXNlb3V0Iiwib25tb3VzZW1vdmUiLCJob3ZlclRpbWUiLCJob3ZlclRpbWVvdXQiLCJtYXJrZXJzRm9yRGlhZ25vc3RpY3MiLCJieUxpbmUiLCJtYXJrZXJzIiwibGludEd1dHRlckV4dGVuc2lvbiIsImxpbnRHdXR0ZXJNYXJrZXJzIiwiZW1wdHkiLCJ0IiwibGludEd1dHRlclRoZW1lIiwid2lkdGgiLCJjb21wdXRlIiwiaGlkZU9uIiwiY29uZmlncyIsImxpbnRHdXR0ZXIiLCJmb3JFYWNoRGlhZ25vc3RpYyIsImxTdGF0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@codemirror/lint/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@codemirror/search/dist/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@codemirror/search/dist/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RegExpCursor: () => (/* binding */ RegExpCursor),\n/* harmony export */   SearchCursor: () => (/* binding */ SearchCursor),\n/* harmony export */   SearchQuery: () => (/* binding */ SearchQuery),\n/* harmony export */   closeSearchPanel: () => (/* binding */ closeSearchPanel),\n/* harmony export */   findNext: () => (/* binding */ findNext),\n/* harmony export */   findPrevious: () => (/* binding */ findPrevious),\n/* harmony export */   getSearchQuery: () => (/* binding */ getSearchQuery),\n/* harmony export */   gotoLine: () => (/* binding */ gotoLine),\n/* harmony export */   highlightSelectionMatches: () => (/* binding */ highlightSelectionMatches),\n/* harmony export */   openSearchPanel: () => (/* binding */ openSearchPanel),\n/* harmony export */   replaceAll: () => (/* binding */ replaceAll),\n/* harmony export */   replaceNext: () => (/* binding */ replaceNext),\n/* harmony export */   search: () => (/* binding */ search),\n/* harmony export */   searchKeymap: () => (/* binding */ searchKeymap),\n/* harmony export */   searchPanelOpen: () => (/* binding */ searchPanelOpen),\n/* harmony export */   selectMatches: () => (/* binding */ selectMatches),\n/* harmony export */   selectNextOccurrence: () => (/* binding */ selectNextOccurrence),\n/* harmony export */   selectSelectionMatches: () => (/* binding */ selectSelectionMatches),\n/* harmony export */   setSearchQuery: () => (/* binding */ setSearchQuery)\n/* harmony export */ });\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/view */ \"(ssr)/./node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/state */ \"(ssr)/./node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var crelt__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crelt */ \"(ssr)/./node_modules/crelt/index.js\");\n\n\n\nconst basicNormalize = typeof String.prototype.normalize == \"function\" ? (x)=>x.normalize(\"NFKD\") : (x)=>x;\n/**\nA search cursor provides an iterator over text matches in a\ndocument.\n*/ class SearchCursor {\n    /**\n    Create a text cursor. The query is the search string, `from` to\n    `to` provides the region to search.\n    \n    When `normalize` is given, it will be called, on both the query\n    string and the content it is matched against, before comparing.\n    You can, for example, create a case-insensitive search by\n    passing `s => s.toLowerCase()`.\n    \n    Text is always normalized with\n    [`.normalize(\"NFKD\")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)\n    (when supported).\n    */ constructor(text, query, from = 0, to = text.length, normalize, test){\n        this.test = test;\n        /**\n        The current match (only holds a meaningful value after\n        [`next`](https://codemirror.net/6/docs/ref/#search.SearchCursor.next) has been called and when\n        `done` is false).\n        */ this.value = {\n            from: 0,\n            to: 0\n        };\n        /**\n        Whether the end of the iterated region has been reached.\n        */ this.done = false;\n        this.matches = [];\n        this.buffer = \"\";\n        this.bufferPos = 0;\n        this.iter = text.iterRange(from, to);\n        this.bufferStart = from;\n        this.normalize = normalize ? (x)=>normalize(basicNormalize(x)) : basicNormalize;\n        this.query = this.normalize(query);\n    }\n    peek() {\n        if (this.bufferPos == this.buffer.length) {\n            this.bufferStart += this.buffer.length;\n            this.iter.next();\n            if (this.iter.done) return -1;\n            this.bufferPos = 0;\n            this.buffer = this.iter.value;\n        }\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(this.buffer, this.bufferPos);\n    }\n    /**\n    Look for the next match. Updates the iterator's\n    [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and\n    [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called\n    at least once before using the cursor.\n    */ next() {\n        while(this.matches.length)this.matches.pop();\n        return this.nextOverlapping();\n    }\n    /**\n    The `next` method will ignore matches that partially overlap a\n    previous match. This method behaves like `next`, but includes\n    such matches.\n    */ nextOverlapping() {\n        for(;;){\n            let next = this.peek();\n            if (next < 0) {\n                this.done = true;\n                return this;\n            }\n            let str = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.fromCodePoint)(next), start = this.bufferStart + this.bufferPos;\n            this.bufferPos += (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)(next);\n            let norm = this.normalize(str);\n            for(let i = 0, pos = start;; i++){\n                let code = norm.charCodeAt(i);\n                let match = this.match(code, pos);\n                if (i == norm.length - 1) {\n                    if (match) {\n                        this.value = match;\n                        return this;\n                    }\n                    break;\n                }\n                if (pos == start && i < str.length && str.charCodeAt(i) == code) pos++;\n            }\n        }\n    }\n    match(code, pos) {\n        let match = null;\n        for(let i = 0; i < this.matches.length; i += 2){\n            let index = this.matches[i], keep = false;\n            if (this.query.charCodeAt(index) == code) {\n                if (index == this.query.length - 1) {\n                    match = {\n                        from: this.matches[i + 1],\n                        to: pos + 1\n                    };\n                } else {\n                    this.matches[i]++;\n                    keep = true;\n                }\n            }\n            if (!keep) {\n                this.matches.splice(i, 2);\n                i -= 2;\n            }\n        }\n        if (this.query.charCodeAt(0) == code) {\n            if (this.query.length == 1) match = {\n                from: pos,\n                to: pos + 1\n            };\n            else this.matches.push(1, pos);\n        }\n        if (match && this.test && !this.test(match.from, match.to, this.buffer, this.bufferStart)) match = null;\n        return match;\n    }\n}\nif (typeof Symbol != \"undefined\") SearchCursor.prototype[Symbol.iterator] = function() {\n    return this;\n};\nconst empty = {\n    from: -1,\n    to: -1,\n    match: /*@__PURE__*/ /.*/.exec(\"\")\n};\nconst baseFlags = \"gm\" + (/x/.unicode == null ? \"\" : \"u\");\n/**\nThis class is similar to [`SearchCursor`](https://codemirror.net/6/docs/ref/#search.SearchCursor)\nbut searches for a regular expression pattern instead of a plain\nstring.\n*/ class RegExpCursor {\n    /**\n    Create a cursor that will search the given range in the given\n    document. `query` should be the raw pattern (as you'd pass it to\n    `new RegExp`).\n    */ constructor(text, query, options, from = 0, to = text.length){\n        this.text = text;\n        this.to = to;\n        this.curLine = \"\";\n        /**\n        Set to `true` when the cursor has reached the end of the search\n        range.\n        */ this.done = false;\n        /**\n        Will contain an object with the extent of the match and the\n        match object when [`next`](https://codemirror.net/6/docs/ref/#search.RegExpCursor.next)\n        sucessfully finds a match.\n        */ this.value = empty;\n        if (/\\\\[sWDnr]|\\n|\\r|\\[\\^/.test(query)) return new MultilineRegExpCursor(text, query, options, from, to);\n        this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? \"i\" : \"\"));\n        this.test = options === null || options === void 0 ? void 0 : options.test;\n        this.iter = text.iter();\n        let startLine = text.lineAt(from);\n        this.curLineStart = startLine.from;\n        this.matchPos = toCharEnd(text, from);\n        this.getLine(this.curLineStart);\n    }\n    getLine(skip) {\n        this.iter.next(skip);\n        if (this.iter.lineBreak) {\n            this.curLine = \"\";\n        } else {\n            this.curLine = this.iter.value;\n            if (this.curLineStart + this.curLine.length > this.to) this.curLine = this.curLine.slice(0, this.to - this.curLineStart);\n            this.iter.next();\n        }\n    }\n    nextLine() {\n        this.curLineStart = this.curLineStart + this.curLine.length + 1;\n        if (this.curLineStart > this.to) this.curLine = \"\";\n        else this.getLine(0);\n    }\n    /**\n    Move to the next match, if there is one.\n    */ next() {\n        for(let off = this.matchPos - this.curLineStart;;){\n            this.re.lastIndex = off;\n            let match = this.matchPos <= this.to && this.re.exec(this.curLine);\n            if (match) {\n                let from = this.curLineStart + match.index, to = from + match[0].length;\n                this.matchPos = toCharEnd(this.text, to + (from == to ? 1 : 0));\n                if (from == this.curLineStart + this.curLine.length) this.nextLine();\n                if ((from < to || from > this.value.to) && (!this.test || this.test(from, to, match))) {\n                    this.value = {\n                        from,\n                        to,\n                        match\n                    };\n                    return this;\n                }\n                off = this.matchPos - this.curLineStart;\n            } else if (this.curLineStart + this.curLine.length < this.to) {\n                this.nextLine();\n                off = 0;\n            } else {\n                this.done = true;\n                return this;\n            }\n        }\n    }\n}\nconst flattened = /*@__PURE__*/ new WeakMap();\n// Reusable (partially) flattened document strings\nclass FlattenedDoc {\n    constructor(from, text){\n        this.from = from;\n        this.text = text;\n    }\n    get to() {\n        return this.from + this.text.length;\n    }\n    static get(doc, from, to) {\n        let cached = flattened.get(doc);\n        if (!cached || cached.from >= to || cached.to <= from) {\n            let flat = new FlattenedDoc(from, doc.sliceString(from, to));\n            flattened.set(doc, flat);\n            return flat;\n        }\n        if (cached.from == from && cached.to == to) return cached;\n        let { text, from: cachedFrom } = cached;\n        if (cachedFrom > from) {\n            text = doc.sliceString(from, cachedFrom) + text;\n            cachedFrom = from;\n        }\n        if (cached.to < to) text += doc.sliceString(cached.to, to);\n        flattened.set(doc, new FlattenedDoc(cachedFrom, text));\n        return new FlattenedDoc(from, text.slice(from - cachedFrom, to - cachedFrom));\n    }\n}\nclass MultilineRegExpCursor {\n    constructor(text, query, options, from, to){\n        this.text = text;\n        this.to = to;\n        this.done = false;\n        this.value = empty;\n        this.matchPos = toCharEnd(text, from);\n        this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? \"i\" : \"\"));\n        this.test = options === null || options === void 0 ? void 0 : options.test;\n        this.flat = FlattenedDoc.get(text, from, this.chunkEnd(from + 5000 /* Chunk.Base */ ));\n    }\n    chunkEnd(pos) {\n        return pos >= this.to ? this.to : this.text.lineAt(pos).to;\n    }\n    next() {\n        for(;;){\n            let off = this.re.lastIndex = this.matchPos - this.flat.from;\n            let match = this.re.exec(this.flat.text);\n            // Skip empty matches directly after the last match\n            if (match && !match[0] && match.index == off) {\n                this.re.lastIndex = off + 1;\n                match = this.re.exec(this.flat.text);\n            }\n            if (match) {\n                let from = this.flat.from + match.index, to = from + match[0].length;\n                // If a match goes almost to the end of a noncomplete chunk, try\n                // again, since it'll likely be able to match more\n                if ((this.flat.to >= this.to || match.index + match[0].length <= this.flat.text.length - 10) && (!this.test || this.test(from, to, match))) {\n                    this.value = {\n                        from,\n                        to,\n                        match\n                    };\n                    this.matchPos = toCharEnd(this.text, to + (from == to ? 1 : 0));\n                    return this;\n                }\n            }\n            if (this.flat.to == this.to) {\n                this.done = true;\n                return this;\n            }\n            // Grow the flattened doc\n            this.flat = FlattenedDoc.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));\n        }\n    }\n}\nif (typeof Symbol != \"undefined\") {\n    RegExpCursor.prototype[Symbol.iterator] = MultilineRegExpCursor.prototype[Symbol.iterator] = function() {\n        return this;\n    };\n}\nfunction validRegExp(source) {\n    try {\n        new RegExp(source, baseFlags);\n        return true;\n    } catch (_a) {\n        return false;\n    }\n}\nfunction toCharEnd(text, pos) {\n    if (pos >= text.length) return pos;\n    let line = text.lineAt(pos), next;\n    while(pos < line.to && (next = line.text.charCodeAt(pos - line.from)) >= 0xDC00 && next < 0xE000)pos++;\n    return pos;\n}\nfunction createLineDialog(view) {\n    let line = String(view.state.doc.lineAt(view.state.selection.main.head).number);\n    let input = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"input\", {\n        class: \"cm-textfield\",\n        name: \"line\",\n        value: line\n    });\n    let dom = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"form\", {\n        class: \"cm-gotoLine\",\n        onkeydown: (event)=>{\n            if (event.keyCode == 27) {\n                event.preventDefault();\n                view.dispatch({\n                    effects: dialogEffect.of(false)\n                });\n                view.focus();\n            } else if (event.keyCode == 13) {\n                event.preventDefault();\n                go();\n            }\n        },\n        onsubmit: (event)=>{\n            event.preventDefault();\n            go();\n        }\n    }, (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"label\", view.state.phrase(\"Go to line\"), \": \", input), \" \", (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"button\", {\n        class: \"cm-button\",\n        type: \"submit\"\n    }, view.state.phrase(\"go\")));\n    function go() {\n        let match = /^([+-])?(\\d+)?(:\\d+)?(%)?$/.exec(input.value);\n        if (!match) return;\n        let { state } = view, startLine = state.doc.lineAt(state.selection.main.head);\n        let [, sign, ln, cl, percent] = match;\n        let col = cl ? +cl.slice(1) : 0;\n        let line = ln ? +ln : startLine.number;\n        if (ln && percent) {\n            let pc = line / 100;\n            if (sign) pc = pc * (sign == \"-\" ? -1 : 1) + startLine.number / state.doc.lines;\n            line = Math.round(state.doc.lines * pc);\n        } else if (ln && sign) {\n            line = line * (sign == \"-\" ? -1 : 1) + startLine.number;\n        }\n        let docLine = state.doc.line(Math.max(1, Math.min(state.doc.lines, line)));\n        let selection = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(docLine.from + Math.max(0, Math.min(col, docLine.length)));\n        view.dispatch({\n            effects: [\n                dialogEffect.of(false),\n                _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.scrollIntoView(selection.from, {\n                    y: \"center\"\n                })\n            ],\n            selection\n        });\n        view.focus();\n    }\n    return {\n        dom\n    };\n}\nconst dialogEffect = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();\nconst dialogField = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateField.define({\n    create () {\n        return true;\n    },\n    update (value, tr) {\n        for (let e of tr.effects)if (e.is(dialogEffect)) value = e.value;\n        return value;\n    },\n    provide: (f)=>_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.showPanel.from(f, (val)=>val ? createLineDialog : null)\n});\n/**\nCommand that shows a dialog asking the user for a line number, and\nwhen a valid position is provided, moves the cursor to that line.\n\nSupports line numbers, relative line offsets prefixed with `+` or\n`-`, document percentages suffixed with `%`, and an optional\ncolumn position by adding `:` and a second number after the line\nnumber.\n*/ const gotoLine = (view)=>{\n    let panel = (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.getPanel)(view, createLineDialog);\n    if (!panel) {\n        let effects = [\n            dialogEffect.of(true)\n        ];\n        if (view.state.field(dialogField, false) == null) effects.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.appendConfig.of([\n            dialogField,\n            baseTheme$1\n        ]));\n        view.dispatch({\n            effects\n        });\n        panel = (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.getPanel)(view, createLineDialog);\n    }\n    if (panel) panel.dom.querySelector(\"input\").select();\n    return true;\n};\nconst baseTheme$1 = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.baseTheme({\n    \".cm-panel.cm-gotoLine\": {\n        padding: \"2px 6px 4px\",\n        \"& label\": {\n            fontSize: \"80%\"\n        }\n    }\n});\nconst defaultHighlightOptions = {\n    highlightWordAroundCursor: false,\n    minSelectionLength: 1,\n    maxMatches: 100,\n    wholeWords: false\n};\nconst highlightConfig = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define({\n    combine (options) {\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.combineConfig)(options, defaultHighlightOptions, {\n            highlightWordAroundCursor: (a, b)=>a || b,\n            minSelectionLength: Math.min,\n            maxMatches: Math.min\n        });\n    }\n});\n/**\nThis extension highlights text that matches the selection. It uses\nthe `\"cm-selectionMatch\"` class for the highlighting. When\n`highlightWordAroundCursor` is enabled, the word at the cursor\nitself will be highlighted with `\"cm-selectionMatch-main\"`.\n*/ function highlightSelectionMatches(options) {\n    let ext = [\n        defaultTheme,\n        matchHighlighter\n    ];\n    if (options) ext.push(highlightConfig.of(options));\n    return ext;\n}\nconst matchDeco = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.mark({\n    class: \"cm-selectionMatch\"\n});\nconst mainMatchDeco = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.mark({\n    class: \"cm-selectionMatch cm-selectionMatch-main\"\n});\n// Whether the characters directly outside the given positions are non-word characters\nfunction insideWordBoundaries(check, state, from, to) {\n    return (from == 0 || check(state.sliceDoc(from - 1, from)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word) && (to == state.doc.length || check(state.sliceDoc(to, to + 1)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word);\n}\n// Whether the characters directly at the given positions are word characters\nfunction insideWord(check, state, from, to) {\n    return check(state.sliceDoc(from, from + 1)) == _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word && check(state.sliceDoc(to - 1, to)) == _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word;\n}\nconst matchHighlighter = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.ViewPlugin.fromClass(class {\n    constructor(view){\n        this.decorations = this.getDeco(view);\n    }\n    update(update) {\n        if (update.selectionSet || update.docChanged || update.viewportChanged) this.decorations = this.getDeco(update.view);\n    }\n    getDeco(view) {\n        let conf = view.state.facet(highlightConfig);\n        let { state } = view, sel = state.selection;\n        if (sel.ranges.length > 1) return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none;\n        let range = sel.main, query, check = null;\n        if (range.empty) {\n            if (!conf.highlightWordAroundCursor) return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none;\n            let word = state.wordAt(range.head);\n            if (!word) return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none;\n            check = state.charCategorizer(range.head);\n            query = state.sliceDoc(word.from, word.to);\n        } else {\n            let len = range.to - range.from;\n            if (len < conf.minSelectionLength || len > 200) return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none;\n            if (conf.wholeWords) {\n                query = state.sliceDoc(range.from, range.to); // TODO: allow and include leading/trailing space?\n                check = state.charCategorizer(range.head);\n                if (!(insideWordBoundaries(check, state, range.from, range.to) && insideWord(check, state, range.from, range.to))) return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none;\n            } else {\n                query = state.sliceDoc(range.from, range.to).trim();\n                if (!query) return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none;\n            }\n        }\n        let deco = [];\n        for (let part of view.visibleRanges){\n            let cursor = new SearchCursor(state.doc, query, part.from, part.to);\n            while(!cursor.next().done){\n                let { from, to } = cursor.value;\n                if (!check || insideWordBoundaries(check, state, from, to)) {\n                    if (range.empty && from <= range.from && to >= range.to) deco.push(mainMatchDeco.range(from, to));\n                    else if (from >= range.to || to <= range.from) deco.push(matchDeco.range(from, to));\n                    if (deco.length > conf.maxMatches) return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none;\n                }\n            }\n        }\n        return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.set(deco);\n    }\n}, {\n    decorations: (v)=>v.decorations\n});\nconst defaultTheme = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.baseTheme({\n    \".cm-selectionMatch\": {\n        backgroundColor: \"#99ff7780\"\n    },\n    \".cm-searchMatch .cm-selectionMatch\": {\n        backgroundColor: \"transparent\"\n    }\n});\n// Select the words around the cursors.\nconst selectWord = ({ state, dispatch })=>{\n    let { selection } = state;\n    let newSel = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create(selection.ranges.map((range)=>state.wordAt(range.head) || _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(range.head)), selection.mainIndex);\n    if (newSel.eq(selection)) return false;\n    dispatch(state.update({\n        selection: newSel\n    }));\n    return true;\n};\n// Find next occurrence of query relative to last cursor. Wrap around\n// the document if there are no more matches.\nfunction findNextOccurrence(state, query) {\n    let { main, ranges } = state.selection;\n    let word = state.wordAt(main.head), fullWord = word && word.from == main.from && word.to == main.to;\n    for(let cycled = false, cursor = new SearchCursor(state.doc, query, ranges[ranges.length - 1].to);;){\n        cursor.next();\n        if (cursor.done) {\n            if (cycled) return null;\n            cursor = new SearchCursor(state.doc, query, 0, Math.max(0, ranges[ranges.length - 1].from - 1));\n            cycled = true;\n        } else {\n            if (cycled && ranges.some((r)=>r.from == cursor.value.from)) continue;\n            if (fullWord) {\n                let word = state.wordAt(cursor.value.from);\n                if (!word || word.from != cursor.value.from || word.to != cursor.value.to) continue;\n            }\n            return cursor.value;\n        }\n    }\n}\n/**\nSelect next occurrence of the current selection. Expand selection\nto the surrounding word when the selection is empty.\n*/ const selectNextOccurrence = ({ state, dispatch })=>{\n    let { ranges } = state.selection;\n    if (ranges.some((sel)=>sel.from === sel.to)) return selectWord({\n        state,\n        dispatch\n    });\n    let searchedText = state.sliceDoc(ranges[0].from, ranges[0].to);\n    if (state.selection.ranges.some((r)=>state.sliceDoc(r.from, r.to) != searchedText)) return false;\n    let range = findNextOccurrence(state, searchedText);\n    if (!range) return false;\n    dispatch(state.update({\n        selection: state.selection.addRange(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(range.from, range.to), false),\n        effects: _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.scrollIntoView(range.to)\n    }));\n    return true;\n};\nconst searchConfigFacet = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define({\n    combine (configs) {\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.combineConfig)(configs, {\n            top: false,\n            caseSensitive: false,\n            literal: false,\n            regexp: false,\n            wholeWord: false,\n            createPanel: (view)=>new SearchPanel(view),\n            scrollToMatch: (range)=>_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.scrollIntoView(range)\n        });\n    }\n});\n/**\nAdd search state to the editor configuration, and optionally\nconfigure the search extension.\n([`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel) will automatically\nenable this if it isn't already on).\n*/ function search(config) {\n    return config ? [\n        searchConfigFacet.of(config),\n        searchExtensions\n    ] : searchExtensions;\n}\n/**\nA search query. Part of the editor's search state.\n*/ class SearchQuery {\n    /**\n    Create a query object.\n    */ constructor(config){\n        this.search = config.search;\n        this.caseSensitive = !!config.caseSensitive;\n        this.literal = !!config.literal;\n        this.regexp = !!config.regexp;\n        this.replace = config.replace || \"\";\n        this.valid = !!this.search && (!this.regexp || validRegExp(this.search));\n        this.unquoted = this.unquote(this.search);\n        this.wholeWord = !!config.wholeWord;\n    }\n    /**\n    @internal\n    */ unquote(text) {\n        return this.literal ? text : text.replace(/\\\\([nrt\\\\])/g, (_, ch)=>ch == \"n\" ? \"\\n\" : ch == \"r\" ? \"\\r\" : ch == \"t\" ? \"\t\" : \"\\\\\");\n    }\n    /**\n    Compare this query to another query.\n    */ eq(other) {\n        return this.search == other.search && this.replace == other.replace && this.caseSensitive == other.caseSensitive && this.regexp == other.regexp && this.wholeWord == other.wholeWord;\n    }\n    /**\n    @internal\n    */ create() {\n        return this.regexp ? new RegExpQuery(this) : new StringQuery(this);\n    }\n    /**\n    Get a search cursor for this query, searching through the given\n    range in the given state.\n    */ getCursor(state, from = 0, to) {\n        let st = state.doc ? state : _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorState.create({\n            doc: state\n        });\n        if (to == null) to = st.doc.length;\n        return this.regexp ? regexpCursor(this, st, from, to) : stringCursor(this, st, from, to);\n    }\n}\nclass QueryType {\n    constructor(spec){\n        this.spec = spec;\n    }\n}\nfunction stringCursor(spec, state, from, to) {\n    return new SearchCursor(state.doc, spec.unquoted, from, to, spec.caseSensitive ? undefined : (x)=>x.toLowerCase(), spec.wholeWord ? stringWordTest(state.doc, state.charCategorizer(state.selection.main.head)) : undefined);\n}\nfunction stringWordTest(doc, categorizer) {\n    return (from, to, buf, bufPos)=>{\n        if (bufPos > from || bufPos + buf.length < to) {\n            bufPos = Math.max(0, from - 2);\n            buf = doc.sliceString(bufPos, Math.min(doc.length, to + 2));\n        }\n        return (categorizer(charBefore(buf, from - bufPos)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word || categorizer(charAfter(buf, from - bufPos)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word) && (categorizer(charAfter(buf, to - bufPos)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word || categorizer(charBefore(buf, to - bufPos)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word);\n    };\n}\nclass StringQuery extends QueryType {\n    constructor(spec){\n        super(spec);\n    }\n    nextMatch(state, curFrom, curTo) {\n        let cursor = stringCursor(this.spec, state, curTo, state.doc.length).nextOverlapping();\n        if (cursor.done) cursor = stringCursor(this.spec, state, 0, curFrom).nextOverlapping();\n        return cursor.done ? null : cursor.value;\n    }\n    // Searching in reverse is, rather than implementing an inverted search\n    // cursor, done by scanning chunk after chunk forward.\n    prevMatchInRange(state, from, to) {\n        for(let pos = to;;){\n            let start = Math.max(from, pos - 10000 /* FindPrev.ChunkSize */  - this.spec.unquoted.length);\n            let cursor = stringCursor(this.spec, state, start, pos), range = null;\n            while(!cursor.nextOverlapping().done)range = cursor.value;\n            if (range) return range;\n            if (start == from) return null;\n            pos -= 10000 /* FindPrev.ChunkSize */ ;\n        }\n    }\n    prevMatch(state, curFrom, curTo) {\n        return this.prevMatchInRange(state, 0, curFrom) || this.prevMatchInRange(state, curTo, state.doc.length);\n    }\n    getReplacement(_result) {\n        return this.spec.unquote(this.spec.replace);\n    }\n    matchAll(state, limit) {\n        let cursor = stringCursor(this.spec, state, 0, state.doc.length), ranges = [];\n        while(!cursor.next().done){\n            if (ranges.length >= limit) return null;\n            ranges.push(cursor.value);\n        }\n        return ranges;\n    }\n    highlight(state, from, to, add) {\n        let cursor = stringCursor(this.spec, state, Math.max(0, from - this.spec.unquoted.length), Math.min(to + this.spec.unquoted.length, state.doc.length));\n        while(!cursor.next().done)add(cursor.value.from, cursor.value.to);\n    }\n}\nfunction regexpCursor(spec, state, from, to) {\n    return new RegExpCursor(state.doc, spec.search, {\n        ignoreCase: !spec.caseSensitive,\n        test: spec.wholeWord ? regexpWordTest(state.charCategorizer(state.selection.main.head)) : undefined\n    }, from, to);\n}\nfunction charBefore(str, index) {\n    return str.slice((0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.findClusterBreak)(str, index, false), index);\n}\nfunction charAfter(str, index) {\n    return str.slice(index, (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.findClusterBreak)(str, index));\n}\nfunction regexpWordTest(categorizer) {\n    return (_from, _to, match)=>!match[0].length || (categorizer(charBefore(match.input, match.index)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word || categorizer(charAfter(match.input, match.index)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word) && (categorizer(charAfter(match.input, match.index + match[0].length)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word || categorizer(charBefore(match.input, match.index + match[0].length)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word);\n}\nclass RegExpQuery extends QueryType {\n    nextMatch(state, curFrom, curTo) {\n        let cursor = regexpCursor(this.spec, state, curTo, state.doc.length).next();\n        if (cursor.done) cursor = regexpCursor(this.spec, state, 0, curFrom).next();\n        return cursor.done ? null : cursor.value;\n    }\n    prevMatchInRange(state, from, to) {\n        for(let size = 1;; size++){\n            let start = Math.max(from, to - size * 10000 /* FindPrev.ChunkSize */ );\n            let cursor = regexpCursor(this.spec, state, start, to), range = null;\n            while(!cursor.next().done)range = cursor.value;\n            if (range && (start == from || range.from > start + 10)) return range;\n            if (start == from) return null;\n        }\n    }\n    prevMatch(state, curFrom, curTo) {\n        return this.prevMatchInRange(state, 0, curFrom) || this.prevMatchInRange(state, curTo, state.doc.length);\n    }\n    getReplacement(result) {\n        return this.spec.unquote(this.spec.replace).replace(/\\$([$&\\d+])/g, (m, i)=>i == \"$\" ? \"$\" : i == \"&\" ? result.match[0] : i != \"0\" && +i < result.match.length ? result.match[i] : m);\n    }\n    matchAll(state, limit) {\n        let cursor = regexpCursor(this.spec, state, 0, state.doc.length), ranges = [];\n        while(!cursor.next().done){\n            if (ranges.length >= limit) return null;\n            ranges.push(cursor.value);\n        }\n        return ranges;\n    }\n    highlight(state, from, to, add) {\n        let cursor = regexpCursor(this.spec, state, Math.max(0, from - 250 /* RegExp.HighlightMargin */ ), Math.min(to + 250 /* RegExp.HighlightMargin */ , state.doc.length));\n        while(!cursor.next().done)add(cursor.value.from, cursor.value.to);\n    }\n}\n/**\nA state effect that updates the current search query. Note that\nthis only has an effect if the search state has been initialized\n(by including [`search`](https://codemirror.net/6/docs/ref/#search.search) in your configuration or\nby running [`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel) at least\nonce).\n*/ const setSearchQuery = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();\nconst togglePanel = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();\nconst searchState = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateField.define({\n    create (state) {\n        return new SearchState(defaultQuery(state).create(), null);\n    },\n    update (value, tr) {\n        for (let effect of tr.effects){\n            if (effect.is(setSearchQuery)) value = new SearchState(effect.value.create(), value.panel);\n            else if (effect.is(togglePanel)) value = new SearchState(value.query, effect.value ? createSearchPanel : null);\n        }\n        return value;\n    },\n    provide: (f)=>_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.showPanel.from(f, (val)=>val.panel)\n});\n/**\nGet the current search query from an editor state.\n*/ function getSearchQuery(state) {\n    let curState = state.field(searchState, false);\n    return curState ? curState.query.spec : defaultQuery(state);\n}\n/**\nQuery whether the search panel is open in the given editor state.\n*/ function searchPanelOpen(state) {\n    var _a;\n    return ((_a = state.field(searchState, false)) === null || _a === void 0 ? void 0 : _a.panel) != null;\n}\nclass SearchState {\n    constructor(query, panel){\n        this.query = query;\n        this.panel = panel;\n    }\n}\nconst matchMark = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.mark({\n    class: \"cm-searchMatch\"\n}), selectedMatchMark = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.mark({\n    class: \"cm-searchMatch cm-searchMatch-selected\"\n});\nconst searchHighlighter = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.ViewPlugin.fromClass(class {\n    constructor(view){\n        this.view = view;\n        this.decorations = this.highlight(view.state.field(searchState));\n    }\n    update(update) {\n        let state = update.state.field(searchState);\n        if (state != update.startState.field(searchState) || update.docChanged || update.selectionSet || update.viewportChanged) this.decorations = this.highlight(state);\n    }\n    highlight({ query, panel }) {\n        if (!panel || !query.spec.valid) return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none;\n        let { view } = this;\n        let builder = new _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.RangeSetBuilder();\n        for(let i = 0, ranges = view.visibleRanges, l = ranges.length; i < l; i++){\n            let { from, to } = ranges[i];\n            while(i < l - 1 && to > ranges[i + 1].from - 2 * 250 /* RegExp.HighlightMargin */ )to = ranges[++i].to;\n            query.highlight(view.state, from, to, (from, to)=>{\n                let selected = view.state.selection.ranges.some((r)=>r.from == from && r.to == to);\n                builder.add(from, to, selected ? selectedMatchMark : matchMark);\n            });\n        }\n        return builder.finish();\n    }\n}, {\n    decorations: (v)=>v.decorations\n});\nfunction searchCommand(f) {\n    return (view)=>{\n        let state = view.state.field(searchState, false);\n        return state && state.query.spec.valid ? f(view, state) : openSearchPanel(view);\n    };\n}\n/**\nOpen the search panel if it isn't already open, and move the\nselection to the first match after the current main selection.\nWill wrap around to the start of the document when it reaches the\nend.\n*/ const findNext = /*@__PURE__*/ searchCommand((view, { query })=>{\n    let { to } = view.state.selection.main;\n    let next = query.nextMatch(view.state, to, to);\n    if (!next) return false;\n    let selection = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.single(next.from, next.to);\n    let config = view.state.facet(searchConfigFacet);\n    view.dispatch({\n        selection,\n        effects: [\n            announceMatch(view, next),\n            config.scrollToMatch(selection.main, view)\n        ],\n        userEvent: \"select.search\"\n    });\n    selectSearchInput(view);\n    return true;\n});\n/**\nMove the selection to the previous instance of the search query,\nbefore the current main selection. Will wrap past the start\nof the document to start searching at the end again.\n*/ const findPrevious = /*@__PURE__*/ searchCommand((view, { query })=>{\n    let { state } = view, { from } = state.selection.main;\n    let prev = query.prevMatch(state, from, from);\n    if (!prev) return false;\n    let selection = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.single(prev.from, prev.to);\n    let config = view.state.facet(searchConfigFacet);\n    view.dispatch({\n        selection,\n        effects: [\n            announceMatch(view, prev),\n            config.scrollToMatch(selection.main, view)\n        ],\n        userEvent: \"select.search\"\n    });\n    selectSearchInput(view);\n    return true;\n});\n/**\nSelect all instances of the search query.\n*/ const selectMatches = /*@__PURE__*/ searchCommand((view, { query })=>{\n    let ranges = query.matchAll(view.state, 1000);\n    if (!ranges || !ranges.length) return false;\n    view.dispatch({\n        selection: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create(ranges.map((r)=>_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(r.from, r.to))),\n        userEvent: \"select.search.matches\"\n    });\n    return true;\n});\n/**\nSelect all instances of the currently selected text.\n*/ const selectSelectionMatches = ({ state, dispatch })=>{\n    let sel = state.selection;\n    if (sel.ranges.length > 1 || sel.main.empty) return false;\n    let { from, to } = sel.main;\n    let ranges = [], main = 0;\n    for(let cur = new SearchCursor(state.doc, state.sliceDoc(from, to)); !cur.next().done;){\n        if (ranges.length > 1000) return false;\n        if (cur.value.from == from) main = ranges.length;\n        ranges.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(cur.value.from, cur.value.to));\n    }\n    dispatch(state.update({\n        selection: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create(ranges, main),\n        userEvent: \"select.search.matches\"\n    }));\n    return true;\n};\n/**\nReplace the current match of the search query.\n*/ const replaceNext = /*@__PURE__*/ searchCommand((view, { query })=>{\n    let { state } = view, { from, to } = state.selection.main;\n    if (state.readOnly) return false;\n    let next = query.nextMatch(state, from, from);\n    if (!next) return false;\n    let changes = [], selection, replacement;\n    let effects = [];\n    if (next.from == from && next.to == to) {\n        replacement = state.toText(query.getReplacement(next));\n        changes.push({\n            from: next.from,\n            to: next.to,\n            insert: replacement\n        });\n        next = query.nextMatch(state, next.from, next.to);\n        effects.push(_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.announce.of(state.phrase(\"replaced match on line $\", state.doc.lineAt(from).number) + \".\"));\n    }\n    if (next) {\n        let off = changes.length == 0 || changes[0].from >= next.to ? 0 : next.to - next.from - replacement.length;\n        selection = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.single(next.from - off, next.to - off);\n        effects.push(announceMatch(view, next));\n        effects.push(state.facet(searchConfigFacet).scrollToMatch(selection.main, view));\n    }\n    view.dispatch({\n        changes,\n        selection,\n        effects,\n        userEvent: \"input.replace\"\n    });\n    return true;\n});\n/**\nReplace all instances of the search query with the given\nreplacement.\n*/ const replaceAll = /*@__PURE__*/ searchCommand((view, { query })=>{\n    if (view.state.readOnly) return false;\n    let changes = query.matchAll(view.state, 1e9).map((match)=>{\n        let { from, to } = match;\n        return {\n            from,\n            to,\n            insert: query.getReplacement(match)\n        };\n    });\n    if (!changes.length) return false;\n    let announceText = view.state.phrase(\"replaced $ matches\", changes.length) + \".\";\n    view.dispatch({\n        changes,\n        effects: _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.announce.of(announceText),\n        userEvent: \"input.replace.all\"\n    });\n    return true;\n});\nfunction createSearchPanel(view) {\n    return view.state.facet(searchConfigFacet).createPanel(view);\n}\nfunction defaultQuery(state, fallback) {\n    var _a, _b, _c, _d, _e;\n    let sel = state.selection.main;\n    let selText = sel.empty || sel.to > sel.from + 100 ? \"\" : state.sliceDoc(sel.from, sel.to);\n    if (fallback && !selText) return fallback;\n    let config = state.facet(searchConfigFacet);\n    return new SearchQuery({\n        search: ((_a = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _a !== void 0 ? _a : config.literal) ? selText : selText.replace(/\\n/g, \"\\\\n\"),\n        caseSensitive: (_b = fallback === null || fallback === void 0 ? void 0 : fallback.caseSensitive) !== null && _b !== void 0 ? _b : config.caseSensitive,\n        literal: (_c = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _c !== void 0 ? _c : config.literal,\n        regexp: (_d = fallback === null || fallback === void 0 ? void 0 : fallback.regexp) !== null && _d !== void 0 ? _d : config.regexp,\n        wholeWord: (_e = fallback === null || fallback === void 0 ? void 0 : fallback.wholeWord) !== null && _e !== void 0 ? _e : config.wholeWord\n    });\n}\nfunction getSearchInput(view) {\n    let panel = (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.getPanel)(view, createSearchPanel);\n    return panel && panel.dom.querySelector(\"[main-field]\");\n}\nfunction selectSearchInput(view) {\n    let input = getSearchInput(view);\n    if (input && input == view.root.activeElement) input.select();\n}\n/**\nMake sure the search panel is open and focused.\n*/ const openSearchPanel = (view)=>{\n    let state = view.state.field(searchState, false);\n    if (state && state.panel) {\n        let searchInput = getSearchInput(view);\n        if (searchInput && searchInput != view.root.activeElement) {\n            let query = defaultQuery(view.state, state.query.spec);\n            if (query.valid) view.dispatch({\n                effects: setSearchQuery.of(query)\n            });\n            searchInput.focus();\n            searchInput.select();\n        }\n    } else {\n        view.dispatch({\n            effects: [\n                togglePanel.of(true),\n                state ? setSearchQuery.of(defaultQuery(view.state, state.query.spec)) : _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.appendConfig.of(searchExtensions)\n            ]\n        });\n    }\n    return true;\n};\n/**\nClose the search panel.\n*/ const closeSearchPanel = (view)=>{\n    let state = view.state.field(searchState, false);\n    if (!state || !state.panel) return false;\n    let panel = (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.getPanel)(view, createSearchPanel);\n    if (panel && panel.dom.contains(view.root.activeElement)) view.focus();\n    view.dispatch({\n        effects: togglePanel.of(false)\n    });\n    return true;\n};\n/**\nDefault search-related key bindings.\n\n - Mod-f: [`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel)\n - F3, Mod-g: [`findNext`](https://codemirror.net/6/docs/ref/#search.findNext)\n - Shift-F3, Shift-Mod-g: [`findPrevious`](https://codemirror.net/6/docs/ref/#search.findPrevious)\n - Mod-Alt-g: [`gotoLine`](https://codemirror.net/6/docs/ref/#search.gotoLine)\n - Mod-d: [`selectNextOccurrence`](https://codemirror.net/6/docs/ref/#search.selectNextOccurrence)\n*/ const searchKeymap = [\n    {\n        key: \"Mod-f\",\n        run: openSearchPanel,\n        scope: \"editor search-panel\"\n    },\n    {\n        key: \"F3\",\n        run: findNext,\n        shift: findPrevious,\n        scope: \"editor search-panel\",\n        preventDefault: true\n    },\n    {\n        key: \"Mod-g\",\n        run: findNext,\n        shift: findPrevious,\n        scope: \"editor search-panel\",\n        preventDefault: true\n    },\n    {\n        key: \"Escape\",\n        run: closeSearchPanel,\n        scope: \"editor search-panel\"\n    },\n    {\n        key: \"Mod-Shift-l\",\n        run: selectSelectionMatches\n    },\n    {\n        key: \"Mod-Alt-g\",\n        run: gotoLine\n    },\n    {\n        key: \"Mod-d\",\n        run: selectNextOccurrence,\n        preventDefault: true\n    }\n];\nclass SearchPanel {\n    constructor(view){\n        this.view = view;\n        let query = this.query = view.state.field(searchState).query.spec;\n        this.commit = this.commit.bind(this);\n        this.searchField = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"input\", {\n            value: query.search,\n            placeholder: phrase(view, \"Find\"),\n            \"aria-label\": phrase(view, \"Find\"),\n            class: \"cm-textfield\",\n            name: \"search\",\n            form: \"\",\n            \"main-field\": \"true\",\n            onchange: this.commit,\n            onkeyup: this.commit\n        });\n        this.replaceField = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"input\", {\n            value: query.replace,\n            placeholder: phrase(view, \"Replace\"),\n            \"aria-label\": phrase(view, \"Replace\"),\n            class: \"cm-textfield\",\n            name: \"replace\",\n            form: \"\",\n            onchange: this.commit,\n            onkeyup: this.commit\n        });\n        this.caseField = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"input\", {\n            type: \"checkbox\",\n            name: \"case\",\n            form: \"\",\n            checked: query.caseSensitive,\n            onchange: this.commit\n        });\n        this.reField = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"input\", {\n            type: \"checkbox\",\n            name: \"re\",\n            form: \"\",\n            checked: query.regexp,\n            onchange: this.commit\n        });\n        this.wordField = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"input\", {\n            type: \"checkbox\",\n            name: \"word\",\n            form: \"\",\n            checked: query.wholeWord,\n            onchange: this.commit\n        });\n        function button(name, onclick, content) {\n            return (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"button\", {\n                class: \"cm-button\",\n                name,\n                onclick,\n                type: \"button\"\n            }, content);\n        }\n        this.dom = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"div\", {\n            onkeydown: (e)=>this.keydown(e),\n            class: \"cm-search\"\n        }, [\n            this.searchField,\n            button(\"next\", ()=>findNext(view), [\n                phrase(view, \"next\")\n            ]),\n            button(\"prev\", ()=>findPrevious(view), [\n                phrase(view, \"previous\")\n            ]),\n            button(\"select\", ()=>selectMatches(view), [\n                phrase(view, \"all\")\n            ]),\n            (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"label\", null, [\n                this.caseField,\n                phrase(view, \"match case\")\n            ]),\n            (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"label\", null, [\n                this.reField,\n                phrase(view, \"regexp\")\n            ]),\n            (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"label\", null, [\n                this.wordField,\n                phrase(view, \"by word\")\n            ]),\n            ...view.state.readOnly ? [] : [\n                (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"br\"),\n                this.replaceField,\n                button(\"replace\", ()=>replaceNext(view), [\n                    phrase(view, \"replace\")\n                ]),\n                button(\"replaceAll\", ()=>replaceAll(view), [\n                    phrase(view, \"replace all\")\n                ])\n            ],\n            (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"button\", {\n                name: \"close\",\n                onclick: ()=>closeSearchPanel(view),\n                \"aria-label\": phrase(view, \"close\"),\n                type: \"button\"\n            }, [\n                \"\\xd7\"\n            ])\n        ]);\n    }\n    commit() {\n        let query = new SearchQuery({\n            search: this.searchField.value,\n            caseSensitive: this.caseField.checked,\n            regexp: this.reField.checked,\n            wholeWord: this.wordField.checked,\n            replace: this.replaceField.value\n        });\n        if (!query.eq(this.query)) {\n            this.query = query;\n            this.view.dispatch({\n                effects: setSearchQuery.of(query)\n            });\n        }\n    }\n    keydown(e) {\n        if ((0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.runScopeHandlers)(this.view, e, \"search-panel\")) {\n            e.preventDefault();\n        } else if (e.keyCode == 13 && e.target == this.searchField) {\n            e.preventDefault();\n            (e.shiftKey ? findPrevious : findNext)(this.view);\n        } else if (e.keyCode == 13 && e.target == this.replaceField) {\n            e.preventDefault();\n            replaceNext(this.view);\n        }\n    }\n    update(update) {\n        for (let tr of update.transactions)for (let effect of tr.effects){\n            if (effect.is(setSearchQuery) && !effect.value.eq(this.query)) this.setQuery(effect.value);\n        }\n    }\n    setQuery(query) {\n        this.query = query;\n        this.searchField.value = query.search;\n        this.replaceField.value = query.replace;\n        this.caseField.checked = query.caseSensitive;\n        this.reField.checked = query.regexp;\n        this.wordField.checked = query.wholeWord;\n    }\n    mount() {\n        this.searchField.select();\n    }\n    get pos() {\n        return 80;\n    }\n    get top() {\n        return this.view.state.facet(searchConfigFacet).top;\n    }\n}\nfunction phrase(view, phrase) {\n    return view.state.phrase(phrase);\n}\nconst AnnounceMargin = 30;\nconst Break = /[\\s\\.,:;?!]/;\nfunction announceMatch(view, { from, to }) {\n    let line = view.state.doc.lineAt(from), lineEnd = view.state.doc.lineAt(to).to;\n    let start = Math.max(line.from, from - AnnounceMargin), end = Math.min(lineEnd, to + AnnounceMargin);\n    let text = view.state.sliceDoc(start, end);\n    if (start != line.from) {\n        for(let i = 0; i < AnnounceMargin; i++)if (!Break.test(text[i + 1]) && Break.test(text[i])) {\n            text = text.slice(i);\n            break;\n        }\n    }\n    if (end != lineEnd) {\n        for(let i = text.length - 1; i > text.length - AnnounceMargin; i--)if (!Break.test(text[i - 1]) && Break.test(text[i])) {\n            text = text.slice(0, i);\n            break;\n        }\n    }\n    return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.announce.of(`${view.state.phrase(\"current match\")}. ${text} ${view.state.phrase(\"on line\")} ${line.number}.`);\n}\nconst baseTheme = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.baseTheme({\n    \".cm-panel.cm-search\": {\n        padding: \"2px 6px 4px\",\n        position: \"relative\",\n        \"& [name=close]\": {\n            position: \"absolute\",\n            top: \"0\",\n            right: \"4px\",\n            backgroundColor: \"inherit\",\n            border: \"none\",\n            font: \"inherit\",\n            padding: 0,\n            margin: 0\n        },\n        \"& input, & button, & label\": {\n            margin: \".2em .6em .2em 0\"\n        },\n        \"& input[type=checkbox]\": {\n            marginRight: \".2em\"\n        },\n        \"& label\": {\n            fontSize: \"80%\",\n            whiteSpace: \"pre\"\n        }\n    },\n    \"&light .cm-searchMatch\": {\n        backgroundColor: \"#ffff0054\"\n    },\n    \"&dark .cm-searchMatch\": {\n        backgroundColor: \"#00ffff8a\"\n    },\n    \"&light .cm-searchMatch-selected\": {\n        backgroundColor: \"#ff6a0054\"\n    },\n    \"&dark .cm-searchMatch-selected\": {\n        backgroundColor: \"#ff00ff8a\"\n    }\n});\nconst searchExtensions = [\n    searchState,\n    /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Prec.low(searchHighlighter),\n    baseTheme\n];\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3Ivc2VhcmNoL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUE2RztBQUNxRztBQUMxTDtBQUV4QixNQUFNb0IsaUJBQWlCLE9BQU9DLE9BQU9DLFNBQVMsQ0FBQ0MsU0FBUyxJQUFJLGFBQ3REQyxDQUFBQSxJQUFLQSxFQUFFRCxTQUFTLENBQUMsVUFBVUMsQ0FBQUEsSUFBS0E7QUFDdEM7OztBQUdBLEdBQ0EsTUFBTUM7SUFDRjs7Ozs7Ozs7Ozs7O0lBWUEsR0FDQUMsWUFBWUMsSUFBSSxFQUFFQyxLQUFLLEVBQUVDLE9BQU8sQ0FBQyxFQUFFQyxLQUFLSCxLQUFLSSxNQUFNLEVBQUVSLFNBQVMsRUFBRVMsSUFBSSxDQUFFO1FBQ2xFLElBQUksQ0FBQ0EsSUFBSSxHQUFHQTtRQUNaOzs7O1FBSUEsR0FDQSxJQUFJLENBQUNDLEtBQUssR0FBRztZQUFFSixNQUFNO1lBQUdDLElBQUk7UUFBRTtRQUM5Qjs7UUFFQSxHQUNBLElBQUksQ0FBQ0ksSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDQyxPQUFPLEdBQUcsRUFBRTtRQUNqQixJQUFJLENBQUNDLE1BQU0sR0FBRztRQUNkLElBQUksQ0FBQ0MsU0FBUyxHQUFHO1FBQ2pCLElBQUksQ0FBQ0MsSUFBSSxHQUFHWCxLQUFLWSxTQUFTLENBQUNWLE1BQU1DO1FBQ2pDLElBQUksQ0FBQ1UsV0FBVyxHQUFHWDtRQUNuQixJQUFJLENBQUNOLFNBQVMsR0FBR0EsWUFBWUMsQ0FBQUEsSUFBS0QsVUFBVUgsZUFBZUksTUFBTUo7UUFDakUsSUFBSSxDQUFDUSxLQUFLLEdBQUcsSUFBSSxDQUFDTCxTQUFTLENBQUNLO0lBQ2hDO0lBQ0FhLE9BQU87UUFDSCxJQUFJLElBQUksQ0FBQ0osU0FBUyxJQUFJLElBQUksQ0FBQ0QsTUFBTSxDQUFDTCxNQUFNLEVBQUU7WUFDdEMsSUFBSSxDQUFDUyxXQUFXLElBQUksSUFBSSxDQUFDSixNQUFNLENBQUNMLE1BQU07WUFDdEMsSUFBSSxDQUFDTyxJQUFJLENBQUNJLElBQUk7WUFDZCxJQUFJLElBQUksQ0FBQ0osSUFBSSxDQUFDSixJQUFJLEVBQ2QsT0FBTyxDQUFDO1lBQ1osSUFBSSxDQUFDRyxTQUFTLEdBQUc7WUFDakIsSUFBSSxDQUFDRCxNQUFNLEdBQUcsSUFBSSxDQUFDRSxJQUFJLENBQUNMLEtBQUs7UUFDakM7UUFDQSxPQUFPM0IsOERBQVdBLENBQUMsSUFBSSxDQUFDOEIsTUFBTSxFQUFFLElBQUksQ0FBQ0MsU0FBUztJQUNsRDtJQUNBOzs7OztJQUtBLEdBQ0FLLE9BQU87UUFDSCxNQUFPLElBQUksQ0FBQ1AsT0FBTyxDQUFDSixNQUFNLENBQ3RCLElBQUksQ0FBQ0ksT0FBTyxDQUFDUSxHQUFHO1FBQ3BCLE9BQU8sSUFBSSxDQUFDQyxlQUFlO0lBQy9CO0lBQ0E7Ozs7SUFJQSxHQUNBQSxrQkFBa0I7UUFDZCxPQUFTO1lBQ0wsSUFBSUYsT0FBTyxJQUFJLENBQUNELElBQUk7WUFDcEIsSUFBSUMsT0FBTyxHQUFHO2dCQUNWLElBQUksQ0FBQ1IsSUFBSSxHQUFHO2dCQUNaLE9BQU8sSUFBSTtZQUNmO1lBQ0EsSUFBSVcsTUFBTXRDLGdFQUFhQSxDQUFDbUMsT0FBT0ksUUFBUSxJQUFJLENBQUNOLFdBQVcsR0FBRyxJQUFJLENBQUNILFNBQVM7WUFDeEUsSUFBSSxDQUFDQSxTQUFTLElBQUk3QixnRUFBYUEsQ0FBQ2tDO1lBQ2hDLElBQUlLLE9BQU8sSUFBSSxDQUFDeEIsU0FBUyxDQUFDc0I7WUFDMUIsSUFBSyxJQUFJRyxJQUFJLEdBQUdDLE1BQU1ILFFBQVFFLElBQUs7Z0JBQy9CLElBQUlFLE9BQU9ILEtBQUtJLFVBQVUsQ0FBQ0g7Z0JBQzNCLElBQUlJLFFBQVEsSUFBSSxDQUFDQSxLQUFLLENBQUNGLE1BQU1EO2dCQUM3QixJQUFJRCxLQUFLRCxLQUFLaEIsTUFBTSxHQUFHLEdBQUc7b0JBQ3RCLElBQUlxQixPQUFPO3dCQUNQLElBQUksQ0FBQ25CLEtBQUssR0FBR21CO3dCQUNiLE9BQU8sSUFBSTtvQkFDZjtvQkFDQTtnQkFDSjtnQkFDQSxJQUFJSCxPQUFPSCxTQUFTRSxJQUFJSCxJQUFJZCxNQUFNLElBQUljLElBQUlNLFVBQVUsQ0FBQ0gsTUFBTUUsTUFDdkREO1lBQ1I7UUFDSjtJQUNKO0lBQ0FHLE1BQU1GLElBQUksRUFBRUQsR0FBRyxFQUFFO1FBQ2IsSUFBSUcsUUFBUTtRQUNaLElBQUssSUFBSUosSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQ2IsT0FBTyxDQUFDSixNQUFNLEVBQUVpQixLQUFLLEVBQUc7WUFDN0MsSUFBSUssUUFBUSxJQUFJLENBQUNsQixPQUFPLENBQUNhLEVBQUUsRUFBRU0sT0FBTztZQUNwQyxJQUFJLElBQUksQ0FBQzFCLEtBQUssQ0FBQ3VCLFVBQVUsQ0FBQ0UsVUFBVUgsTUFBTTtnQkFDdEMsSUFBSUcsU0FBUyxJQUFJLENBQUN6QixLQUFLLENBQUNHLE1BQU0sR0FBRyxHQUFHO29CQUNoQ3FCLFFBQVE7d0JBQUV2QixNQUFNLElBQUksQ0FBQ00sT0FBTyxDQUFDYSxJQUFJLEVBQUU7d0JBQUVsQixJQUFJbUIsTUFBTTtvQkFBRTtnQkFDckQsT0FDSztvQkFDRCxJQUFJLENBQUNkLE9BQU8sQ0FBQ2EsRUFBRTtvQkFDZk0sT0FBTztnQkFDWDtZQUNKO1lBQ0EsSUFBSSxDQUFDQSxNQUFNO2dCQUNQLElBQUksQ0FBQ25CLE9BQU8sQ0FBQ29CLE1BQU0sQ0FBQ1AsR0FBRztnQkFDdkJBLEtBQUs7WUFDVDtRQUNKO1FBQ0EsSUFBSSxJQUFJLENBQUNwQixLQUFLLENBQUN1QixVQUFVLENBQUMsTUFBTUQsTUFBTTtZQUNsQyxJQUFJLElBQUksQ0FBQ3RCLEtBQUssQ0FBQ0csTUFBTSxJQUFJLEdBQ3JCcUIsUUFBUTtnQkFBRXZCLE1BQU1vQjtnQkFBS25CLElBQUltQixNQUFNO1lBQUU7aUJBRWpDLElBQUksQ0FBQ2QsT0FBTyxDQUFDcUIsSUFBSSxDQUFDLEdBQUdQO1FBQzdCO1FBQ0EsSUFBSUcsU0FBUyxJQUFJLENBQUNwQixJQUFJLElBQUksQ0FBQyxJQUFJLENBQUNBLElBQUksQ0FBQ29CLE1BQU12QixJQUFJLEVBQUV1QixNQUFNdEIsRUFBRSxFQUFFLElBQUksQ0FBQ00sTUFBTSxFQUFFLElBQUksQ0FBQ0ksV0FBVyxHQUNwRlksUUFBUTtRQUNaLE9BQU9BO0lBQ1g7QUFDSjtBQUNBLElBQUksT0FBT0ssVUFBVSxhQUNqQmhDLGFBQWFILFNBQVMsQ0FBQ21DLE9BQU9DLFFBQVEsQ0FBQyxHQUFHO0lBQWMsT0FBTyxJQUFJO0FBQUU7QUFFekUsTUFBTUMsUUFBUTtJQUFFOUIsTUFBTSxDQUFDO0lBQUdDLElBQUksQ0FBQztJQUFHc0IsT0FBTyxXQUFXLEdBQUUsS0FBS1EsSUFBSSxDQUFDO0FBQUk7QUFDcEUsTUFBTUMsWUFBWSxPQUFRLEtBQUlDLE9BQU8sSUFBSSxPQUFPLEtBQUssR0FBRTtBQUN2RDs7OztBQUlBLEdBQ0EsTUFBTUM7SUFDRjs7OztJQUlBLEdBQ0FyQyxZQUFZQyxJQUFJLEVBQUVDLEtBQUssRUFBRW9DLE9BQU8sRUFBRW5DLE9BQU8sQ0FBQyxFQUFFQyxLQUFLSCxLQUFLSSxNQUFNLENBQUU7UUFDMUQsSUFBSSxDQUFDSixJQUFJLEdBQUdBO1FBQ1osSUFBSSxDQUFDRyxFQUFFLEdBQUdBO1FBQ1YsSUFBSSxDQUFDbUMsT0FBTyxHQUFHO1FBQ2Y7OztRQUdBLEdBQ0EsSUFBSSxDQUFDL0IsSUFBSSxHQUFHO1FBQ1o7Ozs7UUFJQSxHQUNBLElBQUksQ0FBQ0QsS0FBSyxHQUFHMEI7UUFDYixJQUFJLHVCQUF1QjNCLElBQUksQ0FBQ0osUUFDNUIsT0FBTyxJQUFJc0Msc0JBQXNCdkMsTUFBTUMsT0FBT29DLFNBQVNuQyxNQUFNQztRQUNqRSxJQUFJLENBQUNxQyxFQUFFLEdBQUcsSUFBSUMsT0FBT3hDLE9BQU9pQyxZQUFhLEVBQUNHLFlBQVksUUFBUUEsWUFBWSxLQUFLLElBQUksS0FBSyxJQUFJQSxRQUFRSyxVQUFVLElBQUksTUFBTSxFQUFDO1FBQ3pILElBQUksQ0FBQ3JDLElBQUksR0FBR2dDLFlBQVksUUFBUUEsWUFBWSxLQUFLLElBQUksS0FBSyxJQUFJQSxRQUFRaEMsSUFBSTtRQUMxRSxJQUFJLENBQUNNLElBQUksR0FBR1gsS0FBS1csSUFBSTtRQUNyQixJQUFJZ0MsWUFBWTNDLEtBQUs0QyxNQUFNLENBQUMxQztRQUM1QixJQUFJLENBQUMyQyxZQUFZLEdBQUdGLFVBQVV6QyxJQUFJO1FBQ2xDLElBQUksQ0FBQzRDLFFBQVEsR0FBR0MsVUFBVS9DLE1BQU1FO1FBQ2hDLElBQUksQ0FBQzhDLE9BQU8sQ0FBQyxJQUFJLENBQUNILFlBQVk7SUFDbEM7SUFDQUcsUUFBUUMsSUFBSSxFQUFFO1FBQ1YsSUFBSSxDQUFDdEMsSUFBSSxDQUFDSSxJQUFJLENBQUNrQztRQUNmLElBQUksSUFBSSxDQUFDdEMsSUFBSSxDQUFDdUMsU0FBUyxFQUFFO1lBQ3JCLElBQUksQ0FBQ1osT0FBTyxHQUFHO1FBQ25CLE9BQ0s7WUFDRCxJQUFJLENBQUNBLE9BQU8sR0FBRyxJQUFJLENBQUMzQixJQUFJLENBQUNMLEtBQUs7WUFDOUIsSUFBSSxJQUFJLENBQUN1QyxZQUFZLEdBQUcsSUFBSSxDQUFDUCxPQUFPLENBQUNsQyxNQUFNLEdBQUcsSUFBSSxDQUFDRCxFQUFFLEVBQ2pELElBQUksQ0FBQ21DLE9BQU8sR0FBRyxJQUFJLENBQUNBLE9BQU8sQ0FBQ2EsS0FBSyxDQUFDLEdBQUcsSUFBSSxDQUFDaEQsRUFBRSxHQUFHLElBQUksQ0FBQzBDLFlBQVk7WUFDcEUsSUFBSSxDQUFDbEMsSUFBSSxDQUFDSSxJQUFJO1FBQ2xCO0lBQ0o7SUFDQXFDLFdBQVc7UUFDUCxJQUFJLENBQUNQLFlBQVksR0FBRyxJQUFJLENBQUNBLFlBQVksR0FBRyxJQUFJLENBQUNQLE9BQU8sQ0FBQ2xDLE1BQU0sR0FBRztRQUM5RCxJQUFJLElBQUksQ0FBQ3lDLFlBQVksR0FBRyxJQUFJLENBQUMxQyxFQUFFLEVBQzNCLElBQUksQ0FBQ21DLE9BQU8sR0FBRzthQUVmLElBQUksQ0FBQ1UsT0FBTyxDQUFDO0lBQ3JCO0lBQ0E7O0lBRUEsR0FDQWpDLE9BQU87UUFDSCxJQUFLLElBQUlzQyxNQUFNLElBQUksQ0FBQ1AsUUFBUSxHQUFHLElBQUksQ0FBQ0QsWUFBWSxHQUFJO1lBQ2hELElBQUksQ0FBQ0wsRUFBRSxDQUFDYyxTQUFTLEdBQUdEO1lBQ3BCLElBQUk1QixRQUFRLElBQUksQ0FBQ3FCLFFBQVEsSUFBSSxJQUFJLENBQUMzQyxFQUFFLElBQUksSUFBSSxDQUFDcUMsRUFBRSxDQUFDUCxJQUFJLENBQUMsSUFBSSxDQUFDSyxPQUFPO1lBQ2pFLElBQUliLE9BQU87Z0JBQ1AsSUFBSXZCLE9BQU8sSUFBSSxDQUFDMkMsWUFBWSxHQUFHcEIsTUFBTUMsS0FBSyxFQUFFdkIsS0FBS0QsT0FBT3VCLEtBQUssQ0FBQyxFQUFFLENBQUNyQixNQUFNO2dCQUN2RSxJQUFJLENBQUMwQyxRQUFRLEdBQUdDLFVBQVUsSUFBSSxDQUFDL0MsSUFBSSxFQUFFRyxLQUFNRCxDQUFBQSxRQUFRQyxLQUFLLElBQUk7Z0JBQzVELElBQUlELFFBQVEsSUFBSSxDQUFDMkMsWUFBWSxHQUFHLElBQUksQ0FBQ1AsT0FBTyxDQUFDbEMsTUFBTSxFQUMvQyxJQUFJLENBQUNnRCxRQUFRO2dCQUNqQixJQUFJLENBQUNsRCxPQUFPQyxNQUFNRCxPQUFPLElBQUksQ0FBQ0ksS0FBSyxDQUFDSCxFQUFFLEtBQU0sRUFBQyxJQUFJLENBQUNFLElBQUksSUFBSSxJQUFJLENBQUNBLElBQUksQ0FBQ0gsTUFBTUMsSUFBSXNCLE1BQUssR0FBSTtvQkFDbkYsSUFBSSxDQUFDbkIsS0FBSyxHQUFHO3dCQUFFSjt3QkFBTUM7d0JBQUlzQjtvQkFBTTtvQkFDL0IsT0FBTyxJQUFJO2dCQUNmO2dCQUNBNEIsTUFBTSxJQUFJLENBQUNQLFFBQVEsR0FBRyxJQUFJLENBQUNELFlBQVk7WUFDM0MsT0FDSyxJQUFJLElBQUksQ0FBQ0EsWUFBWSxHQUFHLElBQUksQ0FBQ1AsT0FBTyxDQUFDbEMsTUFBTSxHQUFHLElBQUksQ0FBQ0QsRUFBRSxFQUFFO2dCQUN4RCxJQUFJLENBQUNpRCxRQUFRO2dCQUNiQyxNQUFNO1lBQ1YsT0FDSztnQkFDRCxJQUFJLENBQUM5QyxJQUFJLEdBQUc7Z0JBQ1osT0FBTyxJQUFJO1lBQ2Y7UUFDSjtJQUNKO0FBQ0o7QUFDQSxNQUFNZ0QsWUFBWSxXQUFXLEdBQUUsSUFBSUM7QUFDbkMsa0RBQWtEO0FBQ2xELE1BQU1DO0lBQ0YxRCxZQUFZRyxJQUFJLEVBQUVGLElBQUksQ0FBRTtRQUNwQixJQUFJLENBQUNFLElBQUksR0FBR0E7UUFDWixJQUFJLENBQUNGLElBQUksR0FBR0E7SUFDaEI7SUFDQSxJQUFJRyxLQUFLO1FBQUUsT0FBTyxJQUFJLENBQUNELElBQUksR0FBRyxJQUFJLENBQUNGLElBQUksQ0FBQ0ksTUFBTTtJQUFFO0lBQ2hELE9BQU9zRCxJQUFJQyxHQUFHLEVBQUV6RCxJQUFJLEVBQUVDLEVBQUUsRUFBRTtRQUN0QixJQUFJeUQsU0FBU0wsVUFBVUcsR0FBRyxDQUFDQztRQUMzQixJQUFJLENBQUNDLFVBQVVBLE9BQU8xRCxJQUFJLElBQUlDLE1BQU15RCxPQUFPekQsRUFBRSxJQUFJRCxNQUFNO1lBQ25ELElBQUkyRCxPQUFPLElBQUlKLGFBQWF2RCxNQUFNeUQsSUFBSUcsV0FBVyxDQUFDNUQsTUFBTUM7WUFDeERvRCxVQUFVUSxHQUFHLENBQUNKLEtBQUtFO1lBQ25CLE9BQU9BO1FBQ1g7UUFDQSxJQUFJRCxPQUFPMUQsSUFBSSxJQUFJQSxRQUFRMEQsT0FBT3pELEVBQUUsSUFBSUEsSUFDcEMsT0FBT3lEO1FBQ1gsSUFBSSxFQUFFNUQsSUFBSSxFQUFFRSxNQUFNOEQsVUFBVSxFQUFFLEdBQUdKO1FBQ2pDLElBQUlJLGFBQWE5RCxNQUFNO1lBQ25CRixPQUFPMkQsSUFBSUcsV0FBVyxDQUFDNUQsTUFBTThELGNBQWNoRTtZQUMzQ2dFLGFBQWE5RDtRQUNqQjtRQUNBLElBQUkwRCxPQUFPekQsRUFBRSxHQUFHQSxJQUNaSCxRQUFRMkQsSUFBSUcsV0FBVyxDQUFDRixPQUFPekQsRUFBRSxFQUFFQTtRQUN2Q29ELFVBQVVRLEdBQUcsQ0FBQ0osS0FBSyxJQUFJRixhQUFhTyxZQUFZaEU7UUFDaEQsT0FBTyxJQUFJeUQsYUFBYXZELE1BQU1GLEtBQUttRCxLQUFLLENBQUNqRCxPQUFPOEQsWUFBWTdELEtBQUs2RDtJQUNyRTtBQUNKO0FBQ0EsTUFBTXpCO0lBQ0Z4QyxZQUFZQyxJQUFJLEVBQUVDLEtBQUssRUFBRW9DLE9BQU8sRUFBRW5DLElBQUksRUFBRUMsRUFBRSxDQUFFO1FBQ3hDLElBQUksQ0FBQ0gsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQ0csRUFBRSxHQUFHQTtRQUNWLElBQUksQ0FBQ0ksSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDRCxLQUFLLEdBQUcwQjtRQUNiLElBQUksQ0FBQ2MsUUFBUSxHQUFHQyxVQUFVL0MsTUFBTUU7UUFDaEMsSUFBSSxDQUFDc0MsRUFBRSxHQUFHLElBQUlDLE9BQU94QyxPQUFPaUMsWUFBYSxFQUFDRyxZQUFZLFFBQVFBLFlBQVksS0FBSyxJQUFJLEtBQUssSUFBSUEsUUFBUUssVUFBVSxJQUFJLE1BQU0sRUFBQztRQUN6SCxJQUFJLENBQUNyQyxJQUFJLEdBQUdnQyxZQUFZLFFBQVFBLFlBQVksS0FBSyxJQUFJLEtBQUssSUFBSUEsUUFBUWhDLElBQUk7UUFDMUUsSUFBSSxDQUFDd0QsSUFBSSxHQUFHSixhQUFhQyxHQUFHLENBQUMxRCxNQUFNRSxNQUFNLElBQUksQ0FBQytELFFBQVEsQ0FBQy9ELE9BQU8sS0FBSyxjQUFjO0lBQ3JGO0lBQ0ErRCxTQUFTM0MsR0FBRyxFQUFFO1FBQ1YsT0FBT0EsT0FBTyxJQUFJLENBQUNuQixFQUFFLEdBQUcsSUFBSSxDQUFDQSxFQUFFLEdBQUcsSUFBSSxDQUFDSCxJQUFJLENBQUM0QyxNQUFNLENBQUN0QixLQUFLbkIsRUFBRTtJQUM5RDtJQUNBWSxPQUFPO1FBQ0gsT0FBUztZQUNMLElBQUlzQyxNQUFNLElBQUksQ0FBQ2IsRUFBRSxDQUFDYyxTQUFTLEdBQUcsSUFBSSxDQUFDUixRQUFRLEdBQUcsSUFBSSxDQUFDZSxJQUFJLENBQUMzRCxJQUFJO1lBQzVELElBQUl1QixRQUFRLElBQUksQ0FBQ2UsRUFBRSxDQUFDUCxJQUFJLENBQUMsSUFBSSxDQUFDNEIsSUFBSSxDQUFDN0QsSUFBSTtZQUN2QyxtREFBbUQ7WUFDbkQsSUFBSXlCLFNBQVMsQ0FBQ0EsS0FBSyxDQUFDLEVBQUUsSUFBSUEsTUFBTUMsS0FBSyxJQUFJMkIsS0FBSztnQkFDMUMsSUFBSSxDQUFDYixFQUFFLENBQUNjLFNBQVMsR0FBR0QsTUFBTTtnQkFDMUI1QixRQUFRLElBQUksQ0FBQ2UsRUFBRSxDQUFDUCxJQUFJLENBQUMsSUFBSSxDQUFDNEIsSUFBSSxDQUFDN0QsSUFBSTtZQUN2QztZQUNBLElBQUl5QixPQUFPO2dCQUNQLElBQUl2QixPQUFPLElBQUksQ0FBQzJELElBQUksQ0FBQzNELElBQUksR0FBR3VCLE1BQU1DLEtBQUssRUFBRXZCLEtBQUtELE9BQU91QixLQUFLLENBQUMsRUFBRSxDQUFDckIsTUFBTTtnQkFDcEUsZ0VBQWdFO2dCQUNoRSxrREFBa0Q7Z0JBQ2xELElBQUksQ0FBQyxJQUFJLENBQUN5RCxJQUFJLENBQUMxRCxFQUFFLElBQUksSUFBSSxDQUFDQSxFQUFFLElBQUlzQixNQUFNQyxLQUFLLEdBQUdELEtBQUssQ0FBQyxFQUFFLENBQUNyQixNQUFNLElBQUksSUFBSSxDQUFDeUQsSUFBSSxDQUFDN0QsSUFBSSxDQUFDSSxNQUFNLEdBQUcsRUFBQyxLQUNyRixFQUFDLElBQUksQ0FBQ0MsSUFBSSxJQUFJLElBQUksQ0FBQ0EsSUFBSSxDQUFDSCxNQUFNQyxJQUFJc0IsTUFBSyxHQUFJO29CQUM1QyxJQUFJLENBQUNuQixLQUFLLEdBQUc7d0JBQUVKO3dCQUFNQzt3QkFBSXNCO29CQUFNO29CQUMvQixJQUFJLENBQUNxQixRQUFRLEdBQUdDLFVBQVUsSUFBSSxDQUFDL0MsSUFBSSxFQUFFRyxLQUFNRCxDQUFBQSxRQUFRQyxLQUFLLElBQUk7b0JBQzVELE9BQU8sSUFBSTtnQkFDZjtZQUNKO1lBQ0EsSUFBSSxJQUFJLENBQUMwRCxJQUFJLENBQUMxRCxFQUFFLElBQUksSUFBSSxDQUFDQSxFQUFFLEVBQUU7Z0JBQ3pCLElBQUksQ0FBQ0ksSUFBSSxHQUFHO2dCQUNaLE9BQU8sSUFBSTtZQUNmO1lBQ0EseUJBQXlCO1lBQ3pCLElBQUksQ0FBQ3NELElBQUksR0FBR0osYUFBYUMsR0FBRyxDQUFDLElBQUksQ0FBQzFELElBQUksRUFBRSxJQUFJLENBQUM2RCxJQUFJLENBQUMzRCxJQUFJLEVBQUUsSUFBSSxDQUFDK0QsUUFBUSxDQUFDLElBQUksQ0FBQ0osSUFBSSxDQUFDM0QsSUFBSSxHQUFHLElBQUksQ0FBQzJELElBQUksQ0FBQzdELElBQUksQ0FBQ0ksTUFBTSxHQUFHO1FBQ25IO0lBQ0o7QUFDSjtBQUNBLElBQUksT0FBTzBCLFVBQVUsYUFBYTtJQUM5Qk0sYUFBYXpDLFNBQVMsQ0FBQ21DLE9BQU9DLFFBQVEsQ0FBQyxHQUFHUSxzQkFBc0I1QyxTQUFTLENBQUNtQyxPQUFPQyxRQUFRLENBQUMsR0FDdEY7UUFBYyxPQUFPLElBQUk7SUFBRTtBQUNuQztBQUNBLFNBQVNtQyxZQUFZQyxNQUFNO0lBQ3ZCLElBQUk7UUFDQSxJQUFJMUIsT0FBTzBCLFFBQVFqQztRQUNuQixPQUFPO0lBQ1gsRUFDQSxPQUFPa0MsSUFBSTtRQUNQLE9BQU87SUFDWDtBQUNKO0FBQ0EsU0FBU3JCLFVBQVUvQyxJQUFJLEVBQUVzQixHQUFHO0lBQ3hCLElBQUlBLE9BQU90QixLQUFLSSxNQUFNLEVBQ2xCLE9BQU9rQjtJQUNYLElBQUkrQyxPQUFPckUsS0FBSzRDLE1BQU0sQ0FBQ3RCLE1BQU1QO0lBQzdCLE1BQU9PLE1BQU0rQyxLQUFLbEUsRUFBRSxJQUFJLENBQUNZLE9BQU9zRCxLQUFLckUsSUFBSSxDQUFDd0IsVUFBVSxDQUFDRixNQUFNK0MsS0FBS25FLElBQUksTUFBTSxVQUFVYSxPQUFPLE9BQ3ZGTztJQUNKLE9BQU9BO0FBQ1g7QUFFQSxTQUFTZ0QsaUJBQWlCQyxJQUFJO0lBQzFCLElBQUlGLE9BQU8zRSxPQUFPNkUsS0FBS0MsS0FBSyxDQUFDYixHQUFHLENBQUNmLE1BQU0sQ0FBQzJCLEtBQUtDLEtBQUssQ0FBQ0MsU0FBUyxDQUFDQyxJQUFJLENBQUNDLElBQUksRUFBRUMsTUFBTTtJQUM5RSxJQUFJQyxRQUFRckYsaURBQUdBLENBQUMsU0FBUztRQUFFc0YsT0FBTztRQUFnQkMsTUFBTTtRQUFRekUsT0FBTytEO0lBQUs7SUFDNUUsSUFBSVcsTUFBTXhGLGlEQUFHQSxDQUFDLFFBQVE7UUFDbEJzRixPQUFPO1FBQ1BHLFdBQVcsQ0FBQ0M7WUFDUixJQUFJQSxNQUFNQyxPQUFPLElBQUksSUFBSTtnQkFDckJELE1BQU1FLGNBQWM7Z0JBQ3BCYixLQUFLYyxRQUFRLENBQUM7b0JBQUVDLFNBQVNDLGFBQWFDLEVBQUUsQ0FBQztnQkFBTztnQkFDaERqQixLQUFLa0IsS0FBSztZQUNkLE9BQ0ssSUFBSVAsTUFBTUMsT0FBTyxJQUFJLElBQUk7Z0JBQzFCRCxNQUFNRSxjQUFjO2dCQUNwQk07WUFDSjtRQUNKO1FBQ0FDLFVBQVUsQ0FBQ1Q7WUFDUEEsTUFBTUUsY0FBYztZQUNwQk07UUFDSjtJQUNKLEdBQUdsRyxpREFBR0EsQ0FBQyxTQUFTK0UsS0FBS0MsS0FBSyxDQUFDb0IsTUFBTSxDQUFDLGVBQWUsTUFBTWYsUUFBUSxLQUFLckYsaURBQUdBLENBQUMsVUFBVTtRQUFFc0YsT0FBTztRQUFhZSxNQUFNO0lBQVMsR0FBR3RCLEtBQUtDLEtBQUssQ0FBQ29CLE1BQU0sQ0FBQztJQUM1SSxTQUFTRjtRQUNMLElBQUlqRSxRQUFRLDZCQUE2QlEsSUFBSSxDQUFDNEMsTUFBTXZFLEtBQUs7UUFDekQsSUFBSSxDQUFDbUIsT0FDRDtRQUNKLElBQUksRUFBRStDLEtBQUssRUFBRSxHQUFHRCxNQUFNNUIsWUFBWTZCLE1BQU1iLEdBQUcsQ0FBQ2YsTUFBTSxDQUFDNEIsTUFBTUMsU0FBUyxDQUFDQyxJQUFJLENBQUNDLElBQUk7UUFDNUUsSUFBSSxHQUFHbUIsTUFBTUMsSUFBSUMsSUFBSUMsUUFBUSxHQUFHeEU7UUFDaEMsSUFBSXlFLE1BQU1GLEtBQUssQ0FBQ0EsR0FBRzdDLEtBQUssQ0FBQyxLQUFLO1FBQzlCLElBQUlrQixPQUFPMEIsS0FBSyxDQUFDQSxLQUFLcEQsVUFBVWlDLE1BQU07UUFDdEMsSUFBSW1CLE1BQU1FLFNBQVM7WUFDZixJQUFJRSxLQUFLOUIsT0FBTztZQUNoQixJQUFJeUIsTUFDQUssS0FBS0EsS0FBTUwsQ0FBQUEsUUFBUSxNQUFNLENBQUMsSUFBSSxLQUFNbkQsVUFBVWlDLE1BQU0sR0FBR0osTUFBTWIsR0FBRyxDQUFDeUMsS0FBSztZQUMxRS9CLE9BQU9nQyxLQUFLQyxLQUFLLENBQUM5QixNQUFNYixHQUFHLENBQUN5QyxLQUFLLEdBQUdEO1FBQ3hDLE9BQ0ssSUFBSUosTUFBTUQsTUFBTTtZQUNqQnpCLE9BQU9BLE9BQVF5QixDQUFBQSxRQUFRLE1BQU0sQ0FBQyxJQUFJLEtBQUtuRCxVQUFVaUMsTUFBTTtRQUMzRDtRQUNBLElBQUkyQixVQUFVL0IsTUFBTWIsR0FBRyxDQUFDVSxJQUFJLENBQUNnQyxLQUFLRyxHQUFHLENBQUMsR0FBR0gsS0FBS0ksR0FBRyxDQUFDakMsTUFBTWIsR0FBRyxDQUFDeUMsS0FBSyxFQUFFL0I7UUFDbkUsSUFBSUksWUFBWXpGLDhEQUFlQSxDQUFDMEgsTUFBTSxDQUFDSCxRQUFRckcsSUFBSSxHQUFHbUcsS0FBS0csR0FBRyxDQUFDLEdBQUdILEtBQUtJLEdBQUcsQ0FBQ1AsS0FBS0ssUUFBUW5HLE1BQU07UUFDOUZtRSxLQUFLYyxRQUFRLENBQUM7WUFDVkMsU0FBUztnQkFBQ0MsYUFBYUMsRUFBRSxDQUFDO2dCQUFRbEgsd0RBQVVBLENBQUNxSSxjQUFjLENBQUNsQyxVQUFVdkUsSUFBSSxFQUFFO29CQUFFMEcsR0FBRztnQkFBUzthQUFHO1lBQzdGbkM7UUFDSjtRQUNBRixLQUFLa0IsS0FBSztJQUNkO0lBQ0EsT0FBTztRQUFFVDtJQUFJO0FBQ2pCO0FBQ0EsTUFBTU8sZUFBZSxXQUFXLEdBQUV6RywwREFBV0EsQ0FBQytILE1BQU07QUFDcEQsTUFBTUMsY0FBYyxXQUFXLEdBQUUvSCx5REFBVUEsQ0FBQzhILE1BQU0sQ0FBQztJQUMvQ0U7UUFBVyxPQUFPO0lBQU07SUFDeEJDLFFBQU8xRyxLQUFLLEVBQUUyRyxFQUFFO1FBQ1osS0FBSyxJQUFJQyxLQUFLRCxHQUFHM0IsT0FBTyxDQUNwQixJQUFJNEIsRUFBRUMsRUFBRSxDQUFDNUIsZUFDTGpGLFFBQVE0RyxFQUFFNUcsS0FBSztRQUN2QixPQUFPQTtJQUNYO0lBQ0E4RyxTQUFTQyxDQUFBQSxJQUFLaEosdURBQVNBLENBQUM2QixJQUFJLENBQUNtSCxHQUFHQyxDQUFBQSxNQUFPQSxNQUFNaEQsbUJBQW1CO0FBQ3BFO0FBQ0E7Ozs7Ozs7O0FBUUEsR0FDQSxNQUFNaUQsV0FBV2hELENBQUFBO0lBQ2IsSUFBSWlELFFBQVFqSiwwREFBUUEsQ0FBQ2dHLE1BQU1EO0lBQzNCLElBQUksQ0FBQ2tELE9BQU87UUFDUixJQUFJbEMsVUFBVTtZQUFDQyxhQUFhQyxFQUFFLENBQUM7U0FBTTtRQUNyQyxJQUFJakIsS0FBS0MsS0FBSyxDQUFDaUQsS0FBSyxDQUFDWCxhQUFhLFVBQVUsTUFDeEN4QixRQUFRekQsSUFBSSxDQUFDL0MsMERBQVdBLENBQUM0SSxZQUFZLENBQUNsQyxFQUFFLENBQUM7WUFBQ3NCO1lBQWFhO1NBQVk7UUFDdkVwRCxLQUFLYyxRQUFRLENBQUM7WUFBRUM7UUFBUTtRQUN4QmtDLFFBQVFqSiwwREFBUUEsQ0FBQ2dHLE1BQU1EO0lBQzNCO0lBQ0EsSUFBSWtELE9BQ0FBLE1BQU14QyxHQUFHLENBQUM0QyxhQUFhLENBQUMsU0FBU0MsTUFBTTtJQUMzQyxPQUFPO0FBQ1g7QUFDQSxNQUFNRixjQUFjLFdBQVcsR0FBRXJKLHdEQUFVQSxDQUFDd0osU0FBUyxDQUFDO0lBQ2xELHlCQUF5QjtRQUNyQkMsU0FBUztRQUNULFdBQVc7WUFBRUMsVUFBVTtRQUFNO0lBQ2pDO0FBQ0o7QUFFQSxNQUFNQywwQkFBMEI7SUFDNUJDLDJCQUEyQjtJQUMzQkMsb0JBQW9CO0lBQ3BCQyxZQUFZO0lBQ1pDLFlBQVk7QUFDaEI7QUFDQSxNQUFNQyxrQkFBa0IsV0FBVyxHQUFFckosb0RBQUtBLENBQUM0SCxNQUFNLENBQUM7SUFDOUMwQixTQUFRbEcsT0FBTztRQUNYLE9BQU9uRCxnRUFBYUEsQ0FBQ21ELFNBQVM0Rix5QkFBeUI7WUFDbkRDLDJCQUEyQixDQUFDTSxHQUFHQyxJQUFNRCxLQUFLQztZQUMxQ04sb0JBQW9COUIsS0FBS0ksR0FBRztZQUM1QjJCLFlBQVkvQixLQUFLSSxHQUFHO1FBQ3hCO0lBQ0o7QUFDSjtBQUNBOzs7OztBQUtBLEdBQ0EsU0FBU2lDLDBCQUEwQnJHLE9BQU87SUFDdEMsSUFBSXNHLE1BQU07UUFBQ0M7UUFBY0M7S0FBaUI7SUFDMUMsSUFBSXhHLFNBQ0FzRyxJQUFJOUcsSUFBSSxDQUFDeUcsZ0JBQWdCOUMsRUFBRSxDQUFDbkQ7SUFDaEMsT0FBT3NHO0FBQ1g7QUFDQSxNQUFNRyxZQUFZLFdBQVcsR0FBRXRLLHdEQUFVQSxDQUFDdUssSUFBSSxDQUFDO0lBQUVqRSxPQUFPO0FBQW9CO0FBQzVFLE1BQU1rRSxnQkFBZ0IsV0FBVyxHQUFFeEssd0RBQVVBLENBQUN1SyxJQUFJLENBQUM7SUFBRWpFLE9BQU87QUFBMkM7QUFDdkcsc0ZBQXNGO0FBQ3RGLFNBQVNtRSxxQkFBcUJDLEtBQUssRUFBRTFFLEtBQUssRUFBRXRFLElBQUksRUFBRUMsRUFBRTtJQUNoRCxPQUFPLENBQUNELFFBQVEsS0FBS2dKLE1BQU0xRSxNQUFNMkUsUUFBUSxDQUFDakosT0FBTyxHQUFHQSxVQUFVZiwyREFBWUEsQ0FBQ2lLLElBQUksS0FDMUVqSixDQUFBQSxNQUFNcUUsTUFBTWIsR0FBRyxDQUFDdkQsTUFBTSxJQUFJOEksTUFBTTFFLE1BQU0yRSxRQUFRLENBQUNoSixJQUFJQSxLQUFLLE9BQU9oQiwyREFBWUEsQ0FBQ2lLLElBQUk7QUFDekY7QUFDQSw2RUFBNkU7QUFDN0UsU0FBU0MsV0FBV0gsS0FBSyxFQUFFMUUsS0FBSyxFQUFFdEUsSUFBSSxFQUFFQyxFQUFFO0lBQ3RDLE9BQU8rSSxNQUFNMUUsTUFBTTJFLFFBQVEsQ0FBQ2pKLE1BQU1BLE9BQU8sT0FBT2YsMkRBQVlBLENBQUNpSyxJQUFJLElBQzFERixNQUFNMUUsTUFBTTJFLFFBQVEsQ0FBQ2hKLEtBQUssR0FBR0EsUUFBUWhCLDJEQUFZQSxDQUFDaUssSUFBSTtBQUNqRTtBQUNBLE1BQU1QLG1CQUFtQixXQUFXLEdBQUVwSyx3REFBVUEsQ0FBQzZLLFNBQVMsQ0FBQztJQUN2RHZKLFlBQVl3RSxJQUFJLENBQUU7UUFDZCxJQUFJLENBQUNnRixXQUFXLEdBQUcsSUFBSSxDQUFDQyxPQUFPLENBQUNqRjtJQUNwQztJQUNBeUMsT0FBT0EsTUFBTSxFQUFFO1FBQ1gsSUFBSUEsT0FBT3lDLFlBQVksSUFBSXpDLE9BQU8wQyxVQUFVLElBQUkxQyxPQUFPMkMsZUFBZSxFQUNsRSxJQUFJLENBQUNKLFdBQVcsR0FBRyxJQUFJLENBQUNDLE9BQU8sQ0FBQ3hDLE9BQU96QyxJQUFJO0lBQ25EO0lBQ0FpRixRQUFRakYsSUFBSSxFQUFFO1FBQ1YsSUFBSXFGLE9BQU9yRixLQUFLQyxLQUFLLENBQUNxRixLQUFLLENBQUN2QjtRQUM1QixJQUFJLEVBQUU5RCxLQUFLLEVBQUUsR0FBR0QsTUFBTXVGLE1BQU10RixNQUFNQyxTQUFTO1FBQzNDLElBQUlxRixJQUFJQyxNQUFNLENBQUMzSixNQUFNLEdBQUcsR0FDcEIsT0FBTzVCLHdEQUFVQSxDQUFDd0wsSUFBSTtRQUMxQixJQUFJQyxRQUFRSCxJQUFJcEYsSUFBSSxFQUFFekUsT0FBT2lKLFFBQVE7UUFDckMsSUFBSWUsTUFBTWpJLEtBQUssRUFBRTtZQUNiLElBQUksQ0FBQzRILEtBQUsxQix5QkFBeUIsRUFDL0IsT0FBTzFKLHdEQUFVQSxDQUFDd0wsSUFBSTtZQUMxQixJQUFJRSxPQUFPMUYsTUFBTTJGLE1BQU0sQ0FBQ0YsTUFBTXRGLElBQUk7WUFDbEMsSUFBSSxDQUFDdUYsTUFDRCxPQUFPMUwsd0RBQVVBLENBQUN3TCxJQUFJO1lBQzFCZCxRQUFRMUUsTUFBTTRGLGVBQWUsQ0FBQ0gsTUFBTXRGLElBQUk7WUFDeEMxRSxRQUFRdUUsTUFBTTJFLFFBQVEsQ0FBQ2UsS0FBS2hLLElBQUksRUFBRWdLLEtBQUsvSixFQUFFO1FBQzdDLE9BQ0s7WUFDRCxJQUFJa0ssTUFBTUosTUFBTTlKLEVBQUUsR0FBRzhKLE1BQU0vSixJQUFJO1lBQy9CLElBQUltSyxNQUFNVCxLQUFLekIsa0JBQWtCLElBQUlrQyxNQUFNLEtBQ3ZDLE9BQU83TCx3REFBVUEsQ0FBQ3dMLElBQUk7WUFDMUIsSUFBSUosS0FBS3ZCLFVBQVUsRUFBRTtnQkFDakJwSSxRQUFRdUUsTUFBTTJFLFFBQVEsQ0FBQ2MsTUFBTS9KLElBQUksRUFBRStKLE1BQU05SixFQUFFLEdBQUcsa0RBQWtEO2dCQUNoRytJLFFBQVExRSxNQUFNNEYsZUFBZSxDQUFDSCxNQUFNdEYsSUFBSTtnQkFDeEMsSUFBSSxDQUFFc0UsQ0FBQUEscUJBQXFCQyxPQUFPMUUsT0FBT3lGLE1BQU0vSixJQUFJLEVBQUUrSixNQUFNOUosRUFBRSxLQUN0RGtKLFdBQVdILE9BQU8xRSxPQUFPeUYsTUFBTS9KLElBQUksRUFBRStKLE1BQU05SixFQUFFLElBQ2hELE9BQU8zQix3REFBVUEsQ0FBQ3dMLElBQUk7WUFDOUIsT0FDSztnQkFDRC9KLFFBQVF1RSxNQUFNMkUsUUFBUSxDQUFDYyxNQUFNL0osSUFBSSxFQUFFK0osTUFBTTlKLEVBQUUsRUFBRW1LLElBQUk7Z0JBQ2pELElBQUksQ0FBQ3JLLE9BQ0QsT0FBT3pCLHdEQUFVQSxDQUFDd0wsSUFBSTtZQUM5QjtRQUNKO1FBQ0EsSUFBSU8sT0FBTyxFQUFFO1FBQ2IsS0FBSyxJQUFJQyxRQUFRakcsS0FBS2tHLGFBQWEsQ0FBRTtZQUNqQyxJQUFJL0QsU0FBUyxJQUFJNUcsYUFBYTBFLE1BQU1iLEdBQUcsRUFBRTFELE9BQU91SyxLQUFLdEssSUFBSSxFQUFFc0ssS0FBS3JLLEVBQUU7WUFDbEUsTUFBTyxDQUFDdUcsT0FBTzNGLElBQUksR0FBR1IsSUFBSSxDQUFFO2dCQUN4QixJQUFJLEVBQUVMLElBQUksRUFBRUMsRUFBRSxFQUFFLEdBQUd1RyxPQUFPcEcsS0FBSztnQkFDL0IsSUFBSSxDQUFDNEksU0FBU0QscUJBQXFCQyxPQUFPMUUsT0FBT3RFLE1BQU1DLEtBQUs7b0JBQ3hELElBQUk4SixNQUFNakksS0FBSyxJQUFJOUIsUUFBUStKLE1BQU0vSixJQUFJLElBQUlDLE1BQU04SixNQUFNOUosRUFBRSxFQUNuRG9LLEtBQUsxSSxJQUFJLENBQUNtSCxjQUFjaUIsS0FBSyxDQUFDL0osTUFBTUM7eUJBQ25DLElBQUlELFFBQVErSixNQUFNOUosRUFBRSxJQUFJQSxNQUFNOEosTUFBTS9KLElBQUksRUFDekNxSyxLQUFLMUksSUFBSSxDQUFDaUgsVUFBVW1CLEtBQUssQ0FBQy9KLE1BQU1DO29CQUNwQyxJQUFJb0ssS0FBS25LLE1BQU0sR0FBR3dKLEtBQUt4QixVQUFVLEVBQzdCLE9BQU81Six3REFBVUEsQ0FBQ3dMLElBQUk7Z0JBQzlCO1lBQ0o7UUFDSjtRQUNBLE9BQU94TCx3REFBVUEsQ0FBQ3VGLEdBQUcsQ0FBQ3dHO0lBQzFCO0FBQ0osR0FBRztJQUNDaEIsYUFBYW1CLENBQUFBLElBQUtBLEVBQUVuQixXQUFXO0FBQ25DO0FBQ0EsTUFBTVgsZUFBZSxXQUFXLEdBQUV0Syx3REFBVUEsQ0FBQ3dKLFNBQVMsQ0FBQztJQUNuRCxzQkFBc0I7UUFBRTZDLGlCQUFpQjtJQUFZO0lBQ3JELHNDQUFzQztRQUFFQSxpQkFBaUI7SUFBYztBQUMzRTtBQUNBLHVDQUF1QztBQUN2QyxNQUFNQyxhQUFhLENBQUMsRUFBRXBHLEtBQUssRUFBRWEsUUFBUSxFQUFFO0lBQ25DLElBQUksRUFBRVosU0FBUyxFQUFFLEdBQUdEO0lBQ3BCLElBQUlxRyxTQUFTN0wsOERBQWVBLENBQUMrSCxNQUFNLENBQUN0QyxVQUFVc0YsTUFBTSxDQUFDZSxHQUFHLENBQUNiLENBQUFBLFFBQVN6RixNQUFNMkYsTUFBTSxDQUFDRixNQUFNdEYsSUFBSSxLQUFLM0YsOERBQWVBLENBQUMwSCxNQUFNLENBQUN1RCxNQUFNdEYsSUFBSSxJQUFJRixVQUFVc0csU0FBUztJQUN0SixJQUFJRixPQUFPRyxFQUFFLENBQUN2RyxZQUNWLE9BQU87SUFDWFksU0FBU2IsTUFBTXdDLE1BQU0sQ0FBQztRQUFFdkMsV0FBV29HO0lBQU87SUFDMUMsT0FBTztBQUNYO0FBQ0EscUVBQXFFO0FBQ3JFLDZDQUE2QztBQUM3QyxTQUFTSSxtQkFBbUJ6RyxLQUFLLEVBQUV2RSxLQUFLO0lBQ3BDLElBQUksRUFBRXlFLElBQUksRUFBRXFGLE1BQU0sRUFBRSxHQUFHdkYsTUFBTUMsU0FBUztJQUN0QyxJQUFJeUYsT0FBTzFGLE1BQU0yRixNQUFNLENBQUN6RixLQUFLQyxJQUFJLEdBQUd1RyxXQUFXaEIsUUFBUUEsS0FBS2hLLElBQUksSUFBSXdFLEtBQUt4RSxJQUFJLElBQUlnSyxLQUFLL0osRUFBRSxJQUFJdUUsS0FBS3ZFLEVBQUU7SUFDbkcsSUFBSyxJQUFJZ0wsU0FBUyxPQUFPekUsU0FBUyxJQUFJNUcsYUFBYTBFLE1BQU1iLEdBQUcsRUFBRTFELE9BQU84SixNQUFNLENBQUNBLE9BQU8zSixNQUFNLEdBQUcsRUFBRSxDQUFDRCxFQUFFLElBQUs7UUFDbEd1RyxPQUFPM0YsSUFBSTtRQUNYLElBQUkyRixPQUFPbkcsSUFBSSxFQUFFO1lBQ2IsSUFBSTRLLFFBQ0EsT0FBTztZQUNYekUsU0FBUyxJQUFJNUcsYUFBYTBFLE1BQU1iLEdBQUcsRUFBRTFELE9BQU8sR0FBR29HLEtBQUtHLEdBQUcsQ0FBQyxHQUFHdUQsTUFBTSxDQUFDQSxPQUFPM0osTUFBTSxHQUFHLEVBQUUsQ0FBQ0YsSUFBSSxHQUFHO1lBQzVGaUwsU0FBUztRQUNiLE9BQ0s7WUFDRCxJQUFJQSxVQUFVcEIsT0FBT3FCLElBQUksQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRW5MLElBQUksSUFBSXdHLE9BQU9wRyxLQUFLLENBQUNKLElBQUksR0FDdEQ7WUFDSixJQUFJZ0wsVUFBVTtnQkFDVixJQUFJaEIsT0FBTzFGLE1BQU0yRixNQUFNLENBQUN6RCxPQUFPcEcsS0FBSyxDQUFDSixJQUFJO2dCQUN6QyxJQUFJLENBQUNnSyxRQUFRQSxLQUFLaEssSUFBSSxJQUFJd0csT0FBT3BHLEtBQUssQ0FBQ0osSUFBSSxJQUFJZ0ssS0FBSy9KLEVBQUUsSUFBSXVHLE9BQU9wRyxLQUFLLENBQUNILEVBQUUsRUFDckU7WUFDUjtZQUNBLE9BQU91RyxPQUFPcEcsS0FBSztRQUN2QjtJQUNKO0FBQ0o7QUFDQTs7O0FBR0EsR0FDQSxNQUFNZ0wsdUJBQXVCLENBQUMsRUFBRTlHLEtBQUssRUFBRWEsUUFBUSxFQUFFO0lBQzdDLElBQUksRUFBRTBFLE1BQU0sRUFBRSxHQUFHdkYsTUFBTUMsU0FBUztJQUNoQyxJQUFJc0YsT0FBT3FCLElBQUksQ0FBQ3RCLENBQUFBLE1BQU9BLElBQUk1SixJQUFJLEtBQUs0SixJQUFJM0osRUFBRSxHQUN0QyxPQUFPeUssV0FBVztRQUFFcEc7UUFBT2E7SUFBUztJQUN4QyxJQUFJa0csZUFBZS9HLE1BQU0yRSxRQUFRLENBQUNZLE1BQU0sQ0FBQyxFQUFFLENBQUM3SixJQUFJLEVBQUU2SixNQUFNLENBQUMsRUFBRSxDQUFDNUosRUFBRTtJQUM5RCxJQUFJcUUsTUFBTUMsU0FBUyxDQUFDc0YsTUFBTSxDQUFDcUIsSUFBSSxDQUFDQyxDQUFBQSxJQUFLN0csTUFBTTJFLFFBQVEsQ0FBQ2tDLEVBQUVuTCxJQUFJLEVBQUVtTCxFQUFFbEwsRUFBRSxLQUFLb0wsZUFDakUsT0FBTztJQUNYLElBQUl0QixRQUFRZ0IsbUJBQW1CekcsT0FBTytHO0lBQ3RDLElBQUksQ0FBQ3RCLE9BQ0QsT0FBTztJQUNYNUUsU0FBU2IsTUFBTXdDLE1BQU0sQ0FBQztRQUNsQnZDLFdBQVdELE1BQU1DLFNBQVMsQ0FBQytHLFFBQVEsQ0FBQ3hNLDhEQUFlQSxDQUFDaUwsS0FBSyxDQUFDQSxNQUFNL0osSUFBSSxFQUFFK0osTUFBTTlKLEVBQUUsR0FBRztRQUNqRm1GLFNBQVNoSCx3REFBVUEsQ0FBQ3FJLGNBQWMsQ0FBQ3NELE1BQU05SixFQUFFO0lBQy9DO0lBQ0EsT0FBTztBQUNYO0FBRUEsTUFBTXNMLG9CQUFvQixXQUFXLEdBQUV4TSxvREFBS0EsQ0FBQzRILE1BQU0sQ0FBQztJQUNoRDBCLFNBQVFtRCxPQUFPO1FBQ1gsT0FBT3hNLGdFQUFhQSxDQUFDd00sU0FBUztZQUMxQkMsS0FBSztZQUNMQyxlQUFlO1lBQ2ZDLFNBQVM7WUFDVEMsUUFBUTtZQUNSQyxXQUFXO1lBQ1hDLGFBQWF6SCxDQUFBQSxPQUFRLElBQUkwSCxZQUFZMUg7WUFDckMySCxlQUFlakMsQ0FBQUEsUUFBUzNMLHdEQUFVQSxDQUFDcUksY0FBYyxDQUFDc0Q7UUFDdEQ7SUFDSjtBQUNKO0FBQ0E7Ozs7O0FBS0EsR0FDQSxTQUFTa0MsT0FBT0MsTUFBTTtJQUNsQixPQUFPQSxTQUFTO1FBQUNYLGtCQUFrQmpHLEVBQUUsQ0FBQzRHO1FBQVNDO0tBQWlCLEdBQUdBO0FBQ3ZFO0FBQ0E7O0FBRUEsR0FDQSxNQUFNQztJQUNGOztJQUVBLEdBQ0F2TSxZQUFZcU0sTUFBTSxDQUFFO1FBQ2hCLElBQUksQ0FBQ0QsTUFBTSxHQUFHQyxPQUFPRCxNQUFNO1FBQzNCLElBQUksQ0FBQ1AsYUFBYSxHQUFHLENBQUMsQ0FBQ1EsT0FBT1IsYUFBYTtRQUMzQyxJQUFJLENBQUNDLE9BQU8sR0FBRyxDQUFDLENBQUNPLE9BQU9QLE9BQU87UUFDL0IsSUFBSSxDQUFDQyxNQUFNLEdBQUcsQ0FBQyxDQUFDTSxPQUFPTixNQUFNO1FBQzdCLElBQUksQ0FBQ1MsT0FBTyxHQUFHSCxPQUFPRyxPQUFPLElBQUk7UUFDakMsSUFBSSxDQUFDQyxLQUFLLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQ0wsTUFBTSxJQUFLLEVBQUMsSUFBSSxDQUFDTCxNQUFNLElBQUk1SCxZQUFZLElBQUksQ0FBQ2lJLE1BQU07UUFDdEUsSUFBSSxDQUFDTSxRQUFRLEdBQUcsSUFBSSxDQUFDQyxPQUFPLENBQUMsSUFBSSxDQUFDUCxNQUFNO1FBQ3hDLElBQUksQ0FBQ0osU0FBUyxHQUFHLENBQUMsQ0FBQ0ssT0FBT0wsU0FBUztJQUN2QztJQUNBOztJQUVBLEdBQ0FXLFFBQVExTSxJQUFJLEVBQUU7UUFDVixPQUFPLElBQUksQ0FBQzZMLE9BQU8sR0FBRzdMLE9BQ2xCQSxLQUFLdU0sT0FBTyxDQUFDLGdCQUFnQixDQUFDSSxHQUFHQyxLQUFPQSxNQUFNLE1BQU0sT0FBT0EsTUFBTSxNQUFNLE9BQU9BLE1BQU0sTUFBTSxNQUFPO0lBQ3pHO0lBQ0E7O0lBRUEsR0FDQTVCLEdBQUc2QixLQUFLLEVBQUU7UUFDTixPQUFPLElBQUksQ0FBQ1YsTUFBTSxJQUFJVSxNQUFNVixNQUFNLElBQUksSUFBSSxDQUFDSSxPQUFPLElBQUlNLE1BQU1OLE9BQU8sSUFDL0QsSUFBSSxDQUFDWCxhQUFhLElBQUlpQixNQUFNakIsYUFBYSxJQUFJLElBQUksQ0FBQ0UsTUFBTSxJQUFJZSxNQUFNZixNQUFNLElBQ3hFLElBQUksQ0FBQ0MsU0FBUyxJQUFJYyxNQUFNZCxTQUFTO0lBQ3pDO0lBQ0E7O0lBRUEsR0FDQWhGLFNBQVM7UUFDTCxPQUFPLElBQUksQ0FBQytFLE1BQU0sR0FBRyxJQUFJZ0IsWUFBWSxJQUFJLElBQUksSUFBSUMsWUFBWSxJQUFJO0lBQ3JFO0lBQ0E7OztJQUdBLEdBQ0FDLFVBQVV4SSxLQUFLLEVBQUV0RSxPQUFPLENBQUMsRUFBRUMsRUFBRSxFQUFFO1FBQzNCLElBQUk4TSxLQUFLekksTUFBTWIsR0FBRyxHQUFHYSxRQUFRbEYsMERBQVdBLENBQUN5SCxNQUFNLENBQUM7WUFBRXBELEtBQUthO1FBQU07UUFDN0QsSUFBSXJFLE1BQU0sTUFDTkEsS0FBSzhNLEdBQUd0SixHQUFHLENBQUN2RCxNQUFNO1FBQ3RCLE9BQU8sSUFBSSxDQUFDMEwsTUFBTSxHQUFHb0IsYUFBYSxJQUFJLEVBQUVELElBQUkvTSxNQUFNQyxNQUFNZ04sYUFBYSxJQUFJLEVBQUVGLElBQUkvTSxNQUFNQztJQUN6RjtBQUNKO0FBQ0EsTUFBTWlOO0lBQ0ZyTixZQUFZc04sSUFBSSxDQUFFO1FBQ2QsSUFBSSxDQUFDQSxJQUFJLEdBQUdBO0lBQ2hCO0FBQ0o7QUFDQSxTQUFTRixhQUFhRSxJQUFJLEVBQUU3SSxLQUFLLEVBQUV0RSxJQUFJLEVBQUVDLEVBQUU7SUFDdkMsT0FBTyxJQUFJTCxhQUFhMEUsTUFBTWIsR0FBRyxFQUFFMEosS0FBS1osUUFBUSxFQUFFdk0sTUFBTUMsSUFBSWtOLEtBQUt6QixhQUFhLEdBQUcwQixZQUFZek4sQ0FBQUEsSUFBS0EsRUFBRTBOLFdBQVcsSUFBSUYsS0FBS3RCLFNBQVMsR0FBR3lCLGVBQWVoSixNQUFNYixHQUFHLEVBQUVhLE1BQU00RixlQUFlLENBQUM1RixNQUFNQyxTQUFTLENBQUNDLElBQUksQ0FBQ0MsSUFBSSxLQUFLMkk7QUFDdE47QUFDQSxTQUFTRSxlQUFlN0osR0FBRyxFQUFFOEosV0FBVztJQUNwQyxPQUFPLENBQUN2TixNQUFNQyxJQUFJdU4sS0FBS0M7UUFDbkIsSUFBSUEsU0FBU3pOLFFBQVF5TixTQUFTRCxJQUFJdE4sTUFBTSxHQUFHRCxJQUFJO1lBQzNDd04sU0FBU3RILEtBQUtHLEdBQUcsQ0FBQyxHQUFHdEcsT0FBTztZQUM1QndOLE1BQU0vSixJQUFJRyxXQUFXLENBQUM2SixRQUFRdEgsS0FBS0ksR0FBRyxDQUFDOUMsSUFBSXZELE1BQU0sRUFBRUQsS0FBSztRQUM1RDtRQUNBLE9BQU8sQ0FBQ3NOLFlBQVlHLFdBQVdGLEtBQUt4TixPQUFPeU4sWUFBWXhPLDJEQUFZQSxDQUFDaUssSUFBSSxJQUNwRXFFLFlBQVlJLFVBQVVILEtBQUt4TixPQUFPeU4sWUFBWXhPLDJEQUFZQSxDQUFDaUssSUFBSSxLQUM5RHFFLENBQUFBLFlBQVlJLFVBQVVILEtBQUt2TixLQUFLd04sWUFBWXhPLDJEQUFZQSxDQUFDaUssSUFBSSxJQUMxRHFFLFlBQVlHLFdBQVdGLEtBQUt2TixLQUFLd04sWUFBWXhPLDJEQUFZQSxDQUFDaUssSUFBSTtJQUMxRTtBQUNKO0FBQ0EsTUFBTTJELG9CQUFvQks7SUFDdEJyTixZQUFZc04sSUFBSSxDQUFFO1FBQ2QsS0FBSyxDQUFDQTtJQUNWO0lBQ0FTLFVBQVV0SixLQUFLLEVBQUV1SixPQUFPLEVBQUVDLEtBQUssRUFBRTtRQUM3QixJQUFJdEgsU0FBU3lHLGFBQWEsSUFBSSxDQUFDRSxJQUFJLEVBQUU3SSxPQUFPd0osT0FBT3hKLE1BQU1iLEdBQUcsQ0FBQ3ZELE1BQU0sRUFBRWEsZUFBZTtRQUNwRixJQUFJeUYsT0FBT25HLElBQUksRUFDWG1HLFNBQVN5RyxhQUFhLElBQUksQ0FBQ0UsSUFBSSxFQUFFN0ksT0FBTyxHQUFHdUosU0FBUzlNLGVBQWU7UUFDdkUsT0FBT3lGLE9BQU9uRyxJQUFJLEdBQUcsT0FBT21HLE9BQU9wRyxLQUFLO0lBQzVDO0lBQ0EsdUVBQXVFO0lBQ3ZFLHNEQUFzRDtJQUN0RDJOLGlCQUFpQnpKLEtBQUssRUFBRXRFLElBQUksRUFBRUMsRUFBRSxFQUFFO1FBQzlCLElBQUssSUFBSW1CLE1BQU1uQixLQUFNO1lBQ2pCLElBQUlnQixRQUFRa0YsS0FBS0csR0FBRyxDQUFDdEcsTUFBTW9CLE1BQU0sTUFBTSxzQkFBc0IsTUFBSyxJQUFJLENBQUMrTCxJQUFJLENBQUNaLFFBQVEsQ0FBQ3JNLE1BQU07WUFDM0YsSUFBSXNHLFNBQVN5RyxhQUFhLElBQUksQ0FBQ0UsSUFBSSxFQUFFN0ksT0FBT3JELE9BQU9HLE1BQU0ySSxRQUFRO1lBQ2pFLE1BQU8sQ0FBQ3ZELE9BQU96RixlQUFlLEdBQUdWLElBQUksQ0FDakMwSixRQUFRdkQsT0FBT3BHLEtBQUs7WUFDeEIsSUFBSTJKLE9BQ0EsT0FBT0E7WUFDWCxJQUFJOUksU0FBU2pCLE1BQ1QsT0FBTztZQUNYb0IsT0FBTyxNQUFNLHNCQUFzQjtRQUN2QztJQUNKO0lBQ0E0TSxVQUFVMUosS0FBSyxFQUFFdUosT0FBTyxFQUFFQyxLQUFLLEVBQUU7UUFDN0IsT0FBTyxJQUFJLENBQUNDLGdCQUFnQixDQUFDekosT0FBTyxHQUFHdUosWUFDbkMsSUFBSSxDQUFDRSxnQkFBZ0IsQ0FBQ3pKLE9BQU93SixPQUFPeEosTUFBTWIsR0FBRyxDQUFDdkQsTUFBTTtJQUM1RDtJQUNBK04sZUFBZUMsT0FBTyxFQUFFO1FBQUUsT0FBTyxJQUFJLENBQUNmLElBQUksQ0FBQ1gsT0FBTyxDQUFDLElBQUksQ0FBQ1csSUFBSSxDQUFDZCxPQUFPO0lBQUc7SUFDdkU4QixTQUFTN0osS0FBSyxFQUFFOEosS0FBSyxFQUFFO1FBQ25CLElBQUk1SCxTQUFTeUcsYUFBYSxJQUFJLENBQUNFLElBQUksRUFBRTdJLE9BQU8sR0FBR0EsTUFBTWIsR0FBRyxDQUFDdkQsTUFBTSxHQUFHMkosU0FBUyxFQUFFO1FBQzdFLE1BQU8sQ0FBQ3JELE9BQU8zRixJQUFJLEdBQUdSLElBQUksQ0FBRTtZQUN4QixJQUFJd0osT0FBTzNKLE1BQU0sSUFBSWtPLE9BQ2pCLE9BQU87WUFDWHZFLE9BQU9sSSxJQUFJLENBQUM2RSxPQUFPcEcsS0FBSztRQUM1QjtRQUNBLE9BQU95SjtJQUNYO0lBQ0F3RSxVQUFVL0osS0FBSyxFQUFFdEUsSUFBSSxFQUFFQyxFQUFFLEVBQUVxTyxHQUFHLEVBQUU7UUFDNUIsSUFBSTlILFNBQVN5RyxhQUFhLElBQUksQ0FBQ0UsSUFBSSxFQUFFN0ksT0FBTzZCLEtBQUtHLEdBQUcsQ0FBQyxHQUFHdEcsT0FBTyxJQUFJLENBQUNtTixJQUFJLENBQUNaLFFBQVEsQ0FBQ3JNLE1BQU0sR0FBR2lHLEtBQUtJLEdBQUcsQ0FBQ3RHLEtBQUssSUFBSSxDQUFDa04sSUFBSSxDQUFDWixRQUFRLENBQUNyTSxNQUFNLEVBQUVvRSxNQUFNYixHQUFHLENBQUN2RCxNQUFNO1FBQ3BKLE1BQU8sQ0FBQ3NHLE9BQU8zRixJQUFJLEdBQUdSLElBQUksQ0FDdEJpTyxJQUFJOUgsT0FBT3BHLEtBQUssQ0FBQ0osSUFBSSxFQUFFd0csT0FBT3BHLEtBQUssQ0FBQ0gsRUFBRTtJQUM5QztBQUNKO0FBQ0EsU0FBUytNLGFBQWFHLElBQUksRUFBRTdJLEtBQUssRUFBRXRFLElBQUksRUFBRUMsRUFBRTtJQUN2QyxPQUFPLElBQUlpQyxhQUFhb0MsTUFBTWIsR0FBRyxFQUFFMEosS0FBS2xCLE1BQU0sRUFBRTtRQUM1Q3pKLFlBQVksQ0FBQzJLLEtBQUt6QixhQUFhO1FBQy9CdkwsTUFBTWdOLEtBQUt0QixTQUFTLEdBQUcwQyxlQUFlakssTUFBTTRGLGVBQWUsQ0FBQzVGLE1BQU1DLFNBQVMsQ0FBQ0MsSUFBSSxDQUFDQyxJQUFJLEtBQUsySTtJQUM5RixHQUFHcE4sTUFBTUM7QUFDYjtBQUNBLFNBQVN5TixXQUFXMU0sR0FBRyxFQUFFUSxLQUFLO0lBQzFCLE9BQU9SLElBQUlpQyxLQUFLLENBQUM1RCxtRUFBZ0JBLENBQUMyQixLQUFLUSxPQUFPLFFBQVFBO0FBQzFEO0FBQ0EsU0FBU21NLFVBQVUzTSxHQUFHLEVBQUVRLEtBQUs7SUFDekIsT0FBT1IsSUFBSWlDLEtBQUssQ0FBQ3pCLE9BQU9uQyxtRUFBZ0JBLENBQUMyQixLQUFLUTtBQUNsRDtBQUNBLFNBQVMrTSxlQUFlaEIsV0FBVztJQUMvQixPQUFPLENBQUNpQixPQUFPQyxLQUFLbE4sUUFBVSxDQUFDQSxLQUFLLENBQUMsRUFBRSxDQUFDckIsTUFBTSxJQUMxQyxDQUFDcU4sWUFBWUcsV0FBV25NLE1BQU1vRCxLQUFLLEVBQUVwRCxNQUFNQyxLQUFLLE1BQU12QywyREFBWUEsQ0FBQ2lLLElBQUksSUFDbkVxRSxZQUFZSSxVQUFVcE0sTUFBTW9ELEtBQUssRUFBRXBELE1BQU1DLEtBQUssTUFBTXZDLDJEQUFZQSxDQUFDaUssSUFBSSxLQUNwRXFFLENBQUFBLFlBQVlJLFVBQVVwTSxNQUFNb0QsS0FBSyxFQUFFcEQsTUFBTUMsS0FBSyxHQUFHRCxLQUFLLENBQUMsRUFBRSxDQUFDckIsTUFBTSxNQUFNakIsMkRBQVlBLENBQUNpSyxJQUFJLElBQ3BGcUUsWUFBWUcsV0FBV25NLE1BQU1vRCxLQUFLLEVBQUVwRCxNQUFNQyxLQUFLLEdBQUdELEtBQUssQ0FBQyxFQUFFLENBQUNyQixNQUFNLE1BQU1qQiwyREFBWUEsQ0FBQ2lLLElBQUk7QUFDeEc7QUFDQSxNQUFNMEQsb0JBQW9CTTtJQUN0QlUsVUFBVXRKLEtBQUssRUFBRXVKLE9BQU8sRUFBRUMsS0FBSyxFQUFFO1FBQzdCLElBQUl0SCxTQUFTd0csYUFBYSxJQUFJLENBQUNHLElBQUksRUFBRTdJLE9BQU93SixPQUFPeEosTUFBTWIsR0FBRyxDQUFDdkQsTUFBTSxFQUFFVyxJQUFJO1FBQ3pFLElBQUkyRixPQUFPbkcsSUFBSSxFQUNYbUcsU0FBU3dHLGFBQWEsSUFBSSxDQUFDRyxJQUFJLEVBQUU3SSxPQUFPLEdBQUd1SixTQUFTaE4sSUFBSTtRQUM1RCxPQUFPMkYsT0FBT25HLElBQUksR0FBRyxPQUFPbUcsT0FBT3BHLEtBQUs7SUFDNUM7SUFDQTJOLGlCQUFpQnpKLEtBQUssRUFBRXRFLElBQUksRUFBRUMsRUFBRSxFQUFFO1FBQzlCLElBQUssSUFBSXlPLE9BQU8sSUFBSUEsT0FBUTtZQUN4QixJQUFJek4sUUFBUWtGLEtBQUtHLEdBQUcsQ0FBQ3RHLE1BQU1DLEtBQUt5TyxPQUFPLE1BQU0sc0JBQXNCO1lBQ25FLElBQUlsSSxTQUFTd0csYUFBYSxJQUFJLENBQUNHLElBQUksRUFBRTdJLE9BQU9yRCxPQUFPaEIsS0FBSzhKLFFBQVE7WUFDaEUsTUFBTyxDQUFDdkQsT0FBTzNGLElBQUksR0FBR1IsSUFBSSxDQUN0QjBKLFFBQVF2RCxPQUFPcEcsS0FBSztZQUN4QixJQUFJMkosU0FBVTlJLENBQUFBLFNBQVNqQixRQUFRK0osTUFBTS9KLElBQUksR0FBR2lCLFFBQVEsRUFBQyxHQUNqRCxPQUFPOEk7WUFDWCxJQUFJOUksU0FBU2pCLE1BQ1QsT0FBTztRQUNmO0lBQ0o7SUFDQWdPLFVBQVUxSixLQUFLLEVBQUV1SixPQUFPLEVBQUVDLEtBQUssRUFBRTtRQUM3QixPQUFPLElBQUksQ0FBQ0MsZ0JBQWdCLENBQUN6SixPQUFPLEdBQUd1SixZQUNuQyxJQUFJLENBQUNFLGdCQUFnQixDQUFDekosT0FBT3dKLE9BQU94SixNQUFNYixHQUFHLENBQUN2RCxNQUFNO0lBQzVEO0lBQ0ErTixlQUFlVSxNQUFNLEVBQUU7UUFDbkIsT0FBTyxJQUFJLENBQUN4QixJQUFJLENBQUNYLE9BQU8sQ0FBQyxJQUFJLENBQUNXLElBQUksQ0FBQ2QsT0FBTyxFQUFFQSxPQUFPLENBQUMsZ0JBQWdCLENBQUN1QyxHQUFHek4sSUFBTUEsS0FBSyxNQUFNLE1BQ25GQSxLQUFLLE1BQU13TixPQUFPcE4sS0FBSyxDQUFDLEVBQUUsR0FDdEJKLEtBQUssT0FBTyxDQUFDQSxJQUFJd04sT0FBT3BOLEtBQUssQ0FBQ3JCLE1BQU0sR0FBR3lPLE9BQU9wTixLQUFLLENBQUNKLEVBQUUsR0FDbER5TjtJQUNsQjtJQUNBVCxTQUFTN0osS0FBSyxFQUFFOEosS0FBSyxFQUFFO1FBQ25CLElBQUk1SCxTQUFTd0csYUFBYSxJQUFJLENBQUNHLElBQUksRUFBRTdJLE9BQU8sR0FBR0EsTUFBTWIsR0FBRyxDQUFDdkQsTUFBTSxHQUFHMkosU0FBUyxFQUFFO1FBQzdFLE1BQU8sQ0FBQ3JELE9BQU8zRixJQUFJLEdBQUdSLElBQUksQ0FBRTtZQUN4QixJQUFJd0osT0FBTzNKLE1BQU0sSUFBSWtPLE9BQ2pCLE9BQU87WUFDWHZFLE9BQU9sSSxJQUFJLENBQUM2RSxPQUFPcEcsS0FBSztRQUM1QjtRQUNBLE9BQU95SjtJQUNYO0lBQ0F3RSxVQUFVL0osS0FBSyxFQUFFdEUsSUFBSSxFQUFFQyxFQUFFLEVBQUVxTyxHQUFHLEVBQUU7UUFDNUIsSUFBSTlILFNBQVN3RyxhQUFhLElBQUksQ0FBQ0csSUFBSSxFQUFFN0ksT0FBTzZCLEtBQUtHLEdBQUcsQ0FBQyxHQUFHdEcsT0FBTyxJQUFJLDBCQUEwQixNQUFLbUcsS0FBS0ksR0FBRyxDQUFDdEcsS0FBSyxJQUFJLDBCQUEwQixLQUFJcUUsTUFBTWIsR0FBRyxDQUFDdkQsTUFBTTtRQUNsSyxNQUFPLENBQUNzRyxPQUFPM0YsSUFBSSxHQUFHUixJQUFJLENBQ3RCaU8sSUFBSTlILE9BQU9wRyxLQUFLLENBQUNKLElBQUksRUFBRXdHLE9BQU9wRyxLQUFLLENBQUNILEVBQUU7SUFDOUM7QUFDSjtBQUNBOzs7Ozs7QUFNQSxHQUNBLE1BQU00TyxpQkFBaUIsV0FBVyxHQUFFalEsMERBQVdBLENBQUMrSCxNQUFNO0FBQ3RELE1BQU1tSSxjQUFjLFdBQVcsR0FBRWxRLDBEQUFXQSxDQUFDK0gsTUFBTTtBQUNuRCxNQUFNb0ksY0FBYyxXQUFXLEdBQUVsUSx5REFBVUEsQ0FBQzhILE1BQU0sQ0FBQztJQUMvQ0UsUUFBT3ZDLEtBQUs7UUFDUixPQUFPLElBQUkwSyxZQUFZQyxhQUFhM0ssT0FBT3VDLE1BQU0sSUFBSTtJQUN6RDtJQUNBQyxRQUFPMUcsS0FBSyxFQUFFMkcsRUFBRTtRQUNaLEtBQUssSUFBSW1JLFVBQVVuSSxHQUFHM0IsT0FBTyxDQUFFO1lBQzNCLElBQUk4SixPQUFPakksRUFBRSxDQUFDNEgsaUJBQ1Z6TyxRQUFRLElBQUk0TyxZQUFZRSxPQUFPOU8sS0FBSyxDQUFDeUcsTUFBTSxJQUFJekcsTUFBTWtILEtBQUs7aUJBQ3pELElBQUk0SCxPQUFPakksRUFBRSxDQUFDNkgsY0FDZjFPLFFBQVEsSUFBSTRPLFlBQVk1TyxNQUFNTCxLQUFLLEVBQUVtUCxPQUFPOU8sS0FBSyxHQUFHK08sb0JBQW9CO1FBQ2hGO1FBQ0EsT0FBTy9PO0lBQ1g7SUFDQThHLFNBQVNDLENBQUFBLElBQUtoSix1REFBU0EsQ0FBQzZCLElBQUksQ0FBQ21ILEdBQUdDLENBQUFBLE1BQU9BLElBQUlFLEtBQUs7QUFDcEQ7QUFDQTs7QUFFQSxHQUNBLFNBQVM4SCxlQUFlOUssS0FBSztJQUN6QixJQUFJK0ssV0FBVy9LLE1BQU1pRCxLQUFLLENBQUN3SCxhQUFhO0lBQ3hDLE9BQU9NLFdBQVdBLFNBQVN0UCxLQUFLLENBQUNvTixJQUFJLEdBQUc4QixhQUFhM0s7QUFDekQ7QUFDQTs7QUFFQSxHQUNBLFNBQVNnTCxnQkFBZ0JoTCxLQUFLO0lBQzFCLElBQUlKO0lBQ0osT0FBTyxDQUFDLENBQUNBLEtBQUtJLE1BQU1pRCxLQUFLLENBQUN3SCxhQUFhLE1BQUssTUFBTyxRQUFRN0ssT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHb0QsS0FBSyxLQUFLO0FBQ3JHO0FBQ0EsTUFBTTBIO0lBQ0ZuUCxZQUFZRSxLQUFLLEVBQUV1SCxLQUFLLENBQUU7UUFDdEIsSUFBSSxDQUFDdkgsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQ3VILEtBQUssR0FBR0E7SUFDakI7QUFDSjtBQUNBLE1BQU1pSSxZQUFZLFdBQVcsR0FBRWpSLHdEQUFVQSxDQUFDdUssSUFBSSxDQUFDO0lBQUVqRSxPQUFPO0FBQWlCLElBQUk0SyxvQkFBb0IsV0FBVyxHQUFFbFIsd0RBQVVBLENBQUN1SyxJQUFJLENBQUM7SUFBRWpFLE9BQU87QUFBeUM7QUFDaEwsTUFBTTZLLG9CQUFvQixXQUFXLEdBQUVsUix3REFBVUEsQ0FBQzZLLFNBQVMsQ0FBQztJQUN4RHZKLFlBQVl3RSxJQUFJLENBQUU7UUFDZCxJQUFJLENBQUNBLElBQUksR0FBR0E7UUFDWixJQUFJLENBQUNnRixXQUFXLEdBQUcsSUFBSSxDQUFDZ0YsU0FBUyxDQUFDaEssS0FBS0MsS0FBSyxDQUFDaUQsS0FBSyxDQUFDd0g7SUFDdkQ7SUFDQWpJLE9BQU9BLE1BQU0sRUFBRTtRQUNYLElBQUl4QyxRQUFRd0MsT0FBT3hDLEtBQUssQ0FBQ2lELEtBQUssQ0FBQ3dIO1FBQy9CLElBQUl6SyxTQUFTd0MsT0FBTzRJLFVBQVUsQ0FBQ25JLEtBQUssQ0FBQ3dILGdCQUFnQmpJLE9BQU8wQyxVQUFVLElBQUkxQyxPQUFPeUMsWUFBWSxJQUFJekMsT0FBTzJDLGVBQWUsRUFDbkgsSUFBSSxDQUFDSixXQUFXLEdBQUcsSUFBSSxDQUFDZ0YsU0FBUyxDQUFDL0o7SUFDMUM7SUFDQStKLFVBQVUsRUFBRXRPLEtBQUssRUFBRXVILEtBQUssRUFBRSxFQUFFO1FBQ3hCLElBQUksQ0FBQ0EsU0FBUyxDQUFDdkgsTUFBTW9OLElBQUksQ0FBQ2IsS0FBSyxFQUMzQixPQUFPaE8sd0RBQVVBLENBQUN3TCxJQUFJO1FBQzFCLElBQUksRUFBRXpGLElBQUksRUFBRSxHQUFHLElBQUk7UUFDbkIsSUFBSXNMLFVBQVUsSUFBSXpRLDhEQUFlQTtRQUNqQyxJQUFLLElBQUlpQyxJQUFJLEdBQUcwSSxTQUFTeEYsS0FBS2tHLGFBQWEsRUFBRXFGLElBQUkvRixPQUFPM0osTUFBTSxFQUFFaUIsSUFBSXlPLEdBQUd6TyxJQUFLO1lBQ3hFLElBQUksRUFBRW5CLElBQUksRUFBRUMsRUFBRSxFQUFFLEdBQUc0SixNQUFNLENBQUMxSSxFQUFFO1lBQzVCLE1BQU9BLElBQUl5TyxJQUFJLEtBQUszUCxLQUFLNEosTUFBTSxDQUFDMUksSUFBSSxFQUFFLENBQUNuQixJQUFJLEdBQUcsSUFBSSxJQUFJLDBCQUEwQixJQUM1RUMsS0FBSzRKLE1BQU0sQ0FBQyxFQUFFMUksRUFBRSxDQUFDbEIsRUFBRTtZQUN2QkYsTUFBTXNPLFNBQVMsQ0FBQ2hLLEtBQUtDLEtBQUssRUFBRXRFLE1BQU1DLElBQUksQ0FBQ0QsTUFBTUM7Z0JBQ3pDLElBQUk0UCxXQUFXeEwsS0FBS0MsS0FBSyxDQUFDQyxTQUFTLENBQUNzRixNQUFNLENBQUNxQixJQUFJLENBQUNDLENBQUFBLElBQUtBLEVBQUVuTCxJQUFJLElBQUlBLFFBQVFtTCxFQUFFbEwsRUFBRSxJQUFJQTtnQkFDL0UwUCxRQUFRckIsR0FBRyxDQUFDdE8sTUFBTUMsSUFBSTRQLFdBQVdMLG9CQUFvQkQ7WUFDekQ7UUFDSjtRQUNBLE9BQU9JLFFBQVFHLE1BQU07SUFDekI7QUFDSixHQUFHO0lBQ0N6RyxhQUFhbUIsQ0FBQUEsSUFBS0EsRUFBRW5CLFdBQVc7QUFDbkM7QUFDQSxTQUFTMEcsY0FBYzVJLENBQUM7SUFDcEIsT0FBTzlDLENBQUFBO1FBQ0gsSUFBSUMsUUFBUUQsS0FBS0MsS0FBSyxDQUFDaUQsS0FBSyxDQUFDd0gsYUFBYTtRQUMxQyxPQUFPekssU0FBU0EsTUFBTXZFLEtBQUssQ0FBQ29OLElBQUksQ0FBQ2IsS0FBSyxHQUFHbkYsRUFBRTlDLE1BQU1DLFNBQVMwTCxnQkFBZ0IzTDtJQUM5RTtBQUNKO0FBQ0E7Ozs7O0FBS0EsR0FDQSxNQUFNNEwsV0FBVyxXQUFXLEdBQUVGLGNBQWMsQ0FBQzFMLE1BQU0sRUFBRXRFLEtBQUssRUFBRTtJQUN4RCxJQUFJLEVBQUVFLEVBQUUsRUFBRSxHQUFHb0UsS0FBS0MsS0FBSyxDQUFDQyxTQUFTLENBQUNDLElBQUk7SUFDdEMsSUFBSTNELE9BQU9kLE1BQU02TixTQUFTLENBQUN2SixLQUFLQyxLQUFLLEVBQUVyRSxJQUFJQTtJQUMzQyxJQUFJLENBQUNZLE1BQ0QsT0FBTztJQUNYLElBQUkwRCxZQUFZekYsOERBQWVBLENBQUNvUixNQUFNLENBQUNyUCxLQUFLYixJQUFJLEVBQUVhLEtBQUtaLEVBQUU7SUFDekQsSUFBSWlNLFNBQVM3SCxLQUFLQyxLQUFLLENBQUNxRixLQUFLLENBQUM0QjtJQUM5QmxILEtBQUtjLFFBQVEsQ0FBQztRQUNWWjtRQUNBYSxTQUFTO1lBQUMrSyxjQUFjOUwsTUFBTXhEO1lBQU9xTCxPQUFPRixhQUFhLENBQUN6SCxVQUFVQyxJQUFJLEVBQUVIO1NBQU07UUFDaEYrTCxXQUFXO0lBQ2Y7SUFDQUMsa0JBQWtCaE07SUFDbEIsT0FBTztBQUNYO0FBQ0E7Ozs7QUFJQSxHQUNBLE1BQU1pTSxlQUFlLFdBQVcsR0FBRVAsY0FBYyxDQUFDMUwsTUFBTSxFQUFFdEUsS0FBSyxFQUFFO0lBQzVELElBQUksRUFBRXVFLEtBQUssRUFBRSxHQUFHRCxNQUFNLEVBQUVyRSxJQUFJLEVBQUUsR0FBR3NFLE1BQU1DLFNBQVMsQ0FBQ0MsSUFBSTtJQUNyRCxJQUFJK0wsT0FBT3hRLE1BQU1pTyxTQUFTLENBQUMxSixPQUFPdEUsTUFBTUE7SUFDeEMsSUFBSSxDQUFDdVEsTUFDRCxPQUFPO0lBQ1gsSUFBSWhNLFlBQVl6Riw4REFBZUEsQ0FBQ29SLE1BQU0sQ0FBQ0ssS0FBS3ZRLElBQUksRUFBRXVRLEtBQUt0USxFQUFFO0lBQ3pELElBQUlpTSxTQUFTN0gsS0FBS0MsS0FBSyxDQUFDcUYsS0FBSyxDQUFDNEI7SUFDOUJsSCxLQUFLYyxRQUFRLENBQUM7UUFDVlo7UUFDQWEsU0FBUztZQUFDK0ssY0FBYzlMLE1BQU1rTTtZQUFPckUsT0FBT0YsYUFBYSxDQUFDekgsVUFBVUMsSUFBSSxFQUFFSDtTQUFNO1FBQ2hGK0wsV0FBVztJQUNmO0lBQ0FDLGtCQUFrQmhNO0lBQ2xCLE9BQU87QUFDWDtBQUNBOztBQUVBLEdBQ0EsTUFBTW1NLGdCQUFnQixXQUFXLEdBQUVULGNBQWMsQ0FBQzFMLE1BQU0sRUFBRXRFLEtBQUssRUFBRTtJQUM3RCxJQUFJOEosU0FBUzlKLE1BQU1vTyxRQUFRLENBQUM5SixLQUFLQyxLQUFLLEVBQUU7SUFDeEMsSUFBSSxDQUFDdUYsVUFBVSxDQUFDQSxPQUFPM0osTUFBTSxFQUN6QixPQUFPO0lBQ1htRSxLQUFLYyxRQUFRLENBQUM7UUFDVlosV0FBV3pGLDhEQUFlQSxDQUFDK0gsTUFBTSxDQUFDZ0QsT0FBT2UsR0FBRyxDQUFDTyxDQUFBQSxJQUFLck0sOERBQWVBLENBQUNpTCxLQUFLLENBQUNvQixFQUFFbkwsSUFBSSxFQUFFbUwsRUFBRWxMLEVBQUU7UUFDcEZtUSxXQUFXO0lBQ2Y7SUFDQSxPQUFPO0FBQ1g7QUFDQTs7QUFFQSxHQUNBLE1BQU1LLHlCQUF5QixDQUFDLEVBQUVuTSxLQUFLLEVBQUVhLFFBQVEsRUFBRTtJQUMvQyxJQUFJeUUsTUFBTXRGLE1BQU1DLFNBQVM7SUFDekIsSUFBSXFGLElBQUlDLE1BQU0sQ0FBQzNKLE1BQU0sR0FBRyxLQUFLMEosSUFBSXBGLElBQUksQ0FBQzFDLEtBQUssRUFDdkMsT0FBTztJQUNYLElBQUksRUFBRTlCLElBQUksRUFBRUMsRUFBRSxFQUFFLEdBQUcySixJQUFJcEYsSUFBSTtJQUMzQixJQUFJcUYsU0FBUyxFQUFFLEVBQUVyRixPQUFPO0lBQ3hCLElBQUssSUFBSWtNLE1BQU0sSUFBSTlRLGFBQWEwRSxNQUFNYixHQUFHLEVBQUVhLE1BQU0yRSxRQUFRLENBQUNqSixNQUFNQyxNQUFNLENBQUN5USxJQUFJN1AsSUFBSSxHQUFHUixJQUFJLEVBQUc7UUFDckYsSUFBSXdKLE9BQU8zSixNQUFNLEdBQUcsTUFDaEIsT0FBTztRQUNYLElBQUl3USxJQUFJdFEsS0FBSyxDQUFDSixJQUFJLElBQUlBLE1BQ2xCd0UsT0FBT3FGLE9BQU8zSixNQUFNO1FBQ3hCMkosT0FBT2xJLElBQUksQ0FBQzdDLDhEQUFlQSxDQUFDaUwsS0FBSyxDQUFDMkcsSUFBSXRRLEtBQUssQ0FBQ0osSUFBSSxFQUFFMFEsSUFBSXRRLEtBQUssQ0FBQ0gsRUFBRTtJQUNsRTtJQUNBa0YsU0FBU2IsTUFBTXdDLE1BQU0sQ0FBQztRQUNsQnZDLFdBQVd6Riw4REFBZUEsQ0FBQytILE1BQU0sQ0FBQ2dELFFBQVFyRjtRQUMxQzRMLFdBQVc7SUFDZjtJQUNBLE9BQU87QUFDWDtBQUNBOztBQUVBLEdBQ0EsTUFBTU8sY0FBYyxXQUFXLEdBQUVaLGNBQWMsQ0FBQzFMLE1BQU0sRUFBRXRFLEtBQUssRUFBRTtJQUMzRCxJQUFJLEVBQUV1RSxLQUFLLEVBQUUsR0FBR0QsTUFBTSxFQUFFckUsSUFBSSxFQUFFQyxFQUFFLEVBQUUsR0FBR3FFLE1BQU1DLFNBQVMsQ0FBQ0MsSUFBSTtJQUN6RCxJQUFJRixNQUFNc00sUUFBUSxFQUNkLE9BQU87SUFDWCxJQUFJL1AsT0FBT2QsTUFBTTZOLFNBQVMsQ0FBQ3RKLE9BQU90RSxNQUFNQTtJQUN4QyxJQUFJLENBQUNhLE1BQ0QsT0FBTztJQUNYLElBQUlnUSxVQUFVLEVBQUUsRUFBRXRNLFdBQVd1TTtJQUM3QixJQUFJMUwsVUFBVSxFQUFFO0lBQ2hCLElBQUl2RSxLQUFLYixJQUFJLElBQUlBLFFBQVFhLEtBQUtaLEVBQUUsSUFBSUEsSUFBSTtRQUNwQzZRLGNBQWN4TSxNQUFNeU0sTUFBTSxDQUFDaFIsTUFBTWtPLGNBQWMsQ0FBQ3BOO1FBQ2hEZ1EsUUFBUWxQLElBQUksQ0FBQztZQUFFM0IsTUFBTWEsS0FBS2IsSUFBSTtZQUFFQyxJQUFJWSxLQUFLWixFQUFFO1lBQUUrUSxRQUFRRjtRQUFZO1FBQ2pFalEsT0FBT2QsTUFBTTZOLFNBQVMsQ0FBQ3RKLE9BQU96RCxLQUFLYixJQUFJLEVBQUVhLEtBQUtaLEVBQUU7UUFDaERtRixRQUFRekQsSUFBSSxDQUFDdkQsd0RBQVVBLENBQUM2UyxRQUFRLENBQUMzTCxFQUFFLENBQUNoQixNQUFNb0IsTUFBTSxDQUFDLDRCQUE0QnBCLE1BQU1iLEdBQUcsQ0FBQ2YsTUFBTSxDQUFDMUMsTUFBTTBFLE1BQU0sSUFBSTtJQUNsSDtJQUNBLElBQUk3RCxNQUFNO1FBQ04sSUFBSXNDLE1BQU0wTixRQUFRM1EsTUFBTSxJQUFJLEtBQUsyUSxPQUFPLENBQUMsRUFBRSxDQUFDN1EsSUFBSSxJQUFJYSxLQUFLWixFQUFFLEdBQUcsSUFBSVksS0FBS1osRUFBRSxHQUFHWSxLQUFLYixJQUFJLEdBQUc4USxZQUFZNVEsTUFBTTtRQUMxR3FFLFlBQVl6Riw4REFBZUEsQ0FBQ29SLE1BQU0sQ0FBQ3JQLEtBQUtiLElBQUksR0FBR21ELEtBQUt0QyxLQUFLWixFQUFFLEdBQUdrRDtRQUM5RGlDLFFBQVF6RCxJQUFJLENBQUN3TyxjQUFjOUwsTUFBTXhEO1FBQ2pDdUUsUUFBUXpELElBQUksQ0FBQzJDLE1BQU1xRixLQUFLLENBQUM0QixtQkFBbUJTLGFBQWEsQ0FBQ3pILFVBQVVDLElBQUksRUFBRUg7SUFDOUU7SUFDQUEsS0FBS2MsUUFBUSxDQUFDO1FBQ1YwTDtRQUFTdE07UUFBV2E7UUFDcEJnTCxXQUFXO0lBQ2Y7SUFDQSxPQUFPO0FBQ1g7QUFDQTs7O0FBR0EsR0FDQSxNQUFNYyxhQUFhLFdBQVcsR0FBRW5CLGNBQWMsQ0FBQzFMLE1BQU0sRUFBRXRFLEtBQUssRUFBRTtJQUMxRCxJQUFJc0UsS0FBS0MsS0FBSyxDQUFDc00sUUFBUSxFQUNuQixPQUFPO0lBQ1gsSUFBSUMsVUFBVTlRLE1BQU1vTyxRQUFRLENBQUM5SixLQUFLQyxLQUFLLEVBQUUsS0FBS3NHLEdBQUcsQ0FBQ3JKLENBQUFBO1FBQzlDLElBQUksRUFBRXZCLElBQUksRUFBRUMsRUFBRSxFQUFFLEdBQUdzQjtRQUNuQixPQUFPO1lBQUV2QjtZQUFNQztZQUFJK1EsUUFBUWpSLE1BQU1rTyxjQUFjLENBQUMxTTtRQUFPO0lBQzNEO0lBQ0EsSUFBSSxDQUFDc1AsUUFBUTNRLE1BQU0sRUFDZixPQUFPO0lBQ1gsSUFBSWlSLGVBQWU5TSxLQUFLQyxLQUFLLENBQUNvQixNQUFNLENBQUMsc0JBQXNCbUwsUUFBUTNRLE1BQU0sSUFBSTtJQUM3RW1FLEtBQUtjLFFBQVEsQ0FBQztRQUNWMEw7UUFDQXpMLFNBQVNoSCx3REFBVUEsQ0FBQzZTLFFBQVEsQ0FBQzNMLEVBQUUsQ0FBQzZMO1FBQ2hDZixXQUFXO0lBQ2Y7SUFDQSxPQUFPO0FBQ1g7QUFDQSxTQUFTakIsa0JBQWtCOUssSUFBSTtJQUMzQixPQUFPQSxLQUFLQyxLQUFLLENBQUNxRixLQUFLLENBQUM0QixtQkFBbUJPLFdBQVcsQ0FBQ3pIO0FBQzNEO0FBQ0EsU0FBUzRLLGFBQWEzSyxLQUFLLEVBQUU4TSxRQUFRO0lBQ2pDLElBQUlsTixJQUFJbU4sSUFBSUMsSUFBSUMsSUFBSUM7SUFDcEIsSUFBSTVILE1BQU10RixNQUFNQyxTQUFTLENBQUNDLElBQUk7SUFDOUIsSUFBSWlOLFVBQVU3SCxJQUFJOUgsS0FBSyxJQUFJOEgsSUFBSTNKLEVBQUUsR0FBRzJKLElBQUk1SixJQUFJLEdBQUcsTUFBTSxLQUFLc0UsTUFBTTJFLFFBQVEsQ0FBQ1csSUFBSTVKLElBQUksRUFBRTRKLElBQUkzSixFQUFFO0lBQ3pGLElBQUltUixZQUFZLENBQUNLLFNBQ2IsT0FBT0w7SUFDWCxJQUFJbEYsU0FBUzVILE1BQU1xRixLQUFLLENBQUM0QjtJQUN6QixPQUFPLElBQUlhLFlBQVk7UUFDbkJILFFBQVEsQ0FBQyxDQUFDL0gsS0FBS2tOLGFBQWEsUUFBUUEsYUFBYSxLQUFLLElBQUksS0FBSyxJQUFJQSxTQUFTekYsT0FBTyxNQUFNLFFBQVF6SCxPQUFPLEtBQUssSUFBSUEsS0FBS2dJLE9BQU9QLE9BQU8sSUFBSThGLFVBQVVBLFFBQVFwRixPQUFPLENBQUMsT0FBTztRQUN6S1gsZUFBZSxDQUFDMkYsS0FBS0QsYUFBYSxRQUFRQSxhQUFhLEtBQUssSUFBSSxLQUFLLElBQUlBLFNBQVMxRixhQUFhLE1BQU0sUUFBUTJGLE9BQU8sS0FBSyxJQUFJQSxLQUFLbkYsT0FBT1IsYUFBYTtRQUN0SkMsU0FBUyxDQUFDMkYsS0FBS0YsYUFBYSxRQUFRQSxhQUFhLEtBQUssSUFBSSxLQUFLLElBQUlBLFNBQVN6RixPQUFPLE1BQU0sUUFBUTJGLE9BQU8sS0FBSyxJQUFJQSxLQUFLcEYsT0FBT1AsT0FBTztRQUNwSUMsUUFBUSxDQUFDMkYsS0FBS0gsYUFBYSxRQUFRQSxhQUFhLEtBQUssSUFBSSxLQUFLLElBQUlBLFNBQVN4RixNQUFNLE1BQU0sUUFBUTJGLE9BQU8sS0FBSyxJQUFJQSxLQUFLckYsT0FBT04sTUFBTTtRQUNqSUMsV0FBVyxDQUFDMkYsS0FBS0osYUFBYSxRQUFRQSxhQUFhLEtBQUssSUFBSSxLQUFLLElBQUlBLFNBQVN2RixTQUFTLE1BQU0sUUFBUTJGLE9BQU8sS0FBSyxJQUFJQSxLQUFLdEYsT0FBT0wsU0FBUztJQUM5STtBQUNKO0FBQ0EsU0FBUzZGLGVBQWVyTixJQUFJO0lBQ3hCLElBQUlpRCxRQUFRakosMERBQVFBLENBQUNnRyxNQUFNOEs7SUFDM0IsT0FBTzdILFNBQVNBLE1BQU14QyxHQUFHLENBQUM0QyxhQUFhLENBQUM7QUFDNUM7QUFDQSxTQUFTMkksa0JBQWtCaE0sSUFBSTtJQUMzQixJQUFJTSxRQUFRK00sZUFBZXJOO0lBQzNCLElBQUlNLFNBQVNBLFNBQVNOLEtBQUtzTixJQUFJLENBQUNDLGFBQWEsRUFDekNqTixNQUFNZ0QsTUFBTTtBQUNwQjtBQUNBOztBQUVBLEdBQ0EsTUFBTXFJLGtCQUFrQjNMLENBQUFBO0lBQ3BCLElBQUlDLFFBQVFELEtBQUtDLEtBQUssQ0FBQ2lELEtBQUssQ0FBQ3dILGFBQWE7SUFDMUMsSUFBSXpLLFNBQVNBLE1BQU1nRCxLQUFLLEVBQUU7UUFDdEIsSUFBSXVLLGNBQWNILGVBQWVyTjtRQUNqQyxJQUFJd04sZUFBZUEsZUFBZXhOLEtBQUtzTixJQUFJLENBQUNDLGFBQWEsRUFBRTtZQUN2RCxJQUFJN1IsUUFBUWtQLGFBQWE1SyxLQUFLQyxLQUFLLEVBQUVBLE1BQU12RSxLQUFLLENBQUNvTixJQUFJO1lBQ3JELElBQUlwTixNQUFNdU0sS0FBSyxFQUNYakksS0FBS2MsUUFBUSxDQUFDO2dCQUFFQyxTQUFTeUosZUFBZXZKLEVBQUUsQ0FBQ3ZGO1lBQU87WUFDdEQ4UixZQUFZdE0sS0FBSztZQUNqQnNNLFlBQVlsSyxNQUFNO1FBQ3RCO0lBQ0osT0FDSztRQUNEdEQsS0FBS2MsUUFBUSxDQUFDO1lBQUVDLFNBQVM7Z0JBQ2pCMEosWUFBWXhKLEVBQUUsQ0FBQztnQkFDZmhCLFFBQVF1SyxlQUFldkosRUFBRSxDQUFDMkosYUFBYTVLLEtBQUtDLEtBQUssRUFBRUEsTUFBTXZFLEtBQUssQ0FBQ29OLElBQUksS0FBS3ZPLDBEQUFXQSxDQUFDNEksWUFBWSxDQUFDbEMsRUFBRSxDQUFDNkc7YUFDdkc7UUFBQztJQUNWO0lBQ0EsT0FBTztBQUNYO0FBQ0E7O0FBRUEsR0FDQSxNQUFNMkYsbUJBQW1Cek4sQ0FBQUE7SUFDckIsSUFBSUMsUUFBUUQsS0FBS0MsS0FBSyxDQUFDaUQsS0FBSyxDQUFDd0gsYUFBYTtJQUMxQyxJQUFJLENBQUN6SyxTQUFTLENBQUNBLE1BQU1nRCxLQUFLLEVBQ3RCLE9BQU87SUFDWCxJQUFJQSxRQUFRakosMERBQVFBLENBQUNnRyxNQUFNOEs7SUFDM0IsSUFBSTdILFNBQVNBLE1BQU14QyxHQUFHLENBQUNpTixRQUFRLENBQUMxTixLQUFLc04sSUFBSSxDQUFDQyxhQUFhLEdBQ25Edk4sS0FBS2tCLEtBQUs7SUFDZGxCLEtBQUtjLFFBQVEsQ0FBQztRQUFFQyxTQUFTMEosWUFBWXhKLEVBQUUsQ0FBQztJQUFPO0lBQy9DLE9BQU87QUFDWDtBQUNBOzs7Ozs7OztBQVFBLEdBQ0EsTUFBTTBNLGVBQWU7SUFDakI7UUFBRUMsS0FBSztRQUFTQyxLQUFLbEM7UUFBaUJtQyxPQUFPO0lBQXNCO0lBQ25FO1FBQUVGLEtBQUs7UUFBTUMsS0FBS2pDO1FBQVVtQyxPQUFPOUI7UUFBYzZCLE9BQU87UUFBdUJqTixnQkFBZ0I7SUFBSztJQUNwRztRQUFFK00sS0FBSztRQUFTQyxLQUFLakM7UUFBVW1DLE9BQU85QjtRQUFjNkIsT0FBTztRQUF1QmpOLGdCQUFnQjtJQUFLO0lBQ3ZHO1FBQUUrTSxLQUFLO1FBQVVDLEtBQUtKO1FBQWtCSyxPQUFPO0lBQXNCO0lBQ3JFO1FBQUVGLEtBQUs7UUFBZUMsS0FBS3pCO0lBQXVCO0lBQ2xEO1FBQUV3QixLQUFLO1FBQWFDLEtBQUs3SztJQUFTO0lBQ2xDO1FBQUU0SyxLQUFLO1FBQVNDLEtBQUs5RztRQUFzQmxHLGdCQUFnQjtJQUFLO0NBQ25FO0FBQ0QsTUFBTTZHO0lBQ0ZsTSxZQUFZd0UsSUFBSSxDQUFFO1FBQ2QsSUFBSSxDQUFDQSxJQUFJLEdBQUdBO1FBQ1osSUFBSXRFLFFBQVEsSUFBSSxDQUFDQSxLQUFLLEdBQUdzRSxLQUFLQyxLQUFLLENBQUNpRCxLQUFLLENBQUN3SCxhQUFhaFAsS0FBSyxDQUFDb04sSUFBSTtRQUNqRSxJQUFJLENBQUNrRixNQUFNLEdBQUcsSUFBSSxDQUFDQSxNQUFNLENBQUNDLElBQUksQ0FBQyxJQUFJO1FBQ25DLElBQUksQ0FBQ0MsV0FBVyxHQUFHalQsaURBQUdBLENBQUMsU0FBUztZQUM1QmMsT0FBT0wsTUFBTWtNLE1BQU07WUFDbkJ1RyxhQUFhOU0sT0FBT3JCLE1BQU07WUFDMUIsY0FBY3FCLE9BQU9yQixNQUFNO1lBQzNCTyxPQUFPO1lBQ1BDLE1BQU07WUFDTjROLE1BQU07WUFDTixjQUFjO1lBQ2RDLFVBQVUsSUFBSSxDQUFDTCxNQUFNO1lBQ3JCTSxTQUFTLElBQUksQ0FBQ04sTUFBTTtRQUN4QjtRQUNBLElBQUksQ0FBQ08sWUFBWSxHQUFHdFQsaURBQUdBLENBQUMsU0FBUztZQUM3QmMsT0FBT0wsTUFBTXNNLE9BQU87WUFDcEJtRyxhQUFhOU0sT0FBT3JCLE1BQU07WUFDMUIsY0FBY3FCLE9BQU9yQixNQUFNO1lBQzNCTyxPQUFPO1lBQ1BDLE1BQU07WUFDTjROLE1BQU07WUFDTkMsVUFBVSxJQUFJLENBQUNMLE1BQU07WUFDckJNLFNBQVMsSUFBSSxDQUFDTixNQUFNO1FBQ3hCO1FBQ0EsSUFBSSxDQUFDUSxTQUFTLEdBQUd2VCxpREFBR0EsQ0FBQyxTQUFTO1lBQzFCcUcsTUFBTTtZQUNOZCxNQUFNO1lBQ040TixNQUFNO1lBQ05LLFNBQVMvUyxNQUFNMkwsYUFBYTtZQUM1QmdILFVBQVUsSUFBSSxDQUFDTCxNQUFNO1FBQ3pCO1FBQ0EsSUFBSSxDQUFDVSxPQUFPLEdBQUd6VCxpREFBR0EsQ0FBQyxTQUFTO1lBQ3hCcUcsTUFBTTtZQUNOZCxNQUFNO1lBQ040TixNQUFNO1lBQ05LLFNBQVMvUyxNQUFNNkwsTUFBTTtZQUNyQjhHLFVBQVUsSUFBSSxDQUFDTCxNQUFNO1FBQ3pCO1FBQ0EsSUFBSSxDQUFDVyxTQUFTLEdBQUcxVCxpREFBR0EsQ0FBQyxTQUFTO1lBQzFCcUcsTUFBTTtZQUNOZCxNQUFNO1lBQ040TixNQUFNO1lBQ05LLFNBQVMvUyxNQUFNOEwsU0FBUztZQUN4QjZHLFVBQVUsSUFBSSxDQUFDTCxNQUFNO1FBQ3pCO1FBQ0EsU0FBU1ksT0FBT3BPLElBQUksRUFBRXFPLE9BQU8sRUFBRUMsT0FBTztZQUNsQyxPQUFPN1QsaURBQUdBLENBQUMsVUFBVTtnQkFBRXNGLE9BQU87Z0JBQWFDO2dCQUFNcU87Z0JBQVN2TixNQUFNO1lBQVMsR0FBR3dOO1FBQ2hGO1FBQ0EsSUFBSSxDQUFDck8sR0FBRyxHQUFHeEYsaURBQUdBLENBQUMsT0FBTztZQUFFeUYsV0FBVyxDQUFDaUMsSUFBTSxJQUFJLENBQUNvTSxPQUFPLENBQUNwTTtZQUFJcEMsT0FBTztRQUFZLEdBQUc7WUFDN0UsSUFBSSxDQUFDMk4sV0FBVztZQUNoQlUsT0FBTyxRQUFRLElBQU1oRCxTQUFTNUwsT0FBTztnQkFBQ3FCLE9BQU9yQixNQUFNO2FBQVE7WUFDM0Q0TyxPQUFPLFFBQVEsSUFBTTNDLGFBQWFqTSxPQUFPO2dCQUFDcUIsT0FBT3JCLE1BQU07YUFBWTtZQUNuRTRPLE9BQU8sVUFBVSxJQUFNekMsY0FBY25NLE9BQU87Z0JBQUNxQixPQUFPckIsTUFBTTthQUFPO1lBQ2pFL0UsaURBQUdBLENBQUMsU0FBUyxNQUFNO2dCQUFDLElBQUksQ0FBQ3VULFNBQVM7Z0JBQUVuTixPQUFPckIsTUFBTTthQUFjO1lBQy9EL0UsaURBQUdBLENBQUMsU0FBUyxNQUFNO2dCQUFDLElBQUksQ0FBQ3lULE9BQU87Z0JBQUVyTixPQUFPckIsTUFBTTthQUFVO1lBQ3pEL0UsaURBQUdBLENBQUMsU0FBUyxNQUFNO2dCQUFDLElBQUksQ0FBQzBULFNBQVM7Z0JBQUV0TixPQUFPckIsTUFBTTthQUFXO2VBQ3pEQSxLQUFLQyxLQUFLLENBQUNzTSxRQUFRLEdBQUcsRUFBRSxHQUFHO2dCQUMxQnRSLGlEQUFHQSxDQUFDO2dCQUNKLElBQUksQ0FBQ3NULFlBQVk7Z0JBQ2pCSyxPQUFPLFdBQVcsSUFBTXRDLFlBQVl0TSxPQUFPO29CQUFDcUIsT0FBT3JCLE1BQU07aUJBQVc7Z0JBQ3BFNE8sT0FBTyxjQUFjLElBQU0vQixXQUFXN00sT0FBTztvQkFBQ3FCLE9BQU9yQixNQUFNO2lCQUFlO2FBQzdFO1lBQ0QvRSxpREFBR0EsQ0FBQyxVQUFVO2dCQUNWdUYsTUFBTTtnQkFDTnFPLFNBQVMsSUFBTXBCLGlCQUFpQnpOO2dCQUNoQyxjQUFjcUIsT0FBT3JCLE1BQU07Z0JBQzNCc0IsTUFBTTtZQUNWLEdBQUc7Z0JBQUM7YUFBSTtTQUNYO0lBQ0w7SUFDQTBNLFNBQVM7UUFDTCxJQUFJdFMsUUFBUSxJQUFJcU0sWUFBWTtZQUN4QkgsUUFBUSxJQUFJLENBQUNzRyxXQUFXLENBQUNuUyxLQUFLO1lBQzlCc0wsZUFBZSxJQUFJLENBQUNtSCxTQUFTLENBQUNDLE9BQU87WUFDckNsSCxRQUFRLElBQUksQ0FBQ21ILE9BQU8sQ0FBQ0QsT0FBTztZQUM1QmpILFdBQVcsSUFBSSxDQUFDbUgsU0FBUyxDQUFDRixPQUFPO1lBQ2pDekcsU0FBUyxJQUFJLENBQUN1RyxZQUFZLENBQUN4UyxLQUFLO1FBQ3BDO1FBQ0EsSUFBSSxDQUFDTCxNQUFNK0ssRUFBRSxDQUFDLElBQUksQ0FBQy9LLEtBQUssR0FBRztZQUN2QixJQUFJLENBQUNBLEtBQUssR0FBR0E7WUFDYixJQUFJLENBQUNzRSxJQUFJLENBQUNjLFFBQVEsQ0FBQztnQkFBRUMsU0FBU3lKLGVBQWV2SixFQUFFLENBQUN2RjtZQUFPO1FBQzNEO0lBQ0o7SUFDQXFULFFBQVFwTSxDQUFDLEVBQUU7UUFDUCxJQUFJeEksa0VBQWdCQSxDQUFDLElBQUksQ0FBQzZGLElBQUksRUFBRTJDLEdBQUcsaUJBQWlCO1lBQ2hEQSxFQUFFOUIsY0FBYztRQUNwQixPQUNLLElBQUk4QixFQUFFL0IsT0FBTyxJQUFJLE1BQU0rQixFQUFFcU0sTUFBTSxJQUFJLElBQUksQ0FBQ2QsV0FBVyxFQUFFO1lBQ3REdkwsRUFBRTlCLGNBQWM7WUFDZjhCLENBQUFBLEVBQUVzTSxRQUFRLEdBQUdoRCxlQUFlTCxRQUFPLEVBQUcsSUFBSSxDQUFDNUwsSUFBSTtRQUNwRCxPQUNLLElBQUkyQyxFQUFFL0IsT0FBTyxJQUFJLE1BQU0rQixFQUFFcU0sTUFBTSxJQUFJLElBQUksQ0FBQ1QsWUFBWSxFQUFFO1lBQ3ZENUwsRUFBRTlCLGNBQWM7WUFDaEJ5TCxZQUFZLElBQUksQ0FBQ3RNLElBQUk7UUFDekI7SUFDSjtJQUNBeUMsT0FBT0EsTUFBTSxFQUFFO1FBQ1gsS0FBSyxJQUFJQyxNQUFNRCxPQUFPeU0sWUFBWSxDQUM5QixLQUFLLElBQUlyRSxVQUFVbkksR0FBRzNCLE9BQU8sQ0FBRTtZQUMzQixJQUFJOEosT0FBT2pJLEVBQUUsQ0FBQzRILG1CQUFtQixDQUFDSyxPQUFPOU8sS0FBSyxDQUFDMEssRUFBRSxDQUFDLElBQUksQ0FBQy9LLEtBQUssR0FDeEQsSUFBSSxDQUFDeVQsUUFBUSxDQUFDdEUsT0FBTzlPLEtBQUs7UUFDbEM7SUFDUjtJQUNBb1QsU0FBU3pULEtBQUssRUFBRTtRQUNaLElBQUksQ0FBQ0EsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQ3dTLFdBQVcsQ0FBQ25TLEtBQUssR0FBR0wsTUFBTWtNLE1BQU07UUFDckMsSUFBSSxDQUFDMkcsWUFBWSxDQUFDeFMsS0FBSyxHQUFHTCxNQUFNc00sT0FBTztRQUN2QyxJQUFJLENBQUN3RyxTQUFTLENBQUNDLE9BQU8sR0FBRy9TLE1BQU0yTCxhQUFhO1FBQzVDLElBQUksQ0FBQ3FILE9BQU8sQ0FBQ0QsT0FBTyxHQUFHL1MsTUFBTTZMLE1BQU07UUFDbkMsSUFBSSxDQUFDb0gsU0FBUyxDQUFDRixPQUFPLEdBQUcvUyxNQUFNOEwsU0FBUztJQUM1QztJQUNBNEgsUUFBUTtRQUNKLElBQUksQ0FBQ2xCLFdBQVcsQ0FBQzVLLE1BQU07SUFDM0I7SUFDQSxJQUFJdkcsTUFBTTtRQUFFLE9BQU87SUFBSTtJQUN2QixJQUFJcUssTUFBTTtRQUFFLE9BQU8sSUFBSSxDQUFDcEgsSUFBSSxDQUFDQyxLQUFLLENBQUNxRixLQUFLLENBQUM0QixtQkFBbUJFLEdBQUc7SUFBRTtBQUNyRTtBQUNBLFNBQVMvRixPQUFPckIsSUFBSSxFQUFFcUIsTUFBTTtJQUFJLE9BQU9yQixLQUFLQyxLQUFLLENBQUNvQixNQUFNLENBQUNBO0FBQVM7QUFDbEUsTUFBTWdPLGlCQUFpQjtBQUN2QixNQUFNQyxRQUFRO0FBQ2QsU0FBU3hELGNBQWM5TCxJQUFJLEVBQUUsRUFBRXJFLElBQUksRUFBRUMsRUFBRSxFQUFFO0lBQ3JDLElBQUlrRSxPQUFPRSxLQUFLQyxLQUFLLENBQUNiLEdBQUcsQ0FBQ2YsTUFBTSxDQUFDMUMsT0FBTzRULFVBQVV2UCxLQUFLQyxLQUFLLENBQUNiLEdBQUcsQ0FBQ2YsTUFBTSxDQUFDekMsSUFBSUEsRUFBRTtJQUM5RSxJQUFJZ0IsUUFBUWtGLEtBQUtHLEdBQUcsQ0FBQ25DLEtBQUtuRSxJQUFJLEVBQUVBLE9BQU8wVCxpQkFBaUJHLE1BQU0xTixLQUFLSSxHQUFHLENBQUNxTixTQUFTM1QsS0FBS3lUO0lBQ3JGLElBQUk1VCxPQUFPdUUsS0FBS0MsS0FBSyxDQUFDMkUsUUFBUSxDQUFDaEksT0FBTzRTO0lBQ3RDLElBQUk1UyxTQUFTa0QsS0FBS25FLElBQUksRUFBRTtRQUNwQixJQUFLLElBQUltQixJQUFJLEdBQUdBLElBQUl1UyxnQkFBZ0J2UyxJQUNoQyxJQUFJLENBQUN3UyxNQUFNeFQsSUFBSSxDQUFDTCxJQUFJLENBQUNxQixJQUFJLEVBQUUsS0FBS3dTLE1BQU14VCxJQUFJLENBQUNMLElBQUksQ0FBQ3FCLEVBQUUsR0FBRztZQUNqRHJCLE9BQU9BLEtBQUttRCxLQUFLLENBQUM5QjtZQUNsQjtRQUNKO0lBQ1I7SUFDQSxJQUFJMFMsT0FBT0QsU0FBUztRQUNoQixJQUFLLElBQUl6UyxJQUFJckIsS0FBS0ksTUFBTSxHQUFHLEdBQUdpQixJQUFJckIsS0FBS0ksTUFBTSxHQUFHd1QsZ0JBQWdCdlMsSUFDNUQsSUFBSSxDQUFDd1MsTUFBTXhULElBQUksQ0FBQ0wsSUFBSSxDQUFDcUIsSUFBSSxFQUFFLEtBQUt3UyxNQUFNeFQsSUFBSSxDQUFDTCxJQUFJLENBQUNxQixFQUFFLEdBQUc7WUFDakRyQixPQUFPQSxLQUFLbUQsS0FBSyxDQUFDLEdBQUc5QjtZQUNyQjtRQUNKO0lBQ1I7SUFDQSxPQUFPL0Msd0RBQVVBLENBQUM2UyxRQUFRLENBQUMzTCxFQUFFLENBQUMsQ0FBQyxFQUFFakIsS0FBS0MsS0FBSyxDQUFDb0IsTUFBTSxDQUFDLGlCQUFpQixFQUFFLEVBQUU1RixLQUFLLENBQUMsRUFBRXVFLEtBQUtDLEtBQUssQ0FBQ29CLE1BQU0sQ0FBQyxXQUFXLENBQUMsRUFBRXZCLEtBQUtPLE1BQU0sQ0FBQyxDQUFDLENBQUM7QUFDbEk7QUFDQSxNQUFNa0QsWUFBWSxXQUFXLEdBQUV4Six3REFBVUEsQ0FBQ3dKLFNBQVMsQ0FBQztJQUNoRCx1QkFBdUI7UUFDbkJDLFNBQVM7UUFDVGlNLFVBQVU7UUFDVixrQkFBa0I7WUFDZEEsVUFBVTtZQUNWckksS0FBSztZQUNMc0ksT0FBTztZQUNQdEosaUJBQWlCO1lBQ2pCdUosUUFBUTtZQUNSQyxNQUFNO1lBQ05wTSxTQUFTO1lBQ1RxTSxRQUFRO1FBQ1o7UUFDQSw4QkFBOEI7WUFDMUJBLFFBQVE7UUFDWjtRQUNBLDBCQUEwQjtZQUN0QkMsYUFBYTtRQUNqQjtRQUNBLFdBQVc7WUFDUHJNLFVBQVU7WUFDVnNNLFlBQVk7UUFDaEI7SUFDSjtJQUNBLDBCQUEwQjtRQUFFM0osaUJBQWlCO0lBQVk7SUFDekQseUJBQXlCO1FBQUVBLGlCQUFpQjtJQUFZO0lBQ3hELG1DQUFtQztRQUFFQSxpQkFBaUI7SUFBWTtJQUNsRSxrQ0FBa0M7UUFBRUEsaUJBQWlCO0lBQVk7QUFDckU7QUFDQSxNQUFNMEIsbUJBQW1CO0lBQ3JCNEM7SUFDQSxXQUFXLEdBQUU1UCxtREFBSUEsQ0FBQ2tWLEdBQUcsQ0FBQzVFO0lBQ3RCN0g7Q0FDSDtBQUUrUyIsInNvdXJjZXMiOlsid2VicGFjazovL3B5dGhvbi1vbmxpbmUtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL3NlYXJjaC9kaXN0L2luZGV4LmpzP2NkMmYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc2hvd1BhbmVsLCBFZGl0b3JWaWV3LCBnZXRQYW5lbCwgRGVjb3JhdGlvbiwgVmlld1BsdWdpbiwgcnVuU2NvcGVIYW5kbGVycyB9IGZyb20gJ0Bjb2RlbWlycm9yL3ZpZXcnO1xuaW1wb3J0IHsgY29kZVBvaW50QXQsIGZyb21Db2RlUG9pbnQsIGNvZGVQb2ludFNpemUsIFN0YXRlRWZmZWN0LCBTdGF0ZUZpZWxkLCBFZGl0b3JTZWxlY3Rpb24sIEZhY2V0LCBjb21iaW5lQ29uZmlnLCBDaGFyQ2F0ZWdvcnksIFJhbmdlU2V0QnVpbGRlciwgUHJlYywgRWRpdG9yU3RhdGUsIGZpbmRDbHVzdGVyQnJlYWsgfSBmcm9tICdAY29kZW1pcnJvci9zdGF0ZSc7XG5pbXBvcnQgZWx0IGZyb20gJ2NyZWx0JztcblxuY29uc3QgYmFzaWNOb3JtYWxpemUgPSB0eXBlb2YgU3RyaW5nLnByb3RvdHlwZS5ub3JtYWxpemUgPT0gXCJmdW5jdGlvblwiXG4gICAgPyB4ID0+IHgubm9ybWFsaXplKFwiTkZLRFwiKSA6IHggPT4geDtcbi8qKlxuQSBzZWFyY2ggY3Vyc29yIHByb3ZpZGVzIGFuIGl0ZXJhdG9yIG92ZXIgdGV4dCBtYXRjaGVzIGluIGFcbmRvY3VtZW50LlxuKi9cbmNsYXNzIFNlYXJjaEN1cnNvciB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgdGV4dCBjdXJzb3IuIFRoZSBxdWVyeSBpcyB0aGUgc2VhcmNoIHN0cmluZywgYGZyb21gIHRvXG4gICAgYHRvYCBwcm92aWRlcyB0aGUgcmVnaW9uIHRvIHNlYXJjaC5cbiAgICBcbiAgICBXaGVuIGBub3JtYWxpemVgIGlzIGdpdmVuLCBpdCB3aWxsIGJlIGNhbGxlZCwgb24gYm90aCB0aGUgcXVlcnlcbiAgICBzdHJpbmcgYW5kIHRoZSBjb250ZW50IGl0IGlzIG1hdGNoZWQgYWdhaW5zdCwgYmVmb3JlIGNvbXBhcmluZy5cbiAgICBZb3UgY2FuLCBmb3IgZXhhbXBsZSwgY3JlYXRlIGEgY2FzZS1pbnNlbnNpdGl2ZSBzZWFyY2ggYnlcbiAgICBwYXNzaW5nIGBzID0+IHMudG9Mb3dlckNhc2UoKWAuXG4gICAgXG4gICAgVGV4dCBpcyBhbHdheXMgbm9ybWFsaXplZCB3aXRoXG4gICAgW2Aubm9ybWFsaXplKFwiTkZLRFwiKWBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9ub3JtYWxpemUpXG4gICAgKHdoZW4gc3VwcG9ydGVkKS5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHRleHQsIHF1ZXJ5LCBmcm9tID0gMCwgdG8gPSB0ZXh0Lmxlbmd0aCwgbm9ybWFsaXplLCB0ZXN0KSB7XG4gICAgICAgIHRoaXMudGVzdCA9IHRlc3Q7XG4gICAgICAgIC8qKlxuICAgICAgICBUaGUgY3VycmVudCBtYXRjaCAob25seSBob2xkcyBhIG1lYW5pbmdmdWwgdmFsdWUgYWZ0ZXJcbiAgICAgICAgW2BuZXh0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzZWFyY2guU2VhcmNoQ3Vyc29yLm5leHQpIGhhcyBiZWVuIGNhbGxlZCBhbmQgd2hlblxuICAgICAgICBgZG9uZWAgaXMgZmFsc2UpLlxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnZhbHVlID0geyBmcm9tOiAwLCB0bzogMCB9O1xuICAgICAgICAvKipcbiAgICAgICAgV2hldGhlciB0aGUgZW5kIG9mIHRoZSBpdGVyYXRlZCByZWdpb24gaGFzIGJlZW4gcmVhY2hlZC5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICAgIHRoaXMubWF0Y2hlcyA9IFtdO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IFwiXCI7XG4gICAgICAgIHRoaXMuYnVmZmVyUG9zID0gMDtcbiAgICAgICAgdGhpcy5pdGVyID0gdGV4dC5pdGVyUmFuZ2UoZnJvbSwgdG8pO1xuICAgICAgICB0aGlzLmJ1ZmZlclN0YXJ0ID0gZnJvbTtcbiAgICAgICAgdGhpcy5ub3JtYWxpemUgPSBub3JtYWxpemUgPyB4ID0+IG5vcm1hbGl6ZShiYXNpY05vcm1hbGl6ZSh4KSkgOiBiYXNpY05vcm1hbGl6ZTtcbiAgICAgICAgdGhpcy5xdWVyeSA9IHRoaXMubm9ybWFsaXplKHF1ZXJ5KTtcbiAgICB9XG4gICAgcGVlaygpIHtcbiAgICAgICAgaWYgKHRoaXMuYnVmZmVyUG9zID09IHRoaXMuYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5idWZmZXJTdGFydCArPSB0aGlzLmJ1ZmZlci5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLml0ZXIubmV4dCgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXRlci5kb25lKVxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyUG9zID0gMDtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gdGhpcy5pdGVyLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2RlUG9pbnRBdCh0aGlzLmJ1ZmZlciwgdGhpcy5idWZmZXJQb3MpO1xuICAgIH1cbiAgICAvKipcbiAgICBMb29rIGZvciB0aGUgbmV4dCBtYXRjaC4gVXBkYXRlcyB0aGUgaXRlcmF0b3Inc1xuICAgIFtgdmFsdWVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3NlYXJjaC5TZWFyY2hDdXJzb3IudmFsdWUpIGFuZFxuICAgIFtgZG9uZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLlNlYXJjaEN1cnNvci5kb25lKSBwcm9wZXJ0aWVzLiBTaG91bGQgYmUgY2FsbGVkXG4gICAgYXQgbGVhc3Qgb25jZSBiZWZvcmUgdXNpbmcgdGhlIGN1cnNvci5cbiAgICAqL1xuICAgIG5leHQoKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLm1hdGNoZXMubGVuZ3RoKVxuICAgICAgICAgICAgdGhpcy5tYXRjaGVzLnBvcCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5uZXh0T3ZlcmxhcHBpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIGBuZXh0YCBtZXRob2Qgd2lsbCBpZ25vcmUgbWF0Y2hlcyB0aGF0IHBhcnRpYWxseSBvdmVybGFwIGFcbiAgICBwcmV2aW91cyBtYXRjaC4gVGhpcyBtZXRob2QgYmVoYXZlcyBsaWtlIGBuZXh0YCwgYnV0IGluY2x1ZGVzXG4gICAgc3VjaCBtYXRjaGVzLlxuICAgICovXG4gICAgbmV4dE92ZXJsYXBwaW5nKCkge1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IHRoaXMucGVlaygpO1xuICAgICAgICAgICAgaWYgKG5leHQgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzdHIgPSBmcm9tQ29kZVBvaW50KG5leHQpLCBzdGFydCA9IHRoaXMuYnVmZmVyU3RhcnQgKyB0aGlzLmJ1ZmZlclBvcztcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyUG9zICs9IGNvZGVQb2ludFNpemUobmV4dCk7XG4gICAgICAgICAgICBsZXQgbm9ybSA9IHRoaXMubm9ybWFsaXplKHN0cik7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gc3RhcnQ7OyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgY29kZSA9IG5vcm0uY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgICAgICBsZXQgbWF0Y2ggPSB0aGlzLm1hdGNoKGNvZGUsIHBvcyk7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT0gbm9ybS5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IG1hdGNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwb3MgPT0gc3RhcnQgJiYgaSA8IHN0ci5sZW5ndGggJiYgc3RyLmNoYXJDb2RlQXQoaSkgPT0gY29kZSlcbiAgICAgICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbWF0Y2goY29kZSwgcG9zKSB7XG4gICAgICAgIGxldCBtYXRjaCA9IG51bGw7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5tYXRjaGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSB0aGlzLm1hdGNoZXNbaV0sIGtlZXAgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnF1ZXJ5LmNoYXJDb2RlQXQoaW5kZXgpID09IGNvZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT0gdGhpcy5xdWVyeS5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoID0geyBmcm9tOiB0aGlzLm1hdGNoZXNbaSArIDFdLCB0bzogcG9zICsgMSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRjaGVzW2ldKys7XG4gICAgICAgICAgICAgICAgICAgIGtlZXAgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgha2VlcCkge1xuICAgICAgICAgICAgICAgIHRoaXMubWF0Y2hlcy5zcGxpY2UoaSwgMik7XG4gICAgICAgICAgICAgICAgaSAtPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnF1ZXJ5LmNoYXJDb2RlQXQoMCkgPT0gY29kZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucXVlcnkubGVuZ3RoID09IDEpXG4gICAgICAgICAgICAgICAgbWF0Y2ggPSB7IGZyb206IHBvcywgdG86IHBvcyArIDEgfTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLm1hdGNoZXMucHVzaCgxLCBwb3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRjaCAmJiB0aGlzLnRlc3QgJiYgIXRoaXMudGVzdChtYXRjaC5mcm9tLCBtYXRjaC50bywgdGhpcy5idWZmZXIsIHRoaXMuYnVmZmVyU3RhcnQpKVxuICAgICAgICAgICAgbWF0Y2ggPSBudWxsO1xuICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfVxufVxuaWYgKHR5cGVvZiBTeW1ib2wgIT0gXCJ1bmRlZmluZWRcIilcbiAgICBTZWFyY2hDdXJzb3IucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xuXG5jb25zdCBlbXB0eSA9IHsgZnJvbTogLTEsIHRvOiAtMSwgbWF0Y2g6IC8qQF9fUFVSRV9fKi8vLiovLmV4ZWMoXCJcIikgfTtcbmNvbnN0IGJhc2VGbGFncyA9IFwiZ21cIiArICgveC8udW5pY29kZSA9PSBudWxsID8gXCJcIiA6IFwidVwiKTtcbi8qKlxuVGhpcyBjbGFzcyBpcyBzaW1pbGFyIHRvIFtgU2VhcmNoQ3Vyc29yYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzZWFyY2guU2VhcmNoQ3Vyc29yKVxuYnV0IHNlYXJjaGVzIGZvciBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBwYXR0ZXJuIGluc3RlYWQgb2YgYSBwbGFpblxuc3RyaW5nLlxuKi9cbmNsYXNzIFJlZ0V4cEN1cnNvciB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgY3Vyc29yIHRoYXQgd2lsbCBzZWFyY2ggdGhlIGdpdmVuIHJhbmdlIGluIHRoZSBnaXZlblxuICAgIGRvY3VtZW50LiBgcXVlcnlgIHNob3VsZCBiZSB0aGUgcmF3IHBhdHRlcm4gKGFzIHlvdSdkIHBhc3MgaXQgdG9cbiAgICBgbmV3IFJlZ0V4cGApLlxuICAgICovXG4gICAgY29uc3RydWN0b3IodGV4dCwgcXVlcnksIG9wdGlvbnMsIGZyb20gPSAwLCB0byA9IHRleHQubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy5jdXJMaW5lID0gXCJcIjtcbiAgICAgICAgLyoqXG4gICAgICAgIFNldCB0byBgdHJ1ZWAgd2hlbiB0aGUgY3Vyc29yIGhhcyByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIHNlYXJjaFxuICAgICAgICByYW5nZS5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICBXaWxsIGNvbnRhaW4gYW4gb2JqZWN0IHdpdGggdGhlIGV4dGVudCBvZiB0aGUgbWF0Y2ggYW5kIHRoZVxuICAgICAgICBtYXRjaCBvYmplY3Qgd2hlbiBbYG5leHRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3NlYXJjaC5SZWdFeHBDdXJzb3IubmV4dClcbiAgICAgICAgc3VjZXNzZnVsbHkgZmluZHMgYSBtYXRjaC5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy52YWx1ZSA9IGVtcHR5O1xuICAgICAgICBpZiAoL1xcXFxbc1dEbnJdfFxcbnxcXHJ8XFxbXFxeLy50ZXN0KHF1ZXJ5KSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgTXVsdGlsaW5lUmVnRXhwQ3Vyc29yKHRleHQsIHF1ZXJ5LCBvcHRpb25zLCBmcm9tLCB0byk7XG4gICAgICAgIHRoaXMucmUgPSBuZXcgUmVnRXhwKHF1ZXJ5LCBiYXNlRmxhZ3MgKyAoKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5pZ25vcmVDYXNlKSA/IFwiaVwiIDogXCJcIikpO1xuICAgICAgICB0aGlzLnRlc3QgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudGVzdDtcbiAgICAgICAgdGhpcy5pdGVyID0gdGV4dC5pdGVyKCk7XG4gICAgICAgIGxldCBzdGFydExpbmUgPSB0ZXh0LmxpbmVBdChmcm9tKTtcbiAgICAgICAgdGhpcy5jdXJMaW5lU3RhcnQgPSBzdGFydExpbmUuZnJvbTtcbiAgICAgICAgdGhpcy5tYXRjaFBvcyA9IHRvQ2hhckVuZCh0ZXh0LCBmcm9tKTtcbiAgICAgICAgdGhpcy5nZXRMaW5lKHRoaXMuY3VyTGluZVN0YXJ0KTtcbiAgICB9XG4gICAgZ2V0TGluZShza2lwKSB7XG4gICAgICAgIHRoaXMuaXRlci5uZXh0KHNraXApO1xuICAgICAgICBpZiAodGhpcy5pdGVyLmxpbmVCcmVhaykge1xuICAgICAgICAgICAgdGhpcy5jdXJMaW5lID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY3VyTGluZSA9IHRoaXMuaXRlci52YWx1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1ckxpbmVTdGFydCArIHRoaXMuY3VyTGluZS5sZW5ndGggPiB0aGlzLnRvKVxuICAgICAgICAgICAgICAgIHRoaXMuY3VyTGluZSA9IHRoaXMuY3VyTGluZS5zbGljZSgwLCB0aGlzLnRvIC0gdGhpcy5jdXJMaW5lU3RhcnQpO1xuICAgICAgICAgICAgdGhpcy5pdGVyLm5leHQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZXh0TGluZSgpIHtcbiAgICAgICAgdGhpcy5jdXJMaW5lU3RhcnQgPSB0aGlzLmN1ckxpbmVTdGFydCArIHRoaXMuY3VyTGluZS5sZW5ndGggKyAxO1xuICAgICAgICBpZiAodGhpcy5jdXJMaW5lU3RhcnQgPiB0aGlzLnRvKVxuICAgICAgICAgICAgdGhpcy5jdXJMaW5lID0gXCJcIjtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5nZXRMaW5lKDApO1xuICAgIH1cbiAgICAvKipcbiAgICBNb3ZlIHRvIHRoZSBuZXh0IG1hdGNoLCBpZiB0aGVyZSBpcyBvbmUuXG4gICAgKi9cbiAgICBuZXh0KCkge1xuICAgICAgICBmb3IgKGxldCBvZmYgPSB0aGlzLm1hdGNoUG9zIC0gdGhpcy5jdXJMaW5lU3RhcnQ7Oykge1xuICAgICAgICAgICAgdGhpcy5yZS5sYXN0SW5kZXggPSBvZmY7XG4gICAgICAgICAgICBsZXQgbWF0Y2ggPSB0aGlzLm1hdGNoUG9zIDw9IHRoaXMudG8gJiYgdGhpcy5yZS5leGVjKHRoaXMuY3VyTGluZSk7XG4gICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICBsZXQgZnJvbSA9IHRoaXMuY3VyTGluZVN0YXJ0ICsgbWF0Y2guaW5kZXgsIHRvID0gZnJvbSArIG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB0aGlzLm1hdGNoUG9zID0gdG9DaGFyRW5kKHRoaXMudGV4dCwgdG8gKyAoZnJvbSA9PSB0byA/IDEgOiAwKSk7XG4gICAgICAgICAgICAgICAgaWYgKGZyb20gPT0gdGhpcy5jdXJMaW5lU3RhcnQgKyB0aGlzLmN1ckxpbmUubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHRMaW5lKCk7XG4gICAgICAgICAgICAgICAgaWYgKChmcm9tIDwgdG8gfHwgZnJvbSA+IHRoaXMudmFsdWUudG8pICYmICghdGhpcy50ZXN0IHx8IHRoaXMudGVzdChmcm9tLCB0bywgbWF0Y2gpKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0geyBmcm9tLCB0bywgbWF0Y2ggfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9mZiA9IHRoaXMubWF0Y2hQb3MgLSB0aGlzLmN1ckxpbmVTdGFydDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuY3VyTGluZVN0YXJ0ICsgdGhpcy5jdXJMaW5lLmxlbmd0aCA8IHRoaXMudG8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRMaW5lKCk7XG4gICAgICAgICAgICAgICAgb2ZmID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5jb25zdCBmbGF0dGVuZWQgPSAvKkBfX1BVUkVfXyovbmV3IFdlYWtNYXAoKTtcbi8vIFJldXNhYmxlIChwYXJ0aWFsbHkpIGZsYXR0ZW5lZCBkb2N1bWVudCBzdHJpbmdzXG5jbGFzcyBGbGF0dGVuZWREb2Mge1xuICAgIGNvbnN0cnVjdG9yKGZyb20sIHRleHQpIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICB9XG4gICAgZ2V0IHRvKCkgeyByZXR1cm4gdGhpcy5mcm9tICsgdGhpcy50ZXh0Lmxlbmd0aDsgfVxuICAgIHN0YXRpYyBnZXQoZG9jLCBmcm9tLCB0bykge1xuICAgICAgICBsZXQgY2FjaGVkID0gZmxhdHRlbmVkLmdldChkb2MpO1xuICAgICAgICBpZiAoIWNhY2hlZCB8fCBjYWNoZWQuZnJvbSA+PSB0byB8fCBjYWNoZWQudG8gPD0gZnJvbSkge1xuICAgICAgICAgICAgbGV0IGZsYXQgPSBuZXcgRmxhdHRlbmVkRG9jKGZyb20sIGRvYy5zbGljZVN0cmluZyhmcm9tLCB0bykpO1xuICAgICAgICAgICAgZmxhdHRlbmVkLnNldChkb2MsIGZsYXQpO1xuICAgICAgICAgICAgcmV0dXJuIGZsYXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhY2hlZC5mcm9tID09IGZyb20gJiYgY2FjaGVkLnRvID09IHRvKVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICAgICAgbGV0IHsgdGV4dCwgZnJvbTogY2FjaGVkRnJvbSB9ID0gY2FjaGVkO1xuICAgICAgICBpZiAoY2FjaGVkRnJvbSA+IGZyb20pIHtcbiAgICAgICAgICAgIHRleHQgPSBkb2Muc2xpY2VTdHJpbmcoZnJvbSwgY2FjaGVkRnJvbSkgKyB0ZXh0O1xuICAgICAgICAgICAgY2FjaGVkRnJvbSA9IGZyb207XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhY2hlZC50byA8IHRvKVxuICAgICAgICAgICAgdGV4dCArPSBkb2Muc2xpY2VTdHJpbmcoY2FjaGVkLnRvLCB0byk7XG4gICAgICAgIGZsYXR0ZW5lZC5zZXQoZG9jLCBuZXcgRmxhdHRlbmVkRG9jKGNhY2hlZEZyb20sIHRleHQpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBGbGF0dGVuZWREb2MoZnJvbSwgdGV4dC5zbGljZShmcm9tIC0gY2FjaGVkRnJvbSwgdG8gLSBjYWNoZWRGcm9tKSk7XG4gICAgfVxufVxuY2xhc3MgTXVsdGlsaW5lUmVnRXhwQ3Vyc29yIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZXh0LCBxdWVyeSwgb3B0aW9ucywgZnJvbSwgdG8pIHtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IGVtcHR5O1xuICAgICAgICB0aGlzLm1hdGNoUG9zID0gdG9DaGFyRW5kKHRleHQsIGZyb20pO1xuICAgICAgICB0aGlzLnJlID0gbmV3IFJlZ0V4cChxdWVyeSwgYmFzZUZsYWdzICsgKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuaWdub3JlQ2FzZSkgPyBcImlcIiA6IFwiXCIpKTtcbiAgICAgICAgdGhpcy50ZXN0ID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRlc3Q7XG4gICAgICAgIHRoaXMuZmxhdCA9IEZsYXR0ZW5lZERvYy5nZXQodGV4dCwgZnJvbSwgdGhpcy5jaHVua0VuZChmcm9tICsgNTAwMCAvKiBDaHVuay5CYXNlICovKSk7XG4gICAgfVxuICAgIGNodW5rRW5kKHBvcykge1xuICAgICAgICByZXR1cm4gcG9zID49IHRoaXMudG8gPyB0aGlzLnRvIDogdGhpcy50ZXh0LmxpbmVBdChwb3MpLnRvO1xuICAgIH1cbiAgICBuZXh0KCkge1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgb2ZmID0gdGhpcy5yZS5sYXN0SW5kZXggPSB0aGlzLm1hdGNoUG9zIC0gdGhpcy5mbGF0LmZyb207XG4gICAgICAgICAgICBsZXQgbWF0Y2ggPSB0aGlzLnJlLmV4ZWModGhpcy5mbGF0LnRleHQpO1xuICAgICAgICAgICAgLy8gU2tpcCBlbXB0eSBtYXRjaGVzIGRpcmVjdGx5IGFmdGVyIHRoZSBsYXN0IG1hdGNoXG4gICAgICAgICAgICBpZiAobWF0Y2ggJiYgIW1hdGNoWzBdICYmIG1hdGNoLmluZGV4ID09IG9mZikge1xuICAgICAgICAgICAgICAgIHRoaXMucmUubGFzdEluZGV4ID0gb2ZmICsgMTtcbiAgICAgICAgICAgICAgICBtYXRjaCA9IHRoaXMucmUuZXhlYyh0aGlzLmZsYXQudGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICBsZXQgZnJvbSA9IHRoaXMuZmxhdC5mcm9tICsgbWF0Y2guaW5kZXgsIHRvID0gZnJvbSArIG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAvLyBJZiBhIG1hdGNoIGdvZXMgYWxtb3N0IHRvIHRoZSBlbmQgb2YgYSBub25jb21wbGV0ZSBjaHVuaywgdHJ5XG4gICAgICAgICAgICAgICAgLy8gYWdhaW4sIHNpbmNlIGl0J2xsIGxpa2VseSBiZSBhYmxlIHRvIG1hdGNoIG1vcmVcbiAgICAgICAgICAgICAgICBpZiAoKHRoaXMuZmxhdC50byA+PSB0aGlzLnRvIHx8IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoIDw9IHRoaXMuZmxhdC50ZXh0Lmxlbmd0aCAtIDEwKSAmJlxuICAgICAgICAgICAgICAgICAgICAoIXRoaXMudGVzdCB8fCB0aGlzLnRlc3QoZnJvbSwgdG8sIG1hdGNoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHsgZnJvbSwgdG8sIG1hdGNoIH07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2hQb3MgPSB0b0NoYXJFbmQodGhpcy50ZXh0LCB0byArIChmcm9tID09IHRvID8gMSA6IDApKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZmxhdC50byA9PSB0aGlzLnRvKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEdyb3cgdGhlIGZsYXR0ZW5lZCBkb2NcbiAgICAgICAgICAgIHRoaXMuZmxhdCA9IEZsYXR0ZW5lZERvYy5nZXQodGhpcy50ZXh0LCB0aGlzLmZsYXQuZnJvbSwgdGhpcy5jaHVua0VuZCh0aGlzLmZsYXQuZnJvbSArIHRoaXMuZmxhdC50ZXh0Lmxlbmd0aCAqIDIpKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmlmICh0eXBlb2YgU3ltYm9sICE9IFwidW5kZWZpbmVkXCIpIHtcbiAgICBSZWdFeHBDdXJzb3IucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBNdWx0aWxpbmVSZWdFeHBDdXJzb3IucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPVxuICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xufVxuZnVuY3Rpb24gdmFsaWRSZWdFeHAoc291cmNlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgbmV3IFJlZ0V4cChzb3VyY2UsIGJhc2VGbGFncyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRvQ2hhckVuZCh0ZXh0LCBwb3MpIHtcbiAgICBpZiAocG9zID49IHRleHQubGVuZ3RoKVxuICAgICAgICByZXR1cm4gcG9zO1xuICAgIGxldCBsaW5lID0gdGV4dC5saW5lQXQocG9zKSwgbmV4dDtcbiAgICB3aGlsZSAocG9zIDwgbGluZS50byAmJiAobmV4dCA9IGxpbmUudGV4dC5jaGFyQ29kZUF0KHBvcyAtIGxpbmUuZnJvbSkpID49IDB4REMwMCAmJiBuZXh0IDwgMHhFMDAwKVxuICAgICAgICBwb3MrKztcbiAgICByZXR1cm4gcG9zO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVMaW5lRGlhbG9nKHZpZXcpIHtcbiAgICBsZXQgbGluZSA9IFN0cmluZyh2aWV3LnN0YXRlLmRvYy5saW5lQXQodmlldy5zdGF0ZS5zZWxlY3Rpb24ubWFpbi5oZWFkKS5udW1iZXIpO1xuICAgIGxldCBpbnB1dCA9IGVsdChcImlucHV0XCIsIHsgY2xhc3M6IFwiY20tdGV4dGZpZWxkXCIsIG5hbWU6IFwibGluZVwiLCB2YWx1ZTogbGluZSB9KTtcbiAgICBsZXQgZG9tID0gZWx0KFwiZm9ybVwiLCB7XG4gICAgICAgIGNsYXNzOiBcImNtLWdvdG9MaW5lXCIsXG4gICAgICAgIG9ua2V5ZG93bjogKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PSAyNykgeyAvLyBFc2NhcGVcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBkaWFsb2dFZmZlY3Qub2YoZmFsc2UpIH0pO1xuICAgICAgICAgICAgICAgIHZpZXcuZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50LmtleUNvZGUgPT0gMTMpIHsgLy8gRW50ZXJcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGdvKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9uc3VibWl0OiAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBnbygpO1xuICAgICAgICB9XG4gICAgfSwgZWx0KFwibGFiZWxcIiwgdmlldy5zdGF0ZS5waHJhc2UoXCJHbyB0byBsaW5lXCIpLCBcIjogXCIsIGlucHV0KSwgXCIgXCIsIGVsdChcImJ1dHRvblwiLCB7IGNsYXNzOiBcImNtLWJ1dHRvblwiLCB0eXBlOiBcInN1Ym1pdFwiIH0sIHZpZXcuc3RhdGUucGhyYXNlKFwiZ29cIikpKTtcbiAgICBmdW5jdGlvbiBnbygpIHtcbiAgICAgICAgbGV0IG1hdGNoID0gL14oWystXSk/KFxcZCspPyg6XFxkKyk/KCUpPyQvLmV4ZWMoaW5wdXQudmFsdWUpO1xuICAgICAgICBpZiAoIW1hdGNoKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgeyBzdGF0ZSB9ID0gdmlldywgc3RhcnRMaW5lID0gc3RhdGUuZG9jLmxpbmVBdChzdGF0ZS5zZWxlY3Rpb24ubWFpbi5oZWFkKTtcbiAgICAgICAgbGV0IFssIHNpZ24sIGxuLCBjbCwgcGVyY2VudF0gPSBtYXRjaDtcbiAgICAgICAgbGV0IGNvbCA9IGNsID8gK2NsLnNsaWNlKDEpIDogMDtcbiAgICAgICAgbGV0IGxpbmUgPSBsbiA/ICtsbiA6IHN0YXJ0TGluZS5udW1iZXI7XG4gICAgICAgIGlmIChsbiAmJiBwZXJjZW50KSB7XG4gICAgICAgICAgICBsZXQgcGMgPSBsaW5lIC8gMTAwO1xuICAgICAgICAgICAgaWYgKHNpZ24pXG4gICAgICAgICAgICAgICAgcGMgPSBwYyAqIChzaWduID09IFwiLVwiID8gLTEgOiAxKSArIChzdGFydExpbmUubnVtYmVyIC8gc3RhdGUuZG9jLmxpbmVzKTtcbiAgICAgICAgICAgIGxpbmUgPSBNYXRoLnJvdW5kKHN0YXRlLmRvYy5saW5lcyAqIHBjKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsbiAmJiBzaWduKSB7XG4gICAgICAgICAgICBsaW5lID0gbGluZSAqIChzaWduID09IFwiLVwiID8gLTEgOiAxKSArIHN0YXJ0TGluZS5udW1iZXI7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRvY0xpbmUgPSBzdGF0ZS5kb2MubGluZShNYXRoLm1heCgxLCBNYXRoLm1pbihzdGF0ZS5kb2MubGluZXMsIGxpbmUpKSk7XG4gICAgICAgIGxldCBzZWxlY3Rpb24gPSBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKGRvY0xpbmUuZnJvbSArIE1hdGgubWF4KDAsIE1hdGgubWluKGNvbCwgZG9jTGluZS5sZW5ndGgpKSk7XG4gICAgICAgIHZpZXcuZGlzcGF0Y2goe1xuICAgICAgICAgICAgZWZmZWN0czogW2RpYWxvZ0VmZmVjdC5vZihmYWxzZSksIEVkaXRvclZpZXcuc2Nyb2xsSW50b1ZpZXcoc2VsZWN0aW9uLmZyb20sIHsgeTogJ2NlbnRlcicgfSldLFxuICAgICAgICAgICAgc2VsZWN0aW9uLFxuICAgICAgICB9KTtcbiAgICAgICAgdmlldy5mb2N1cygpO1xuICAgIH1cbiAgICByZXR1cm4geyBkb20gfTtcbn1cbmNvbnN0IGRpYWxvZ0VmZmVjdCA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcbmNvbnN0IGRpYWxvZ0ZpZWxkID0gLypAX19QVVJFX18qL1N0YXRlRmllbGQuZGVmaW5lKHtcbiAgICBjcmVhdGUoKSB7IHJldHVybiB0cnVlOyB9LFxuICAgIHVwZGF0ZSh2YWx1ZSwgdHIpIHtcbiAgICAgICAgZm9yIChsZXQgZSBvZiB0ci5lZmZlY3RzKVxuICAgICAgICAgICAgaWYgKGUuaXMoZGlhbG9nRWZmZWN0KSlcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGUudmFsdWU7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIHByb3ZpZGU6IGYgPT4gc2hvd1BhbmVsLmZyb20oZiwgdmFsID0+IHZhbCA/IGNyZWF0ZUxpbmVEaWFsb2cgOiBudWxsKVxufSk7XG4vKipcbkNvbW1hbmQgdGhhdCBzaG93cyBhIGRpYWxvZyBhc2tpbmcgdGhlIHVzZXIgZm9yIGEgbGluZSBudW1iZXIsIGFuZFxud2hlbiBhIHZhbGlkIHBvc2l0aW9uIGlzIHByb3ZpZGVkLCBtb3ZlcyB0aGUgY3Vyc29yIHRvIHRoYXQgbGluZS5cblxuU3VwcG9ydHMgbGluZSBudW1iZXJzLCByZWxhdGl2ZSBsaW5lIG9mZnNldHMgcHJlZml4ZWQgd2l0aCBgK2Agb3JcbmAtYCwgZG9jdW1lbnQgcGVyY2VudGFnZXMgc3VmZml4ZWQgd2l0aCBgJWAsIGFuZCBhbiBvcHRpb25hbFxuY29sdW1uIHBvc2l0aW9uIGJ5IGFkZGluZyBgOmAgYW5kIGEgc2Vjb25kIG51bWJlciBhZnRlciB0aGUgbGluZVxubnVtYmVyLlxuKi9cbmNvbnN0IGdvdG9MaW5lID0gdmlldyA9PiB7XG4gICAgbGV0IHBhbmVsID0gZ2V0UGFuZWwodmlldywgY3JlYXRlTGluZURpYWxvZyk7XG4gICAgaWYgKCFwYW5lbCkge1xuICAgICAgICBsZXQgZWZmZWN0cyA9IFtkaWFsb2dFZmZlY3Qub2YodHJ1ZSldO1xuICAgICAgICBpZiAodmlldy5zdGF0ZS5maWVsZChkaWFsb2dGaWVsZCwgZmFsc2UpID09IG51bGwpXG4gICAgICAgICAgICBlZmZlY3RzLnB1c2goU3RhdGVFZmZlY3QuYXBwZW5kQ29uZmlnLm9mKFtkaWFsb2dGaWVsZCwgYmFzZVRoZW1lJDFdKSk7XG4gICAgICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzIH0pO1xuICAgICAgICBwYW5lbCA9IGdldFBhbmVsKHZpZXcsIGNyZWF0ZUxpbmVEaWFsb2cpO1xuICAgIH1cbiAgICBpZiAocGFuZWwpXG4gICAgICAgIHBhbmVsLmRvbS5xdWVyeVNlbGVjdG9yKFwiaW5wdXRcIikuc2VsZWN0KCk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuY29uc3QgYmFzZVRoZW1lJDEgPSAvKkBfX1BVUkVfXyovRWRpdG9yVmlldy5iYXNlVGhlbWUoe1xuICAgIFwiLmNtLXBhbmVsLmNtLWdvdG9MaW5lXCI6IHtcbiAgICAgICAgcGFkZGluZzogXCIycHggNnB4IDRweFwiLFxuICAgICAgICBcIiYgbGFiZWxcIjogeyBmb250U2l6ZTogXCI4MCVcIiB9XG4gICAgfVxufSk7XG5cbmNvbnN0IGRlZmF1bHRIaWdobGlnaHRPcHRpb25zID0ge1xuICAgIGhpZ2hsaWdodFdvcmRBcm91bmRDdXJzb3I6IGZhbHNlLFxuICAgIG1pblNlbGVjdGlvbkxlbmd0aDogMSxcbiAgICBtYXhNYXRjaGVzOiAxMDAsXG4gICAgd2hvbGVXb3JkczogZmFsc2Vcbn07XG5jb25zdCBoaWdobGlnaHRDb25maWcgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVDb25maWcob3B0aW9ucywgZGVmYXVsdEhpZ2hsaWdodE9wdGlvbnMsIHtcbiAgICAgICAgICAgIGhpZ2hsaWdodFdvcmRBcm91bmRDdXJzb3I6IChhLCBiKSA9PiBhIHx8IGIsXG4gICAgICAgICAgICBtaW5TZWxlY3Rpb25MZW5ndGg6IE1hdGgubWluLFxuICAgICAgICAgICAgbWF4TWF0Y2hlczogTWF0aC5taW5cbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG4vKipcblRoaXMgZXh0ZW5zaW9uIGhpZ2hsaWdodHMgdGV4dCB0aGF0IG1hdGNoZXMgdGhlIHNlbGVjdGlvbi4gSXQgdXNlc1xudGhlIGBcImNtLXNlbGVjdGlvbk1hdGNoXCJgIGNsYXNzIGZvciB0aGUgaGlnaGxpZ2h0aW5nLiBXaGVuXG5gaGlnaGxpZ2h0V29yZEFyb3VuZEN1cnNvcmAgaXMgZW5hYmxlZCwgdGhlIHdvcmQgYXQgdGhlIGN1cnNvclxuaXRzZWxmIHdpbGwgYmUgaGlnaGxpZ2h0ZWQgd2l0aCBgXCJjbS1zZWxlY3Rpb25NYXRjaC1tYWluXCJgLlxuKi9cbmZ1bmN0aW9uIGhpZ2hsaWdodFNlbGVjdGlvbk1hdGNoZXMob3B0aW9ucykge1xuICAgIGxldCBleHQgPSBbZGVmYXVsdFRoZW1lLCBtYXRjaEhpZ2hsaWdodGVyXTtcbiAgICBpZiAob3B0aW9ucylcbiAgICAgICAgZXh0LnB1c2goaGlnaGxpZ2h0Q29uZmlnLm9mKG9wdGlvbnMpKTtcbiAgICByZXR1cm4gZXh0O1xufVxuY29uc3QgbWF0Y2hEZWNvID0gLypAX19QVVJFX18qL0RlY29yYXRpb24ubWFyayh7IGNsYXNzOiBcImNtLXNlbGVjdGlvbk1hdGNoXCIgfSk7XG5jb25zdCBtYWluTWF0Y2hEZWNvID0gLypAX19QVVJFX18qL0RlY29yYXRpb24ubWFyayh7IGNsYXNzOiBcImNtLXNlbGVjdGlvbk1hdGNoIGNtLXNlbGVjdGlvbk1hdGNoLW1haW5cIiB9KTtcbi8vIFdoZXRoZXIgdGhlIGNoYXJhY3RlcnMgZGlyZWN0bHkgb3V0c2lkZSB0aGUgZ2l2ZW4gcG9zaXRpb25zIGFyZSBub24td29yZCBjaGFyYWN0ZXJzXG5mdW5jdGlvbiBpbnNpZGVXb3JkQm91bmRhcmllcyhjaGVjaywgc3RhdGUsIGZyb20sIHRvKSB7XG4gICAgcmV0dXJuIChmcm9tID09IDAgfHwgY2hlY2soc3RhdGUuc2xpY2VEb2MoZnJvbSAtIDEsIGZyb20pKSAhPSBDaGFyQ2F0ZWdvcnkuV29yZCkgJiZcbiAgICAgICAgKHRvID09IHN0YXRlLmRvYy5sZW5ndGggfHwgY2hlY2soc3RhdGUuc2xpY2VEb2ModG8sIHRvICsgMSkpICE9IENoYXJDYXRlZ29yeS5Xb3JkKTtcbn1cbi8vIFdoZXRoZXIgdGhlIGNoYXJhY3RlcnMgZGlyZWN0bHkgYXQgdGhlIGdpdmVuIHBvc2l0aW9ucyBhcmUgd29yZCBjaGFyYWN0ZXJzXG5mdW5jdGlvbiBpbnNpZGVXb3JkKGNoZWNrLCBzdGF0ZSwgZnJvbSwgdG8pIHtcbiAgICByZXR1cm4gY2hlY2soc3RhdGUuc2xpY2VEb2MoZnJvbSwgZnJvbSArIDEpKSA9PSBDaGFyQ2F0ZWdvcnkuV29yZFxuICAgICAgICAmJiBjaGVjayhzdGF0ZS5zbGljZURvYyh0byAtIDEsIHRvKSkgPT0gQ2hhckNhdGVnb3J5LldvcmQ7XG59XG5jb25zdCBtYXRjaEhpZ2hsaWdodGVyID0gLypAX19QVVJFX18qL1ZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSB0aGlzLmdldERlY28odmlldyk7XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgaWYgKHVwZGF0ZS5zZWxlY3Rpb25TZXQgfHwgdXBkYXRlLmRvY0NoYW5nZWQgfHwgdXBkYXRlLnZpZXdwb3J0Q2hhbmdlZClcbiAgICAgICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSB0aGlzLmdldERlY28odXBkYXRlLnZpZXcpO1xuICAgIH1cbiAgICBnZXREZWNvKHZpZXcpIHtcbiAgICAgICAgbGV0IGNvbmYgPSB2aWV3LnN0YXRlLmZhY2V0KGhpZ2hsaWdodENvbmZpZyk7XG4gICAgICAgIGxldCB7IHN0YXRlIH0gPSB2aWV3LCBzZWwgPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgIGlmIChzZWwucmFuZ2VzLmxlbmd0aCA+IDEpXG4gICAgICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5ub25lO1xuICAgICAgICBsZXQgcmFuZ2UgPSBzZWwubWFpbiwgcXVlcnksIGNoZWNrID0gbnVsbDtcbiAgICAgICAgaWYgKHJhbmdlLmVtcHR5KSB7XG4gICAgICAgICAgICBpZiAoIWNvbmYuaGlnaGxpZ2h0V29yZEFyb3VuZEN1cnNvcilcbiAgICAgICAgICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5ub25lO1xuICAgICAgICAgICAgbGV0IHdvcmQgPSBzdGF0ZS53b3JkQXQocmFuZ2UuaGVhZCk7XG4gICAgICAgICAgICBpZiAoIXdvcmQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIERlY29yYXRpb24ubm9uZTtcbiAgICAgICAgICAgIGNoZWNrID0gc3RhdGUuY2hhckNhdGVnb3JpemVyKHJhbmdlLmhlYWQpO1xuICAgICAgICAgICAgcXVlcnkgPSBzdGF0ZS5zbGljZURvYyh3b3JkLmZyb20sIHdvcmQudG8pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGxlbiA9IHJhbmdlLnRvIC0gcmFuZ2UuZnJvbTtcbiAgICAgICAgICAgIGlmIChsZW4gPCBjb25mLm1pblNlbGVjdGlvbkxlbmd0aCB8fCBsZW4gPiAyMDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIERlY29yYXRpb24ubm9uZTtcbiAgICAgICAgICAgIGlmIChjb25mLndob2xlV29yZHMpIHtcbiAgICAgICAgICAgICAgICBxdWVyeSA9IHN0YXRlLnNsaWNlRG9jKHJhbmdlLmZyb20sIHJhbmdlLnRvKTsgLy8gVE9ETzogYWxsb3cgYW5kIGluY2x1ZGUgbGVhZGluZy90cmFpbGluZyBzcGFjZT9cbiAgICAgICAgICAgICAgICBjaGVjayA9IHN0YXRlLmNoYXJDYXRlZ29yaXplcihyYW5nZS5oZWFkKTtcbiAgICAgICAgICAgICAgICBpZiAoIShpbnNpZGVXb3JkQm91bmRhcmllcyhjaGVjaywgc3RhdGUsIHJhbmdlLmZyb20sIHJhbmdlLnRvKVxuICAgICAgICAgICAgICAgICAgICAmJiBpbnNpZGVXb3JkKGNoZWNrLCBzdGF0ZSwgcmFuZ2UuZnJvbSwgcmFuZ2UudG8pKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIERlY29yYXRpb24ubm9uZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHF1ZXJ5ID0gc3RhdGUuc2xpY2VEb2MocmFuZ2UuZnJvbSwgcmFuZ2UudG8pLnRyaW0oKTtcbiAgICAgICAgICAgICAgICBpZiAoIXF1ZXJ5KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5ub25lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBkZWNvID0gW107XG4gICAgICAgIGZvciAobGV0IHBhcnQgb2Ygdmlldy52aXNpYmxlUmFuZ2VzKSB7XG4gICAgICAgICAgICBsZXQgY3Vyc29yID0gbmV3IFNlYXJjaEN1cnNvcihzdGF0ZS5kb2MsIHF1ZXJ5LCBwYXJ0LmZyb20sIHBhcnQudG8pO1xuICAgICAgICAgICAgd2hpbGUgKCFjdXJzb3IubmV4dCgpLmRvbmUpIHtcbiAgICAgICAgICAgICAgICBsZXQgeyBmcm9tLCB0byB9ID0gY3Vyc29yLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICghY2hlY2sgfHwgaW5zaWRlV29yZEJvdW5kYXJpZXMoY2hlY2ssIHN0YXRlLCBmcm9tLCB0bykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlLmVtcHR5ICYmIGZyb20gPD0gcmFuZ2UuZnJvbSAmJiB0byA+PSByYW5nZS50bylcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlY28ucHVzaChtYWluTWF0Y2hEZWNvLnJhbmdlKGZyb20sIHRvKSk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZyb20gPj0gcmFuZ2UudG8gfHwgdG8gPD0gcmFuZ2UuZnJvbSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlY28ucHVzaChtYXRjaERlY28ucmFuZ2UoZnJvbSwgdG8pKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlY28ubGVuZ3RoID4gY29uZi5tYXhNYXRjaGVzKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIERlY29yYXRpb24ubm9uZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIERlY29yYXRpb24uc2V0KGRlY28pO1xuICAgIH1cbn0sIHtcbiAgICBkZWNvcmF0aW9uczogdiA9PiB2LmRlY29yYXRpb25zXG59KTtcbmNvbnN0IGRlZmF1bHRUaGVtZSA9IC8qQF9fUFVSRV9fKi9FZGl0b3JWaWV3LmJhc2VUaGVtZSh7XG4gICAgXCIuY20tc2VsZWN0aW9uTWF0Y2hcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwiIzk5ZmY3NzgwXCIgfSxcbiAgICBcIi5jbS1zZWFyY2hNYXRjaCAuY20tc2VsZWN0aW9uTWF0Y2hcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwidHJhbnNwYXJlbnRcIiB9XG59KTtcbi8vIFNlbGVjdCB0aGUgd29yZHMgYXJvdW5kIHRoZSBjdXJzb3JzLlxuY29uc3Qgc2VsZWN0V29yZCA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgbGV0IHsgc2VsZWN0aW9uIH0gPSBzdGF0ZTtcbiAgICBsZXQgbmV3U2VsID0gRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShzZWxlY3Rpb24ucmFuZ2VzLm1hcChyYW5nZSA9PiBzdGF0ZS53b3JkQXQocmFuZ2UuaGVhZCkgfHwgRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihyYW5nZS5oZWFkKSksIHNlbGVjdGlvbi5tYWluSW5kZXgpO1xuICAgIGlmIChuZXdTZWwuZXEoc2VsZWN0aW9uKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZSh7IHNlbGVjdGlvbjogbmV3U2VsIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vLyBGaW5kIG5leHQgb2NjdXJyZW5jZSBvZiBxdWVyeSByZWxhdGl2ZSB0byBsYXN0IGN1cnNvci4gV3JhcCBhcm91bmRcbi8vIHRoZSBkb2N1bWVudCBpZiB0aGVyZSBhcmUgbm8gbW9yZSBtYXRjaGVzLlxuZnVuY3Rpb24gZmluZE5leHRPY2N1cnJlbmNlKHN0YXRlLCBxdWVyeSkge1xuICAgIGxldCB7IG1haW4sIHJhbmdlcyB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgIGxldCB3b3JkID0gc3RhdGUud29yZEF0KG1haW4uaGVhZCksIGZ1bGxXb3JkID0gd29yZCAmJiB3b3JkLmZyb20gPT0gbWFpbi5mcm9tICYmIHdvcmQudG8gPT0gbWFpbi50bztcbiAgICBmb3IgKGxldCBjeWNsZWQgPSBmYWxzZSwgY3Vyc29yID0gbmV3IFNlYXJjaEN1cnNvcihzdGF0ZS5kb2MsIHF1ZXJ5LCByYW5nZXNbcmFuZ2VzLmxlbmd0aCAtIDFdLnRvKTs7KSB7XG4gICAgICAgIGN1cnNvci5uZXh0KCk7XG4gICAgICAgIGlmIChjdXJzb3IuZG9uZSkge1xuICAgICAgICAgICAgaWYgKGN5Y2xlZClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGN1cnNvciA9IG5ldyBTZWFyY2hDdXJzb3Ioc3RhdGUuZG9jLCBxdWVyeSwgMCwgTWF0aC5tYXgoMCwgcmFuZ2VzW3Jhbmdlcy5sZW5ndGggLSAxXS5mcm9tIC0gMSkpO1xuICAgICAgICAgICAgY3ljbGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjeWNsZWQgJiYgcmFuZ2VzLnNvbWUociA9PiByLmZyb20gPT0gY3Vyc29yLnZhbHVlLmZyb20pKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKGZ1bGxXb3JkKSB7XG4gICAgICAgICAgICAgICAgbGV0IHdvcmQgPSBzdGF0ZS53b3JkQXQoY3Vyc29yLnZhbHVlLmZyb20pO1xuICAgICAgICAgICAgICAgIGlmICghd29yZCB8fCB3b3JkLmZyb20gIT0gY3Vyc29yLnZhbHVlLmZyb20gfHwgd29yZC50byAhPSBjdXJzb3IudmFsdWUudG8pXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGN1cnNvci52YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuU2VsZWN0IG5leHQgb2NjdXJyZW5jZSBvZiB0aGUgY3VycmVudCBzZWxlY3Rpb24uIEV4cGFuZCBzZWxlY3Rpb25cbnRvIHRoZSBzdXJyb3VuZGluZyB3b3JkIHdoZW4gdGhlIHNlbGVjdGlvbiBpcyBlbXB0eS5cbiovXG5jb25zdCBzZWxlY3ROZXh0T2NjdXJyZW5jZSA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgbGV0IHsgcmFuZ2VzIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgaWYgKHJhbmdlcy5zb21lKHNlbCA9PiBzZWwuZnJvbSA9PT0gc2VsLnRvKSlcbiAgICAgICAgcmV0dXJuIHNlbGVjdFdvcmQoeyBzdGF0ZSwgZGlzcGF0Y2ggfSk7XG4gICAgbGV0IHNlYXJjaGVkVGV4dCA9IHN0YXRlLnNsaWNlRG9jKHJhbmdlc1swXS5mcm9tLCByYW5nZXNbMF0udG8pO1xuICAgIGlmIChzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzLnNvbWUociA9PiBzdGF0ZS5zbGljZURvYyhyLmZyb20sIHIudG8pICE9IHNlYXJjaGVkVGV4dCkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgcmFuZ2UgPSBmaW5kTmV4dE9jY3VycmVuY2Uoc3RhdGUsIHNlYXJjaGVkVGV4dCk7XG4gICAgaWYgKCFyYW5nZSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZSh7XG4gICAgICAgIHNlbGVjdGlvbjogc3RhdGUuc2VsZWN0aW9uLmFkZFJhbmdlKEVkaXRvclNlbGVjdGlvbi5yYW5nZShyYW5nZS5mcm9tLCByYW5nZS50byksIGZhbHNlKSxcbiAgICAgICAgZWZmZWN0czogRWRpdG9yVmlldy5zY3JvbGxJbnRvVmlldyhyYW5nZS50bylcbiAgICB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5jb25zdCBzZWFyY2hDb25maWdGYWNldCA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmUoY29uZmlncykge1xuICAgICAgICByZXR1cm4gY29tYmluZUNvbmZpZyhjb25maWdzLCB7XG4gICAgICAgICAgICB0b3A6IGZhbHNlLFxuICAgICAgICAgICAgY2FzZVNlbnNpdGl2ZTogZmFsc2UsXG4gICAgICAgICAgICBsaXRlcmFsOiBmYWxzZSxcbiAgICAgICAgICAgIHJlZ2V4cDogZmFsc2UsXG4gICAgICAgICAgICB3aG9sZVdvcmQ6IGZhbHNlLFxuICAgICAgICAgICAgY3JlYXRlUGFuZWw6IHZpZXcgPT4gbmV3IFNlYXJjaFBhbmVsKHZpZXcpLFxuICAgICAgICAgICAgc2Nyb2xsVG9NYXRjaDogcmFuZ2UgPT4gRWRpdG9yVmlldy5zY3JvbGxJbnRvVmlldyhyYW5nZSlcbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG4vKipcbkFkZCBzZWFyY2ggc3RhdGUgdG8gdGhlIGVkaXRvciBjb25maWd1cmF0aW9uLCBhbmQgb3B0aW9uYWxseVxuY29uZmlndXJlIHRoZSBzZWFyY2ggZXh0ZW5zaW9uLlxuKFtgb3BlblNlYXJjaFBhbmVsYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzZWFyY2gub3BlblNlYXJjaFBhbmVsKSB3aWxsIGF1dG9tYXRpY2FsbHlcbmVuYWJsZSB0aGlzIGlmIGl0IGlzbid0IGFscmVhZHkgb24pLlxuKi9cbmZ1bmN0aW9uIHNlYXJjaChjb25maWcpIHtcbiAgICByZXR1cm4gY29uZmlnID8gW3NlYXJjaENvbmZpZ0ZhY2V0Lm9mKGNvbmZpZyksIHNlYXJjaEV4dGVuc2lvbnNdIDogc2VhcmNoRXh0ZW5zaW9ucztcbn1cbi8qKlxuQSBzZWFyY2ggcXVlcnkuIFBhcnQgb2YgdGhlIGVkaXRvcidzIHNlYXJjaCBzdGF0ZS5cbiovXG5jbGFzcyBTZWFyY2hRdWVyeSB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgcXVlcnkgb2JqZWN0LlxuICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoID0gY29uZmlnLnNlYXJjaDtcbiAgICAgICAgdGhpcy5jYXNlU2Vuc2l0aXZlID0gISFjb25maWcuY2FzZVNlbnNpdGl2ZTtcbiAgICAgICAgdGhpcy5saXRlcmFsID0gISFjb25maWcubGl0ZXJhbDtcbiAgICAgICAgdGhpcy5yZWdleHAgPSAhIWNvbmZpZy5yZWdleHA7XG4gICAgICAgIHRoaXMucmVwbGFjZSA9IGNvbmZpZy5yZXBsYWNlIHx8IFwiXCI7XG4gICAgICAgIHRoaXMudmFsaWQgPSAhIXRoaXMuc2VhcmNoICYmICghdGhpcy5yZWdleHAgfHwgdmFsaWRSZWdFeHAodGhpcy5zZWFyY2gpKTtcbiAgICAgICAgdGhpcy51bnF1b3RlZCA9IHRoaXMudW5xdW90ZSh0aGlzLnNlYXJjaCk7XG4gICAgICAgIHRoaXMud2hvbGVXb3JkID0gISFjb25maWcud2hvbGVXb3JkO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHVucXVvdGUodGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5saXRlcmFsID8gdGV4dCA6XG4gICAgICAgICAgICB0ZXh0LnJlcGxhY2UoL1xcXFwoW25ydFxcXFxdKS9nLCAoXywgY2gpID0+IGNoID09IFwiblwiID8gXCJcXG5cIiA6IGNoID09IFwiclwiID8gXCJcXHJcIiA6IGNoID09IFwidFwiID8gXCJcXHRcIiA6IFwiXFxcXFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29tcGFyZSB0aGlzIHF1ZXJ5IHRvIGFub3RoZXIgcXVlcnkuXG4gICAgKi9cbiAgICBlcShvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWFyY2ggPT0gb3RoZXIuc2VhcmNoICYmIHRoaXMucmVwbGFjZSA9PSBvdGhlci5yZXBsYWNlICYmXG4gICAgICAgICAgICB0aGlzLmNhc2VTZW5zaXRpdmUgPT0gb3RoZXIuY2FzZVNlbnNpdGl2ZSAmJiB0aGlzLnJlZ2V4cCA9PSBvdGhlci5yZWdleHAgJiZcbiAgICAgICAgICAgIHRoaXMud2hvbGVXb3JkID09IG90aGVyLndob2xlV29yZDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjcmVhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZ2V4cCA/IG5ldyBSZWdFeHBRdWVyeSh0aGlzKSA6IG5ldyBTdHJpbmdRdWVyeSh0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IGEgc2VhcmNoIGN1cnNvciBmb3IgdGhpcyBxdWVyeSwgc2VhcmNoaW5nIHRocm91Z2ggdGhlIGdpdmVuXG4gICAgcmFuZ2UgaW4gdGhlIGdpdmVuIHN0YXRlLlxuICAgICovXG4gICAgZ2V0Q3Vyc29yKHN0YXRlLCBmcm9tID0gMCwgdG8pIHtcbiAgICAgICAgbGV0IHN0ID0gc3RhdGUuZG9jID8gc3RhdGUgOiBFZGl0b3JTdGF0ZS5jcmVhdGUoeyBkb2M6IHN0YXRlIH0pO1xuICAgICAgICBpZiAodG8gPT0gbnVsbClcbiAgICAgICAgICAgIHRvID0gc3QuZG9jLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVnZXhwID8gcmVnZXhwQ3Vyc29yKHRoaXMsIHN0LCBmcm9tLCB0bykgOiBzdHJpbmdDdXJzb3IodGhpcywgc3QsIGZyb20sIHRvKTtcbiAgICB9XG59XG5jbGFzcyBRdWVyeVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKHNwZWMpIHtcbiAgICAgICAgdGhpcy5zcGVjID0gc3BlYztcbiAgICB9XG59XG5mdW5jdGlvbiBzdHJpbmdDdXJzb3Ioc3BlYywgc3RhdGUsIGZyb20sIHRvKSB7XG4gICAgcmV0dXJuIG5ldyBTZWFyY2hDdXJzb3Ioc3RhdGUuZG9jLCBzcGVjLnVucXVvdGVkLCBmcm9tLCB0bywgc3BlYy5jYXNlU2Vuc2l0aXZlID8gdW5kZWZpbmVkIDogeCA9PiB4LnRvTG93ZXJDYXNlKCksIHNwZWMud2hvbGVXb3JkID8gc3RyaW5nV29yZFRlc3Qoc3RhdGUuZG9jLCBzdGF0ZS5jaGFyQ2F0ZWdvcml6ZXIoc3RhdGUuc2VsZWN0aW9uLm1haW4uaGVhZCkpIDogdW5kZWZpbmVkKTtcbn1cbmZ1bmN0aW9uIHN0cmluZ1dvcmRUZXN0KGRvYywgY2F0ZWdvcml6ZXIpIHtcbiAgICByZXR1cm4gKGZyb20sIHRvLCBidWYsIGJ1ZlBvcykgPT4ge1xuICAgICAgICBpZiAoYnVmUG9zID4gZnJvbSB8fCBidWZQb3MgKyBidWYubGVuZ3RoIDwgdG8pIHtcbiAgICAgICAgICAgIGJ1ZlBvcyA9IE1hdGgubWF4KDAsIGZyb20gLSAyKTtcbiAgICAgICAgICAgIGJ1ZiA9IGRvYy5zbGljZVN0cmluZyhidWZQb3MsIE1hdGgubWluKGRvYy5sZW5ndGgsIHRvICsgMikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoY2F0ZWdvcml6ZXIoY2hhckJlZm9yZShidWYsIGZyb20gLSBidWZQb3MpKSAhPSBDaGFyQ2F0ZWdvcnkuV29yZCB8fFxuICAgICAgICAgICAgY2F0ZWdvcml6ZXIoY2hhckFmdGVyKGJ1ZiwgZnJvbSAtIGJ1ZlBvcykpICE9IENoYXJDYXRlZ29yeS5Xb3JkKSAmJlxuICAgICAgICAgICAgKGNhdGVnb3JpemVyKGNoYXJBZnRlcihidWYsIHRvIC0gYnVmUG9zKSkgIT0gQ2hhckNhdGVnb3J5LldvcmQgfHxcbiAgICAgICAgICAgICAgICBjYXRlZ29yaXplcihjaGFyQmVmb3JlKGJ1ZiwgdG8gLSBidWZQb3MpKSAhPSBDaGFyQ2F0ZWdvcnkuV29yZCk7XG4gICAgfTtcbn1cbmNsYXNzIFN0cmluZ1F1ZXJ5IGV4dGVuZHMgUXVlcnlUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcihzcGVjKSB7XG4gICAgICAgIHN1cGVyKHNwZWMpO1xuICAgIH1cbiAgICBuZXh0TWF0Y2goc3RhdGUsIGN1ckZyb20sIGN1clRvKSB7XG4gICAgICAgIGxldCBjdXJzb3IgPSBzdHJpbmdDdXJzb3IodGhpcy5zcGVjLCBzdGF0ZSwgY3VyVG8sIHN0YXRlLmRvYy5sZW5ndGgpLm5leHRPdmVybGFwcGluZygpO1xuICAgICAgICBpZiAoY3Vyc29yLmRvbmUpXG4gICAgICAgICAgICBjdXJzb3IgPSBzdHJpbmdDdXJzb3IodGhpcy5zcGVjLCBzdGF0ZSwgMCwgY3VyRnJvbSkubmV4dE92ZXJsYXBwaW5nKCk7XG4gICAgICAgIHJldHVybiBjdXJzb3IuZG9uZSA/IG51bGwgOiBjdXJzb3IudmFsdWU7XG4gICAgfVxuICAgIC8vIFNlYXJjaGluZyBpbiByZXZlcnNlIGlzLCByYXRoZXIgdGhhbiBpbXBsZW1lbnRpbmcgYW4gaW52ZXJ0ZWQgc2VhcmNoXG4gICAgLy8gY3Vyc29yLCBkb25lIGJ5IHNjYW5uaW5nIGNodW5rIGFmdGVyIGNodW5rIGZvcndhcmQuXG4gICAgcHJldk1hdGNoSW5SYW5nZShzdGF0ZSwgZnJvbSwgdG8pIHtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gdG87Oykge1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gTWF0aC5tYXgoZnJvbSwgcG9zIC0gMTAwMDAgLyogRmluZFByZXYuQ2h1bmtTaXplICovIC0gdGhpcy5zcGVjLnVucXVvdGVkLmxlbmd0aCk7XG4gICAgICAgICAgICBsZXQgY3Vyc29yID0gc3RyaW5nQ3Vyc29yKHRoaXMuc3BlYywgc3RhdGUsIHN0YXJ0LCBwb3MpLCByYW5nZSA9IG51bGw7XG4gICAgICAgICAgICB3aGlsZSAoIWN1cnNvci5uZXh0T3ZlcmxhcHBpbmcoKS5kb25lKVxuICAgICAgICAgICAgICAgIHJhbmdlID0gY3Vyc29yLnZhbHVlO1xuICAgICAgICAgICAgaWYgKHJhbmdlKVxuICAgICAgICAgICAgICAgIHJldHVybiByYW5nZTtcbiAgICAgICAgICAgIGlmIChzdGFydCA9PSBmcm9tKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgcG9zIC09IDEwMDAwIC8qIEZpbmRQcmV2LkNodW5rU2l6ZSAqLztcbiAgICAgICAgfVxuICAgIH1cbiAgICBwcmV2TWF0Y2goc3RhdGUsIGN1ckZyb20sIGN1clRvKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByZXZNYXRjaEluUmFuZ2Uoc3RhdGUsIDAsIGN1ckZyb20pIHx8XG4gICAgICAgICAgICB0aGlzLnByZXZNYXRjaEluUmFuZ2Uoc3RhdGUsIGN1clRvLCBzdGF0ZS5kb2MubGVuZ3RoKTtcbiAgICB9XG4gICAgZ2V0UmVwbGFjZW1lbnQoX3Jlc3VsdCkgeyByZXR1cm4gdGhpcy5zcGVjLnVucXVvdGUodGhpcy5zcGVjLnJlcGxhY2UpOyB9XG4gICAgbWF0Y2hBbGwoc3RhdGUsIGxpbWl0KSB7XG4gICAgICAgIGxldCBjdXJzb3IgPSBzdHJpbmdDdXJzb3IodGhpcy5zcGVjLCBzdGF0ZSwgMCwgc3RhdGUuZG9jLmxlbmd0aCksIHJhbmdlcyA9IFtdO1xuICAgICAgICB3aGlsZSAoIWN1cnNvci5uZXh0KCkuZG9uZSkge1xuICAgICAgICAgICAgaWYgKHJhbmdlcy5sZW5ndGggPj0gbGltaXQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICByYW5nZXMucHVzaChjdXJzb3IudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByYW5nZXM7XG4gICAgfVxuICAgIGhpZ2hsaWdodChzdGF0ZSwgZnJvbSwgdG8sIGFkZCkge1xuICAgICAgICBsZXQgY3Vyc29yID0gc3RyaW5nQ3Vyc29yKHRoaXMuc3BlYywgc3RhdGUsIE1hdGgubWF4KDAsIGZyb20gLSB0aGlzLnNwZWMudW5xdW90ZWQubGVuZ3RoKSwgTWF0aC5taW4odG8gKyB0aGlzLnNwZWMudW5xdW90ZWQubGVuZ3RoLCBzdGF0ZS5kb2MubGVuZ3RoKSk7XG4gICAgICAgIHdoaWxlICghY3Vyc29yLm5leHQoKS5kb25lKVxuICAgICAgICAgICAgYWRkKGN1cnNvci52YWx1ZS5mcm9tLCBjdXJzb3IudmFsdWUudG8pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlZ2V4cEN1cnNvcihzcGVjLCBzdGF0ZSwgZnJvbSwgdG8pIHtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cEN1cnNvcihzdGF0ZS5kb2MsIHNwZWMuc2VhcmNoLCB7XG4gICAgICAgIGlnbm9yZUNhc2U6ICFzcGVjLmNhc2VTZW5zaXRpdmUsXG4gICAgICAgIHRlc3Q6IHNwZWMud2hvbGVXb3JkID8gcmVnZXhwV29yZFRlc3Qoc3RhdGUuY2hhckNhdGVnb3JpemVyKHN0YXRlLnNlbGVjdGlvbi5tYWluLmhlYWQpKSA6IHVuZGVmaW5lZFxuICAgIH0sIGZyb20sIHRvKTtcbn1cbmZ1bmN0aW9uIGNoYXJCZWZvcmUoc3RyLCBpbmRleCkge1xuICAgIHJldHVybiBzdHIuc2xpY2UoZmluZENsdXN0ZXJCcmVhayhzdHIsIGluZGV4LCBmYWxzZSksIGluZGV4KTtcbn1cbmZ1bmN0aW9uIGNoYXJBZnRlcihzdHIsIGluZGV4KSB7XG4gICAgcmV0dXJuIHN0ci5zbGljZShpbmRleCwgZmluZENsdXN0ZXJCcmVhayhzdHIsIGluZGV4KSk7XG59XG5mdW5jdGlvbiByZWdleHBXb3JkVGVzdChjYXRlZ29yaXplcikge1xuICAgIHJldHVybiAoX2Zyb20sIF90bywgbWF0Y2gpID0+ICFtYXRjaFswXS5sZW5ndGggfHxcbiAgICAgICAgKGNhdGVnb3JpemVyKGNoYXJCZWZvcmUobWF0Y2guaW5wdXQsIG1hdGNoLmluZGV4KSkgIT0gQ2hhckNhdGVnb3J5LldvcmQgfHxcbiAgICAgICAgICAgIGNhdGVnb3JpemVyKGNoYXJBZnRlcihtYXRjaC5pbnB1dCwgbWF0Y2guaW5kZXgpKSAhPSBDaGFyQ2F0ZWdvcnkuV29yZCkgJiZcbiAgICAgICAgICAgIChjYXRlZ29yaXplcihjaGFyQWZ0ZXIobWF0Y2guaW5wdXQsIG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoKSkgIT0gQ2hhckNhdGVnb3J5LldvcmQgfHxcbiAgICAgICAgICAgICAgICBjYXRlZ29yaXplcihjaGFyQmVmb3JlKG1hdGNoLmlucHV0LCBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCkpICE9IENoYXJDYXRlZ29yeS5Xb3JkKTtcbn1cbmNsYXNzIFJlZ0V4cFF1ZXJ5IGV4dGVuZHMgUXVlcnlUeXBlIHtcbiAgICBuZXh0TWF0Y2goc3RhdGUsIGN1ckZyb20sIGN1clRvKSB7XG4gICAgICAgIGxldCBjdXJzb3IgPSByZWdleHBDdXJzb3IodGhpcy5zcGVjLCBzdGF0ZSwgY3VyVG8sIHN0YXRlLmRvYy5sZW5ndGgpLm5leHQoKTtcbiAgICAgICAgaWYgKGN1cnNvci5kb25lKVxuICAgICAgICAgICAgY3Vyc29yID0gcmVnZXhwQ3Vyc29yKHRoaXMuc3BlYywgc3RhdGUsIDAsIGN1ckZyb20pLm5leHQoKTtcbiAgICAgICAgcmV0dXJuIGN1cnNvci5kb25lID8gbnVsbCA6IGN1cnNvci52YWx1ZTtcbiAgICB9XG4gICAgcHJldk1hdGNoSW5SYW5nZShzdGF0ZSwgZnJvbSwgdG8pIHtcbiAgICAgICAgZm9yIChsZXQgc2l6ZSA9IDE7OyBzaXplKyspIHtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IE1hdGgubWF4KGZyb20sIHRvIC0gc2l6ZSAqIDEwMDAwIC8qIEZpbmRQcmV2LkNodW5rU2l6ZSAqLyk7XG4gICAgICAgICAgICBsZXQgY3Vyc29yID0gcmVnZXhwQ3Vyc29yKHRoaXMuc3BlYywgc3RhdGUsIHN0YXJ0LCB0byksIHJhbmdlID0gbnVsbDtcbiAgICAgICAgICAgIHdoaWxlICghY3Vyc29yLm5leHQoKS5kb25lKVxuICAgICAgICAgICAgICAgIHJhbmdlID0gY3Vyc29yLnZhbHVlO1xuICAgICAgICAgICAgaWYgKHJhbmdlICYmIChzdGFydCA9PSBmcm9tIHx8IHJhbmdlLmZyb20gPiBzdGFydCArIDEwKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgICAgICAgICBpZiAoc3RhcnQgPT0gZnJvbSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwcmV2TWF0Y2goc3RhdGUsIGN1ckZyb20sIGN1clRvKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByZXZNYXRjaEluUmFuZ2Uoc3RhdGUsIDAsIGN1ckZyb20pIHx8XG4gICAgICAgICAgICB0aGlzLnByZXZNYXRjaEluUmFuZ2Uoc3RhdGUsIGN1clRvLCBzdGF0ZS5kb2MubGVuZ3RoKTtcbiAgICB9XG4gICAgZ2V0UmVwbGFjZW1lbnQocmVzdWx0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNwZWMudW5xdW90ZSh0aGlzLnNwZWMucmVwbGFjZSkucmVwbGFjZSgvXFwkKFskJlxcZCtdKS9nLCAobSwgaSkgPT4gaSA9PSBcIiRcIiA/IFwiJFwiXG4gICAgICAgICAgICA6IGkgPT0gXCImXCIgPyByZXN1bHQubWF0Y2hbMF1cbiAgICAgICAgICAgICAgICA6IGkgIT0gXCIwXCIgJiYgK2kgPCByZXN1bHQubWF0Y2gubGVuZ3RoID8gcmVzdWx0Lm1hdGNoW2ldXG4gICAgICAgICAgICAgICAgICAgIDogbSk7XG4gICAgfVxuICAgIG1hdGNoQWxsKHN0YXRlLCBsaW1pdCkge1xuICAgICAgICBsZXQgY3Vyc29yID0gcmVnZXhwQ3Vyc29yKHRoaXMuc3BlYywgc3RhdGUsIDAsIHN0YXRlLmRvYy5sZW5ndGgpLCByYW5nZXMgPSBbXTtcbiAgICAgICAgd2hpbGUgKCFjdXJzb3IubmV4dCgpLmRvbmUpIHtcbiAgICAgICAgICAgIGlmIChyYW5nZXMubGVuZ3RoID49IGxpbWl0KVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgcmFuZ2VzLnB1c2goY3Vyc29yLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmFuZ2VzO1xuICAgIH1cbiAgICBoaWdobGlnaHQoc3RhdGUsIGZyb20sIHRvLCBhZGQpIHtcbiAgICAgICAgbGV0IGN1cnNvciA9IHJlZ2V4cEN1cnNvcih0aGlzLnNwZWMsIHN0YXRlLCBNYXRoLm1heCgwLCBmcm9tIC0gMjUwIC8qIFJlZ0V4cC5IaWdobGlnaHRNYXJnaW4gKi8pLCBNYXRoLm1pbih0byArIDI1MCAvKiBSZWdFeHAuSGlnaGxpZ2h0TWFyZ2luICovLCBzdGF0ZS5kb2MubGVuZ3RoKSk7XG4gICAgICAgIHdoaWxlICghY3Vyc29yLm5leHQoKS5kb25lKVxuICAgICAgICAgICAgYWRkKGN1cnNvci52YWx1ZS5mcm9tLCBjdXJzb3IudmFsdWUudG8pO1xuICAgIH1cbn1cbi8qKlxuQSBzdGF0ZSBlZmZlY3QgdGhhdCB1cGRhdGVzIHRoZSBjdXJyZW50IHNlYXJjaCBxdWVyeS4gTm90ZSB0aGF0XG50aGlzIG9ubHkgaGFzIGFuIGVmZmVjdCBpZiB0aGUgc2VhcmNoIHN0YXRlIGhhcyBiZWVuIGluaXRpYWxpemVkXG4oYnkgaW5jbHVkaW5nIFtgc2VhcmNoYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzZWFyY2guc2VhcmNoKSBpbiB5b3VyIGNvbmZpZ3VyYXRpb24gb3JcbmJ5IHJ1bm5pbmcgW2BvcGVuU2VhcmNoUGFuZWxgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3NlYXJjaC5vcGVuU2VhcmNoUGFuZWwpIGF0IGxlYXN0XG5vbmNlKS5cbiovXG5jb25zdCBzZXRTZWFyY2hRdWVyeSA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcbmNvbnN0IHRvZ2dsZVBhbmVsID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSgpO1xuY29uc3Qgc2VhcmNoU3RhdGUgPSAvKkBfX1BVUkVfXyovU3RhdGVGaWVsZC5kZWZpbmUoe1xuICAgIGNyZWF0ZShzdGF0ZSkge1xuICAgICAgICByZXR1cm4gbmV3IFNlYXJjaFN0YXRlKGRlZmF1bHRRdWVyeShzdGF0ZSkuY3JlYXRlKCksIG51bGwpO1xuICAgIH0sXG4gICAgdXBkYXRlKHZhbHVlLCB0cikge1xuICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgdHIuZWZmZWN0cykge1xuICAgICAgICAgICAgaWYgKGVmZmVjdC5pcyhzZXRTZWFyY2hRdWVyeSkpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBuZXcgU2VhcmNoU3RhdGUoZWZmZWN0LnZhbHVlLmNyZWF0ZSgpLCB2YWx1ZS5wYW5lbCk7XG4gICAgICAgICAgICBlbHNlIGlmIChlZmZlY3QuaXModG9nZ2xlUGFuZWwpKVxuICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3IFNlYXJjaFN0YXRlKHZhbHVlLnF1ZXJ5LCBlZmZlY3QudmFsdWUgPyBjcmVhdGVTZWFyY2hQYW5lbCA6IG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIHByb3ZpZGU6IGYgPT4gc2hvd1BhbmVsLmZyb20oZiwgdmFsID0+IHZhbC5wYW5lbClcbn0pO1xuLyoqXG5HZXQgdGhlIGN1cnJlbnQgc2VhcmNoIHF1ZXJ5IGZyb20gYW4gZWRpdG9yIHN0YXRlLlxuKi9cbmZ1bmN0aW9uIGdldFNlYXJjaFF1ZXJ5KHN0YXRlKSB7XG4gICAgbGV0IGN1clN0YXRlID0gc3RhdGUuZmllbGQoc2VhcmNoU3RhdGUsIGZhbHNlKTtcbiAgICByZXR1cm4gY3VyU3RhdGUgPyBjdXJTdGF0ZS5xdWVyeS5zcGVjIDogZGVmYXVsdFF1ZXJ5KHN0YXRlKTtcbn1cbi8qKlxuUXVlcnkgd2hldGhlciB0aGUgc2VhcmNoIHBhbmVsIGlzIG9wZW4gaW4gdGhlIGdpdmVuIGVkaXRvciBzdGF0ZS5cbiovXG5mdW5jdGlvbiBzZWFyY2hQYW5lbE9wZW4oc3RhdGUpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuICgoX2EgPSBzdGF0ZS5maWVsZChzZWFyY2hTdGF0ZSwgZmFsc2UpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucGFuZWwpICE9IG51bGw7XG59XG5jbGFzcyBTZWFyY2hTdGF0ZSB7XG4gICAgY29uc3RydWN0b3IocXVlcnksIHBhbmVsKSB7XG4gICAgICAgIHRoaXMucXVlcnkgPSBxdWVyeTtcbiAgICAgICAgdGhpcy5wYW5lbCA9IHBhbmVsO1xuICAgIH1cbn1cbmNvbnN0IG1hdGNoTWFyayA9IC8qQF9fUFVSRV9fKi9EZWNvcmF0aW9uLm1hcmsoeyBjbGFzczogXCJjbS1zZWFyY2hNYXRjaFwiIH0pLCBzZWxlY3RlZE1hdGNoTWFyayA9IC8qQF9fUFVSRV9fKi9EZWNvcmF0aW9uLm1hcmsoeyBjbGFzczogXCJjbS1zZWFyY2hNYXRjaCBjbS1zZWFyY2hNYXRjaC1zZWxlY3RlZFwiIH0pO1xuY29uc3Qgc2VhcmNoSGlnaGxpZ2h0ZXIgPSAvKkBfX1BVUkVfXyovVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuaGlnaGxpZ2h0KHZpZXcuc3RhdGUuZmllbGQoc2VhcmNoU3RhdGUpKTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBsZXQgc3RhdGUgPSB1cGRhdGUuc3RhdGUuZmllbGQoc2VhcmNoU3RhdGUpO1xuICAgICAgICBpZiAoc3RhdGUgIT0gdXBkYXRlLnN0YXJ0U3RhdGUuZmllbGQoc2VhcmNoU3RhdGUpIHx8IHVwZGF0ZS5kb2NDaGFuZ2VkIHx8IHVwZGF0ZS5zZWxlY3Rpb25TZXQgfHwgdXBkYXRlLnZpZXdwb3J0Q2hhbmdlZClcbiAgICAgICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSB0aGlzLmhpZ2hsaWdodChzdGF0ZSk7XG4gICAgfVxuICAgIGhpZ2hsaWdodCh7IHF1ZXJ5LCBwYW5lbCB9KSB7XG4gICAgICAgIGlmICghcGFuZWwgfHwgIXF1ZXJ5LnNwZWMudmFsaWQpXG4gICAgICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5ub25lO1xuICAgICAgICBsZXQgeyB2aWV3IH0gPSB0aGlzO1xuICAgICAgICBsZXQgYnVpbGRlciA9IG5ldyBSYW5nZVNldEJ1aWxkZXIoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIHJhbmdlcyA9IHZpZXcudmlzaWJsZVJhbmdlcywgbCA9IHJhbmdlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB7IGZyb20sIHRvIH0gPSByYW5nZXNbaV07XG4gICAgICAgICAgICB3aGlsZSAoaSA8IGwgLSAxICYmIHRvID4gcmFuZ2VzW2kgKyAxXS5mcm9tIC0gMiAqIDI1MCAvKiBSZWdFeHAuSGlnaGxpZ2h0TWFyZ2luICovKVxuICAgICAgICAgICAgICAgIHRvID0gcmFuZ2VzWysraV0udG87XG4gICAgICAgICAgICBxdWVyeS5oaWdobGlnaHQodmlldy5zdGF0ZSwgZnJvbSwgdG8sIChmcm9tLCB0bykgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBzZWxlY3RlZCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLnJhbmdlcy5zb21lKHIgPT4gci5mcm9tID09IGZyb20gJiYgci50byA9PSB0byk7XG4gICAgICAgICAgICAgICAgYnVpbGRlci5hZGQoZnJvbSwgdG8sIHNlbGVjdGVkID8gc2VsZWN0ZWRNYXRjaE1hcmsgOiBtYXRjaE1hcmspO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1aWxkZXIuZmluaXNoKCk7XG4gICAgfVxufSwge1xuICAgIGRlY29yYXRpb25zOiB2ID0+IHYuZGVjb3JhdGlvbnNcbn0pO1xuZnVuY3Rpb24gc2VhcmNoQ29tbWFuZChmKSB7XG4gICAgcmV0dXJuIHZpZXcgPT4ge1xuICAgICAgICBsZXQgc3RhdGUgPSB2aWV3LnN0YXRlLmZpZWxkKHNlYXJjaFN0YXRlLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiBzdGF0ZSAmJiBzdGF0ZS5xdWVyeS5zcGVjLnZhbGlkID8gZih2aWV3LCBzdGF0ZSkgOiBvcGVuU2VhcmNoUGFuZWwodmlldyk7XG4gICAgfTtcbn1cbi8qKlxuT3BlbiB0aGUgc2VhcmNoIHBhbmVsIGlmIGl0IGlzbid0IGFscmVhZHkgb3BlbiwgYW5kIG1vdmUgdGhlXG5zZWxlY3Rpb24gdG8gdGhlIGZpcnN0IG1hdGNoIGFmdGVyIHRoZSBjdXJyZW50IG1haW4gc2VsZWN0aW9uLlxuV2lsbCB3cmFwIGFyb3VuZCB0byB0aGUgc3RhcnQgb2YgdGhlIGRvY3VtZW50IHdoZW4gaXQgcmVhY2hlcyB0aGVcbmVuZC5cbiovXG5jb25zdCBmaW5kTmV4dCA9IC8qQF9fUFVSRV9fKi9zZWFyY2hDb21tYW5kKCh2aWV3LCB7IHF1ZXJ5IH0pID0+IHtcbiAgICBsZXQgeyB0byB9ID0gdmlldy5zdGF0ZS5zZWxlY3Rpb24ubWFpbjtcbiAgICBsZXQgbmV4dCA9IHF1ZXJ5Lm5leHRNYXRjaCh2aWV3LnN0YXRlLCB0bywgdG8pO1xuICAgIGlmICghbmV4dClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBzZWxlY3Rpb24gPSBFZGl0b3JTZWxlY3Rpb24uc2luZ2xlKG5leHQuZnJvbSwgbmV4dC50byk7XG4gICAgbGV0IGNvbmZpZyA9IHZpZXcuc3RhdGUuZmFjZXQoc2VhcmNoQ29uZmlnRmFjZXQpO1xuICAgIHZpZXcuZGlzcGF0Y2goe1xuICAgICAgICBzZWxlY3Rpb24sXG4gICAgICAgIGVmZmVjdHM6IFthbm5vdW5jZU1hdGNoKHZpZXcsIG5leHQpLCBjb25maWcuc2Nyb2xsVG9NYXRjaChzZWxlY3Rpb24ubWFpbiwgdmlldyldLFxuICAgICAgICB1c2VyRXZlbnQ6IFwic2VsZWN0LnNlYXJjaFwiXG4gICAgfSk7XG4gICAgc2VsZWN0U2VhcmNoSW5wdXQodmlldyk7XG4gICAgcmV0dXJuIHRydWU7XG59KTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIHRvIHRoZSBwcmV2aW91cyBpbnN0YW5jZSBvZiB0aGUgc2VhcmNoIHF1ZXJ5LFxuYmVmb3JlIHRoZSBjdXJyZW50IG1haW4gc2VsZWN0aW9uLiBXaWxsIHdyYXAgcGFzdCB0aGUgc3RhcnRcbm9mIHRoZSBkb2N1bWVudCB0byBzdGFydCBzZWFyY2hpbmcgYXQgdGhlIGVuZCBhZ2Fpbi5cbiovXG5jb25zdCBmaW5kUHJldmlvdXMgPSAvKkBfX1BVUkVfXyovc2VhcmNoQ29tbWFuZCgodmlldywgeyBxdWVyeSB9KSA9PiB7XG4gICAgbGV0IHsgc3RhdGUgfSA9IHZpZXcsIHsgZnJvbSB9ID0gc3RhdGUuc2VsZWN0aW9uLm1haW47XG4gICAgbGV0IHByZXYgPSBxdWVyeS5wcmV2TWF0Y2goc3RhdGUsIGZyb20sIGZyb20pO1xuICAgIGlmICghcHJldilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBzZWxlY3Rpb24gPSBFZGl0b3JTZWxlY3Rpb24uc2luZ2xlKHByZXYuZnJvbSwgcHJldi50byk7XG4gICAgbGV0IGNvbmZpZyA9IHZpZXcuc3RhdGUuZmFjZXQoc2VhcmNoQ29uZmlnRmFjZXQpO1xuICAgIHZpZXcuZGlzcGF0Y2goe1xuICAgICAgICBzZWxlY3Rpb24sXG4gICAgICAgIGVmZmVjdHM6IFthbm5vdW5jZU1hdGNoKHZpZXcsIHByZXYpLCBjb25maWcuc2Nyb2xsVG9NYXRjaChzZWxlY3Rpb24ubWFpbiwgdmlldyldLFxuICAgICAgICB1c2VyRXZlbnQ6IFwic2VsZWN0LnNlYXJjaFwiXG4gICAgfSk7XG4gICAgc2VsZWN0U2VhcmNoSW5wdXQodmlldyk7XG4gICAgcmV0dXJuIHRydWU7XG59KTtcbi8qKlxuU2VsZWN0IGFsbCBpbnN0YW5jZXMgb2YgdGhlIHNlYXJjaCBxdWVyeS5cbiovXG5jb25zdCBzZWxlY3RNYXRjaGVzID0gLypAX19QVVJFX18qL3NlYXJjaENvbW1hbmQoKHZpZXcsIHsgcXVlcnkgfSkgPT4ge1xuICAgIGxldCByYW5nZXMgPSBxdWVyeS5tYXRjaEFsbCh2aWV3LnN0YXRlLCAxMDAwKTtcbiAgICBpZiAoIXJhbmdlcyB8fCAhcmFuZ2VzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHZpZXcuZGlzcGF0Y2goe1xuICAgICAgICBzZWxlY3Rpb246IEVkaXRvclNlbGVjdGlvbi5jcmVhdGUocmFuZ2VzLm1hcChyID0+IEVkaXRvclNlbGVjdGlvbi5yYW5nZShyLmZyb20sIHIudG8pKSksXG4gICAgICAgIHVzZXJFdmVudDogXCJzZWxlY3Quc2VhcmNoLm1hdGNoZXNcIlxuICAgIH0pO1xuICAgIHJldHVybiB0cnVlO1xufSk7XG4vKipcblNlbGVjdCBhbGwgaW5zdGFuY2VzIG9mIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgdGV4dC5cbiovXG5jb25zdCBzZWxlY3RTZWxlY3Rpb25NYXRjaGVzID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBsZXQgc2VsID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgIGlmIChzZWwucmFuZ2VzLmxlbmd0aCA+IDEgfHwgc2VsLm1haW4uZW1wdHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgeyBmcm9tLCB0byB9ID0gc2VsLm1haW47XG4gICAgbGV0IHJhbmdlcyA9IFtdLCBtYWluID0gMDtcbiAgICBmb3IgKGxldCBjdXIgPSBuZXcgU2VhcmNoQ3Vyc29yKHN0YXRlLmRvYywgc3RhdGUuc2xpY2VEb2MoZnJvbSwgdG8pKTsgIWN1ci5uZXh0KCkuZG9uZTspIHtcbiAgICAgICAgaWYgKHJhbmdlcy5sZW5ndGggPiAxMDAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoY3VyLnZhbHVlLmZyb20gPT0gZnJvbSlcbiAgICAgICAgICAgIG1haW4gPSByYW5nZXMubGVuZ3RoO1xuICAgICAgICByYW5nZXMucHVzaChFZGl0b3JTZWxlY3Rpb24ucmFuZ2UoY3VyLnZhbHVlLmZyb20sIGN1ci52YWx1ZS50bykpO1xuICAgIH1cbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoe1xuICAgICAgICBzZWxlY3Rpb246IEVkaXRvclNlbGVjdGlvbi5jcmVhdGUocmFuZ2VzLCBtYWluKSxcbiAgICAgICAgdXNlckV2ZW50OiBcInNlbGVjdC5zZWFyY2gubWF0Y2hlc1wiXG4gICAgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuUmVwbGFjZSB0aGUgY3VycmVudCBtYXRjaCBvZiB0aGUgc2VhcmNoIHF1ZXJ5LlxuKi9cbmNvbnN0IHJlcGxhY2VOZXh0ID0gLypAX19QVVJFX18qL3NlYXJjaENvbW1hbmQoKHZpZXcsIHsgcXVlcnkgfSkgPT4ge1xuICAgIGxldCB7IHN0YXRlIH0gPSB2aWV3LCB7IGZyb20sIHRvIH0gPSBzdGF0ZS5zZWxlY3Rpb24ubWFpbjtcbiAgICBpZiAoc3RhdGUucmVhZE9ubHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgbmV4dCA9IHF1ZXJ5Lm5leHRNYXRjaChzdGF0ZSwgZnJvbSwgZnJvbSk7XG4gICAgaWYgKCFuZXh0KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGNoYW5nZXMgPSBbXSwgc2VsZWN0aW9uLCByZXBsYWNlbWVudDtcbiAgICBsZXQgZWZmZWN0cyA9IFtdO1xuICAgIGlmIChuZXh0LmZyb20gPT0gZnJvbSAmJiBuZXh0LnRvID09IHRvKSB7XG4gICAgICAgIHJlcGxhY2VtZW50ID0gc3RhdGUudG9UZXh0KHF1ZXJ5LmdldFJlcGxhY2VtZW50KG5leHQpKTtcbiAgICAgICAgY2hhbmdlcy5wdXNoKHsgZnJvbTogbmV4dC5mcm9tLCB0bzogbmV4dC50bywgaW5zZXJ0OiByZXBsYWNlbWVudCB9KTtcbiAgICAgICAgbmV4dCA9IHF1ZXJ5Lm5leHRNYXRjaChzdGF0ZSwgbmV4dC5mcm9tLCBuZXh0LnRvKTtcbiAgICAgICAgZWZmZWN0cy5wdXNoKEVkaXRvclZpZXcuYW5ub3VuY2Uub2Yoc3RhdGUucGhyYXNlKFwicmVwbGFjZWQgbWF0Y2ggb24gbGluZSAkXCIsIHN0YXRlLmRvYy5saW5lQXQoZnJvbSkubnVtYmVyKSArIFwiLlwiKSk7XG4gICAgfVxuICAgIGlmIChuZXh0KSB7XG4gICAgICAgIGxldCBvZmYgPSBjaGFuZ2VzLmxlbmd0aCA9PSAwIHx8IGNoYW5nZXNbMF0uZnJvbSA+PSBuZXh0LnRvID8gMCA6IG5leHQudG8gLSBuZXh0LmZyb20gLSByZXBsYWNlbWVudC5sZW5ndGg7XG4gICAgICAgIHNlbGVjdGlvbiA9IEVkaXRvclNlbGVjdGlvbi5zaW5nbGUobmV4dC5mcm9tIC0gb2ZmLCBuZXh0LnRvIC0gb2ZmKTtcbiAgICAgICAgZWZmZWN0cy5wdXNoKGFubm91bmNlTWF0Y2godmlldywgbmV4dCkpO1xuICAgICAgICBlZmZlY3RzLnB1c2goc3RhdGUuZmFjZXQoc2VhcmNoQ29uZmlnRmFjZXQpLnNjcm9sbFRvTWF0Y2goc2VsZWN0aW9uLm1haW4sIHZpZXcpKTtcbiAgICB9XG4gICAgdmlldy5kaXNwYXRjaCh7XG4gICAgICAgIGNoYW5nZXMsIHNlbGVjdGlvbiwgZWZmZWN0cyxcbiAgICAgICAgdXNlckV2ZW50OiBcImlucHV0LnJlcGxhY2VcIlxuICAgIH0pO1xuICAgIHJldHVybiB0cnVlO1xufSk7XG4vKipcblJlcGxhY2UgYWxsIGluc3RhbmNlcyBvZiB0aGUgc2VhcmNoIHF1ZXJ5IHdpdGggdGhlIGdpdmVuXG5yZXBsYWNlbWVudC5cbiovXG5jb25zdCByZXBsYWNlQWxsID0gLypAX19QVVJFX18qL3NlYXJjaENvbW1hbmQoKHZpZXcsIHsgcXVlcnkgfSkgPT4ge1xuICAgIGlmICh2aWV3LnN0YXRlLnJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGNoYW5nZXMgPSBxdWVyeS5tYXRjaEFsbCh2aWV3LnN0YXRlLCAxZTkpLm1hcChtYXRjaCA9PiB7XG4gICAgICAgIGxldCB7IGZyb20sIHRvIH0gPSBtYXRjaDtcbiAgICAgICAgcmV0dXJuIHsgZnJvbSwgdG8sIGluc2VydDogcXVlcnkuZ2V0UmVwbGFjZW1lbnQobWF0Y2gpIH07XG4gICAgfSk7XG4gICAgaWYgKCFjaGFuZ2VzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBhbm5vdW5jZVRleHQgPSB2aWV3LnN0YXRlLnBocmFzZShcInJlcGxhY2VkICQgbWF0Y2hlc1wiLCBjaGFuZ2VzLmxlbmd0aCkgKyBcIi5cIjtcbiAgICB2aWV3LmRpc3BhdGNoKHtcbiAgICAgICAgY2hhbmdlcyxcbiAgICAgICAgZWZmZWN0czogRWRpdG9yVmlldy5hbm5vdW5jZS5vZihhbm5vdW5jZVRleHQpLFxuICAgICAgICB1c2VyRXZlbnQ6IFwiaW5wdXQucmVwbGFjZS5hbGxcIlxuICAgIH0pO1xuICAgIHJldHVybiB0cnVlO1xufSk7XG5mdW5jdGlvbiBjcmVhdGVTZWFyY2hQYW5lbCh2aWV3KSB7XG4gICAgcmV0dXJuIHZpZXcuc3RhdGUuZmFjZXQoc2VhcmNoQ29uZmlnRmFjZXQpLmNyZWF0ZVBhbmVsKHZpZXcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdFF1ZXJ5KHN0YXRlLCBmYWxsYmFjaykge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2U7XG4gICAgbGV0IHNlbCA9IHN0YXRlLnNlbGVjdGlvbi5tYWluO1xuICAgIGxldCBzZWxUZXh0ID0gc2VsLmVtcHR5IHx8IHNlbC50byA+IHNlbC5mcm9tICsgMTAwID8gXCJcIiA6IHN0YXRlLnNsaWNlRG9jKHNlbC5mcm9tLCBzZWwudG8pO1xuICAgIGlmIChmYWxsYmFjayAmJiAhc2VsVGV4dClcbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrO1xuICAgIGxldCBjb25maWcgPSBzdGF0ZS5mYWNldChzZWFyY2hDb25maWdGYWNldCk7XG4gICAgcmV0dXJuIG5ldyBTZWFyY2hRdWVyeSh7XG4gICAgICAgIHNlYXJjaDogKChfYSA9IGZhbGxiYWNrID09PSBudWxsIHx8IGZhbGxiYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmYWxsYmFjay5saXRlcmFsKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjb25maWcubGl0ZXJhbCkgPyBzZWxUZXh0IDogc2VsVGV4dC5yZXBsYWNlKC9cXG4vZywgXCJcXFxcblwiKSxcbiAgICAgICAgY2FzZVNlbnNpdGl2ZTogKF9iID0gZmFsbGJhY2sgPT09IG51bGwgfHwgZmFsbGJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZhbGxiYWNrLmNhc2VTZW5zaXRpdmUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGNvbmZpZy5jYXNlU2Vuc2l0aXZlLFxuICAgICAgICBsaXRlcmFsOiAoX2MgPSBmYWxsYmFjayA9PT0gbnVsbCB8fCBmYWxsYmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmFsbGJhY2subGl0ZXJhbCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogY29uZmlnLmxpdGVyYWwsXG4gICAgICAgIHJlZ2V4cDogKF9kID0gZmFsbGJhY2sgPT09IG51bGwgfHwgZmFsbGJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZhbGxiYWNrLnJlZ2V4cCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogY29uZmlnLnJlZ2V4cCxcbiAgICAgICAgd2hvbGVXb3JkOiAoX2UgPSBmYWxsYmFjayA9PT0gbnVsbCB8fCBmYWxsYmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmFsbGJhY2sud2hvbGVXb3JkKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiBjb25maWcud2hvbGVXb3JkXG4gICAgfSk7XG59XG5mdW5jdGlvbiBnZXRTZWFyY2hJbnB1dCh2aWV3KSB7XG4gICAgbGV0IHBhbmVsID0gZ2V0UGFuZWwodmlldywgY3JlYXRlU2VhcmNoUGFuZWwpO1xuICAgIHJldHVybiBwYW5lbCAmJiBwYW5lbC5kb20ucXVlcnlTZWxlY3RvcihcIlttYWluLWZpZWxkXVwiKTtcbn1cbmZ1bmN0aW9uIHNlbGVjdFNlYXJjaElucHV0KHZpZXcpIHtcbiAgICBsZXQgaW5wdXQgPSBnZXRTZWFyY2hJbnB1dCh2aWV3KTtcbiAgICBpZiAoaW5wdXQgJiYgaW5wdXQgPT0gdmlldy5yb290LmFjdGl2ZUVsZW1lbnQpXG4gICAgICAgIGlucHV0LnNlbGVjdCgpO1xufVxuLyoqXG5NYWtlIHN1cmUgdGhlIHNlYXJjaCBwYW5lbCBpcyBvcGVuIGFuZCBmb2N1c2VkLlxuKi9cbmNvbnN0IG9wZW5TZWFyY2hQYW5lbCA9IHZpZXcgPT4ge1xuICAgIGxldCBzdGF0ZSA9IHZpZXcuc3RhdGUuZmllbGQoc2VhcmNoU3RhdGUsIGZhbHNlKTtcbiAgICBpZiAoc3RhdGUgJiYgc3RhdGUucGFuZWwpIHtcbiAgICAgICAgbGV0IHNlYXJjaElucHV0ID0gZ2V0U2VhcmNoSW5wdXQodmlldyk7XG4gICAgICAgIGlmIChzZWFyY2hJbnB1dCAmJiBzZWFyY2hJbnB1dCAhPSB2aWV3LnJvb3QuYWN0aXZlRWxlbWVudCkge1xuICAgICAgICAgICAgbGV0IHF1ZXJ5ID0gZGVmYXVsdFF1ZXJ5KHZpZXcuc3RhdGUsIHN0YXRlLnF1ZXJ5LnNwZWMpO1xuICAgICAgICAgICAgaWYgKHF1ZXJ5LnZhbGlkKVxuICAgICAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBzZXRTZWFyY2hRdWVyeS5vZihxdWVyeSkgfSk7XG4gICAgICAgICAgICBzZWFyY2hJbnB1dC5mb2N1cygpO1xuICAgICAgICAgICAgc2VhcmNoSW5wdXQuc2VsZWN0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBbXG4gICAgICAgICAgICAgICAgdG9nZ2xlUGFuZWwub2YodHJ1ZSksXG4gICAgICAgICAgICAgICAgc3RhdGUgPyBzZXRTZWFyY2hRdWVyeS5vZihkZWZhdWx0UXVlcnkodmlldy5zdGF0ZSwgc3RhdGUucXVlcnkuc3BlYykpIDogU3RhdGVFZmZlY3QuYXBwZW5kQ29uZmlnLm9mKHNlYXJjaEV4dGVuc2lvbnMpXG4gICAgICAgICAgICBdIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbkNsb3NlIHRoZSBzZWFyY2ggcGFuZWwuXG4qL1xuY29uc3QgY2xvc2VTZWFyY2hQYW5lbCA9IHZpZXcgPT4ge1xuICAgIGxldCBzdGF0ZSA9IHZpZXcuc3RhdGUuZmllbGQoc2VhcmNoU3RhdGUsIGZhbHNlKTtcbiAgICBpZiAoIXN0YXRlIHx8ICFzdGF0ZS5wYW5lbClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBwYW5lbCA9IGdldFBhbmVsKHZpZXcsIGNyZWF0ZVNlYXJjaFBhbmVsKTtcbiAgICBpZiAocGFuZWwgJiYgcGFuZWwuZG9tLmNvbnRhaW5zKHZpZXcucm9vdC5hY3RpdmVFbGVtZW50KSlcbiAgICAgICAgdmlldy5mb2N1cygpO1xuICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiB0b2dnbGVQYW5lbC5vZihmYWxzZSkgfSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5EZWZhdWx0IHNlYXJjaC1yZWxhdGVkIGtleSBiaW5kaW5ncy5cblxuIC0gTW9kLWY6IFtgb3BlblNlYXJjaFBhbmVsYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzZWFyY2gub3BlblNlYXJjaFBhbmVsKVxuIC0gRjMsIE1vZC1nOiBbYGZpbmROZXh0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzZWFyY2guZmluZE5leHQpXG4gLSBTaGlmdC1GMywgU2hpZnQtTW9kLWc6IFtgZmluZFByZXZpb3VzYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzZWFyY2guZmluZFByZXZpb3VzKVxuIC0gTW9kLUFsdC1nOiBbYGdvdG9MaW5lYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzZWFyY2guZ290b0xpbmUpXG4gLSBNb2QtZDogW2BzZWxlY3ROZXh0T2NjdXJyZW5jZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLnNlbGVjdE5leHRPY2N1cnJlbmNlKVxuKi9cbmNvbnN0IHNlYXJjaEtleW1hcCA9IFtcbiAgICB7IGtleTogXCJNb2QtZlwiLCBydW46IG9wZW5TZWFyY2hQYW5lbCwgc2NvcGU6IFwiZWRpdG9yIHNlYXJjaC1wYW5lbFwiIH0sXG4gICAgeyBrZXk6IFwiRjNcIiwgcnVuOiBmaW5kTmV4dCwgc2hpZnQ6IGZpbmRQcmV2aW91cywgc2NvcGU6IFwiZWRpdG9yIHNlYXJjaC1wYW5lbFwiLCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsga2V5OiBcIk1vZC1nXCIsIHJ1bjogZmluZE5leHQsIHNoaWZ0OiBmaW5kUHJldmlvdXMsIHNjb3BlOiBcImVkaXRvciBzZWFyY2gtcGFuZWxcIiwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IGtleTogXCJFc2NhcGVcIiwgcnVuOiBjbG9zZVNlYXJjaFBhbmVsLCBzY29wZTogXCJlZGl0b3Igc2VhcmNoLXBhbmVsXCIgfSxcbiAgICB7IGtleTogXCJNb2QtU2hpZnQtbFwiLCBydW46IHNlbGVjdFNlbGVjdGlvbk1hdGNoZXMgfSxcbiAgICB7IGtleTogXCJNb2QtQWx0LWdcIiwgcnVuOiBnb3RvTGluZSB9LFxuICAgIHsga2V5OiBcIk1vZC1kXCIsIHJ1bjogc2VsZWN0TmV4dE9jY3VycmVuY2UsIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG5dO1xuY2xhc3MgU2VhcmNoUGFuZWwge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgbGV0IHF1ZXJ5ID0gdGhpcy5xdWVyeSA9IHZpZXcuc3RhdGUuZmllbGQoc2VhcmNoU3RhdGUpLnF1ZXJ5LnNwZWM7XG4gICAgICAgIHRoaXMuY29tbWl0ID0gdGhpcy5jb21taXQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZWFyY2hGaWVsZCA9IGVsdChcImlucHV0XCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiBxdWVyeS5zZWFyY2gsXG4gICAgICAgICAgICBwbGFjZWhvbGRlcjogcGhyYXNlKHZpZXcsIFwiRmluZFwiKSxcbiAgICAgICAgICAgIFwiYXJpYS1sYWJlbFwiOiBwaHJhc2UodmlldywgXCJGaW5kXCIpLFxuICAgICAgICAgICAgY2xhc3M6IFwiY20tdGV4dGZpZWxkXCIsXG4gICAgICAgICAgICBuYW1lOiBcInNlYXJjaFwiLFxuICAgICAgICAgICAgZm9ybTogXCJcIixcbiAgICAgICAgICAgIFwibWFpbi1maWVsZFwiOiBcInRydWVcIixcbiAgICAgICAgICAgIG9uY2hhbmdlOiB0aGlzLmNvbW1pdCxcbiAgICAgICAgICAgIG9ua2V5dXA6IHRoaXMuY29tbWl0XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlcGxhY2VGaWVsZCA9IGVsdChcImlucHV0XCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiBxdWVyeS5yZXBsYWNlLFxuICAgICAgICAgICAgcGxhY2Vob2xkZXI6IHBocmFzZSh2aWV3LCBcIlJlcGxhY2VcIiksXG4gICAgICAgICAgICBcImFyaWEtbGFiZWxcIjogcGhyYXNlKHZpZXcsIFwiUmVwbGFjZVwiKSxcbiAgICAgICAgICAgIGNsYXNzOiBcImNtLXRleHRmaWVsZFwiLFxuICAgICAgICAgICAgbmFtZTogXCJyZXBsYWNlXCIsXG4gICAgICAgICAgICBmb3JtOiBcIlwiLFxuICAgICAgICAgICAgb25jaGFuZ2U6IHRoaXMuY29tbWl0LFxuICAgICAgICAgICAgb25rZXl1cDogdGhpcy5jb21taXRcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2FzZUZpZWxkID0gZWx0KFwiaW5wdXRcIiwge1xuICAgICAgICAgICAgdHlwZTogXCJjaGVja2JveFwiLFxuICAgICAgICAgICAgbmFtZTogXCJjYXNlXCIsXG4gICAgICAgICAgICBmb3JtOiBcIlwiLFxuICAgICAgICAgICAgY2hlY2tlZDogcXVlcnkuY2FzZVNlbnNpdGl2ZSxcbiAgICAgICAgICAgIG9uY2hhbmdlOiB0aGlzLmNvbW1pdFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZUZpZWxkID0gZWx0KFwiaW5wdXRcIiwge1xuICAgICAgICAgICAgdHlwZTogXCJjaGVja2JveFwiLFxuICAgICAgICAgICAgbmFtZTogXCJyZVwiLFxuICAgICAgICAgICAgZm9ybTogXCJcIixcbiAgICAgICAgICAgIGNoZWNrZWQ6IHF1ZXJ5LnJlZ2V4cCxcbiAgICAgICAgICAgIG9uY2hhbmdlOiB0aGlzLmNvbW1pdFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy53b3JkRmllbGQgPSBlbHQoXCJpbnB1dFwiLCB7XG4gICAgICAgICAgICB0eXBlOiBcImNoZWNrYm94XCIsXG4gICAgICAgICAgICBuYW1lOiBcIndvcmRcIixcbiAgICAgICAgICAgIGZvcm06IFwiXCIsXG4gICAgICAgICAgICBjaGVja2VkOiBxdWVyeS53aG9sZVdvcmQsXG4gICAgICAgICAgICBvbmNoYW5nZTogdGhpcy5jb21taXRcbiAgICAgICAgfSk7XG4gICAgICAgIGZ1bmN0aW9uIGJ1dHRvbihuYW1lLCBvbmNsaWNrLCBjb250ZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gZWx0KFwiYnV0dG9uXCIsIHsgY2xhc3M6IFwiY20tYnV0dG9uXCIsIG5hbWUsIG9uY2xpY2ssIHR5cGU6IFwiYnV0dG9uXCIgfSwgY29udGVudCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kb20gPSBlbHQoXCJkaXZcIiwgeyBvbmtleWRvd246IChlKSA9PiB0aGlzLmtleWRvd24oZSksIGNsYXNzOiBcImNtLXNlYXJjaFwiIH0sIFtcbiAgICAgICAgICAgIHRoaXMuc2VhcmNoRmllbGQsXG4gICAgICAgICAgICBidXR0b24oXCJuZXh0XCIsICgpID0+IGZpbmROZXh0KHZpZXcpLCBbcGhyYXNlKHZpZXcsIFwibmV4dFwiKV0pLFxuICAgICAgICAgICAgYnV0dG9uKFwicHJldlwiLCAoKSA9PiBmaW5kUHJldmlvdXModmlldyksIFtwaHJhc2UodmlldywgXCJwcmV2aW91c1wiKV0pLFxuICAgICAgICAgICAgYnV0dG9uKFwic2VsZWN0XCIsICgpID0+IHNlbGVjdE1hdGNoZXModmlldyksIFtwaHJhc2UodmlldywgXCJhbGxcIildKSxcbiAgICAgICAgICAgIGVsdChcImxhYmVsXCIsIG51bGwsIFt0aGlzLmNhc2VGaWVsZCwgcGhyYXNlKHZpZXcsIFwibWF0Y2ggY2FzZVwiKV0pLFxuICAgICAgICAgICAgZWx0KFwibGFiZWxcIiwgbnVsbCwgW3RoaXMucmVGaWVsZCwgcGhyYXNlKHZpZXcsIFwicmVnZXhwXCIpXSksXG4gICAgICAgICAgICBlbHQoXCJsYWJlbFwiLCBudWxsLCBbdGhpcy53b3JkRmllbGQsIHBocmFzZSh2aWV3LCBcImJ5IHdvcmRcIildKSxcbiAgICAgICAgICAgIC4uLnZpZXcuc3RhdGUucmVhZE9ubHkgPyBbXSA6IFtcbiAgICAgICAgICAgICAgICBlbHQoXCJiclwiKSxcbiAgICAgICAgICAgICAgICB0aGlzLnJlcGxhY2VGaWVsZCxcbiAgICAgICAgICAgICAgICBidXR0b24oXCJyZXBsYWNlXCIsICgpID0+IHJlcGxhY2VOZXh0KHZpZXcpLCBbcGhyYXNlKHZpZXcsIFwicmVwbGFjZVwiKV0pLFxuICAgICAgICAgICAgICAgIGJ1dHRvbihcInJlcGxhY2VBbGxcIiwgKCkgPT4gcmVwbGFjZUFsbCh2aWV3KSwgW3BocmFzZSh2aWV3LCBcInJlcGxhY2UgYWxsXCIpXSlcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBlbHQoXCJidXR0b25cIiwge1xuICAgICAgICAgICAgICAgIG5hbWU6IFwiY2xvc2VcIixcbiAgICAgICAgICAgICAgICBvbmNsaWNrOiAoKSA9PiBjbG9zZVNlYXJjaFBhbmVsKHZpZXcpLFxuICAgICAgICAgICAgICAgIFwiYXJpYS1sYWJlbFwiOiBwaHJhc2UodmlldywgXCJjbG9zZVwiKSxcbiAgICAgICAgICAgICAgICB0eXBlOiBcImJ1dHRvblwiXG4gICAgICAgICAgICB9LCBbXCLDl1wiXSlcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNvbW1pdCgpIHtcbiAgICAgICAgbGV0IHF1ZXJ5ID0gbmV3IFNlYXJjaFF1ZXJ5KHtcbiAgICAgICAgICAgIHNlYXJjaDogdGhpcy5zZWFyY2hGaWVsZC52YWx1ZSxcbiAgICAgICAgICAgIGNhc2VTZW5zaXRpdmU6IHRoaXMuY2FzZUZpZWxkLmNoZWNrZWQsXG4gICAgICAgICAgICByZWdleHA6IHRoaXMucmVGaWVsZC5jaGVja2VkLFxuICAgICAgICAgICAgd2hvbGVXb3JkOiB0aGlzLndvcmRGaWVsZC5jaGVja2VkLFxuICAgICAgICAgICAgcmVwbGFjZTogdGhpcy5yZXBsYWNlRmllbGQudmFsdWUsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXF1ZXJ5LmVxKHRoaXMucXVlcnkpKSB7XG4gICAgICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnk7XG4gICAgICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBzZXRTZWFyY2hRdWVyeS5vZihxdWVyeSkgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAga2V5ZG93bihlKSB7XG4gICAgICAgIGlmIChydW5TY29wZUhhbmRsZXJzKHRoaXMudmlldywgZSwgXCJzZWFyY2gtcGFuZWxcIikpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlLmtleUNvZGUgPT0gMTMgJiYgZS50YXJnZXQgPT0gdGhpcy5zZWFyY2hGaWVsZCkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgKGUuc2hpZnRLZXkgPyBmaW5kUHJldmlvdXMgOiBmaW5kTmV4dCkodGhpcy52aWV3KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlLmtleUNvZGUgPT0gMTMgJiYgZS50YXJnZXQgPT0gdGhpcy5yZXBsYWNlRmllbGQpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHJlcGxhY2VOZXh0KHRoaXMudmlldyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBmb3IgKGxldCB0ciBvZiB1cGRhdGUudHJhbnNhY3Rpb25zKVxuICAgICAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIHRyLmVmZmVjdHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWZmZWN0LmlzKHNldFNlYXJjaFF1ZXJ5KSAmJiAhZWZmZWN0LnZhbHVlLmVxKHRoaXMucXVlcnkpKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFF1ZXJ5KGVmZmVjdC52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIHNldFF1ZXJ5KHF1ZXJ5KSB7XG4gICAgICAgIHRoaXMucXVlcnkgPSBxdWVyeTtcbiAgICAgICAgdGhpcy5zZWFyY2hGaWVsZC52YWx1ZSA9IHF1ZXJ5LnNlYXJjaDtcbiAgICAgICAgdGhpcy5yZXBsYWNlRmllbGQudmFsdWUgPSBxdWVyeS5yZXBsYWNlO1xuICAgICAgICB0aGlzLmNhc2VGaWVsZC5jaGVja2VkID0gcXVlcnkuY2FzZVNlbnNpdGl2ZTtcbiAgICAgICAgdGhpcy5yZUZpZWxkLmNoZWNrZWQgPSBxdWVyeS5yZWdleHA7XG4gICAgICAgIHRoaXMud29yZEZpZWxkLmNoZWNrZWQgPSBxdWVyeS53aG9sZVdvcmQ7XG4gICAgfVxuICAgIG1vdW50KCkge1xuICAgICAgICB0aGlzLnNlYXJjaEZpZWxkLnNlbGVjdCgpO1xuICAgIH1cbiAgICBnZXQgcG9zKCkgeyByZXR1cm4gODA7IH1cbiAgICBnZXQgdG9wKCkgeyByZXR1cm4gdGhpcy52aWV3LnN0YXRlLmZhY2V0KHNlYXJjaENvbmZpZ0ZhY2V0KS50b3A7IH1cbn1cbmZ1bmN0aW9uIHBocmFzZSh2aWV3LCBwaHJhc2UpIHsgcmV0dXJuIHZpZXcuc3RhdGUucGhyYXNlKHBocmFzZSk7IH1cbmNvbnN0IEFubm91bmNlTWFyZ2luID0gMzA7XG5jb25zdCBCcmVhayA9IC9bXFxzXFwuLDo7PyFdLztcbmZ1bmN0aW9uIGFubm91bmNlTWF0Y2godmlldywgeyBmcm9tLCB0byB9KSB7XG4gICAgbGV0IGxpbmUgPSB2aWV3LnN0YXRlLmRvYy5saW5lQXQoZnJvbSksIGxpbmVFbmQgPSB2aWV3LnN0YXRlLmRvYy5saW5lQXQodG8pLnRvO1xuICAgIGxldCBzdGFydCA9IE1hdGgubWF4KGxpbmUuZnJvbSwgZnJvbSAtIEFubm91bmNlTWFyZ2luKSwgZW5kID0gTWF0aC5taW4obGluZUVuZCwgdG8gKyBBbm5vdW5jZU1hcmdpbik7XG4gICAgbGV0IHRleHQgPSB2aWV3LnN0YXRlLnNsaWNlRG9jKHN0YXJ0LCBlbmQpO1xuICAgIGlmIChzdGFydCAhPSBsaW5lLmZyb20pIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBBbm5vdW5jZU1hcmdpbjsgaSsrKVxuICAgICAgICAgICAgaWYgKCFCcmVhay50ZXN0KHRleHRbaSArIDFdKSAmJiBCcmVhay50ZXN0KHRleHRbaV0pKSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IHRleHQuc2xpY2UoaSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIGlmIChlbmQgIT0gbGluZUVuZCkge1xuICAgICAgICBmb3IgKGxldCBpID0gdGV4dC5sZW5ndGggLSAxOyBpID4gdGV4dC5sZW5ndGggLSBBbm5vdW5jZU1hcmdpbjsgaS0tKVxuICAgICAgICAgICAgaWYgKCFCcmVhay50ZXN0KHRleHRbaSAtIDFdKSAmJiBCcmVhay50ZXN0KHRleHRbaV0pKSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IHRleHQuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBFZGl0b3JWaWV3LmFubm91bmNlLm9mKGAke3ZpZXcuc3RhdGUucGhyYXNlKFwiY3VycmVudCBtYXRjaFwiKX0uICR7dGV4dH0gJHt2aWV3LnN0YXRlLnBocmFzZShcIm9uIGxpbmVcIil9ICR7bGluZS5udW1iZXJ9LmApO1xufVxuY29uc3QgYmFzZVRoZW1lID0gLypAX19QVVJFX18qL0VkaXRvclZpZXcuYmFzZVRoZW1lKHtcbiAgICBcIi5jbS1wYW5lbC5jbS1zZWFyY2hcIjoge1xuICAgICAgICBwYWRkaW5nOiBcIjJweCA2cHggNHB4XCIsXG4gICAgICAgIHBvc2l0aW9uOiBcInJlbGF0aXZlXCIsXG4gICAgICAgIFwiJiBbbmFtZT1jbG9zZV1cIjoge1xuICAgICAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgICAgIHRvcDogXCIwXCIsXG4gICAgICAgICAgICByaWdodDogXCI0cHhcIixcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCJpbmhlcml0XCIsXG4gICAgICAgICAgICBib3JkZXI6IFwibm9uZVwiLFxuICAgICAgICAgICAgZm9udDogXCJpbmhlcml0XCIsXG4gICAgICAgICAgICBwYWRkaW5nOiAwLFxuICAgICAgICAgICAgbWFyZ2luOiAwXG4gICAgICAgIH0sXG4gICAgICAgIFwiJiBpbnB1dCwgJiBidXR0b24sICYgbGFiZWxcIjoge1xuICAgICAgICAgICAgbWFyZ2luOiBcIi4yZW0gLjZlbSAuMmVtIDBcIlxuICAgICAgICB9LFxuICAgICAgICBcIiYgaW5wdXRbdHlwZT1jaGVja2JveF1cIjoge1xuICAgICAgICAgICAgbWFyZ2luUmlnaHQ6IFwiLjJlbVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiJiBsYWJlbFwiOiB7XG4gICAgICAgICAgICBmb250U2l6ZTogXCI4MCVcIixcbiAgICAgICAgICAgIHdoaXRlU3BhY2U6IFwicHJlXCJcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXCImbGlnaHQgLmNtLXNlYXJjaE1hdGNoXCI6IHsgYmFja2dyb3VuZENvbG9yOiBcIiNmZmZmMDA1NFwiIH0sXG4gICAgXCImZGFyayAuY20tc2VhcmNoTWF0Y2hcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwiIzAwZmZmZjhhXCIgfSxcbiAgICBcIiZsaWdodCAuY20tc2VhcmNoTWF0Y2gtc2VsZWN0ZWRcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwiI2ZmNmEwMDU0XCIgfSxcbiAgICBcIiZkYXJrIC5jbS1zZWFyY2hNYXRjaC1zZWxlY3RlZFwiOiB7IGJhY2tncm91bmRDb2xvcjogXCIjZmYwMGZmOGFcIiB9XG59KTtcbmNvbnN0IHNlYXJjaEV4dGVuc2lvbnMgPSBbXG4gICAgc2VhcmNoU3RhdGUsXG4gICAgLypAX19QVVJFX18qL1ByZWMubG93KHNlYXJjaEhpZ2hsaWdodGVyKSxcbiAgICBiYXNlVGhlbWVcbl07XG5cbmV4cG9ydCB7IFJlZ0V4cEN1cnNvciwgU2VhcmNoQ3Vyc29yLCBTZWFyY2hRdWVyeSwgY2xvc2VTZWFyY2hQYW5lbCwgZmluZE5leHQsIGZpbmRQcmV2aW91cywgZ2V0U2VhcmNoUXVlcnksIGdvdG9MaW5lLCBoaWdobGlnaHRTZWxlY3Rpb25NYXRjaGVzLCBvcGVuU2VhcmNoUGFuZWwsIHJlcGxhY2VBbGwsIHJlcGxhY2VOZXh0LCBzZWFyY2gsIHNlYXJjaEtleW1hcCwgc2VhcmNoUGFuZWxPcGVuLCBzZWxlY3RNYXRjaGVzLCBzZWxlY3ROZXh0T2NjdXJyZW5jZSwgc2VsZWN0U2VsZWN0aW9uTWF0Y2hlcywgc2V0U2VhcmNoUXVlcnkgfTtcbiJdLCJuYW1lcyI6WyJzaG93UGFuZWwiLCJFZGl0b3JWaWV3IiwiZ2V0UGFuZWwiLCJEZWNvcmF0aW9uIiwiVmlld1BsdWdpbiIsInJ1blNjb3BlSGFuZGxlcnMiLCJjb2RlUG9pbnRBdCIsImZyb21Db2RlUG9pbnQiLCJjb2RlUG9pbnRTaXplIiwiU3RhdGVFZmZlY3QiLCJTdGF0ZUZpZWxkIiwiRWRpdG9yU2VsZWN0aW9uIiwiRmFjZXQiLCJjb21iaW5lQ29uZmlnIiwiQ2hhckNhdGVnb3J5IiwiUmFuZ2VTZXRCdWlsZGVyIiwiUHJlYyIsIkVkaXRvclN0YXRlIiwiZmluZENsdXN0ZXJCcmVhayIsImVsdCIsImJhc2ljTm9ybWFsaXplIiwiU3RyaW5nIiwicHJvdG90eXBlIiwibm9ybWFsaXplIiwieCIsIlNlYXJjaEN1cnNvciIsImNvbnN0cnVjdG9yIiwidGV4dCIsInF1ZXJ5IiwiZnJvbSIsInRvIiwibGVuZ3RoIiwidGVzdCIsInZhbHVlIiwiZG9uZSIsIm1hdGNoZXMiLCJidWZmZXIiLCJidWZmZXJQb3MiLCJpdGVyIiwiaXRlclJhbmdlIiwiYnVmZmVyU3RhcnQiLCJwZWVrIiwibmV4dCIsInBvcCIsIm5leHRPdmVybGFwcGluZyIsInN0ciIsInN0YXJ0Iiwibm9ybSIsImkiLCJwb3MiLCJjb2RlIiwiY2hhckNvZGVBdCIsIm1hdGNoIiwiaW5kZXgiLCJrZWVwIiwic3BsaWNlIiwicHVzaCIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiZW1wdHkiLCJleGVjIiwiYmFzZUZsYWdzIiwidW5pY29kZSIsIlJlZ0V4cEN1cnNvciIsIm9wdGlvbnMiLCJjdXJMaW5lIiwiTXVsdGlsaW5lUmVnRXhwQ3Vyc29yIiwicmUiLCJSZWdFeHAiLCJpZ25vcmVDYXNlIiwic3RhcnRMaW5lIiwibGluZUF0IiwiY3VyTGluZVN0YXJ0IiwibWF0Y2hQb3MiLCJ0b0NoYXJFbmQiLCJnZXRMaW5lIiwic2tpcCIsImxpbmVCcmVhayIsInNsaWNlIiwibmV4dExpbmUiLCJvZmYiLCJsYXN0SW5kZXgiLCJmbGF0dGVuZWQiLCJXZWFrTWFwIiwiRmxhdHRlbmVkRG9jIiwiZ2V0IiwiZG9jIiwiY2FjaGVkIiwiZmxhdCIsInNsaWNlU3RyaW5nIiwic2V0IiwiY2FjaGVkRnJvbSIsImNodW5rRW5kIiwidmFsaWRSZWdFeHAiLCJzb3VyY2UiLCJfYSIsImxpbmUiLCJjcmVhdGVMaW5lRGlhbG9nIiwidmlldyIsInN0YXRlIiwic2VsZWN0aW9uIiwibWFpbiIsImhlYWQiLCJudW1iZXIiLCJpbnB1dCIsImNsYXNzIiwibmFtZSIsImRvbSIsIm9ua2V5ZG93biIsImV2ZW50Iiwia2V5Q29kZSIsInByZXZlbnREZWZhdWx0IiwiZGlzcGF0Y2giLCJlZmZlY3RzIiwiZGlhbG9nRWZmZWN0Iiwib2YiLCJmb2N1cyIsImdvIiwib25zdWJtaXQiLCJwaHJhc2UiLCJ0eXBlIiwic2lnbiIsImxuIiwiY2wiLCJwZXJjZW50IiwiY29sIiwicGMiLCJsaW5lcyIsIk1hdGgiLCJyb3VuZCIsImRvY0xpbmUiLCJtYXgiLCJtaW4iLCJjdXJzb3IiLCJzY3JvbGxJbnRvVmlldyIsInkiLCJkZWZpbmUiLCJkaWFsb2dGaWVsZCIsImNyZWF0ZSIsInVwZGF0ZSIsInRyIiwiZSIsImlzIiwicHJvdmlkZSIsImYiLCJ2YWwiLCJnb3RvTGluZSIsInBhbmVsIiwiZmllbGQiLCJhcHBlbmRDb25maWciLCJiYXNlVGhlbWUkMSIsInF1ZXJ5U2VsZWN0b3IiLCJzZWxlY3QiLCJiYXNlVGhlbWUiLCJwYWRkaW5nIiwiZm9udFNpemUiLCJkZWZhdWx0SGlnaGxpZ2h0T3B0aW9ucyIsImhpZ2hsaWdodFdvcmRBcm91bmRDdXJzb3IiLCJtaW5TZWxlY3Rpb25MZW5ndGgiLCJtYXhNYXRjaGVzIiwid2hvbGVXb3JkcyIsImhpZ2hsaWdodENvbmZpZyIsImNvbWJpbmUiLCJhIiwiYiIsImhpZ2hsaWdodFNlbGVjdGlvbk1hdGNoZXMiLCJleHQiLCJkZWZhdWx0VGhlbWUiLCJtYXRjaEhpZ2hsaWdodGVyIiwibWF0Y2hEZWNvIiwibWFyayIsIm1haW5NYXRjaERlY28iLCJpbnNpZGVXb3JkQm91bmRhcmllcyIsImNoZWNrIiwic2xpY2VEb2MiLCJXb3JkIiwiaW5zaWRlV29yZCIsImZyb21DbGFzcyIsImRlY29yYXRpb25zIiwiZ2V0RGVjbyIsInNlbGVjdGlvblNldCIsImRvY0NoYW5nZWQiLCJ2aWV3cG9ydENoYW5nZWQiLCJjb25mIiwiZmFjZXQiLCJzZWwiLCJyYW5nZXMiLCJub25lIiwicmFuZ2UiLCJ3b3JkIiwid29yZEF0IiwiY2hhckNhdGVnb3JpemVyIiwibGVuIiwidHJpbSIsImRlY28iLCJwYXJ0IiwidmlzaWJsZVJhbmdlcyIsInYiLCJiYWNrZ3JvdW5kQ29sb3IiLCJzZWxlY3RXb3JkIiwibmV3U2VsIiwibWFwIiwibWFpbkluZGV4IiwiZXEiLCJmaW5kTmV4dE9jY3VycmVuY2UiLCJmdWxsV29yZCIsImN5Y2xlZCIsInNvbWUiLCJyIiwic2VsZWN0TmV4dE9jY3VycmVuY2UiLCJzZWFyY2hlZFRleHQiLCJhZGRSYW5nZSIsInNlYXJjaENvbmZpZ0ZhY2V0IiwiY29uZmlncyIsInRvcCIsImNhc2VTZW5zaXRpdmUiLCJsaXRlcmFsIiwicmVnZXhwIiwid2hvbGVXb3JkIiwiY3JlYXRlUGFuZWwiLCJTZWFyY2hQYW5lbCIsInNjcm9sbFRvTWF0Y2giLCJzZWFyY2giLCJjb25maWciLCJzZWFyY2hFeHRlbnNpb25zIiwiU2VhcmNoUXVlcnkiLCJyZXBsYWNlIiwidmFsaWQiLCJ1bnF1b3RlZCIsInVucXVvdGUiLCJfIiwiY2giLCJvdGhlciIsIlJlZ0V4cFF1ZXJ5IiwiU3RyaW5nUXVlcnkiLCJnZXRDdXJzb3IiLCJzdCIsInJlZ2V4cEN1cnNvciIsInN0cmluZ0N1cnNvciIsIlF1ZXJ5VHlwZSIsInNwZWMiLCJ1bmRlZmluZWQiLCJ0b0xvd2VyQ2FzZSIsInN0cmluZ1dvcmRUZXN0IiwiY2F0ZWdvcml6ZXIiLCJidWYiLCJidWZQb3MiLCJjaGFyQmVmb3JlIiwiY2hhckFmdGVyIiwibmV4dE1hdGNoIiwiY3VyRnJvbSIsImN1clRvIiwicHJldk1hdGNoSW5SYW5nZSIsInByZXZNYXRjaCIsImdldFJlcGxhY2VtZW50IiwiX3Jlc3VsdCIsIm1hdGNoQWxsIiwibGltaXQiLCJoaWdobGlnaHQiLCJhZGQiLCJyZWdleHBXb3JkVGVzdCIsIl9mcm9tIiwiX3RvIiwic2l6ZSIsInJlc3VsdCIsIm0iLCJzZXRTZWFyY2hRdWVyeSIsInRvZ2dsZVBhbmVsIiwic2VhcmNoU3RhdGUiLCJTZWFyY2hTdGF0ZSIsImRlZmF1bHRRdWVyeSIsImVmZmVjdCIsImNyZWF0ZVNlYXJjaFBhbmVsIiwiZ2V0U2VhcmNoUXVlcnkiLCJjdXJTdGF0ZSIsInNlYXJjaFBhbmVsT3BlbiIsIm1hdGNoTWFyayIsInNlbGVjdGVkTWF0Y2hNYXJrIiwic2VhcmNoSGlnaGxpZ2h0ZXIiLCJzdGFydFN0YXRlIiwiYnVpbGRlciIsImwiLCJzZWxlY3RlZCIsImZpbmlzaCIsInNlYXJjaENvbW1hbmQiLCJvcGVuU2VhcmNoUGFuZWwiLCJmaW5kTmV4dCIsInNpbmdsZSIsImFubm91bmNlTWF0Y2giLCJ1c2VyRXZlbnQiLCJzZWxlY3RTZWFyY2hJbnB1dCIsImZpbmRQcmV2aW91cyIsInByZXYiLCJzZWxlY3RNYXRjaGVzIiwic2VsZWN0U2VsZWN0aW9uTWF0Y2hlcyIsImN1ciIsInJlcGxhY2VOZXh0IiwicmVhZE9ubHkiLCJjaGFuZ2VzIiwicmVwbGFjZW1lbnQiLCJ0b1RleHQiLCJpbnNlcnQiLCJhbm5vdW5jZSIsInJlcGxhY2VBbGwiLCJhbm5vdW5jZVRleHQiLCJmYWxsYmFjayIsIl9iIiwiX2MiLCJfZCIsIl9lIiwic2VsVGV4dCIsImdldFNlYXJjaElucHV0Iiwicm9vdCIsImFjdGl2ZUVsZW1lbnQiLCJzZWFyY2hJbnB1dCIsImNsb3NlU2VhcmNoUGFuZWwiLCJjb250YWlucyIsInNlYXJjaEtleW1hcCIsImtleSIsInJ1biIsInNjb3BlIiwic2hpZnQiLCJjb21taXQiLCJiaW5kIiwic2VhcmNoRmllbGQiLCJwbGFjZWhvbGRlciIsImZvcm0iLCJvbmNoYW5nZSIsIm9ua2V5dXAiLCJyZXBsYWNlRmllbGQiLCJjYXNlRmllbGQiLCJjaGVja2VkIiwicmVGaWVsZCIsIndvcmRGaWVsZCIsImJ1dHRvbiIsIm9uY2xpY2siLCJjb250ZW50Iiwia2V5ZG93biIsInRhcmdldCIsInNoaWZ0S2V5IiwidHJhbnNhY3Rpb25zIiwic2V0UXVlcnkiLCJtb3VudCIsIkFubm91bmNlTWFyZ2luIiwiQnJlYWsiLCJsaW5lRW5kIiwiZW5kIiwicG9zaXRpb24iLCJyaWdodCIsImJvcmRlciIsImZvbnQiLCJtYXJnaW4iLCJtYXJnaW5SaWdodCIsIndoaXRlU3BhY2UiLCJsb3ciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@codemirror/search/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@codemirror/state/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@codemirror/state/dist/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Annotation: () => (/* binding */ Annotation),\n/* harmony export */   AnnotationType: () => (/* binding */ AnnotationType),\n/* harmony export */   ChangeDesc: () => (/* binding */ ChangeDesc),\n/* harmony export */   ChangeSet: () => (/* binding */ ChangeSet),\n/* harmony export */   CharCategory: () => (/* binding */ CharCategory),\n/* harmony export */   Compartment: () => (/* binding */ Compartment),\n/* harmony export */   EditorSelection: () => (/* binding */ EditorSelection),\n/* harmony export */   EditorState: () => (/* binding */ EditorState),\n/* harmony export */   Facet: () => (/* binding */ Facet),\n/* harmony export */   Line: () => (/* binding */ Line),\n/* harmony export */   MapMode: () => (/* binding */ MapMode),\n/* harmony export */   Prec: () => (/* binding */ Prec),\n/* harmony export */   Range: () => (/* binding */ Range),\n/* harmony export */   RangeSet: () => (/* binding */ RangeSet),\n/* harmony export */   RangeSetBuilder: () => (/* binding */ RangeSetBuilder),\n/* harmony export */   RangeValue: () => (/* binding */ RangeValue),\n/* harmony export */   SelectionRange: () => (/* binding */ SelectionRange),\n/* harmony export */   StateEffect: () => (/* binding */ StateEffect),\n/* harmony export */   StateEffectType: () => (/* binding */ StateEffectType),\n/* harmony export */   StateField: () => (/* binding */ StateField),\n/* harmony export */   Text: () => (/* binding */ Text),\n/* harmony export */   Transaction: () => (/* binding */ Transaction),\n/* harmony export */   codePointAt: () => (/* binding */ codePointAt),\n/* harmony export */   codePointSize: () => (/* binding */ codePointSize),\n/* harmony export */   combineConfig: () => (/* binding */ combineConfig),\n/* harmony export */   countColumn: () => (/* binding */ countColumn),\n/* harmony export */   findClusterBreak: () => (/* binding */ findClusterBreak),\n/* harmony export */   findColumn: () => (/* binding */ findColumn),\n/* harmony export */   fromCodePoint: () => (/* binding */ fromCodePoint)\n/* harmony export */ });\n/**\nThe data structure for documents. @nonabstract\n*/ class Text {\n    /**\n    Get the line description around the given position.\n    */ lineAt(pos) {\n        if (pos < 0 || pos > this.length) throw new RangeError(`Invalid position ${pos} in document of length ${this.length}`);\n        return this.lineInner(pos, false, 1, 0);\n    }\n    /**\n    Get the description for the given (1-based) line number.\n    */ line(n) {\n        if (n < 1 || n > this.lines) throw new RangeError(`Invalid line number ${n} in ${this.lines}-line document`);\n        return this.lineInner(n, true, 1, 0);\n    }\n    /**\n    Replace a range of the text with the given content.\n    */ replace(from, to, text) {\n        let parts = [];\n        this.decompose(0, from, parts, 2 /* Open.To */ );\n        if (text.length) text.decompose(0, text.length, parts, 1 /* Open.From */  | 2 /* Open.To */ );\n        this.decompose(to, this.length, parts, 1 /* Open.From */ );\n        return TextNode.from(parts, this.length - (to - from) + text.length);\n    }\n    /**\n    Append another document to this one.\n    */ append(other) {\n        return this.replace(this.length, this.length, other);\n    }\n    /**\n    Retrieve the text between the given points.\n    */ slice(from, to = this.length) {\n        let parts = [];\n        this.decompose(from, to, parts, 0);\n        return TextNode.from(parts, to - from);\n    }\n    /**\n    Test whether this text is equal to another instance.\n    */ eq(other) {\n        if (other == this) return true;\n        if (other.length != this.length || other.lines != this.lines) return false;\n        let start = this.scanIdentical(other, 1), end = this.length - this.scanIdentical(other, -1);\n        let a = new RawTextCursor(this), b = new RawTextCursor(other);\n        for(let skip = start, pos = start;;){\n            a.next(skip);\n            b.next(skip);\n            skip = 0;\n            if (a.lineBreak != b.lineBreak || a.done != b.done || a.value != b.value) return false;\n            pos += a.value.length;\n            if (a.done || pos >= end) return true;\n        }\n    }\n    /**\n    Iterate over the text. When `dir` is `-1`, iteration happens\n    from end to start. This will return lines and the breaks between\n    them as separate strings.\n    */ iter(dir = 1) {\n        return new RawTextCursor(this, dir);\n    }\n    /**\n    Iterate over a range of the text. When `from` > `to`, the\n    iterator will run in reverse.\n    */ iterRange(from, to = this.length) {\n        return new PartialTextCursor(this, from, to);\n    }\n    /**\n    Return a cursor that iterates over the given range of lines,\n    _without_ returning the line breaks between, and yielding empty\n    strings for empty lines.\n    \n    When `from` and `to` are given, they should be 1-based line numbers.\n    */ iterLines(from, to) {\n        let inner;\n        if (from == null) {\n            inner = this.iter();\n        } else {\n            if (to == null) to = this.lines + 1;\n            let start = this.line(from).from;\n            inner = this.iterRange(start, Math.max(start, to == this.lines + 1 ? this.length : to <= 1 ? 0 : this.line(to - 1).to));\n        }\n        return new LineCursor(inner);\n    }\n    /**\n    Return the document as a string, using newline characters to\n    separate lines.\n    */ toString() {\n        return this.sliceString(0);\n    }\n    /**\n    Convert the document to an array of lines (which can be\n    deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#state.Text^of)).\n    */ toJSON() {\n        let lines = [];\n        this.flatten(lines);\n        return lines;\n    }\n    /**\n    @internal\n    */ constructor(){}\n    /**\n    Create a `Text` instance for the given array of lines.\n    */ static of(text) {\n        if (text.length == 0) throw new RangeError(\"A document must have at least one line\");\n        if (text.length == 1 && !text[0]) return Text.empty;\n        return text.length <= 32 /* Tree.Branch */  ? new TextLeaf(text) : TextNode.from(TextLeaf.split(text, []));\n    }\n}\n// Leaves store an array of line strings. There are always line breaks\n// between these strings. Leaves are limited in size and have to be\n// contained in TextNode instances for bigger documents.\nclass TextLeaf extends Text {\n    constructor(text, length = textLength(text)){\n        super();\n        this.text = text;\n        this.length = length;\n    }\n    get lines() {\n        return this.text.length;\n    }\n    get children() {\n        return null;\n    }\n    lineInner(target, isLine, line, offset) {\n        for(let i = 0;; i++){\n            let string = this.text[i], end = offset + string.length;\n            if ((isLine ? line : end) >= target) return new Line(offset, end, line, string);\n            offset = end + 1;\n            line++;\n        }\n    }\n    decompose(from, to, target, open) {\n        let text = from <= 0 && to >= this.length ? this : new TextLeaf(sliceText(this.text, from, to), Math.min(to, this.length) - Math.max(0, from));\n        if (open & 1 /* Open.From */ ) {\n            let prev = target.pop();\n            let joined = appendText(text.text, prev.text.slice(), 0, text.length);\n            if (joined.length <= 32 /* Tree.Branch */ ) {\n                target.push(new TextLeaf(joined, prev.length + text.length));\n            } else {\n                let mid = joined.length >> 1;\n                target.push(new TextLeaf(joined.slice(0, mid)), new TextLeaf(joined.slice(mid)));\n            }\n        } else {\n            target.push(text);\n        }\n    }\n    replace(from, to, text) {\n        if (!(text instanceof TextLeaf)) return super.replace(from, to, text);\n        let lines = appendText(this.text, appendText(text.text, sliceText(this.text, 0, from)), to);\n        let newLen = this.length + text.length - (to - from);\n        if (lines.length <= 32 /* Tree.Branch */ ) return new TextLeaf(lines, newLen);\n        return TextNode.from(TextLeaf.split(lines, []), newLen);\n    }\n    sliceString(from, to = this.length, lineSep = \"\\n\") {\n        let result = \"\";\n        for(let pos = 0, i = 0; pos <= to && i < this.text.length; i++){\n            let line = this.text[i], end = pos + line.length;\n            if (pos > from && i) result += lineSep;\n            if (from < end && to > pos) result += line.slice(Math.max(0, from - pos), to - pos);\n            pos = end + 1;\n        }\n        return result;\n    }\n    flatten(target) {\n        for (let line of this.text)target.push(line);\n    }\n    scanIdentical() {\n        return 0;\n    }\n    static split(text, target) {\n        let part = [], len = -1;\n        for (let line of text){\n            part.push(line);\n            len += line.length + 1;\n            if (part.length == 32 /* Tree.Branch */ ) {\n                target.push(new TextLeaf(part, len));\n                part = [];\n                len = -1;\n            }\n        }\n        if (len > -1) target.push(new TextLeaf(part, len));\n        return target;\n    }\n}\n// Nodes provide the tree structure of the `Text` type. They store a\n// number of other nodes or leaves, taking care to balance themselves\n// on changes. There are implied line breaks _between_ the children of\n// a node (but not before the first or after the last child).\nclass TextNode extends Text {\n    constructor(children, length){\n        super();\n        this.children = children;\n        this.length = length;\n        this.lines = 0;\n        for (let child of children)this.lines += child.lines;\n    }\n    lineInner(target, isLine, line, offset) {\n        for(let i = 0;; i++){\n            let child = this.children[i], end = offset + child.length, endLine = line + child.lines - 1;\n            if ((isLine ? endLine : end) >= target) return child.lineInner(target, isLine, line, offset);\n            offset = end + 1;\n            line = endLine + 1;\n        }\n    }\n    decompose(from, to, target, open) {\n        for(let i = 0, pos = 0; pos <= to && i < this.children.length; i++){\n            let child = this.children[i], end = pos + child.length;\n            if (from <= end && to >= pos) {\n                let childOpen = open & ((pos <= from ? 1 /* Open.From */  : 0) | (end >= to ? 2 /* Open.To */  : 0));\n                if (pos >= from && end <= to && !childOpen) target.push(child);\n                else child.decompose(from - pos, to - pos, target, childOpen);\n            }\n            pos = end + 1;\n        }\n    }\n    replace(from, to, text) {\n        if (text.lines < this.lines) for(let i = 0, pos = 0; i < this.children.length; i++){\n            let child = this.children[i], end = pos + child.length;\n            // Fast path: if the change only affects one child and the\n            // child's size remains in the acceptable range, only update\n            // that child\n            if (from >= pos && to <= end) {\n                let updated = child.replace(from - pos, to - pos, text);\n                let totalLines = this.lines - child.lines + updated.lines;\n                if (updated.lines < totalLines >> 5 /* Tree.BranchShift */  - 1 && updated.lines > totalLines >> 5 /* Tree.BranchShift */  + 1) {\n                    let copy = this.children.slice();\n                    copy[i] = updated;\n                    return new TextNode(copy, this.length - (to - from) + text.length);\n                }\n                return super.replace(pos, end, updated);\n            }\n            pos = end + 1;\n        }\n        return super.replace(from, to, text);\n    }\n    sliceString(from, to = this.length, lineSep = \"\\n\") {\n        let result = \"\";\n        for(let i = 0, pos = 0; i < this.children.length && pos <= to; i++){\n            let child = this.children[i], end = pos + child.length;\n            if (pos > from && i) result += lineSep;\n            if (from < end && to > pos) result += child.sliceString(from - pos, to - pos, lineSep);\n            pos = end + 1;\n        }\n        return result;\n    }\n    flatten(target) {\n        for (let child of this.children)child.flatten(target);\n    }\n    scanIdentical(other, dir) {\n        if (!(other instanceof TextNode)) return 0;\n        let length = 0;\n        let [iA, iB, eA, eB] = dir > 0 ? [\n            0,\n            0,\n            this.children.length,\n            other.children.length\n        ] : [\n            this.children.length - 1,\n            other.children.length - 1,\n            -1,\n            -1\n        ];\n        for(;; iA += dir, iB += dir){\n            if (iA == eA || iB == eB) return length;\n            let chA = this.children[iA], chB = other.children[iB];\n            if (chA != chB) return length + chA.scanIdentical(chB, dir);\n            length += chA.length + 1;\n        }\n    }\n    static from(children, length = children.reduce((l, ch)=>l + ch.length + 1, -1)) {\n        let lines = 0;\n        for (let ch of children)lines += ch.lines;\n        if (lines < 32 /* Tree.Branch */ ) {\n            let flat = [];\n            for (let ch of children)ch.flatten(flat);\n            return new TextLeaf(flat, length);\n        }\n        let chunk = Math.max(32 /* Tree.Branch */ , lines >> 5 /* Tree.BranchShift */ ), maxChunk = chunk << 1, minChunk = chunk >> 1;\n        let chunked = [], currentLines = 0, currentLen = -1, currentChunk = [];\n        function add(child) {\n            let last;\n            if (child.lines > maxChunk && child instanceof TextNode) {\n                for (let node of child.children)add(node);\n            } else if (child.lines > minChunk && (currentLines > minChunk || !currentLines)) {\n                flush();\n                chunked.push(child);\n            } else if (child instanceof TextLeaf && currentLines && (last = currentChunk[currentChunk.length - 1]) instanceof TextLeaf && child.lines + last.lines <= 32 /* Tree.Branch */ ) {\n                currentLines += child.lines;\n                currentLen += child.length + 1;\n                currentChunk[currentChunk.length - 1] = new TextLeaf(last.text.concat(child.text), last.length + 1 + child.length);\n            } else {\n                if (currentLines + child.lines > chunk) flush();\n                currentLines += child.lines;\n                currentLen += child.length + 1;\n                currentChunk.push(child);\n            }\n        }\n        function flush() {\n            if (currentLines == 0) return;\n            chunked.push(currentChunk.length == 1 ? currentChunk[0] : TextNode.from(currentChunk, currentLen));\n            currentLen = -1;\n            currentLines = currentChunk.length = 0;\n        }\n        for (let child of children)add(child);\n        flush();\n        return chunked.length == 1 ? chunked[0] : new TextNode(chunked, length);\n    }\n}\nText.empty = /*@__PURE__*/ new TextLeaf([\n    \"\"\n], 0);\nfunction textLength(text) {\n    let length = -1;\n    for (let line of text)length += line.length + 1;\n    return length;\n}\nfunction appendText(text, target, from = 0, to = 1e9) {\n    for(let pos = 0, i = 0, first = true; i < text.length && pos <= to; i++){\n        let line = text[i], end = pos + line.length;\n        if (end >= from) {\n            if (end > to) line = line.slice(0, to - pos);\n            if (pos < from) line = line.slice(from - pos);\n            if (first) {\n                target[target.length - 1] += line;\n                first = false;\n            } else target.push(line);\n        }\n        pos = end + 1;\n    }\n    return target;\n}\nfunction sliceText(text, from, to) {\n    return appendText(text, [\n        \"\"\n    ], from, to);\n}\nclass RawTextCursor {\n    constructor(text, dir = 1){\n        this.dir = dir;\n        this.done = false;\n        this.lineBreak = false;\n        this.value = \"\";\n        this.nodes = [\n            text\n        ];\n        this.offsets = [\n            dir > 0 ? 1 : (text instanceof TextLeaf ? text.text.length : text.children.length) << 1\n        ];\n    }\n    nextInner(skip, dir) {\n        this.done = this.lineBreak = false;\n        for(;;){\n            let last = this.nodes.length - 1;\n            let top = this.nodes[last], offsetValue = this.offsets[last], offset = offsetValue >> 1;\n            let size = top instanceof TextLeaf ? top.text.length : top.children.length;\n            if (offset == (dir > 0 ? size : 0)) {\n                if (last == 0) {\n                    this.done = true;\n                    this.value = \"\";\n                    return this;\n                }\n                if (dir > 0) this.offsets[last - 1]++;\n                this.nodes.pop();\n                this.offsets.pop();\n            } else if ((offsetValue & 1) == (dir > 0 ? 0 : 1)) {\n                this.offsets[last] += dir;\n                if (skip == 0) {\n                    this.lineBreak = true;\n                    this.value = \"\\n\";\n                    return this;\n                }\n                skip--;\n            } else if (top instanceof TextLeaf) {\n                // Move to the next string\n                let next = top.text[offset + (dir < 0 ? -1 : 0)];\n                this.offsets[last] += dir;\n                if (next.length > Math.max(0, skip)) {\n                    this.value = skip == 0 ? next : dir > 0 ? next.slice(skip) : next.slice(0, next.length - skip);\n                    return this;\n                }\n                skip -= next.length;\n            } else {\n                let next = top.children[offset + (dir < 0 ? -1 : 0)];\n                if (skip > next.length) {\n                    skip -= next.length;\n                    this.offsets[last] += dir;\n                } else {\n                    if (dir < 0) this.offsets[last]--;\n                    this.nodes.push(next);\n                    this.offsets.push(dir > 0 ? 1 : (next instanceof TextLeaf ? next.text.length : next.children.length) << 1);\n                }\n            }\n        }\n    }\n    next(skip = 0) {\n        if (skip < 0) {\n            this.nextInner(-skip, -this.dir);\n            skip = this.value.length;\n        }\n        return this.nextInner(skip, this.dir);\n    }\n}\nclass PartialTextCursor {\n    constructor(text, start, end){\n        this.value = \"\";\n        this.done = false;\n        this.cursor = new RawTextCursor(text, start > end ? -1 : 1);\n        this.pos = start > end ? text.length : 0;\n        this.from = Math.min(start, end);\n        this.to = Math.max(start, end);\n    }\n    nextInner(skip, dir) {\n        if (dir < 0 ? this.pos <= this.from : this.pos >= this.to) {\n            this.value = \"\";\n            this.done = true;\n            return this;\n        }\n        skip += Math.max(0, dir < 0 ? this.pos - this.to : this.from - this.pos);\n        let limit = dir < 0 ? this.pos - this.from : this.to - this.pos;\n        if (skip > limit) skip = limit;\n        limit -= skip;\n        let { value } = this.cursor.next(skip);\n        this.pos += (value.length + skip) * dir;\n        this.value = value.length <= limit ? value : dir < 0 ? value.slice(value.length - limit) : value.slice(0, limit);\n        this.done = !this.value;\n        return this;\n    }\n    next(skip = 0) {\n        if (skip < 0) skip = Math.max(skip, this.from - this.pos);\n        else if (skip > 0) skip = Math.min(skip, this.to - this.pos);\n        return this.nextInner(skip, this.cursor.dir);\n    }\n    get lineBreak() {\n        return this.cursor.lineBreak && this.value != \"\";\n    }\n}\nclass LineCursor {\n    constructor(inner){\n        this.inner = inner;\n        this.afterBreak = true;\n        this.value = \"\";\n        this.done = false;\n    }\n    next(skip = 0) {\n        let { done, lineBreak, value } = this.inner.next(skip);\n        if (done && this.afterBreak) {\n            this.value = \"\";\n            this.afterBreak = false;\n        } else if (done) {\n            this.done = true;\n            this.value = \"\";\n        } else if (lineBreak) {\n            if (this.afterBreak) {\n                this.value = \"\";\n            } else {\n                this.afterBreak = true;\n                this.next();\n            }\n        } else {\n            this.value = value;\n            this.afterBreak = false;\n        }\n        return this;\n    }\n    get lineBreak() {\n        return false;\n    }\n}\nif (typeof Symbol != \"undefined\") {\n    Text.prototype[Symbol.iterator] = function() {\n        return this.iter();\n    };\n    RawTextCursor.prototype[Symbol.iterator] = PartialTextCursor.prototype[Symbol.iterator] = LineCursor.prototype[Symbol.iterator] = function() {\n        return this;\n    };\n}\n/**\nThis type describes a line in the document. It is created\non-demand when lines are [queried](https://codemirror.net/6/docs/ref/#state.Text.lineAt).\n*/ class Line {\n    /**\n    @internal\n    */ constructor(/**\n    The position of the start of the line.\n    */ from, /**\n    The position at the end of the line (_before_ the line break,\n    or at the end of document for the last line).\n    */ to, /**\n    This line's line number (1-based).\n    */ number, /**\n    The line's content.\n    */ text){\n        this.from = from;\n        this.to = to;\n        this.number = number;\n        this.text = text;\n    }\n    /**\n    The length of the line (not including any line break after it).\n    */ get length() {\n        return this.to - this.from;\n    }\n}\n// Compressed representation of the Grapheme_Cluster_Break=Extend\n// information from\n// http://www.unicode.org/Public/13.0.0/ucd/auxiliary/GraphemeBreakProperty.txt.\n// Each pair of elements represents a range, as an offet from the\n// previous range and a length. Numbers are in base-36, with the empty\n// string being a shorthand for 1.\nlet extend = /*@__PURE__*/ \"lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o\".split(\",\").map((s)=>s ? parseInt(s, 36) : 1);\n// Convert offsets into absolute values\nfor(let i = 1; i < extend.length; i++)extend[i] += extend[i - 1];\nfunction isExtendingChar(code) {\n    for(let i = 1; i < extend.length; i += 2)if (extend[i] > code) return extend[i - 1] <= code;\n    return false;\n}\nfunction isRegionalIndicator(code) {\n    return code >= 0x1F1E6 && code <= 0x1F1FF;\n}\nconst ZWJ = 0x200d;\n/**\nReturns a next grapheme cluster break _after_ (not equal to)\n`pos`, if `forward` is true, or before otherwise. Returns `pos`\nitself if no further cluster break is available in the string.\nMoves across surrogate pairs, extending characters (when\n`includeExtending` is true), characters joined with zero-width\njoiners, and flag emoji.\n*/ function findClusterBreak(str, pos, forward = true, includeExtending = true) {\n    return (forward ? nextClusterBreak : prevClusterBreak)(str, pos, includeExtending);\n}\nfunction nextClusterBreak(str, pos, includeExtending) {\n    if (pos == str.length) return pos;\n    // If pos is in the middle of a surrogate pair, move to its start\n    if (pos && surrogateLow(str.charCodeAt(pos)) && surrogateHigh(str.charCodeAt(pos - 1))) pos--;\n    let prev = codePointAt(str, pos);\n    pos += codePointSize(prev);\n    while(pos < str.length){\n        let next = codePointAt(str, pos);\n        if (prev == ZWJ || next == ZWJ || includeExtending && isExtendingChar(next)) {\n            pos += codePointSize(next);\n            prev = next;\n        } else if (isRegionalIndicator(next)) {\n            let countBefore = 0, i = pos - 2;\n            while(i >= 0 && isRegionalIndicator(codePointAt(str, i))){\n                countBefore++;\n                i -= 2;\n            }\n            if (countBefore % 2 == 0) break;\n            else pos += 2;\n        } else {\n            break;\n        }\n    }\n    return pos;\n}\nfunction prevClusterBreak(str, pos, includeExtending) {\n    while(pos > 0){\n        let found = nextClusterBreak(str, pos - 2, includeExtending);\n        if (found < pos) return found;\n        pos--;\n    }\n    return 0;\n}\nfunction surrogateLow(ch) {\n    return ch >= 0xDC00 && ch < 0xE000;\n}\nfunction surrogateHigh(ch) {\n    return ch >= 0xD800 && ch < 0xDC00;\n}\n/**\nFind the code point at the given position in a string (like the\n[`codePointAt`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/codePointAt)\nstring method).\n*/ function codePointAt(str, pos) {\n    let code0 = str.charCodeAt(pos);\n    if (!surrogateHigh(code0) || pos + 1 == str.length) return code0;\n    let code1 = str.charCodeAt(pos + 1);\n    if (!surrogateLow(code1)) return code0;\n    return (code0 - 0xd800 << 10) + (code1 - 0xdc00) + 0x10000;\n}\n/**\nGiven a Unicode codepoint, return the JavaScript string that\nrespresents it (like\n[`String.fromCodePoint`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCodePoint)).\n*/ function fromCodePoint(code) {\n    if (code <= 0xffff) return String.fromCharCode(code);\n    code -= 0x10000;\n    return String.fromCharCode((code >> 10) + 0xd800, (code & 1023) + 0xdc00);\n}\n/**\nThe amount of positions a character takes up a JavaScript string.\n*/ function codePointSize(code) {\n    return code < 0x10000 ? 1 : 2;\n}\nconst DefaultSplit = /\\r\\n?|\\n/;\n/**\nDistinguishes different ways in which positions can be mapped.\n*/ var MapMode = /*@__PURE__*/ function(MapMode) {\n    /**\n    Map a position to a valid new position, even when its context\n    was deleted.\n    */ MapMode[MapMode[\"Simple\"] = 0] = \"Simple\";\n    /**\n    Return null if deletion happens across the position.\n    */ MapMode[MapMode[\"TrackDel\"] = 1] = \"TrackDel\";\n    /**\n    Return null if the character _before_ the position is deleted.\n    */ MapMode[MapMode[\"TrackBefore\"] = 2] = \"TrackBefore\";\n    /**\n    Return null if the character _after_ the position is deleted.\n    */ MapMode[MapMode[\"TrackAfter\"] = 3] = \"TrackAfter\";\n    return MapMode;\n}(MapMode || (MapMode = {}));\n/**\nA change description is a variant of [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet)\nthat doesn't store the inserted text. As such, it can't be\napplied, but is cheaper to store and manipulate.\n*/ class ChangeDesc {\n    // Sections are encoded as pairs of integers. The first is the\n    // length in the current document, and the second is -1 for\n    // unaffected sections, and the length of the replacement content\n    // otherwise. So an insertion would be (0, n>0), a deletion (n>0,\n    // 0), and a replacement two positive numbers.\n    /**\n    @internal\n    */ constructor(/**\n    @internal\n    */ sections){\n        this.sections = sections;\n    }\n    /**\n    The length of the document before the change.\n    */ get length() {\n        let result = 0;\n        for(let i = 0; i < this.sections.length; i += 2)result += this.sections[i];\n        return result;\n    }\n    /**\n    The length of the document after the change.\n    */ get newLength() {\n        let result = 0;\n        for(let i = 0; i < this.sections.length; i += 2){\n            let ins = this.sections[i + 1];\n            result += ins < 0 ? this.sections[i] : ins;\n        }\n        return result;\n    }\n    /**\n    False when there are actual changes in this set.\n    */ get empty() {\n        return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;\n    }\n    /**\n    Iterate over the unchanged parts left by these changes. `posA`\n    provides the position of the range in the old document, `posB`\n    the new position in the changed document.\n    */ iterGaps(f) {\n        for(let i = 0, posA = 0, posB = 0; i < this.sections.length;){\n            let len = this.sections[i++], ins = this.sections[i++];\n            if (ins < 0) {\n                f(posA, posB, len);\n                posB += len;\n            } else {\n                posB += ins;\n            }\n            posA += len;\n        }\n    }\n    /**\n    Iterate over the ranges changed by these changes. (See\n    [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a\n    variant that also provides you with the inserted text.)\n    `fromA`/`toA` provides the extent of the change in the starting\n    document, `fromB`/`toB` the extent of the replacement in the\n    changed document.\n    \n    When `individual` is true, adjacent changes (which are kept\n    separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are\n    reported separately.\n    */ iterChangedRanges(f, individual = false) {\n        iterChanges(this, f, individual);\n    }\n    /**\n    Get a description of the inverted form of these changes.\n    */ get invertedDesc() {\n        let sections = [];\n        for(let i = 0; i < this.sections.length;){\n            let len = this.sections[i++], ins = this.sections[i++];\n            if (ins < 0) sections.push(len, ins);\n            else sections.push(ins, len);\n        }\n        return new ChangeDesc(sections);\n    }\n    /**\n    Compute the combined effect of applying another set of changes\n    after this one. The length of the document after this set should\n    match the length before `other`.\n    */ composeDesc(other) {\n        return this.empty ? other : other.empty ? this : composeSets(this, other);\n    }\n    /**\n    Map this description, which should start with the same document\n    as `other`, over another set of changes, so that it can be\n    applied after it. When `before` is true, map as if the changes\n    in `other` happened before the ones in `this`.\n    */ mapDesc(other, before = false) {\n        return other.empty ? this : mapSet(this, other, before);\n    }\n    mapPos(pos, assoc = -1, mode = MapMode.Simple) {\n        let posA = 0, posB = 0;\n        for(let i = 0; i < this.sections.length;){\n            let len = this.sections[i++], ins = this.sections[i++], endA = posA + len;\n            if (ins < 0) {\n                if (endA > pos) return posB + (pos - posA);\n                posB += len;\n            } else {\n                if (mode != MapMode.Simple && endA >= pos && (mode == MapMode.TrackDel && posA < pos && endA > pos || mode == MapMode.TrackBefore && posA < pos || mode == MapMode.TrackAfter && endA > pos)) return null;\n                if (endA > pos || endA == pos && assoc < 0 && !len) return pos == posA || assoc < 0 ? posB : posB + ins;\n                posB += ins;\n            }\n            posA = endA;\n        }\n        if (pos > posA) throw new RangeError(`Position ${pos} is out of range for changeset of length ${posA}`);\n        return posB;\n    }\n    /**\n    Check whether these changes touch a given range. When one of the\n    changes entirely covers the range, the string `\"cover\"` is\n    returned.\n    */ touchesRange(from, to = from) {\n        for(let i = 0, pos = 0; i < this.sections.length && pos <= to;){\n            let len = this.sections[i++], ins = this.sections[i++], end = pos + len;\n            if (ins >= 0 && pos <= to && end >= from) return pos < from && end > to ? \"cover\" : true;\n            pos = end;\n        }\n        return false;\n    }\n    /**\n    @internal\n    */ toString() {\n        let result = \"\";\n        for(let i = 0; i < this.sections.length;){\n            let len = this.sections[i++], ins = this.sections[i++];\n            result += (result ? \" \" : \"\") + len + (ins >= 0 ? \":\" + ins : \"\");\n        }\n        return result;\n    }\n    /**\n    Serialize this change desc to a JSON-representable value.\n    */ toJSON() {\n        return this.sections;\n    }\n    /**\n    Create a change desc from its JSON representation (as produced\n    by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).\n    */ static fromJSON(json) {\n        if (!Array.isArray(json) || json.length % 2 || json.some((a)=>typeof a != \"number\")) throw new RangeError(\"Invalid JSON representation of ChangeDesc\");\n        return new ChangeDesc(json);\n    }\n    /**\n    @internal\n    */ static create(sections) {\n        return new ChangeDesc(sections);\n    }\n}\n/**\nA change set represents a group of modifications to a document. It\nstores the document length, and can only be applied to documents\nwith exactly that length.\n*/ class ChangeSet extends ChangeDesc {\n    constructor(sections, /**\n    @internal\n    */ inserted){\n        super(sections);\n        this.inserted = inserted;\n    }\n    /**\n    Apply the changes to a document, returning the modified\n    document.\n    */ apply(doc) {\n        if (this.length != doc.length) throw new RangeError(\"Applying change set to a document with the wrong length\");\n        iterChanges(this, (fromA, toA, fromB, _toB, text)=>doc = doc.replace(fromB, fromB + (toA - fromA), text), false);\n        return doc;\n    }\n    mapDesc(other, before = false) {\n        return mapSet(this, other, before, true);\n    }\n    /**\n    Given the document as it existed _before_ the changes, return a\n    change set that represents the inverse of this set, which could\n    be used to go from the document created by the changes back to\n    the document as it existed before the changes.\n    */ invert(doc) {\n        let sections = this.sections.slice(), inserted = [];\n        for(let i = 0, pos = 0; i < sections.length; i += 2){\n            let len = sections[i], ins = sections[i + 1];\n            if (ins >= 0) {\n                sections[i] = ins;\n                sections[i + 1] = len;\n                let index = i >> 1;\n                while(inserted.length < index)inserted.push(Text.empty);\n                inserted.push(len ? doc.slice(pos, pos + len) : Text.empty);\n            }\n            pos += len;\n        }\n        return new ChangeSet(sections, inserted);\n    }\n    /**\n    Combine two subsequent change sets into a single set. `other`\n    must start in the document produced by `this`. If `this` goes\n    `docA` → `docB` and `other` represents `docB` → `docC`, the\n    returned value will represent the change `docA` → `docC`.\n    */ compose(other) {\n        return this.empty ? other : other.empty ? this : composeSets(this, other, true);\n    }\n    /**\n    Given another change set starting in the same document, maps this\n    change set over the other, producing a new change set that can be\n    applied to the document produced by applying `other`. When\n    `before` is `true`, order changes as if `this` comes before\n    `other`, otherwise (the default) treat `other` as coming first.\n    \n    Given two changes `A` and `B`, `A.compose(B.map(A))` and\n    `B.compose(A.map(B, true))` will produce the same document. This\n    provides a basic form of [operational\n    transformation](https://en.wikipedia.org/wiki/Operational_transformation),\n    and can be used for collaborative editing.\n    */ map(other, before = false) {\n        return other.empty ? this : mapSet(this, other, before, true);\n    }\n    /**\n    Iterate over the changed ranges in the document, calling `f` for\n    each, with the range in the original document (`fromA`-`toA`)\n    and the range that replaces it in the new document\n    (`fromB`-`toB`).\n    \n    When `individual` is true, adjacent changes are reported\n    separately.\n    */ iterChanges(f, individual = false) {\n        iterChanges(this, f, individual);\n    }\n    /**\n    Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change\n    set.\n    */ get desc() {\n        return ChangeDesc.create(this.sections);\n    }\n    /**\n    @internal\n    */ filter(ranges) {\n        let resultSections = [], resultInserted = [], filteredSections = [];\n        let iter = new SectionIter(this);\n        done: for(let i = 0, pos = 0;;){\n            let next = i == ranges.length ? 1e9 : ranges[i++];\n            while(pos < next || pos == next && iter.len == 0){\n                if (iter.done) break done;\n                let len = Math.min(iter.len, next - pos);\n                addSection(filteredSections, len, -1);\n                let ins = iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0;\n                addSection(resultSections, len, ins);\n                if (ins > 0) addInsert(resultInserted, resultSections, iter.text);\n                iter.forward(len);\n                pos += len;\n            }\n            let end = ranges[i++];\n            while(pos < end){\n                if (iter.done) break done;\n                let len = Math.min(iter.len, end - pos);\n                addSection(resultSections, len, -1);\n                addSection(filteredSections, len, iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0);\n                iter.forward(len);\n                pos += len;\n            }\n        }\n        return {\n            changes: new ChangeSet(resultSections, resultInserted),\n            filtered: ChangeDesc.create(filteredSections)\n        };\n    }\n    /**\n    Serialize this change set to a JSON-representable value.\n    */ toJSON() {\n        let parts = [];\n        for(let i = 0; i < this.sections.length; i += 2){\n            let len = this.sections[i], ins = this.sections[i + 1];\n            if (ins < 0) parts.push(len);\n            else if (ins == 0) parts.push([\n                len\n            ]);\n            else parts.push([\n                len\n            ].concat(this.inserted[i >> 1].toJSON()));\n        }\n        return parts;\n    }\n    /**\n    Create a change set for the given changes, for a document of the\n    given length, using `lineSep` as line separator.\n    */ static of(changes, length, lineSep) {\n        let sections = [], inserted = [], pos = 0;\n        let total = null;\n        function flush(force = false) {\n            if (!force && !sections.length) return;\n            if (pos < length) addSection(sections, length - pos, -1);\n            let set = new ChangeSet(sections, inserted);\n            total = total ? total.compose(set.map(total)) : set;\n            sections = [];\n            inserted = [];\n            pos = 0;\n        }\n        function process(spec) {\n            if (Array.isArray(spec)) {\n                for (let sub of spec)process(sub);\n            } else if (spec instanceof ChangeSet) {\n                if (spec.length != length) throw new RangeError(`Mismatched change set length (got ${spec.length}, expected ${length})`);\n                flush();\n                total = total ? total.compose(spec.map(total)) : spec;\n            } else {\n                let { from, to = from, insert } = spec;\n                if (from > to || from < 0 || to > length) throw new RangeError(`Invalid change range ${from} to ${to} (in doc of length ${length})`);\n                let insText = !insert ? Text.empty : typeof insert == \"string\" ? Text.of(insert.split(lineSep || DefaultSplit)) : insert;\n                let insLen = insText.length;\n                if (from == to && insLen == 0) return;\n                if (from < pos) flush();\n                if (from > pos) addSection(sections, from - pos, -1);\n                addSection(sections, to - from, insLen);\n                addInsert(inserted, sections, insText);\n                pos = to;\n            }\n        }\n        process(changes);\n        flush(!total);\n        return total;\n    }\n    /**\n    Create an empty changeset of the given length.\n    */ static empty(length) {\n        return new ChangeSet(length ? [\n            length,\n            -1\n        ] : [], []);\n    }\n    /**\n    Create a changeset from its JSON representation (as produced by\n    [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).\n    */ static fromJSON(json) {\n        if (!Array.isArray(json)) throw new RangeError(\"Invalid JSON representation of ChangeSet\");\n        let sections = [], inserted = [];\n        for(let i = 0; i < json.length; i++){\n            let part = json[i];\n            if (typeof part == \"number\") {\n                sections.push(part, -1);\n            } else if (!Array.isArray(part) || typeof part[0] != \"number\" || part.some((e, i)=>i && typeof e != \"string\")) {\n                throw new RangeError(\"Invalid JSON representation of ChangeSet\");\n            } else if (part.length == 1) {\n                sections.push(part[0], 0);\n            } else {\n                while(inserted.length < i)inserted.push(Text.empty);\n                inserted[i] = Text.of(part.slice(1));\n                sections.push(part[0], inserted[i].length);\n            }\n        }\n        return new ChangeSet(sections, inserted);\n    }\n    /**\n    @internal\n    */ static createSet(sections, inserted) {\n        return new ChangeSet(sections, inserted);\n    }\n}\nfunction addSection(sections, len, ins, forceJoin = false) {\n    if (len == 0 && ins <= 0) return;\n    let last = sections.length - 2;\n    if (last >= 0 && ins <= 0 && ins == sections[last + 1]) sections[last] += len;\n    else if (len == 0 && sections[last] == 0) sections[last + 1] += ins;\n    else if (forceJoin) {\n        sections[last] += len;\n        sections[last + 1] += ins;\n    } else sections.push(len, ins);\n}\nfunction addInsert(values, sections, value) {\n    if (value.length == 0) return;\n    let index = sections.length - 2 >> 1;\n    if (index < values.length) {\n        values[values.length - 1] = values[values.length - 1].append(value);\n    } else {\n        while(values.length < index)values.push(Text.empty);\n        values.push(value);\n    }\n}\nfunction iterChanges(desc, f, individual) {\n    let inserted = desc.inserted;\n    for(let posA = 0, posB = 0, i = 0; i < desc.sections.length;){\n        let len = desc.sections[i++], ins = desc.sections[i++];\n        if (ins < 0) {\n            posA += len;\n            posB += len;\n        } else {\n            let endA = posA, endB = posB, text = Text.empty;\n            for(;;){\n                endA += len;\n                endB += ins;\n                if (ins && inserted) text = text.append(inserted[i - 2 >> 1]);\n                if (individual || i == desc.sections.length || desc.sections[i + 1] < 0) break;\n                len = desc.sections[i++];\n                ins = desc.sections[i++];\n            }\n            f(posA, endA, posB, endB, text);\n            posA = endA;\n            posB = endB;\n        }\n    }\n}\nfunction mapSet(setA, setB, before, mkSet = false) {\n    // Produce a copy of setA that applies to the document after setB\n    // has been applied (assuming both start at the same document).\n    let sections = [], insert = mkSet ? [] : null;\n    let a = new SectionIter(setA), b = new SectionIter(setB);\n    // Iterate over both sets in parallel. inserted tracks, for changes\n    // in A that have to be processed piece-by-piece, whether their\n    // content has been inserted already, and refers to the section\n    // index.\n    for(let inserted = -1;;){\n        if (a.ins == -1 && b.ins == -1) {\n            // Move across ranges skipped by both sets.\n            let len = Math.min(a.len, b.len);\n            addSection(sections, len, -1);\n            a.forward(len);\n            b.forward(len);\n        } else if (b.ins >= 0 && (a.ins < 0 || inserted == a.i || a.off == 0 && (b.len < a.len || b.len == a.len && !before))) {\n            // If there's a change in B that comes before the next change in\n            // A (ordered by start pos, then len, then before flag), skip\n            // that (and process any changes in A it covers).\n            let len = b.len;\n            addSection(sections, b.ins, -1);\n            while(len){\n                let piece = Math.min(a.len, len);\n                if (a.ins >= 0 && inserted < a.i && a.len <= piece) {\n                    addSection(sections, 0, a.ins);\n                    if (insert) addInsert(insert, sections, a.text);\n                    inserted = a.i;\n                }\n                a.forward(piece);\n                len -= piece;\n            }\n            b.next();\n        } else if (a.ins >= 0) {\n            // Process the part of a change in A up to the start of the next\n            // non-deletion change in B (if overlapping).\n            let len = 0, left = a.len;\n            while(left){\n                if (b.ins == -1) {\n                    let piece = Math.min(left, b.len);\n                    len += piece;\n                    left -= piece;\n                    b.forward(piece);\n                } else if (b.ins == 0 && b.len < left) {\n                    left -= b.len;\n                    b.next();\n                } else {\n                    break;\n                }\n            }\n            addSection(sections, len, inserted < a.i ? a.ins : 0);\n            if (insert && inserted < a.i) addInsert(insert, sections, a.text);\n            inserted = a.i;\n            a.forward(a.len - left);\n        } else if (a.done && b.done) {\n            return insert ? ChangeSet.createSet(sections, insert) : ChangeDesc.create(sections);\n        } else {\n            throw new Error(\"Mismatched change set lengths\");\n        }\n    }\n}\nfunction composeSets(setA, setB, mkSet = false) {\n    let sections = [];\n    let insert = mkSet ? [] : null;\n    let a = new SectionIter(setA), b = new SectionIter(setB);\n    for(let open = false;;){\n        if (a.done && b.done) {\n            return insert ? ChangeSet.createSet(sections, insert) : ChangeDesc.create(sections);\n        } else if (a.ins == 0) {\n            addSection(sections, a.len, 0, open);\n            a.next();\n        } else if (b.len == 0 && !b.done) {\n            addSection(sections, 0, b.ins, open);\n            if (insert) addInsert(insert, sections, b.text);\n            b.next();\n        } else if (a.done || b.done) {\n            throw new Error(\"Mismatched change set lengths\");\n        } else {\n            let len = Math.min(a.len2, b.len), sectionLen = sections.length;\n            if (a.ins == -1) {\n                let insB = b.ins == -1 ? -1 : b.off ? 0 : b.ins;\n                addSection(sections, len, insB, open);\n                if (insert && insB) addInsert(insert, sections, b.text);\n            } else if (b.ins == -1) {\n                addSection(sections, a.off ? 0 : a.len, len, open);\n                if (insert) addInsert(insert, sections, a.textBit(len));\n            } else {\n                addSection(sections, a.off ? 0 : a.len, b.off ? 0 : b.ins, open);\n                if (insert && !b.off) addInsert(insert, sections, b.text);\n            }\n            open = (a.ins > len || b.ins >= 0 && b.len > len) && (open || sections.length > sectionLen);\n            a.forward2(len);\n            b.forward(len);\n        }\n    }\n}\nclass SectionIter {\n    constructor(set){\n        this.set = set;\n        this.i = 0;\n        this.next();\n    }\n    next() {\n        let { sections } = this.set;\n        if (this.i < sections.length) {\n            this.len = sections[this.i++];\n            this.ins = sections[this.i++];\n        } else {\n            this.len = 0;\n            this.ins = -2;\n        }\n        this.off = 0;\n    }\n    get done() {\n        return this.ins == -2;\n    }\n    get len2() {\n        return this.ins < 0 ? this.len : this.ins;\n    }\n    get text() {\n        let { inserted } = this.set, index = this.i - 2 >> 1;\n        return index >= inserted.length ? Text.empty : inserted[index];\n    }\n    textBit(len) {\n        let { inserted } = this.set, index = this.i - 2 >> 1;\n        return index >= inserted.length && !len ? Text.empty : inserted[index].slice(this.off, len == null ? undefined : this.off + len);\n    }\n    forward(len) {\n        if (len == this.len) this.next();\n        else {\n            this.len -= len;\n            this.off += len;\n        }\n    }\n    forward2(len) {\n        if (this.ins == -1) this.forward(len);\n        else if (len == this.ins) this.next();\n        else {\n            this.ins -= len;\n            this.off += len;\n        }\n    }\n}\n/**\nA single selection range. When\n[`allowMultipleSelections`](https://codemirror.net/6/docs/ref/#state.EditorState^allowMultipleSelections)\nis enabled, a [selection](https://codemirror.net/6/docs/ref/#state.EditorSelection) may hold\nmultiple ranges. By default, selections hold exactly one range.\n*/ class SelectionRange {\n    constructor(/**\n    The lower boundary of the range.\n    */ from, /**\n    The upper boundary of the range.\n    */ to, flags){\n        this.from = from;\n        this.to = to;\n        this.flags = flags;\n    }\n    /**\n    The anchor of the range—the side that doesn't move when you\n    extend it.\n    */ get anchor() {\n        return this.flags & 32 /* RangeFlag.Inverted */  ? this.to : this.from;\n    }\n    /**\n    The head of the range, which is moved when the range is\n    [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).\n    */ get head() {\n        return this.flags & 32 /* RangeFlag.Inverted */  ? this.from : this.to;\n    }\n    /**\n    True when `anchor` and `head` are at the same position.\n    */ get empty() {\n        return this.from == this.to;\n    }\n    /**\n    If this is a cursor that is explicitly associated with the\n    character on one of its sides, this returns the side. -1 means\n    the character before its position, 1 the character after, and 0\n    means no association.\n    */ get assoc() {\n        return this.flags & 8 /* RangeFlag.AssocBefore */  ? -1 : this.flags & 16 /* RangeFlag.AssocAfter */  ? 1 : 0;\n    }\n    /**\n    The bidirectional text level associated with this cursor, if\n    any.\n    */ get bidiLevel() {\n        let level = this.flags & 7 /* RangeFlag.BidiLevelMask */ ;\n        return level == 7 ? null : level;\n    }\n    /**\n    The goal column (stored vertical offset) associated with a\n    cursor. This is used to preserve the vertical position when\n    [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across\n    lines of different length.\n    */ get goalColumn() {\n        let value = this.flags >> 6 /* RangeFlag.GoalColumnOffset */ ;\n        return value == 16777215 /* RangeFlag.NoGoalColumn */  ? undefined : value;\n    }\n    /**\n    Map this range through a change, producing a valid range in the\n    updated document.\n    */ map(change, assoc = -1) {\n        let from, to;\n        if (this.empty) {\n            from = to = change.mapPos(this.from, assoc);\n        } else {\n            from = change.mapPos(this.from, 1);\n            to = change.mapPos(this.to, -1);\n        }\n        return from == this.from && to == this.to ? this : new SelectionRange(from, to, this.flags);\n    }\n    /**\n    Extend this range to cover at least `from` to `to`.\n    */ extend(from, to = from) {\n        if (from <= this.anchor && to >= this.anchor) return EditorSelection.range(from, to);\n        let head = Math.abs(from - this.anchor) > Math.abs(to - this.anchor) ? from : to;\n        return EditorSelection.range(this.anchor, head);\n    }\n    /**\n    Compare this range to another range.\n    */ eq(other) {\n        return this.anchor == other.anchor && this.head == other.head;\n    }\n    /**\n    Return a JSON-serializable object representing the range.\n    */ toJSON() {\n        return {\n            anchor: this.anchor,\n            head: this.head\n        };\n    }\n    /**\n    Convert a JSON representation of a range to a `SelectionRange`\n    instance.\n    */ static fromJSON(json) {\n        if (!json || typeof json.anchor != \"number\" || typeof json.head != \"number\") throw new RangeError(\"Invalid JSON representation for SelectionRange\");\n        return EditorSelection.range(json.anchor, json.head);\n    }\n    /**\n    @internal\n    */ static create(from, to, flags) {\n        return new SelectionRange(from, to, flags);\n    }\n}\n/**\nAn editor selection holds one or more selection ranges.\n*/ class EditorSelection {\n    constructor(/**\n    The ranges in the selection, sorted by position. Ranges cannot\n    overlap (but they may touch, if they aren't empty).\n    */ ranges, /**\n    The index of the _main_ range in the selection (which is\n    usually the range that was added last).\n    */ mainIndex){\n        this.ranges = ranges;\n        this.mainIndex = mainIndex;\n    }\n    /**\n    Map a selection through a change. Used to adjust the selection\n    position for changes.\n    */ map(change, assoc = -1) {\n        if (change.empty) return this;\n        return EditorSelection.create(this.ranges.map((r)=>r.map(change, assoc)), this.mainIndex);\n    }\n    /**\n    Compare this selection to another selection.\n    */ eq(other) {\n        if (this.ranges.length != other.ranges.length || this.mainIndex != other.mainIndex) return false;\n        for(let i = 0; i < this.ranges.length; i++)if (!this.ranges[i].eq(other.ranges[i])) return false;\n        return true;\n    }\n    /**\n    Get the primary selection range. Usually, you should make sure\n    your code applies to _all_ ranges, by using methods like\n    [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).\n    */ get main() {\n        return this.ranges[this.mainIndex];\n    }\n    /**\n    Make sure the selection only has one range. Returns a selection\n    holding only the main range from this selection.\n    */ asSingle() {\n        return this.ranges.length == 1 ? this : new EditorSelection([\n            this.main\n        ], 0);\n    }\n    /**\n    Extend this selection with an extra range.\n    */ addRange(range, main = true) {\n        return EditorSelection.create([\n            range\n        ].concat(this.ranges), main ? 0 : this.mainIndex + 1);\n    }\n    /**\n    Replace a given range with another range, and then normalize the\n    selection to merge and sort ranges if necessary.\n    */ replaceRange(range, which = this.mainIndex) {\n        let ranges = this.ranges.slice();\n        ranges[which] = range;\n        return EditorSelection.create(ranges, this.mainIndex);\n    }\n    /**\n    Convert this selection to an object that can be serialized to\n    JSON.\n    */ toJSON() {\n        return {\n            ranges: this.ranges.map((r)=>r.toJSON()),\n            main: this.mainIndex\n        };\n    }\n    /**\n    Create a selection from a JSON representation.\n    */ static fromJSON(json) {\n        if (!json || !Array.isArray(json.ranges) || typeof json.main != \"number\" || json.main >= json.ranges.length) throw new RangeError(\"Invalid JSON representation for EditorSelection\");\n        return new EditorSelection(json.ranges.map((r)=>SelectionRange.fromJSON(r)), json.main);\n    }\n    /**\n    Create a selection holding a single range.\n    */ static single(anchor, head = anchor) {\n        return new EditorSelection([\n            EditorSelection.range(anchor, head)\n        ], 0);\n    }\n    /**\n    Sort and merge the given set of ranges, creating a valid\n    selection.\n    */ static create(ranges, mainIndex = 0) {\n        if (ranges.length == 0) throw new RangeError(\"A selection needs at least one range\");\n        for(let pos = 0, i = 0; i < ranges.length; i++){\n            let range = ranges[i];\n            if (range.empty ? range.from <= pos : range.from < pos) return EditorSelection.normalized(ranges.slice(), mainIndex);\n            pos = range.to;\n        }\n        return new EditorSelection(ranges, mainIndex);\n    }\n    /**\n    Create a cursor selection range at the given position. You can\n    safely ignore the optional arguments in most situations.\n    */ static cursor(pos, assoc = 0, bidiLevel, goalColumn) {\n        return SelectionRange.create(pos, pos, (assoc == 0 ? 0 : assoc < 0 ? 8 /* RangeFlag.AssocBefore */  : 16 /* RangeFlag.AssocAfter */ ) | (bidiLevel == null ? 7 : Math.min(6, bidiLevel)) | (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 16777215 /* RangeFlag.NoGoalColumn */ ) << 6 /* RangeFlag.GoalColumnOffset */ );\n    }\n    /**\n    Create a selection range.\n    */ static range(anchor, head, goalColumn, bidiLevel) {\n        let flags = (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 16777215 /* RangeFlag.NoGoalColumn */ ) << 6 /* RangeFlag.GoalColumnOffset */  | (bidiLevel == null ? 7 : Math.min(6, bidiLevel));\n        return head < anchor ? SelectionRange.create(head, anchor, 32 /* RangeFlag.Inverted */  | 16 /* RangeFlag.AssocAfter */  | flags) : SelectionRange.create(anchor, head, (head > anchor ? 8 /* RangeFlag.AssocBefore */  : 0) | flags);\n    }\n    /**\n    @internal\n    */ static normalized(ranges, mainIndex = 0) {\n        let main = ranges[mainIndex];\n        ranges.sort((a, b)=>a.from - b.from);\n        mainIndex = ranges.indexOf(main);\n        for(let i = 1; i < ranges.length; i++){\n            let range = ranges[i], prev = ranges[i - 1];\n            if (range.empty ? range.from <= prev.to : range.from < prev.to) {\n                let from = prev.from, to = Math.max(range.to, prev.to);\n                if (i <= mainIndex) mainIndex--;\n                ranges.splice(--i, 2, range.anchor > range.head ? EditorSelection.range(to, from) : EditorSelection.range(from, to));\n            }\n        }\n        return new EditorSelection(ranges, mainIndex);\n    }\n}\nfunction checkSelection(selection, docLength) {\n    for (let range of selection.ranges)if (range.to > docLength) throw new RangeError(\"Selection points outside of document\");\n}\nlet nextID = 0;\n/**\nA facet is a labeled value that is associated with an editor\nstate. It takes inputs from any number of extensions, and combines\nthose into a single output value.\n\nExamples of uses of facets are the [tab\nsize](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize), [editor\nattributes](https://codemirror.net/6/docs/ref/#view.EditorView^editorAttributes), and [update\nlisteners](https://codemirror.net/6/docs/ref/#view.EditorView^updateListener).\n\nNote that `Facet` instances can be used anywhere where\n[`FacetReader`](https://codemirror.net/6/docs/ref/#state.FacetReader) is expected.\n*/ class Facet {\n    constructor(/**\n    @internal\n    */ combine, /**\n    @internal\n    */ compareInput, /**\n    @internal\n    */ compare, isStatic, enables){\n        this.combine = combine;\n        this.compareInput = compareInput;\n        this.compare = compare;\n        this.isStatic = isStatic;\n        /**\n        @internal\n        */ this.id = nextID++;\n        this.default = combine([]);\n        this.extensions = typeof enables == \"function\" ? enables(this) : enables;\n    }\n    /**\n    Returns a facet reader for this facet, which can be used to\n    [read](https://codemirror.net/6/docs/ref/#state.EditorState.facet) it but not to define values for it.\n    */ get reader() {\n        return this;\n    }\n    /**\n    Define a new facet.\n    */ static define(config = {}) {\n        return new Facet(config.combine || ((a)=>a), config.compareInput || ((a, b)=>a === b), config.compare || (!config.combine ? sameArray : (a, b)=>a === b), !!config.static, config.enables);\n    }\n    /**\n    Returns an extension that adds the given value to this facet.\n    */ of(value) {\n        return new FacetProvider([], this, 0 /* Provider.Static */ , value);\n    }\n    /**\n    Create an extension that computes a value for the facet from a\n    state. You must take care to declare the parts of the state that\n    this value depends on, since your function is only called again\n    for a new state when one of those parts changed.\n    \n    In cases where your value depends only on a single field, you'll\n    want to use the [`from`](https://codemirror.net/6/docs/ref/#state.Facet.from) method instead.\n    */ compute(deps, get) {\n        if (this.isStatic) throw new Error(\"Can't compute a static facet\");\n        return new FacetProvider(deps, this, 1 /* Provider.Single */ , get);\n    }\n    /**\n    Create an extension that computes zero or more values for this\n    facet from a state.\n    */ computeN(deps, get) {\n        if (this.isStatic) throw new Error(\"Can't compute a static facet\");\n        return new FacetProvider(deps, this, 2 /* Provider.Multi */ , get);\n    }\n    from(field, get) {\n        if (!get) get = (x)=>x;\n        return this.compute([\n            field\n        ], (state)=>get(state.field(field)));\n    }\n}\nfunction sameArray(a, b) {\n    return a == b || a.length == b.length && a.every((e, i)=>e === b[i]);\n}\nclass FacetProvider {\n    constructor(dependencies, facet, type, value){\n        this.dependencies = dependencies;\n        this.facet = facet;\n        this.type = type;\n        this.value = value;\n        this.id = nextID++;\n    }\n    dynamicSlot(addresses) {\n        var _a;\n        let getter = this.value;\n        let compare = this.facet.compareInput;\n        let id = this.id, idx = addresses[id] >> 1, multi = this.type == 2 /* Provider.Multi */ ;\n        let depDoc = false, depSel = false, depAddrs = [];\n        for (let dep of this.dependencies){\n            if (dep == \"doc\") depDoc = true;\n            else if (dep == \"selection\") depSel = true;\n            else if ((((_a = addresses[dep.id]) !== null && _a !== void 0 ? _a : 1) & 1) == 0) depAddrs.push(addresses[dep.id]);\n        }\n        return {\n            create (state) {\n                state.values[idx] = getter(state);\n                return 1 /* SlotStatus.Changed */ ;\n            },\n            update (state, tr) {\n                if (depDoc && tr.docChanged || depSel && (tr.docChanged || tr.selection) || ensureAll(state, depAddrs)) {\n                    let newVal = getter(state);\n                    if (multi ? !compareArray(newVal, state.values[idx], compare) : !compare(newVal, state.values[idx])) {\n                        state.values[idx] = newVal;\n                        return 1 /* SlotStatus.Changed */ ;\n                    }\n                }\n                return 0;\n            },\n            reconfigure: (state, oldState)=>{\n                let newVal, oldAddr = oldState.config.address[id];\n                if (oldAddr != null) {\n                    let oldVal = getAddr(oldState, oldAddr);\n                    if (this.dependencies.every((dep)=>{\n                        return dep instanceof Facet ? oldState.facet(dep) === state.facet(dep) : dep instanceof StateField ? oldState.field(dep, false) == state.field(dep, false) : true;\n                    }) || (multi ? compareArray(newVal = getter(state), oldVal, compare) : compare(newVal = getter(state), oldVal))) {\n                        state.values[idx] = oldVal;\n                        return 0;\n                    }\n                } else {\n                    newVal = getter(state);\n                }\n                state.values[idx] = newVal;\n                return 1 /* SlotStatus.Changed */ ;\n            }\n        };\n    }\n}\nfunction compareArray(a, b, compare) {\n    if (a.length != b.length) return false;\n    for(let i = 0; i < a.length; i++)if (!compare(a[i], b[i])) return false;\n    return true;\n}\nfunction ensureAll(state, addrs) {\n    let changed = false;\n    for (let addr of addrs)if (ensureAddr(state, addr) & 1 /* SlotStatus.Changed */ ) changed = true;\n    return changed;\n}\nfunction dynamicFacetSlot(addresses, facet, providers) {\n    let providerAddrs = providers.map((p)=>addresses[p.id]);\n    let providerTypes = providers.map((p)=>p.type);\n    let dynamic = providerAddrs.filter((p)=>!(p & 1));\n    let idx = addresses[facet.id] >> 1;\n    function get(state) {\n        let values = [];\n        for(let i = 0; i < providerAddrs.length; i++){\n            let value = getAddr(state, providerAddrs[i]);\n            if (providerTypes[i] == 2 /* Provider.Multi */ ) for (let val of value)values.push(val);\n            else values.push(value);\n        }\n        return facet.combine(values);\n    }\n    return {\n        create (state) {\n            for (let addr of providerAddrs)ensureAddr(state, addr);\n            state.values[idx] = get(state);\n            return 1 /* SlotStatus.Changed */ ;\n        },\n        update (state, tr) {\n            if (!ensureAll(state, dynamic)) return 0;\n            let value = get(state);\n            if (facet.compare(value, state.values[idx])) return 0;\n            state.values[idx] = value;\n            return 1 /* SlotStatus.Changed */ ;\n        },\n        reconfigure (state, oldState) {\n            let depChanged = ensureAll(state, providerAddrs);\n            let oldProviders = oldState.config.facets[facet.id], oldValue = oldState.facet(facet);\n            if (oldProviders && !depChanged && sameArray(providers, oldProviders)) {\n                state.values[idx] = oldValue;\n                return 0;\n            }\n            let value = get(state);\n            if (facet.compare(value, oldValue)) {\n                state.values[idx] = oldValue;\n                return 0;\n            }\n            state.values[idx] = value;\n            return 1 /* SlotStatus.Changed */ ;\n        }\n    };\n}\nconst initField = /*@__PURE__*/ Facet.define({\n    static: true\n});\n/**\nFields can store additional information in an editor state, and\nkeep it in sync with the rest of the state.\n*/ class StateField {\n    constructor(/**\n    @internal\n    */ id, createF, updateF, compareF, /**\n    @internal\n    */ spec){\n        this.id = id;\n        this.createF = createF;\n        this.updateF = updateF;\n        this.compareF = compareF;\n        this.spec = spec;\n        /**\n        @internal\n        */ this.provides = undefined;\n    }\n    /**\n    Define a state field.\n    */ static define(config) {\n        let field = new StateField(nextID++, config.create, config.update, config.compare || ((a, b)=>a === b), config);\n        if (config.provide) field.provides = config.provide(field);\n        return field;\n    }\n    create(state) {\n        let init = state.facet(initField).find((i)=>i.field == this);\n        return ((init === null || init === void 0 ? void 0 : init.create) || this.createF)(state);\n    }\n    /**\n    @internal\n    */ slot(addresses) {\n        let idx = addresses[this.id] >> 1;\n        return {\n            create: (state)=>{\n                state.values[idx] = this.create(state);\n                return 1 /* SlotStatus.Changed */ ;\n            },\n            update: (state, tr)=>{\n                let oldVal = state.values[idx];\n                let value = this.updateF(oldVal, tr);\n                if (this.compareF(oldVal, value)) return 0;\n                state.values[idx] = value;\n                return 1 /* SlotStatus.Changed */ ;\n            },\n            reconfigure: (state, oldState)=>{\n                if (oldState.config.address[this.id] != null) {\n                    state.values[idx] = oldState.field(this);\n                    return 0;\n                }\n                state.values[idx] = this.create(state);\n                return 1 /* SlotStatus.Changed */ ;\n            }\n        };\n    }\n    /**\n    Returns an extension that enables this field and overrides the\n    way it is initialized. Can be useful when you need to provide a\n    non-default starting value for the field.\n    */ init(create) {\n        return [\n            this,\n            initField.of({\n                field: this,\n                create\n            })\n        ];\n    }\n    /**\n    State field instances can be used as\n    [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a\n    given state.\n    */ get extension() {\n        return this;\n    }\n}\nconst Prec_ = {\n    lowest: 4,\n    low: 3,\n    default: 2,\n    high: 1,\n    highest: 0\n};\nfunction prec(value) {\n    return (ext)=>new PrecExtension(ext, value);\n}\n/**\nBy default extensions are registered in the order they are found\nin the flattened form of nested array that was provided.\nIndividual extension values can be assigned a precedence to\noverride this. Extensions that do not have a precedence set get\nthe precedence of the nearest parent with a precedence, or\n[`default`](https://codemirror.net/6/docs/ref/#state.Prec.default) if there is no such parent. The\nfinal ordering of extensions is determined by first sorting by\nprecedence and then by order within each precedence.\n*/ const Prec = {\n    /**\n    The highest precedence level, for extensions that should end up\n    near the start of the precedence ordering.\n    */ highest: /*@__PURE__*/ prec(Prec_.highest),\n    /**\n    A higher-than-default precedence, for extensions that should\n    come before those with default precedence.\n    */ high: /*@__PURE__*/ prec(Prec_.high),\n    /**\n    The default precedence, which is also used for extensions\n    without an explicit precedence.\n    */ default: /*@__PURE__*/ prec(Prec_.default),\n    /**\n    A lower-than-default precedence.\n    */ low: /*@__PURE__*/ prec(Prec_.low),\n    /**\n    The lowest precedence level. Meant for things that should end up\n    near the end of the extension order.\n    */ lowest: /*@__PURE__*/ prec(Prec_.lowest)\n};\nclass PrecExtension {\n    constructor(inner, prec){\n        this.inner = inner;\n        this.prec = prec;\n    }\n}\n/**\nExtension compartments can be used to make a configuration\ndynamic. By [wrapping](https://codemirror.net/6/docs/ref/#state.Compartment.of) part of your\nconfiguration in a compartment, you can later\n[replace](https://codemirror.net/6/docs/ref/#state.Compartment.reconfigure) that part through a\ntransaction.\n*/ class Compartment {\n    /**\n    Create an instance of this compartment to add to your [state\n    configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).\n    */ of(ext) {\n        return new CompartmentInstance(this, ext);\n    }\n    /**\n    Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that\n    reconfigures this compartment.\n    */ reconfigure(content) {\n        return Compartment.reconfigure.of({\n            compartment: this,\n            extension: content\n        });\n    }\n    /**\n    Get the current content of the compartment in the state, or\n    `undefined` if it isn't present.\n    */ get(state) {\n        return state.config.compartments.get(this);\n    }\n}\nclass CompartmentInstance {\n    constructor(compartment, inner){\n        this.compartment = compartment;\n        this.inner = inner;\n    }\n}\nclass Configuration {\n    constructor(base, compartments, dynamicSlots, address, staticValues, facets){\n        this.base = base;\n        this.compartments = compartments;\n        this.dynamicSlots = dynamicSlots;\n        this.address = address;\n        this.staticValues = staticValues;\n        this.facets = facets;\n        this.statusTemplate = [];\n        while(this.statusTemplate.length < dynamicSlots.length)this.statusTemplate.push(0 /* SlotStatus.Unresolved */ );\n    }\n    staticFacet(facet) {\n        let addr = this.address[facet.id];\n        return addr == null ? facet.default : this.staticValues[addr >> 1];\n    }\n    static resolve(base, compartments, oldState) {\n        let fields = [];\n        let facets = Object.create(null);\n        let newCompartments = new Map();\n        for (let ext of flatten(base, compartments, newCompartments)){\n            if (ext instanceof StateField) fields.push(ext);\n            else (facets[ext.facet.id] || (facets[ext.facet.id] = [])).push(ext);\n        }\n        let address = Object.create(null);\n        let staticValues = [];\n        let dynamicSlots = [];\n        for (let field of fields){\n            address[field.id] = dynamicSlots.length << 1;\n            dynamicSlots.push((a)=>field.slot(a));\n        }\n        let oldFacets = oldState === null || oldState === void 0 ? void 0 : oldState.config.facets;\n        for(let id in facets){\n            let providers = facets[id], facet = providers[0].facet;\n            let oldProviders = oldFacets && oldFacets[id] || [];\n            if (providers.every((p)=>p.type == 0 /* Provider.Static */ )) {\n                address[facet.id] = staticValues.length << 1 | 1;\n                if (sameArray(oldProviders, providers)) {\n                    staticValues.push(oldState.facet(facet));\n                } else {\n                    let value = facet.combine(providers.map((p)=>p.value));\n                    staticValues.push(oldState && facet.compare(value, oldState.facet(facet)) ? oldState.facet(facet) : value);\n                }\n            } else {\n                for (let p of providers){\n                    if (p.type == 0 /* Provider.Static */ ) {\n                        address[p.id] = staticValues.length << 1 | 1;\n                        staticValues.push(p.value);\n                    } else {\n                        address[p.id] = dynamicSlots.length << 1;\n                        dynamicSlots.push((a)=>p.dynamicSlot(a));\n                    }\n                }\n                address[facet.id] = dynamicSlots.length << 1;\n                dynamicSlots.push((a)=>dynamicFacetSlot(a, facet, providers));\n            }\n        }\n        let dynamic = dynamicSlots.map((f)=>f(address));\n        return new Configuration(base, newCompartments, dynamic, address, staticValues, facets);\n    }\n}\nfunction flatten(extension, compartments, newCompartments) {\n    let result = [\n        [],\n        [],\n        [],\n        [],\n        []\n    ];\n    let seen = new Map();\n    function inner(ext, prec) {\n        let known = seen.get(ext);\n        if (known != null) {\n            if (known <= prec) return;\n            let found = result[known].indexOf(ext);\n            if (found > -1) result[known].splice(found, 1);\n            if (ext instanceof CompartmentInstance) newCompartments.delete(ext.compartment);\n        }\n        seen.set(ext, prec);\n        if (Array.isArray(ext)) {\n            for (let e of ext)inner(e, prec);\n        } else if (ext instanceof CompartmentInstance) {\n            if (newCompartments.has(ext.compartment)) throw new RangeError(`Duplicate use of compartment in extensions`);\n            let content = compartments.get(ext.compartment) || ext.inner;\n            newCompartments.set(ext.compartment, content);\n            inner(content, prec);\n        } else if (ext instanceof PrecExtension) {\n            inner(ext.inner, ext.prec);\n        } else if (ext instanceof StateField) {\n            result[prec].push(ext);\n            if (ext.provides) inner(ext.provides, prec);\n        } else if (ext instanceof FacetProvider) {\n            result[prec].push(ext);\n            if (ext.facet.extensions) inner(ext.facet.extensions, Prec_.default);\n        } else {\n            let content = ext.extension;\n            if (!content) throw new Error(`Unrecognized extension value in extension set (${ext}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);\n            inner(content, prec);\n        }\n    }\n    inner(extension, Prec_.default);\n    return result.reduce((a, b)=>a.concat(b));\n}\nfunction ensureAddr(state, addr) {\n    if (addr & 1) return 2 /* SlotStatus.Computed */ ;\n    let idx = addr >> 1;\n    let status = state.status[idx];\n    if (status == 4 /* SlotStatus.Computing */ ) throw new Error(\"Cyclic dependency between fields and/or facets\");\n    if (status & 2 /* SlotStatus.Computed */ ) return status;\n    state.status[idx] = 4 /* SlotStatus.Computing */ ;\n    let changed = state.computeSlot(state, state.config.dynamicSlots[idx]);\n    return state.status[idx] = 2 /* SlotStatus.Computed */  | changed;\n}\nfunction getAddr(state, addr) {\n    return addr & 1 ? state.config.staticValues[addr >> 1] : state.values[addr >> 1];\n}\nconst languageData = /*@__PURE__*/ Facet.define();\nconst allowMultipleSelections = /*@__PURE__*/ Facet.define({\n    combine: (values)=>values.some((v)=>v),\n    static: true\n});\nconst lineSeparator = /*@__PURE__*/ Facet.define({\n    combine: (values)=>values.length ? values[0] : undefined,\n    static: true\n});\nconst changeFilter = /*@__PURE__*/ Facet.define();\nconst transactionFilter = /*@__PURE__*/ Facet.define();\nconst transactionExtender = /*@__PURE__*/ Facet.define();\nconst readOnly = /*@__PURE__*/ Facet.define({\n    combine: (values)=>values.length ? values[0] : false\n});\n/**\nAnnotations are tagged values that are used to add metadata to\ntransactions in an extensible way. They should be used to model\nthings that effect the entire transaction (such as its [time\nstamp](https://codemirror.net/6/docs/ref/#state.Transaction^time) or information about its\n[origin](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent)). For effects that happen\n_alongside_ the other changes made by the transaction, [state\neffects](https://codemirror.net/6/docs/ref/#state.StateEffect) are more appropriate.\n*/ class Annotation {\n    /**\n    @internal\n    */ constructor(/**\n    The annotation type.\n    */ type, /**\n    The value of this annotation.\n    */ value){\n        this.type = type;\n        this.value = value;\n    }\n    /**\n    Define a new type of annotation.\n    */ static define() {\n        return new AnnotationType();\n    }\n}\n/**\nMarker that identifies a type of [annotation](https://codemirror.net/6/docs/ref/#state.Annotation).\n*/ class AnnotationType {\n    /**\n    Create an instance of this annotation.\n    */ of(value) {\n        return new Annotation(this, value);\n    }\n}\n/**\nRepresentation of a type of state effect. Defined with\n[`StateEffect.define`](https://codemirror.net/6/docs/ref/#state.StateEffect^define).\n*/ class StateEffectType {\n    /**\n    @internal\n    */ constructor(// The `any` types in these function types are there to work\n    // around TypeScript issue #37631, where the type guard on\n    // `StateEffect.is` mysteriously stops working when these properly\n    // have type `Value`.\n    /**\n    @internal\n    */ map){\n        this.map = map;\n    }\n    /**\n    Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this\n    type.\n    */ of(value) {\n        return new StateEffect(this, value);\n    }\n}\n/**\nState effects can be used to represent additional effects\nassociated with a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction.effects). They\nare often useful to model changes to custom [state\nfields](https://codemirror.net/6/docs/ref/#state.StateField), when those changes aren't implicit in\ndocument or selection changes.\n*/ class StateEffect {\n    /**\n    @internal\n    */ constructor(/**\n    @internal\n    */ type, /**\n    The value of this effect.\n    */ value){\n        this.type = type;\n        this.value = value;\n    }\n    /**\n    Map this effect through a position mapping. Will return\n    `undefined` when that ends up deleting the effect.\n    */ map(mapping) {\n        let mapped = this.type.map(this.value, mapping);\n        return mapped === undefined ? undefined : mapped == this.value ? this : new StateEffect(this.type, mapped);\n    }\n    /**\n    Tells you whether this effect object is of a given\n    [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).\n    */ is(type) {\n        return this.type == type;\n    }\n    /**\n    Define a new effect type. The type parameter indicates the type\n    of values that his effect holds. It should be a type that\n    doesn't include `undefined`, since that is used in\n    [mapping](https://codemirror.net/6/docs/ref/#state.StateEffect.map) to indicate that an effect is\n    removed.\n    */ static define(spec = {}) {\n        return new StateEffectType(spec.map || ((v)=>v));\n    }\n    /**\n    Map an array of effects through a change set.\n    */ static mapEffects(effects, mapping) {\n        if (!effects.length) return effects;\n        let result = [];\n        for (let effect of effects){\n            let mapped = effect.map(mapping);\n            if (mapped) result.push(mapped);\n        }\n        return result;\n    }\n}\n/**\nThis effect can be used to reconfigure the root extensions of\nthe editor. Doing this will discard any extensions\n[appended](https://codemirror.net/6/docs/ref/#state.StateEffect^appendConfig), but does not reset\nthe content of [reconfigured](https://codemirror.net/6/docs/ref/#state.Compartment.reconfigure)\ncompartments.\n*/ StateEffect.reconfigure = /*@__PURE__*/ StateEffect.define();\n/**\nAppend extensions to the top-level configuration of the editor.\n*/ StateEffect.appendConfig = /*@__PURE__*/ StateEffect.define();\n/**\nChanges to the editor state are grouped into transactions.\nTypically, a user action creates a single transaction, which may\ncontain any number of document changes, may change the selection,\nor have other effects. Create a transaction by calling\n[`EditorState.update`](https://codemirror.net/6/docs/ref/#state.EditorState.update), or immediately\ndispatch one by calling\n[`EditorView.dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch).\n*/ class Transaction {\n    constructor(/**\n    The state from which the transaction starts.\n    */ startState, /**\n    The document changes made by this transaction.\n    */ changes, /**\n    The selection set by this transaction, or undefined if it\n    doesn't explicitly set a selection.\n    */ selection, /**\n    The effects added to the transaction.\n    */ effects, /**\n    @internal\n    */ annotations, /**\n    Whether the selection should be scrolled into view after this\n    transaction is dispatched.\n    */ scrollIntoView){\n        this.startState = startState;\n        this.changes = changes;\n        this.selection = selection;\n        this.effects = effects;\n        this.annotations = annotations;\n        this.scrollIntoView = scrollIntoView;\n        /**\n        @internal\n        */ this._doc = null;\n        /**\n        @internal\n        */ this._state = null;\n        if (selection) checkSelection(selection, changes.newLength);\n        if (!annotations.some((a)=>a.type == Transaction.time)) this.annotations = annotations.concat(Transaction.time.of(Date.now()));\n    }\n    /**\n    @internal\n    */ static create(startState, changes, selection, effects, annotations, scrollIntoView) {\n        return new Transaction(startState, changes, selection, effects, annotations, scrollIntoView);\n    }\n    /**\n    The new document produced by the transaction. Contrary to\n    [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't\n    force the entire new state to be computed right away, so it is\n    recommended that [transaction\n    filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter\n    when they need to look at the new document.\n    */ get newDoc() {\n        return this._doc || (this._doc = this.changes.apply(this.startState.doc));\n    }\n    /**\n    The new selection produced by the transaction. If\n    [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,\n    this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's\n    current selection through the changes made by the transaction.\n    */ get newSelection() {\n        return this.selection || this.startState.selection.map(this.changes);\n    }\n    /**\n    The new state created by the transaction. Computed on demand\n    (but retained for subsequent access), so it is recommended not to\n    access it in [transaction\n    filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.\n    */ get state() {\n        if (!this._state) this.startState.applyTransaction(this);\n        return this._state;\n    }\n    /**\n    Get the value of the given annotation type, if any.\n    */ annotation(type) {\n        for (let ann of this.annotations)if (ann.type == type) return ann.value;\n        return undefined;\n    }\n    /**\n    Indicates whether the transaction changed the document.\n    */ get docChanged() {\n        return !this.changes.empty;\n    }\n    /**\n    Indicates whether this transaction reconfigures the state\n    (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or\n    with a top-level configuration\n    [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).\n    */ get reconfigured() {\n        return this.startState.config != this.state.config;\n    }\n    /**\n    Returns true if the transaction has a [user\n    event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to\n    or more specific than `event`. For example, if the transaction\n    has `\"select.pointer\"` as user event, `\"select\"` and\n    `\"select.pointer\"` will match it.\n    */ isUserEvent(event) {\n        let e = this.annotation(Transaction.userEvent);\n        return !!(e && (e == event || e.length > event.length && e.slice(0, event.length) == event && e[event.length] == \".\"));\n    }\n}\n/**\nAnnotation used to store transaction timestamps. Automatically\nadded to every transaction, holding `Date.now()`.\n*/ Transaction.time = /*@__PURE__*/ Annotation.define();\n/**\nAnnotation used to associate a transaction with a user interface\nevent. Holds a string identifying the event, using a\ndot-separated format to support attaching more specific\ninformation. The events used by the core libraries are:\n\n - `\"input\"` when content is entered\n   - `\"input.type\"` for typed input\n     - `\"input.type.compose\"` for composition\n   - `\"input.paste\"` for pasted input\n   - `\"input.drop\"` when adding content with drag-and-drop\n   - `\"input.complete\"` when autocompleting\n - `\"delete\"` when the user deletes content\n   - `\"delete.selection\"` when deleting the selection\n   - `\"delete.forward\"` when deleting forward from the selection\n   - `\"delete.backward\"` when deleting backward from the selection\n   - `\"delete.cut\"` when cutting to the clipboard\n - `\"move\"` when content is moved\n   - `\"move.drop\"` when content is moved within the editor through drag-and-drop\n - `\"select\"` when explicitly changing the selection\n   - `\"select.pointer\"` when selecting with a mouse or other pointing device\n - `\"undo\"` and `\"redo\"` for history actions\n\nUse [`isUserEvent`](https://codemirror.net/6/docs/ref/#state.Transaction.isUserEvent) to check\nwhether the annotation matches a given event.\n*/ Transaction.userEvent = /*@__PURE__*/ Annotation.define();\n/**\nAnnotation indicating whether a transaction should be added to\nthe undo history or not.\n*/ Transaction.addToHistory = /*@__PURE__*/ Annotation.define();\n/**\nAnnotation indicating (when present and true) that a transaction\nrepresents a change made by some other actor, not the user. This\nis used, for example, to tag other people's changes in\ncollaborative editing.\n*/ Transaction.remote = /*@__PURE__*/ Annotation.define();\nfunction joinRanges(a, b) {\n    let result = [];\n    for(let iA = 0, iB = 0;;){\n        let from, to;\n        if (iA < a.length && (iB == b.length || b[iB] >= a[iA])) {\n            from = a[iA++];\n            to = a[iA++];\n        } else if (iB < b.length) {\n            from = b[iB++];\n            to = b[iB++];\n        } else return result;\n        if (!result.length || result[result.length - 1] < from) result.push(from, to);\n        else if (result[result.length - 1] < to) result[result.length - 1] = to;\n    }\n}\nfunction mergeTransaction(a, b, sequential) {\n    var _a;\n    let mapForA, mapForB, changes;\n    if (sequential) {\n        mapForA = b.changes;\n        mapForB = ChangeSet.empty(b.changes.length);\n        changes = a.changes.compose(b.changes);\n    } else {\n        mapForA = b.changes.map(a.changes);\n        mapForB = a.changes.mapDesc(b.changes, true);\n        changes = a.changes.compose(mapForA);\n    }\n    return {\n        changes,\n        selection: b.selection ? b.selection.map(mapForB) : (_a = a.selection) === null || _a === void 0 ? void 0 : _a.map(mapForA),\n        effects: StateEffect.mapEffects(a.effects, mapForA).concat(StateEffect.mapEffects(b.effects, mapForB)),\n        annotations: a.annotations.length ? a.annotations.concat(b.annotations) : b.annotations,\n        scrollIntoView: a.scrollIntoView || b.scrollIntoView\n    };\n}\nfunction resolveTransactionInner(state, spec, docSize) {\n    let sel = spec.selection, annotations = asArray(spec.annotations);\n    if (spec.userEvent) annotations = annotations.concat(Transaction.userEvent.of(spec.userEvent));\n    return {\n        changes: spec.changes instanceof ChangeSet ? spec.changes : ChangeSet.of(spec.changes || [], docSize, state.facet(lineSeparator)),\n        selection: sel && (sel instanceof EditorSelection ? sel : EditorSelection.single(sel.anchor, sel.head)),\n        effects: asArray(spec.effects),\n        annotations,\n        scrollIntoView: !!spec.scrollIntoView\n    };\n}\nfunction resolveTransaction(state, specs, filter) {\n    let s = resolveTransactionInner(state, specs.length ? specs[0] : {}, state.doc.length);\n    if (specs.length && specs[0].filter === false) filter = false;\n    for(let i = 1; i < specs.length; i++){\n        if (specs[i].filter === false) filter = false;\n        let seq = !!specs[i].sequential;\n        s = mergeTransaction(s, resolveTransactionInner(state, specs[i], seq ? s.changes.newLength : state.doc.length), seq);\n    }\n    let tr = Transaction.create(state, s.changes, s.selection, s.effects, s.annotations, s.scrollIntoView);\n    return extendTransaction(filter ? filterTransaction(tr) : tr);\n}\n// Finish a transaction by applying filters if necessary.\nfunction filterTransaction(tr) {\n    let state = tr.startState;\n    // Change filters\n    let result = true;\n    for (let filter of state.facet(changeFilter)){\n        let value = filter(tr);\n        if (value === false) {\n            result = false;\n            break;\n        }\n        if (Array.isArray(value)) result = result === true ? value : joinRanges(result, value);\n    }\n    if (result !== true) {\n        let changes, back;\n        if (result === false) {\n            back = tr.changes.invertedDesc;\n            changes = ChangeSet.empty(state.doc.length);\n        } else {\n            let filtered = tr.changes.filter(result);\n            changes = filtered.changes;\n            back = filtered.filtered.mapDesc(filtered.changes).invertedDesc;\n        }\n        tr = Transaction.create(state, changes, tr.selection && tr.selection.map(back), StateEffect.mapEffects(tr.effects, back), tr.annotations, tr.scrollIntoView);\n    }\n    // Transaction filters\n    let filters = state.facet(transactionFilter);\n    for(let i = filters.length - 1; i >= 0; i--){\n        let filtered = filters[i](tr);\n        if (filtered instanceof Transaction) tr = filtered;\n        else if (Array.isArray(filtered) && filtered.length == 1 && filtered[0] instanceof Transaction) tr = filtered[0];\n        else tr = resolveTransaction(state, asArray(filtered), false);\n    }\n    return tr;\n}\nfunction extendTransaction(tr) {\n    let state = tr.startState, extenders = state.facet(transactionExtender), spec = tr;\n    for(let i = extenders.length - 1; i >= 0; i--){\n        let extension = extenders[i](tr);\n        if (extension && Object.keys(extension).length) spec = mergeTransaction(spec, resolveTransactionInner(state, extension, tr.changes.newLength), true);\n    }\n    return spec == tr ? tr : Transaction.create(state, tr.changes, tr.selection, spec.effects, spec.annotations, spec.scrollIntoView);\n}\nconst none = [];\nfunction asArray(value) {\n    return value == null ? none : Array.isArray(value) ? value : [\n        value\n    ];\n}\n/**\nThe categories produced by a [character\ncategorizer](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer). These are used\ndo things like selecting by word.\n*/ var CharCategory = /*@__PURE__*/ function(CharCategory) {\n    /**\n    Word characters.\n    */ CharCategory[CharCategory[\"Word\"] = 0] = \"Word\";\n    /**\n    Whitespace.\n    */ CharCategory[CharCategory[\"Space\"] = 1] = \"Space\";\n    /**\n    Anything else.\n    */ CharCategory[CharCategory[\"Other\"] = 2] = \"Other\";\n    return CharCategory;\n}(CharCategory || (CharCategory = {}));\nconst nonASCIISingleCaseWordChar = /[\\u00df\\u0587\\u0590-\\u05f4\\u0600-\\u06ff\\u3040-\\u309f\\u30a0-\\u30ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\uac00-\\ud7af]/;\nlet wordChar;\ntry {\n    wordChar = /*@__PURE__*/ new RegExp(\"[\\\\p{Alphabetic}\\\\p{Number}_]\", \"u\");\n} catch (_) {}\nfunction hasWordChar(str) {\n    if (wordChar) return wordChar.test(str);\n    for(let i = 0; i < str.length; i++){\n        let ch = str[i];\n        if (/\\w/.test(ch) || ch > \"\\x80\" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch))) return true;\n    }\n    return false;\n}\nfunction makeCategorizer(wordChars) {\n    return (char)=>{\n        if (!/\\S/.test(char)) return CharCategory.Space;\n        if (hasWordChar(char)) return CharCategory.Word;\n        for(let i = 0; i < wordChars.length; i++)if (char.indexOf(wordChars[i]) > -1) return CharCategory.Word;\n        return CharCategory.Other;\n    };\n}\n/**\nThe editor state class is a persistent (immutable) data structure.\nTo update a state, you [create](https://codemirror.net/6/docs/ref/#state.EditorState.update) a\n[transaction](https://codemirror.net/6/docs/ref/#state.Transaction), which produces a _new_ state\ninstance, without modifying the original object.\n\nAs such, _never_ mutate properties of a state directly. That'll\njust break things.\n*/ class EditorState {\n    constructor(/**\n    @internal\n    */ config, /**\n    The current document.\n    */ doc, /**\n    The current selection.\n    */ selection, /**\n    @internal\n    */ values, computeSlot, tr){\n        this.config = config;\n        this.doc = doc;\n        this.selection = selection;\n        this.values = values;\n        this.status = config.statusTemplate.slice();\n        this.computeSlot = computeSlot;\n        // Fill in the computed state immediately, so that further queries\n        // for it made during the update return this state\n        if (tr) tr._state = this;\n        for(let i = 0; i < this.config.dynamicSlots.length; i++)ensureAddr(this, i << 1);\n        this.computeSlot = null;\n    }\n    field(field, require = true) {\n        let addr = this.config.address[field.id];\n        if (addr == null) {\n            if (require) throw new RangeError(\"Field is not present in this state\");\n            return undefined;\n        }\n        ensureAddr(this, addr);\n        return getAddr(this, addr);\n    }\n    /**\n    Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this\n    state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)\n    can be passed. Unless\n    [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the\n    [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec\n    are assumed to start in the _current_ document (not the document\n    produced by previous specs), and its\n    [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and\n    [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer\n    to the document created by its _own_ changes. The resulting\n    transaction contains the combined effect of all the different\n    specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later\n    specs take precedence over earlier ones.\n    */ update(...specs) {\n        return resolveTransaction(this, specs, true);\n    }\n    /**\n    @internal\n    */ applyTransaction(tr) {\n        let conf = this.config, { base, compartments } = conf;\n        for (let effect of tr.effects){\n            if (effect.is(Compartment.reconfigure)) {\n                if (conf) {\n                    compartments = new Map;\n                    conf.compartments.forEach((val, key)=>compartments.set(key, val));\n                    conf = null;\n                }\n                compartments.set(effect.value.compartment, effect.value.extension);\n            } else if (effect.is(StateEffect.reconfigure)) {\n                conf = null;\n                base = effect.value;\n            } else if (effect.is(StateEffect.appendConfig)) {\n                conf = null;\n                base = asArray(base).concat(effect.value);\n            }\n        }\n        let startValues;\n        if (!conf) {\n            conf = Configuration.resolve(base, compartments, this);\n            let intermediateState = new EditorState(conf, this.doc, this.selection, conf.dynamicSlots.map(()=>null), (state, slot)=>slot.reconfigure(state, this), null);\n            startValues = intermediateState.values;\n        } else {\n            startValues = tr.startState.values.slice();\n        }\n        let selection = tr.startState.facet(allowMultipleSelections) ? tr.newSelection : tr.newSelection.asSingle();\n        new EditorState(conf, tr.newDoc, selection, startValues, (state, slot)=>slot.update(state, tr), tr);\n    }\n    /**\n    Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that\n    replaces every selection range with the given content.\n    */ replaceSelection(text) {\n        if (typeof text == \"string\") text = this.toText(text);\n        return this.changeByRange((range)=>({\n                changes: {\n                    from: range.from,\n                    to: range.to,\n                    insert: text\n                },\n                range: EditorSelection.cursor(range.from + text.length)\n            }));\n    }\n    /**\n    Create a set of changes and a new selection by running the given\n    function for each range in the active selection. The function\n    can return an optional set of changes (in the coordinate space\n    of the start document), plus an updated range (in the coordinate\n    space of the document produced by the call's own changes). This\n    method will merge all the changes and ranges into a single\n    changeset and selection, and return it as a [transaction\n    spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to\n    [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).\n    */ changeByRange(f) {\n        let sel = this.selection;\n        let result1 = f(sel.ranges[0]);\n        let changes = this.changes(result1.changes), ranges = [\n            result1.range\n        ];\n        let effects = asArray(result1.effects);\n        for(let i = 1; i < sel.ranges.length; i++){\n            let result = f(sel.ranges[i]);\n            let newChanges = this.changes(result.changes), newMapped = newChanges.map(changes);\n            for(let j = 0; j < i; j++)ranges[j] = ranges[j].map(newMapped);\n            let mapBy = changes.mapDesc(newChanges, true);\n            ranges.push(result.range.map(mapBy));\n            changes = changes.compose(newMapped);\n            effects = StateEffect.mapEffects(effects, newMapped).concat(StateEffect.mapEffects(asArray(result.effects), mapBy));\n        }\n        return {\n            changes,\n            selection: EditorSelection.create(ranges, sel.mainIndex),\n            effects\n        };\n    }\n    /**\n    Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change\n    description, taking the state's document length and line\n    separator into account.\n    */ changes(spec = []) {\n        if (spec instanceof ChangeSet) return spec;\n        return ChangeSet.of(spec, this.doc.length, this.facet(EditorState.lineSeparator));\n    }\n    /**\n    Using the state's [line\n    separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a\n    [`Text`](https://codemirror.net/6/docs/ref/#state.Text) instance from the given string.\n    */ toText(string) {\n        return Text.of(string.split(this.facet(EditorState.lineSeparator) || DefaultSplit));\n    }\n    /**\n    Return the given range of the document as a string.\n    */ sliceDoc(from = 0, to = this.doc.length) {\n        return this.doc.sliceString(from, to, this.lineBreak);\n    }\n    /**\n    Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).\n    */ facet(facet) {\n        let addr = this.config.address[facet.id];\n        if (addr == null) return facet.default;\n        ensureAddr(this, addr);\n        return getAddr(this, addr);\n    }\n    /**\n    Convert this state to a JSON-serializable object. When custom\n    fields should be serialized, you can pass them in as an object\n    mapping property names (in the resulting object, which should\n    not use `doc` or `selection`) to fields.\n    */ toJSON(fields) {\n        let result = {\n            doc: this.sliceDoc(),\n            selection: this.selection.toJSON()\n        };\n        if (fields) for(let prop in fields){\n            let value = fields[prop];\n            if (value instanceof StateField && this.config.address[value.id] != null) result[prop] = value.spec.toJSON(this.field(fields[prop]), this);\n        }\n        return result;\n    }\n    /**\n    Deserialize a state from its JSON representation. When custom\n    fields should be deserialized, pass the same object you passed\n    to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as\n    third argument.\n    */ static fromJSON(json, config = {}, fields) {\n        if (!json || typeof json.doc != \"string\") throw new RangeError(\"Invalid JSON representation for EditorState\");\n        let fieldInit = [];\n        if (fields) for(let prop in fields){\n            if (Object.prototype.hasOwnProperty.call(json, prop)) {\n                let field = fields[prop], value = json[prop];\n                fieldInit.push(field.init((state)=>field.spec.fromJSON(value, state)));\n            }\n        }\n        return EditorState.create({\n            doc: json.doc,\n            selection: EditorSelection.fromJSON(json.selection),\n            extensions: config.extensions ? fieldInit.concat([\n                config.extensions\n            ]) : fieldInit\n        });\n    }\n    /**\n    Create a new state. You'll usually only need this when\n    initializing an editor—updated states are created by applying\n    transactions.\n    */ static create(config = {}) {\n        let configuration = Configuration.resolve(config.extensions || [], new Map);\n        let doc = config.doc instanceof Text ? config.doc : Text.of((config.doc || \"\").split(configuration.staticFacet(EditorState.lineSeparator) || DefaultSplit));\n        let selection = !config.selection ? EditorSelection.single(0) : config.selection instanceof EditorSelection ? config.selection : EditorSelection.single(config.selection.anchor, config.selection.head);\n        checkSelection(selection, doc.length);\n        if (!configuration.staticFacet(allowMultipleSelections)) selection = selection.asSingle();\n        return new EditorState(configuration, doc, selection, configuration.dynamicSlots.map(()=>null), (state, slot)=>slot.create(state), null);\n    }\n    /**\n    The size (in columns) of a tab in the document, determined by\n    the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.\n    */ get tabSize() {\n        return this.facet(EditorState.tabSize);\n    }\n    /**\n    Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)\n    string for this state.\n    */ get lineBreak() {\n        return this.facet(EditorState.lineSeparator) || \"\\n\";\n    }\n    /**\n    Returns true when the editor is\n    [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.\n    */ get readOnly() {\n        return this.facet(readOnly);\n    }\n    /**\n    Look up a translation for the given phrase (via the\n    [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the\n    original string if no translation is found.\n    \n    If additional arguments are passed, they will be inserted in\n    place of markers like `$1` (for the first value) and `$2`, etc.\n    A single `$` is equivalent to `$1`, and `$$` will produce a\n    literal dollar sign.\n    */ phrase(phrase, ...insert) {\n        for (let map of this.facet(EditorState.phrases))if (Object.prototype.hasOwnProperty.call(map, phrase)) {\n            phrase = map[phrase];\n            break;\n        }\n        if (insert.length) phrase = phrase.replace(/\\$(\\$|\\d*)/g, (m, i)=>{\n            if (i == \"$\") return \"$\";\n            let n = +(i || 1);\n            return !n || n > insert.length ? m : insert[n - 1];\n        });\n        return phrase;\n    }\n    /**\n    Find the values for a given language data field, provided by the\n    the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.\n    \n    Examples of language data fields are...\n    \n    - [`\"commentTokens\"`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) for specifying\n      comment syntax.\n    - [`\"autocomplete\"`](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion^config.override)\n      for providing language-specific completion sources.\n    - [`\"wordChars\"`](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) for adding\n      characters that should be considered part of words in this\n      language.\n    - [`\"closeBrackets\"`](https://codemirror.net/6/docs/ref/#autocomplete.CloseBracketConfig) controls\n      bracket closing behavior.\n    */ languageDataAt(name, pos, side = -1) {\n        let values = [];\n        for (let provider of this.facet(languageData)){\n            for (let result of provider(this, pos, side)){\n                if (Object.prototype.hasOwnProperty.call(result, name)) values.push(result[name]);\n            }\n        }\n        return values;\n    }\n    /**\n    Return a function that can categorize strings (expected to\n    represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak))\n    into one of:\n    \n     - Word (contains an alphanumeric character or a character\n       explicitly listed in the local language's `\"wordChars\"`\n       language data, which should be a string)\n     - Space (contains only whitespace)\n     - Other (anything else)\n    */ charCategorizer(at) {\n        return makeCategorizer(this.languageDataAt(\"wordChars\", at).join(\"\"));\n    }\n    /**\n    Find the word at the given position, meaning the range\n    containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters\n    around it. If no word characters are adjacent to the position,\n    this returns null.\n    */ wordAt(pos) {\n        let { text, from, length } = this.doc.lineAt(pos);\n        let cat = this.charCategorizer(pos);\n        let start = pos - from, end = pos - from;\n        while(start > 0){\n            let prev = findClusterBreak(text, start, false);\n            if (cat(text.slice(prev, start)) != CharCategory.Word) break;\n            start = prev;\n        }\n        while(end < length){\n            let next = findClusterBreak(text, end);\n            if (cat(text.slice(end, next)) != CharCategory.Word) break;\n            end = next;\n        }\n        return start == end ? null : EditorSelection.range(start + from, end + from);\n    }\n}\n/**\nA facet that, when enabled, causes the editor to allow multiple\nranges to be selected. Be careful though, because by default the\neditor relies on the native DOM selection, which cannot handle\nmultiple selections. An extension like\n[`drawSelection`](https://codemirror.net/6/docs/ref/#view.drawSelection) can be used to make\nsecondary selections visible to the user.\n*/ EditorState.allowMultipleSelections = allowMultipleSelections;\n/**\nConfigures the tab size to use in this state. The first\n(highest-precedence) value of the facet is used. If no value is\ngiven, this defaults to 4.\n*/ EditorState.tabSize = /*@__PURE__*/ Facet.define({\n    combine: (values)=>values.length ? values[0] : 4\n});\n/**\nThe line separator to use. By default, any of `\"\\n\"`, `\"\\r\\n\"`\nand `\"\\r\"` is treated as a separator when splitting lines, and\nlines are joined with `\"\\n\"`.\n\nWhen you configure a value here, only that precise separator\nwill be used, allowing you to round-trip documents through the\neditor without normalizing line separators.\n*/ EditorState.lineSeparator = lineSeparator;\n/**\nThis facet controls the value of the\n[`readOnly`](https://codemirror.net/6/docs/ref/#state.EditorState.readOnly) getter, which is\nconsulted by commands and extensions that implement editing\nfunctionality to determine whether they should apply. It\ndefaults to false, but when its highest-precedence value is\n`true`, such functionality disables itself.\n\nNot to be confused with\n[`EditorView.editable`](https://codemirror.net/6/docs/ref/#view.EditorView^editable), which\ncontrols whether the editor's DOM is set to be editable (and\nthus focusable).\n*/ EditorState.readOnly = readOnly;\n/**\nRegisters translation phrases. The\n[`phrase`](https://codemirror.net/6/docs/ref/#state.EditorState.phrase) method will look through\nall objects registered with this facet to find translations for\nits argument.\n*/ EditorState.phrases = /*@__PURE__*/ Facet.define({\n    compare (a, b) {\n        let kA = Object.keys(a), kB = Object.keys(b);\n        return kA.length == kB.length && kA.every((k)=>a[k] == b[k]);\n    }\n});\n/**\nA facet used to register [language\ndata](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt) providers.\n*/ EditorState.languageData = languageData;\n/**\nFacet used to register change filters, which are called for each\ntransaction (unless explicitly\n[disabled](https://codemirror.net/6/docs/ref/#state.TransactionSpec.filter)), and can suppress\npart of the transaction's changes.\n\nSuch a function can return `true` to indicate that it doesn't\nwant to do anything, `false` to completely stop the changes in\nthe transaction, or a set of ranges in which changes should be\nsuppressed. Such ranges are represented as an array of numbers,\nwith each pair of two numbers indicating the start and end of a\nrange. So for example `[10, 20, 100, 110]` suppresses changes\nbetween 10 and 20, and between 100 and 110.\n*/ EditorState.changeFilter = changeFilter;\n/**\nFacet used to register a hook that gets a chance to update or\nreplace transaction specs before they are applied. This will\nonly be applied for transactions that don't have\n[`filter`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.filter) set to `false`. You\ncan either return a single transaction spec (possibly the input\ntransaction), or an array of specs (which will be combined in\nthe same way as the arguments to\n[`EditorState.update`](https://codemirror.net/6/docs/ref/#state.EditorState.update)).\n\nWhen possible, it is recommended to avoid accessing\n[`Transaction.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state) in a filter,\nsince it will force creation of a state that will then be\ndiscarded again, if the transaction is actually filtered.\n\n(This functionality should be used with care. Indiscriminately\nmodifying transaction is likely to break something or degrade\nthe user experience.)\n*/ EditorState.transactionFilter = transactionFilter;\n/**\nThis is a more limited form of\n[`transactionFilter`](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter),\nwhich can only add\n[annotations](https://codemirror.net/6/docs/ref/#state.TransactionSpec.annotations) and\n[effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects). _But_, this type\nof filter runs even if the transaction has disabled regular\n[filtering](https://codemirror.net/6/docs/ref/#state.TransactionSpec.filter), making it suitable\nfor effects that don't need to touch the changes or selection,\nbut do want to process every transaction.\n\nExtenders run _after_ filters, when both are present.\n*/ EditorState.transactionExtender = transactionExtender;\nCompartment.reconfigure = /*@__PURE__*/ StateEffect.define();\n/**\nUtility function for combining behaviors to fill in a config\nobject from an array of provided configs. `defaults` should hold\ndefault values for all optional fields in `Config`.\n\nThe function will, by default, error\nwhen a field gets two values that aren't `===`-equal, but you can\nprovide combine functions per field to do something else.\n*/ function combineConfig(configs, defaults, combine = {}) {\n    let result = {};\n    for (let config of configs)for (let key of Object.keys(config)){\n        let value = config[key], current = result[key];\n        if (current === undefined) result[key] = value;\n        else if (current === value || value === undefined) ; // No conflict\n        else if (Object.hasOwnProperty.call(combine, key)) result[key] = combine[key](current, value);\n        else throw new Error(\"Config merge conflict for field \" + key);\n    }\n    for(let key in defaults)if (result[key] === undefined) result[key] = defaults[key];\n    return result;\n}\n/**\nEach range is associated with a value, which must inherit from\nthis class.\n*/ class RangeValue {\n    /**\n    Compare this value with another value. Used when comparing\n    rangesets. The default implementation compares by identity.\n    Unless you are only creating a fixed number of unique instances\n    of your value type, it is a good idea to implement this\n    properly.\n    */ eq(other) {\n        return this == other;\n    }\n    /**\n    Create a [range](https://codemirror.net/6/docs/ref/#state.Range) with this value.\n    */ range(from, to = from) {\n        return Range.create(from, to, this);\n    }\n}\nRangeValue.prototype.startSide = RangeValue.prototype.endSide = 0;\nRangeValue.prototype.point = false;\nRangeValue.prototype.mapMode = MapMode.TrackDel;\n/**\nA range associates a value with a range of positions.\n*/ class Range {\n    constructor(/**\n    The range's start position.\n    */ from, /**\n    Its end position.\n    */ to, /**\n    The value associated with this range.\n    */ value){\n        this.from = from;\n        this.to = to;\n        this.value = value;\n    }\n    /**\n    @internal\n    */ static create(from, to, value) {\n        return new Range(from, to, value);\n    }\n}\nfunction cmpRange(a, b) {\n    return a.from - b.from || a.value.startSide - b.value.startSide;\n}\nclass Chunk {\n    constructor(from, to, value, // Chunks are marked with the largest point that occurs\n    // in them (or -1 for no points), so that scans that are\n    // only interested in points (such as the\n    // heightmap-related logic) can skip range-only chunks.\n    maxPoint){\n        this.from = from;\n        this.to = to;\n        this.value = value;\n        this.maxPoint = maxPoint;\n    }\n    get length() {\n        return this.to[this.to.length - 1];\n    }\n    // Find the index of the given position and side. Use the ranges'\n    // `from` pos when `end == false`, `to` when `end == true`.\n    findIndex(pos, side, end, startAt = 0) {\n        let arr = end ? this.to : this.from;\n        for(let lo = startAt, hi = arr.length;;){\n            if (lo == hi) return lo;\n            let mid = lo + hi >> 1;\n            let diff = arr[mid] - pos || (end ? this.value[mid].endSide : this.value[mid].startSide) - side;\n            if (mid == lo) return diff >= 0 ? lo : hi;\n            if (diff >= 0) hi = mid;\n            else lo = mid + 1;\n        }\n    }\n    between(offset, from, to, f) {\n        for(let i = this.findIndex(from, -1000000000 /* C.Far */ , true), e = this.findIndex(to, 1000000000 /* C.Far */ , false, i); i < e; i++)if (f(this.from[i] + offset, this.to[i] + offset, this.value[i]) === false) return false;\n    }\n    map(offset, changes) {\n        let value = [], from = [], to = [], newPos = -1, maxPoint = -1;\n        for(let i = 0; i < this.value.length; i++){\n            let val = this.value[i], curFrom = this.from[i] + offset, curTo = this.to[i] + offset, newFrom, newTo;\n            if (curFrom == curTo) {\n                let mapped = changes.mapPos(curFrom, val.startSide, val.mapMode);\n                if (mapped == null) continue;\n                newFrom = newTo = mapped;\n                if (val.startSide != val.endSide) {\n                    newTo = changes.mapPos(curFrom, val.endSide);\n                    if (newTo < newFrom) continue;\n                }\n            } else {\n                newFrom = changes.mapPos(curFrom, val.startSide);\n                newTo = changes.mapPos(curTo, val.endSide);\n                if (newFrom > newTo || newFrom == newTo && val.startSide > 0 && val.endSide <= 0) continue;\n            }\n            if ((newTo - newFrom || val.endSide - val.startSide) < 0) continue;\n            if (newPos < 0) newPos = newFrom;\n            if (val.point) maxPoint = Math.max(maxPoint, newTo - newFrom);\n            value.push(val);\n            from.push(newFrom - newPos);\n            to.push(newTo - newPos);\n        }\n        return {\n            mapped: value.length ? new Chunk(from, to, value, maxPoint) : null,\n            pos: newPos\n        };\n    }\n}\n/**\nA range set stores a collection of [ranges](https://codemirror.net/6/docs/ref/#state.Range) in a\nway that makes them efficient to [map](https://codemirror.net/6/docs/ref/#state.RangeSet.map) and\n[update](https://codemirror.net/6/docs/ref/#state.RangeSet.update). This is an immutable data\nstructure.\n*/ class RangeSet {\n    constructor(/**\n    @internal\n    */ chunkPos, /**\n    @internal\n    */ chunk, /**\n    @internal\n    */ nextLayer, /**\n    @internal\n    */ maxPoint){\n        this.chunkPos = chunkPos;\n        this.chunk = chunk;\n        this.nextLayer = nextLayer;\n        this.maxPoint = maxPoint;\n    }\n    /**\n    @internal\n    */ static create(chunkPos, chunk, nextLayer, maxPoint) {\n        return new RangeSet(chunkPos, chunk, nextLayer, maxPoint);\n    }\n    /**\n    @internal\n    */ get length() {\n        let last = this.chunk.length - 1;\n        return last < 0 ? 0 : Math.max(this.chunkEnd(last), this.nextLayer.length);\n    }\n    /**\n    The number of ranges in the set.\n    */ get size() {\n        if (this.isEmpty) return 0;\n        let size = this.nextLayer.size;\n        for (let chunk of this.chunk)size += chunk.value.length;\n        return size;\n    }\n    /**\n    @internal\n    */ chunkEnd(index) {\n        return this.chunkPos[index] + this.chunk[index].length;\n    }\n    /**\n    Update the range set, optionally adding new ranges or filtering\n    out existing ones.\n    \n    (Note: The type parameter is just there as a kludge to work\n    around TypeScript variance issues that prevented `RangeSet<X>`\n    from being a subtype of `RangeSet<Y>` when `X` is a subtype of\n    `Y`.)\n    */ update(updateSpec) {\n        let { add = [], sort = false, filterFrom = 0, filterTo = this.length } = updateSpec;\n        let filter = updateSpec.filter;\n        if (add.length == 0 && !filter) return this;\n        if (sort) add = add.slice().sort(cmpRange);\n        if (this.isEmpty) return add.length ? RangeSet.of(add) : this;\n        let cur = new LayerCursor(this, null, -1).goto(0), i = 0, spill = [];\n        let builder = new RangeSetBuilder();\n        while(cur.value || i < add.length){\n            if (i < add.length && (cur.from - add[i].from || cur.startSide - add[i].value.startSide) >= 0) {\n                let range = add[i++];\n                if (!builder.addInner(range.from, range.to, range.value)) spill.push(range);\n            } else if (cur.rangeIndex == 1 && cur.chunkIndex < this.chunk.length && (i == add.length || this.chunkEnd(cur.chunkIndex) < add[i].from) && (!filter || filterFrom > this.chunkEnd(cur.chunkIndex) || filterTo < this.chunkPos[cur.chunkIndex]) && builder.addChunk(this.chunkPos[cur.chunkIndex], this.chunk[cur.chunkIndex])) {\n                cur.nextChunk();\n            } else {\n                if (!filter || filterFrom > cur.to || filterTo < cur.from || filter(cur.from, cur.to, cur.value)) {\n                    if (!builder.addInner(cur.from, cur.to, cur.value)) spill.push(Range.create(cur.from, cur.to, cur.value));\n                }\n                cur.next();\n            }\n        }\n        return builder.finishInner(this.nextLayer.isEmpty && !spill.length ? RangeSet.empty : this.nextLayer.update({\n            add: spill,\n            filter,\n            filterFrom,\n            filterTo\n        }));\n    }\n    /**\n    Map this range set through a set of changes, return the new set.\n    */ map(changes) {\n        if (changes.empty || this.isEmpty) return this;\n        let chunks = [], chunkPos = [], maxPoint = -1;\n        for(let i = 0; i < this.chunk.length; i++){\n            let start = this.chunkPos[i], chunk = this.chunk[i];\n            let touch = changes.touchesRange(start, start + chunk.length);\n            if (touch === false) {\n                maxPoint = Math.max(maxPoint, chunk.maxPoint);\n                chunks.push(chunk);\n                chunkPos.push(changes.mapPos(start));\n            } else if (touch === true) {\n                let { mapped, pos } = chunk.map(start, changes);\n                if (mapped) {\n                    maxPoint = Math.max(maxPoint, mapped.maxPoint);\n                    chunks.push(mapped);\n                    chunkPos.push(pos);\n                }\n            }\n        }\n        let next = this.nextLayer.map(changes);\n        return chunks.length == 0 ? next : new RangeSet(chunkPos, chunks, next || RangeSet.empty, maxPoint);\n    }\n    /**\n    Iterate over the ranges that touch the region `from` to `to`,\n    calling `f` for each. There is no guarantee that the ranges will\n    be reported in any specific order. When the callback returns\n    `false`, iteration stops.\n    */ between(from, to, f) {\n        if (this.isEmpty) return;\n        for(let i = 0; i < this.chunk.length; i++){\n            let start = this.chunkPos[i], chunk = this.chunk[i];\n            if (to >= start && from <= start + chunk.length && chunk.between(start, from - start, to - start, f) === false) return;\n        }\n        this.nextLayer.between(from, to, f);\n    }\n    /**\n    Iterate over the ranges in this set, in order, including all\n    ranges that end at or after `from`.\n    */ iter(from = 0) {\n        return HeapCursor.from([\n            this\n        ]).goto(from);\n    }\n    /**\n    @internal\n    */ get isEmpty() {\n        return this.nextLayer == this;\n    }\n    /**\n    Iterate over the ranges in a collection of sets, in order,\n    starting from `from`.\n    */ static iter(sets, from = 0) {\n        return HeapCursor.from(sets).goto(from);\n    }\n    /**\n    Iterate over two groups of sets, calling methods on `comparator`\n    to notify it of possible differences.\n    */ static compare(oldSets, newSets, /**\n    This indicates how the underlying data changed between these\n    ranges, and is needed to synchronize the iteration.\n    */ textDiff, comparator, /**\n    Can be used to ignore all non-point ranges, and points below\n    the given size. When -1, all ranges are compared.\n    */ minPointSize = -1) {\n        let a = oldSets.filter((set)=>set.maxPoint > 0 || !set.isEmpty && set.maxPoint >= minPointSize);\n        let b = newSets.filter((set)=>set.maxPoint > 0 || !set.isEmpty && set.maxPoint >= minPointSize);\n        let sharedChunks = findSharedChunks(a, b, textDiff);\n        let sideA = new SpanCursor(a, sharedChunks, minPointSize);\n        let sideB = new SpanCursor(b, sharedChunks, minPointSize);\n        textDiff.iterGaps((fromA, fromB, length)=>compare(sideA, fromA, sideB, fromB, length, comparator));\n        if (textDiff.empty && textDiff.length == 0) compare(sideA, 0, sideB, 0, 0, comparator);\n    }\n    /**\n    Compare the contents of two groups of range sets, returning true\n    if they are equivalent in the given range.\n    */ static eq(oldSets, newSets, from = 0, to) {\n        if (to == null) to = 1000000000 /* C.Far */  - 1;\n        let a = oldSets.filter((set)=>!set.isEmpty && newSets.indexOf(set) < 0);\n        let b = newSets.filter((set)=>!set.isEmpty && oldSets.indexOf(set) < 0);\n        if (a.length != b.length) return false;\n        if (!a.length) return true;\n        let sharedChunks = findSharedChunks(a, b);\n        let sideA = new SpanCursor(a, sharedChunks, 0).goto(from), sideB = new SpanCursor(b, sharedChunks, 0).goto(from);\n        for(;;){\n            if (sideA.to != sideB.to || !sameValues(sideA.active, sideB.active) || sideA.point && (!sideB.point || !sideA.point.eq(sideB.point))) return false;\n            if (sideA.to > to) return true;\n            sideA.next();\n            sideB.next();\n        }\n    }\n    /**\n    Iterate over a group of range sets at the same time, notifying\n    the iterator about the ranges covering every given piece of\n    content. Returns the open count (see\n    [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#state.SpanIterator.span)) at the end\n    of the iteration.\n    */ static spans(sets, from, to, iterator, /**\n    When given and greater than -1, only points of at least this\n    size are taken into account.\n    */ minPointSize = -1) {\n        let cursor = new SpanCursor(sets, null, minPointSize).goto(from), pos = from;\n        let openRanges = cursor.openStart;\n        for(;;){\n            let curTo = Math.min(cursor.to, to);\n            if (cursor.point) {\n                let active = cursor.activeForPoint(cursor.to);\n                let openCount = cursor.pointFrom < from ? active.length + 1 : Math.min(active.length, openRanges);\n                iterator.point(pos, curTo, cursor.point, active, openCount, cursor.pointRank);\n                openRanges = Math.min(cursor.openEnd(curTo), active.length);\n            } else if (curTo > pos) {\n                iterator.span(pos, curTo, cursor.active, openRanges);\n                openRanges = cursor.openEnd(curTo);\n            }\n            if (cursor.to > to) return openRanges + (cursor.point && cursor.to > to ? 1 : 0);\n            pos = cursor.to;\n            cursor.next();\n        }\n    }\n    /**\n    Create a range set for the given range or array of ranges. By\n    default, this expects the ranges to be _sorted_ (by start\n    position and, if two start at the same position,\n    `value.startSide`). You can pass `true` as second argument to\n    cause the method to sort them.\n    */ static of(ranges, sort = false) {\n        let build = new RangeSetBuilder();\n        for (let range of ranges instanceof Range ? [\n            ranges\n        ] : sort ? lazySort(ranges) : ranges)build.add(range.from, range.to, range.value);\n        return build.finish();\n    }\n}\n/**\nThe empty set of ranges.\n*/ RangeSet.empty = /*@__PURE__*/ new RangeSet([], [], null, -1);\nfunction lazySort(ranges) {\n    if (ranges.length > 1) for(let prev = ranges[0], i = 1; i < ranges.length; i++){\n        let cur = ranges[i];\n        if (cmpRange(prev, cur) > 0) return ranges.slice().sort(cmpRange);\n        prev = cur;\n    }\n    return ranges;\n}\nRangeSet.empty.nextLayer = RangeSet.empty;\n/**\nA range set builder is a data structure that helps build up a\n[range set](https://codemirror.net/6/docs/ref/#state.RangeSet) directly, without first allocating\nan array of [`Range`](https://codemirror.net/6/docs/ref/#state.Range) objects.\n*/ class RangeSetBuilder {\n    finishChunk(newArrays) {\n        this.chunks.push(new Chunk(this.from, this.to, this.value, this.maxPoint));\n        this.chunkPos.push(this.chunkStart);\n        this.chunkStart = -1;\n        this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint);\n        this.maxPoint = -1;\n        if (newArrays) {\n            this.from = [];\n            this.to = [];\n            this.value = [];\n        }\n    }\n    /**\n    Create an empty builder.\n    */ constructor(){\n        this.chunks = [];\n        this.chunkPos = [];\n        this.chunkStart = -1;\n        this.last = null;\n        this.lastFrom = -1000000000 /* C.Far */ ;\n        this.lastTo = -1000000000 /* C.Far */ ;\n        this.from = [];\n        this.to = [];\n        this.value = [];\n        this.maxPoint = -1;\n        this.setMaxPoint = -1;\n        this.nextLayer = null;\n    }\n    /**\n    Add a range. Ranges should be added in sorted (by `from` and\n    `value.startSide`) order.\n    */ add(from, to, value) {\n        if (!this.addInner(from, to, value)) (this.nextLayer || (this.nextLayer = new RangeSetBuilder)).add(from, to, value);\n    }\n    /**\n    @internal\n    */ addInner(from, to, value) {\n        let diff = from - this.lastTo || value.startSide - this.last.endSide;\n        if (diff <= 0 && (from - this.lastFrom || value.startSide - this.last.startSide) < 0) throw new Error(\"Ranges must be added sorted by `from` position and `startSide`\");\n        if (diff < 0) return false;\n        if (this.from.length == 250 /* C.ChunkSize */ ) this.finishChunk(true);\n        if (this.chunkStart < 0) this.chunkStart = from;\n        this.from.push(from - this.chunkStart);\n        this.to.push(to - this.chunkStart);\n        this.last = value;\n        this.lastFrom = from;\n        this.lastTo = to;\n        this.value.push(value);\n        if (value.point) this.maxPoint = Math.max(this.maxPoint, to - from);\n        return true;\n    }\n    /**\n    @internal\n    */ addChunk(from, chunk) {\n        if ((from - this.lastTo || chunk.value[0].startSide - this.last.endSide) < 0) return false;\n        if (this.from.length) this.finishChunk(true);\n        this.setMaxPoint = Math.max(this.setMaxPoint, chunk.maxPoint);\n        this.chunks.push(chunk);\n        this.chunkPos.push(from);\n        let last = chunk.value.length - 1;\n        this.last = chunk.value[last];\n        this.lastFrom = chunk.from[last] + from;\n        this.lastTo = chunk.to[last] + from;\n        return true;\n    }\n    /**\n    Finish the range set. Returns the new set. The builder can't be\n    used anymore after this has been called.\n    */ finish() {\n        return this.finishInner(RangeSet.empty);\n    }\n    /**\n    @internal\n    */ finishInner(next) {\n        if (this.from.length) this.finishChunk(false);\n        if (this.chunks.length == 0) return next;\n        let result = RangeSet.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(next) : next, this.setMaxPoint);\n        this.from = null; // Make sure further `add` calls produce errors\n        return result;\n    }\n}\nfunction findSharedChunks(a, b, textDiff) {\n    let inA = new Map();\n    for (let set of a)for(let i = 0; i < set.chunk.length; i++)if (set.chunk[i].maxPoint <= 0) inA.set(set.chunk[i], set.chunkPos[i]);\n    let shared = new Set();\n    for (let set of b)for(let i = 0; i < set.chunk.length; i++){\n        let known = inA.get(set.chunk[i]);\n        if (known != null && (textDiff ? textDiff.mapPos(known) : known) == set.chunkPos[i] && !(textDiff === null || textDiff === void 0 ? void 0 : textDiff.touchesRange(known, known + set.chunk[i].length))) shared.add(set.chunk[i]);\n    }\n    return shared;\n}\nclass LayerCursor {\n    constructor(layer, skip, minPoint, rank = 0){\n        this.layer = layer;\n        this.skip = skip;\n        this.minPoint = minPoint;\n        this.rank = rank;\n    }\n    get startSide() {\n        return this.value ? this.value.startSide : 0;\n    }\n    get endSide() {\n        return this.value ? this.value.endSide : 0;\n    }\n    goto(pos, side = -1000000000 /* C.Far */ ) {\n        this.chunkIndex = this.rangeIndex = 0;\n        this.gotoInner(pos, side, false);\n        return this;\n    }\n    gotoInner(pos, side, forward) {\n        while(this.chunkIndex < this.layer.chunk.length){\n            let next = this.layer.chunk[this.chunkIndex];\n            if (!(this.skip && this.skip.has(next) || this.layer.chunkEnd(this.chunkIndex) < pos || next.maxPoint < this.minPoint)) break;\n            this.chunkIndex++;\n            forward = false;\n        }\n        if (this.chunkIndex < this.layer.chunk.length) {\n            let rangeIndex = this.layer.chunk[this.chunkIndex].findIndex(pos - this.layer.chunkPos[this.chunkIndex], side, true);\n            if (!forward || this.rangeIndex < rangeIndex) this.setRangeIndex(rangeIndex);\n        }\n        this.next();\n    }\n    forward(pos, side) {\n        if ((this.to - pos || this.endSide - side) < 0) this.gotoInner(pos, side, true);\n    }\n    next() {\n        for(;;){\n            if (this.chunkIndex == this.layer.chunk.length) {\n                this.from = this.to = 1000000000 /* C.Far */ ;\n                this.value = null;\n                break;\n            } else {\n                let chunkPos = this.layer.chunkPos[this.chunkIndex], chunk = this.layer.chunk[this.chunkIndex];\n                let from = chunkPos + chunk.from[this.rangeIndex];\n                this.from = from;\n                this.to = chunkPos + chunk.to[this.rangeIndex];\n                this.value = chunk.value[this.rangeIndex];\n                this.setRangeIndex(this.rangeIndex + 1);\n                if (this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint) break;\n            }\n        }\n    }\n    setRangeIndex(index) {\n        if (index == this.layer.chunk[this.chunkIndex].value.length) {\n            this.chunkIndex++;\n            if (this.skip) {\n                while(this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]))this.chunkIndex++;\n            }\n            this.rangeIndex = 0;\n        } else {\n            this.rangeIndex = index;\n        }\n    }\n    nextChunk() {\n        this.chunkIndex++;\n        this.rangeIndex = 0;\n        this.next();\n    }\n    compare(other) {\n        return this.from - other.from || this.startSide - other.startSide || this.rank - other.rank || this.to - other.to || this.endSide - other.endSide;\n    }\n}\nclass HeapCursor {\n    constructor(heap){\n        this.heap = heap;\n    }\n    static from(sets, skip = null, minPoint = -1) {\n        let heap = [];\n        for(let i = 0; i < sets.length; i++){\n            for(let cur = sets[i]; !cur.isEmpty; cur = cur.nextLayer){\n                if (cur.maxPoint >= minPoint) heap.push(new LayerCursor(cur, skip, minPoint, i));\n            }\n        }\n        return heap.length == 1 ? heap[0] : new HeapCursor(heap);\n    }\n    get startSide() {\n        return this.value ? this.value.startSide : 0;\n    }\n    goto(pos, side = -1000000000 /* C.Far */ ) {\n        for (let cur of this.heap)cur.goto(pos, side);\n        for(let i = this.heap.length >> 1; i >= 0; i--)heapBubble(this.heap, i);\n        this.next();\n        return this;\n    }\n    forward(pos, side) {\n        for (let cur of this.heap)cur.forward(pos, side);\n        for(let i = this.heap.length >> 1; i >= 0; i--)heapBubble(this.heap, i);\n        if ((this.to - pos || this.value.endSide - side) < 0) this.next();\n    }\n    next() {\n        if (this.heap.length == 0) {\n            this.from = this.to = 1000000000 /* C.Far */ ;\n            this.value = null;\n            this.rank = -1;\n        } else {\n            let top = this.heap[0];\n            this.from = top.from;\n            this.to = top.to;\n            this.value = top.value;\n            this.rank = top.rank;\n            if (top.value) top.next();\n            heapBubble(this.heap, 0);\n        }\n    }\n}\nfunction heapBubble(heap, index) {\n    for(let cur = heap[index];;){\n        let childIndex = (index << 1) + 1;\n        if (childIndex >= heap.length) break;\n        let child = heap[childIndex];\n        if (childIndex + 1 < heap.length && child.compare(heap[childIndex + 1]) >= 0) {\n            child = heap[childIndex + 1];\n            childIndex++;\n        }\n        if (cur.compare(child) < 0) break;\n        heap[childIndex] = cur;\n        heap[index] = child;\n        index = childIndex;\n    }\n}\nclass SpanCursor {\n    constructor(sets, skip, minPoint){\n        this.minPoint = minPoint;\n        this.active = [];\n        this.activeTo = [];\n        this.activeRank = [];\n        this.minActive = -1;\n        // A currently active point range, if any\n        this.point = null;\n        this.pointFrom = 0;\n        this.pointRank = 0;\n        this.to = -1000000000 /* C.Far */ ;\n        this.endSide = 0;\n        // The amount of open active ranges at the start of the iterator.\n        // Not including points.\n        this.openStart = -1;\n        this.cursor = HeapCursor.from(sets, skip, minPoint);\n    }\n    goto(pos, side = -1000000000 /* C.Far */ ) {\n        this.cursor.goto(pos, side);\n        this.active.length = this.activeTo.length = this.activeRank.length = 0;\n        this.minActive = -1;\n        this.to = pos;\n        this.endSide = side;\n        this.openStart = -1;\n        this.next();\n        return this;\n    }\n    forward(pos, side) {\n        while(this.minActive > -1 && (this.activeTo[this.minActive] - pos || this.active[this.minActive].endSide - side) < 0)this.removeActive(this.minActive);\n        this.cursor.forward(pos, side);\n    }\n    removeActive(index) {\n        remove(this.active, index);\n        remove(this.activeTo, index);\n        remove(this.activeRank, index);\n        this.minActive = findMinIndex(this.active, this.activeTo);\n    }\n    addActive(trackOpen) {\n        let i = 0, { value, to, rank } = this.cursor;\n        while(i < this.activeRank.length && this.activeRank[i] <= rank)i++;\n        insert(this.active, i, value);\n        insert(this.activeTo, i, to);\n        insert(this.activeRank, i, rank);\n        if (trackOpen) insert(trackOpen, i, this.cursor.from);\n        this.minActive = findMinIndex(this.active, this.activeTo);\n    }\n    // After calling this, if `this.point` != null, the next range is a\n    // point. Otherwise, it's a regular range, covered by `this.active`.\n    next() {\n        let from = this.to, wasPoint = this.point;\n        this.point = null;\n        let trackOpen = this.openStart < 0 ? [] : null;\n        for(;;){\n            let a = this.minActive;\n            if (a > -1 && (this.activeTo[a] - this.cursor.from || this.active[a].endSide - this.cursor.startSide) < 0) {\n                if (this.activeTo[a] > from) {\n                    this.to = this.activeTo[a];\n                    this.endSide = this.active[a].endSide;\n                    break;\n                }\n                this.removeActive(a);\n                if (trackOpen) remove(trackOpen, a);\n            } else if (!this.cursor.value) {\n                this.to = this.endSide = 1000000000 /* C.Far */ ;\n                break;\n            } else if (this.cursor.from > from) {\n                this.to = this.cursor.from;\n                this.endSide = this.cursor.startSide;\n                break;\n            } else {\n                let nextVal = this.cursor.value;\n                if (!nextVal.point) {\n                    this.addActive(trackOpen);\n                    this.cursor.next();\n                } else if (wasPoint && this.cursor.to == this.to && this.cursor.from < this.cursor.to) {\n                    // Ignore any non-empty points that end precisely at the end of the prev point\n                    this.cursor.next();\n                } else {\n                    this.point = nextVal;\n                    this.pointFrom = this.cursor.from;\n                    this.pointRank = this.cursor.rank;\n                    this.to = this.cursor.to;\n                    this.endSide = nextVal.endSide;\n                    this.cursor.next();\n                    this.forward(this.to, this.endSide);\n                    break;\n                }\n            }\n        }\n        if (trackOpen) {\n            this.openStart = 0;\n            for(let i = trackOpen.length - 1; i >= 0 && trackOpen[i] < from; i--)this.openStart++;\n        }\n    }\n    activeForPoint(to) {\n        if (!this.active.length) return this.active;\n        let active = [];\n        for(let i = this.active.length - 1; i >= 0; i--){\n            if (this.activeRank[i] < this.pointRank) break;\n            if (this.activeTo[i] > to || this.activeTo[i] == to && this.active[i].endSide >= this.point.endSide) active.push(this.active[i]);\n        }\n        return active.reverse();\n    }\n    openEnd(to) {\n        let open = 0;\n        for(let i = this.activeTo.length - 1; i >= 0 && this.activeTo[i] > to; i--)open++;\n        return open;\n    }\n}\nfunction compare(a, startA, b, startB, length, comparator) {\n    a.goto(startA);\n    b.goto(startB);\n    let endB = startB + length;\n    let pos = startB, dPos = startB - startA;\n    for(;;){\n        let diff = a.to + dPos - b.to || a.endSide - b.endSide;\n        let end = diff < 0 ? a.to + dPos : b.to, clipEnd = Math.min(end, endB);\n        if (a.point || b.point) {\n            if (!(a.point && b.point && (a.point == b.point || a.point.eq(b.point)) && sameValues(a.activeForPoint(a.to), b.activeForPoint(b.to)))) comparator.comparePoint(pos, clipEnd, a.point, b.point);\n        } else {\n            if (clipEnd > pos && !sameValues(a.active, b.active)) comparator.compareRange(pos, clipEnd, a.active, b.active);\n        }\n        if (end > endB) break;\n        pos = end;\n        if (diff <= 0) a.next();\n        if (diff >= 0) b.next();\n    }\n}\nfunction sameValues(a, b) {\n    if (a.length != b.length) return false;\n    for(let i = 0; i < a.length; i++)if (a[i] != b[i] && !a[i].eq(b[i])) return false;\n    return true;\n}\nfunction remove(array, index) {\n    for(let i = index, e = array.length - 1; i < e; i++)array[i] = array[i + 1];\n    array.pop();\n}\nfunction insert(array, index, value) {\n    for(let i = array.length - 1; i >= index; i--)array[i + 1] = array[i];\n    array[index] = value;\n}\nfunction findMinIndex(value, array) {\n    let found = -1, foundPos = 1000000000 /* C.Far */ ;\n    for(let i = 0; i < array.length; i++)if ((array[i] - foundPos || value[i].endSide - value[found].endSide) < 0) {\n        found = i;\n        foundPos = array[i];\n    }\n    return found;\n}\n/**\nCount the column position at the given offset into the string,\ntaking extending characters and tab size into account.\n*/ function countColumn(string, tabSize, to = string.length) {\n    let n = 0;\n    for(let i = 0; i < to;){\n        if (string.charCodeAt(i) == 9) {\n            n += tabSize - n % tabSize;\n            i++;\n        } else {\n            n++;\n            i = findClusterBreak(string, i);\n        }\n    }\n    return n;\n}\n/**\nFind the offset that corresponds to the given column position in a\nstring, taking extending characters and tab size into account. By\ndefault, the string length is returned when it is too short to\nreach the column. Pass `strict` true to make it return -1 in that\nsituation.\n*/ function findColumn(string, col, tabSize, strict) {\n    for(let i = 0, n = 0;;){\n        if (n >= col) return i;\n        if (i == string.length) break;\n        n += string.charCodeAt(i) == 9 ? tabSize - n % tabSize : 1;\n        i = findClusterBreak(string, i);\n    }\n    return strict === true ? -1 : string.length;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3Ivc3RhdGUvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOztBQUVBLEdBQ0EsTUFBTUE7SUFDRjs7SUFFQSxHQUNBQyxPQUFPQyxHQUFHLEVBQUU7UUFDUixJQUFJQSxNQUFNLEtBQUtBLE1BQU0sSUFBSSxDQUFDQyxNQUFNLEVBQzVCLE1BQU0sSUFBSUMsV0FBVyxDQUFDLGlCQUFpQixFQUFFRixJQUFJLHVCQUF1QixFQUFFLElBQUksQ0FBQ0MsTUFBTSxDQUFDLENBQUM7UUFDdkYsT0FBTyxJQUFJLENBQUNFLFNBQVMsQ0FBQ0gsS0FBSyxPQUFPLEdBQUc7SUFDekM7SUFDQTs7SUFFQSxHQUNBSSxLQUFLQyxDQUFDLEVBQUU7UUFDSixJQUFJQSxJQUFJLEtBQUtBLElBQUksSUFBSSxDQUFDQyxLQUFLLEVBQ3ZCLE1BQU0sSUFBSUosV0FBVyxDQUFDLG9CQUFvQixFQUFFRyxFQUFFLElBQUksRUFBRSxJQUFJLENBQUNDLEtBQUssQ0FBQyxjQUFjLENBQUM7UUFDbEYsT0FBTyxJQUFJLENBQUNILFNBQVMsQ0FBQ0UsR0FBRyxNQUFNLEdBQUc7SUFDdEM7SUFDQTs7SUFFQSxHQUNBRSxRQUFRQyxJQUFJLEVBQUVDLEVBQUUsRUFBRUMsSUFBSSxFQUFFO1FBQ3BCLElBQUlDLFFBQVEsRUFBRTtRQUNkLElBQUksQ0FBQ0MsU0FBUyxDQUFDLEdBQUdKLE1BQU1HLE9BQU8sRUFBRSxXQUFXO1FBQzVDLElBQUlELEtBQUtULE1BQU0sRUFDWFMsS0FBS0UsU0FBUyxDQUFDLEdBQUdGLEtBQUtULE1BQU0sRUFBRVUsT0FBTyxFQUFFLGFBQWEsTUFBSyxFQUFFLFdBQVc7UUFDM0UsSUFBSSxDQUFDQyxTQUFTLENBQUNILElBQUksSUFBSSxDQUFDUixNQUFNLEVBQUVVLE9BQU8sRUFBRSxhQUFhO1FBQ3RELE9BQU9FLFNBQVNMLElBQUksQ0FBQ0csT0FB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QU8rRTtBQUNYO0FBRUE7OztBQUdBLEdBQ0EsU0FBU3liLFlBQVl2Z0IsTUFBTSxFQUFFMFksT0FBTyxFQUFFdGIsS0FBSzRDLE9BQU9wRCxNQUFNO0lBQ3BELElBQUlJLElBQUk7SUFDUixJQUFLLElBQUkrQyxJQUFJLEdBQUdBLElBQUkzQyxJQUFLO1FBQ3JCLElBQUk0QyxPQUFPeUUsVUFBVSxDQUFDMUUsTUFBTSxHQUFHO1lBQzNCL0MsS0FBSzBiLFVBQVcxYixJQUFJMGI7WUFDcEIzWTtRQUNKLE9BQ0s7WUFDRC9DO1lBQ0ErQyxJQUFJbUUsaUJBQWlCbEUsUUFBUUQ7UUFDakM7SUFDSjtJQUNBLE9BQU8vQztBQUNYO0FBQ0E7Ozs7OztBQU1BLEdBQ0EsU0FBU3dqQixXQUFXeGdCLE1BQU0sRUFBRXlnQixHQUFHLEVBQUUvSCxPQUFPLEVBQUVnSSxNQUFNO0lBQzVDLElBQUssSUFBSTNnQixJQUFJLEdBQUcvQyxJQUFJLElBQUs7UUFDckIsSUFBSUEsS0FBS3lqQixLQUNMLE9BQU8xZ0I7UUFDWCxJQUFJQSxLQUFLQyxPQUFPcEQsTUFBTSxFQUNsQjtRQUNKSSxLQUFLZ0QsT0FBT3lFLFVBQVUsQ0FBQzFFLE1BQU0sSUFBSTJZLFVBQVcxYixJQUFJMGIsVUFBVztRQUMzRDNZLElBQUltRSxpQkFBaUJsRSxRQUFRRDtJQUNqQztJQUNBLE9BQU8yZ0IsV0FBVyxPQUFPLENBQUMsSUFBSTFnQixPQUFPcEQsTUFBTTtBQUMvQztBQUVrWCIsInNvdXJjZXMiOlsid2VicGFjazovL3B5dGhvbi1vbmxpbmUtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL3N0YXRlL2Rpc3QvaW5kZXguanM/OGM4YSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcblRoZSBkYXRhIHN0cnVjdHVyZSBmb3IgZG9jdW1lbnRzLiBAbm9uYWJzdHJhY3RcbiovXG5jbGFzcyBUZXh0IHtcbiAgICAvKipcbiAgICBHZXQgdGhlIGxpbmUgZGVzY3JpcHRpb24gYXJvdW5kIHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAgICAqL1xuICAgIGxpbmVBdChwb3MpIHtcbiAgICAgICAgaWYgKHBvcyA8IDAgfHwgcG9zID4gdGhpcy5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgSW52YWxpZCBwb3NpdGlvbiAke3Bvc30gaW4gZG9jdW1lbnQgb2YgbGVuZ3RoICR7dGhpcy5sZW5ndGh9YCk7XG4gICAgICAgIHJldHVybiB0aGlzLmxpbmVJbm5lcihwb3MsIGZhbHNlLCAxLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBkZXNjcmlwdGlvbiBmb3IgdGhlIGdpdmVuICgxLWJhc2VkKSBsaW5lIG51bWJlci5cbiAgICAqL1xuICAgIGxpbmUobikge1xuICAgICAgICBpZiAobiA8IDEgfHwgbiA+IHRoaXMubGluZXMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgSW52YWxpZCBsaW5lIG51bWJlciAke259IGluICR7dGhpcy5saW5lc30tbGluZSBkb2N1bWVudGApO1xuICAgICAgICByZXR1cm4gdGhpcy5saW5lSW5uZXIobiwgdHJ1ZSwgMSwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlcGxhY2UgYSByYW5nZSBvZiB0aGUgdGV4dCB3aXRoIHRoZSBnaXZlbiBjb250ZW50LlxuICAgICovXG4gICAgcmVwbGFjZShmcm9tLCB0bywgdGV4dCkge1xuICAgICAgICBsZXQgcGFydHMgPSBbXTtcbiAgICAgICAgdGhpcy5kZWNvbXBvc2UoMCwgZnJvbSwgcGFydHMsIDIgLyogT3Blbi5UbyAqLyk7XG4gICAgICAgIGlmICh0ZXh0Lmxlbmd0aClcbiAgICAgICAgICAgIHRleHQuZGVjb21wb3NlKDAsIHRleHQubGVuZ3RoLCBwYXJ0cywgMSAvKiBPcGVuLkZyb20gKi8gfCAyIC8qIE9wZW4uVG8gKi8pO1xuICAgICAgICB0aGlzLmRlY29tcG9zZSh0bywgdGhpcy5sZW5ndGgsIHBhcnRzLCAxIC8qIE9wZW4uRnJvbSAqLyk7XG4gICAgICAgIHJldHVybiBUZXh0Tm9kZS5mcm9tKHBhcnRzLCB0aGlzLmxlbmd0aCAtICh0byAtIGZyb20pICsgdGV4dC5sZW5ndGgpO1xuICAgIH1cbiAgICAvKipcbiAgICBBcHBlbmQgYW5vdGhlciBkb2N1bWVudCB0byB0aGlzIG9uZS5cbiAgICAqL1xuICAgIGFwcGVuZChvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXBsYWNlKHRoaXMubGVuZ3RoLCB0aGlzLmxlbmd0aCwgb3RoZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXRyaWV2ZSB0aGUgdGV4dCBiZXR3ZWVuIHRoZSBnaXZlbiBwb2ludHMuXG4gICAgKi9cbiAgICBzbGljZShmcm9tLCB0byA9IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgIGxldCBwYXJ0cyA9IFtdO1xuICAgICAgICB0aGlzLmRlY29tcG9zZShmcm9tLCB0bywgcGFydHMsIDApO1xuICAgICAgICByZXR1cm4gVGV4dE5vZGUuZnJvbShwYXJ0cywgdG8gLSBmcm9tKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGVzdCB3aGV0aGVyIHRoaXMgdGV4dCBpcyBlcXVhbCB0byBhbm90aGVyIGluc3RhbmNlLlxuICAgICovXG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgaWYgKG90aGVyID09IHRoaXMpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKG90aGVyLmxlbmd0aCAhPSB0aGlzLmxlbmd0aCB8fCBvdGhlci5saW5lcyAhPSB0aGlzLmxpbmVzKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLnNjYW5JZGVudGljYWwob3RoZXIsIDEpLCBlbmQgPSB0aGlzLmxlbmd0aCAtIHRoaXMuc2NhbklkZW50aWNhbChvdGhlciwgLTEpO1xuICAgICAgICBsZXQgYSA9IG5ldyBSYXdUZXh0Q3Vyc29yKHRoaXMpLCBiID0gbmV3IFJhd1RleHRDdXJzb3Iob3RoZXIpO1xuICAgICAgICBmb3IgKGxldCBza2lwID0gc3RhcnQsIHBvcyA9IHN0YXJ0OzspIHtcbiAgICAgICAgICAgIGEubmV4dChza2lwKTtcbiAgICAgICAgICAgIGIubmV4dChza2lwKTtcbiAgICAgICAgICAgIHNraXAgPSAwO1xuICAgICAgICAgICAgaWYgKGEubGluZUJyZWFrICE9IGIubGluZUJyZWFrIHx8IGEuZG9uZSAhPSBiLmRvbmUgfHwgYS52YWx1ZSAhPSBiLnZhbHVlKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHBvcyArPSBhLnZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChhLmRvbmUgfHwgcG9zID49IGVuZClcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBJdGVyYXRlIG92ZXIgdGhlIHRleHQuIFdoZW4gYGRpcmAgaXMgYC0xYCwgaXRlcmF0aW9uIGhhcHBlbnNcbiAgICBmcm9tIGVuZCB0byBzdGFydC4gVGhpcyB3aWxsIHJldHVybiBsaW5lcyBhbmQgdGhlIGJyZWFrcyBiZXR3ZWVuXG4gICAgdGhlbSBhcyBzZXBhcmF0ZSBzdHJpbmdzLlxuICAgICovXG4gICAgaXRlcihkaXIgPSAxKSB7IHJldHVybiBuZXcgUmF3VGV4dEN1cnNvcih0aGlzLCBkaXIpOyB9XG4gICAgLyoqXG4gICAgSXRlcmF0ZSBvdmVyIGEgcmFuZ2Ugb2YgdGhlIHRleHQuIFdoZW4gYGZyb21gID4gYHRvYCwgdGhlXG4gICAgaXRlcmF0b3Igd2lsbCBydW4gaW4gcmV2ZXJzZS5cbiAgICAqL1xuICAgIGl0ZXJSYW5nZShmcm9tLCB0byA9IHRoaXMubGVuZ3RoKSB7IHJldHVybiBuZXcgUGFydGlhbFRleHRDdXJzb3IodGhpcywgZnJvbSwgdG8pOyB9XG4gICAgLyoqXG4gICAgUmV0dXJuIGEgY3Vyc29yIHRoYXQgaXRlcmF0ZXMgb3ZlciB0aGUgZ2l2ZW4gcmFuZ2Ugb2YgbGluZXMsXG4gICAgX3dpdGhvdXRfIHJldHVybmluZyB0aGUgbGluZSBicmVha3MgYmV0d2VlbiwgYW5kIHlpZWxkaW5nIGVtcHR5XG4gICAgc3RyaW5ncyBmb3IgZW1wdHkgbGluZXMuXG4gICAgXG4gICAgV2hlbiBgZnJvbWAgYW5kIGB0b2AgYXJlIGdpdmVuLCB0aGV5IHNob3VsZCBiZSAxLWJhc2VkIGxpbmUgbnVtYmVycy5cbiAgICAqL1xuICAgIGl0ZXJMaW5lcyhmcm9tLCB0bykge1xuICAgICAgICBsZXQgaW5uZXI7XG4gICAgICAgIGlmIChmcm9tID09IG51bGwpIHtcbiAgICAgICAgICAgIGlubmVyID0gdGhpcy5pdGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodG8gPT0gbnVsbClcbiAgICAgICAgICAgICAgICB0byA9IHRoaXMubGluZXMgKyAxO1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5saW5lKGZyb20pLmZyb207XG4gICAgICAgICAgICBpbm5lciA9IHRoaXMuaXRlclJhbmdlKHN0YXJ0LCBNYXRoLm1heChzdGFydCwgdG8gPT0gdGhpcy5saW5lcyArIDEgPyB0aGlzLmxlbmd0aCA6IHRvIDw9IDEgPyAwIDogdGhpcy5saW5lKHRvIC0gMSkudG8pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IExpbmVDdXJzb3IoaW5uZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm4gdGhlIGRvY3VtZW50IGFzIGEgc3RyaW5nLCB1c2luZyBuZXdsaW5lIGNoYXJhY3RlcnMgdG9cbiAgICBzZXBhcmF0ZSBsaW5lcy5cbiAgICAqL1xuICAgIHRvU3RyaW5nKCkgeyByZXR1cm4gdGhpcy5zbGljZVN0cmluZygwKTsgfVxuICAgIC8qKlxuICAgIENvbnZlcnQgdGhlIGRvY3VtZW50IHRvIGFuIGFycmF5IG9mIGxpbmVzICh3aGljaCBjYW4gYmVcbiAgICBkZXNlcmlhbGl6ZWQgYWdhaW4gdmlhIFtgVGV4dC5vZmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVGV4dF5vZikpLlxuICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBsZXQgbGluZXMgPSBbXTtcbiAgICAgICAgdGhpcy5mbGF0dGVuKGxpbmVzKTtcbiAgICAgICAgcmV0dXJuIGxpbmVzO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkgeyB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgYFRleHRgIGluc3RhbmNlIGZvciB0aGUgZ2l2ZW4gYXJyYXkgb2YgbGluZXMuXG4gICAgKi9cbiAgICBzdGF0aWMgb2YodGV4dCkge1xuICAgICAgICBpZiAodGV4dC5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQSBkb2N1bWVudCBtdXN0IGhhdmUgYXQgbGVhc3Qgb25lIGxpbmVcIik7XG4gICAgICAgIGlmICh0ZXh0Lmxlbmd0aCA9PSAxICYmICF0ZXh0WzBdKVxuICAgICAgICAgICAgcmV0dXJuIFRleHQuZW1wdHk7XG4gICAgICAgIHJldHVybiB0ZXh0Lmxlbmd0aCA8PSAzMiAvKiBUcmVlLkJyYW5jaCAqLyA/IG5ldyBUZXh0TGVhZih0ZXh0KSA6IFRleHROb2RlLmZyb20oVGV4dExlYWYuc3BsaXQodGV4dCwgW10pKTtcbiAgICB9XG59XG4vLyBMZWF2ZXMgc3RvcmUgYW4gYXJyYXkgb2YgbGluZSBzdHJpbmdzLiBUaGVyZSBhcmUgYWx3YXlzIGxpbmUgYnJlYWtzXG4vLyBiZXR3ZWVuIHRoZXNlIHN0cmluZ3MuIExlYXZlcyBhcmUgbGltaXRlZCBpbiBzaXplIGFuZCBoYXZlIHRvIGJlXG4vLyBjb250YWluZWQgaW4gVGV4dE5vZGUgaW5zdGFuY2VzIGZvciBiaWdnZXIgZG9jdW1lbnRzLlxuY2xhc3MgVGV4dExlYWYgZXh0ZW5kcyBUZXh0IHtcbiAgICBjb25zdHJ1Y3Rvcih0ZXh0LCBsZW5ndGggPSB0ZXh0TGVuZ3RoKHRleHQpKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgIH1cbiAgICBnZXQgbGluZXMoKSB7IHJldHVybiB0aGlzLnRleHQubGVuZ3RoOyB9XG4gICAgZ2V0IGNoaWxkcmVuKCkgeyByZXR1cm4gbnVsbDsgfVxuICAgIGxpbmVJbm5lcih0YXJnZXQsIGlzTGluZSwgbGluZSwgb2Zmc2V0KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgc3RyaW5nID0gdGhpcy50ZXh0W2ldLCBlbmQgPSBvZmZzZXQgKyBzdHJpbmcubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKChpc0xpbmUgPyBsaW5lIDogZW5kKSA+PSB0YXJnZXQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBMaW5lKG9mZnNldCwgZW5kLCBsaW5lLCBzdHJpbmcpO1xuICAgICAgICAgICAgb2Zmc2V0ID0gZW5kICsgMTtcbiAgICAgICAgICAgIGxpbmUrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZWNvbXBvc2UoZnJvbSwgdG8sIHRhcmdldCwgb3Blbikge1xuICAgICAgICBsZXQgdGV4dCA9IGZyb20gPD0gMCAmJiB0byA+PSB0aGlzLmxlbmd0aCA/IHRoaXNcbiAgICAgICAgICAgIDogbmV3IFRleHRMZWFmKHNsaWNlVGV4dCh0aGlzLnRleHQsIGZyb20sIHRvKSwgTWF0aC5taW4odG8sIHRoaXMubGVuZ3RoKSAtIE1hdGgubWF4KDAsIGZyb20pKTtcbiAgICAgICAgaWYgKG9wZW4gJiAxIC8qIE9wZW4uRnJvbSAqLykge1xuICAgICAgICAgICAgbGV0IHByZXYgPSB0YXJnZXQucG9wKCk7XG4gICAgICAgICAgICBsZXQgam9pbmVkID0gYXBwZW5kVGV4dCh0ZXh0LnRleHQsIHByZXYudGV4dC5zbGljZSgpLCAwLCB0ZXh0Lmxlbmd0aCk7XG4gICAgICAgICAgICBpZiAoam9pbmVkLmxlbmd0aCA8PSAzMiAvKiBUcmVlLkJyYW5jaCAqLykge1xuICAgICAgICAgICAgICAgIHRhcmdldC5wdXNoKG5ldyBUZXh0TGVhZihqb2luZWQsIHByZXYubGVuZ3RoICsgdGV4dC5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBtaWQgPSBqb2luZWQubGVuZ3RoID4+IDE7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnB1c2gobmV3IFRleHRMZWFmKGpvaW5lZC5zbGljZSgwLCBtaWQpKSwgbmV3IFRleHRMZWFmKGpvaW5lZC5zbGljZShtaWQpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0YXJnZXQucHVzaCh0ZXh0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXBsYWNlKGZyb20sIHRvLCB0ZXh0KSB7XG4gICAgICAgIGlmICghKHRleHQgaW5zdGFuY2VvZiBUZXh0TGVhZikpXG4gICAgICAgICAgICByZXR1cm4gc3VwZXIucmVwbGFjZShmcm9tLCB0bywgdGV4dCk7XG4gICAgICAgIGxldCBsaW5lcyA9IGFwcGVuZFRleHQodGhpcy50ZXh0LCBhcHBlbmRUZXh0KHRleHQudGV4dCwgc2xpY2VUZXh0KHRoaXMudGV4dCwgMCwgZnJvbSkpLCB0byk7XG4gICAgICAgIGxldCBuZXdMZW4gPSB0aGlzLmxlbmd0aCArIHRleHQubGVuZ3RoIC0gKHRvIC0gZnJvbSk7XG4gICAgICAgIGlmIChsaW5lcy5sZW5ndGggPD0gMzIgLyogVHJlZS5CcmFuY2ggKi8pXG4gICAgICAgICAgICByZXR1cm4gbmV3IFRleHRMZWFmKGxpbmVzLCBuZXdMZW4pO1xuICAgICAgICByZXR1cm4gVGV4dE5vZGUuZnJvbShUZXh0TGVhZi5zcGxpdChsaW5lcywgW10pLCBuZXdMZW4pO1xuICAgIH1cbiAgICBzbGljZVN0cmluZyhmcm9tLCB0byA9IHRoaXMubGVuZ3RoLCBsaW5lU2VwID0gXCJcXG5cIikge1xuICAgICAgICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMCwgaSA9IDA7IHBvcyA8PSB0byAmJiBpIDwgdGhpcy50ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbGluZSA9IHRoaXMudGV4dFtpXSwgZW5kID0gcG9zICsgbGluZS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAocG9zID4gZnJvbSAmJiBpKVxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBsaW5lU2VwO1xuICAgICAgICAgICAgaWYgKGZyb20gPCBlbmQgJiYgdG8gPiBwb3MpXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IGxpbmUuc2xpY2UoTWF0aC5tYXgoMCwgZnJvbSAtIHBvcyksIHRvIC0gcG9zKTtcbiAgICAgICAgICAgIHBvcyA9IGVuZCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZmxhdHRlbih0YXJnZXQpIHtcbiAgICAgICAgZm9yIChsZXQgbGluZSBvZiB0aGlzLnRleHQpXG4gICAgICAgICAgICB0YXJnZXQucHVzaChsaW5lKTtcbiAgICB9XG4gICAgc2NhbklkZW50aWNhbCgpIHsgcmV0dXJuIDA7IH1cbiAgICBzdGF0aWMgc3BsaXQodGV4dCwgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBwYXJ0ID0gW10sIGxlbiA9IC0xO1xuICAgICAgICBmb3IgKGxldCBsaW5lIG9mIHRleHQpIHtcbiAgICAgICAgICAgIHBhcnQucHVzaChsaW5lKTtcbiAgICAgICAgICAgIGxlbiArPSBsaW5lLmxlbmd0aCArIDE7XG4gICAgICAgICAgICBpZiAocGFydC5sZW5ndGggPT0gMzIgLyogVHJlZS5CcmFuY2ggKi8pIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQucHVzaChuZXcgVGV4dExlYWYocGFydCwgbGVuKSk7XG4gICAgICAgICAgICAgICAgcGFydCA9IFtdO1xuICAgICAgICAgICAgICAgIGxlbiA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChsZW4gPiAtMSlcbiAgICAgICAgICAgIHRhcmdldC5wdXNoKG5ldyBUZXh0TGVhZihwYXJ0LCBsZW4pKTtcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG59XG4vLyBOb2RlcyBwcm92aWRlIHRoZSB0cmVlIHN0cnVjdHVyZSBvZiB0aGUgYFRleHRgIHR5cGUuIFRoZXkgc3RvcmUgYVxuLy8gbnVtYmVyIG9mIG90aGVyIG5vZGVzIG9yIGxlYXZlcywgdGFraW5nIGNhcmUgdG8gYmFsYW5jZSB0aGVtc2VsdmVzXG4vLyBvbiBjaGFuZ2VzLiBUaGVyZSBhcmUgaW1wbGllZCBsaW5lIGJyZWFrcyBfYmV0d2Vlbl8gdGhlIGNoaWxkcmVuIG9mXG4vLyBhIG5vZGUgKGJ1dCBub3QgYmVmb3JlIHRoZSBmaXJzdCBvciBhZnRlciB0aGUgbGFzdCBjaGlsZCkuXG5jbGFzcyBUZXh0Tm9kZSBleHRlbmRzIFRleHQge1xuICAgIGNvbnN0cnVjdG9yKGNoaWxkcmVuLCBsZW5ndGgpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdGhpcy5saW5lcyA9IDA7XG4gICAgICAgIGZvciAobGV0IGNoaWxkIG9mIGNoaWxkcmVuKVxuICAgICAgICAgICAgdGhpcy5saW5lcyArPSBjaGlsZC5saW5lcztcbiAgICB9XG4gICAgbGluZUlubmVyKHRhcmdldCwgaXNMaW5lLCBsaW5lLCBvZmZzZXQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sIGVuZCA9IG9mZnNldCArIGNoaWxkLmxlbmd0aCwgZW5kTGluZSA9IGxpbmUgKyBjaGlsZC5saW5lcyAtIDE7XG4gICAgICAgICAgICBpZiAoKGlzTGluZSA/IGVuZExpbmUgOiBlbmQpID49IHRhcmdldClcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQubGluZUlubmVyKHRhcmdldCwgaXNMaW5lLCBsaW5lLCBvZmZzZXQpO1xuICAgICAgICAgICAgb2Zmc2V0ID0gZW5kICsgMTtcbiAgICAgICAgICAgIGxpbmUgPSBlbmRMaW5lICsgMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZWNvbXBvc2UoZnJvbSwgdG8sIHRhcmdldCwgb3Blbikge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gMDsgcG9zIDw9IHRvICYmIGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldLCBlbmQgPSBwb3MgKyBjaGlsZC5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoZnJvbSA8PSBlbmQgJiYgdG8gPj0gcG9zKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkT3BlbiA9IG9wZW4gJiAoKHBvcyA8PSBmcm9tID8gMSAvKiBPcGVuLkZyb20gKi8gOiAwKSB8IChlbmQgPj0gdG8gPyAyIC8qIE9wZW4uVG8gKi8gOiAwKSk7XG4gICAgICAgICAgICAgICAgaWYgKHBvcyA+PSBmcm9tICYmIGVuZCA8PSB0byAmJiAhY2hpbGRPcGVuKVxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQucHVzaChjaGlsZCk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBjaGlsZC5kZWNvbXBvc2UoZnJvbSAtIHBvcywgdG8gLSBwb3MsIHRhcmdldCwgY2hpbGRPcGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcyA9IGVuZCArIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVwbGFjZShmcm9tLCB0bywgdGV4dCkge1xuICAgICAgICBpZiAodGV4dC5saW5lcyA8IHRoaXMubGluZXMpXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldLCBlbmQgPSBwb3MgKyBjaGlsZC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgLy8gRmFzdCBwYXRoOiBpZiB0aGUgY2hhbmdlIG9ubHkgYWZmZWN0cyBvbmUgY2hpbGQgYW5kIHRoZVxuICAgICAgICAgICAgICAgIC8vIGNoaWxkJ3Mgc2l6ZSByZW1haW5zIGluIHRoZSBhY2NlcHRhYmxlIHJhbmdlLCBvbmx5IHVwZGF0ZVxuICAgICAgICAgICAgICAgIC8vIHRoYXQgY2hpbGRcbiAgICAgICAgICAgICAgICBpZiAoZnJvbSA+PSBwb3MgJiYgdG8gPD0gZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB1cGRhdGVkID0gY2hpbGQucmVwbGFjZShmcm9tIC0gcG9zLCB0byAtIHBvcywgdGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0b3RhbExpbmVzID0gdGhpcy5saW5lcyAtIGNoaWxkLmxpbmVzICsgdXBkYXRlZC5saW5lcztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVwZGF0ZWQubGluZXMgPCAodG90YWxMaW5lcyA+PiAoNSAvKiBUcmVlLkJyYW5jaFNoaWZ0ICovIC0gMSkpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVkLmxpbmVzID4gKHRvdGFsTGluZXMgPj4gKDUgLyogVHJlZS5CcmFuY2hTaGlmdCAqLyArIDEpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNvcHkgPSB0aGlzLmNoaWxkcmVuLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3B5W2ldID0gdXBkYXRlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVGV4dE5vZGUoY29weSwgdGhpcy5sZW5ndGggLSAodG8gLSBmcm9tKSArIHRleHQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3VwZXIucmVwbGFjZShwb3MsIGVuZCwgdXBkYXRlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBvcyA9IGVuZCArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdXBlci5yZXBsYWNlKGZyb20sIHRvLCB0ZXh0KTtcbiAgICB9XG4gICAgc2xpY2VTdHJpbmcoZnJvbSwgdG8gPSB0aGlzLmxlbmd0aCwgbGluZVNlcCA9IFwiXFxuXCIpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3MgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGggJiYgcG9zIDw9IHRvOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sIGVuZCA9IHBvcyArIGNoaWxkLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChwb3MgPiBmcm9tICYmIGkpXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IGxpbmVTZXA7XG4gICAgICAgICAgICBpZiAoZnJvbSA8IGVuZCAmJiB0byA+IHBvcylcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gY2hpbGQuc2xpY2VTdHJpbmcoZnJvbSAtIHBvcywgdG8gLSBwb3MsIGxpbmVTZXApO1xuICAgICAgICAgICAgcG9zID0gZW5kICsgMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBmbGF0dGVuKHRhcmdldCkge1xuICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiB0aGlzLmNoaWxkcmVuKVxuICAgICAgICAgICAgY2hpbGQuZmxhdHRlbih0YXJnZXQpO1xuICAgIH1cbiAgICBzY2FuSWRlbnRpY2FsKG90aGVyLCBkaXIpIHtcbiAgICAgICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBUZXh0Tm9kZSkpXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgbGV0IGxlbmd0aCA9IDA7XG4gICAgICAgIGxldCBbaUEsIGlCLCBlQSwgZUJdID0gZGlyID4gMCA/IFswLCAwLCB0aGlzLmNoaWxkcmVuLmxlbmd0aCwgb3RoZXIuY2hpbGRyZW4ubGVuZ3RoXVxuICAgICAgICAgICAgOiBbdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxLCBvdGhlci5jaGlsZHJlbi5sZW5ndGggLSAxLCAtMSwgLTFdO1xuICAgICAgICBmb3IgKDs7IGlBICs9IGRpciwgaUIgKz0gZGlyKSB7XG4gICAgICAgICAgICBpZiAoaUEgPT0gZUEgfHwgaUIgPT0gZUIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICAgICAgICAgIGxldCBjaEEgPSB0aGlzLmNoaWxkcmVuW2lBXSwgY2hCID0gb3RoZXIuY2hpbGRyZW5baUJdO1xuICAgICAgICAgICAgaWYgKGNoQSAhPSBjaEIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlbmd0aCArIGNoQS5zY2FuSWRlbnRpY2FsKGNoQiwgZGlyKTtcbiAgICAgICAgICAgIGxlbmd0aCArPSBjaEEubGVuZ3RoICsgMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgZnJvbShjaGlsZHJlbiwgbGVuZ3RoID0gY2hpbGRyZW4ucmVkdWNlKChsLCBjaCkgPT4gbCArIGNoLmxlbmd0aCArIDEsIC0xKSkge1xuICAgICAgICBsZXQgbGluZXMgPSAwO1xuICAgICAgICBmb3IgKGxldCBjaCBvZiBjaGlsZHJlbilcbiAgICAgICAgICAgIGxpbmVzICs9IGNoLmxpbmVzO1xuICAgICAgICBpZiAobGluZXMgPCAzMiAvKiBUcmVlLkJyYW5jaCAqLykge1xuICAgICAgICAgICAgbGV0IGZsYXQgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGNoIG9mIGNoaWxkcmVuKVxuICAgICAgICAgICAgICAgIGNoLmZsYXR0ZW4oZmxhdCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFRleHRMZWFmKGZsYXQsIGxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNodW5rID0gTWF0aC5tYXgoMzIgLyogVHJlZS5CcmFuY2ggKi8sIGxpbmVzID4+IDUgLyogVHJlZS5CcmFuY2hTaGlmdCAqLyksIG1heENodW5rID0gY2h1bmsgPDwgMSwgbWluQ2h1bmsgPSBjaHVuayA+PiAxO1xuICAgICAgICBsZXQgY2h1bmtlZCA9IFtdLCBjdXJyZW50TGluZXMgPSAwLCBjdXJyZW50TGVuID0gLTEsIGN1cnJlbnRDaHVuayA9IFtdO1xuICAgICAgICBmdW5jdGlvbiBhZGQoY2hpbGQpIHtcbiAgICAgICAgICAgIGxldCBsYXN0O1xuICAgICAgICAgICAgaWYgKGNoaWxkLmxpbmVzID4gbWF4Q2h1bmsgJiYgY2hpbGQgaW5zdGFuY2VvZiBUZXh0Tm9kZSkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IG5vZGUgb2YgY2hpbGQuY2hpbGRyZW4pXG4gICAgICAgICAgICAgICAgICAgIGFkZChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoaWxkLmxpbmVzID4gbWluQ2h1bmsgJiYgKGN1cnJlbnRMaW5lcyA+IG1pbkNodW5rIHx8ICFjdXJyZW50TGluZXMpKSB7XG4gICAgICAgICAgICAgICAgZmx1c2goKTtcbiAgICAgICAgICAgICAgICBjaHVua2VkLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hpbGQgaW5zdGFuY2VvZiBUZXh0TGVhZiAmJiBjdXJyZW50TGluZXMgJiZcbiAgICAgICAgICAgICAgICAobGFzdCA9IGN1cnJlbnRDaHVua1tjdXJyZW50Q2h1bmsubGVuZ3RoIC0gMV0pIGluc3RhbmNlb2YgVGV4dExlYWYgJiZcbiAgICAgICAgICAgICAgICBjaGlsZC5saW5lcyArIGxhc3QubGluZXMgPD0gMzIgLyogVHJlZS5CcmFuY2ggKi8pIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50TGluZXMgKz0gY2hpbGQubGluZXM7XG4gICAgICAgICAgICAgICAgY3VycmVudExlbiArPSBjaGlsZC5sZW5ndGggKyAxO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRDaHVua1tjdXJyZW50Q2h1bmsubGVuZ3RoIC0gMV0gPSBuZXcgVGV4dExlYWYobGFzdC50ZXh0LmNvbmNhdChjaGlsZC50ZXh0KSwgbGFzdC5sZW5ndGggKyAxICsgY2hpbGQubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50TGluZXMgKyBjaGlsZC5saW5lcyA+IGNodW5rKVxuICAgICAgICAgICAgICAgICAgICBmbHVzaCgpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRMaW5lcyArPSBjaGlsZC5saW5lcztcbiAgICAgICAgICAgICAgICBjdXJyZW50TGVuICs9IGNoaWxkLmxlbmd0aCArIDE7XG4gICAgICAgICAgICAgICAgY3VycmVudENodW5rLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGZsdXNoKCkge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRMaW5lcyA9PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNodW5rZWQucHVzaChjdXJyZW50Q2h1bmsubGVuZ3RoID09IDEgPyBjdXJyZW50Q2h1bmtbMF0gOiBUZXh0Tm9kZS5mcm9tKGN1cnJlbnRDaHVuaywgY3VycmVudExlbikpO1xuICAgICAgICAgICAgY3VycmVudExlbiA9IC0xO1xuICAgICAgICAgICAgY3VycmVudExpbmVzID0gY3VycmVudENodW5rLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgY2hpbGQgb2YgY2hpbGRyZW4pXG4gICAgICAgICAgICBhZGQoY2hpbGQpO1xuICAgICAgICBmbHVzaCgpO1xuICAgICAgICByZXR1cm4gY2h1bmtlZC5sZW5ndGggPT0gMSA/IGNodW5rZWRbMF0gOiBuZXcgVGV4dE5vZGUoY2h1bmtlZCwgbGVuZ3RoKTtcbiAgICB9XG59XG5UZXh0LmVtcHR5ID0gLypAX19QVVJFX18qL25ldyBUZXh0TGVhZihbXCJcIl0sIDApO1xuZnVuY3Rpb24gdGV4dExlbmd0aCh0ZXh0KSB7XG4gICAgbGV0IGxlbmd0aCA9IC0xO1xuICAgIGZvciAobGV0IGxpbmUgb2YgdGV4dClcbiAgICAgICAgbGVuZ3RoICs9IGxpbmUubGVuZ3RoICsgMTtcbiAgICByZXR1cm4gbGVuZ3RoO1xufVxuZnVuY3Rpb24gYXBwZW5kVGV4dCh0ZXh0LCB0YXJnZXQsIGZyb20gPSAwLCB0byA9IDFlOSkge1xuICAgIGZvciAobGV0IHBvcyA9IDAsIGkgPSAwLCBmaXJzdCA9IHRydWU7IGkgPCB0ZXh0Lmxlbmd0aCAmJiBwb3MgPD0gdG87IGkrKykge1xuICAgICAgICBsZXQgbGluZSA9IHRleHRbaV0sIGVuZCA9IHBvcyArIGxpbmUubGVuZ3RoO1xuICAgICAgICBpZiAoZW5kID49IGZyb20pIHtcbiAgICAgICAgICAgIGlmIChlbmQgPiB0bylcbiAgICAgICAgICAgICAgICBsaW5lID0gbGluZS5zbGljZSgwLCB0byAtIHBvcyk7XG4gICAgICAgICAgICBpZiAocG9zIDwgZnJvbSlcbiAgICAgICAgICAgICAgICBsaW5lID0gbGluZS5zbGljZShmcm9tIC0gcG9zKTtcbiAgICAgICAgICAgIGlmIChmaXJzdCkge1xuICAgICAgICAgICAgICAgIHRhcmdldFt0YXJnZXQubGVuZ3RoIC0gMV0gKz0gbGluZTtcbiAgICAgICAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRhcmdldC5wdXNoKGxpbmUpO1xuICAgICAgICB9XG4gICAgICAgIHBvcyA9IGVuZCArIDE7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBzbGljZVRleHQodGV4dCwgZnJvbSwgdG8pIHtcbiAgICByZXR1cm4gYXBwZW5kVGV4dCh0ZXh0LCBbXCJcIl0sIGZyb20sIHRvKTtcbn1cbmNsYXNzIFJhd1RleHRDdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKHRleHQsIGRpciA9IDEpIHtcbiAgICAgICAgdGhpcy5kaXIgPSBkaXI7XG4gICAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxpbmVCcmVhayA9IGZhbHNlO1xuICAgICAgICB0aGlzLnZhbHVlID0gXCJcIjtcbiAgICAgICAgdGhpcy5ub2RlcyA9IFt0ZXh0XTtcbiAgICAgICAgdGhpcy5vZmZzZXRzID0gW2RpciA+IDAgPyAxIDogKHRleHQgaW5zdGFuY2VvZiBUZXh0TGVhZiA/IHRleHQudGV4dC5sZW5ndGggOiB0ZXh0LmNoaWxkcmVuLmxlbmd0aCkgPDwgMV07XG4gICAgfVxuICAgIG5leHRJbm5lcihza2lwLCBkaXIpIHtcbiAgICAgICAgdGhpcy5kb25lID0gdGhpcy5saW5lQnJlYWsgPSBmYWxzZTtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IGxhc3QgPSB0aGlzLm5vZGVzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICBsZXQgdG9wID0gdGhpcy5ub2Rlc1tsYXN0XSwgb2Zmc2V0VmFsdWUgPSB0aGlzLm9mZnNldHNbbGFzdF0sIG9mZnNldCA9IG9mZnNldFZhbHVlID4+IDE7XG4gICAgICAgICAgICBsZXQgc2l6ZSA9IHRvcCBpbnN0YW5jZW9mIFRleHRMZWFmID8gdG9wLnRleHQubGVuZ3RoIDogdG9wLmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPT0gKGRpciA+IDAgPyBzaXplIDogMCkpIHtcbiAgICAgICAgICAgICAgICBpZiAobGFzdCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRpciA+IDApXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub2Zmc2V0c1tsYXN0IC0gMV0rKztcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVzLnBvcCgpO1xuICAgICAgICAgICAgICAgIHRoaXMub2Zmc2V0cy5wb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKChvZmZzZXRWYWx1ZSAmIDEpID09IChkaXIgPiAwID8gMCA6IDEpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vZmZzZXRzW2xhc3RdICs9IGRpcjtcbiAgICAgICAgICAgICAgICBpZiAoc2tpcCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGluZUJyZWFrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IFwiXFxuXCI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBza2lwLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0b3AgaW5zdGFuY2VvZiBUZXh0TGVhZikge1xuICAgICAgICAgICAgICAgIC8vIE1vdmUgdG8gdGhlIG5leHQgc3RyaW5nXG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSB0b3AudGV4dFtvZmZzZXQgKyAoZGlyIDwgMCA/IC0xIDogMCldO1xuICAgICAgICAgICAgICAgIHRoaXMub2Zmc2V0c1tsYXN0XSArPSBkaXI7XG4gICAgICAgICAgICAgICAgaWYgKG5leHQubGVuZ3RoID4gTWF0aC5tYXgoMCwgc2tpcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHNraXAgPT0gMCA/IG5leHQgOiBkaXIgPiAwID8gbmV4dC5zbGljZShza2lwKSA6IG5leHQuc2xpY2UoMCwgbmV4dC5sZW5ndGggLSBza2lwKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNraXAgLT0gbmV4dC5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IHRvcC5jaGlsZHJlbltvZmZzZXQgKyAoZGlyIDwgMCA/IC0xIDogMCldO1xuICAgICAgICAgICAgICAgIGlmIChza2lwID4gbmV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2tpcCAtPSBuZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vZmZzZXRzW2xhc3RdICs9IGRpcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkaXIgPCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vZmZzZXRzW2xhc3RdLS07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubm9kZXMucHVzaChuZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vZmZzZXRzLnB1c2goZGlyID4gMCA/IDEgOiAobmV4dCBpbnN0YW5jZW9mIFRleHRMZWFmID8gbmV4dC50ZXh0Lmxlbmd0aCA6IG5leHQuY2hpbGRyZW4ubGVuZ3RoKSA8PCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmV4dChza2lwID0gMCkge1xuICAgICAgICBpZiAoc2tpcCA8IDApIHtcbiAgICAgICAgICAgIHRoaXMubmV4dElubmVyKC1za2lwLCAoLXRoaXMuZGlyKSk7XG4gICAgICAgICAgICBza2lwID0gdGhpcy52YWx1ZS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dElubmVyKHNraXAsIHRoaXMuZGlyKTtcbiAgICB9XG59XG5jbGFzcyBQYXJ0aWFsVGV4dEN1cnNvciB7XG4gICAgY29uc3RydWN0b3IodGV4dCwgc3RhcnQsIGVuZCkge1xuICAgICAgICB0aGlzLnZhbHVlID0gXCJcIjtcbiAgICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY3Vyc29yID0gbmV3IFJhd1RleHRDdXJzb3IodGV4dCwgc3RhcnQgPiBlbmQgPyAtMSA6IDEpO1xuICAgICAgICB0aGlzLnBvcyA9IHN0YXJ0ID4gZW5kID8gdGV4dC5sZW5ndGggOiAwO1xuICAgICAgICB0aGlzLmZyb20gPSBNYXRoLm1pbihzdGFydCwgZW5kKTtcbiAgICAgICAgdGhpcy50byA9IE1hdGgubWF4KHN0YXJ0LCBlbmQpO1xuICAgIH1cbiAgICBuZXh0SW5uZXIoc2tpcCwgZGlyKSB7XG4gICAgICAgIGlmIChkaXIgPCAwID8gdGhpcy5wb3MgPD0gdGhpcy5mcm9tIDogdGhpcy5wb3MgPj0gdGhpcy50bykge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IFwiXCI7XG4gICAgICAgICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgc2tpcCArPSBNYXRoLm1heCgwLCBkaXIgPCAwID8gdGhpcy5wb3MgLSB0aGlzLnRvIDogdGhpcy5mcm9tIC0gdGhpcy5wb3MpO1xuICAgICAgICBsZXQgbGltaXQgPSBkaXIgPCAwID8gdGhpcy5wb3MgLSB0aGlzLmZyb20gOiB0aGlzLnRvIC0gdGhpcy5wb3M7XG4gICAgICAgIGlmIChza2lwID4gbGltaXQpXG4gICAgICAgICAgICBza2lwID0gbGltaXQ7XG4gICAgICAgIGxpbWl0IC09IHNraXA7XG4gICAgICAgIGxldCB7IHZhbHVlIH0gPSB0aGlzLmN1cnNvci5uZXh0KHNraXApO1xuICAgICAgICB0aGlzLnBvcyArPSAodmFsdWUubGVuZ3RoICsgc2tpcCkgKiBkaXI7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZS5sZW5ndGggPD0gbGltaXQgPyB2YWx1ZSA6IGRpciA8IDAgPyB2YWx1ZS5zbGljZSh2YWx1ZS5sZW5ndGggLSBsaW1pdCkgOiB2YWx1ZS5zbGljZSgwLCBsaW1pdCk7XG4gICAgICAgIHRoaXMuZG9uZSA9ICF0aGlzLnZhbHVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgbmV4dChza2lwID0gMCkge1xuICAgICAgICBpZiAoc2tpcCA8IDApXG4gICAgICAgICAgICBza2lwID0gTWF0aC5tYXgoc2tpcCwgdGhpcy5mcm9tIC0gdGhpcy5wb3MpO1xuICAgICAgICBlbHNlIGlmIChza2lwID4gMClcbiAgICAgICAgICAgIHNraXAgPSBNYXRoLm1pbihza2lwLCB0aGlzLnRvIC0gdGhpcy5wb3MpO1xuICAgICAgICByZXR1cm4gdGhpcy5uZXh0SW5uZXIoc2tpcCwgdGhpcy5jdXJzb3IuZGlyKTtcbiAgICB9XG4gICAgZ2V0IGxpbmVCcmVhaygpIHsgcmV0dXJuIHRoaXMuY3Vyc29yLmxpbmVCcmVhayAmJiB0aGlzLnZhbHVlICE9IFwiXCI7IH1cbn1cbmNsYXNzIExpbmVDdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKGlubmVyKSB7XG4gICAgICAgIHRoaXMuaW5uZXIgPSBpbm5lcjtcbiAgICAgICAgdGhpcy5hZnRlckJyZWFrID0gdHJ1ZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IFwiXCI7XG4gICAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgIH1cbiAgICBuZXh0KHNraXAgPSAwKSB7XG4gICAgICAgIGxldCB7IGRvbmUsIGxpbmVCcmVhaywgdmFsdWUgfSA9IHRoaXMuaW5uZXIubmV4dChza2lwKTtcbiAgICAgICAgaWYgKGRvbmUgJiYgdGhpcy5hZnRlckJyZWFrKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gXCJcIjtcbiAgICAgICAgICAgIHRoaXMuYWZ0ZXJCcmVhayA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsaW5lQnJlYWspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFmdGVyQnJlYWspIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYWZ0ZXJCcmVhayA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLmFmdGVyQnJlYWsgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0IGxpbmVCcmVhaygpIHsgcmV0dXJuIGZhbHNlOyB9XG59XG5pZiAodHlwZW9mIFN5bWJvbCAhPSBcInVuZGVmaW5lZFwiKSB7XG4gICAgVGV4dC5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuaXRlcigpOyB9O1xuICAgIFJhd1RleHRDdXJzb3IucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBQYXJ0aWFsVGV4dEN1cnNvci5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9XG4gICAgICAgIExpbmVDdXJzb3IucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xufVxuLyoqXG5UaGlzIHR5cGUgZGVzY3JpYmVzIGEgbGluZSBpbiB0aGUgZG9jdW1lbnQuIEl0IGlzIGNyZWF0ZWRcbm9uLWRlbWFuZCB3aGVuIGxpbmVzIGFyZSBbcXVlcmllZF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UZXh0LmxpbmVBdCkuXG4qL1xuY2xhc3MgTGluZSB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgcG9zaXRpb24gb2YgdGhlIHN0YXJ0IG9mIHRoZSBsaW5lLlxuICAgICovXG4gICAgZnJvbSwgXG4gICAgLyoqXG4gICAgVGhlIHBvc2l0aW9uIGF0IHRoZSBlbmQgb2YgdGhlIGxpbmUgKF9iZWZvcmVfIHRoZSBsaW5lIGJyZWFrLFxuICAgIG9yIGF0IHRoZSBlbmQgb2YgZG9jdW1lbnQgZm9yIHRoZSBsYXN0IGxpbmUpLlxuICAgICovXG4gICAgdG8sIFxuICAgIC8qKlxuICAgIFRoaXMgbGluZSdzIGxpbmUgbnVtYmVyICgxLWJhc2VkKS5cbiAgICAqL1xuICAgIG51bWJlciwgXG4gICAgLyoqXG4gICAgVGhlIGxpbmUncyBjb250ZW50LlxuICAgICovXG4gICAgdGV4dCkge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMubnVtYmVyID0gbnVtYmVyO1xuICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgbGVuZ3RoIG9mIHRoZSBsaW5lIChub3QgaW5jbHVkaW5nIGFueSBsaW5lIGJyZWFrIGFmdGVyIGl0KS5cbiAgICAqL1xuICAgIGdldCBsZW5ndGgoKSB7IHJldHVybiB0aGlzLnRvIC0gdGhpcy5mcm9tOyB9XG59XG5cbi8vIENvbXByZXNzZWQgcmVwcmVzZW50YXRpb24gb2YgdGhlIEdyYXBoZW1lX0NsdXN0ZXJfQnJlYWs9RXh0ZW5kXG4vLyBpbmZvcm1hdGlvbiBmcm9tXG4vLyBodHRwOi8vd3d3LnVuaWNvZGUub3JnL1B1YmxpYy8xMy4wLjAvdWNkL2F1eGlsaWFyeS9HcmFwaGVtZUJyZWFrUHJvcGVydHkudHh0LlxuLy8gRWFjaCBwYWlyIG9mIGVsZW1lbnRzIHJlcHJlc2VudHMgYSByYW5nZSwgYXMgYW4gb2ZmZXQgZnJvbSB0aGVcbi8vIHByZXZpb3VzIHJhbmdlIGFuZCBhIGxlbmd0aC4gTnVtYmVycyBhcmUgaW4gYmFzZS0zNiwgd2l0aCB0aGUgZW1wdHlcbi8vIHN0cmluZyBiZWluZyBhIHNob3J0aGFuZCBmb3IgMS5cbmxldCBleHRlbmQgPSAvKkBfX1BVUkVfXyovXCJsYywzNCw3biw3LDdiLDE5LCwsLDIsLDIsLCwyMCxiLDFjLGwsZywsMnQsNywyLDYsMiwyLCw0LHosLHUsciwyaixiLDFtLDksOSwsbyw0LCw5LCwzLCw1LDE3LDMsM2IsZiwsdywxaiwsLCw0LDgsNCwsMyw3LGEsMix0LCwxbSwsLCwyLDQsOCwsOSwsYSwyLHEsLDIsMiwxbCwsNCwyLDQsMiwyLDMsMywsdSwyLDMsLGIsMiwxbCwsNCw1LCwyLDQsLGssMixtLDYsLCwxbSwsLDIsLDQsOCwsNywzLGEsMix1LCwxbiwsLCxjLCw5LCwxNCwsMywsMWwsMyw1LDMsLDQsNywyLGIsMix0LCwxbSwsMiwsMiwsMywsNSwyLDcsMixiLDIscywyLDFsLDIsLCwyLDQsOCwsOSwsYSwyLHQsLDIwLCw0LCwyLDMsLCw4LCwyOSwsMiw3LGMsOCwycSwsMiw5LGIsNiwyMiwyLHIsLCwsLCwxaixlLCw1LCwyLDUsYiwsMTAsOSwsMnUsNCwsNiwsMiwyLDIscCwyLDQsMyxnLDQsZCwsMiwyLDYsLGYsLGpqLDMscWEsMyx0LDMsdCwyLHUsMiwxcywyLCw3LDgsLDIsYiw5LCwxOSwzLDNiLDIseSwsM2EsMyw0LDIsOSwsNiwzLDYzLDIsMiwsMW0sLCw3LCwsLCwyLDgsNixhLDIsLDFjLGgsMXIsNCwxYyw3LCwsNSwsMTQsOSxjLDIsdyw0LDIsMiwsMywxaywsLDIsMywsLDMsMW0sOCwyLDIsNDgsMywsZCwsNyw0LCw2LCwzLDIsNWksMW0sLDUsZWssLDVmLHgsMmRhLDMsM3gsLDJvLHcsZmUsNiwyeCwyLG45dyw0LCxhLHcsMiwyOCwyLDdrLCwzLCw0LCxwLDIsNSwsNDcsMixxLGksZCwsMTIsOCxwLGIsMWEsMywxYywsMiw0LDIsMiwxMywsMXYsNiwyLDIsMiwyLGMsLDgsLDFiLCwxZiwsLDMsMiwyLDUsMiwsLDE2LDIsOCwsNm0sLDIsLDQsLGZuNCwsa2gsZyxnLGcsYTYsMixndCwsNmEsLDQ1LDUsMWFlLDMsLDIsNSw0LDE0LDMsNCwsNGwsMixmeCw0LGFyLDIsNDksYiw0dywsMWksZiwxaywzLDFkLDQsMiwyLDF4LDMsMTAsNSwsOCwxcSwsYywyLDFnLDksYSw0LDIsLDJuLDMsMiwsLDIsNiwsNGcsLDMsOCxsLDIsMWwsMiwsLCwsbSwsZSw3LDMsNSw1Ziw4LDIsMywsLG4sLDI5LCwyLDYsLCwyLCwsMiwsMiw2aiwsMiw0LDYsMiwsMixyLDIsMmQsOCwyLCwsMiwyeSwsLCwyLDYsLCwydCwzLDIsNCwsNSw3Nyw5LCwyLDZ0LCxhLDIsLCw0LCw0MCw0LDIsMiw0LCx3LGEsMTQsNiwyLDQsOCwsOSw2LDIsMywxYSxkLCwyLGJhLDcsLDYsLCwyYSxtLDIsNywsMiwsMiwzZSw2LDMsLCwyLCw3LCwsMjAsMiwzLCwsLDluLDIsZjBiLDUsMW4sNyx0NCwsMXIsNCwyOSwsZjVrLDIsNDNxLCwsMyw0LDUsOCw4LDIsNyx1LDQsNDQsMywxaXosMWosNCwxZSw4LCxlLCxtLDUsLGYsMTFzLDcsLGgsMiw3LCwyLCw1LDc5LDcsYzUsNCwxNXMsNywzMSw3LDI0MCw1LGd4N2ssMm8sM2ssNm9cIi5zcGxpdChcIixcIikubWFwKHMgPT4gcyA/IHBhcnNlSW50KHMsIDM2KSA6IDEpO1xuLy8gQ29udmVydCBvZmZzZXRzIGludG8gYWJzb2x1dGUgdmFsdWVzXG5mb3IgKGxldCBpID0gMTsgaSA8IGV4dGVuZC5sZW5ndGg7IGkrKylcbiAgICBleHRlbmRbaV0gKz0gZXh0ZW5kW2kgLSAxXTtcbmZ1bmN0aW9uIGlzRXh0ZW5kaW5nQ2hhcihjb2RlKSB7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBleHRlbmQubGVuZ3RoOyBpICs9IDIpXG4gICAgICAgIGlmIChleHRlbmRbaV0gPiBjb2RlKVxuICAgICAgICAgICAgcmV0dXJuIGV4dGVuZFtpIC0gMV0gPD0gY29kZTtcbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc1JlZ2lvbmFsSW5kaWNhdG9yKGNvZGUpIHtcbiAgICByZXR1cm4gY29kZSA+PSAweDFGMUU2ICYmIGNvZGUgPD0gMHgxRjFGRjtcbn1cbmNvbnN0IFpXSiA9IDB4MjAwZDtcbi8qKlxuUmV0dXJucyBhIG5leHQgZ3JhcGhlbWUgY2x1c3RlciBicmVhayBfYWZ0ZXJfIChub3QgZXF1YWwgdG8pXG5gcG9zYCwgaWYgYGZvcndhcmRgIGlzIHRydWUsIG9yIGJlZm9yZSBvdGhlcndpc2UuIFJldHVybnMgYHBvc2Bcbml0c2VsZiBpZiBubyBmdXJ0aGVyIGNsdXN0ZXIgYnJlYWsgaXMgYXZhaWxhYmxlIGluIHRoZSBzdHJpbmcuXG5Nb3ZlcyBhY3Jvc3Mgc3Vycm9nYXRlIHBhaXJzLCBleHRlbmRpbmcgY2hhcmFjdGVycyAod2hlblxuYGluY2x1ZGVFeHRlbmRpbmdgIGlzIHRydWUpLCBjaGFyYWN0ZXJzIGpvaW5lZCB3aXRoIHplcm8td2lkdGhcbmpvaW5lcnMsIGFuZCBmbGFnIGVtb2ppLlxuKi9cbmZ1bmN0aW9uIGZpbmRDbHVzdGVyQnJlYWsoc3RyLCBwb3MsIGZvcndhcmQgPSB0cnVlLCBpbmNsdWRlRXh0ZW5kaW5nID0gdHJ1ZSkge1xuICAgIHJldHVybiAoZm9yd2FyZCA/IG5leHRDbHVzdGVyQnJlYWsgOiBwcmV2Q2x1c3RlckJyZWFrKShzdHIsIHBvcywgaW5jbHVkZUV4dGVuZGluZyk7XG59XG5mdW5jdGlvbiBuZXh0Q2x1c3RlckJyZWFrKHN0ciwgcG9zLCBpbmNsdWRlRXh0ZW5kaW5nKSB7XG4gICAgaWYgKHBvcyA9PSBzdHIubGVuZ3RoKVxuICAgICAgICByZXR1cm4gcG9zO1xuICAgIC8vIElmIHBvcyBpcyBpbiB0aGUgbWlkZGxlIG9mIGEgc3Vycm9nYXRlIHBhaXIsIG1vdmUgdG8gaXRzIHN0YXJ0XG4gICAgaWYgKHBvcyAmJiBzdXJyb2dhdGVMb3coc3RyLmNoYXJDb2RlQXQocG9zKSkgJiYgc3Vycm9nYXRlSGlnaChzdHIuY2hhckNvZGVBdChwb3MgLSAxKSkpXG4gICAgICAgIHBvcy0tO1xuICAgIGxldCBwcmV2ID0gY29kZVBvaW50QXQoc3RyLCBwb3MpO1xuICAgIHBvcyArPSBjb2RlUG9pbnRTaXplKHByZXYpO1xuICAgIHdoaWxlIChwb3MgPCBzdHIubGVuZ3RoKSB7XG4gICAgICAgIGxldCBuZXh0ID0gY29kZVBvaW50QXQoc3RyLCBwb3MpO1xuICAgICAgICBpZiAocHJldiA9PSBaV0ogfHwgbmV4dCA9PSBaV0ogfHwgaW5jbHVkZUV4dGVuZGluZyAmJiBpc0V4dGVuZGluZ0NoYXIobmV4dCkpIHtcbiAgICAgICAgICAgIHBvcyArPSBjb2RlUG9pbnRTaXplKG5leHQpO1xuICAgICAgICAgICAgcHJldiA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNSZWdpb25hbEluZGljYXRvcihuZXh0KSkge1xuICAgICAgICAgICAgbGV0IGNvdW50QmVmb3JlID0gMCwgaSA9IHBvcyAtIDI7XG4gICAgICAgICAgICB3aGlsZSAoaSA+PSAwICYmIGlzUmVnaW9uYWxJbmRpY2F0b3IoY29kZVBvaW50QXQoc3RyLCBpKSkpIHtcbiAgICAgICAgICAgICAgICBjb3VudEJlZm9yZSsrO1xuICAgICAgICAgICAgICAgIGkgLT0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb3VudEJlZm9yZSAlIDIgPT0gMClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBwb3MgKz0gMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwb3M7XG59XG5mdW5jdGlvbiBwcmV2Q2x1c3RlckJyZWFrKHN0ciwgcG9zLCBpbmNsdWRlRXh0ZW5kaW5nKSB7XG4gICAgd2hpbGUgKHBvcyA+IDApIHtcbiAgICAgICAgbGV0IGZvdW5kID0gbmV4dENsdXN0ZXJCcmVhayhzdHIsIHBvcyAtIDIsIGluY2x1ZGVFeHRlbmRpbmcpO1xuICAgICAgICBpZiAoZm91bmQgPCBwb3MpXG4gICAgICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgICAgIHBvcy0tO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIHN1cnJvZ2F0ZUxvdyhjaCkgeyByZXR1cm4gY2ggPj0gMHhEQzAwICYmIGNoIDwgMHhFMDAwOyB9XG5mdW5jdGlvbiBzdXJyb2dhdGVIaWdoKGNoKSB7IHJldHVybiBjaCA+PSAweEQ4MDAgJiYgY2ggPCAweERDMDA7IH1cbi8qKlxuRmluZCB0aGUgY29kZSBwb2ludCBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24gaW4gYSBzdHJpbmcgKGxpa2UgdGhlXG5bYGNvZGVQb2ludEF0YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL2NvZGVQb2ludEF0KVxuc3RyaW5nIG1ldGhvZCkuXG4qL1xuZnVuY3Rpb24gY29kZVBvaW50QXQoc3RyLCBwb3MpIHtcbiAgICBsZXQgY29kZTAgPSBzdHIuY2hhckNvZGVBdChwb3MpO1xuICAgIGlmICghc3Vycm9nYXRlSGlnaChjb2RlMCkgfHwgcG9zICsgMSA9PSBzdHIubGVuZ3RoKVxuICAgICAgICByZXR1cm4gY29kZTA7XG4gICAgbGV0IGNvZGUxID0gc3RyLmNoYXJDb2RlQXQocG9zICsgMSk7XG4gICAgaWYgKCFzdXJyb2dhdGVMb3coY29kZTEpKVxuICAgICAgICByZXR1cm4gY29kZTA7XG4gICAgcmV0dXJuICgoY29kZTAgLSAweGQ4MDApIDw8IDEwKSArIChjb2RlMSAtIDB4ZGMwMCkgKyAweDEwMDAwO1xufVxuLyoqXG5HaXZlbiBhIFVuaWNvZGUgY29kZXBvaW50LCByZXR1cm4gdGhlIEphdmFTY3JpcHQgc3RyaW5nIHRoYXRcbnJlc3ByZXNlbnRzIGl0IChsaWtlXG5bYFN0cmluZy5mcm9tQ29kZVBvaW50YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL2Zyb21Db2RlUG9pbnQpKS5cbiovXG5mdW5jdGlvbiBmcm9tQ29kZVBvaW50KGNvZGUpIHtcbiAgICBpZiAoY29kZSA8PSAweGZmZmYpXG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgIGNvZGUgLT0gMHgxMDAwMDtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSgoY29kZSA+PiAxMCkgKyAweGQ4MDAsIChjb2RlICYgMTAyMykgKyAweGRjMDApO1xufVxuLyoqXG5UaGUgYW1vdW50IG9mIHBvc2l0aW9ucyBhIGNoYXJhY3RlciB0YWtlcyB1cCBhIEphdmFTY3JpcHQgc3RyaW5nLlxuKi9cbmZ1bmN0aW9uIGNvZGVQb2ludFNpemUoY29kZSkgeyByZXR1cm4gY29kZSA8IDB4MTAwMDAgPyAxIDogMjsgfVxuXG5jb25zdCBEZWZhdWx0U3BsaXQgPSAvXFxyXFxuP3xcXG4vO1xuLyoqXG5EaXN0aW5ndWlzaGVzIGRpZmZlcmVudCB3YXlzIGluIHdoaWNoIHBvc2l0aW9ucyBjYW4gYmUgbWFwcGVkLlxuKi9cbnZhciBNYXBNb2RlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoTWFwTW9kZSkge1xuICAgIC8qKlxuICAgIE1hcCBhIHBvc2l0aW9uIHRvIGEgdmFsaWQgbmV3IHBvc2l0aW9uLCBldmVuIHdoZW4gaXRzIGNvbnRleHRcbiAgICB3YXMgZGVsZXRlZC5cbiAgICAqL1xuICAgIE1hcE1vZGVbTWFwTW9kZVtcIlNpbXBsZVwiXSA9IDBdID0gXCJTaW1wbGVcIjtcbiAgICAvKipcbiAgICBSZXR1cm4gbnVsbCBpZiBkZWxldGlvbiBoYXBwZW5zIGFjcm9zcyB0aGUgcG9zaXRpb24uXG4gICAgKi9cbiAgICBNYXBNb2RlW01hcE1vZGVbXCJUcmFja0RlbFwiXSA9IDFdID0gXCJUcmFja0RlbFwiO1xuICAgIC8qKlxuICAgIFJldHVybiBudWxsIGlmIHRoZSBjaGFyYWN0ZXIgX2JlZm9yZV8gdGhlIHBvc2l0aW9uIGlzIGRlbGV0ZWQuXG4gICAgKi9cbiAgICBNYXBNb2RlW01hcE1vZGVbXCJUcmFja0JlZm9yZVwiXSA9IDJdID0gXCJUcmFja0JlZm9yZVwiO1xuICAgIC8qKlxuICAgIFJldHVybiBudWxsIGlmIHRoZSBjaGFyYWN0ZXIgX2FmdGVyXyB0aGUgcG9zaXRpb24gaXMgZGVsZXRlZC5cbiAgICAqL1xuICAgIE1hcE1vZGVbTWFwTW9kZVtcIlRyYWNrQWZ0ZXJcIl0gPSAzXSA9IFwiVHJhY2tBZnRlclwiO1xucmV0dXJuIE1hcE1vZGV9KShNYXBNb2RlIHx8IChNYXBNb2RlID0ge30pKTtcbi8qKlxuQSBjaGFuZ2UgZGVzY3JpcHRpb24gaXMgYSB2YXJpYW50IG9mIFtjaGFuZ2Ugc2V0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkNoYW5nZVNldClcbnRoYXQgZG9lc24ndCBzdG9yZSB0aGUgaW5zZXJ0ZWQgdGV4dC4gQXMgc3VjaCwgaXQgY2FuJ3QgYmVcbmFwcGxpZWQsIGJ1dCBpcyBjaGVhcGVyIHRvIHN0b3JlIGFuZCBtYW5pcHVsYXRlLlxuKi9cbmNsYXNzIENoYW5nZURlc2Mge1xuICAgIC8vIFNlY3Rpb25zIGFyZSBlbmNvZGVkIGFzIHBhaXJzIG9mIGludGVnZXJzLiBUaGUgZmlyc3QgaXMgdGhlXG4gICAgLy8gbGVuZ3RoIGluIHRoZSBjdXJyZW50IGRvY3VtZW50LCBhbmQgdGhlIHNlY29uZCBpcyAtMSBmb3JcbiAgICAvLyB1bmFmZmVjdGVkIHNlY3Rpb25zLCBhbmQgdGhlIGxlbmd0aCBvZiB0aGUgcmVwbGFjZW1lbnQgY29udGVudFxuICAgIC8vIG90aGVyd2lzZS4gU28gYW4gaW5zZXJ0aW9uIHdvdWxkIGJlICgwLCBuPjApLCBhIGRlbGV0aW9uIChuPjAsXG4gICAgLy8gMCksIGFuZCBhIHJlcGxhY2VtZW50IHR3byBwb3NpdGl2ZSBudW1iZXJzLlxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzZWN0aW9ucykge1xuICAgICAgICB0aGlzLnNlY3Rpb25zID0gc2VjdGlvbnM7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBsZW5ndGggb2YgdGhlIGRvY3VtZW50IGJlZm9yZSB0aGUgY2hhbmdlLlxuICAgICovXG4gICAgZ2V0IGxlbmd0aCgpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zZWN0aW9ucy5sZW5ndGg7IGkgKz0gMilcbiAgICAgICAgICAgIHJlc3VsdCArPSB0aGlzLnNlY3Rpb25zW2ldO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgbGVuZ3RoIG9mIHRoZSBkb2N1bWVudCBhZnRlciB0aGUgY2hhbmdlLlxuICAgICovXG4gICAgZ2V0IG5ld0xlbmd0aCgpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zZWN0aW9ucy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgbGV0IGlucyA9IHRoaXMuc2VjdGlvbnNbaSArIDFdO1xuICAgICAgICAgICAgcmVzdWx0ICs9IGlucyA8IDAgPyB0aGlzLnNlY3Rpb25zW2ldIDogaW5zO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEZhbHNlIHdoZW4gdGhlcmUgYXJlIGFjdHVhbCBjaGFuZ2VzIGluIHRoaXMgc2V0LlxuICAgICovXG4gICAgZ2V0IGVtcHR5KCkgeyByZXR1cm4gdGhpcy5zZWN0aW9ucy5sZW5ndGggPT0gMCB8fCB0aGlzLnNlY3Rpb25zLmxlbmd0aCA9PSAyICYmIHRoaXMuc2VjdGlvbnNbMV0gPCAwOyB9XG4gICAgLyoqXG4gICAgSXRlcmF0ZSBvdmVyIHRoZSB1bmNoYW5nZWQgcGFydHMgbGVmdCBieSB0aGVzZSBjaGFuZ2VzLiBgcG9zQWBcbiAgICBwcm92aWRlcyB0aGUgcG9zaXRpb24gb2YgdGhlIHJhbmdlIGluIHRoZSBvbGQgZG9jdW1lbnQsIGBwb3NCYFxuICAgIHRoZSBuZXcgcG9zaXRpb24gaW4gdGhlIGNoYW5nZWQgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBpdGVyR2FwcyhmKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3NBID0gMCwgcG9zQiA9IDA7IGkgPCB0aGlzLnNlY3Rpb25zLmxlbmd0aDspIHtcbiAgICAgICAgICAgIGxldCBsZW4gPSB0aGlzLnNlY3Rpb25zW2krK10sIGlucyA9IHRoaXMuc2VjdGlvbnNbaSsrXTtcbiAgICAgICAgICAgIGlmIChpbnMgPCAwKSB7XG4gICAgICAgICAgICAgICAgZihwb3NBLCBwb3NCLCBsZW4pO1xuICAgICAgICAgICAgICAgIHBvc0IgKz0gbGVuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcG9zQiArPSBpbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3NBICs9IGxlbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBJdGVyYXRlIG92ZXIgdGhlIHJhbmdlcyBjaGFuZ2VkIGJ5IHRoZXNlIGNoYW5nZXMuIChTZWVcbiAgICBbYENoYW5nZVNldC5pdGVyQ2hhbmdlc2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuQ2hhbmdlU2V0Lml0ZXJDaGFuZ2VzKSBmb3IgYVxuICAgIHZhcmlhbnQgdGhhdCBhbHNvIHByb3ZpZGVzIHlvdSB3aXRoIHRoZSBpbnNlcnRlZCB0ZXh0LilcbiAgICBgZnJvbUFgL2B0b0FgIHByb3ZpZGVzIHRoZSBleHRlbnQgb2YgdGhlIGNoYW5nZSBpbiB0aGUgc3RhcnRpbmdcbiAgICBkb2N1bWVudCwgYGZyb21CYC9gdG9CYCB0aGUgZXh0ZW50IG9mIHRoZSByZXBsYWNlbWVudCBpbiB0aGVcbiAgICBjaGFuZ2VkIGRvY3VtZW50LlxuICAgIFxuICAgIFdoZW4gYGluZGl2aWR1YWxgIGlzIHRydWUsIGFkamFjZW50IGNoYW5nZXMgKHdoaWNoIGFyZSBrZXB0XG4gICAgc2VwYXJhdGUgZm9yIFtwb3NpdGlvbiBtYXBwaW5nXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkNoYW5nZURlc2MubWFwUG9zKSkgYXJlXG4gICAgcmVwb3J0ZWQgc2VwYXJhdGVseS5cbiAgICAqL1xuICAgIGl0ZXJDaGFuZ2VkUmFuZ2VzKGYsIGluZGl2aWR1YWwgPSBmYWxzZSkge1xuICAgICAgICBpdGVyQ2hhbmdlcyh0aGlzLCBmLCBpbmRpdmlkdWFsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IGEgZGVzY3JpcHRpb24gb2YgdGhlIGludmVydGVkIGZvcm0gb2YgdGhlc2UgY2hhbmdlcy5cbiAgICAqL1xuICAgIGdldCBpbnZlcnRlZERlc2MoKSB7XG4gICAgICAgIGxldCBzZWN0aW9ucyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2VjdGlvbnMubGVuZ3RoOykge1xuICAgICAgICAgICAgbGV0IGxlbiA9IHRoaXMuc2VjdGlvbnNbaSsrXSwgaW5zID0gdGhpcy5zZWN0aW9uc1tpKytdO1xuICAgICAgICAgICAgaWYgKGlucyA8IDApXG4gICAgICAgICAgICAgICAgc2VjdGlvbnMucHVzaChsZW4sIGlucyk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgc2VjdGlvbnMucHVzaChpbnMsIGxlbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBDaGFuZ2VEZXNjKHNlY3Rpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29tcHV0ZSB0aGUgY29tYmluZWQgZWZmZWN0IG9mIGFwcGx5aW5nIGFub3RoZXIgc2V0IG9mIGNoYW5nZXNcbiAgICBhZnRlciB0aGlzIG9uZS4gVGhlIGxlbmd0aCBvZiB0aGUgZG9jdW1lbnQgYWZ0ZXIgdGhpcyBzZXQgc2hvdWxkXG4gICAgbWF0Y2ggdGhlIGxlbmd0aCBiZWZvcmUgYG90aGVyYC5cbiAgICAqL1xuICAgIGNvbXBvc2VEZXNjKG90aGVyKSB7IHJldHVybiB0aGlzLmVtcHR5ID8gb3RoZXIgOiBvdGhlci5lbXB0eSA/IHRoaXMgOiBjb21wb3NlU2V0cyh0aGlzLCBvdGhlcik7IH1cbiAgICAvKipcbiAgICBNYXAgdGhpcyBkZXNjcmlwdGlvbiwgd2hpY2ggc2hvdWxkIHN0YXJ0IHdpdGggdGhlIHNhbWUgZG9jdW1lbnRcbiAgICBhcyBgb3RoZXJgLCBvdmVyIGFub3RoZXIgc2V0IG9mIGNoYW5nZXMsIHNvIHRoYXQgaXQgY2FuIGJlXG4gICAgYXBwbGllZCBhZnRlciBpdC4gV2hlbiBgYmVmb3JlYCBpcyB0cnVlLCBtYXAgYXMgaWYgdGhlIGNoYW5nZXNcbiAgICBpbiBgb3RoZXJgIGhhcHBlbmVkIGJlZm9yZSB0aGUgb25lcyBpbiBgdGhpc2AuXG4gICAgKi9cbiAgICBtYXBEZXNjKG90aGVyLCBiZWZvcmUgPSBmYWxzZSkgeyByZXR1cm4gb3RoZXIuZW1wdHkgPyB0aGlzIDogbWFwU2V0KHRoaXMsIG90aGVyLCBiZWZvcmUpOyB9XG4gICAgbWFwUG9zKHBvcywgYXNzb2MgPSAtMSwgbW9kZSA9IE1hcE1vZGUuU2ltcGxlKSB7XG4gICAgICAgIGxldCBwb3NBID0gMCwgcG9zQiA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zZWN0aW9ucy5sZW5ndGg7KSB7XG4gICAgICAgICAgICBsZXQgbGVuID0gdGhpcy5zZWN0aW9uc1tpKytdLCBpbnMgPSB0aGlzLnNlY3Rpb25zW2krK10sIGVuZEEgPSBwb3NBICsgbGVuO1xuICAgICAgICAgICAgaWYgKGlucyA8IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoZW5kQSA+IHBvcylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBvc0IgKyAocG9zIC0gcG9zQSk7XG4gICAgICAgICAgICAgICAgcG9zQiArPSBsZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAobW9kZSAhPSBNYXBNb2RlLlNpbXBsZSAmJiBlbmRBID49IHBvcyAmJlxuICAgICAgICAgICAgICAgICAgICAobW9kZSA9PSBNYXBNb2RlLlRyYWNrRGVsICYmIHBvc0EgPCBwb3MgJiYgZW5kQSA+IHBvcyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZSA9PSBNYXBNb2RlLlRyYWNrQmVmb3JlICYmIHBvc0EgPCBwb3MgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGUgPT0gTWFwTW9kZS5UcmFja0FmdGVyICYmIGVuZEEgPiBwb3MpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoZW5kQSA+IHBvcyB8fCBlbmRBID09IHBvcyAmJiBhc3NvYyA8IDAgJiYgIWxlbilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBvcyA9PSBwb3NBIHx8IGFzc29jIDwgMCA/IHBvc0IgOiBwb3NCICsgaW5zO1xuICAgICAgICAgICAgICAgIHBvc0IgKz0gaW5zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zQSA9IGVuZEE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvcyA+IHBvc0EpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgUG9zaXRpb24gJHtwb3N9IGlzIG91dCBvZiByYW5nZSBmb3IgY2hhbmdlc2V0IG9mIGxlbmd0aCAke3Bvc0F9YCk7XG4gICAgICAgIHJldHVybiBwb3NCO1xuICAgIH1cbiAgICAvKipcbiAgICBDaGVjayB3aGV0aGVyIHRoZXNlIGNoYW5nZXMgdG91Y2ggYSBnaXZlbiByYW5nZS4gV2hlbiBvbmUgb2YgdGhlXG4gICAgY2hhbmdlcyBlbnRpcmVseSBjb3ZlcnMgdGhlIHJhbmdlLCB0aGUgc3RyaW5nIGBcImNvdmVyXCJgIGlzXG4gICAgcmV0dXJuZWQuXG4gICAgKi9cbiAgICB0b3VjaGVzUmFuZ2UoZnJvbSwgdG8gPSBmcm9tKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3MgPSAwOyBpIDwgdGhpcy5zZWN0aW9ucy5sZW5ndGggJiYgcG9zIDw9IHRvOykge1xuICAgICAgICAgICAgbGV0IGxlbiA9IHRoaXMuc2VjdGlvbnNbaSsrXSwgaW5zID0gdGhpcy5zZWN0aW9uc1tpKytdLCBlbmQgPSBwb3MgKyBsZW47XG4gICAgICAgICAgICBpZiAoaW5zID49IDAgJiYgcG9zIDw9IHRvICYmIGVuZCA+PSBmcm9tKVxuICAgICAgICAgICAgICAgIHJldHVybiBwb3MgPCBmcm9tICYmIGVuZCA+IHRvID8gXCJjb3ZlclwiIDogdHJ1ZTtcbiAgICAgICAgICAgIHBvcyA9IGVuZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2VjdGlvbnMubGVuZ3RoOykge1xuICAgICAgICAgICAgbGV0IGxlbiA9IHRoaXMuc2VjdGlvbnNbaSsrXSwgaW5zID0gdGhpcy5zZWN0aW9uc1tpKytdO1xuICAgICAgICAgICAgcmVzdWx0ICs9IChyZXN1bHQgPyBcIiBcIiA6IFwiXCIpICsgbGVuICsgKGlucyA+PSAwID8gXCI6XCIgKyBpbnMgOiBcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICBTZXJpYWxpemUgdGhpcyBjaGFuZ2UgZGVzYyB0byBhIEpTT04tcmVwcmVzZW50YWJsZSB2YWx1ZS5cbiAgICAqL1xuICAgIHRvSlNPTigpIHsgcmV0dXJuIHRoaXMuc2VjdGlvbnM7IH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBjaGFuZ2UgZGVzYyBmcm9tIGl0cyBKU09OIHJlcHJlc2VudGF0aW9uIChhcyBwcm9kdWNlZFxuICAgIGJ5IFtgdG9KU09OYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5DaGFuZ2VEZXNjLnRvSlNPTikuXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oanNvbikge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoanNvbikgfHwganNvbi5sZW5ndGggJSAyIHx8IGpzb24uc29tZShhID0+IHR5cGVvZiBhICE9IFwibnVtYmVyXCIpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIEpTT04gcmVwcmVzZW50YXRpb24gb2YgQ2hhbmdlRGVzY1wiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBDaGFuZ2VEZXNjKGpzb24pO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUoc2VjdGlvbnMpIHsgcmV0dXJuIG5ldyBDaGFuZ2VEZXNjKHNlY3Rpb25zKTsgfVxufVxuLyoqXG5BIGNoYW5nZSBzZXQgcmVwcmVzZW50cyBhIGdyb3VwIG9mIG1vZGlmaWNhdGlvbnMgdG8gYSBkb2N1bWVudC4gSXRcbnN0b3JlcyB0aGUgZG9jdW1lbnQgbGVuZ3RoLCBhbmQgY2FuIG9ubHkgYmUgYXBwbGllZCB0byBkb2N1bWVudHNcbndpdGggZXhhY3RseSB0aGF0IGxlbmd0aC5cbiovXG5jbGFzcyBDaGFuZ2VTZXQgZXh0ZW5kcyBDaGFuZ2VEZXNjIHtcbiAgICBjb25zdHJ1Y3RvcihzZWN0aW9ucywgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBpbnNlcnRlZCkge1xuICAgICAgICBzdXBlcihzZWN0aW9ucyk7XG4gICAgICAgIHRoaXMuaW5zZXJ0ZWQgPSBpbnNlcnRlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgQXBwbHkgdGhlIGNoYW5nZXMgdG8gYSBkb2N1bWVudCwgcmV0dXJuaW5nIHRoZSBtb2RpZmllZFxuICAgIGRvY3VtZW50LlxuICAgICovXG4gICAgYXBwbHkoZG9jKSB7XG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCAhPSBkb2MubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJBcHBseWluZyBjaGFuZ2Ugc2V0IHRvIGEgZG9jdW1lbnQgd2l0aCB0aGUgd3JvbmcgbGVuZ3RoXCIpO1xuICAgICAgICBpdGVyQ2hhbmdlcyh0aGlzLCAoZnJvbUEsIHRvQSwgZnJvbUIsIF90b0IsIHRleHQpID0+IGRvYyA9IGRvYy5yZXBsYWNlKGZyb21CLCBmcm9tQiArICh0b0EgLSBmcm9tQSksIHRleHQpLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiBkb2M7XG4gICAgfVxuICAgIG1hcERlc2Mob3RoZXIsIGJlZm9yZSA9IGZhbHNlKSB7IHJldHVybiBtYXBTZXQodGhpcywgb3RoZXIsIGJlZm9yZSwgdHJ1ZSk7IH1cbiAgICAvKipcbiAgICBHaXZlbiB0aGUgZG9jdW1lbnQgYXMgaXQgZXhpc3RlZCBfYmVmb3JlXyB0aGUgY2hhbmdlcywgcmV0dXJuIGFcbiAgICBjaGFuZ2Ugc2V0IHRoYXQgcmVwcmVzZW50cyB0aGUgaW52ZXJzZSBvZiB0aGlzIHNldCwgd2hpY2ggY291bGRcbiAgICBiZSB1c2VkIHRvIGdvIGZyb20gdGhlIGRvY3VtZW50IGNyZWF0ZWQgYnkgdGhlIGNoYW5nZXMgYmFjayB0b1xuICAgIHRoZSBkb2N1bWVudCBhcyBpdCBleGlzdGVkIGJlZm9yZSB0aGUgY2hhbmdlcy5cbiAgICAqL1xuICAgIGludmVydChkb2MpIHtcbiAgICAgICAgbGV0IHNlY3Rpb25zID0gdGhpcy5zZWN0aW9ucy5zbGljZSgpLCBpbnNlcnRlZCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gMDsgaSA8IHNlY3Rpb25zLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICBsZXQgbGVuID0gc2VjdGlvbnNbaV0sIGlucyA9IHNlY3Rpb25zW2kgKyAxXTtcbiAgICAgICAgICAgIGlmIChpbnMgPj0gMCkge1xuICAgICAgICAgICAgICAgIHNlY3Rpb25zW2ldID0gaW5zO1xuICAgICAgICAgICAgICAgIHNlY3Rpb25zW2kgKyAxXSA9IGxlbjtcbiAgICAgICAgICAgICAgICBsZXQgaW5kZXggPSBpID4+IDE7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGluc2VydGVkLmxlbmd0aCA8IGluZGV4KVxuICAgICAgICAgICAgICAgICAgICBpbnNlcnRlZC5wdXNoKFRleHQuZW1wdHkpO1xuICAgICAgICAgICAgICAgIGluc2VydGVkLnB1c2gobGVuID8gZG9jLnNsaWNlKHBvcywgcG9zICsgbGVuKSA6IFRleHQuZW1wdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zICs9IGxlbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IENoYW5nZVNldChzZWN0aW9ucywgaW5zZXJ0ZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICBDb21iaW5lIHR3byBzdWJzZXF1ZW50IGNoYW5nZSBzZXRzIGludG8gYSBzaW5nbGUgc2V0LiBgb3RoZXJgXG4gICAgbXVzdCBzdGFydCBpbiB0aGUgZG9jdW1lbnQgcHJvZHVjZWQgYnkgYHRoaXNgLiBJZiBgdGhpc2AgZ29lc1xuICAgIGBkb2NBYCDihpIgYGRvY0JgIGFuZCBgb3RoZXJgIHJlcHJlc2VudHMgYGRvY0JgIOKGkiBgZG9jQ2AsIHRoZVxuICAgIHJldHVybmVkIHZhbHVlIHdpbGwgcmVwcmVzZW50IHRoZSBjaGFuZ2UgYGRvY0FgIOKGkiBgZG9jQ2AuXG4gICAgKi9cbiAgICBjb21wb3NlKG90aGVyKSB7IHJldHVybiB0aGlzLmVtcHR5ID8gb3RoZXIgOiBvdGhlci5lbXB0eSA/IHRoaXMgOiBjb21wb3NlU2V0cyh0aGlzLCBvdGhlciwgdHJ1ZSk7IH1cbiAgICAvKipcbiAgICBHaXZlbiBhbm90aGVyIGNoYW5nZSBzZXQgc3RhcnRpbmcgaW4gdGhlIHNhbWUgZG9jdW1lbnQsIG1hcHMgdGhpc1xuICAgIGNoYW5nZSBzZXQgb3ZlciB0aGUgb3RoZXIsIHByb2R1Y2luZyBhIG5ldyBjaGFuZ2Ugc2V0IHRoYXQgY2FuIGJlXG4gICAgYXBwbGllZCB0byB0aGUgZG9jdW1lbnQgcHJvZHVjZWQgYnkgYXBwbHlpbmcgYG90aGVyYC4gV2hlblxuICAgIGBiZWZvcmVgIGlzIGB0cnVlYCwgb3JkZXIgY2hhbmdlcyBhcyBpZiBgdGhpc2AgY29tZXMgYmVmb3JlXG4gICAgYG90aGVyYCwgb3RoZXJ3aXNlICh0aGUgZGVmYXVsdCkgdHJlYXQgYG90aGVyYCBhcyBjb21pbmcgZmlyc3QuXG4gICAgXG4gICAgR2l2ZW4gdHdvIGNoYW5nZXMgYEFgIGFuZCBgQmAsIGBBLmNvbXBvc2UoQi5tYXAoQSkpYCBhbmRcbiAgICBgQi5jb21wb3NlKEEubWFwKEIsIHRydWUpKWAgd2lsbCBwcm9kdWNlIHRoZSBzYW1lIGRvY3VtZW50LiBUaGlzXG4gICAgcHJvdmlkZXMgYSBiYXNpYyBmb3JtIG9mIFtvcGVyYXRpb25hbFxuICAgIHRyYW5zZm9ybWF0aW9uXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9PcGVyYXRpb25hbF90cmFuc2Zvcm1hdGlvbiksXG4gICAgYW5kIGNhbiBiZSB1c2VkIGZvciBjb2xsYWJvcmF0aXZlIGVkaXRpbmcuXG4gICAgKi9cbiAgICBtYXAob3RoZXIsIGJlZm9yZSA9IGZhbHNlKSB7IHJldHVybiBvdGhlci5lbXB0eSA/IHRoaXMgOiBtYXBTZXQodGhpcywgb3RoZXIsIGJlZm9yZSwgdHJ1ZSk7IH1cbiAgICAvKipcbiAgICBJdGVyYXRlIG92ZXIgdGhlIGNoYW5nZWQgcmFuZ2VzIGluIHRoZSBkb2N1bWVudCwgY2FsbGluZyBgZmAgZm9yXG4gICAgZWFjaCwgd2l0aCB0aGUgcmFuZ2UgaW4gdGhlIG9yaWdpbmFsIGRvY3VtZW50IChgZnJvbUFgLWB0b0FgKVxuICAgIGFuZCB0aGUgcmFuZ2UgdGhhdCByZXBsYWNlcyBpdCBpbiB0aGUgbmV3IGRvY3VtZW50XG4gICAgKGBmcm9tQmAtYHRvQmApLlxuICAgIFxuICAgIFdoZW4gYGluZGl2aWR1YWxgIGlzIHRydWUsIGFkamFjZW50IGNoYW5nZXMgYXJlIHJlcG9ydGVkXG4gICAgc2VwYXJhdGVseS5cbiAgICAqL1xuICAgIGl0ZXJDaGFuZ2VzKGYsIGluZGl2aWR1YWwgPSBmYWxzZSkge1xuICAgICAgICBpdGVyQ2hhbmdlcyh0aGlzLCBmLCBpbmRpdmlkdWFsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IGEgW2NoYW5nZSBkZXNjcmlwdGlvbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5DaGFuZ2VEZXNjKSBmb3IgdGhpcyBjaGFuZ2VcbiAgICBzZXQuXG4gICAgKi9cbiAgICBnZXQgZGVzYygpIHsgcmV0dXJuIENoYW5nZURlc2MuY3JlYXRlKHRoaXMuc2VjdGlvbnMpOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBmaWx0ZXIocmFuZ2VzKSB7XG4gICAgICAgIGxldCByZXN1bHRTZWN0aW9ucyA9IFtdLCByZXN1bHRJbnNlcnRlZCA9IFtdLCBmaWx0ZXJlZFNlY3Rpb25zID0gW107XG4gICAgICAgIGxldCBpdGVyID0gbmV3IFNlY3Rpb25JdGVyKHRoaXMpO1xuICAgICAgICBkb25lOiBmb3IgKGxldCBpID0gMCwgcG9zID0gMDs7KSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IGkgPT0gcmFuZ2VzLmxlbmd0aCA/IDFlOSA6IHJhbmdlc1tpKytdO1xuICAgICAgICAgICAgd2hpbGUgKHBvcyA8IG5leHQgfHwgcG9zID09IG5leHQgJiYgaXRlci5sZW4gPT0gMCkge1xuICAgICAgICAgICAgICAgIGlmIChpdGVyLmRvbmUpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrIGRvbmU7XG4gICAgICAgICAgICAgICAgbGV0IGxlbiA9IE1hdGgubWluKGl0ZXIubGVuLCBuZXh0IC0gcG9zKTtcbiAgICAgICAgICAgICAgICBhZGRTZWN0aW9uKGZpbHRlcmVkU2VjdGlvbnMsIGxlbiwgLTEpO1xuICAgICAgICAgICAgICAgIGxldCBpbnMgPSBpdGVyLmlucyA9PSAtMSA/IC0xIDogaXRlci5vZmYgPT0gMCA/IGl0ZXIuaW5zIDogMDtcbiAgICAgICAgICAgICAgICBhZGRTZWN0aW9uKHJlc3VsdFNlY3Rpb25zLCBsZW4sIGlucyk7XG4gICAgICAgICAgICAgICAgaWYgKGlucyA+IDApXG4gICAgICAgICAgICAgICAgICAgIGFkZEluc2VydChyZXN1bHRJbnNlcnRlZCwgcmVzdWx0U2VjdGlvbnMsIGl0ZXIudGV4dCk7XG4gICAgICAgICAgICAgICAgaXRlci5mb3J3YXJkKGxlbik7XG4gICAgICAgICAgICAgICAgcG9zICs9IGxlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBlbmQgPSByYW5nZXNbaSsrXTtcbiAgICAgICAgICAgIHdoaWxlIChwb3MgPCBlbmQpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlci5kb25lKVxuICAgICAgICAgICAgICAgICAgICBicmVhayBkb25lO1xuICAgICAgICAgICAgICAgIGxldCBsZW4gPSBNYXRoLm1pbihpdGVyLmxlbiwgZW5kIC0gcG9zKTtcbiAgICAgICAgICAgICAgICBhZGRTZWN0aW9uKHJlc3VsdFNlY3Rpb25zLCBsZW4sIC0xKTtcbiAgICAgICAgICAgICAgICBhZGRTZWN0aW9uKGZpbHRlcmVkU2VjdGlvbnMsIGxlbiwgaXRlci5pbnMgPT0gLTEgPyAtMSA6IGl0ZXIub2ZmID09IDAgPyBpdGVyLmlucyA6IDApO1xuICAgICAgICAgICAgICAgIGl0ZXIuZm9yd2FyZChsZW4pO1xuICAgICAgICAgICAgICAgIHBvcyArPSBsZW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogbmV3IENoYW5nZVNldChyZXN1bHRTZWN0aW9ucywgcmVzdWx0SW5zZXJ0ZWQpLFxuICAgICAgICAgICAgZmlsdGVyZWQ6IENoYW5nZURlc2MuY3JlYXRlKGZpbHRlcmVkU2VjdGlvbnMpIH07XG4gICAgfVxuICAgIC8qKlxuICAgIFNlcmlhbGl6ZSB0aGlzIGNoYW5nZSBzZXQgdG8gYSBKU09OLXJlcHJlc2VudGFibGUgdmFsdWUuXG4gICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGxldCBwYXJ0cyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2VjdGlvbnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgIGxldCBsZW4gPSB0aGlzLnNlY3Rpb25zW2ldLCBpbnMgPSB0aGlzLnNlY3Rpb25zW2kgKyAxXTtcbiAgICAgICAgICAgIGlmIChpbnMgPCAwKVxuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2gobGVuKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlucyA9PSAwKVxuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2goW2xlbl0pO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2goW2xlbl0uY29uY2F0KHRoaXMuaW5zZXJ0ZWRbaSA+PiAxXS50b0pTT04oKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJ0cztcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgY2hhbmdlIHNldCBmb3IgdGhlIGdpdmVuIGNoYW5nZXMsIGZvciBhIGRvY3VtZW50IG9mIHRoZVxuICAgIGdpdmVuIGxlbmd0aCwgdXNpbmcgYGxpbmVTZXBgIGFzIGxpbmUgc2VwYXJhdG9yLlxuICAgICovXG4gICAgc3RhdGljIG9mKGNoYW5nZXMsIGxlbmd0aCwgbGluZVNlcCkge1xuICAgICAgICBsZXQgc2VjdGlvbnMgPSBbXSwgaW5zZXJ0ZWQgPSBbXSwgcG9zID0gMDtcbiAgICAgICAgbGV0IHRvdGFsID0gbnVsbDtcbiAgICAgICAgZnVuY3Rpb24gZmx1c2goZm9yY2UgPSBmYWxzZSkge1xuICAgICAgICAgICAgaWYgKCFmb3JjZSAmJiAhc2VjdGlvbnMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmIChwb3MgPCBsZW5ndGgpXG4gICAgICAgICAgICAgICAgYWRkU2VjdGlvbihzZWN0aW9ucywgbGVuZ3RoIC0gcG9zLCAtMSk7XG4gICAgICAgICAgICBsZXQgc2V0ID0gbmV3IENoYW5nZVNldChzZWN0aW9ucywgaW5zZXJ0ZWQpO1xuICAgICAgICAgICAgdG90YWwgPSB0b3RhbCA/IHRvdGFsLmNvbXBvc2Uoc2V0Lm1hcCh0b3RhbCkpIDogc2V0O1xuICAgICAgICAgICAgc2VjdGlvbnMgPSBbXTtcbiAgICAgICAgICAgIGluc2VydGVkID0gW107XG4gICAgICAgICAgICBwb3MgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHByb2Nlc3Moc3BlYykge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc3BlYykpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBzdWIgb2Ygc3BlYylcbiAgICAgICAgICAgICAgICAgICAgcHJvY2VzcyhzdWIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3BlYyBpbnN0YW5jZW9mIENoYW5nZVNldCkge1xuICAgICAgICAgICAgICAgIGlmIChzcGVjLmxlbmd0aCAhPSBsZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBNaXNtYXRjaGVkIGNoYW5nZSBzZXQgbGVuZ3RoIChnb3QgJHtzcGVjLmxlbmd0aH0sIGV4cGVjdGVkICR7bGVuZ3RofSlgKTtcbiAgICAgICAgICAgICAgICBmbHVzaCgpO1xuICAgICAgICAgICAgICAgIHRvdGFsID0gdG90YWwgPyB0b3RhbC5jb21wb3NlKHNwZWMubWFwKHRvdGFsKSkgOiBzcGVjO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgZnJvbSwgdG8gPSBmcm9tLCBpbnNlcnQgfSA9IHNwZWM7XG4gICAgICAgICAgICAgICAgaWYgKGZyb20gPiB0byB8fCBmcm9tIDwgMCB8fCB0byA+IGxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEludmFsaWQgY2hhbmdlIHJhbmdlICR7ZnJvbX0gdG8gJHt0b30gKGluIGRvYyBvZiBsZW5ndGggJHtsZW5ndGh9KWApO1xuICAgICAgICAgICAgICAgIGxldCBpbnNUZXh0ID0gIWluc2VydCA/IFRleHQuZW1wdHkgOiB0eXBlb2YgaW5zZXJ0ID09IFwic3RyaW5nXCIgPyBUZXh0Lm9mKGluc2VydC5zcGxpdChsaW5lU2VwIHx8IERlZmF1bHRTcGxpdCkpIDogaW5zZXJ0O1xuICAgICAgICAgICAgICAgIGxldCBpbnNMZW4gPSBpbnNUZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbSA9PSB0byAmJiBpbnNMZW4gPT0gMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmIChmcm9tIDwgcG9zKVxuICAgICAgICAgICAgICAgICAgICBmbHVzaCgpO1xuICAgICAgICAgICAgICAgIGlmIChmcm9tID4gcG9zKVxuICAgICAgICAgICAgICAgICAgICBhZGRTZWN0aW9uKHNlY3Rpb25zLCBmcm9tIC0gcG9zLCAtMSk7XG4gICAgICAgICAgICAgICAgYWRkU2VjdGlvbihzZWN0aW9ucywgdG8gLSBmcm9tLCBpbnNMZW4pO1xuICAgICAgICAgICAgICAgIGFkZEluc2VydChpbnNlcnRlZCwgc2VjdGlvbnMsIGluc1RleHQpO1xuICAgICAgICAgICAgICAgIHBvcyA9IHRvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHByb2Nlc3MoY2hhbmdlcyk7XG4gICAgICAgIGZsdXNoKCF0b3RhbCk7XG4gICAgICAgIHJldHVybiB0b3RhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGFuIGVtcHR5IGNoYW5nZXNldCBvZiB0aGUgZ2l2ZW4gbGVuZ3RoLlxuICAgICovXG4gICAgc3RhdGljIGVtcHR5KGxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbmV3IENoYW5nZVNldChsZW5ndGggPyBbbGVuZ3RoLCAtMV0gOiBbXSwgW10pO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBjaGFuZ2VzZXQgZnJvbSBpdHMgSlNPTiByZXByZXNlbnRhdGlvbiAoYXMgcHJvZHVjZWQgYnlcbiAgICBbYHRvSlNPTmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuQ2hhbmdlU2V0LnRvSlNPTikuXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oanNvbikge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoanNvbikpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgSlNPTiByZXByZXNlbnRhdGlvbiBvZiBDaGFuZ2VTZXRcIik7XG4gICAgICAgIGxldCBzZWN0aW9ucyA9IFtdLCBpbnNlcnRlZCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGpzb24ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBwYXJ0ID0ganNvbltpXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGFydCA9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgc2VjdGlvbnMucHVzaChwYXJ0LCAtMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghQXJyYXkuaXNBcnJheShwYXJ0KSB8fCB0eXBlb2YgcGFydFswXSAhPSBcIm51bWJlclwiIHx8IHBhcnQuc29tZSgoZSwgaSkgPT4gaSAmJiB0eXBlb2YgZSAhPSBcInN0cmluZ1wiKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBKU09OIHJlcHJlc2VudGF0aW9uIG9mIENoYW5nZVNldFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcnQubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgICAgICBzZWN0aW9ucy5wdXNoKHBhcnRbMF0sIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGluc2VydGVkLmxlbmd0aCA8IGkpXG4gICAgICAgICAgICAgICAgICAgIGluc2VydGVkLnB1c2goVGV4dC5lbXB0eSk7XG4gICAgICAgICAgICAgICAgaW5zZXJ0ZWRbaV0gPSBUZXh0Lm9mKHBhcnQuc2xpY2UoMSkpO1xuICAgICAgICAgICAgICAgIHNlY3Rpb25zLnB1c2gocGFydFswXSwgaW5zZXJ0ZWRbaV0ubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IENoYW5nZVNldChzZWN0aW9ucywgaW5zZXJ0ZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVTZXQoc2VjdGlvbnMsIGluc2VydGVkKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2hhbmdlU2V0KHNlY3Rpb25zLCBpbnNlcnRlZCk7XG4gICAgfVxufVxuZnVuY3Rpb24gYWRkU2VjdGlvbihzZWN0aW9ucywgbGVuLCBpbnMsIGZvcmNlSm9pbiA9IGZhbHNlKSB7XG4gICAgaWYgKGxlbiA9PSAwICYmIGlucyA8PSAwKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0IGxhc3QgPSBzZWN0aW9ucy5sZW5ndGggLSAyO1xuICAgIGlmIChsYXN0ID49IDAgJiYgaW5zIDw9IDAgJiYgaW5zID09IHNlY3Rpb25zW2xhc3QgKyAxXSlcbiAgICAgICAgc2VjdGlvbnNbbGFzdF0gKz0gbGVuO1xuICAgIGVsc2UgaWYgKGxlbiA9PSAwICYmIHNlY3Rpb25zW2xhc3RdID09IDApXG4gICAgICAgIHNlY3Rpb25zW2xhc3QgKyAxXSArPSBpbnM7XG4gICAgZWxzZSBpZiAoZm9yY2VKb2luKSB7XG4gICAgICAgIHNlY3Rpb25zW2xhc3RdICs9IGxlbjtcbiAgICAgICAgc2VjdGlvbnNbbGFzdCArIDFdICs9IGlucztcbiAgICB9XG4gICAgZWxzZVxuICAgICAgICBzZWN0aW9ucy5wdXNoKGxlbiwgaW5zKTtcbn1cbmZ1bmN0aW9uIGFkZEluc2VydCh2YWx1ZXMsIHNlY3Rpb25zLCB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZS5sZW5ndGggPT0gMClcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCBpbmRleCA9IChzZWN0aW9ucy5sZW5ndGggLSAyKSA+PiAxO1xuICAgIGlmIChpbmRleCA8IHZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgdmFsdWVzW3ZhbHVlcy5sZW5ndGggLSAxXSA9IHZhbHVlc1t2YWx1ZXMubGVuZ3RoIC0gMV0uYXBwZW5kKHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHdoaWxlICh2YWx1ZXMubGVuZ3RoIDwgaW5kZXgpXG4gICAgICAgICAgICB2YWx1ZXMucHVzaChUZXh0LmVtcHR5KTtcbiAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGl0ZXJDaGFuZ2VzKGRlc2MsIGYsIGluZGl2aWR1YWwpIHtcbiAgICBsZXQgaW5zZXJ0ZWQgPSBkZXNjLmluc2VydGVkO1xuICAgIGZvciAobGV0IHBvc0EgPSAwLCBwb3NCID0gMCwgaSA9IDA7IGkgPCBkZXNjLnNlY3Rpb25zLmxlbmd0aDspIHtcbiAgICAgICAgbGV0IGxlbiA9IGRlc2Muc2VjdGlvbnNbaSsrXSwgaW5zID0gZGVzYy5zZWN0aW9uc1tpKytdO1xuICAgICAgICBpZiAoaW5zIDwgMCkge1xuICAgICAgICAgICAgcG9zQSArPSBsZW47XG4gICAgICAgICAgICBwb3NCICs9IGxlbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBlbmRBID0gcG9zQSwgZW5kQiA9IHBvc0IsIHRleHQgPSBUZXh0LmVtcHR5O1xuICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgIGVuZEEgKz0gbGVuO1xuICAgICAgICAgICAgICAgIGVuZEIgKz0gaW5zO1xuICAgICAgICAgICAgICAgIGlmIChpbnMgJiYgaW5zZXJ0ZWQpXG4gICAgICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0LmFwcGVuZChpbnNlcnRlZFsoaSAtIDIpID4+IDFdKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kaXZpZHVhbCB8fCBpID09IGRlc2Muc2VjdGlvbnMubGVuZ3RoIHx8IGRlc2Muc2VjdGlvbnNbaSArIDFdIDwgMClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgbGVuID0gZGVzYy5zZWN0aW9uc1tpKytdO1xuICAgICAgICAgICAgICAgIGlucyA9IGRlc2Muc2VjdGlvbnNbaSsrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGYocG9zQSwgZW5kQSwgcG9zQiwgZW5kQiwgdGV4dCk7XG4gICAgICAgICAgICBwb3NBID0gZW5kQTtcbiAgICAgICAgICAgIHBvc0IgPSBlbmRCO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gbWFwU2V0KHNldEEsIHNldEIsIGJlZm9yZSwgbWtTZXQgPSBmYWxzZSkge1xuICAgIC8vIFByb2R1Y2UgYSBjb3B5IG9mIHNldEEgdGhhdCBhcHBsaWVzIHRvIHRoZSBkb2N1bWVudCBhZnRlciBzZXRCXG4gICAgLy8gaGFzIGJlZW4gYXBwbGllZCAoYXNzdW1pbmcgYm90aCBzdGFydCBhdCB0aGUgc2FtZSBkb2N1bWVudCkuXG4gICAgbGV0IHNlY3Rpb25zID0gW10sIGluc2VydCA9IG1rU2V0ID8gW10gOiBudWxsO1xuICAgIGxldCBhID0gbmV3IFNlY3Rpb25JdGVyKHNldEEpLCBiID0gbmV3IFNlY3Rpb25JdGVyKHNldEIpO1xuICAgIC8vIEl0ZXJhdGUgb3ZlciBib3RoIHNldHMgaW4gcGFyYWxsZWwuIGluc2VydGVkIHRyYWNrcywgZm9yIGNoYW5nZXNcbiAgICAvLyBpbiBBIHRoYXQgaGF2ZSB0byBiZSBwcm9jZXNzZWQgcGllY2UtYnktcGllY2UsIHdoZXRoZXIgdGhlaXJcbiAgICAvLyBjb250ZW50IGhhcyBiZWVuIGluc2VydGVkIGFscmVhZHksIGFuZCByZWZlcnMgdG8gdGhlIHNlY3Rpb25cbiAgICAvLyBpbmRleC5cbiAgICBmb3IgKGxldCBpbnNlcnRlZCA9IC0xOzspIHtcbiAgICAgICAgaWYgKGEuaW5zID09IC0xICYmIGIuaW5zID09IC0xKSB7XG4gICAgICAgICAgICAvLyBNb3ZlIGFjcm9zcyByYW5nZXMgc2tpcHBlZCBieSBib3RoIHNldHMuXG4gICAgICAgICAgICBsZXQgbGVuID0gTWF0aC5taW4oYS5sZW4sIGIubGVuKTtcbiAgICAgICAgICAgIGFkZFNlY3Rpb24oc2VjdGlvbnMsIGxlbiwgLTEpO1xuICAgICAgICAgICAgYS5mb3J3YXJkKGxlbik7XG4gICAgICAgICAgICBiLmZvcndhcmQobGVuKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChiLmlucyA+PSAwICYmIChhLmlucyA8IDAgfHwgaW5zZXJ0ZWQgPT0gYS5pIHx8IGEub2ZmID09IDAgJiYgKGIubGVuIDwgYS5sZW4gfHwgYi5sZW4gPT0gYS5sZW4gJiYgIWJlZm9yZSkpKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSdzIGEgY2hhbmdlIGluIEIgdGhhdCBjb21lcyBiZWZvcmUgdGhlIG5leHQgY2hhbmdlIGluXG4gICAgICAgICAgICAvLyBBIChvcmRlcmVkIGJ5IHN0YXJ0IHBvcywgdGhlbiBsZW4sIHRoZW4gYmVmb3JlIGZsYWcpLCBza2lwXG4gICAgICAgICAgICAvLyB0aGF0IChhbmQgcHJvY2VzcyBhbnkgY2hhbmdlcyBpbiBBIGl0IGNvdmVycykuXG4gICAgICAgICAgICBsZXQgbGVuID0gYi5sZW47XG4gICAgICAgICAgICBhZGRTZWN0aW9uKHNlY3Rpb25zLCBiLmlucywgLTEpO1xuICAgICAgICAgICAgd2hpbGUgKGxlbikge1xuICAgICAgICAgICAgICAgIGxldCBwaWVjZSA9IE1hdGgubWluKGEubGVuLCBsZW4pO1xuICAgICAgICAgICAgICAgIGlmIChhLmlucyA+PSAwICYmIGluc2VydGVkIDwgYS5pICYmIGEubGVuIDw9IHBpZWNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZFNlY3Rpb24oc2VjdGlvbnMsIDAsIGEuaW5zKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluc2VydClcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZEluc2VydChpbnNlcnQsIHNlY3Rpb25zLCBhLnRleHQpO1xuICAgICAgICAgICAgICAgICAgICBpbnNlcnRlZCA9IGEuaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYS5mb3J3YXJkKHBpZWNlKTtcbiAgICAgICAgICAgICAgICBsZW4gLT0gcGllY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiLm5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhLmlucyA+PSAwKSB7XG4gICAgICAgICAgICAvLyBQcm9jZXNzIHRoZSBwYXJ0IG9mIGEgY2hhbmdlIGluIEEgdXAgdG8gdGhlIHN0YXJ0IG9mIHRoZSBuZXh0XG4gICAgICAgICAgICAvLyBub24tZGVsZXRpb24gY2hhbmdlIGluIEIgKGlmIG92ZXJsYXBwaW5nKS5cbiAgICAgICAgICAgIGxldCBsZW4gPSAwLCBsZWZ0ID0gYS5sZW47XG4gICAgICAgICAgICB3aGlsZSAobGVmdCkge1xuICAgICAgICAgICAgICAgIGlmIChiLmlucyA9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcGllY2UgPSBNYXRoLm1pbihsZWZ0LCBiLmxlbik7XG4gICAgICAgICAgICAgICAgICAgIGxlbiArPSBwaWVjZTtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCAtPSBwaWVjZTtcbiAgICAgICAgICAgICAgICAgICAgYi5mb3J3YXJkKHBpZWNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYi5pbnMgPT0gMCAmJiBiLmxlbiA8IGxlZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCAtPSBiLmxlbjtcbiAgICAgICAgICAgICAgICAgICAgYi5uZXh0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZGRTZWN0aW9uKHNlY3Rpb25zLCBsZW4sIGluc2VydGVkIDwgYS5pID8gYS5pbnMgOiAwKTtcbiAgICAgICAgICAgIGlmIChpbnNlcnQgJiYgaW5zZXJ0ZWQgPCBhLmkpXG4gICAgICAgICAgICAgICAgYWRkSW5zZXJ0KGluc2VydCwgc2VjdGlvbnMsIGEudGV4dCk7XG4gICAgICAgICAgICBpbnNlcnRlZCA9IGEuaTtcbiAgICAgICAgICAgIGEuZm9yd2FyZChhLmxlbiAtIGxlZnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGEuZG9uZSAmJiBiLmRvbmUpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnNlcnQgPyBDaGFuZ2VTZXQuY3JlYXRlU2V0KHNlY3Rpb25zLCBpbnNlcnQpIDogQ2hhbmdlRGVzYy5jcmVhdGUoc2VjdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzbWF0Y2hlZCBjaGFuZ2Ugc2V0IGxlbmd0aHNcIik7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBjb21wb3NlU2V0cyhzZXRBLCBzZXRCLCBta1NldCA9IGZhbHNlKSB7XG4gICAgbGV0IHNlY3Rpb25zID0gW107XG4gICAgbGV0IGluc2VydCA9IG1rU2V0ID8gW10gOiBudWxsO1xuICAgIGxldCBhID0gbmV3IFNlY3Rpb25JdGVyKHNldEEpLCBiID0gbmV3IFNlY3Rpb25JdGVyKHNldEIpO1xuICAgIGZvciAobGV0IG9wZW4gPSBmYWxzZTs7KSB7XG4gICAgICAgIGlmIChhLmRvbmUgJiYgYi5kb25lKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5zZXJ0ID8gQ2hhbmdlU2V0LmNyZWF0ZVNldChzZWN0aW9ucywgaW5zZXJ0KSA6IENoYW5nZURlc2MuY3JlYXRlKHNlY3Rpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhLmlucyA9PSAwKSB7IC8vIERlbGV0aW9uIGluIEFcbiAgICAgICAgICAgIGFkZFNlY3Rpb24oc2VjdGlvbnMsIGEubGVuLCAwLCBvcGVuKTtcbiAgICAgICAgICAgIGEubmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGIubGVuID09IDAgJiYgIWIuZG9uZSkgeyAvLyBJbnNlcnRpb24gaW4gQlxuICAgICAgICAgICAgYWRkU2VjdGlvbihzZWN0aW9ucywgMCwgYi5pbnMsIG9wZW4pO1xuICAgICAgICAgICAgaWYgKGluc2VydClcbiAgICAgICAgICAgICAgICBhZGRJbnNlcnQoaW5zZXJ0LCBzZWN0aW9ucywgYi50ZXh0KTtcbiAgICAgICAgICAgIGIubmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGEuZG9uZSB8fCBiLmRvbmUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc21hdGNoZWQgY2hhbmdlIHNldCBsZW5ndGhzXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGxlbiA9IE1hdGgubWluKGEubGVuMiwgYi5sZW4pLCBzZWN0aW9uTGVuID0gc2VjdGlvbnMubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGEuaW5zID09IC0xKSB7XG4gICAgICAgICAgICAgICAgbGV0IGluc0IgPSBiLmlucyA9PSAtMSA/IC0xIDogYi5vZmYgPyAwIDogYi5pbnM7XG4gICAgICAgICAgICAgICAgYWRkU2VjdGlvbihzZWN0aW9ucywgbGVuLCBpbnNCLCBvcGVuKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5zZXJ0ICYmIGluc0IpXG4gICAgICAgICAgICAgICAgICAgIGFkZEluc2VydChpbnNlcnQsIHNlY3Rpb25zLCBiLnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYi5pbnMgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBhZGRTZWN0aW9uKHNlY3Rpb25zLCBhLm9mZiA/IDAgOiBhLmxlbiwgbGVuLCBvcGVuKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5zZXJ0KVxuICAgICAgICAgICAgICAgICAgICBhZGRJbnNlcnQoaW5zZXJ0LCBzZWN0aW9ucywgYS50ZXh0Qml0KGxlbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYWRkU2VjdGlvbihzZWN0aW9ucywgYS5vZmYgPyAwIDogYS5sZW4sIGIub2ZmID8gMCA6IGIuaW5zLCBvcGVuKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5zZXJ0ICYmICFiLm9mZilcbiAgICAgICAgICAgICAgICAgICAgYWRkSW5zZXJ0KGluc2VydCwgc2VjdGlvbnMsIGIudGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcGVuID0gKGEuaW5zID4gbGVuIHx8IGIuaW5zID49IDAgJiYgYi5sZW4gPiBsZW4pICYmIChvcGVuIHx8IHNlY3Rpb25zLmxlbmd0aCA+IHNlY3Rpb25MZW4pO1xuICAgICAgICAgICAgYS5mb3J3YXJkMihsZW4pO1xuICAgICAgICAgICAgYi5mb3J3YXJkKGxlbik7XG4gICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBTZWN0aW9uSXRlciB7XG4gICAgY29uc3RydWN0b3Ioc2V0KSB7XG4gICAgICAgIHRoaXMuc2V0ID0gc2V0O1xuICAgICAgICB0aGlzLmkgPSAwO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICB9XG4gICAgbmV4dCgpIHtcbiAgICAgICAgbGV0IHsgc2VjdGlvbnMgfSA9IHRoaXMuc2V0O1xuICAgICAgICBpZiAodGhpcy5pIDwgc2VjdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmxlbiA9IHNlY3Rpb25zW3RoaXMuaSsrXTtcbiAgICAgICAgICAgIHRoaXMuaW5zID0gc2VjdGlvbnNbdGhpcy5pKytdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5sZW4gPSAwO1xuICAgICAgICAgICAgdGhpcy5pbnMgPSAtMjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9mZiA9IDA7XG4gICAgfVxuICAgIGdldCBkb25lKCkgeyByZXR1cm4gdGhpcy5pbnMgPT0gLTI7IH1cbiAgICBnZXQgbGVuMigpIHsgcmV0dXJuIHRoaXMuaW5zIDwgMCA/IHRoaXMubGVuIDogdGhpcy5pbnM7IH1cbiAgICBnZXQgdGV4dCgpIHtcbiAgICAgICAgbGV0IHsgaW5zZXJ0ZWQgfSA9IHRoaXMuc2V0LCBpbmRleCA9ICh0aGlzLmkgLSAyKSA+PiAxO1xuICAgICAgICByZXR1cm4gaW5kZXggPj0gaW5zZXJ0ZWQubGVuZ3RoID8gVGV4dC5lbXB0eSA6IGluc2VydGVkW2luZGV4XTtcbiAgICB9XG4gICAgdGV4dEJpdChsZW4pIHtcbiAgICAgICAgbGV0IHsgaW5zZXJ0ZWQgfSA9IHRoaXMuc2V0LCBpbmRleCA9ICh0aGlzLmkgLSAyKSA+PiAxO1xuICAgICAgICByZXR1cm4gaW5kZXggPj0gaW5zZXJ0ZWQubGVuZ3RoICYmICFsZW4gPyBUZXh0LmVtcHR5XG4gICAgICAgICAgICA6IGluc2VydGVkW2luZGV4XS5zbGljZSh0aGlzLm9mZiwgbGVuID09IG51bGwgPyB1bmRlZmluZWQgOiB0aGlzLm9mZiArIGxlbik7XG4gICAgfVxuICAgIGZvcndhcmQobGVuKSB7XG4gICAgICAgIGlmIChsZW4gPT0gdGhpcy5sZW4pXG4gICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxlbiAtPSBsZW47XG4gICAgICAgICAgICB0aGlzLm9mZiArPSBsZW47XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yd2FyZDIobGVuKSB7XG4gICAgICAgIGlmICh0aGlzLmlucyA9PSAtMSlcbiAgICAgICAgICAgIHRoaXMuZm9yd2FyZChsZW4pO1xuICAgICAgICBlbHNlIGlmIChsZW4gPT0gdGhpcy5pbnMpXG4gICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmlucyAtPSBsZW47XG4gICAgICAgICAgICB0aGlzLm9mZiArPSBsZW47XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuQSBzaW5nbGUgc2VsZWN0aW9uIHJhbmdlLiBXaGVuXG5bYGFsbG93TXVsdGlwbGVTZWxlY3Rpb25zYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV5hbGxvd011bHRpcGxlU2VsZWN0aW9ucylcbmlzIGVuYWJsZWQsIGEgW3NlbGVjdGlvbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTZWxlY3Rpb24pIG1heSBob2xkXG5tdWx0aXBsZSByYW5nZXMuIEJ5IGRlZmF1bHQsIHNlbGVjdGlvbnMgaG9sZCBleGFjdGx5IG9uZSByYW5nZS5cbiovXG5jbGFzcyBTZWxlY3Rpb25SYW5nZSB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIGxvd2VyIGJvdW5kYXJ5IG9mIHRoZSByYW5nZS5cbiAgICAqL1xuICAgIGZyb20sIFxuICAgIC8qKlxuICAgIFRoZSB1cHBlciBib3VuZGFyeSBvZiB0aGUgcmFuZ2UuXG4gICAgKi9cbiAgICB0bywgZmxhZ3MpIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLmZsYWdzID0gZmxhZ3M7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBhbmNob3Igb2YgdGhlIHJhbmdl4oCUdGhlIHNpZGUgdGhhdCBkb2Vzbid0IG1vdmUgd2hlbiB5b3VcbiAgICBleHRlbmQgaXQuXG4gICAgKi9cbiAgICBnZXQgYW5jaG9yKCkgeyByZXR1cm4gdGhpcy5mbGFncyAmIDMyIC8qIFJhbmdlRmxhZy5JbnZlcnRlZCAqLyA/IHRoaXMudG8gOiB0aGlzLmZyb207IH1cbiAgICAvKipcbiAgICBUaGUgaGVhZCBvZiB0aGUgcmFuZ2UsIHdoaWNoIGlzIG1vdmVkIHdoZW4gdGhlIHJhbmdlIGlzXG4gICAgW2V4dGVuZGVkXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlNlbGVjdGlvblJhbmdlLmV4dGVuZCkuXG4gICAgKi9cbiAgICBnZXQgaGVhZCgpIHsgcmV0dXJuIHRoaXMuZmxhZ3MgJiAzMiAvKiBSYW5nZUZsYWcuSW52ZXJ0ZWQgKi8gPyB0aGlzLmZyb20gOiB0aGlzLnRvOyB9XG4gICAgLyoqXG4gICAgVHJ1ZSB3aGVuIGBhbmNob3JgIGFuZCBgaGVhZGAgYXJlIGF0IHRoZSBzYW1lIHBvc2l0aW9uLlxuICAgICovXG4gICAgZ2V0IGVtcHR5KCkgeyByZXR1cm4gdGhpcy5mcm9tID09IHRoaXMudG87IH1cbiAgICAvKipcbiAgICBJZiB0aGlzIGlzIGEgY3Vyc29yIHRoYXQgaXMgZXhwbGljaXRseSBhc3NvY2lhdGVkIHdpdGggdGhlXG4gICAgY2hhcmFjdGVyIG9uIG9uZSBvZiBpdHMgc2lkZXMsIHRoaXMgcmV0dXJucyB0aGUgc2lkZS4gLTEgbWVhbnNcbiAgICB0aGUgY2hhcmFjdGVyIGJlZm9yZSBpdHMgcG9zaXRpb24sIDEgdGhlIGNoYXJhY3RlciBhZnRlciwgYW5kIDBcbiAgICBtZWFucyBubyBhc3NvY2lhdGlvbi5cbiAgICAqL1xuICAgIGdldCBhc3NvYygpIHsgcmV0dXJuIHRoaXMuZmxhZ3MgJiA4IC8qIFJhbmdlRmxhZy5Bc3NvY0JlZm9yZSAqLyA/IC0xIDogdGhpcy5mbGFncyAmIDE2IC8qIFJhbmdlRmxhZy5Bc3NvY0FmdGVyICovID8gMSA6IDA7IH1cbiAgICAvKipcbiAgICBUaGUgYmlkaXJlY3Rpb25hbCB0ZXh0IGxldmVsIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGN1cnNvciwgaWZcbiAgICBhbnkuXG4gICAgKi9cbiAgICBnZXQgYmlkaUxldmVsKCkge1xuICAgICAgICBsZXQgbGV2ZWwgPSB0aGlzLmZsYWdzICYgNyAvKiBSYW5nZUZsYWcuQmlkaUxldmVsTWFzayAqLztcbiAgICAgICAgcmV0dXJuIGxldmVsID09IDcgPyBudWxsIDogbGV2ZWw7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBnb2FsIGNvbHVtbiAoc3RvcmVkIHZlcnRpY2FsIG9mZnNldCkgYXNzb2NpYXRlZCB3aXRoIGFcbiAgICBjdXJzb3IuIFRoaXMgaXMgdXNlZCB0byBwcmVzZXJ2ZSB0aGUgdmVydGljYWwgcG9zaXRpb24gd2hlblxuICAgIFttb3ZpbmddKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3Lm1vdmVWZXJ0aWNhbGx5KSBhY3Jvc3NcbiAgICBsaW5lcyBvZiBkaWZmZXJlbnQgbGVuZ3RoLlxuICAgICovXG4gICAgZ2V0IGdvYWxDb2x1bW4oKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IHRoaXMuZmxhZ3MgPj4gNiAvKiBSYW5nZUZsYWcuR29hbENvbHVtbk9mZnNldCAqLztcbiAgICAgICAgcmV0dXJuIHZhbHVlID09IDE2Nzc3MjE1IC8qIFJhbmdlRmxhZy5Ob0dvYWxDb2x1bW4gKi8gPyB1bmRlZmluZWQgOiB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgTWFwIHRoaXMgcmFuZ2UgdGhyb3VnaCBhIGNoYW5nZSwgcHJvZHVjaW5nIGEgdmFsaWQgcmFuZ2UgaW4gdGhlXG4gICAgdXBkYXRlZCBkb2N1bWVudC5cbiAgICAqL1xuICAgIG1hcChjaGFuZ2UsIGFzc29jID0gLTEpIHtcbiAgICAgICAgbGV0IGZyb20sIHRvO1xuICAgICAgICBpZiAodGhpcy5lbXB0eSkge1xuICAgICAgICAgICAgZnJvbSA9IHRvID0gY2hhbmdlLm1hcFBvcyh0aGlzLmZyb20sIGFzc29jKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZyb20gPSBjaGFuZ2UubWFwUG9zKHRoaXMuZnJvbSwgMSk7XG4gICAgICAgICAgICB0byA9IGNoYW5nZS5tYXBQb3ModGhpcy50bywgLTEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmcm9tID09IHRoaXMuZnJvbSAmJiB0byA9PSB0aGlzLnRvID8gdGhpcyA6IG5ldyBTZWxlY3Rpb25SYW5nZShmcm9tLCB0bywgdGhpcy5mbGFncyk7XG4gICAgfVxuICAgIC8qKlxuICAgIEV4dGVuZCB0aGlzIHJhbmdlIHRvIGNvdmVyIGF0IGxlYXN0IGBmcm9tYCB0byBgdG9gLlxuICAgICovXG4gICAgZXh0ZW5kKGZyb20sIHRvID0gZnJvbSkge1xuICAgICAgICBpZiAoZnJvbSA8PSB0aGlzLmFuY2hvciAmJiB0byA+PSB0aGlzLmFuY2hvcilcbiAgICAgICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UoZnJvbSwgdG8pO1xuICAgICAgICBsZXQgaGVhZCA9IE1hdGguYWJzKGZyb20gLSB0aGlzLmFuY2hvcikgPiBNYXRoLmFicyh0byAtIHRoaXMuYW5jaG9yKSA/IGZyb20gOiB0bztcbiAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5yYW5nZSh0aGlzLmFuY2hvciwgaGVhZCk7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbXBhcmUgdGhpcyByYW5nZSB0byBhbm90aGVyIHJhbmdlLlxuICAgICovXG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYW5jaG9yID09IG90aGVyLmFuY2hvciAmJiB0aGlzLmhlYWQgPT0gb3RoZXIuaGVhZDtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJuIGEgSlNPTi1zZXJpYWxpemFibGUgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgcmFuZ2UuXG4gICAgKi9cbiAgICB0b0pTT04oKSB7IHJldHVybiB7IGFuY2hvcjogdGhpcy5hbmNob3IsIGhlYWQ6IHRoaXMuaGVhZCB9OyB9XG4gICAgLyoqXG4gICAgQ29udmVydCBhIEpTT04gcmVwcmVzZW50YXRpb24gb2YgYSByYW5nZSB0byBhIGBTZWxlY3Rpb25SYW5nZWBcbiAgICBpbnN0YW5jZS5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihqc29uKSB7XG4gICAgICAgIGlmICghanNvbiB8fCB0eXBlb2YganNvbi5hbmNob3IgIT0gXCJudW1iZXJcIiB8fCB0eXBlb2YganNvbi5oZWFkICE9IFwibnVtYmVyXCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgSlNPTiByZXByZXNlbnRhdGlvbiBmb3IgU2VsZWN0aW9uUmFuZ2VcIik7XG4gICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UoanNvbi5hbmNob3IsIGpzb24uaGVhZCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShmcm9tLCB0bywgZmxhZ3MpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTZWxlY3Rpb25SYW5nZShmcm9tLCB0bywgZmxhZ3MpO1xuICAgIH1cbn1cbi8qKlxuQW4gZWRpdG9yIHNlbGVjdGlvbiBob2xkcyBvbmUgb3IgbW9yZSBzZWxlY3Rpb24gcmFuZ2VzLlxuKi9cbmNsYXNzIEVkaXRvclNlbGVjdGlvbiB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHJhbmdlcyBpbiB0aGUgc2VsZWN0aW9uLCBzb3J0ZWQgYnkgcG9zaXRpb24uIFJhbmdlcyBjYW5ub3RcbiAgICBvdmVybGFwIChidXQgdGhleSBtYXkgdG91Y2gsIGlmIHRoZXkgYXJlbid0IGVtcHR5KS5cbiAgICAqL1xuICAgIHJhbmdlcywgXG4gICAgLyoqXG4gICAgVGhlIGluZGV4IG9mIHRoZSBfbWFpbl8gcmFuZ2UgaW4gdGhlIHNlbGVjdGlvbiAod2hpY2ggaXNcbiAgICB1c3VhbGx5IHRoZSByYW5nZSB0aGF0IHdhcyBhZGRlZCBsYXN0KS5cbiAgICAqL1xuICAgIG1haW5JbmRleCkge1xuICAgICAgICB0aGlzLnJhbmdlcyA9IHJhbmdlcztcbiAgICAgICAgdGhpcy5tYWluSW5kZXggPSBtYWluSW5kZXg7XG4gICAgfVxuICAgIC8qKlxuICAgIE1hcCBhIHNlbGVjdGlvbiB0aHJvdWdoIGEgY2hhbmdlLiBVc2VkIHRvIGFkanVzdCB0aGUgc2VsZWN0aW9uXG4gICAgcG9zaXRpb24gZm9yIGNoYW5nZXMuXG4gICAgKi9cbiAgICBtYXAoY2hhbmdlLCBhc3NvYyA9IC0xKSB7XG4gICAgICAgIGlmIChjaGFuZ2UuZW1wdHkpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jcmVhdGUodGhpcy5yYW5nZXMubWFwKHIgPT4gci5tYXAoY2hhbmdlLCBhc3NvYykpLCB0aGlzLm1haW5JbmRleCk7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbXBhcmUgdGhpcyBzZWxlY3Rpb24gdG8gYW5vdGhlciBzZWxlY3Rpb24uXG4gICAgKi9cbiAgICBlcShvdGhlcikge1xuICAgICAgICBpZiAodGhpcy5yYW5nZXMubGVuZ3RoICE9IG90aGVyLnJhbmdlcy5sZW5ndGggfHxcbiAgICAgICAgICAgIHRoaXMubWFpbkluZGV4ICE9IG90aGVyLm1haW5JbmRleClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJhbmdlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmICghdGhpcy5yYW5nZXNbaV0uZXEob3RoZXIucmFuZ2VzW2ldKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIHByaW1hcnkgc2VsZWN0aW9uIHJhbmdlLiBVc3VhbGx5LCB5b3Ugc2hvdWxkIG1ha2Ugc3VyZVxuICAgIHlvdXIgY29kZSBhcHBsaWVzIHRvIF9hbGxfIHJhbmdlcywgYnkgdXNpbmcgbWV0aG9kcyBsaWtlXG4gICAgW2BjaGFuZ2VCeVJhbmdlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5jaGFuZ2VCeVJhbmdlKS5cbiAgICAqL1xuICAgIGdldCBtYWluKCkgeyByZXR1cm4gdGhpcy5yYW5nZXNbdGhpcy5tYWluSW5kZXhdOyB9XG4gICAgLyoqXG4gICAgTWFrZSBzdXJlIHRoZSBzZWxlY3Rpb24gb25seSBoYXMgb25lIHJhbmdlLiBSZXR1cm5zIGEgc2VsZWN0aW9uXG4gICAgaG9sZGluZyBvbmx5IHRoZSBtYWluIHJhbmdlIGZyb20gdGhpcyBzZWxlY3Rpb24uXG4gICAgKi9cbiAgICBhc1NpbmdsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmFuZ2VzLmxlbmd0aCA9PSAxID8gdGhpcyA6IG5ldyBFZGl0b3JTZWxlY3Rpb24oW3RoaXMubWFpbl0sIDApO1xuICAgIH1cbiAgICAvKipcbiAgICBFeHRlbmQgdGhpcyBzZWxlY3Rpb24gd2l0aCBhbiBleHRyYSByYW5nZS5cbiAgICAqL1xuICAgIGFkZFJhbmdlKHJhbmdlLCBtYWluID0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShbcmFuZ2VdLmNvbmNhdCh0aGlzLnJhbmdlcyksIG1haW4gPyAwIDogdGhpcy5tYWluSW5kZXggKyAxKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmVwbGFjZSBhIGdpdmVuIHJhbmdlIHdpdGggYW5vdGhlciByYW5nZSwgYW5kIHRoZW4gbm9ybWFsaXplIHRoZVxuICAgIHNlbGVjdGlvbiB0byBtZXJnZSBhbmQgc29ydCByYW5nZXMgaWYgbmVjZXNzYXJ5LlxuICAgICovXG4gICAgcmVwbGFjZVJhbmdlKHJhbmdlLCB3aGljaCA9IHRoaXMubWFpbkluZGV4KSB7XG4gICAgICAgIGxldCByYW5nZXMgPSB0aGlzLnJhbmdlcy5zbGljZSgpO1xuICAgICAgICByYW5nZXNbd2hpY2hdID0gcmFuZ2U7XG4gICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKHJhbmdlcywgdGhpcy5tYWluSW5kZXgpO1xuICAgIH1cbiAgICAvKipcbiAgICBDb252ZXJ0IHRoaXMgc2VsZWN0aW9uIHRvIGFuIG9iamVjdCB0aGF0IGNhbiBiZSBzZXJpYWxpemVkIHRvXG4gICAgSlNPTi5cbiAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHsgcmFuZ2VzOiB0aGlzLnJhbmdlcy5tYXAociA9PiByLnRvSlNPTigpKSwgbWFpbjogdGhpcy5tYWluSW5kZXggfTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgc2VsZWN0aW9uIGZyb20gYSBKU09OIHJlcHJlc2VudGF0aW9uLlxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKGpzb24pIHtcbiAgICAgICAgaWYgKCFqc29uIHx8ICFBcnJheS5pc0FycmF5KGpzb24ucmFuZ2VzKSB8fCB0eXBlb2YganNvbi5tYWluICE9IFwibnVtYmVyXCIgfHwganNvbi5tYWluID49IGpzb24ucmFuZ2VzLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBKU09OIHJlcHJlc2VudGF0aW9uIGZvciBFZGl0b3JTZWxlY3Rpb25cIik7XG4gICAgICAgIHJldHVybiBuZXcgRWRpdG9yU2VsZWN0aW9uKGpzb24ucmFuZ2VzLm1hcCgocikgPT4gU2VsZWN0aW9uUmFuZ2UuZnJvbUpTT04ocikpLCBqc29uLm1haW4pO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBzZWxlY3Rpb24gaG9sZGluZyBhIHNpbmdsZSByYW5nZS5cbiAgICAqL1xuICAgIHN0YXRpYyBzaW5nbGUoYW5jaG9yLCBoZWFkID0gYW5jaG9yKSB7XG4gICAgICAgIHJldHVybiBuZXcgRWRpdG9yU2VsZWN0aW9uKFtFZGl0b3JTZWxlY3Rpb24ucmFuZ2UoYW5jaG9yLCBoZWFkKV0sIDApO1xuICAgIH1cbiAgICAvKipcbiAgICBTb3J0IGFuZCBtZXJnZSB0aGUgZ2l2ZW4gc2V0IG9mIHJhbmdlcywgY3JlYXRpbmcgYSB2YWxpZFxuICAgIHNlbGVjdGlvbi5cbiAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUocmFuZ2VzLCBtYWluSW5kZXggPSAwKSB7XG4gICAgICAgIGlmIChyYW5nZXMubGVuZ3RoID09IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkEgc2VsZWN0aW9uIG5lZWRzIGF0IGxlYXN0IG9uZSByYW5nZVwiKTtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMCwgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCByYW5nZSA9IHJhbmdlc1tpXTtcbiAgICAgICAgICAgIGlmIChyYW5nZS5lbXB0eSA/IHJhbmdlLmZyb20gPD0gcG9zIDogcmFuZ2UuZnJvbSA8IHBvcylcbiAgICAgICAgICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLm5vcm1hbGl6ZWQocmFuZ2VzLnNsaWNlKCksIG1haW5JbmRleCk7XG4gICAgICAgICAgICBwb3MgPSByYW5nZS50bztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEVkaXRvclNlbGVjdGlvbihyYW5nZXMsIG1haW5JbmRleCk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIGN1cnNvciBzZWxlY3Rpb24gcmFuZ2UgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLiBZb3UgY2FuXG4gICAgc2FmZWx5IGlnbm9yZSB0aGUgb3B0aW9uYWwgYXJndW1lbnRzIGluIG1vc3Qgc2l0dWF0aW9ucy5cbiAgICAqL1xuICAgIHN0YXRpYyBjdXJzb3IocG9zLCBhc3NvYyA9IDAsIGJpZGlMZXZlbCwgZ29hbENvbHVtbikge1xuICAgICAgICByZXR1cm4gU2VsZWN0aW9uUmFuZ2UuY3JlYXRlKHBvcywgcG9zLCAoYXNzb2MgPT0gMCA/IDAgOiBhc3NvYyA8IDAgPyA4IC8qIFJhbmdlRmxhZy5Bc3NvY0JlZm9yZSAqLyA6IDE2IC8qIFJhbmdlRmxhZy5Bc3NvY0FmdGVyICovKSB8XG4gICAgICAgICAgICAoYmlkaUxldmVsID09IG51bGwgPyA3IDogTWF0aC5taW4oNiwgYmlkaUxldmVsKSkgfFxuICAgICAgICAgICAgKChnb2FsQ29sdW1uICE9PSBudWxsICYmIGdvYWxDb2x1bW4gIT09IHZvaWQgMCA/IGdvYWxDb2x1bW4gOiAxNjc3NzIxNSAvKiBSYW5nZUZsYWcuTm9Hb2FsQ29sdW1uICovKSA8PCA2IC8qIFJhbmdlRmxhZy5Hb2FsQ29sdW1uT2Zmc2V0ICovKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHNlbGVjdGlvbiByYW5nZS5cbiAgICAqL1xuICAgIHN0YXRpYyByYW5nZShhbmNob3IsIGhlYWQsIGdvYWxDb2x1bW4sIGJpZGlMZXZlbCkge1xuICAgICAgICBsZXQgZmxhZ3MgPSAoKGdvYWxDb2x1bW4gIT09IG51bGwgJiYgZ29hbENvbHVtbiAhPT0gdm9pZCAwID8gZ29hbENvbHVtbiA6IDE2Nzc3MjE1IC8qIFJhbmdlRmxhZy5Ob0dvYWxDb2x1bW4gKi8pIDw8IDYgLyogUmFuZ2VGbGFnLkdvYWxDb2x1bW5PZmZzZXQgKi8pIHxcbiAgICAgICAgICAgIChiaWRpTGV2ZWwgPT0gbnVsbCA/IDcgOiBNYXRoLm1pbig2LCBiaWRpTGV2ZWwpKTtcbiAgICAgICAgcmV0dXJuIGhlYWQgPCBhbmNob3IgPyBTZWxlY3Rpb25SYW5nZS5jcmVhdGUoaGVhZCwgYW5jaG9yLCAzMiAvKiBSYW5nZUZsYWcuSW52ZXJ0ZWQgKi8gfCAxNiAvKiBSYW5nZUZsYWcuQXNzb2NBZnRlciAqLyB8IGZsYWdzKVxuICAgICAgICAgICAgOiBTZWxlY3Rpb25SYW5nZS5jcmVhdGUoYW5jaG9yLCBoZWFkLCAoaGVhZCA+IGFuY2hvciA/IDggLyogUmFuZ2VGbGFnLkFzc29jQmVmb3JlICovIDogMCkgfCBmbGFncyk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIG5vcm1hbGl6ZWQocmFuZ2VzLCBtYWluSW5kZXggPSAwKSB7XG4gICAgICAgIGxldCBtYWluID0gcmFuZ2VzW21haW5JbmRleF07XG4gICAgICAgIHJhbmdlcy5zb3J0KChhLCBiKSA9PiBhLmZyb20gLSBiLmZyb20pO1xuICAgICAgICBtYWluSW5kZXggPSByYW5nZXMuaW5kZXhPZihtYWluKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCByYW5nZSA9IHJhbmdlc1tpXSwgcHJldiA9IHJhbmdlc1tpIC0gMV07XG4gICAgICAgICAgICBpZiAocmFuZ2UuZW1wdHkgPyByYW5nZS5mcm9tIDw9IHByZXYudG8gOiByYW5nZS5mcm9tIDwgcHJldi50bykge1xuICAgICAgICAgICAgICAgIGxldCBmcm9tID0gcHJldi5mcm9tLCB0byA9IE1hdGgubWF4KHJhbmdlLnRvLCBwcmV2LnRvKTtcbiAgICAgICAgICAgICAgICBpZiAoaSA8PSBtYWluSW5kZXgpXG4gICAgICAgICAgICAgICAgICAgIG1haW5JbmRleC0tO1xuICAgICAgICAgICAgICAgIHJhbmdlcy5zcGxpY2UoLS1pLCAyLCByYW5nZS5hbmNob3IgPiByYW5nZS5oZWFkID8gRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHRvLCBmcm9tKSA6IEVkaXRvclNlbGVjdGlvbi5yYW5nZShmcm9tLCB0bykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRWRpdG9yU2VsZWN0aW9uKHJhbmdlcywgbWFpbkluZGV4KTtcbiAgICB9XG59XG5mdW5jdGlvbiBjaGVja1NlbGVjdGlvbihzZWxlY3Rpb24sIGRvY0xlbmd0aCkge1xuICAgIGZvciAobGV0IHJhbmdlIG9mIHNlbGVjdGlvbi5yYW5nZXMpXG4gICAgICAgIGlmIChyYW5nZS50byA+IGRvY0xlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiU2VsZWN0aW9uIHBvaW50cyBvdXRzaWRlIG9mIGRvY3VtZW50XCIpO1xufVxuXG5sZXQgbmV4dElEID0gMDtcbi8qKlxuQSBmYWNldCBpcyBhIGxhYmVsZWQgdmFsdWUgdGhhdCBpcyBhc3NvY2lhdGVkIHdpdGggYW4gZWRpdG9yXG5zdGF0ZS4gSXQgdGFrZXMgaW5wdXRzIGZyb20gYW55IG51bWJlciBvZiBleHRlbnNpb25zLCBhbmQgY29tYmluZXNcbnRob3NlIGludG8gYSBzaW5nbGUgb3V0cHV0IHZhbHVlLlxuXG5FeGFtcGxlcyBvZiB1c2VzIG9mIGZhY2V0cyBhcmUgdGhlIFt0YWJcbnNpemVdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVedGFiU2l6ZSksIFtlZGl0b3JcbmF0dHJpYnV0ZXNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3XmVkaXRvckF0dHJpYnV0ZXMpLCBhbmQgW3VwZGF0ZVxubGlzdGVuZXJzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlld151cGRhdGVMaXN0ZW5lcikuXG5cbk5vdGUgdGhhdCBgRmFjZXRgIGluc3RhbmNlcyBjYW4gYmUgdXNlZCBhbnl3aGVyZSB3aGVyZVxuW2BGYWNldFJlYWRlcmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRmFjZXRSZWFkZXIpIGlzIGV4cGVjdGVkLlxuKi9cbmNsYXNzIEZhY2V0IHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbWJpbmUsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29tcGFyZUlucHV0LCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbXBhcmUsIGlzU3RhdGljLCBlbmFibGVzKSB7XG4gICAgICAgIHRoaXMuY29tYmluZSA9IGNvbWJpbmU7XG4gICAgICAgIHRoaXMuY29tcGFyZUlucHV0ID0gY29tcGFyZUlucHV0O1xuICAgICAgICB0aGlzLmNvbXBhcmUgPSBjb21wYXJlO1xuICAgICAgICB0aGlzLmlzU3RhdGljID0gaXNTdGF0aWM7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pZCA9IG5leHRJRCsrO1xuICAgICAgICB0aGlzLmRlZmF1bHQgPSBjb21iaW5lKFtdKTtcbiAgICAgICAgdGhpcy5leHRlbnNpb25zID0gdHlwZW9mIGVuYWJsZXMgPT0gXCJmdW5jdGlvblwiID8gZW5hYmxlcyh0aGlzKSA6IGVuYWJsZXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybnMgYSBmYWNldCByZWFkZXIgZm9yIHRoaXMgZmFjZXQsIHdoaWNoIGNhbiBiZSB1c2VkIHRvXG4gICAgW3JlYWRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUuZmFjZXQpIGl0IGJ1dCBub3QgdG8gZGVmaW5lIHZhbHVlcyBmb3IgaXQuXG4gICAgKi9cbiAgICBnZXQgcmVhZGVyKCkgeyByZXR1cm4gdGhpczsgfVxuICAgIC8qKlxuICAgIERlZmluZSBhIG5ldyBmYWNldC5cbiAgICAqL1xuICAgIHN0YXRpYyBkZWZpbmUoY29uZmlnID0ge30pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGYWNldChjb25maWcuY29tYmluZSB8fCAoKGEpID0+IGEpLCBjb25maWcuY29tcGFyZUlucHV0IHx8ICgoYSwgYikgPT4gYSA9PT0gYiksIGNvbmZpZy5jb21wYXJlIHx8ICghY29uZmlnLmNvbWJpbmUgPyBzYW1lQXJyYXkgOiAoYSwgYikgPT4gYSA9PT0gYiksICEhY29uZmlnLnN0YXRpYywgY29uZmlnLmVuYWJsZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIGFuIGV4dGVuc2lvbiB0aGF0IGFkZHMgdGhlIGdpdmVuIHZhbHVlIHRvIHRoaXMgZmFjZXQuXG4gICAgKi9cbiAgICBvZih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbmV3IEZhY2V0UHJvdmlkZXIoW10sIHRoaXMsIDAgLyogUHJvdmlkZXIuU3RhdGljICovLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhbiBleHRlbnNpb24gdGhhdCBjb21wdXRlcyBhIHZhbHVlIGZvciB0aGUgZmFjZXQgZnJvbSBhXG4gICAgc3RhdGUuIFlvdSBtdXN0IHRha2UgY2FyZSB0byBkZWNsYXJlIHRoZSBwYXJ0cyBvZiB0aGUgc3RhdGUgdGhhdFxuICAgIHRoaXMgdmFsdWUgZGVwZW5kcyBvbiwgc2luY2UgeW91ciBmdW5jdGlvbiBpcyBvbmx5IGNhbGxlZCBhZ2FpblxuICAgIGZvciBhIG5ldyBzdGF0ZSB3aGVuIG9uZSBvZiB0aG9zZSBwYXJ0cyBjaGFuZ2VkLlxuICAgIFxuICAgIEluIGNhc2VzIHdoZXJlIHlvdXIgdmFsdWUgZGVwZW5kcyBvbmx5IG9uIGEgc2luZ2xlIGZpZWxkLCB5b3UnbGxcbiAgICB3YW50IHRvIHVzZSB0aGUgW2Bmcm9tYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5GYWNldC5mcm9tKSBtZXRob2QgaW5zdGVhZC5cbiAgICAqL1xuICAgIGNvbXB1dGUoZGVwcywgZ2V0KSB7XG4gICAgICAgIGlmICh0aGlzLmlzU3RhdGljKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgY29tcHV0ZSBhIHN0YXRpYyBmYWNldFwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBGYWNldFByb3ZpZGVyKGRlcHMsIHRoaXMsIDEgLyogUHJvdmlkZXIuU2luZ2xlICovLCBnZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYW4gZXh0ZW5zaW9uIHRoYXQgY29tcHV0ZXMgemVybyBvciBtb3JlIHZhbHVlcyBmb3IgdGhpc1xuICAgIGZhY2V0IGZyb20gYSBzdGF0ZS5cbiAgICAqL1xuICAgIGNvbXB1dGVOKGRlcHMsIGdldCkge1xuICAgICAgICBpZiAodGhpcy5pc1N0YXRpYylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGNvbXB1dGUgYSBzdGF0aWMgZmFjZXRcIik7XG4gICAgICAgIHJldHVybiBuZXcgRmFjZXRQcm92aWRlcihkZXBzLCB0aGlzLCAyIC8qIFByb3ZpZGVyLk11bHRpICovLCBnZXQpO1xuICAgIH1cbiAgICBmcm9tKGZpZWxkLCBnZXQpIHtcbiAgICAgICAgaWYgKCFnZXQpXG4gICAgICAgICAgICBnZXQgPSB4ID0+IHg7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXB1dGUoW2ZpZWxkXSwgc3RhdGUgPT4gZ2V0KHN0YXRlLmZpZWxkKGZpZWxkKSkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNhbWVBcnJheShhLCBiKSB7XG4gICAgcmV0dXJuIGEgPT0gYiB8fCBhLmxlbmd0aCA9PSBiLmxlbmd0aCAmJiBhLmV2ZXJ5KChlLCBpKSA9PiBlID09PSBiW2ldKTtcbn1cbmNsYXNzIEZhY2V0UHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKGRlcGVuZGVuY2llcywgZmFjZXQsIHR5cGUsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZGVwZW5kZW5jaWVzID0gZGVwZW5kZW5jaWVzO1xuICAgICAgICB0aGlzLmZhY2V0ID0gZmFjZXQ7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5pZCA9IG5leHRJRCsrO1xuICAgIH1cbiAgICBkeW5hbWljU2xvdChhZGRyZXNzZXMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgZ2V0dGVyID0gdGhpcy52YWx1ZTtcbiAgICAgICAgbGV0IGNvbXBhcmUgPSB0aGlzLmZhY2V0LmNvbXBhcmVJbnB1dDtcbiAgICAgICAgbGV0IGlkID0gdGhpcy5pZCwgaWR4ID0gYWRkcmVzc2VzW2lkXSA+PiAxLCBtdWx0aSA9IHRoaXMudHlwZSA9PSAyIC8qIFByb3ZpZGVyLk11bHRpICovO1xuICAgICAgICBsZXQgZGVwRG9jID0gZmFsc2UsIGRlcFNlbCA9IGZhbHNlLCBkZXBBZGRycyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBkZXAgb2YgdGhpcy5kZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgICAgIGlmIChkZXAgPT0gXCJkb2NcIilcbiAgICAgICAgICAgICAgICBkZXBEb2MgPSB0cnVlO1xuICAgICAgICAgICAgZWxzZSBpZiAoZGVwID09IFwic2VsZWN0aW9uXCIpXG4gICAgICAgICAgICAgICAgZGVwU2VsID0gdHJ1ZTtcbiAgICAgICAgICAgIGVsc2UgaWYgKCgoKF9hID0gYWRkcmVzc2VzW2RlcC5pZF0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDEpICYgMSkgPT0gMClcbiAgICAgICAgICAgICAgICBkZXBBZGRycy5wdXNoKGFkZHJlc3Nlc1tkZXAuaWRdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY3JlYXRlKHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUudmFsdWVzW2lkeF0gPSBnZXR0ZXIoc3RhdGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiAxIC8qIFNsb3RTdGF0dXMuQ2hhbmdlZCAqLztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1cGRhdGUoc3RhdGUsIHRyKSB7XG4gICAgICAgICAgICAgICAgaWYgKChkZXBEb2MgJiYgdHIuZG9jQ2hhbmdlZCkgfHwgKGRlcFNlbCAmJiAodHIuZG9jQ2hhbmdlZCB8fCB0ci5zZWxlY3Rpb24pKSB8fCBlbnN1cmVBbGwoc3RhdGUsIGRlcEFkZHJzKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmV3VmFsID0gZ2V0dGVyKHN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG11bHRpID8gIWNvbXBhcmVBcnJheShuZXdWYWwsIHN0YXRlLnZhbHVlc1tpZHhdLCBjb21wYXJlKSA6ICFjb21wYXJlKG5ld1ZhbCwgc3RhdGUudmFsdWVzW2lkeF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS52YWx1ZXNbaWR4XSA9IG5ld1ZhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAxIC8qIFNsb3RTdGF0dXMuQ2hhbmdlZCAqLztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZWNvbmZpZ3VyZTogKHN0YXRlLCBvbGRTdGF0ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBuZXdWYWwsIG9sZEFkZHIgPSBvbGRTdGF0ZS5jb25maWcuYWRkcmVzc1tpZF07XG4gICAgICAgICAgICAgICAgaWYgKG9sZEFkZHIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgb2xkVmFsID0gZ2V0QWRkcihvbGRTdGF0ZSwgb2xkQWRkcik7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmRlcGVuZGVuY2llcy5ldmVyeShkZXAgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlcCBpbnN0YW5jZW9mIEZhY2V0ID8gb2xkU3RhdGUuZmFjZXQoZGVwKSA9PT0gc3RhdGUuZmFjZXQoZGVwKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVwIGluc3RhbmNlb2YgU3RhdGVGaWVsZCA/IG9sZFN0YXRlLmZpZWxkKGRlcCwgZmFsc2UpID09IHN0YXRlLmZpZWxkKGRlcCwgZmFsc2UpIDogdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSkgfHwgKG11bHRpID8gY29tcGFyZUFycmF5KG5ld1ZhbCA9IGdldHRlcihzdGF0ZSksIG9sZFZhbCwgY29tcGFyZSkgOiBjb21wYXJlKG5ld1ZhbCA9IGdldHRlcihzdGF0ZSksIG9sZFZhbCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS52YWx1ZXNbaWR4XSA9IG9sZFZhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuZXdWYWwgPSBnZXR0ZXIoc3RhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGF0ZS52YWx1ZXNbaWR4XSA9IG5ld1ZhbDtcbiAgICAgICAgICAgICAgICByZXR1cm4gMSAvKiBTbG90U3RhdHVzLkNoYW5nZWQgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxufVxuZnVuY3Rpb24gY29tcGFyZUFycmF5KGEsIGIsIGNvbXBhcmUpIHtcbiAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmICghY29tcGFyZShhW2ldLCBiW2ldKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGVuc3VyZUFsbChzdGF0ZSwgYWRkcnMpIHtcbiAgICBsZXQgY2hhbmdlZCA9IGZhbHNlO1xuICAgIGZvciAobGV0IGFkZHIgb2YgYWRkcnMpXG4gICAgICAgIGlmIChlbnN1cmVBZGRyKHN0YXRlLCBhZGRyKSAmIDEgLyogU2xvdFN0YXR1cy5DaGFuZ2VkICovKVxuICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgcmV0dXJuIGNoYW5nZWQ7XG59XG5mdW5jdGlvbiBkeW5hbWljRmFjZXRTbG90KGFkZHJlc3NlcywgZmFjZXQsIHByb3ZpZGVycykge1xuICAgIGxldCBwcm92aWRlckFkZHJzID0gcHJvdmlkZXJzLm1hcChwID0+IGFkZHJlc3Nlc1twLmlkXSk7XG4gICAgbGV0IHByb3ZpZGVyVHlwZXMgPSBwcm92aWRlcnMubWFwKHAgPT4gcC50eXBlKTtcbiAgICBsZXQgZHluYW1pYyA9IHByb3ZpZGVyQWRkcnMuZmlsdGVyKHAgPT4gIShwICYgMSkpO1xuICAgIGxldCBpZHggPSBhZGRyZXNzZXNbZmFjZXQuaWRdID4+IDE7XG4gICAgZnVuY3Rpb24gZ2V0KHN0YXRlKSB7XG4gICAgICAgIGxldCB2YWx1ZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm92aWRlckFkZHJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBnZXRBZGRyKHN0YXRlLCBwcm92aWRlckFkZHJzW2ldKTtcbiAgICAgICAgICAgIGlmIChwcm92aWRlclR5cGVzW2ldID09IDIgLyogUHJvdmlkZXIuTXVsdGkgKi8pXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgdmFsIG9mIHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaCh2YWwpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFjZXQuY29tYmluZSh2YWx1ZXMpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBjcmVhdGUoc3RhdGUpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGFkZHIgb2YgcHJvdmlkZXJBZGRycylcbiAgICAgICAgICAgICAgICBlbnN1cmVBZGRyKHN0YXRlLCBhZGRyKTtcbiAgICAgICAgICAgIHN0YXRlLnZhbHVlc1tpZHhdID0gZ2V0KHN0YXRlKTtcbiAgICAgICAgICAgIHJldHVybiAxIC8qIFNsb3RTdGF0dXMuQ2hhbmdlZCAqLztcbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlKHN0YXRlLCB0cikge1xuICAgICAgICAgICAgaWYgKCFlbnN1cmVBbGwoc3RhdGUsIGR5bmFtaWMpKVxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gZ2V0KHN0YXRlKTtcbiAgICAgICAgICAgIGlmIChmYWNldC5jb21wYXJlKHZhbHVlLCBzdGF0ZS52YWx1ZXNbaWR4XSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICBzdGF0ZS52YWx1ZXNbaWR4XSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIDEgLyogU2xvdFN0YXR1cy5DaGFuZ2VkICovO1xuICAgICAgICB9LFxuICAgICAgICByZWNvbmZpZ3VyZShzdGF0ZSwgb2xkU3RhdGUpIHtcbiAgICAgICAgICAgIGxldCBkZXBDaGFuZ2VkID0gZW5zdXJlQWxsKHN0YXRlLCBwcm92aWRlckFkZHJzKTtcbiAgICAgICAgICAgIGxldCBvbGRQcm92aWRlcnMgPSBvbGRTdGF0ZS5jb25maWcuZmFjZXRzW2ZhY2V0LmlkXSwgb2xkVmFsdWUgPSBvbGRTdGF0ZS5mYWNldChmYWNldCk7XG4gICAgICAgICAgICBpZiAob2xkUHJvdmlkZXJzICYmICFkZXBDaGFuZ2VkICYmIHNhbWVBcnJheShwcm92aWRlcnMsIG9sZFByb3ZpZGVycykpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS52YWx1ZXNbaWR4XSA9IG9sZFZhbHVlO1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHZhbHVlID0gZ2V0KHN0YXRlKTtcbiAgICAgICAgICAgIGlmIChmYWNldC5jb21wYXJlKHZhbHVlLCBvbGRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS52YWx1ZXNbaWR4XSA9IG9sZFZhbHVlO1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhdGUudmFsdWVzW2lkeF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiAxIC8qIFNsb3RTdGF0dXMuQ2hhbmdlZCAqLztcbiAgICAgICAgfVxuICAgIH07XG59XG5jb25zdCBpbml0RmllbGQgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHsgc3RhdGljOiB0cnVlIH0pO1xuLyoqXG5GaWVsZHMgY2FuIHN0b3JlIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gaW4gYW4gZWRpdG9yIHN0YXRlLCBhbmRcbmtlZXAgaXQgaW4gc3luYyB3aXRoIHRoZSByZXN0IG9mIHRoZSBzdGF0ZS5cbiovXG5jbGFzcyBTdGF0ZUZpZWxkIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGlkLCBjcmVhdGVGLCB1cGRhdGVGLCBjb21wYXJlRiwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzcGVjKSB7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5jcmVhdGVGID0gY3JlYXRlRjtcbiAgICAgICAgdGhpcy51cGRhdGVGID0gdXBkYXRlRjtcbiAgICAgICAgdGhpcy5jb21wYXJlRiA9IGNvbXBhcmVGO1xuICAgICAgICB0aGlzLnNwZWMgPSBzcGVjO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMucHJvdmlkZXMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgIERlZmluZSBhIHN0YXRlIGZpZWxkLlxuICAgICovXG4gICAgc3RhdGljIGRlZmluZShjb25maWcpIHtcbiAgICAgICAgbGV0IGZpZWxkID0gbmV3IFN0YXRlRmllbGQobmV4dElEKyssIGNvbmZpZy5jcmVhdGUsIGNvbmZpZy51cGRhdGUsIGNvbmZpZy5jb21wYXJlIHx8ICgoYSwgYikgPT4gYSA9PT0gYiksIGNvbmZpZyk7XG4gICAgICAgIGlmIChjb25maWcucHJvdmlkZSlcbiAgICAgICAgICAgIGZpZWxkLnByb3ZpZGVzID0gY29uZmlnLnByb3ZpZGUoZmllbGQpO1xuICAgICAgICByZXR1cm4gZmllbGQ7XG4gICAgfVxuICAgIGNyZWF0ZShzdGF0ZSkge1xuICAgICAgICBsZXQgaW5pdCA9IHN0YXRlLmZhY2V0KGluaXRGaWVsZCkuZmluZChpID0+IGkuZmllbGQgPT0gdGhpcyk7XG4gICAgICAgIHJldHVybiAoKGluaXQgPT09IG51bGwgfHwgaW5pdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW5pdC5jcmVhdGUpIHx8IHRoaXMuY3JlYXRlRikoc3RhdGUpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHNsb3QoYWRkcmVzc2VzKSB7XG4gICAgICAgIGxldCBpZHggPSBhZGRyZXNzZXNbdGhpcy5pZF0gPj4gMTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNyZWF0ZTogKHN0YXRlKSA9PiB7XG4gICAgICAgICAgICAgICAgc3RhdGUudmFsdWVzW2lkeF0gPSB0aGlzLmNyZWF0ZShzdGF0ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDEgLyogU2xvdFN0YXR1cy5DaGFuZ2VkICovO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVwZGF0ZTogKHN0YXRlLCB0cikgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBvbGRWYWwgPSBzdGF0ZS52YWx1ZXNbaWR4XTtcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSB0aGlzLnVwZGF0ZUYob2xkVmFsLCB0cik7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29tcGFyZUYob2xkVmFsLCB2YWx1ZSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgIHN0YXRlLnZhbHVlc1tpZHhdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDEgLyogU2xvdFN0YXR1cy5DaGFuZ2VkICovO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlY29uZmlndXJlOiAoc3RhdGUsIG9sZFN0YXRlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG9sZFN0YXRlLmNvbmZpZy5hZGRyZXNzW3RoaXMuaWRdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUudmFsdWVzW2lkeF0gPSBvbGRTdGF0ZS5maWVsZCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0YXRlLnZhbHVlc1tpZHhdID0gdGhpcy5jcmVhdGUoc3RhdGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiAxIC8qIFNsb3RTdGF0dXMuQ2hhbmdlZCAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJucyBhbiBleHRlbnNpb24gdGhhdCBlbmFibGVzIHRoaXMgZmllbGQgYW5kIG92ZXJyaWRlcyB0aGVcbiAgICB3YXkgaXQgaXMgaW5pdGlhbGl6ZWQuIENhbiBiZSB1c2VmdWwgd2hlbiB5b3UgbmVlZCB0byBwcm92aWRlIGFcbiAgICBub24tZGVmYXVsdCBzdGFydGluZyB2YWx1ZSBmb3IgdGhlIGZpZWxkLlxuICAgICovXG4gICAgaW5pdChjcmVhdGUpIHtcbiAgICAgICAgcmV0dXJuIFt0aGlzLCBpbml0RmllbGQub2YoeyBmaWVsZDogdGhpcywgY3JlYXRlIH0pXTtcbiAgICB9XG4gICAgLyoqXG4gICAgU3RhdGUgZmllbGQgaW5zdGFuY2VzIGNhbiBiZSB1c2VkIGFzXG4gICAgW2BFeHRlbnNpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkV4dGVuc2lvbikgdmFsdWVzIHRvIGVuYWJsZSB0aGUgZmllbGQgaW4gYVxuICAgIGdpdmVuIHN0YXRlLlxuICAgICovXG4gICAgZ2V0IGV4dGVuc2lvbigpIHsgcmV0dXJuIHRoaXM7IH1cbn1cbmNvbnN0IFByZWNfID0geyBsb3dlc3Q6IDQsIGxvdzogMywgZGVmYXVsdDogMiwgaGlnaDogMSwgaGlnaGVzdDogMCB9O1xuZnVuY3Rpb24gcHJlYyh2YWx1ZSkge1xuICAgIHJldHVybiAoZXh0KSA9PiBuZXcgUHJlY0V4dGVuc2lvbihleHQsIHZhbHVlKTtcbn1cbi8qKlxuQnkgZGVmYXVsdCBleHRlbnNpb25zIGFyZSByZWdpc3RlcmVkIGluIHRoZSBvcmRlciB0aGV5IGFyZSBmb3VuZFxuaW4gdGhlIGZsYXR0ZW5lZCBmb3JtIG9mIG5lc3RlZCBhcnJheSB0aGF0IHdhcyBwcm92aWRlZC5cbkluZGl2aWR1YWwgZXh0ZW5zaW9uIHZhbHVlcyBjYW4gYmUgYXNzaWduZWQgYSBwcmVjZWRlbmNlIHRvXG5vdmVycmlkZSB0aGlzLiBFeHRlbnNpb25zIHRoYXQgZG8gbm90IGhhdmUgYSBwcmVjZWRlbmNlIHNldCBnZXRcbnRoZSBwcmVjZWRlbmNlIG9mIHRoZSBuZWFyZXN0IHBhcmVudCB3aXRoIGEgcHJlY2VkZW5jZSwgb3JcbltgZGVmYXVsdGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuUHJlYy5kZWZhdWx0KSBpZiB0aGVyZSBpcyBubyBzdWNoIHBhcmVudC4gVGhlXG5maW5hbCBvcmRlcmluZyBvZiBleHRlbnNpb25zIGlzIGRldGVybWluZWQgYnkgZmlyc3Qgc29ydGluZyBieVxucHJlY2VkZW5jZSBhbmQgdGhlbiBieSBvcmRlciB3aXRoaW4gZWFjaCBwcmVjZWRlbmNlLlxuKi9cbmNvbnN0IFByZWMgPSB7XG4gICAgLyoqXG4gICAgVGhlIGhpZ2hlc3QgcHJlY2VkZW5jZSBsZXZlbCwgZm9yIGV4dGVuc2lvbnMgdGhhdCBzaG91bGQgZW5kIHVwXG4gICAgbmVhciB0aGUgc3RhcnQgb2YgdGhlIHByZWNlZGVuY2Ugb3JkZXJpbmcuXG4gICAgKi9cbiAgICBoaWdoZXN0OiAvKkBfX1BVUkVfXyovcHJlYyhQcmVjXy5oaWdoZXN0KSxcbiAgICAvKipcbiAgICBBIGhpZ2hlci10aGFuLWRlZmF1bHQgcHJlY2VkZW5jZSwgZm9yIGV4dGVuc2lvbnMgdGhhdCBzaG91bGRcbiAgICBjb21lIGJlZm9yZSB0aG9zZSB3aXRoIGRlZmF1bHQgcHJlY2VkZW5jZS5cbiAgICAqL1xuICAgIGhpZ2g6IC8qQF9fUFVSRV9fKi9wcmVjKFByZWNfLmhpZ2gpLFxuICAgIC8qKlxuICAgIFRoZSBkZWZhdWx0IHByZWNlZGVuY2UsIHdoaWNoIGlzIGFsc28gdXNlZCBmb3IgZXh0ZW5zaW9uc1xuICAgIHdpdGhvdXQgYW4gZXhwbGljaXQgcHJlY2VkZW5jZS5cbiAgICAqL1xuICAgIGRlZmF1bHQ6IC8qQF9fUFVSRV9fKi9wcmVjKFByZWNfLmRlZmF1bHQpLFxuICAgIC8qKlxuICAgIEEgbG93ZXItdGhhbi1kZWZhdWx0IHByZWNlZGVuY2UuXG4gICAgKi9cbiAgICBsb3c6IC8qQF9fUFVSRV9fKi9wcmVjKFByZWNfLmxvdyksXG4gICAgLyoqXG4gICAgVGhlIGxvd2VzdCBwcmVjZWRlbmNlIGxldmVsLiBNZWFudCBmb3IgdGhpbmdzIHRoYXQgc2hvdWxkIGVuZCB1cFxuICAgIG5lYXIgdGhlIGVuZCBvZiB0aGUgZXh0ZW5zaW9uIG9yZGVyLlxuICAgICovXG4gICAgbG93ZXN0OiAvKkBfX1BVUkVfXyovcHJlYyhQcmVjXy5sb3dlc3QpXG59O1xuY2xhc3MgUHJlY0V4dGVuc2lvbiB7XG4gICAgY29uc3RydWN0b3IoaW5uZXIsIHByZWMpIHtcbiAgICAgICAgdGhpcy5pbm5lciA9IGlubmVyO1xuICAgICAgICB0aGlzLnByZWMgPSBwcmVjO1xuICAgIH1cbn1cbi8qKlxuRXh0ZW5zaW9uIGNvbXBhcnRtZW50cyBjYW4gYmUgdXNlZCB0byBtYWtlIGEgY29uZmlndXJhdGlvblxuZHluYW1pYy4gQnkgW3dyYXBwaW5nXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkNvbXBhcnRtZW50Lm9mKSBwYXJ0IG9mIHlvdXJcbmNvbmZpZ3VyYXRpb24gaW4gYSBjb21wYXJ0bWVudCwgeW91IGNhbiBsYXRlclxuW3JlcGxhY2VdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuQ29tcGFydG1lbnQucmVjb25maWd1cmUpIHRoYXQgcGFydCB0aHJvdWdoIGFcbnRyYW5zYWN0aW9uLlxuKi9cbmNsYXNzIENvbXBhcnRtZW50IHtcbiAgICAvKipcbiAgICBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjb21wYXJ0bWVudCB0byBhZGQgdG8geW91ciBbc3RhdGVcbiAgICBjb25maWd1cmF0aW9uXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlQ29uZmlnLmV4dGVuc2lvbnMpLlxuICAgICovXG4gICAgb2YoZXh0KSB7IHJldHVybiBuZXcgQ29tcGFydG1lbnRJbnN0YW5jZSh0aGlzLCBleHQpOyB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGFuIFtlZmZlY3RdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjLmVmZmVjdHMpIHRoYXRcbiAgICByZWNvbmZpZ3VyZXMgdGhpcyBjb21wYXJ0bWVudC5cbiAgICAqL1xuICAgIHJlY29uZmlndXJlKGNvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIENvbXBhcnRtZW50LnJlY29uZmlndXJlLm9mKHsgY29tcGFydG1lbnQ6IHRoaXMsIGV4dGVuc2lvbjogY29udGVudCB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBjdXJyZW50IGNvbnRlbnQgb2YgdGhlIGNvbXBhcnRtZW50IGluIHRoZSBzdGF0ZSwgb3JcbiAgICBgdW5kZWZpbmVkYCBpZiBpdCBpc24ndCBwcmVzZW50LlxuICAgICovXG4gICAgZ2V0KHN0YXRlKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZS5jb25maWcuY29tcGFydG1lbnRzLmdldCh0aGlzKTtcbiAgICB9XG59XG5jbGFzcyBDb21wYXJ0bWVudEluc3RhbmNlIHtcbiAgICBjb25zdHJ1Y3Rvcihjb21wYXJ0bWVudCwgaW5uZXIpIHtcbiAgICAgICAgdGhpcy5jb21wYXJ0bWVudCA9IGNvbXBhcnRtZW50O1xuICAgICAgICB0aGlzLmlubmVyID0gaW5uZXI7XG4gICAgfVxufVxuY2xhc3MgQ29uZmlndXJhdGlvbiB7XG4gICAgY29uc3RydWN0b3IoYmFzZSwgY29tcGFydG1lbnRzLCBkeW5hbWljU2xvdHMsIGFkZHJlc3MsIHN0YXRpY1ZhbHVlcywgZmFjZXRzKSB7XG4gICAgICAgIHRoaXMuYmFzZSA9IGJhc2U7XG4gICAgICAgIHRoaXMuY29tcGFydG1lbnRzID0gY29tcGFydG1lbnRzO1xuICAgICAgICB0aGlzLmR5bmFtaWNTbG90cyA9IGR5bmFtaWNTbG90cztcbiAgICAgICAgdGhpcy5hZGRyZXNzID0gYWRkcmVzcztcbiAgICAgICAgdGhpcy5zdGF0aWNWYWx1ZXMgPSBzdGF0aWNWYWx1ZXM7XG4gICAgICAgIHRoaXMuZmFjZXRzID0gZmFjZXRzO1xuICAgICAgICB0aGlzLnN0YXR1c1RlbXBsYXRlID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLnN0YXR1c1RlbXBsYXRlLmxlbmd0aCA8IGR5bmFtaWNTbG90cy5sZW5ndGgpXG4gICAgICAgICAgICB0aGlzLnN0YXR1c1RlbXBsYXRlLnB1c2goMCAvKiBTbG90U3RhdHVzLlVucmVzb2x2ZWQgKi8pO1xuICAgIH1cbiAgICBzdGF0aWNGYWNldChmYWNldCkge1xuICAgICAgICBsZXQgYWRkciA9IHRoaXMuYWRkcmVzc1tmYWNldC5pZF07XG4gICAgICAgIHJldHVybiBhZGRyID09IG51bGwgPyBmYWNldC5kZWZhdWx0IDogdGhpcy5zdGF0aWNWYWx1ZXNbYWRkciA+PiAxXTtcbiAgICB9XG4gICAgc3RhdGljIHJlc29sdmUoYmFzZSwgY29tcGFydG1lbnRzLCBvbGRTdGF0ZSkge1xuICAgICAgICBsZXQgZmllbGRzID0gW107XG4gICAgICAgIGxldCBmYWNldHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBsZXQgbmV3Q29tcGFydG1lbnRzID0gbmV3IE1hcCgpO1xuICAgICAgICBmb3IgKGxldCBleHQgb2YgZmxhdHRlbihiYXNlLCBjb21wYXJ0bWVudHMsIG5ld0NvbXBhcnRtZW50cykpIHtcbiAgICAgICAgICAgIGlmIChleHQgaW5zdGFuY2VvZiBTdGF0ZUZpZWxkKVxuICAgICAgICAgICAgICAgIGZpZWxkcy5wdXNoKGV4dCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgKGZhY2V0c1tleHQuZmFjZXQuaWRdIHx8IChmYWNldHNbZXh0LmZhY2V0LmlkXSA9IFtdKSkucHVzaChleHQpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBhZGRyZXNzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgbGV0IHN0YXRpY1ZhbHVlcyA9IFtdO1xuICAgICAgICBsZXQgZHluYW1pY1Nsb3RzID0gW107XG4gICAgICAgIGZvciAobGV0IGZpZWxkIG9mIGZpZWxkcykge1xuICAgICAgICAgICAgYWRkcmVzc1tmaWVsZC5pZF0gPSBkeW5hbWljU2xvdHMubGVuZ3RoIDw8IDE7XG4gICAgICAgICAgICBkeW5hbWljU2xvdHMucHVzaChhID0+IGZpZWxkLnNsb3QoYSkpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBvbGRGYWNldHMgPSBvbGRTdGF0ZSA9PT0gbnVsbCB8fCBvbGRTdGF0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2xkU3RhdGUuY29uZmlnLmZhY2V0cztcbiAgICAgICAgZm9yIChsZXQgaWQgaW4gZmFjZXRzKSB7XG4gICAgICAgICAgICBsZXQgcHJvdmlkZXJzID0gZmFjZXRzW2lkXSwgZmFjZXQgPSBwcm92aWRlcnNbMF0uZmFjZXQ7XG4gICAgICAgICAgICBsZXQgb2xkUHJvdmlkZXJzID0gb2xkRmFjZXRzICYmIG9sZEZhY2V0c1tpZF0gfHwgW107XG4gICAgICAgICAgICBpZiAocHJvdmlkZXJzLmV2ZXJ5KHAgPT4gcC50eXBlID09IDAgLyogUHJvdmlkZXIuU3RhdGljICovKSkge1xuICAgICAgICAgICAgICAgIGFkZHJlc3NbZmFjZXQuaWRdID0gKHN0YXRpY1ZhbHVlcy5sZW5ndGggPDwgMSkgfCAxO1xuICAgICAgICAgICAgICAgIGlmIChzYW1lQXJyYXkob2xkUHJvdmlkZXJzLCBwcm92aWRlcnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRpY1ZhbHVlcy5wdXNoKG9sZFN0YXRlLmZhY2V0KGZhY2V0KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSBmYWNldC5jb21iaW5lKHByb3ZpZGVycy5tYXAocCA9PiBwLnZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRpY1ZhbHVlcy5wdXNoKG9sZFN0YXRlICYmIGZhY2V0LmNvbXBhcmUodmFsdWUsIG9sZFN0YXRlLmZhY2V0KGZhY2V0KSkgPyBvbGRTdGF0ZS5mYWNldChmYWNldCkgOiB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcCBvZiBwcm92aWRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHAudHlwZSA9PSAwIC8qIFByb3ZpZGVyLlN0YXRpYyAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzc1twLmlkXSA9IChzdGF0aWNWYWx1ZXMubGVuZ3RoIDw8IDEpIHwgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRpY1ZhbHVlcy5wdXNoKHAudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzc1twLmlkXSA9IGR5bmFtaWNTbG90cy5sZW5ndGggPDwgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGR5bmFtaWNTbG90cy5wdXNoKGEgPT4gcC5keW5hbWljU2xvdChhKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWRkcmVzc1tmYWNldC5pZF0gPSBkeW5hbWljU2xvdHMubGVuZ3RoIDw8IDE7XG4gICAgICAgICAgICAgICAgZHluYW1pY1Nsb3RzLnB1c2goYSA9PiBkeW5hbWljRmFjZXRTbG90KGEsIGZhY2V0LCBwcm92aWRlcnMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgZHluYW1pYyA9IGR5bmFtaWNTbG90cy5tYXAoZiA9PiBmKGFkZHJlc3MpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBDb25maWd1cmF0aW9uKGJhc2UsIG5ld0NvbXBhcnRtZW50cywgZHluYW1pYywgYWRkcmVzcywgc3RhdGljVmFsdWVzLCBmYWNldHMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZsYXR0ZW4oZXh0ZW5zaW9uLCBjb21wYXJ0bWVudHMsIG5ld0NvbXBhcnRtZW50cykge1xuICAgIGxldCByZXN1bHQgPSBbW10sIFtdLCBbXSwgW10sIFtdXTtcbiAgICBsZXQgc2VlbiA9IG5ldyBNYXAoKTtcbiAgICBmdW5jdGlvbiBpbm5lcihleHQsIHByZWMpIHtcbiAgICAgICAgbGV0IGtub3duID0gc2Vlbi5nZXQoZXh0KTtcbiAgICAgICAgaWYgKGtub3duICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChrbm93biA8PSBwcmVjKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGxldCBmb3VuZCA9IHJlc3VsdFtrbm93bl0uaW5kZXhPZihleHQpO1xuICAgICAgICAgICAgaWYgKGZvdW5kID4gLTEpXG4gICAgICAgICAgICAgICAgcmVzdWx0W2tub3duXS5zcGxpY2UoZm91bmQsIDEpO1xuICAgICAgICAgICAgaWYgKGV4dCBpbnN0YW5jZW9mIENvbXBhcnRtZW50SW5zdGFuY2UpXG4gICAgICAgICAgICAgICAgbmV3Q29tcGFydG1lbnRzLmRlbGV0ZShleHQuY29tcGFydG1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHNlZW4uc2V0KGV4dCwgcHJlYyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGV4dCkpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGUgb2YgZXh0KVxuICAgICAgICAgICAgICAgIGlubmVyKGUsIHByZWMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV4dCBpbnN0YW5jZW9mIENvbXBhcnRtZW50SW5zdGFuY2UpIHtcbiAgICAgICAgICAgIGlmIChuZXdDb21wYXJ0bWVudHMuaGFzKGV4dC5jb21wYXJ0bWVudCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYER1cGxpY2F0ZSB1c2Ugb2YgY29tcGFydG1lbnQgaW4gZXh0ZW5zaW9uc2ApO1xuICAgICAgICAgICAgbGV0IGNvbnRlbnQgPSBjb21wYXJ0bWVudHMuZ2V0KGV4dC5jb21wYXJ0bWVudCkgfHwgZXh0LmlubmVyO1xuICAgICAgICAgICAgbmV3Q29tcGFydG1lbnRzLnNldChleHQuY29tcGFydG1lbnQsIGNvbnRlbnQpO1xuICAgICAgICAgICAgaW5uZXIoY29udGVudCwgcHJlYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXh0IGluc3RhbmNlb2YgUHJlY0V4dGVuc2lvbikge1xuICAgICAgICAgICAgaW5uZXIoZXh0LmlubmVyLCBleHQucHJlYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXh0IGluc3RhbmNlb2YgU3RhdGVGaWVsZCkge1xuICAgICAgICAgICAgcmVzdWx0W3ByZWNdLnB1c2goZXh0KTtcbiAgICAgICAgICAgIGlmIChleHQucHJvdmlkZXMpXG4gICAgICAgICAgICAgICAgaW5uZXIoZXh0LnByb3ZpZGVzLCBwcmVjKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChleHQgaW5zdGFuY2VvZiBGYWNldFByb3ZpZGVyKSB7XG4gICAgICAgICAgICByZXN1bHRbcHJlY10ucHVzaChleHQpO1xuICAgICAgICAgICAgaWYgKGV4dC5mYWNldC5leHRlbnNpb25zKVxuICAgICAgICAgICAgICAgIGlubmVyKGV4dC5mYWNldC5leHRlbnNpb25zLCBQcmVjXy5kZWZhdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBjb250ZW50ID0gZXh0LmV4dGVuc2lvbjtcbiAgICAgICAgICAgIGlmICghY29udGVudClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVucmVjb2duaXplZCBleHRlbnNpb24gdmFsdWUgaW4gZXh0ZW5zaW9uIHNldCAoJHtleHR9KS4gVGhpcyBzb21ldGltZXMgaGFwcGVucyBiZWNhdXNlIG11bHRpcGxlIGluc3RhbmNlcyBvZiBAY29kZW1pcnJvci9zdGF0ZSBhcmUgbG9hZGVkLCBicmVha2luZyBpbnN0YW5jZW9mIGNoZWNrcy5gKTtcbiAgICAgICAgICAgIGlubmVyKGNvbnRlbnQsIHByZWMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlubmVyKGV4dGVuc2lvbiwgUHJlY18uZGVmYXVsdCk7XG4gICAgcmV0dXJuIHJlc3VsdC5yZWR1Y2UoKGEsIGIpID0+IGEuY29uY2F0KGIpKTtcbn1cbmZ1bmN0aW9uIGVuc3VyZUFkZHIoc3RhdGUsIGFkZHIpIHtcbiAgICBpZiAoYWRkciAmIDEpXG4gICAgICAgIHJldHVybiAyIC8qIFNsb3RTdGF0dXMuQ29tcHV0ZWQgKi87XG4gICAgbGV0IGlkeCA9IGFkZHIgPj4gMTtcbiAgICBsZXQgc3RhdHVzID0gc3RhdGUuc3RhdHVzW2lkeF07XG4gICAgaWYgKHN0YXR1cyA9PSA0IC8qIFNsb3RTdGF0dXMuQ29tcHV0aW5nICovKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDeWNsaWMgZGVwZW5kZW5jeSBiZXR3ZWVuIGZpZWxkcyBhbmQvb3IgZmFjZXRzXCIpO1xuICAgIGlmIChzdGF0dXMgJiAyIC8qIFNsb3RTdGF0dXMuQ29tcHV0ZWQgKi8pXG4gICAgICAgIHJldHVybiBzdGF0dXM7XG4gICAgc3RhdGUuc3RhdHVzW2lkeF0gPSA0IC8qIFNsb3RTdGF0dXMuQ29tcHV0aW5nICovO1xuICAgIGxldCBjaGFuZ2VkID0gc3RhdGUuY29tcHV0ZVNsb3Qoc3RhdGUsIHN0YXRlLmNvbmZpZy5keW5hbWljU2xvdHNbaWR4XSk7XG4gICAgcmV0dXJuIHN0YXRlLnN0YXR1c1tpZHhdID0gMiAvKiBTbG90U3RhdHVzLkNvbXB1dGVkICovIHwgY2hhbmdlZDtcbn1cbmZ1bmN0aW9uIGdldEFkZHIoc3RhdGUsIGFkZHIpIHtcbiAgICByZXR1cm4gYWRkciAmIDEgPyBzdGF0ZS5jb25maWcuc3RhdGljVmFsdWVzW2FkZHIgPj4gMV0gOiBzdGF0ZS52YWx1ZXNbYWRkciA+PiAxXTtcbn1cblxuY29uc3QgbGFuZ3VhZ2VEYXRhID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgYWxsb3dNdWx0aXBsZVNlbGVjdGlvbnMgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lOiB2YWx1ZXMgPT4gdmFsdWVzLnNvbWUodiA9PiB2KSxcbiAgICBzdGF0aWM6IHRydWVcbn0pO1xuY29uc3QgbGluZVNlcGFyYXRvciA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmU6IHZhbHVlcyA9PiB2YWx1ZXMubGVuZ3RoID8gdmFsdWVzWzBdIDogdW5kZWZpbmVkLFxuICAgIHN0YXRpYzogdHJ1ZVxufSk7XG5jb25zdCBjaGFuZ2VGaWx0ZXIgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCB0cmFuc2FjdGlvbkZpbHRlciA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IHRyYW5zYWN0aW9uRXh0ZW5kZXIgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCByZWFkT25seSA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmU6IHZhbHVlcyA9PiB2YWx1ZXMubGVuZ3RoID8gdmFsdWVzWzBdIDogZmFsc2Vcbn0pO1xuXG4vKipcbkFubm90YXRpb25zIGFyZSB0YWdnZWQgdmFsdWVzIHRoYXQgYXJlIHVzZWQgdG8gYWRkIG1ldGFkYXRhIHRvXG50cmFuc2FjdGlvbnMgaW4gYW4gZXh0ZW5zaWJsZSB3YXkuIFRoZXkgc2hvdWxkIGJlIHVzZWQgdG8gbW9kZWxcbnRoaW5ncyB0aGF0IGVmZmVjdCB0aGUgZW50aXJlIHRyYW5zYWN0aW9uIChzdWNoIGFzIGl0cyBbdGltZVxuc3RhbXBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25edGltZSkgb3IgaW5mb3JtYXRpb24gYWJvdXQgaXRzXG5bb3JpZ2luXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uXnVzZXJFdmVudCkpLiBGb3IgZWZmZWN0cyB0aGF0IGhhcHBlblxuX2Fsb25nc2lkZV8gdGhlIG90aGVyIGNoYW5nZXMgbWFkZSBieSB0aGUgdHJhbnNhY3Rpb24sIFtzdGF0ZVxuZWZmZWN0c10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5TdGF0ZUVmZmVjdCkgYXJlIG1vcmUgYXBwcm9wcmlhdGUuXG4qL1xuY2xhc3MgQW5ub3RhdGlvbiB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgYW5ub3RhdGlvbiB0eXBlLlxuICAgICovXG4gICAgdHlwZSwgXG4gICAgLyoqXG4gICAgVGhlIHZhbHVlIG9mIHRoaXMgYW5ub3RhdGlvbi5cbiAgICAqL1xuICAgIHZhbHVlKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgRGVmaW5lIGEgbmV3IHR5cGUgb2YgYW5ub3RhdGlvbi5cbiAgICAqL1xuICAgIHN0YXRpYyBkZWZpbmUoKSB7IHJldHVybiBuZXcgQW5ub3RhdGlvblR5cGUoKTsgfVxufVxuLyoqXG5NYXJrZXIgdGhhdCBpZGVudGlmaWVzIGEgdHlwZSBvZiBbYW5ub3RhdGlvbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5Bbm5vdGF0aW9uKS5cbiovXG5jbGFzcyBBbm5vdGF0aW9uVHlwZSB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoaXMgYW5ub3RhdGlvbi5cbiAgICAqL1xuICAgIG9mKHZhbHVlKSB7IHJldHVybiBuZXcgQW5ub3RhdGlvbih0aGlzLCB2YWx1ZSk7IH1cbn1cbi8qKlxuUmVwcmVzZW50YXRpb24gb2YgYSB0eXBlIG9mIHN0YXRlIGVmZmVjdC4gRGVmaW5lZCB3aXRoXG5bYFN0YXRlRWZmZWN0LmRlZmluZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuU3RhdGVFZmZlY3ReZGVmaW5lKS5cbiovXG5jbGFzcyBTdGF0ZUVmZmVjdFR5cGUge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLy8gVGhlIGBhbnlgIHR5cGVzIGluIHRoZXNlIGZ1bmN0aW9uIHR5cGVzIGFyZSB0aGVyZSB0byB3b3JrXG4gICAgLy8gYXJvdW5kIFR5cGVTY3JpcHQgaXNzdWUgIzM3NjMxLCB3aGVyZSB0aGUgdHlwZSBndWFyZCBvblxuICAgIC8vIGBTdGF0ZUVmZmVjdC5pc2AgbXlzdGVyaW91c2x5IHN0b3BzIHdvcmtpbmcgd2hlbiB0aGVzZSBwcm9wZXJseVxuICAgIC8vIGhhdmUgdHlwZSBgVmFsdWVgLlxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgbWFwKSB7XG4gICAgICAgIHRoaXMubWFwID0gbWFwO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBbc3RhdGUgZWZmZWN0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlN0YXRlRWZmZWN0KSBpbnN0YW5jZSBvZiB0aGlzXG4gICAgdHlwZS5cbiAgICAqL1xuICAgIG9mKHZhbHVlKSB7IHJldHVybiBuZXcgU3RhdGVFZmZlY3QodGhpcywgdmFsdWUpOyB9XG59XG4vKipcblN0YXRlIGVmZmVjdHMgY2FuIGJlIHVzZWQgdG8gcmVwcmVzZW50IGFkZGl0aW9uYWwgZWZmZWN0c1xuYXNzb2NpYXRlZCB3aXRoIGEgW3RyYW5zYWN0aW9uXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uLmVmZmVjdHMpLiBUaGV5XG5hcmUgb2Z0ZW4gdXNlZnVsIHRvIG1vZGVsIGNoYW5nZXMgdG8gY3VzdG9tIFtzdGF0ZVxuZmllbGRzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlN0YXRlRmllbGQpLCB3aGVuIHRob3NlIGNoYW5nZXMgYXJlbid0IGltcGxpY2l0IGluXG5kb2N1bWVudCBvciBzZWxlY3Rpb24gY2hhbmdlcy5cbiovXG5jbGFzcyBTdGF0ZUVmZmVjdCB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHR5cGUsIFxuICAgIC8qKlxuICAgIFRoZSB2YWx1ZSBvZiB0aGlzIGVmZmVjdC5cbiAgICAqL1xuICAgIHZhbHVlKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgTWFwIHRoaXMgZWZmZWN0IHRocm91Z2ggYSBwb3NpdGlvbiBtYXBwaW5nLiBXaWxsIHJldHVyblxuICAgIGB1bmRlZmluZWRgIHdoZW4gdGhhdCBlbmRzIHVwIGRlbGV0aW5nIHRoZSBlZmZlY3QuXG4gICAgKi9cbiAgICBtYXAobWFwcGluZykge1xuICAgICAgICBsZXQgbWFwcGVkID0gdGhpcy50eXBlLm1hcCh0aGlzLnZhbHVlLCBtYXBwaW5nKTtcbiAgICAgICAgcmV0dXJuIG1hcHBlZCA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogbWFwcGVkID09IHRoaXMudmFsdWUgPyB0aGlzIDogbmV3IFN0YXRlRWZmZWN0KHRoaXMudHlwZSwgbWFwcGVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGVsbHMgeW91IHdoZXRoZXIgdGhpcyBlZmZlY3Qgb2JqZWN0IGlzIG9mIGEgZ2l2ZW5cbiAgICBbdHlwZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5TdGF0ZUVmZmVjdFR5cGUpLlxuICAgICovXG4gICAgaXModHlwZSkgeyByZXR1cm4gdGhpcy50eXBlID09IHR5cGU7IH1cbiAgICAvKipcbiAgICBEZWZpbmUgYSBuZXcgZWZmZWN0IHR5cGUuIFRoZSB0eXBlIHBhcmFtZXRlciBpbmRpY2F0ZXMgdGhlIHR5cGVcbiAgICBvZiB2YWx1ZXMgdGhhdCBoaXMgZWZmZWN0IGhvbGRzLiBJdCBzaG91bGQgYmUgYSB0eXBlIHRoYXRcbiAgICBkb2Vzbid0IGluY2x1ZGUgYHVuZGVmaW5lZGAsIHNpbmNlIHRoYXQgaXMgdXNlZCBpblxuICAgIFttYXBwaW5nXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlN0YXRlRWZmZWN0Lm1hcCkgdG8gaW5kaWNhdGUgdGhhdCBhbiBlZmZlY3QgaXNcbiAgICByZW1vdmVkLlxuICAgICovXG4gICAgc3RhdGljIGRlZmluZShzcGVjID0ge30pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdGF0ZUVmZmVjdFR5cGUoc3BlYy5tYXAgfHwgKHYgPT4gdikpO1xuICAgIH1cbiAgICAvKipcbiAgICBNYXAgYW4gYXJyYXkgb2YgZWZmZWN0cyB0aHJvdWdoIGEgY2hhbmdlIHNldC5cbiAgICAqL1xuICAgIHN0YXRpYyBtYXBFZmZlY3RzKGVmZmVjdHMsIG1hcHBpbmcpIHtcbiAgICAgICAgaWYgKCFlZmZlY3RzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBlZmZlY3RzO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiBlZmZlY3RzKSB7XG4gICAgICAgICAgICBsZXQgbWFwcGVkID0gZWZmZWN0Lm1hcChtYXBwaW5nKTtcbiAgICAgICAgICAgIGlmIChtYXBwZWQpXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobWFwcGVkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbi8qKlxuVGhpcyBlZmZlY3QgY2FuIGJlIHVzZWQgdG8gcmVjb25maWd1cmUgdGhlIHJvb3QgZXh0ZW5zaW9ucyBvZlxudGhlIGVkaXRvci4gRG9pbmcgdGhpcyB3aWxsIGRpc2NhcmQgYW55IGV4dGVuc2lvbnNcblthcHBlbmRlZF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5TdGF0ZUVmZmVjdF5hcHBlbmRDb25maWcpLCBidXQgZG9lcyBub3QgcmVzZXRcbnRoZSBjb250ZW50IG9mIFtyZWNvbmZpZ3VyZWRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuQ29tcGFydG1lbnQucmVjb25maWd1cmUpXG5jb21wYXJ0bWVudHMuXG4qL1xuU3RhdGVFZmZlY3QucmVjb25maWd1cmUgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG4vKipcbkFwcGVuZCBleHRlbnNpb25zIHRvIHRoZSB0b3AtbGV2ZWwgY29uZmlndXJhdGlvbiBvZiB0aGUgZWRpdG9yLlxuKi9cblN0YXRlRWZmZWN0LmFwcGVuZENvbmZpZyA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcbi8qKlxuQ2hhbmdlcyB0byB0aGUgZWRpdG9yIHN0YXRlIGFyZSBncm91cGVkIGludG8gdHJhbnNhY3Rpb25zLlxuVHlwaWNhbGx5LCBhIHVzZXIgYWN0aW9uIGNyZWF0ZXMgYSBzaW5nbGUgdHJhbnNhY3Rpb24sIHdoaWNoIG1heVxuY29udGFpbiBhbnkgbnVtYmVyIG9mIGRvY3VtZW50IGNoYW5nZXMsIG1heSBjaGFuZ2UgdGhlIHNlbGVjdGlvbixcbm9yIGhhdmUgb3RoZXIgZWZmZWN0cy4gQ3JlYXRlIGEgdHJhbnNhY3Rpb24gYnkgY2FsbGluZ1xuW2BFZGl0b3JTdGF0ZS51cGRhdGVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLnVwZGF0ZSksIG9yIGltbWVkaWF0ZWx5XG5kaXNwYXRjaCBvbmUgYnkgY2FsbGluZ1xuW2BFZGl0b3JWaWV3LmRpc3BhdGNoYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcuZGlzcGF0Y2gpLlxuKi9cbmNsYXNzIFRyYW5zYWN0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgc3RhdGUgZnJvbSB3aGljaCB0aGUgdHJhbnNhY3Rpb24gc3RhcnRzLlxuICAgICovXG4gICAgc3RhcnRTdGF0ZSwgXG4gICAgLyoqXG4gICAgVGhlIGRvY3VtZW50IGNoYW5nZXMgbWFkZSBieSB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICovXG4gICAgY2hhbmdlcywgXG4gICAgLyoqXG4gICAgVGhlIHNlbGVjdGlvbiBzZXQgYnkgdGhpcyB0cmFuc2FjdGlvbiwgb3IgdW5kZWZpbmVkIGlmIGl0XG4gICAgZG9lc24ndCBleHBsaWNpdGx5IHNldCBhIHNlbGVjdGlvbi5cbiAgICAqL1xuICAgIHNlbGVjdGlvbiwgXG4gICAgLyoqXG4gICAgVGhlIGVmZmVjdHMgYWRkZWQgdG8gdGhlIHRyYW5zYWN0aW9uLlxuICAgICovXG4gICAgZWZmZWN0cywgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBhbm5vdGF0aW9ucywgXG4gICAgLyoqXG4gICAgV2hldGhlciB0aGUgc2VsZWN0aW9uIHNob3VsZCBiZSBzY3JvbGxlZCBpbnRvIHZpZXcgYWZ0ZXIgdGhpc1xuICAgIHRyYW5zYWN0aW9uIGlzIGRpc3BhdGNoZWQuXG4gICAgKi9cbiAgICBzY3JvbGxJbnRvVmlldykge1xuICAgICAgICB0aGlzLnN0YXJ0U3RhdGUgPSBzdGFydFN0YXRlO1xuICAgICAgICB0aGlzLmNoYW5nZXMgPSBjaGFuZ2VzO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbiA9IHNlbGVjdGlvbjtcbiAgICAgICAgdGhpcy5lZmZlY3RzID0gZWZmZWN0cztcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9ucyA9IGFubm90YXRpb25zO1xuICAgICAgICB0aGlzLnNjcm9sbEludG9WaWV3ID0gc2Nyb2xsSW50b1ZpZXc7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fZG9jID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IG51bGw7XG4gICAgICAgIGlmIChzZWxlY3Rpb24pXG4gICAgICAgICAgICBjaGVja1NlbGVjdGlvbihzZWxlY3Rpb24sIGNoYW5nZXMubmV3TGVuZ3RoKTtcbiAgICAgICAgaWYgKCFhbm5vdGF0aW9ucy5zb21lKChhKSA9PiBhLnR5cGUgPT0gVHJhbnNhY3Rpb24udGltZSkpXG4gICAgICAgICAgICB0aGlzLmFubm90YXRpb25zID0gYW5ub3RhdGlvbnMuY29uY2F0KFRyYW5zYWN0aW9uLnRpbWUub2YoRGF0ZS5ub3coKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUoc3RhcnRTdGF0ZSwgY2hhbmdlcywgc2VsZWN0aW9uLCBlZmZlY3RzLCBhbm5vdGF0aW9ucywgc2Nyb2xsSW50b1ZpZXcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbihzdGFydFN0YXRlLCBjaGFuZ2VzLCBzZWxlY3Rpb24sIGVmZmVjdHMsIGFubm90YXRpb25zLCBzY3JvbGxJbnRvVmlldyk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBuZXcgZG9jdW1lbnQgcHJvZHVjZWQgYnkgdGhlIHRyYW5zYWN0aW9uLiBDb250cmFyeSB0b1xuICAgIFtgLnN0YXRlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvbi5zdGF0ZSlgLmRvY2AsIGFjY2Vzc2luZyB0aGlzIHdvbid0XG4gICAgZm9yY2UgdGhlIGVudGlyZSBuZXcgc3RhdGUgdG8gYmUgY29tcHV0ZWQgcmlnaHQgYXdheSwgc28gaXQgaXNcbiAgICByZWNvbW1lbmRlZCB0aGF0IFt0cmFuc2FjdGlvblxuICAgIGZpbHRlcnNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVedHJhbnNhY3Rpb25GaWx0ZXIpIHVzZSB0aGlzIGdldHRlclxuICAgIHdoZW4gdGhleSBuZWVkIHRvIGxvb2sgYXQgdGhlIG5ldyBkb2N1bWVudC5cbiAgICAqL1xuICAgIGdldCBuZXdEb2MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kb2MgfHwgKHRoaXMuX2RvYyA9IHRoaXMuY2hhbmdlcy5hcHBseSh0aGlzLnN0YXJ0U3RhdGUuZG9jKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBuZXcgc2VsZWN0aW9uIHByb2R1Y2VkIGJ5IHRoZSB0cmFuc2FjdGlvbi4gSWZcbiAgICBbYHRoaXMuc2VsZWN0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvbi5zZWxlY3Rpb24pIGlzIHVuZGVmaW5lZCxcbiAgICB0aGlzIHdpbGwgW21hcF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTZWxlY3Rpb24ubWFwKSB0aGUgc3RhcnQgc3RhdGUnc1xuICAgIGN1cnJlbnQgc2VsZWN0aW9uIHRocm91Z2ggdGhlIGNoYW5nZXMgbWFkZSBieSB0aGUgdHJhbnNhY3Rpb24uXG4gICAgKi9cbiAgICBnZXQgbmV3U2VsZWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb24gfHwgdGhpcy5zdGFydFN0YXRlLnNlbGVjdGlvbi5tYXAodGhpcy5jaGFuZ2VzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIG5ldyBzdGF0ZSBjcmVhdGVkIGJ5IHRoZSB0cmFuc2FjdGlvbi4gQ29tcHV0ZWQgb24gZGVtYW5kXG4gICAgKGJ1dCByZXRhaW5lZCBmb3Igc3Vic2VxdWVudCBhY2Nlc3MpLCBzbyBpdCBpcyByZWNvbW1lbmRlZCBub3QgdG9cbiAgICBhY2Nlc3MgaXQgaW4gW3RyYW5zYWN0aW9uXG4gICAgZmlsdGVyc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV50cmFuc2FjdGlvbkZpbHRlcikgd2hlbiBwb3NzaWJsZS5cbiAgICAqL1xuICAgIGdldCBzdGF0ZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9zdGF0ZSlcbiAgICAgICAgICAgIHRoaXMuc3RhcnRTdGF0ZS5hcHBseVRyYW5zYWN0aW9uKHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgdmFsdWUgb2YgdGhlIGdpdmVuIGFubm90YXRpb24gdHlwZSwgaWYgYW55LlxuICAgICovXG4gICAgYW5ub3RhdGlvbih0eXBlKSB7XG4gICAgICAgIGZvciAobGV0IGFubiBvZiB0aGlzLmFubm90YXRpb25zKVxuICAgICAgICAgICAgaWYgKGFubi50eXBlID09IHR5cGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFubi52YWx1ZTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHRyYW5zYWN0aW9uIGNoYW5nZWQgdGhlIGRvY3VtZW50LlxuICAgICovXG4gICAgZ2V0IGRvY0NoYW5nZWQoKSB7IHJldHVybiAhdGhpcy5jaGFuZ2VzLmVtcHR5OyB9XG4gICAgLyoqXG4gICAgSW5kaWNhdGVzIHdoZXRoZXIgdGhpcyB0cmFuc2FjdGlvbiByZWNvbmZpZ3VyZXMgdGhlIHN0YXRlXG4gICAgKHRocm91Z2ggYSBbY29uZmlndXJhdGlvbiBjb21wYXJ0bWVudF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5Db21wYXJ0bWVudCkgb3JcbiAgICB3aXRoIGEgdG9wLWxldmVsIGNvbmZpZ3VyYXRpb25cbiAgICBbZWZmZWN0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlN0YXRlRWZmZWN0XnJlY29uZmlndXJlKS5cbiAgICAqL1xuICAgIGdldCByZWNvbmZpZ3VyZWQoKSB7IHJldHVybiB0aGlzLnN0YXJ0U3RhdGUuY29uZmlnICE9IHRoaXMuc3RhdGUuY29uZmlnOyB9XG4gICAgLyoqXG4gICAgUmV0dXJucyB0cnVlIGlmIHRoZSB0cmFuc2FjdGlvbiBoYXMgYSBbdXNlclxuICAgIGV2ZW50XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uXnVzZXJFdmVudCkgYW5ub3RhdGlvbiB0aGF0IGlzIGVxdWFsIHRvXG4gICAgb3IgbW9yZSBzcGVjaWZpYyB0aGFuIGBldmVudGAuIEZvciBleGFtcGxlLCBpZiB0aGUgdHJhbnNhY3Rpb25cbiAgICBoYXMgYFwic2VsZWN0LnBvaW50ZXJcImAgYXMgdXNlciBldmVudCwgYFwic2VsZWN0XCJgIGFuZFxuICAgIGBcInNlbGVjdC5wb2ludGVyXCJgIHdpbGwgbWF0Y2ggaXQuXG4gICAgKi9cbiAgICBpc1VzZXJFdmVudChldmVudCkge1xuICAgICAgICBsZXQgZSA9IHRoaXMuYW5ub3RhdGlvbihUcmFuc2FjdGlvbi51c2VyRXZlbnQpO1xuICAgICAgICByZXR1cm4gISEoZSAmJiAoZSA9PSBldmVudCB8fCBlLmxlbmd0aCA+IGV2ZW50Lmxlbmd0aCAmJiBlLnNsaWNlKDAsIGV2ZW50Lmxlbmd0aCkgPT0gZXZlbnQgJiYgZVtldmVudC5sZW5ndGhdID09IFwiLlwiKSk7XG4gICAgfVxufVxuLyoqXG5Bbm5vdGF0aW9uIHVzZWQgdG8gc3RvcmUgdHJhbnNhY3Rpb24gdGltZXN0YW1wcy4gQXV0b21hdGljYWxseVxuYWRkZWQgdG8gZXZlcnkgdHJhbnNhY3Rpb24sIGhvbGRpbmcgYERhdGUubm93KClgLlxuKi9cblRyYW5zYWN0aW9uLnRpbWUgPSAvKkBfX1BVUkVfXyovQW5ub3RhdGlvbi5kZWZpbmUoKTtcbi8qKlxuQW5ub3RhdGlvbiB1c2VkIHRvIGFzc29jaWF0ZSBhIHRyYW5zYWN0aW9uIHdpdGggYSB1c2VyIGludGVyZmFjZVxuZXZlbnQuIEhvbGRzIGEgc3RyaW5nIGlkZW50aWZ5aW5nIHRoZSBldmVudCwgdXNpbmcgYVxuZG90LXNlcGFyYXRlZCBmb3JtYXQgdG8gc3VwcG9ydCBhdHRhY2hpbmcgbW9yZSBzcGVjaWZpY1xuaW5mb3JtYXRpb24uIFRoZSBldmVudHMgdXNlZCBieSB0aGUgY29yZSBsaWJyYXJpZXMgYXJlOlxuXG4gLSBgXCJpbnB1dFwiYCB3aGVuIGNvbnRlbnQgaXMgZW50ZXJlZFxuICAgLSBgXCJpbnB1dC50eXBlXCJgIGZvciB0eXBlZCBpbnB1dFxuICAgICAtIGBcImlucHV0LnR5cGUuY29tcG9zZVwiYCBmb3IgY29tcG9zaXRpb25cbiAgIC0gYFwiaW5wdXQucGFzdGVcImAgZm9yIHBhc3RlZCBpbnB1dFxuICAgLSBgXCJpbnB1dC5kcm9wXCJgIHdoZW4gYWRkaW5nIGNvbnRlbnQgd2l0aCBkcmFnLWFuZC1kcm9wXG4gICAtIGBcImlucHV0LmNvbXBsZXRlXCJgIHdoZW4gYXV0b2NvbXBsZXRpbmdcbiAtIGBcImRlbGV0ZVwiYCB3aGVuIHRoZSB1c2VyIGRlbGV0ZXMgY29udGVudFxuICAgLSBgXCJkZWxldGUuc2VsZWN0aW9uXCJgIHdoZW4gZGVsZXRpbmcgdGhlIHNlbGVjdGlvblxuICAgLSBgXCJkZWxldGUuZm9yd2FyZFwiYCB3aGVuIGRlbGV0aW5nIGZvcndhcmQgZnJvbSB0aGUgc2VsZWN0aW9uXG4gICAtIGBcImRlbGV0ZS5iYWNrd2FyZFwiYCB3aGVuIGRlbGV0aW5nIGJhY2t3YXJkIGZyb20gdGhlIHNlbGVjdGlvblxuICAgLSBgXCJkZWxldGUuY3V0XCJgIHdoZW4gY3V0dGluZyB0byB0aGUgY2xpcGJvYXJkXG4gLSBgXCJtb3ZlXCJgIHdoZW4gY29udGVudCBpcyBtb3ZlZFxuICAgLSBgXCJtb3ZlLmRyb3BcImAgd2hlbiBjb250ZW50IGlzIG1vdmVkIHdpdGhpbiB0aGUgZWRpdG9yIHRocm91Z2ggZHJhZy1hbmQtZHJvcFxuIC0gYFwic2VsZWN0XCJgIHdoZW4gZXhwbGljaXRseSBjaGFuZ2luZyB0aGUgc2VsZWN0aW9uXG4gICAtIGBcInNlbGVjdC5wb2ludGVyXCJgIHdoZW4gc2VsZWN0aW5nIHdpdGggYSBtb3VzZSBvciBvdGhlciBwb2ludGluZyBkZXZpY2VcbiAtIGBcInVuZG9cImAgYW5kIGBcInJlZG9cImAgZm9yIGhpc3RvcnkgYWN0aW9uc1xuXG5Vc2UgW2Bpc1VzZXJFdmVudGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb24uaXNVc2VyRXZlbnQpIHRvIGNoZWNrXG53aGV0aGVyIHRoZSBhbm5vdGF0aW9uIG1hdGNoZXMgYSBnaXZlbiBldmVudC5cbiovXG5UcmFuc2FjdGlvbi51c2VyRXZlbnQgPSAvKkBfX1BVUkVfXyovQW5ub3RhdGlvbi5kZWZpbmUoKTtcbi8qKlxuQW5ub3RhdGlvbiBpbmRpY2F0aW5nIHdoZXRoZXIgYSB0cmFuc2FjdGlvbiBzaG91bGQgYmUgYWRkZWQgdG9cbnRoZSB1bmRvIGhpc3Rvcnkgb3Igbm90LlxuKi9cblRyYW5zYWN0aW9uLmFkZFRvSGlzdG9yeSA9IC8qQF9fUFVSRV9fKi9Bbm5vdGF0aW9uLmRlZmluZSgpO1xuLyoqXG5Bbm5vdGF0aW9uIGluZGljYXRpbmcgKHdoZW4gcHJlc2VudCBhbmQgdHJ1ZSkgdGhhdCBhIHRyYW5zYWN0aW9uXG5yZXByZXNlbnRzIGEgY2hhbmdlIG1hZGUgYnkgc29tZSBvdGhlciBhY3Rvciwgbm90IHRoZSB1c2VyLiBUaGlzXG5pcyB1c2VkLCBmb3IgZXhhbXBsZSwgdG8gdGFnIG90aGVyIHBlb3BsZSdzIGNoYW5nZXMgaW5cbmNvbGxhYm9yYXRpdmUgZWRpdGluZy5cbiovXG5UcmFuc2FjdGlvbi5yZW1vdGUgPSAvKkBfX1BVUkVfXyovQW5ub3RhdGlvbi5kZWZpbmUoKTtcbmZ1bmN0aW9uIGpvaW5SYW5nZXMoYSwgYikge1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBpQSA9IDAsIGlCID0gMDs7KSB7XG4gICAgICAgIGxldCBmcm9tLCB0bztcbiAgICAgICAgaWYgKGlBIDwgYS5sZW5ndGggJiYgKGlCID09IGIubGVuZ3RoIHx8IGJbaUJdID49IGFbaUFdKSkge1xuICAgICAgICAgICAgZnJvbSA9IGFbaUErK107XG4gICAgICAgICAgICB0byA9IGFbaUErK107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaUIgPCBiLmxlbmd0aCkge1xuICAgICAgICAgICAgZnJvbSA9IGJbaUIrK107XG4gICAgICAgICAgICB0byA9IGJbaUIrK107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgaWYgKCFyZXN1bHQubGVuZ3RoIHx8IHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0gPCBmcm9tKVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goZnJvbSwgdG8pO1xuICAgICAgICBlbHNlIGlmIChyZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdIDwgdG8pXG4gICAgICAgICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdID0gdG87XG4gICAgfVxufVxuZnVuY3Rpb24gbWVyZ2VUcmFuc2FjdGlvbihhLCBiLCBzZXF1ZW50aWFsKSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCBtYXBGb3JBLCBtYXBGb3JCLCBjaGFuZ2VzO1xuICAgIGlmIChzZXF1ZW50aWFsKSB7XG4gICAgICAgIG1hcEZvckEgPSBiLmNoYW5nZXM7XG4gICAgICAgIG1hcEZvckIgPSBDaGFuZ2VTZXQuZW1wdHkoYi5jaGFuZ2VzLmxlbmd0aCk7XG4gICAgICAgIGNoYW5nZXMgPSBhLmNoYW5nZXMuY29tcG9zZShiLmNoYW5nZXMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbWFwRm9yQSA9IGIuY2hhbmdlcy5tYXAoYS5jaGFuZ2VzKTtcbiAgICAgICAgbWFwRm9yQiA9IGEuY2hhbmdlcy5tYXBEZXNjKGIuY2hhbmdlcywgdHJ1ZSk7XG4gICAgICAgIGNoYW5nZXMgPSBhLmNoYW5nZXMuY29tcG9zZShtYXBGb3JBKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY2hhbmdlcyxcbiAgICAgICAgc2VsZWN0aW9uOiBiLnNlbGVjdGlvbiA/IGIuc2VsZWN0aW9uLm1hcChtYXBGb3JCKSA6IChfYSA9IGEuc2VsZWN0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFwKG1hcEZvckEpLFxuICAgICAgICBlZmZlY3RzOiBTdGF0ZUVmZmVjdC5tYXBFZmZlY3RzKGEuZWZmZWN0cywgbWFwRm9yQSkuY29uY2F0KFN0YXRlRWZmZWN0Lm1hcEVmZmVjdHMoYi5lZmZlY3RzLCBtYXBGb3JCKSksXG4gICAgICAgIGFubm90YXRpb25zOiBhLmFubm90YXRpb25zLmxlbmd0aCA/IGEuYW5ub3RhdGlvbnMuY29uY2F0KGIuYW5ub3RhdGlvbnMpIDogYi5hbm5vdGF0aW9ucyxcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IGEuc2Nyb2xsSW50b1ZpZXcgfHwgYi5zY3JvbGxJbnRvVmlld1xuICAgIH07XG59XG5mdW5jdGlvbiByZXNvbHZlVHJhbnNhY3Rpb25Jbm5lcihzdGF0ZSwgc3BlYywgZG9jU2l6ZSkge1xuICAgIGxldCBzZWwgPSBzcGVjLnNlbGVjdGlvbiwgYW5ub3RhdGlvbnMgPSBhc0FycmF5KHNwZWMuYW5ub3RhdGlvbnMpO1xuICAgIGlmIChzcGVjLnVzZXJFdmVudClcbiAgICAgICAgYW5ub3RhdGlvbnMgPSBhbm5vdGF0aW9ucy5jb25jYXQoVHJhbnNhY3Rpb24udXNlckV2ZW50Lm9mKHNwZWMudXNlckV2ZW50KSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY2hhbmdlczogc3BlYy5jaGFuZ2VzIGluc3RhbmNlb2YgQ2hhbmdlU2V0ID8gc3BlYy5jaGFuZ2VzXG4gICAgICAgICAgICA6IENoYW5nZVNldC5vZihzcGVjLmNoYW5nZXMgfHwgW10sIGRvY1NpemUsIHN0YXRlLmZhY2V0KGxpbmVTZXBhcmF0b3IpKSxcbiAgICAgICAgc2VsZWN0aW9uOiBzZWwgJiYgKHNlbCBpbnN0YW5jZW9mIEVkaXRvclNlbGVjdGlvbiA/IHNlbCA6IEVkaXRvclNlbGVjdGlvbi5zaW5nbGUoc2VsLmFuY2hvciwgc2VsLmhlYWQpKSxcbiAgICAgICAgZWZmZWN0czogYXNBcnJheShzcGVjLmVmZmVjdHMpLFxuICAgICAgICBhbm5vdGF0aW9ucyxcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6ICEhc3BlYy5zY3JvbGxJbnRvVmlld1xuICAgIH07XG59XG5mdW5jdGlvbiByZXNvbHZlVHJhbnNhY3Rpb24oc3RhdGUsIHNwZWNzLCBmaWx0ZXIpIHtcbiAgICBsZXQgcyA9IHJlc29sdmVUcmFuc2FjdGlvbklubmVyKHN0YXRlLCBzcGVjcy5sZW5ndGggPyBzcGVjc1swXSA6IHt9LCBzdGF0ZS5kb2MubGVuZ3RoKTtcbiAgICBpZiAoc3BlY3MubGVuZ3RoICYmIHNwZWNzWzBdLmZpbHRlciA9PT0gZmFsc2UpXG4gICAgICAgIGZpbHRlciA9IGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgc3BlY3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHNwZWNzW2ldLmZpbHRlciA9PT0gZmFsc2UpXG4gICAgICAgICAgICBmaWx0ZXIgPSBmYWxzZTtcbiAgICAgICAgbGV0IHNlcSA9ICEhc3BlY3NbaV0uc2VxdWVudGlhbDtcbiAgICAgICAgcyA9IG1lcmdlVHJhbnNhY3Rpb24ocywgcmVzb2x2ZVRyYW5zYWN0aW9uSW5uZXIoc3RhdGUsIHNwZWNzW2ldLCBzZXEgPyBzLmNoYW5nZXMubmV3TGVuZ3RoIDogc3RhdGUuZG9jLmxlbmd0aCksIHNlcSk7XG4gICAgfVxuICAgIGxldCB0ciA9IFRyYW5zYWN0aW9uLmNyZWF0ZShzdGF0ZSwgcy5jaGFuZ2VzLCBzLnNlbGVjdGlvbiwgcy5lZmZlY3RzLCBzLmFubm90YXRpb25zLCBzLnNjcm9sbEludG9WaWV3KTtcbiAgICByZXR1cm4gZXh0ZW5kVHJhbnNhY3Rpb24oZmlsdGVyID8gZmlsdGVyVHJhbnNhY3Rpb24odHIpIDogdHIpO1xufVxuLy8gRmluaXNoIGEgdHJhbnNhY3Rpb24gYnkgYXBwbHlpbmcgZmlsdGVycyBpZiBuZWNlc3NhcnkuXG5mdW5jdGlvbiBmaWx0ZXJUcmFuc2FjdGlvbih0cikge1xuICAgIGxldCBzdGF0ZSA9IHRyLnN0YXJ0U3RhdGU7XG4gICAgLy8gQ2hhbmdlIGZpbHRlcnNcbiAgICBsZXQgcmVzdWx0ID0gdHJ1ZTtcbiAgICBmb3IgKGxldCBmaWx0ZXIgb2Ygc3RhdGUuZmFjZXQoY2hhbmdlRmlsdGVyKSkge1xuICAgICAgICBsZXQgdmFsdWUgPSBmaWx0ZXIodHIpO1xuICAgICAgICBpZiAodmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSlcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdCA9PT0gdHJ1ZSA/IHZhbHVlIDogam9pblJhbmdlcyhyZXN1bHQsIHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKHJlc3VsdCAhPT0gdHJ1ZSkge1xuICAgICAgICBsZXQgY2hhbmdlcywgYmFjaztcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGJhY2sgPSB0ci5jaGFuZ2VzLmludmVydGVkRGVzYztcbiAgICAgICAgICAgIGNoYW5nZXMgPSBDaGFuZ2VTZXQuZW1wdHkoc3RhdGUuZG9jLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgZmlsdGVyZWQgPSB0ci5jaGFuZ2VzLmZpbHRlcihyZXN1bHQpO1xuICAgICAgICAgICAgY2hhbmdlcyA9IGZpbHRlcmVkLmNoYW5nZXM7XG4gICAgICAgICAgICBiYWNrID0gZmlsdGVyZWQuZmlsdGVyZWQubWFwRGVzYyhmaWx0ZXJlZC5jaGFuZ2VzKS5pbnZlcnRlZERlc2M7XG4gICAgICAgIH1cbiAgICAgICAgdHIgPSBUcmFuc2FjdGlvbi5jcmVhdGUoc3RhdGUsIGNoYW5nZXMsIHRyLnNlbGVjdGlvbiAmJiB0ci5zZWxlY3Rpb24ubWFwKGJhY2spLCBTdGF0ZUVmZmVjdC5tYXBFZmZlY3RzKHRyLmVmZmVjdHMsIGJhY2spLCB0ci5hbm5vdGF0aW9ucywgdHIuc2Nyb2xsSW50b1ZpZXcpO1xuICAgIH1cbiAgICAvLyBUcmFuc2FjdGlvbiBmaWx0ZXJzXG4gICAgbGV0IGZpbHRlcnMgPSBzdGF0ZS5mYWNldCh0cmFuc2FjdGlvbkZpbHRlcik7XG4gICAgZm9yIChsZXQgaSA9IGZpbHRlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgbGV0IGZpbHRlcmVkID0gZmlsdGVyc1tpXSh0cik7XG4gICAgICAgIGlmIChmaWx0ZXJlZCBpbnN0YW5jZW9mIFRyYW5zYWN0aW9uKVxuICAgICAgICAgICAgdHIgPSBmaWx0ZXJlZDtcbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShmaWx0ZXJlZCkgJiYgZmlsdGVyZWQubGVuZ3RoID09IDEgJiYgZmlsdGVyZWRbMF0gaW5zdGFuY2VvZiBUcmFuc2FjdGlvbilcbiAgICAgICAgICAgIHRyID0gZmlsdGVyZWRbMF07XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRyID0gcmVzb2x2ZVRyYW5zYWN0aW9uKHN0YXRlLCBhc0FycmF5KGZpbHRlcmVkKSwgZmFsc2UpO1xuICAgIH1cbiAgICByZXR1cm4gdHI7XG59XG5mdW5jdGlvbiBleHRlbmRUcmFuc2FjdGlvbih0cikge1xuICAgIGxldCBzdGF0ZSA9IHRyLnN0YXJ0U3RhdGUsIGV4dGVuZGVycyA9IHN0YXRlLmZhY2V0KHRyYW5zYWN0aW9uRXh0ZW5kZXIpLCBzcGVjID0gdHI7XG4gICAgZm9yIChsZXQgaSA9IGV4dGVuZGVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBsZXQgZXh0ZW5zaW9uID0gZXh0ZW5kZXJzW2ldKHRyKTtcbiAgICAgICAgaWYgKGV4dGVuc2lvbiAmJiBPYmplY3Qua2V5cyhleHRlbnNpb24pLmxlbmd0aClcbiAgICAgICAgICAgIHNwZWMgPSBtZXJnZVRyYW5zYWN0aW9uKHNwZWMsIHJlc29sdmVUcmFuc2FjdGlvbklubmVyKHN0YXRlLCBleHRlbnNpb24sIHRyLmNoYW5nZXMubmV3TGVuZ3RoKSwgdHJ1ZSk7XG4gICAgfVxuICAgIHJldHVybiBzcGVjID09IHRyID8gdHIgOiBUcmFuc2FjdGlvbi5jcmVhdGUoc3RhdGUsIHRyLmNoYW5nZXMsIHRyLnNlbGVjdGlvbiwgc3BlYy5lZmZlY3RzLCBzcGVjLmFubm90YXRpb25zLCBzcGVjLnNjcm9sbEludG9WaWV3KTtcbn1cbmNvbnN0IG5vbmUgPSBbXTtcbmZ1bmN0aW9uIGFzQXJyYXkodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/IG5vbmUgOiBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW3ZhbHVlXTtcbn1cblxuLyoqXG5UaGUgY2F0ZWdvcmllcyBwcm9kdWNlZCBieSBhIFtjaGFyYWN0ZXJcbmNhdGVnb3JpemVyXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLmNoYXJDYXRlZ29yaXplcikuIFRoZXNlIGFyZSB1c2VkXG5kbyB0aGluZ3MgbGlrZSBzZWxlY3RpbmcgYnkgd29yZC5cbiovXG52YXIgQ2hhckNhdGVnb3J5ID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoQ2hhckNhdGVnb3J5KSB7XG4gICAgLyoqXG4gICAgV29yZCBjaGFyYWN0ZXJzLlxuICAgICovXG4gICAgQ2hhckNhdGVnb3J5W0NoYXJDYXRlZ29yeVtcIldvcmRcIl0gPSAwXSA9IFwiV29yZFwiO1xuICAgIC8qKlxuICAgIFdoaXRlc3BhY2UuXG4gICAgKi9cbiAgICBDaGFyQ2F0ZWdvcnlbQ2hhckNhdGVnb3J5W1wiU3BhY2VcIl0gPSAxXSA9IFwiU3BhY2VcIjtcbiAgICAvKipcbiAgICBBbnl0aGluZyBlbHNlLlxuICAgICovXG4gICAgQ2hhckNhdGVnb3J5W0NoYXJDYXRlZ29yeVtcIk90aGVyXCJdID0gMl0gPSBcIk90aGVyXCI7XG5yZXR1cm4gQ2hhckNhdGVnb3J5fSkoQ2hhckNhdGVnb3J5IHx8IChDaGFyQ2F0ZWdvcnkgPSB7fSkpO1xuY29uc3Qgbm9uQVNDSUlTaW5nbGVDYXNlV29yZENoYXIgPSAvW1xcdTAwZGZcXHUwNTg3XFx1MDU5MC1cXHUwNWY0XFx1MDYwMC1cXHUwNmZmXFx1MzA0MC1cXHUzMDlmXFx1MzBhMC1cXHUzMGZmXFx1MzQwMC1cXHU0ZGI1XFx1NGUwMC1cXHU5ZmNjXFx1YWMwMC1cXHVkN2FmXS87XG5sZXQgd29yZENoYXI7XG50cnkge1xuICAgIHdvcmRDaGFyID0gLypAX19QVVJFX18qL25ldyBSZWdFeHAoXCJbXFxcXHB7QWxwaGFiZXRpY31cXFxccHtOdW1iZXJ9X11cIiwgXCJ1XCIpO1xufVxuY2F0Y2ggKF8pIHsgfVxuZnVuY3Rpb24gaGFzV29yZENoYXIoc3RyKSB7XG4gICAgaWYgKHdvcmRDaGFyKVxuICAgICAgICByZXR1cm4gd29yZENoYXIudGVzdChzdHIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBjaCA9IHN0cltpXTtcbiAgICAgICAgaWYgKC9cXHcvLnRlc3QoY2gpIHx8IGNoID4gXCJcXHg4MFwiICYmIChjaC50b1VwcGVyQ2FzZSgpICE9IGNoLnRvTG93ZXJDYXNlKCkgfHwgbm9uQVNDSUlTaW5nbGVDYXNlV29yZENoYXIudGVzdChjaCkpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIG1ha2VDYXRlZ29yaXplcih3b3JkQ2hhcnMpIHtcbiAgICByZXR1cm4gKGNoYXIpID0+IHtcbiAgICAgICAgaWYgKCEvXFxTLy50ZXN0KGNoYXIpKVxuICAgICAgICAgICAgcmV0dXJuIENoYXJDYXRlZ29yeS5TcGFjZTtcbiAgICAgICAgaWYgKGhhc1dvcmRDaGFyKGNoYXIpKVxuICAgICAgICAgICAgcmV0dXJuIENoYXJDYXRlZ29yeS5Xb3JkO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdvcmRDaGFycy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmIChjaGFyLmluZGV4T2Yod29yZENoYXJzW2ldKSA+IC0xKVxuICAgICAgICAgICAgICAgIHJldHVybiBDaGFyQ2F0ZWdvcnkuV29yZDtcbiAgICAgICAgcmV0dXJuIENoYXJDYXRlZ29yeS5PdGhlcjtcbiAgICB9O1xufVxuXG4vKipcblRoZSBlZGl0b3Igc3RhdGUgY2xhc3MgaXMgYSBwZXJzaXN0ZW50IChpbW11dGFibGUpIGRhdGEgc3RydWN0dXJlLlxuVG8gdXBkYXRlIGEgc3RhdGUsIHlvdSBbY3JlYXRlXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLnVwZGF0ZSkgYVxuW3RyYW5zYWN0aW9uXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uKSwgd2hpY2ggcHJvZHVjZXMgYSBfbmV3XyBzdGF0ZVxuaW5zdGFuY2UsIHdpdGhvdXQgbW9kaWZ5aW5nIHRoZSBvcmlnaW5hbCBvYmplY3QuXG5cbkFzIHN1Y2gsIF9uZXZlcl8gbXV0YXRlIHByb3BlcnRpZXMgb2YgYSBzdGF0ZSBkaXJlY3RseS4gVGhhdCdsbFxuanVzdCBicmVhayB0aGluZ3MuXG4qL1xuY2xhc3MgRWRpdG9yU3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uZmlnLCBcbiAgICAvKipcbiAgICBUaGUgY3VycmVudCBkb2N1bWVudC5cbiAgICAqL1xuICAgIGRvYywgXG4gICAgLyoqXG4gICAgVGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxuICAgICovXG4gICAgc2VsZWN0aW9uLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHZhbHVlcywgY29tcHV0ZVNsb3QsIHRyKSB7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICB0aGlzLmRvYyA9IGRvYztcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSBzZWxlY3Rpb247XG4gICAgICAgIHRoaXMudmFsdWVzID0gdmFsdWVzO1xuICAgICAgICB0aGlzLnN0YXR1cyA9IGNvbmZpZy5zdGF0dXNUZW1wbGF0ZS5zbGljZSgpO1xuICAgICAgICB0aGlzLmNvbXB1dGVTbG90ID0gY29tcHV0ZVNsb3Q7XG4gICAgICAgIC8vIEZpbGwgaW4gdGhlIGNvbXB1dGVkIHN0YXRlIGltbWVkaWF0ZWx5LCBzbyB0aGF0IGZ1cnRoZXIgcXVlcmllc1xuICAgICAgICAvLyBmb3IgaXQgbWFkZSBkdXJpbmcgdGhlIHVwZGF0ZSByZXR1cm4gdGhpcyBzdGF0ZVxuICAgICAgICBpZiAodHIpXG4gICAgICAgICAgICB0ci5fc3RhdGUgPSB0aGlzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY29uZmlnLmR5bmFtaWNTbG90cy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGVuc3VyZUFkZHIodGhpcywgaSA8PCAxKTtcbiAgICAgICAgdGhpcy5jb21wdXRlU2xvdCA9IG51bGw7XG4gICAgfVxuICAgIGZpZWxkKGZpZWxkLCByZXF1aXJlID0gdHJ1ZSkge1xuICAgICAgICBsZXQgYWRkciA9IHRoaXMuY29uZmlnLmFkZHJlc3NbZmllbGQuaWRdO1xuICAgICAgICBpZiAoYWRkciA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAocmVxdWlyZSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkZpZWxkIGlzIG5vdCBwcmVzZW50IGluIHRoaXMgc3RhdGVcIik7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVuc3VyZUFkZHIodGhpcywgYWRkcik7XG4gICAgICAgIHJldHVybiBnZXRBZGRyKHRoaXMsIGFkZHIpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBbdHJhbnNhY3Rpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb24pIHRoYXQgdXBkYXRlcyB0aGlzXG4gICAgc3RhdGUuIEFueSBudW1iZXIgb2YgW3RyYW5zYWN0aW9uIHNwZWNzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYylcbiAgICBjYW4gYmUgcGFzc2VkLiBVbmxlc3NcbiAgICBbYHNlcXVlbnRpYWxgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYy5zZXF1ZW50aWFsKSBpcyBzZXQsIHRoZVxuICAgIFtjaGFuZ2VzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYy5jaGFuZ2VzKSAoaWYgYW55KSBvZiBlYWNoIHNwZWNcbiAgICBhcmUgYXNzdW1lZCB0byBzdGFydCBpbiB0aGUgX2N1cnJlbnRfIGRvY3VtZW50IChub3QgdGhlIGRvY3VtZW50XG4gICAgcHJvZHVjZWQgYnkgcHJldmlvdXMgc3BlY3MpLCBhbmQgaXRzXG4gICAgW3NlbGVjdGlvbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMuc2VsZWN0aW9uKSBhbmRcbiAgICBbZWZmZWN0c10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMuZWZmZWN0cykgYXJlIGFzc3VtZWQgdG8gcmVmZXJcbiAgICB0byB0aGUgZG9jdW1lbnQgY3JlYXRlZCBieSBpdHMgX293bl8gY2hhbmdlcy4gVGhlIHJlc3VsdGluZ1xuICAgIHRyYW5zYWN0aW9uIGNvbnRhaW5zIHRoZSBjb21iaW5lZCBlZmZlY3Qgb2YgYWxsIHRoZSBkaWZmZXJlbnRcbiAgICBzcGVjcy4gRm9yIFtzZWxlY3Rpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjLnNlbGVjdGlvbiksIGxhdGVyXG4gICAgc3BlY3MgdGFrZSBwcmVjZWRlbmNlIG92ZXIgZWFybGllciBvbmVzLlxuICAgICovXG4gICAgdXBkYXRlKC4uLnNwZWNzKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlVHJhbnNhY3Rpb24odGhpcywgc3BlY3MsIHRydWUpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGFwcGx5VHJhbnNhY3Rpb24odHIpIHtcbiAgICAgICAgbGV0IGNvbmYgPSB0aGlzLmNvbmZpZywgeyBiYXNlLCBjb21wYXJ0bWVudHMgfSA9IGNvbmY7XG4gICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiB0ci5lZmZlY3RzKSB7XG4gICAgICAgICAgICBpZiAoZWZmZWN0LmlzKENvbXBhcnRtZW50LnJlY29uZmlndXJlKSkge1xuICAgICAgICAgICAgICAgIGlmIChjb25mKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBhcnRtZW50cyA9IG5ldyBNYXA7XG4gICAgICAgICAgICAgICAgICAgIGNvbmYuY29tcGFydG1lbnRzLmZvckVhY2goKHZhbCwga2V5KSA9PiBjb21wYXJ0bWVudHMuc2V0KGtleSwgdmFsKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbmYgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb21wYXJ0bWVudHMuc2V0KGVmZmVjdC52YWx1ZS5jb21wYXJ0bWVudCwgZWZmZWN0LnZhbHVlLmV4dGVuc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlZmZlY3QuaXMoU3RhdGVFZmZlY3QucmVjb25maWd1cmUpKSB7XG4gICAgICAgICAgICAgICAgY29uZiA9IG51bGw7XG4gICAgICAgICAgICAgICAgYmFzZSA9IGVmZmVjdC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGVmZmVjdC5pcyhTdGF0ZUVmZmVjdC5hcHBlbmRDb25maWcpKSB7XG4gICAgICAgICAgICAgICAgY29uZiA9IG51bGw7XG4gICAgICAgICAgICAgICAgYmFzZSA9IGFzQXJyYXkoYmFzZSkuY29uY2F0KGVmZmVjdC52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0YXJ0VmFsdWVzO1xuICAgICAgICBpZiAoIWNvbmYpIHtcbiAgICAgICAgICAgIGNvbmYgPSBDb25maWd1cmF0aW9uLnJlc29sdmUoYmFzZSwgY29tcGFydG1lbnRzLCB0aGlzKTtcbiAgICAgICAgICAgIGxldCBpbnRlcm1lZGlhdGVTdGF0ZSA9IG5ldyBFZGl0b3JTdGF0ZShjb25mLCB0aGlzLmRvYywgdGhpcy5zZWxlY3Rpb24sIGNvbmYuZHluYW1pY1Nsb3RzLm1hcCgoKSA9PiBudWxsKSwgKHN0YXRlLCBzbG90KSA9PiBzbG90LnJlY29uZmlndXJlKHN0YXRlLCB0aGlzKSwgbnVsbCk7XG4gICAgICAgICAgICBzdGFydFZhbHVlcyA9IGludGVybWVkaWF0ZVN0YXRlLnZhbHVlcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXJ0VmFsdWVzID0gdHIuc3RhcnRTdGF0ZS52YWx1ZXMuc2xpY2UoKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc2VsZWN0aW9uID0gdHIuc3RhcnRTdGF0ZS5mYWNldChhbGxvd011bHRpcGxlU2VsZWN0aW9ucykgPyB0ci5uZXdTZWxlY3Rpb24gOiB0ci5uZXdTZWxlY3Rpb24uYXNTaW5nbGUoKTtcbiAgICAgICAgbmV3IEVkaXRvclN0YXRlKGNvbmYsIHRyLm5ld0RvYywgc2VsZWN0aW9uLCBzdGFydFZhbHVlcywgKHN0YXRlLCBzbG90KSA9PiBzbG90LnVwZGF0ZShzdGF0ZSwgdHIpLCB0cik7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIFt0cmFuc2FjdGlvbiBzcGVjXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYykgdGhhdFxuICAgIHJlcGxhY2VzIGV2ZXJ5IHNlbGVjdGlvbiByYW5nZSB3aXRoIHRoZSBnaXZlbiBjb250ZW50LlxuICAgICovXG4gICAgcmVwbGFjZVNlbGVjdGlvbih0ZXh0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGV4dCA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgdGV4dCA9IHRoaXMudG9UZXh0KHRleHQpO1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+ICh7IGNoYW5nZXM6IHsgZnJvbTogcmFuZ2UuZnJvbSwgdG86IHJhbmdlLnRvLCBpbnNlcnQ6IHRleHQgfSxcbiAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHJhbmdlLmZyb20gKyB0ZXh0Lmxlbmd0aCkgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBzZXQgb2YgY2hhbmdlcyBhbmQgYSBuZXcgc2VsZWN0aW9uIGJ5IHJ1bm5pbmcgdGhlIGdpdmVuXG4gICAgZnVuY3Rpb24gZm9yIGVhY2ggcmFuZ2UgaW4gdGhlIGFjdGl2ZSBzZWxlY3Rpb24uIFRoZSBmdW5jdGlvblxuICAgIGNhbiByZXR1cm4gYW4gb3B0aW9uYWwgc2V0IG9mIGNoYW5nZXMgKGluIHRoZSBjb29yZGluYXRlIHNwYWNlXG4gICAgb2YgdGhlIHN0YXJ0IGRvY3VtZW50KSwgcGx1cyBhbiB1cGRhdGVkIHJhbmdlIChpbiB0aGUgY29vcmRpbmF0ZVxuICAgIHNwYWNlIG9mIHRoZSBkb2N1bWVudCBwcm9kdWNlZCBieSB0aGUgY2FsbCdzIG93biBjaGFuZ2VzKS4gVGhpc1xuICAgIG1ldGhvZCB3aWxsIG1lcmdlIGFsbCB0aGUgY2hhbmdlcyBhbmQgcmFuZ2VzIGludG8gYSBzaW5nbGVcbiAgICBjaGFuZ2VzZXQgYW5kIHNlbGVjdGlvbiwgYW5kIHJldHVybiBpdCBhcyBhIFt0cmFuc2FjdGlvblxuICAgIHNwZWNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjKSwgd2hpY2ggY2FuIGJlIHBhc3NlZCB0b1xuICAgIFtgdXBkYXRlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS51cGRhdGUpLlxuICAgICovXG4gICAgY2hhbmdlQnlSYW5nZShmKSB7XG4gICAgICAgIGxldCBzZWwgPSB0aGlzLnNlbGVjdGlvbjtcbiAgICAgICAgbGV0IHJlc3VsdDEgPSBmKHNlbC5yYW5nZXNbMF0pO1xuICAgICAgICBsZXQgY2hhbmdlcyA9IHRoaXMuY2hhbmdlcyhyZXN1bHQxLmNoYW5nZXMpLCByYW5nZXMgPSBbcmVzdWx0MS5yYW5nZV07XG4gICAgICAgIGxldCBlZmZlY3RzID0gYXNBcnJheShyZXN1bHQxLmVmZmVjdHMpO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHNlbC5yYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBmKHNlbC5yYW5nZXNbaV0pO1xuICAgICAgICAgICAgbGV0IG5ld0NoYW5nZXMgPSB0aGlzLmNoYW5nZXMocmVzdWx0LmNoYW5nZXMpLCBuZXdNYXBwZWQgPSBuZXdDaGFuZ2VzLm1hcChjaGFuZ2VzKTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgaTsgaisrKVxuICAgICAgICAgICAgICAgIHJhbmdlc1tqXSA9IHJhbmdlc1tqXS5tYXAobmV3TWFwcGVkKTtcbiAgICAgICAgICAgIGxldCBtYXBCeSA9IGNoYW5nZXMubWFwRGVzYyhuZXdDaGFuZ2VzLCB0cnVlKTtcbiAgICAgICAgICAgIHJhbmdlcy5wdXNoKHJlc3VsdC5yYW5nZS5tYXAobWFwQnkpKTtcbiAgICAgICAgICAgIGNoYW5nZXMgPSBjaGFuZ2VzLmNvbXBvc2UobmV3TWFwcGVkKTtcbiAgICAgICAgICAgIGVmZmVjdHMgPSBTdGF0ZUVmZmVjdC5tYXBFZmZlY3RzKGVmZmVjdHMsIG5ld01hcHBlZCkuY29uY2F0KFN0YXRlRWZmZWN0Lm1hcEVmZmVjdHMoYXNBcnJheShyZXN1bHQuZWZmZWN0cyksIG1hcEJ5KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNoYW5nZXMsXG4gICAgICAgICAgICBzZWxlY3Rpb246IEVkaXRvclNlbGVjdGlvbi5jcmVhdGUocmFuZ2VzLCBzZWwubWFpbkluZGV4KSxcbiAgICAgICAgICAgIGVmZmVjdHNcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgW2NoYW5nZSBzZXRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuQ2hhbmdlU2V0KSBmcm9tIHRoZSBnaXZlbiBjaGFuZ2VcbiAgICBkZXNjcmlwdGlvbiwgdGFraW5nIHRoZSBzdGF0ZSdzIGRvY3VtZW50IGxlbmd0aCBhbmQgbGluZVxuICAgIHNlcGFyYXRvciBpbnRvIGFjY291bnQuXG4gICAgKi9cbiAgICBjaGFuZ2VzKHNwZWMgPSBbXSkge1xuICAgICAgICBpZiAoc3BlYyBpbnN0YW5jZW9mIENoYW5nZVNldClcbiAgICAgICAgICAgIHJldHVybiBzcGVjO1xuICAgICAgICByZXR1cm4gQ2hhbmdlU2V0Lm9mKHNwZWMsIHRoaXMuZG9jLmxlbmd0aCwgdGhpcy5mYWNldChFZGl0b3JTdGF0ZS5saW5lU2VwYXJhdG9yKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFVzaW5nIHRoZSBzdGF0ZSdzIFtsaW5lXG4gICAgc2VwYXJhdG9yXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlXmxpbmVTZXBhcmF0b3IpLCBjcmVhdGUgYVxuICAgIFtgVGV4dGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVGV4dCkgaW5zdGFuY2UgZnJvbSB0aGUgZ2l2ZW4gc3RyaW5nLlxuICAgICovXG4gICAgdG9UZXh0KHN0cmluZykge1xuICAgICAgICByZXR1cm4gVGV4dC5vZihzdHJpbmcuc3BsaXQodGhpcy5mYWNldChFZGl0b3JTdGF0ZS5saW5lU2VwYXJhdG9yKSB8fCBEZWZhdWx0U3BsaXQpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJuIHRoZSBnaXZlbiByYW5nZSBvZiB0aGUgZG9jdW1lbnQgYXMgYSBzdHJpbmcuXG4gICAgKi9cbiAgICBzbGljZURvYyhmcm9tID0gMCwgdG8gPSB0aGlzLmRvYy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jLnNsaWNlU3RyaW5nKGZyb20sIHRvLCB0aGlzLmxpbmVCcmVhayk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgdmFsdWUgb2YgYSBzdGF0ZSBbZmFjZXRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRmFjZXQpLlxuICAgICovXG4gICAgZmFjZXQoZmFjZXQpIHtcbiAgICAgICAgbGV0IGFkZHIgPSB0aGlzLmNvbmZpZy5hZGRyZXNzW2ZhY2V0LmlkXTtcbiAgICAgICAgaWYgKGFkZHIgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBmYWNldC5kZWZhdWx0O1xuICAgICAgICBlbnN1cmVBZGRyKHRoaXMsIGFkZHIpO1xuICAgICAgICByZXR1cm4gZ2V0QWRkcih0aGlzLCBhZGRyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29udmVydCB0aGlzIHN0YXRlIHRvIGEgSlNPTi1zZXJpYWxpemFibGUgb2JqZWN0LiBXaGVuIGN1c3RvbVxuICAgIGZpZWxkcyBzaG91bGQgYmUgc2VyaWFsaXplZCwgeW91IGNhbiBwYXNzIHRoZW0gaW4gYXMgYW4gb2JqZWN0XG4gICAgbWFwcGluZyBwcm9wZXJ0eSBuYW1lcyAoaW4gdGhlIHJlc3VsdGluZyBvYmplY3QsIHdoaWNoIHNob3VsZFxuICAgIG5vdCB1c2UgYGRvY2Agb3IgYHNlbGVjdGlvbmApIHRvIGZpZWxkcy5cbiAgICAqL1xuICAgIHRvSlNPTihmaWVsZHMpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgIGRvYzogdGhpcy5zbGljZURvYygpLFxuICAgICAgICAgICAgc2VsZWN0aW9uOiB0aGlzLnNlbGVjdGlvbi50b0pTT04oKVxuICAgICAgICB9O1xuICAgICAgICBpZiAoZmllbGRzKVxuICAgICAgICAgICAgZm9yIChsZXQgcHJvcCBpbiBmaWVsZHMpIHtcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSBmaWVsZHNbcHJvcF07XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgU3RhdGVGaWVsZCAmJiB0aGlzLmNvbmZpZy5hZGRyZXNzW3ZhbHVlLmlkXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICByZXN1bHRbcHJvcF0gPSB2YWx1ZS5zcGVjLnRvSlNPTih0aGlzLmZpZWxkKGZpZWxkc1twcm9wXSksIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICBEZXNlcmlhbGl6ZSBhIHN0YXRlIGZyb20gaXRzIEpTT04gcmVwcmVzZW50YXRpb24uIFdoZW4gY3VzdG9tXG4gICAgZmllbGRzIHNob3VsZCBiZSBkZXNlcmlhbGl6ZWQsIHBhc3MgdGhlIHNhbWUgb2JqZWN0IHlvdSBwYXNzZWRcbiAgICB0byBbYHRvSlNPTmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUudG9KU09OKSB3aGVuIHNlcmlhbGl6aW5nIGFzXG4gICAgdGhpcmQgYXJndW1lbnQuXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oanNvbiwgY29uZmlnID0ge30sIGZpZWxkcykge1xuICAgICAgICBpZiAoIWpzb24gfHwgdHlwZW9mIGpzb24uZG9jICE9IFwic3RyaW5nXCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgSlNPTiByZXByZXNlbnRhdGlvbiBmb3IgRWRpdG9yU3RhdGVcIik7XG4gICAgICAgIGxldCBmaWVsZEluaXQgPSBbXTtcbiAgICAgICAgaWYgKGZpZWxkcylcbiAgICAgICAgICAgIGZvciAobGV0IHByb3AgaW4gZmllbGRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChqc29uLCBwcm9wKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZmllbGQgPSBmaWVsZHNbcHJvcF0sIHZhbHVlID0ganNvbltwcm9wXTtcbiAgICAgICAgICAgICAgICAgICAgZmllbGRJbml0LnB1c2goZmllbGQuaW5pdChzdGF0ZSA9PiBmaWVsZC5zcGVjLmZyb21KU09OKHZhbHVlLCBzdGF0ZSkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiBFZGl0b3JTdGF0ZS5jcmVhdGUoe1xuICAgICAgICAgICAgZG9jOiBqc29uLmRvYyxcbiAgICAgICAgICAgIHNlbGVjdGlvbjogRWRpdG9yU2VsZWN0aW9uLmZyb21KU09OKGpzb24uc2VsZWN0aW9uKSxcbiAgICAgICAgICAgIGV4dGVuc2lvbnM6IGNvbmZpZy5leHRlbnNpb25zID8gZmllbGRJbml0LmNvbmNhdChbY29uZmlnLmV4dGVuc2lvbnNdKSA6IGZpZWxkSW5pdFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbmV3IHN0YXRlLiBZb3UnbGwgdXN1YWxseSBvbmx5IG5lZWQgdGhpcyB3aGVuXG4gICAgaW5pdGlhbGl6aW5nIGFuIGVkaXRvcuKAlHVwZGF0ZWQgc3RhdGVzIGFyZSBjcmVhdGVkIGJ5IGFwcGx5aW5nXG4gICAgdHJhbnNhY3Rpb25zLlxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShjb25maWcgPSB7fSkge1xuICAgICAgICBsZXQgY29uZmlndXJhdGlvbiA9IENvbmZpZ3VyYXRpb24ucmVzb2x2ZShjb25maWcuZXh0ZW5zaW9ucyB8fCBbXSwgbmV3IE1hcCk7XG4gICAgICAgIGxldCBkb2MgPSBjb25maWcuZG9jIGluc3RhbmNlb2YgVGV4dCA/IGNvbmZpZy5kb2NcbiAgICAgICAgICAgIDogVGV4dC5vZigoY29uZmlnLmRvYyB8fCBcIlwiKS5zcGxpdChjb25maWd1cmF0aW9uLnN0YXRpY0ZhY2V0KEVkaXRvclN0YXRlLmxpbmVTZXBhcmF0b3IpIHx8IERlZmF1bHRTcGxpdCkpO1xuICAgICAgICBsZXQgc2VsZWN0aW9uID0gIWNvbmZpZy5zZWxlY3Rpb24gPyBFZGl0b3JTZWxlY3Rpb24uc2luZ2xlKDApXG4gICAgICAgICAgICA6IGNvbmZpZy5zZWxlY3Rpb24gaW5zdGFuY2VvZiBFZGl0b3JTZWxlY3Rpb24gPyBjb25maWcuc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgOiBFZGl0b3JTZWxlY3Rpb24uc2luZ2xlKGNvbmZpZy5zZWxlY3Rpb24uYW5jaG9yLCBjb25maWcuc2VsZWN0aW9uLmhlYWQpO1xuICAgICAgICBjaGVja1NlbGVjdGlvbihzZWxlY3Rpb24sIGRvYy5sZW5ndGgpO1xuICAgICAgICBpZiAoIWNvbmZpZ3VyYXRpb24uc3RhdGljRmFjZXQoYWxsb3dNdWx0aXBsZVNlbGVjdGlvbnMpKVxuICAgICAgICAgICAgc2VsZWN0aW9uID0gc2VsZWN0aW9uLmFzU2luZ2xlKCk7XG4gICAgICAgIHJldHVybiBuZXcgRWRpdG9yU3RhdGUoY29uZmlndXJhdGlvbiwgZG9jLCBzZWxlY3Rpb24sIGNvbmZpZ3VyYXRpb24uZHluYW1pY1Nsb3RzLm1hcCgoKSA9PiBudWxsKSwgKHN0YXRlLCBzbG90KSA9PiBzbG90LmNyZWF0ZShzdGF0ZSksIG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgc2l6ZSAoaW4gY29sdW1ucykgb2YgYSB0YWIgaW4gdGhlIGRvY3VtZW50LCBkZXRlcm1pbmVkIGJ5XG4gICAgdGhlIFtgdGFiU2l6ZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVedGFiU2l6ZSkgZmFjZXQuXG4gICAgKi9cbiAgICBnZXQgdGFiU2l6ZSgpIHsgcmV0dXJuIHRoaXMuZmFjZXQoRWRpdG9yU3RhdGUudGFiU2l6ZSk7IH1cbiAgICAvKipcbiAgICBHZXQgdGhlIHByb3BlciBbbGluZS1icmVha10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV5saW5lU2VwYXJhdG9yKVxuICAgIHN0cmluZyBmb3IgdGhpcyBzdGF0ZS5cbiAgICAqL1xuICAgIGdldCBsaW5lQnJlYWsoKSB7IHJldHVybiB0aGlzLmZhY2V0KEVkaXRvclN0YXRlLmxpbmVTZXBhcmF0b3IpIHx8IFwiXFxuXCI7IH1cbiAgICAvKipcbiAgICBSZXR1cm5zIHRydWUgd2hlbiB0aGUgZWRpdG9yIGlzXG4gICAgW2NvbmZpZ3VyZWRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVecmVhZE9ubHkpIHRvIGJlIHJlYWQtb25seS5cbiAgICAqL1xuICAgIGdldCByZWFkT25seSgpIHsgcmV0dXJuIHRoaXMuZmFjZXQocmVhZE9ubHkpOyB9XG4gICAgLyoqXG4gICAgTG9vayB1cCBhIHRyYW5zbGF0aW9uIGZvciB0aGUgZ2l2ZW4gcGhyYXNlICh2aWEgdGhlXG4gICAgW2BwaHJhc2VzYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV5waHJhc2VzKSBmYWNldCksIG9yIHJldHVybiB0aGVcbiAgICBvcmlnaW5hbCBzdHJpbmcgaWYgbm8gdHJhbnNsYXRpb24gaXMgZm91bmQuXG4gICAgXG4gICAgSWYgYWRkaXRpb25hbCBhcmd1bWVudHMgYXJlIHBhc3NlZCwgdGhleSB3aWxsIGJlIGluc2VydGVkIGluXG4gICAgcGxhY2Ugb2YgbWFya2VycyBsaWtlIGAkMWAgKGZvciB0aGUgZmlyc3QgdmFsdWUpIGFuZCBgJDJgLCBldGMuXG4gICAgQSBzaW5nbGUgYCRgIGlzIGVxdWl2YWxlbnQgdG8gYCQxYCwgYW5kIGAkJGAgd2lsbCBwcm9kdWNlIGFcbiAgICBsaXRlcmFsIGRvbGxhciBzaWduLlxuICAgICovXG4gICAgcGhyYXNlKHBocmFzZSwgLi4uaW5zZXJ0KSB7XG4gICAgICAgIGZvciAobGV0IG1hcCBvZiB0aGlzLmZhY2V0KEVkaXRvclN0YXRlLnBocmFzZXMpKVxuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtYXAsIHBocmFzZSkpIHtcbiAgICAgICAgICAgICAgICBwaHJhc2UgPSBtYXBbcGhyYXNlXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgaWYgKGluc2VydC5sZW5ndGgpXG4gICAgICAgICAgICBwaHJhc2UgPSBwaHJhc2UucmVwbGFjZSgvXFwkKFxcJHxcXGQqKS9nLCAobSwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpID09IFwiJFwiKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCIkXCI7XG4gICAgICAgICAgICAgICAgbGV0IG4gPSArKGkgfHwgMSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFuIHx8IG4gPiBpbnNlcnQubGVuZ3RoID8gbSA6IGluc2VydFtuIC0gMV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBocmFzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgdmFsdWVzIGZvciBhIGdpdmVuIGxhbmd1YWdlIGRhdGEgZmllbGQsIHByb3ZpZGVkIGJ5IHRoZVxuICAgIHRoZSBbYGxhbmd1YWdlRGF0YWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVebGFuZ3VhZ2VEYXRhKSBmYWNldC5cbiAgICBcbiAgICBFeGFtcGxlcyBvZiBsYW5ndWFnZSBkYXRhIGZpZWxkcyBhcmUuLi5cbiAgICBcbiAgICAtIFtgXCJjb21tZW50VG9rZW5zXCJgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLkNvbW1lbnRUb2tlbnMpIGZvciBzcGVjaWZ5aW5nXG4gICAgICBjb21tZW50IHN5bnRheC5cbiAgICAtIFtgXCJhdXRvY29tcGxldGVcImBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLmF1dG9jb21wbGV0aW9uXmNvbmZpZy5vdmVycmlkZSlcbiAgICAgIGZvciBwcm92aWRpbmcgbGFuZ3VhZ2Utc3BlY2lmaWMgY29tcGxldGlvbiBzb3VyY2VzLlxuICAgIC0gW2BcIndvcmRDaGFyc1wiYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5jaGFyQ2F0ZWdvcml6ZXIpIGZvciBhZGRpbmdcbiAgICAgIGNoYXJhY3RlcnMgdGhhdCBzaG91bGQgYmUgY29uc2lkZXJlZCBwYXJ0IG9mIHdvcmRzIGluIHRoaXNcbiAgICAgIGxhbmd1YWdlLlxuICAgIC0gW2BcImNsb3NlQnJhY2tldHNcImBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLkNsb3NlQnJhY2tldENvbmZpZykgY29udHJvbHNcbiAgICAgIGJyYWNrZXQgY2xvc2luZyBiZWhhdmlvci5cbiAgICAqL1xuICAgIGxhbmd1YWdlRGF0YUF0KG5hbWUsIHBvcywgc2lkZSA9IC0xKSB7XG4gICAgICAgIGxldCB2YWx1ZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgcHJvdmlkZXIgb2YgdGhpcy5mYWNldChsYW5ndWFnZURhdGEpKSB7XG4gICAgICAgICAgICBmb3IgKGxldCByZXN1bHQgb2YgcHJvdmlkZXIodGhpcywgcG9zLCBzaWRlKSkge1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocmVzdWx0LCBuYW1lKSlcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnB1c2gocmVzdWx0W25hbWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm4gYSBmdW5jdGlvbiB0aGF0IGNhbiBjYXRlZ29yaXplIHN0cmluZ3MgKGV4cGVjdGVkIHRvXG4gICAgcmVwcmVzZW50IGEgc2luZ2xlIFtncmFwaGVtZSBjbHVzdGVyXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLmZpbmRDbHVzdGVyQnJlYWspKVxuICAgIGludG8gb25lIG9mOlxuICAgIFxuICAgICAtIFdvcmQgKGNvbnRhaW5zIGFuIGFscGhhbnVtZXJpYyBjaGFyYWN0ZXIgb3IgYSBjaGFyYWN0ZXJcbiAgICAgICBleHBsaWNpdGx5IGxpc3RlZCBpbiB0aGUgbG9jYWwgbGFuZ3VhZ2UncyBgXCJ3b3JkQ2hhcnNcImBcbiAgICAgICBsYW5ndWFnZSBkYXRhLCB3aGljaCBzaG91bGQgYmUgYSBzdHJpbmcpXG4gICAgIC0gU3BhY2UgKGNvbnRhaW5zIG9ubHkgd2hpdGVzcGFjZSlcbiAgICAgLSBPdGhlciAoYW55dGhpbmcgZWxzZSlcbiAgICAqL1xuICAgIGNoYXJDYXRlZ29yaXplcihhdCkge1xuICAgICAgICByZXR1cm4gbWFrZUNhdGVnb3JpemVyKHRoaXMubGFuZ3VhZ2VEYXRhQXQoXCJ3b3JkQ2hhcnNcIiwgYXQpLmpvaW4oXCJcIikpO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSB3b3JkIGF0IHRoZSBnaXZlbiBwb3NpdGlvbiwgbWVhbmluZyB0aGUgcmFuZ2VcbiAgICBjb250YWluaW5nIGFsbCBbd29yZF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5DaGFyQ2F0ZWdvcnkuV29yZCkgY2hhcmFjdGVyc1xuICAgIGFyb3VuZCBpdC4gSWYgbm8gd29yZCBjaGFyYWN0ZXJzIGFyZSBhZGphY2VudCB0byB0aGUgcG9zaXRpb24sXG4gICAgdGhpcyByZXR1cm5zIG51bGwuXG4gICAgKi9cbiAgICB3b3JkQXQocG9zKSB7XG4gICAgICAgIGxldCB7IHRleHQsIGZyb20sIGxlbmd0aCB9ID0gdGhpcy5kb2MubGluZUF0KHBvcyk7XG4gICAgICAgIGxldCBjYXQgPSB0aGlzLmNoYXJDYXRlZ29yaXplcihwb3MpO1xuICAgICAgICBsZXQgc3RhcnQgPSBwb3MgLSBmcm9tLCBlbmQgPSBwb3MgLSBmcm9tO1xuICAgICAgICB3aGlsZSAoc3RhcnQgPiAwKSB7XG4gICAgICAgICAgICBsZXQgcHJldiA9IGZpbmRDbHVzdGVyQnJlYWsodGV4dCwgc3RhcnQsIGZhbHNlKTtcbiAgICAgICAgICAgIGlmIChjYXQodGV4dC5zbGljZShwcmV2LCBzdGFydCkpICE9IENoYXJDYXRlZ29yeS5Xb3JkKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgc3RhcnQgPSBwcmV2O1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChlbmQgPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gZmluZENsdXN0ZXJCcmVhayh0ZXh0LCBlbmQpO1xuICAgICAgICAgICAgaWYgKGNhdCh0ZXh0LnNsaWNlKGVuZCwgbmV4dCkpICE9IENoYXJDYXRlZ29yeS5Xb3JkKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZW5kID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhcnQgPT0gZW5kID8gbnVsbCA6IEVkaXRvclNlbGVjdGlvbi5yYW5nZShzdGFydCArIGZyb20sIGVuZCArIGZyb20pO1xuICAgIH1cbn1cbi8qKlxuQSBmYWNldCB0aGF0LCB3aGVuIGVuYWJsZWQsIGNhdXNlcyB0aGUgZWRpdG9yIHRvIGFsbG93IG11bHRpcGxlXG5yYW5nZXMgdG8gYmUgc2VsZWN0ZWQuIEJlIGNhcmVmdWwgdGhvdWdoLCBiZWNhdXNlIGJ5IGRlZmF1bHQgdGhlXG5lZGl0b3IgcmVsaWVzIG9uIHRoZSBuYXRpdmUgRE9NIHNlbGVjdGlvbiwgd2hpY2ggY2Fubm90IGhhbmRsZVxubXVsdGlwbGUgc2VsZWN0aW9ucy4gQW4gZXh0ZW5zaW9uIGxpa2VcbltgZHJhd1NlbGVjdGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5kcmF3U2VsZWN0aW9uKSBjYW4gYmUgdXNlZCB0byBtYWtlXG5zZWNvbmRhcnkgc2VsZWN0aW9ucyB2aXNpYmxlIHRvIHRoZSB1c2VyLlxuKi9cbkVkaXRvclN0YXRlLmFsbG93TXVsdGlwbGVTZWxlY3Rpb25zID0gYWxsb3dNdWx0aXBsZVNlbGVjdGlvbnM7XG4vKipcbkNvbmZpZ3VyZXMgdGhlIHRhYiBzaXplIHRvIHVzZSBpbiB0aGlzIHN0YXRlLiBUaGUgZmlyc3RcbihoaWdoZXN0LXByZWNlZGVuY2UpIHZhbHVlIG9mIHRoZSBmYWNldCBpcyB1c2VkLiBJZiBubyB2YWx1ZSBpc1xuZ2l2ZW4sIHRoaXMgZGVmYXVsdHMgdG8gNC5cbiovXG5FZGl0b3JTdGF0ZS50YWJTaXplID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZTogdmFsdWVzID0+IHZhbHVlcy5sZW5ndGggPyB2YWx1ZXNbMF0gOiA0XG59KTtcbi8qKlxuVGhlIGxpbmUgc2VwYXJhdG9yIHRvIHVzZS4gQnkgZGVmYXVsdCwgYW55IG9mIGBcIlxcblwiYCwgYFwiXFxyXFxuXCJgXG5hbmQgYFwiXFxyXCJgIGlzIHRyZWF0ZWQgYXMgYSBzZXBhcmF0b3Igd2hlbiBzcGxpdHRpbmcgbGluZXMsIGFuZFxubGluZXMgYXJlIGpvaW5lZCB3aXRoIGBcIlxcblwiYC5cblxuV2hlbiB5b3UgY29uZmlndXJlIGEgdmFsdWUgaGVyZSwgb25seSB0aGF0IHByZWNpc2Ugc2VwYXJhdG9yXG53aWxsIGJlIHVzZWQsIGFsbG93aW5nIHlvdSB0byByb3VuZC10cmlwIGRvY3VtZW50cyB0aHJvdWdoIHRoZVxuZWRpdG9yIHdpdGhvdXQgbm9ybWFsaXppbmcgbGluZSBzZXBhcmF0b3JzLlxuKi9cbkVkaXRvclN0YXRlLmxpbmVTZXBhcmF0b3IgPSBsaW5lU2VwYXJhdG9yO1xuLyoqXG5UaGlzIGZhY2V0IGNvbnRyb2xzIHRoZSB2YWx1ZSBvZiB0aGVcbltgcmVhZE9ubHlgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLnJlYWRPbmx5KSBnZXR0ZXIsIHdoaWNoIGlzXG5jb25zdWx0ZWQgYnkgY29tbWFuZHMgYW5kIGV4dGVuc2lvbnMgdGhhdCBpbXBsZW1lbnQgZWRpdGluZ1xuZnVuY3Rpb25hbGl0eSB0byBkZXRlcm1pbmUgd2hldGhlciB0aGV5IHNob3VsZCBhcHBseS4gSXRcbmRlZmF1bHRzIHRvIGZhbHNlLCBidXQgd2hlbiBpdHMgaGlnaGVzdC1wcmVjZWRlbmNlIHZhbHVlIGlzXG5gdHJ1ZWAsIHN1Y2ggZnVuY3Rpb25hbGl0eSBkaXNhYmxlcyBpdHNlbGYuXG5cbk5vdCB0byBiZSBjb25mdXNlZCB3aXRoXG5bYEVkaXRvclZpZXcuZWRpdGFibGVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlld15lZGl0YWJsZSksIHdoaWNoXG5jb250cm9scyB3aGV0aGVyIHRoZSBlZGl0b3IncyBET00gaXMgc2V0IHRvIGJlIGVkaXRhYmxlIChhbmRcbnRodXMgZm9jdXNhYmxlKS5cbiovXG5FZGl0b3JTdGF0ZS5yZWFkT25seSA9IHJlYWRPbmx5O1xuLyoqXG5SZWdpc3RlcnMgdHJhbnNsYXRpb24gcGhyYXNlcy4gVGhlXG5bYHBocmFzZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUucGhyYXNlKSBtZXRob2Qgd2lsbCBsb29rIHRocm91Z2hcbmFsbCBvYmplY3RzIHJlZ2lzdGVyZWQgd2l0aCB0aGlzIGZhY2V0IHRvIGZpbmQgdHJhbnNsYXRpb25zIGZvclxuaXRzIGFyZ3VtZW50LlxuKi9cbkVkaXRvclN0YXRlLnBocmFzZXMgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21wYXJlKGEsIGIpIHtcbiAgICAgICAgbGV0IGtBID0gT2JqZWN0LmtleXMoYSksIGtCID0gT2JqZWN0LmtleXMoYik7XG4gICAgICAgIHJldHVybiBrQS5sZW5ndGggPT0ga0IubGVuZ3RoICYmIGtBLmV2ZXJ5KGsgPT4gYVtrXSA9PSBiW2tdKTtcbiAgICB9XG59KTtcbi8qKlxuQSBmYWNldCB1c2VkIHRvIHJlZ2lzdGVyIFtsYW5ndWFnZVxuZGF0YV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5sYW5ndWFnZURhdGFBdCkgcHJvdmlkZXJzLlxuKi9cbkVkaXRvclN0YXRlLmxhbmd1YWdlRGF0YSA9IGxhbmd1YWdlRGF0YTtcbi8qKlxuRmFjZXQgdXNlZCB0byByZWdpc3RlciBjaGFuZ2UgZmlsdGVycywgd2hpY2ggYXJlIGNhbGxlZCBmb3IgZWFjaFxudHJhbnNhY3Rpb24gKHVubGVzcyBleHBsaWNpdGx5XG5bZGlzYWJsZWRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjLmZpbHRlcikpLCBhbmQgY2FuIHN1cHByZXNzXG5wYXJ0IG9mIHRoZSB0cmFuc2FjdGlvbidzIGNoYW5nZXMuXG5cblN1Y2ggYSBmdW5jdGlvbiBjYW4gcmV0dXJuIGB0cnVlYCB0byBpbmRpY2F0ZSB0aGF0IGl0IGRvZXNuJ3RcbndhbnQgdG8gZG8gYW55dGhpbmcsIGBmYWxzZWAgdG8gY29tcGxldGVseSBzdG9wIHRoZSBjaGFuZ2VzIGluXG50aGUgdHJhbnNhY3Rpb24sIG9yIGEgc2V0IG9mIHJhbmdlcyBpbiB3aGljaCBjaGFuZ2VzIHNob3VsZCBiZVxuc3VwcHJlc3NlZC4gU3VjaCByYW5nZXMgYXJlIHJlcHJlc2VudGVkIGFzIGFuIGFycmF5IG9mIG51bWJlcnMsXG53aXRoIGVhY2ggcGFpciBvZiB0d28gbnVtYmVycyBpbmRpY2F0aW5nIHRoZSBzdGFydCBhbmQgZW5kIG9mIGFcbnJhbmdlLiBTbyBmb3IgZXhhbXBsZSBgWzEwLCAyMCwgMTAwLCAxMTBdYCBzdXBwcmVzc2VzIGNoYW5nZXNcbmJldHdlZW4gMTAgYW5kIDIwLCBhbmQgYmV0d2VlbiAxMDAgYW5kIDExMC5cbiovXG5FZGl0b3JTdGF0ZS5jaGFuZ2VGaWx0ZXIgPSBjaGFuZ2VGaWx0ZXI7XG4vKipcbkZhY2V0IHVzZWQgdG8gcmVnaXN0ZXIgYSBob29rIHRoYXQgZ2V0cyBhIGNoYW5jZSB0byB1cGRhdGUgb3JcbnJlcGxhY2UgdHJhbnNhY3Rpb24gc3BlY3MgYmVmb3JlIHRoZXkgYXJlIGFwcGxpZWQuIFRoaXMgd2lsbFxub25seSBiZSBhcHBsaWVkIGZvciB0cmFuc2FjdGlvbnMgdGhhdCBkb24ndCBoYXZlXG5bYGZpbHRlcmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjLmZpbHRlcikgc2V0IHRvIGBmYWxzZWAuIFlvdVxuY2FuIGVpdGhlciByZXR1cm4gYSBzaW5nbGUgdHJhbnNhY3Rpb24gc3BlYyAocG9zc2libHkgdGhlIGlucHV0XG50cmFuc2FjdGlvbiksIG9yIGFuIGFycmF5IG9mIHNwZWNzICh3aGljaCB3aWxsIGJlIGNvbWJpbmVkIGluXG50aGUgc2FtZSB3YXkgYXMgdGhlIGFyZ3VtZW50cyB0b1xuW2BFZGl0b3JTdGF0ZS51cGRhdGVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLnVwZGF0ZSkpLlxuXG5XaGVuIHBvc3NpYmxlLCBpdCBpcyByZWNvbW1lbmRlZCB0byBhdm9pZCBhY2Nlc3NpbmdcbltgVHJhbnNhY3Rpb24uc3RhdGVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uLnN0YXRlKSBpbiBhIGZpbHRlcixcbnNpbmNlIGl0IHdpbGwgZm9yY2UgY3JlYXRpb24gb2YgYSBzdGF0ZSB0aGF0IHdpbGwgdGhlbiBiZVxuZGlzY2FyZGVkIGFnYWluLCBpZiB0aGUgdHJhbnNhY3Rpb24gaXMgYWN0dWFsbHkgZmlsdGVyZWQuXG5cbihUaGlzIGZ1bmN0aW9uYWxpdHkgc2hvdWxkIGJlIHVzZWQgd2l0aCBjYXJlLiBJbmRpc2NyaW1pbmF0ZWx5XG5tb2RpZnlpbmcgdHJhbnNhY3Rpb24gaXMgbGlrZWx5IHRvIGJyZWFrIHNvbWV0aGluZyBvciBkZWdyYWRlXG50aGUgdXNlciBleHBlcmllbmNlLilcbiovXG5FZGl0b3JTdGF0ZS50cmFuc2FjdGlvbkZpbHRlciA9IHRyYW5zYWN0aW9uRmlsdGVyO1xuLyoqXG5UaGlzIGlzIGEgbW9yZSBsaW1pdGVkIGZvcm0gb2ZcbltgdHJhbnNhY3Rpb25GaWx0ZXJgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlXnRyYW5zYWN0aW9uRmlsdGVyKSxcbndoaWNoIGNhbiBvbmx5IGFkZFxuW2Fubm90YXRpb25zXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYy5hbm5vdGF0aW9ucykgYW5kXG5bZWZmZWN0c10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMuZWZmZWN0cykuIF9CdXRfLCB0aGlzIHR5cGVcbm9mIGZpbHRlciBydW5zIGV2ZW4gaWYgdGhlIHRyYW5zYWN0aW9uIGhhcyBkaXNhYmxlZCByZWd1bGFyXG5bZmlsdGVyaW5nXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYy5maWx0ZXIpLCBtYWtpbmcgaXQgc3VpdGFibGVcbmZvciBlZmZlY3RzIHRoYXQgZG9uJ3QgbmVlZCB0byB0b3VjaCB0aGUgY2hhbmdlcyBvciBzZWxlY3Rpb24sXG5idXQgZG8gd2FudCB0byBwcm9jZXNzIGV2ZXJ5IHRyYW5zYWN0aW9uLlxuXG5FeHRlbmRlcnMgcnVuIF9hZnRlcl8gZmlsdGVycywgd2hlbiBib3RoIGFyZSBwcmVzZW50LlxuKi9cbkVkaXRvclN0YXRlLnRyYW5zYWN0aW9uRXh0ZW5kZXIgPSB0cmFuc2FjdGlvbkV4dGVuZGVyO1xuQ29tcGFydG1lbnQucmVjb25maWd1cmUgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG5cbi8qKlxuVXRpbGl0eSBmdW5jdGlvbiBmb3IgY29tYmluaW5nIGJlaGF2aW9ycyB0byBmaWxsIGluIGEgY29uZmlnXG5vYmplY3QgZnJvbSBhbiBhcnJheSBvZiBwcm92aWRlZCBjb25maWdzLiBgZGVmYXVsdHNgIHNob3VsZCBob2xkXG5kZWZhdWx0IHZhbHVlcyBmb3IgYWxsIG9wdGlvbmFsIGZpZWxkcyBpbiBgQ29uZmlnYC5cblxuVGhlIGZ1bmN0aW9uIHdpbGwsIGJ5IGRlZmF1bHQsIGVycm9yXG53aGVuIGEgZmllbGQgZ2V0cyB0d28gdmFsdWVzIHRoYXQgYXJlbid0IGA9PT1gLWVxdWFsLCBidXQgeW91IGNhblxucHJvdmlkZSBjb21iaW5lIGZ1bmN0aW9ucyBwZXIgZmllbGQgdG8gZG8gc29tZXRoaW5nIGVsc2UuXG4qL1xuZnVuY3Rpb24gY29tYmluZUNvbmZpZyhjb25maWdzLCBkZWZhdWx0cywgLy8gU2hvdWxkIGhvbGQgb25seSB0aGUgb3B0aW9uYWwgcHJvcGVydGllcyBvZiBDb25maWcsIGJ1dCBJIGhhdmVuJ3QgbWFuYWdlZCB0byBleHByZXNzIHRoYXRcbmNvbWJpbmUgPSB7fSkge1xuICAgIGxldCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGxldCBjb25maWcgb2YgY29uZmlncylcbiAgICAgICAgZm9yIChsZXQga2V5IG9mIE9iamVjdC5rZXlzKGNvbmZpZykpIHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGNvbmZpZ1trZXldLCBjdXJyZW50ID0gcmVzdWx0W2tleV07XG4gICAgICAgICAgICBpZiAoY3VycmVudCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICBlbHNlIGlmIChjdXJyZW50ID09PSB2YWx1ZSB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSA7IC8vIE5vIGNvbmZsaWN0XG4gICAgICAgICAgICBlbHNlIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChjb21iaW5lLCBrZXkpKVxuICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gY29tYmluZVtrZXldKGN1cnJlbnQsIHZhbHVlKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb25maWcgbWVyZ2UgY29uZmxpY3QgZm9yIGZpZWxkIFwiICsga2V5KTtcbiAgICAgICAgfVxuICAgIGZvciAobGV0IGtleSBpbiBkZWZhdWx0cylcbiAgICAgICAgaWYgKHJlc3VsdFtrZXldID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IGRlZmF1bHRzW2tleV07XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG5FYWNoIHJhbmdlIGlzIGFzc29jaWF0ZWQgd2l0aCBhIHZhbHVlLCB3aGljaCBtdXN0IGluaGVyaXQgZnJvbVxudGhpcyBjbGFzcy5cbiovXG5jbGFzcyBSYW5nZVZhbHVlIHtcbiAgICAvKipcbiAgICBDb21wYXJlIHRoaXMgdmFsdWUgd2l0aCBhbm90aGVyIHZhbHVlLiBVc2VkIHdoZW4gY29tcGFyaW5nXG4gICAgcmFuZ2VzZXRzLiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBjb21wYXJlcyBieSBpZGVudGl0eS5cbiAgICBVbmxlc3MgeW91IGFyZSBvbmx5IGNyZWF0aW5nIGEgZml4ZWQgbnVtYmVyIG9mIHVuaXF1ZSBpbnN0YW5jZXNcbiAgICBvZiB5b3VyIHZhbHVlIHR5cGUsIGl0IGlzIGEgZ29vZCBpZGVhIHRvIGltcGxlbWVudCB0aGlzXG4gICAgcHJvcGVybHkuXG4gICAgKi9cbiAgICBlcShvdGhlcikgeyByZXR1cm4gdGhpcyA9PSBvdGhlcjsgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIFtyYW5nZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5SYW5nZSkgd2l0aCB0aGlzIHZhbHVlLlxuICAgICovXG4gICAgcmFuZ2UoZnJvbSwgdG8gPSBmcm9tKSB7IHJldHVybiBSYW5nZS5jcmVhdGUoZnJvbSwgdG8sIHRoaXMpOyB9XG59XG5SYW5nZVZhbHVlLnByb3RvdHlwZS5zdGFydFNpZGUgPSBSYW5nZVZhbHVlLnByb3RvdHlwZS5lbmRTaWRlID0gMDtcblJhbmdlVmFsdWUucHJvdG90eXBlLnBvaW50ID0gZmFsc2U7XG5SYW5nZVZhbHVlLnByb3RvdHlwZS5tYXBNb2RlID0gTWFwTW9kZS5UcmFja0RlbDtcbi8qKlxuQSByYW5nZSBhc3NvY2lhdGVzIGEgdmFsdWUgd2l0aCBhIHJhbmdlIG9mIHBvc2l0aW9ucy5cbiovXG5jbGFzcyBSYW5nZSB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHJhbmdlJ3Mgc3RhcnQgcG9zaXRpb24uXG4gICAgKi9cbiAgICBmcm9tLCBcbiAgICAvKipcbiAgICBJdHMgZW5kIHBvc2l0aW9uLlxuICAgICovXG4gICAgdG8sIFxuICAgIC8qKlxuICAgIFRoZSB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggdGhpcyByYW5nZS5cbiAgICAqL1xuICAgIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUoZnJvbSwgdG8sIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmFuZ2UoZnJvbSwgdG8sIHZhbHVlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjbXBSYW5nZShhLCBiKSB7XG4gICAgcmV0dXJuIGEuZnJvbSAtIGIuZnJvbSB8fCBhLnZhbHVlLnN0YXJ0U2lkZSAtIGIudmFsdWUuc3RhcnRTaWRlO1xufVxuY2xhc3MgQ2h1bmsge1xuICAgIGNvbnN0cnVjdG9yKGZyb20sIHRvLCB2YWx1ZSwgXG4gICAgLy8gQ2h1bmtzIGFyZSBtYXJrZWQgd2l0aCB0aGUgbGFyZ2VzdCBwb2ludCB0aGF0IG9jY3Vyc1xuICAgIC8vIGluIHRoZW0gKG9yIC0xIGZvciBubyBwb2ludHMpLCBzbyB0aGF0IHNjYW5zIHRoYXQgYXJlXG4gICAgLy8gb25seSBpbnRlcmVzdGVkIGluIHBvaW50cyAoc3VjaCBhcyB0aGVcbiAgICAvLyBoZWlnaHRtYXAtcmVsYXRlZCBsb2dpYykgY2FuIHNraXAgcmFuZ2Utb25seSBjaHVua3MuXG4gICAgbWF4UG9pbnQpIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMubWF4UG9pbnQgPSBtYXhQb2ludDtcbiAgICB9XG4gICAgZ2V0IGxlbmd0aCgpIHsgcmV0dXJuIHRoaXMudG9bdGhpcy50by5sZW5ndGggLSAxXTsgfVxuICAgIC8vIEZpbmQgdGhlIGluZGV4IG9mIHRoZSBnaXZlbiBwb3NpdGlvbiBhbmQgc2lkZS4gVXNlIHRoZSByYW5nZXMnXG4gICAgLy8gYGZyb21gIHBvcyB3aGVuIGBlbmQgPT0gZmFsc2VgLCBgdG9gIHdoZW4gYGVuZCA9PSB0cnVlYC5cbiAgICBmaW5kSW5kZXgocG9zLCBzaWRlLCBlbmQsIHN0YXJ0QXQgPSAwKSB7XG4gICAgICAgIGxldCBhcnIgPSBlbmQgPyB0aGlzLnRvIDogdGhpcy5mcm9tO1xuICAgICAgICBmb3IgKGxldCBsbyA9IHN0YXJ0QXQsIGhpID0gYXJyLmxlbmd0aDs7KSB7XG4gICAgICAgICAgICBpZiAobG8gPT0gaGkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvO1xuICAgICAgICAgICAgbGV0IG1pZCA9IChsbyArIGhpKSA+PiAxO1xuICAgICAgICAgICAgbGV0IGRpZmYgPSBhcnJbbWlkXSAtIHBvcyB8fCAoZW5kID8gdGhpcy52YWx1ZVttaWRdLmVuZFNpZGUgOiB0aGlzLnZhbHVlW21pZF0uc3RhcnRTaWRlKSAtIHNpZGU7XG4gICAgICAgICAgICBpZiAobWlkID09IGxvKVxuICAgICAgICAgICAgICAgIHJldHVybiBkaWZmID49IDAgPyBsbyA6IGhpO1xuICAgICAgICAgICAgaWYgKGRpZmYgPj0gMClcbiAgICAgICAgICAgICAgICBoaSA9IG1pZDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBsbyA9IG1pZCArIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYmV0d2VlbihvZmZzZXQsIGZyb20sIHRvLCBmKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmZpbmRJbmRleChmcm9tLCAtMTAwMDAwMDAwMCAvKiBDLkZhciAqLywgdHJ1ZSksIGUgPSB0aGlzLmZpbmRJbmRleCh0bywgMTAwMDAwMDAwMCAvKiBDLkZhciAqLywgZmFsc2UsIGkpOyBpIDwgZTsgaSsrKVxuICAgICAgICAgICAgaWYgKGYodGhpcy5mcm9tW2ldICsgb2Zmc2V0LCB0aGlzLnRvW2ldICsgb2Zmc2V0LCB0aGlzLnZhbHVlW2ldKSA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBtYXAob2Zmc2V0LCBjaGFuZ2VzKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IFtdLCBmcm9tID0gW10sIHRvID0gW10sIG5ld1BvcyA9IC0xLCBtYXhQb2ludCA9IC0xO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB2YWwgPSB0aGlzLnZhbHVlW2ldLCBjdXJGcm9tID0gdGhpcy5mcm9tW2ldICsgb2Zmc2V0LCBjdXJUbyA9IHRoaXMudG9baV0gKyBvZmZzZXQsIG5ld0Zyb20sIG5ld1RvO1xuICAgICAgICAgICAgaWYgKGN1ckZyb20gPT0gY3VyVG8pIHtcbiAgICAgICAgICAgICAgICBsZXQgbWFwcGVkID0gY2hhbmdlcy5tYXBQb3MoY3VyRnJvbSwgdmFsLnN0YXJ0U2lkZSwgdmFsLm1hcE1vZGUpO1xuICAgICAgICAgICAgICAgIGlmIChtYXBwZWQgPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgbmV3RnJvbSA9IG5ld1RvID0gbWFwcGVkO1xuICAgICAgICAgICAgICAgIGlmICh2YWwuc3RhcnRTaWRlICE9IHZhbC5lbmRTaWRlKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1RvID0gY2hhbmdlcy5tYXBQb3MoY3VyRnJvbSwgdmFsLmVuZFNpZGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV3VG8gPCBuZXdGcm9tKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3RnJvbSA9IGNoYW5nZXMubWFwUG9zKGN1ckZyb20sIHZhbC5zdGFydFNpZGUpO1xuICAgICAgICAgICAgICAgIG5ld1RvID0gY2hhbmdlcy5tYXBQb3MoY3VyVG8sIHZhbC5lbmRTaWRlKTtcbiAgICAgICAgICAgICAgICBpZiAobmV3RnJvbSA+IG5ld1RvIHx8IG5ld0Zyb20gPT0gbmV3VG8gJiYgdmFsLnN0YXJ0U2lkZSA+IDAgJiYgdmFsLmVuZFNpZGUgPD0gMClcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKG5ld1RvIC0gbmV3RnJvbSB8fCB2YWwuZW5kU2lkZSAtIHZhbC5zdGFydFNpZGUpIDwgMClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChuZXdQb3MgPCAwKVxuICAgICAgICAgICAgICAgIG5ld1BvcyA9IG5ld0Zyb207XG4gICAgICAgICAgICBpZiAodmFsLnBvaW50KVxuICAgICAgICAgICAgICAgIG1heFBvaW50ID0gTWF0aC5tYXgobWF4UG9pbnQsIG5ld1RvIC0gbmV3RnJvbSk7XG4gICAgICAgICAgICB2YWx1ZS5wdXNoKHZhbCk7XG4gICAgICAgICAgICBmcm9tLnB1c2gobmV3RnJvbSAtIG5ld1Bvcyk7XG4gICAgICAgICAgICB0by5wdXNoKG5ld1RvIC0gbmV3UG9zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBtYXBwZWQ6IHZhbHVlLmxlbmd0aCA/IG5ldyBDaHVuayhmcm9tLCB0bywgdmFsdWUsIG1heFBvaW50KSA6IG51bGwsIHBvczogbmV3UG9zIH07XG4gICAgfVxufVxuLyoqXG5BIHJhbmdlIHNldCBzdG9yZXMgYSBjb2xsZWN0aW9uIG9mIFtyYW5nZXNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuUmFuZ2UpIGluIGFcbndheSB0aGF0IG1ha2VzIHRoZW0gZWZmaWNpZW50IHRvIFttYXBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuUmFuZ2VTZXQubWFwKSBhbmRcblt1cGRhdGVdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuUmFuZ2VTZXQudXBkYXRlKS4gVGhpcyBpcyBhbiBpbW11dGFibGUgZGF0YVxuc3RydWN0dXJlLlxuKi9cbmNsYXNzIFJhbmdlU2V0IHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNodW5rUG9zLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNodW5rLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIG5leHRMYXllciwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBtYXhQb2ludCkge1xuICAgICAgICB0aGlzLmNodW5rUG9zID0gY2h1bmtQb3M7XG4gICAgICAgIHRoaXMuY2h1bmsgPSBjaHVuaztcbiAgICAgICAgdGhpcy5uZXh0TGF5ZXIgPSBuZXh0TGF5ZXI7XG4gICAgICAgIHRoaXMubWF4UG9pbnQgPSBtYXhQb2ludDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKGNodW5rUG9zLCBjaHVuaywgbmV4dExheWVyLCBtYXhQb2ludCkge1xuICAgICAgICByZXR1cm4gbmV3IFJhbmdlU2V0KGNodW5rUG9zLCBjaHVuaywgbmV4dExheWVyLCBtYXhQb2ludCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZ2V0IGxlbmd0aCgpIHtcbiAgICAgICAgbGV0IGxhc3QgPSB0aGlzLmNodW5rLmxlbmd0aCAtIDE7XG4gICAgICAgIHJldHVybiBsYXN0IDwgMCA/IDAgOiBNYXRoLm1heCh0aGlzLmNodW5rRW5kKGxhc3QpLCB0aGlzLm5leHRMYXllci5sZW5ndGgpO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgbnVtYmVyIG9mIHJhbmdlcyBpbiB0aGUgc2V0LlxuICAgICovXG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRW1wdHkpXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgbGV0IHNpemUgPSB0aGlzLm5leHRMYXllci5zaXplO1xuICAgICAgICBmb3IgKGxldCBjaHVuayBvZiB0aGlzLmNodW5rKVxuICAgICAgICAgICAgc2l6ZSArPSBjaHVuay52YWx1ZS5sZW5ndGg7XG4gICAgICAgIHJldHVybiBzaXplO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNodW5rRW5kKGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNodW5rUG9zW2luZGV4XSArIHRoaXMuY2h1bmtbaW5kZXhdLmxlbmd0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgVXBkYXRlIHRoZSByYW5nZSBzZXQsIG9wdGlvbmFsbHkgYWRkaW5nIG5ldyByYW5nZXMgb3IgZmlsdGVyaW5nXG4gICAgb3V0IGV4aXN0aW5nIG9uZXMuXG4gICAgXG4gICAgKE5vdGU6IFRoZSB0eXBlIHBhcmFtZXRlciBpcyBqdXN0IHRoZXJlIGFzIGEga2x1ZGdlIHRvIHdvcmtcbiAgICBhcm91bmQgVHlwZVNjcmlwdCB2YXJpYW5jZSBpc3N1ZXMgdGhhdCBwcmV2ZW50ZWQgYFJhbmdlU2V0PFg+YFxuICAgIGZyb20gYmVpbmcgYSBzdWJ0eXBlIG9mIGBSYW5nZVNldDxZPmAgd2hlbiBgWGAgaXMgYSBzdWJ0eXBlIG9mXG4gICAgYFlgLilcbiAgICAqL1xuICAgIHVwZGF0ZSh1cGRhdGVTcGVjKSB7XG4gICAgICAgIGxldCB7IGFkZCA9IFtdLCBzb3J0ID0gZmFsc2UsIGZpbHRlckZyb20gPSAwLCBmaWx0ZXJUbyA9IHRoaXMubGVuZ3RoIH0gPSB1cGRhdGVTcGVjO1xuICAgICAgICBsZXQgZmlsdGVyID0gdXBkYXRlU3BlYy5maWx0ZXI7XG4gICAgICAgIGlmIChhZGQubGVuZ3RoID09IDAgJiYgIWZpbHRlcilcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBpZiAoc29ydClcbiAgICAgICAgICAgIGFkZCA9IGFkZC5zbGljZSgpLnNvcnQoY21wUmFuZ2UpO1xuICAgICAgICBpZiAodGhpcy5pc0VtcHR5KVxuICAgICAgICAgICAgcmV0dXJuIGFkZC5sZW5ndGggPyBSYW5nZVNldC5vZihhZGQpIDogdGhpcztcbiAgICAgICAgbGV0IGN1ciA9IG5ldyBMYXllckN1cnNvcih0aGlzLCBudWxsLCAtMSkuZ290bygwKSwgaSA9IDAsIHNwaWxsID0gW107XG4gICAgICAgIGxldCBidWlsZGVyID0gbmV3IFJhbmdlU2V0QnVpbGRlcigpO1xuICAgICAgICB3aGlsZSAoY3VyLnZhbHVlIHx8IGkgPCBhZGQubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaSA8IGFkZC5sZW5ndGggJiYgKGN1ci5mcm9tIC0gYWRkW2ldLmZyb20gfHwgY3VyLnN0YXJ0U2lkZSAtIGFkZFtpXS52YWx1ZS5zdGFydFNpZGUpID49IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgcmFuZ2UgPSBhZGRbaSsrXTtcbiAgICAgICAgICAgICAgICBpZiAoIWJ1aWxkZXIuYWRkSW5uZXIocmFuZ2UuZnJvbSwgcmFuZ2UudG8sIHJhbmdlLnZhbHVlKSlcbiAgICAgICAgICAgICAgICAgICAgc3BpbGwucHVzaChyYW5nZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjdXIucmFuZ2VJbmRleCA9PSAxICYmIGN1ci5jaHVua0luZGV4IDwgdGhpcy5jaHVuay5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAoaSA9PSBhZGQubGVuZ3RoIHx8IHRoaXMuY2h1bmtFbmQoY3VyLmNodW5rSW5kZXgpIDwgYWRkW2ldLmZyb20pICYmXG4gICAgICAgICAgICAgICAgKCFmaWx0ZXIgfHwgZmlsdGVyRnJvbSA+IHRoaXMuY2h1bmtFbmQoY3VyLmNodW5rSW5kZXgpIHx8IGZpbHRlclRvIDwgdGhpcy5jaHVua1Bvc1tjdXIuY2h1bmtJbmRleF0pICYmXG4gICAgICAgICAgICAgICAgYnVpbGRlci5hZGRDaHVuayh0aGlzLmNodW5rUG9zW2N1ci5jaHVua0luZGV4XSwgdGhpcy5jaHVua1tjdXIuY2h1bmtJbmRleF0pKSB7XG4gICAgICAgICAgICAgICAgY3VyLm5leHRDaHVuaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCFmaWx0ZXIgfHwgZmlsdGVyRnJvbSA+IGN1ci50byB8fCBmaWx0ZXJUbyA8IGN1ci5mcm9tIHx8IGZpbHRlcihjdXIuZnJvbSwgY3VyLnRvLCBjdXIudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYnVpbGRlci5hZGRJbm5lcihjdXIuZnJvbSwgY3VyLnRvLCBjdXIudmFsdWUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgc3BpbGwucHVzaChSYW5nZS5jcmVhdGUoY3VyLmZyb20sIGN1ci50bywgY3VyLnZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1ci5uZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1aWxkZXIuZmluaXNoSW5uZXIodGhpcy5uZXh0TGF5ZXIuaXNFbXB0eSAmJiAhc3BpbGwubGVuZ3RoID8gUmFuZ2VTZXQuZW1wdHlcbiAgICAgICAgICAgIDogdGhpcy5uZXh0TGF5ZXIudXBkYXRlKHsgYWRkOiBzcGlsbCwgZmlsdGVyLCBmaWx0ZXJGcm9tLCBmaWx0ZXJUbyB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgIE1hcCB0aGlzIHJhbmdlIHNldCB0aHJvdWdoIGEgc2V0IG9mIGNoYW5nZXMsIHJldHVybiB0aGUgbmV3IHNldC5cbiAgICAqL1xuICAgIG1hcChjaGFuZ2VzKSB7XG4gICAgICAgIGlmIChjaGFuZ2VzLmVtcHR5IHx8IHRoaXMuaXNFbXB0eSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBsZXQgY2h1bmtzID0gW10sIGNodW5rUG9zID0gW10sIG1heFBvaW50ID0gLTE7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaHVuay5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5jaHVua1Bvc1tpXSwgY2h1bmsgPSB0aGlzLmNodW5rW2ldO1xuICAgICAgICAgICAgbGV0IHRvdWNoID0gY2hhbmdlcy50b3VjaGVzUmFuZ2Uoc3RhcnQsIHN0YXJ0ICsgY2h1bmsubGVuZ3RoKTtcbiAgICAgICAgICAgIGlmICh0b3VjaCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBtYXhQb2ludCA9IE1hdGgubWF4KG1heFBvaW50LCBjaHVuay5tYXhQb2ludCk7XG4gICAgICAgICAgICAgICAgY2h1bmtzLnB1c2goY2h1bmspO1xuICAgICAgICAgICAgICAgIGNodW5rUG9zLnB1c2goY2hhbmdlcy5tYXBQb3Moc3RhcnQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRvdWNoID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgbWFwcGVkLCBwb3MgfSA9IGNodW5rLm1hcChzdGFydCwgY2hhbmdlcyk7XG4gICAgICAgICAgICAgICAgaWYgKG1hcHBlZCkge1xuICAgICAgICAgICAgICAgICAgICBtYXhQb2ludCA9IE1hdGgubWF4KG1heFBvaW50LCBtYXBwZWQubWF4UG9pbnQpO1xuICAgICAgICAgICAgICAgICAgICBjaHVua3MucHVzaChtYXBwZWQpO1xuICAgICAgICAgICAgICAgICAgICBjaHVua1Bvcy5wdXNoKHBvcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBuZXh0ID0gdGhpcy5uZXh0TGF5ZXIubWFwKGNoYW5nZXMpO1xuICAgICAgICByZXR1cm4gY2h1bmtzLmxlbmd0aCA9PSAwID8gbmV4dCA6IG5ldyBSYW5nZVNldChjaHVua1BvcywgY2h1bmtzLCBuZXh0IHx8IFJhbmdlU2V0LmVtcHR5LCBtYXhQb2ludCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEl0ZXJhdGUgb3ZlciB0aGUgcmFuZ2VzIHRoYXQgdG91Y2ggdGhlIHJlZ2lvbiBgZnJvbWAgdG8gYHRvYCxcbiAgICBjYWxsaW5nIGBmYCBmb3IgZWFjaC4gVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgdGhlIHJhbmdlcyB3aWxsXG4gICAgYmUgcmVwb3J0ZWQgaW4gYW55IHNwZWNpZmljIG9yZGVyLiBXaGVuIHRoZSBjYWxsYmFjayByZXR1cm5zXG4gICAgYGZhbHNlYCwgaXRlcmF0aW9uIHN0b3BzLlxuICAgICovXG4gICAgYmV0d2Vlbihmcm9tLCB0bywgZikge1xuICAgICAgICBpZiAodGhpcy5pc0VtcHR5KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2h1bmsubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IHRoaXMuY2h1bmtQb3NbaV0sIGNodW5rID0gdGhpcy5jaHVua1tpXTtcbiAgICAgICAgICAgIGlmICh0byA+PSBzdGFydCAmJiBmcm9tIDw9IHN0YXJ0ICsgY2h1bmsubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgY2h1bmsuYmV0d2VlbihzdGFydCwgZnJvbSAtIHN0YXJ0LCB0byAtIHN0YXJ0LCBmKSA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubmV4dExheWVyLmJldHdlZW4oZnJvbSwgdG8sIGYpO1xuICAgIH1cbiAgICAvKipcbiAgICBJdGVyYXRlIG92ZXIgdGhlIHJhbmdlcyBpbiB0aGlzIHNldCwgaW4gb3JkZXIsIGluY2x1ZGluZyBhbGxcbiAgICByYW5nZXMgdGhhdCBlbmQgYXQgb3IgYWZ0ZXIgYGZyb21gLlxuICAgICovXG4gICAgaXRlcihmcm9tID0gMCkge1xuICAgICAgICByZXR1cm4gSGVhcEN1cnNvci5mcm9tKFt0aGlzXSkuZ290byhmcm9tKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBnZXQgaXNFbXB0eSgpIHsgcmV0dXJuIHRoaXMubmV4dExheWVyID09IHRoaXM7IH1cbiAgICAvKipcbiAgICBJdGVyYXRlIG92ZXIgdGhlIHJhbmdlcyBpbiBhIGNvbGxlY3Rpb24gb2Ygc2V0cywgaW4gb3JkZXIsXG4gICAgc3RhcnRpbmcgZnJvbSBgZnJvbWAuXG4gICAgKi9cbiAgICBzdGF0aWMgaXRlcihzZXRzLCBmcm9tID0gMCkge1xuICAgICAgICByZXR1cm4gSGVhcEN1cnNvci5mcm9tKHNldHMpLmdvdG8oZnJvbSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEl0ZXJhdGUgb3ZlciB0d28gZ3JvdXBzIG9mIHNldHMsIGNhbGxpbmcgbWV0aG9kcyBvbiBgY29tcGFyYXRvcmBcbiAgICB0byBub3RpZnkgaXQgb2YgcG9zc2libGUgZGlmZmVyZW5jZXMuXG4gICAgKi9cbiAgICBzdGF0aWMgY29tcGFyZShvbGRTZXRzLCBuZXdTZXRzLCBcbiAgICAvKipcbiAgICBUaGlzIGluZGljYXRlcyBob3cgdGhlIHVuZGVybHlpbmcgZGF0YSBjaGFuZ2VkIGJldHdlZW4gdGhlc2VcbiAgICByYW5nZXMsIGFuZCBpcyBuZWVkZWQgdG8gc3luY2hyb25pemUgdGhlIGl0ZXJhdGlvbi5cbiAgICAqL1xuICAgIHRleHREaWZmLCBjb21wYXJhdG9yLCBcbiAgICAvKipcbiAgICBDYW4gYmUgdXNlZCB0byBpZ25vcmUgYWxsIG5vbi1wb2ludCByYW5nZXMsIGFuZCBwb2ludHMgYmVsb3dcbiAgICB0aGUgZ2l2ZW4gc2l6ZS4gV2hlbiAtMSwgYWxsIHJhbmdlcyBhcmUgY29tcGFyZWQuXG4gICAgKi9cbiAgICBtaW5Qb2ludFNpemUgPSAtMSkge1xuICAgICAgICBsZXQgYSA9IG9sZFNldHMuZmlsdGVyKHNldCA9PiBzZXQubWF4UG9pbnQgPiAwIHx8ICFzZXQuaXNFbXB0eSAmJiBzZXQubWF4UG9pbnQgPj0gbWluUG9pbnRTaXplKTtcbiAgICAgICAgbGV0IGIgPSBuZXdTZXRzLmZpbHRlcihzZXQgPT4gc2V0Lm1heFBvaW50ID4gMCB8fCAhc2V0LmlzRW1wdHkgJiYgc2V0Lm1heFBvaW50ID49IG1pblBvaW50U2l6ZSk7XG4gICAgICAgIGxldCBzaGFyZWRDaHVua3MgPSBmaW5kU2hhcmVkQ2h1bmtzKGEsIGIsIHRleHREaWZmKTtcbiAgICAgICAgbGV0IHNpZGVBID0gbmV3IFNwYW5DdXJzb3IoYSwgc2hhcmVkQ2h1bmtzLCBtaW5Qb2ludFNpemUpO1xuICAgICAgICBsZXQgc2lkZUIgPSBuZXcgU3BhbkN1cnNvcihiLCBzaGFyZWRDaHVua3MsIG1pblBvaW50U2l6ZSk7XG4gICAgICAgIHRleHREaWZmLml0ZXJHYXBzKChmcm9tQSwgZnJvbUIsIGxlbmd0aCkgPT4gY29tcGFyZShzaWRlQSwgZnJvbUEsIHNpZGVCLCBmcm9tQiwgbGVuZ3RoLCBjb21wYXJhdG9yKSk7XG4gICAgICAgIGlmICh0ZXh0RGlmZi5lbXB0eSAmJiB0ZXh0RGlmZi5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIGNvbXBhcmUoc2lkZUEsIDAsIHNpZGVCLCAwLCAwLCBjb21wYXJhdG9yKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29tcGFyZSB0aGUgY29udGVudHMgb2YgdHdvIGdyb3VwcyBvZiByYW5nZSBzZXRzLCByZXR1cm5pbmcgdHJ1ZVxuICAgIGlmIHRoZXkgYXJlIGVxdWl2YWxlbnQgaW4gdGhlIGdpdmVuIHJhbmdlLlxuICAgICovXG4gICAgc3RhdGljIGVxKG9sZFNldHMsIG5ld1NldHMsIGZyb20gPSAwLCB0bykge1xuICAgICAgICBpZiAodG8gPT0gbnVsbClcbiAgICAgICAgICAgIHRvID0gMTAwMDAwMDAwMCAvKiBDLkZhciAqLyAtIDE7XG4gICAgICAgIGxldCBhID0gb2xkU2V0cy5maWx0ZXIoc2V0ID0+ICFzZXQuaXNFbXB0eSAmJiBuZXdTZXRzLmluZGV4T2Yoc2V0KSA8IDApO1xuICAgICAgICBsZXQgYiA9IG5ld1NldHMuZmlsdGVyKHNldCA9PiAhc2V0LmlzRW1wdHkgJiYgb2xkU2V0cy5pbmRleE9mKHNldCkgPCAwKTtcbiAgICAgICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoIWEubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGxldCBzaGFyZWRDaHVua3MgPSBmaW5kU2hhcmVkQ2h1bmtzKGEsIGIpO1xuICAgICAgICBsZXQgc2lkZUEgPSBuZXcgU3BhbkN1cnNvcihhLCBzaGFyZWRDaHVua3MsIDApLmdvdG8oZnJvbSksIHNpZGVCID0gbmV3IFNwYW5DdXJzb3IoYiwgc2hhcmVkQ2h1bmtzLCAwKS5nb3RvKGZyb20pO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBpZiAoc2lkZUEudG8gIT0gc2lkZUIudG8gfHxcbiAgICAgICAgICAgICAgICAhc2FtZVZhbHVlcyhzaWRlQS5hY3RpdmUsIHNpZGVCLmFjdGl2ZSkgfHxcbiAgICAgICAgICAgICAgICBzaWRlQS5wb2ludCAmJiAoIXNpZGVCLnBvaW50IHx8ICFzaWRlQS5wb2ludC5lcShzaWRlQi5wb2ludCkpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmIChzaWRlQS50byA+IHRvKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgc2lkZUEubmV4dCgpO1xuICAgICAgICAgICAgc2lkZUIubmV4dCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEl0ZXJhdGUgb3ZlciBhIGdyb3VwIG9mIHJhbmdlIHNldHMgYXQgdGhlIHNhbWUgdGltZSwgbm90aWZ5aW5nXG4gICAgdGhlIGl0ZXJhdG9yIGFib3V0IHRoZSByYW5nZXMgY292ZXJpbmcgZXZlcnkgZ2l2ZW4gcGllY2Ugb2ZcbiAgICBjb250ZW50LiBSZXR1cm5zIHRoZSBvcGVuIGNvdW50IChzZWVcbiAgICBbYFNwYW5JdGVyYXRvci5zcGFuYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5TcGFuSXRlcmF0b3Iuc3BhbikpIGF0IHRoZSBlbmRcbiAgICBvZiB0aGUgaXRlcmF0aW9uLlxuICAgICovXG4gICAgc3RhdGljIHNwYW5zKHNldHMsIGZyb20sIHRvLCBpdGVyYXRvciwgXG4gICAgLyoqXG4gICAgV2hlbiBnaXZlbiBhbmQgZ3JlYXRlciB0aGFuIC0xLCBvbmx5IHBvaW50cyBvZiBhdCBsZWFzdCB0aGlzXG4gICAgc2l6ZSBhcmUgdGFrZW4gaW50byBhY2NvdW50LlxuICAgICovXG4gICAgbWluUG9pbnRTaXplID0gLTEpIHtcbiAgICAgICAgbGV0IGN1cnNvciA9IG5ldyBTcGFuQ3Vyc29yKHNldHMsIG51bGwsIG1pblBvaW50U2l6ZSkuZ290byhmcm9tKSwgcG9zID0gZnJvbTtcbiAgICAgICAgbGV0IG9wZW5SYW5nZXMgPSBjdXJzb3Iub3BlblN0YXJ0O1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgY3VyVG8gPSBNYXRoLm1pbihjdXJzb3IudG8sIHRvKTtcbiAgICAgICAgICAgIGlmIChjdXJzb3IucG9pbnQpIHtcbiAgICAgICAgICAgICAgICBsZXQgYWN0aXZlID0gY3Vyc29yLmFjdGl2ZUZvclBvaW50KGN1cnNvci50byk7XG4gICAgICAgICAgICAgICAgbGV0IG9wZW5Db3VudCA9IGN1cnNvci5wb2ludEZyb20gPCBmcm9tID8gYWN0aXZlLmxlbmd0aCArIDEgOiBNYXRoLm1pbihhY3RpdmUubGVuZ3RoLCBvcGVuUmFuZ2VzKTtcbiAgICAgICAgICAgICAgICBpdGVyYXRvci5wb2ludChwb3MsIGN1clRvLCBjdXJzb3IucG9pbnQsIGFjdGl2ZSwgb3BlbkNvdW50LCBjdXJzb3IucG9pbnRSYW5rKTtcbiAgICAgICAgICAgICAgICBvcGVuUmFuZ2VzID0gTWF0aC5taW4oY3Vyc29yLm9wZW5FbmQoY3VyVG8pLCBhY3RpdmUubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGN1clRvID4gcG9zKSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0b3Iuc3Bhbihwb3MsIGN1clRvLCBjdXJzb3IuYWN0aXZlLCBvcGVuUmFuZ2VzKTtcbiAgICAgICAgICAgICAgICBvcGVuUmFuZ2VzID0gY3Vyc29yLm9wZW5FbmQoY3VyVG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnNvci50byA+IHRvKVxuICAgICAgICAgICAgICAgIHJldHVybiBvcGVuUmFuZ2VzICsgKGN1cnNvci5wb2ludCAmJiBjdXJzb3IudG8gPiB0byA/IDEgOiAwKTtcbiAgICAgICAgICAgIHBvcyA9IGN1cnNvci50bztcbiAgICAgICAgICAgIGN1cnNvci5uZXh0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgcmFuZ2Ugc2V0IGZvciB0aGUgZ2l2ZW4gcmFuZ2Ugb3IgYXJyYXkgb2YgcmFuZ2VzLiBCeVxuICAgIGRlZmF1bHQsIHRoaXMgZXhwZWN0cyB0aGUgcmFuZ2VzIHRvIGJlIF9zb3J0ZWRfIChieSBzdGFydFxuICAgIHBvc2l0aW9uIGFuZCwgaWYgdHdvIHN0YXJ0IGF0IHRoZSBzYW1lIHBvc2l0aW9uLFxuICAgIGB2YWx1ZS5zdGFydFNpZGVgKS4gWW91IGNhbiBwYXNzIGB0cnVlYCBhcyBzZWNvbmQgYXJndW1lbnQgdG9cbiAgICBjYXVzZSB0aGUgbWV0aG9kIHRvIHNvcnQgdGhlbS5cbiAgICAqL1xuICAgIHN0YXRpYyBvZihyYW5nZXMsIHNvcnQgPSBmYWxzZSkge1xuICAgICAgICBsZXQgYnVpbGQgPSBuZXcgUmFuZ2VTZXRCdWlsZGVyKCk7XG4gICAgICAgIGZvciAobGV0IHJhbmdlIG9mIHJhbmdlcyBpbnN0YW5jZW9mIFJhbmdlID8gW3Jhbmdlc10gOiBzb3J0ID8gbGF6eVNvcnQocmFuZ2VzKSA6IHJhbmdlcylcbiAgICAgICAgICAgIGJ1aWxkLmFkZChyYW5nZS5mcm9tLCByYW5nZS50bywgcmFuZ2UudmFsdWUpO1xuICAgICAgICByZXR1cm4gYnVpbGQuZmluaXNoKCk7XG4gICAgfVxufVxuLyoqXG5UaGUgZW1wdHkgc2V0IG9mIHJhbmdlcy5cbiovXG5SYW5nZVNldC5lbXB0eSA9IC8qQF9fUFVSRV9fKi9uZXcgUmFuZ2VTZXQoW10sIFtdLCBudWxsLCAtMSk7XG5mdW5jdGlvbiBsYXp5U29ydChyYW5nZXMpIHtcbiAgICBpZiAocmFuZ2VzLmxlbmd0aCA+IDEpXG4gICAgICAgIGZvciAobGV0IHByZXYgPSByYW5nZXNbMF0sIGkgPSAxOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY3VyID0gcmFuZ2VzW2ldO1xuICAgICAgICAgICAgaWYgKGNtcFJhbmdlKHByZXYsIGN1cikgPiAwKVxuICAgICAgICAgICAgICAgIHJldHVybiByYW5nZXMuc2xpY2UoKS5zb3J0KGNtcFJhbmdlKTtcbiAgICAgICAgICAgIHByZXYgPSBjdXI7XG4gICAgICAgIH1cbiAgICByZXR1cm4gcmFuZ2VzO1xufVxuUmFuZ2VTZXQuZW1wdHkubmV4dExheWVyID0gUmFuZ2VTZXQuZW1wdHk7XG4vKipcbkEgcmFuZ2Ugc2V0IGJ1aWxkZXIgaXMgYSBkYXRhIHN0cnVjdHVyZSB0aGF0IGhlbHBzIGJ1aWxkIHVwIGFcbltyYW5nZSBzZXRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuUmFuZ2VTZXQpIGRpcmVjdGx5LCB3aXRob3V0IGZpcnN0IGFsbG9jYXRpbmdcbmFuIGFycmF5IG9mIFtgUmFuZ2VgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlJhbmdlKSBvYmplY3RzLlxuKi9cbmNsYXNzIFJhbmdlU2V0QnVpbGRlciB7XG4gICAgZmluaXNoQ2h1bmsobmV3QXJyYXlzKSB7XG4gICAgICAgIHRoaXMuY2h1bmtzLnB1c2gobmV3IENodW5rKHRoaXMuZnJvbSwgdGhpcy50bywgdGhpcy52YWx1ZSwgdGhpcy5tYXhQb2ludCkpO1xuICAgICAgICB0aGlzLmNodW5rUG9zLnB1c2godGhpcy5jaHVua1N0YXJ0KTtcbiAgICAgICAgdGhpcy5jaHVua1N0YXJ0ID0gLTE7XG4gICAgICAgIHRoaXMuc2V0TWF4UG9pbnQgPSBNYXRoLm1heCh0aGlzLnNldE1heFBvaW50LCB0aGlzLm1heFBvaW50KTtcbiAgICAgICAgdGhpcy5tYXhQb2ludCA9IC0xO1xuICAgICAgICBpZiAobmV3QXJyYXlzKSB7XG4gICAgICAgICAgICB0aGlzLmZyb20gPSBbXTtcbiAgICAgICAgICAgIHRoaXMudG8gPSBbXTtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBbXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYW4gZW1wdHkgYnVpbGRlci5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmNodW5rcyA9IFtdO1xuICAgICAgICB0aGlzLmNodW5rUG9zID0gW107XG4gICAgICAgIHRoaXMuY2h1bmtTdGFydCA9IC0xO1xuICAgICAgICB0aGlzLmxhc3QgPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3RGcm9tID0gLTEwMDAwMDAwMDAgLyogQy5GYXIgKi87XG4gICAgICAgIHRoaXMubGFzdFRvID0gLTEwMDAwMDAwMDAgLyogQy5GYXIgKi87XG4gICAgICAgIHRoaXMuZnJvbSA9IFtdO1xuICAgICAgICB0aGlzLnRvID0gW107XG4gICAgICAgIHRoaXMudmFsdWUgPSBbXTtcbiAgICAgICAgdGhpcy5tYXhQb2ludCA9IC0xO1xuICAgICAgICB0aGlzLnNldE1heFBvaW50ID0gLTE7XG4gICAgICAgIHRoaXMubmV4dExheWVyID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgQWRkIGEgcmFuZ2UuIFJhbmdlcyBzaG91bGQgYmUgYWRkZWQgaW4gc29ydGVkIChieSBgZnJvbWAgYW5kXG4gICAgYHZhbHVlLnN0YXJ0U2lkZWApIG9yZGVyLlxuICAgICovXG4gICAgYWRkKGZyb20sIHRvLCB2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMuYWRkSW5uZXIoZnJvbSwgdG8sIHZhbHVlKSlcbiAgICAgICAgICAgICh0aGlzLm5leHRMYXllciB8fCAodGhpcy5uZXh0TGF5ZXIgPSBuZXcgUmFuZ2VTZXRCdWlsZGVyKSkuYWRkKGZyb20sIHRvLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgYWRkSW5uZXIoZnJvbSwgdG8sIHZhbHVlKSB7XG4gICAgICAgIGxldCBkaWZmID0gZnJvbSAtIHRoaXMubGFzdFRvIHx8IHZhbHVlLnN0YXJ0U2lkZSAtIHRoaXMubGFzdC5lbmRTaWRlO1xuICAgICAgICBpZiAoZGlmZiA8PSAwICYmIChmcm9tIC0gdGhpcy5sYXN0RnJvbSB8fCB2YWx1ZS5zdGFydFNpZGUgLSB0aGlzLmxhc3Quc3RhcnRTaWRlKSA8IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSYW5nZXMgbXVzdCBiZSBhZGRlZCBzb3J0ZWQgYnkgYGZyb21gIHBvc2l0aW9uIGFuZCBgc3RhcnRTaWRlYFwiKTtcbiAgICAgICAgaWYgKGRpZmYgPCAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5mcm9tLmxlbmd0aCA9PSAyNTAgLyogQy5DaHVua1NpemUgKi8pXG4gICAgICAgICAgICB0aGlzLmZpbmlzaENodW5rKHRydWUpO1xuICAgICAgICBpZiAodGhpcy5jaHVua1N0YXJ0IDwgMClcbiAgICAgICAgICAgIHRoaXMuY2h1bmtTdGFydCA9IGZyb207XG4gICAgICAgIHRoaXMuZnJvbS5wdXNoKGZyb20gLSB0aGlzLmNodW5rU3RhcnQpO1xuICAgICAgICB0aGlzLnRvLnB1c2godG8gLSB0aGlzLmNodW5rU3RhcnQpO1xuICAgICAgICB0aGlzLmxhc3QgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5sYXN0RnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMubGFzdFRvID0gdG87XG4gICAgICAgIHRoaXMudmFsdWUucHVzaCh2YWx1ZSk7XG4gICAgICAgIGlmICh2YWx1ZS5wb2ludClcbiAgICAgICAgICAgIHRoaXMubWF4UG9pbnQgPSBNYXRoLm1heCh0aGlzLm1heFBvaW50LCB0byAtIGZyb20pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBhZGRDaHVuayhmcm9tLCBjaHVuaykge1xuICAgICAgICBpZiAoKGZyb20gLSB0aGlzLmxhc3RUbyB8fCBjaHVuay52YWx1ZVswXS5zdGFydFNpZGUgLSB0aGlzLmxhc3QuZW5kU2lkZSkgPCAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5mcm9tLmxlbmd0aClcbiAgICAgICAgICAgIHRoaXMuZmluaXNoQ2h1bmsodHJ1ZSk7XG4gICAgICAgIHRoaXMuc2V0TWF4UG9pbnQgPSBNYXRoLm1heCh0aGlzLnNldE1heFBvaW50LCBjaHVuay5tYXhQb2ludCk7XG4gICAgICAgIHRoaXMuY2h1bmtzLnB1c2goY2h1bmspO1xuICAgICAgICB0aGlzLmNodW5rUG9zLnB1c2goZnJvbSk7XG4gICAgICAgIGxldCBsYXN0ID0gY2h1bmsudmFsdWUubGVuZ3RoIC0gMTtcbiAgICAgICAgdGhpcy5sYXN0ID0gY2h1bmsudmFsdWVbbGFzdF07XG4gICAgICAgIHRoaXMubGFzdEZyb20gPSBjaHVuay5mcm9tW2xhc3RdICsgZnJvbTtcbiAgICAgICAgdGhpcy5sYXN0VG8gPSBjaHVuay50b1tsYXN0XSArIGZyb207XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5pc2ggdGhlIHJhbmdlIHNldC4gUmV0dXJucyB0aGUgbmV3IHNldC4gVGhlIGJ1aWxkZXIgY2FuJ3QgYmVcbiAgICB1c2VkIGFueW1vcmUgYWZ0ZXIgdGhpcyBoYXMgYmVlbiBjYWxsZWQuXG4gICAgKi9cbiAgICBmaW5pc2goKSB7IHJldHVybiB0aGlzLmZpbmlzaElubmVyKFJhbmdlU2V0LmVtcHR5KTsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZmluaXNoSW5uZXIobmV4dCkge1xuICAgICAgICBpZiAodGhpcy5mcm9tLmxlbmd0aClcbiAgICAgICAgICAgIHRoaXMuZmluaXNoQ2h1bmsoZmFsc2UpO1xuICAgICAgICBpZiAodGhpcy5jaHVua3MubGVuZ3RoID09IDApXG4gICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFJhbmdlU2V0LmNyZWF0ZSh0aGlzLmNodW5rUG9zLCB0aGlzLmNodW5rcywgdGhpcy5uZXh0TGF5ZXIgPyB0aGlzLm5leHRMYXllci5maW5pc2hJbm5lcihuZXh0KSA6IG5leHQsIHRoaXMuc2V0TWF4UG9pbnQpO1xuICAgICAgICB0aGlzLmZyb20gPSBudWxsOyAvLyBNYWtlIHN1cmUgZnVydGhlciBgYWRkYCBjYWxscyBwcm9kdWNlIGVycm9yc1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZpbmRTaGFyZWRDaHVua3MoYSwgYiwgdGV4dERpZmYpIHtcbiAgICBsZXQgaW5BID0gbmV3IE1hcCgpO1xuICAgIGZvciAobGV0IHNldCBvZiBhKVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldC5jaHVuay5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmIChzZXQuY2h1bmtbaV0ubWF4UG9pbnQgPD0gMClcbiAgICAgICAgICAgICAgICBpbkEuc2V0KHNldC5jaHVua1tpXSwgc2V0LmNodW5rUG9zW2ldKTtcbiAgICBsZXQgc2hhcmVkID0gbmV3IFNldCgpO1xuICAgIGZvciAobGV0IHNldCBvZiBiKVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldC5jaHVuay5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGtub3duID0gaW5BLmdldChzZXQuY2h1bmtbaV0pO1xuICAgICAgICAgICAgaWYgKGtub3duICE9IG51bGwgJiYgKHRleHREaWZmID8gdGV4dERpZmYubWFwUG9zKGtub3duKSA6IGtub3duKSA9PSBzZXQuY2h1bmtQb3NbaV0gJiZcbiAgICAgICAgICAgICAgICAhKHRleHREaWZmID09PSBudWxsIHx8IHRleHREaWZmID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0ZXh0RGlmZi50b3VjaGVzUmFuZ2Uoa25vd24sIGtub3duICsgc2V0LmNodW5rW2ldLmxlbmd0aCkpKVxuICAgICAgICAgICAgICAgIHNoYXJlZC5hZGQoc2V0LmNodW5rW2ldKTtcbiAgICAgICAgfVxuICAgIHJldHVybiBzaGFyZWQ7XG59XG5jbGFzcyBMYXllckN1cnNvciB7XG4gICAgY29uc3RydWN0b3IobGF5ZXIsIHNraXAsIG1pblBvaW50LCByYW5rID0gMCkge1xuICAgICAgICB0aGlzLmxheWVyID0gbGF5ZXI7XG4gICAgICAgIHRoaXMuc2tpcCA9IHNraXA7XG4gICAgICAgIHRoaXMubWluUG9pbnQgPSBtaW5Qb2ludDtcbiAgICAgICAgdGhpcy5yYW5rID0gcmFuaztcbiAgICB9XG4gICAgZ2V0IHN0YXJ0U2lkZSgpIHsgcmV0dXJuIHRoaXMudmFsdWUgPyB0aGlzLnZhbHVlLnN0YXJ0U2lkZSA6IDA7IH1cbiAgICBnZXQgZW5kU2lkZSgpIHsgcmV0dXJuIHRoaXMudmFsdWUgPyB0aGlzLnZhbHVlLmVuZFNpZGUgOiAwOyB9XG4gICAgZ290byhwb3MsIHNpZGUgPSAtMTAwMDAwMDAwMCAvKiBDLkZhciAqLykge1xuICAgICAgICB0aGlzLmNodW5rSW5kZXggPSB0aGlzLnJhbmdlSW5kZXggPSAwO1xuICAgICAgICB0aGlzLmdvdG9Jbm5lcihwb3MsIHNpZGUsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGdvdG9Jbm5lcihwb3MsIHNpZGUsIGZvcndhcmQpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuY2h1bmtJbmRleCA8IHRoaXMubGF5ZXIuY2h1bmsubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IHRoaXMubGF5ZXIuY2h1bmtbdGhpcy5jaHVua0luZGV4XTtcbiAgICAgICAgICAgIGlmICghKHRoaXMuc2tpcCAmJiB0aGlzLnNraXAuaGFzKG5leHQpIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5sYXllci5jaHVua0VuZCh0aGlzLmNodW5rSW5kZXgpIDwgcG9zIHx8XG4gICAgICAgICAgICAgICAgbmV4dC5tYXhQb2ludCA8IHRoaXMubWluUG9pbnQpKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgdGhpcy5jaHVua0luZGV4Kys7XG4gICAgICAgICAgICBmb3J3YXJkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2h1bmtJbmRleCA8IHRoaXMubGF5ZXIuY2h1bmsubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgcmFuZ2VJbmRleCA9IHRoaXMubGF5ZXIuY2h1bmtbdGhpcy5jaHVua0luZGV4XS5maW5kSW5kZXgocG9zIC0gdGhpcy5sYXllci5jaHVua1Bvc1t0aGlzLmNodW5rSW5kZXhdLCBzaWRlLCB0cnVlKTtcbiAgICAgICAgICAgIGlmICghZm9yd2FyZCB8fCB0aGlzLnJhbmdlSW5kZXggPCByYW5nZUluZGV4KVxuICAgICAgICAgICAgICAgIHRoaXMuc2V0UmFuZ2VJbmRleChyYW5nZUluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICB9XG4gICAgZm9yd2FyZChwb3MsIHNpZGUpIHtcbiAgICAgICAgaWYgKCh0aGlzLnRvIC0gcG9zIHx8IHRoaXMuZW5kU2lkZSAtIHNpZGUpIDwgMClcbiAgICAgICAgICAgIHRoaXMuZ290b0lubmVyKHBvcywgc2lkZSwgdHJ1ZSk7XG4gICAgfVxuICAgIG5leHQoKSB7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNodW5rSW5kZXggPT0gdGhpcy5sYXllci5jaHVuay5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZyb20gPSB0aGlzLnRvID0gMTAwMDAwMDAwMCAvKiBDLkZhciAqLztcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBjaHVua1BvcyA9IHRoaXMubGF5ZXIuY2h1bmtQb3NbdGhpcy5jaHVua0luZGV4XSwgY2h1bmsgPSB0aGlzLmxheWVyLmNodW5rW3RoaXMuY2h1bmtJbmRleF07XG4gICAgICAgICAgICAgICAgbGV0IGZyb20gPSBjaHVua1BvcyArIGNodW5rLmZyb21bdGhpcy5yYW5nZUluZGV4XTtcbiAgICAgICAgICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICAgICAgICAgIHRoaXMudG8gPSBjaHVua1BvcyArIGNodW5rLnRvW3RoaXMucmFuZ2VJbmRleF07XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IGNodW5rLnZhbHVlW3RoaXMucmFuZ2VJbmRleF07XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRSYW5nZUluZGV4KHRoaXMucmFuZ2VJbmRleCArIDEpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1pblBvaW50IDwgMCB8fCB0aGlzLnZhbHVlLnBvaW50ICYmIHRoaXMudG8gLSB0aGlzLmZyb20gPj0gdGhpcy5taW5Qb2ludClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0UmFuZ2VJbmRleChpbmRleCkge1xuICAgICAgICBpZiAoaW5kZXggPT0gdGhpcy5sYXllci5jaHVua1t0aGlzLmNodW5rSW5kZXhdLnZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5jaHVua0luZGV4Kys7XG4gICAgICAgICAgICBpZiAodGhpcy5za2lwKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHRoaXMuY2h1bmtJbmRleCA8IHRoaXMubGF5ZXIuY2h1bmsubGVuZ3RoICYmIHRoaXMuc2tpcC5oYXModGhpcy5sYXllci5jaHVua1t0aGlzLmNodW5rSW5kZXhdKSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaHVua0luZGV4Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJhbmdlSW5kZXggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yYW5nZUluZGV4ID0gaW5kZXg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmV4dENodW5rKCkge1xuICAgICAgICB0aGlzLmNodW5rSW5kZXgrKztcbiAgICAgICAgdGhpcy5yYW5nZUluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgfVxuICAgIGNvbXBhcmUob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJvbSAtIG90aGVyLmZyb20gfHwgdGhpcy5zdGFydFNpZGUgLSBvdGhlci5zdGFydFNpZGUgfHwgdGhpcy5yYW5rIC0gb3RoZXIucmFuayB8fFxuICAgICAgICAgICAgdGhpcy50byAtIG90aGVyLnRvIHx8IHRoaXMuZW5kU2lkZSAtIG90aGVyLmVuZFNpZGU7XG4gICAgfVxufVxuY2xhc3MgSGVhcEN1cnNvciB7XG4gICAgY29uc3RydWN0b3IoaGVhcCkge1xuICAgICAgICB0aGlzLmhlYXAgPSBoZWFwO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbShzZXRzLCBza2lwID0gbnVsbCwgbWluUG9pbnQgPSAtMSkge1xuICAgICAgICBsZXQgaGVhcCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IGN1ciA9IHNldHNbaV07ICFjdXIuaXNFbXB0eTsgY3VyID0gY3VyLm5leHRMYXllcikge1xuICAgICAgICAgICAgICAgIGlmIChjdXIubWF4UG9pbnQgPj0gbWluUG9pbnQpXG4gICAgICAgICAgICAgICAgICAgIGhlYXAucHVzaChuZXcgTGF5ZXJDdXJzb3IoY3VyLCBza2lwLCBtaW5Qb2ludCwgaSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZWFwLmxlbmd0aCA9PSAxID8gaGVhcFswXSA6IG5ldyBIZWFwQ3Vyc29yKGhlYXApO1xuICAgIH1cbiAgICBnZXQgc3RhcnRTaWRlKCkgeyByZXR1cm4gdGhpcy52YWx1ZSA/IHRoaXMudmFsdWUuc3RhcnRTaWRlIDogMDsgfVxuICAgIGdvdG8ocG9zLCBzaWRlID0gLTEwMDAwMDAwMDAgLyogQy5GYXIgKi8pIHtcbiAgICAgICAgZm9yIChsZXQgY3VyIG9mIHRoaXMuaGVhcClcbiAgICAgICAgICAgIGN1ci5nb3RvKHBvcywgc2lkZSk7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmhlYXAubGVuZ3RoID4+IDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICAgICAgaGVhcEJ1YmJsZSh0aGlzLmhlYXAsIGkpO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGZvcndhcmQocG9zLCBzaWRlKSB7XG4gICAgICAgIGZvciAobGV0IGN1ciBvZiB0aGlzLmhlYXApXG4gICAgICAgICAgICBjdXIuZm9yd2FyZChwb3MsIHNpZGUpO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5oZWFwLmxlbmd0aCA+PiAxOyBpID49IDA7IGktLSlcbiAgICAgICAgICAgIGhlYXBCdWJibGUodGhpcy5oZWFwLCBpKTtcbiAgICAgICAgaWYgKCh0aGlzLnRvIC0gcG9zIHx8IHRoaXMudmFsdWUuZW5kU2lkZSAtIHNpZGUpIDwgMClcbiAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgIH1cbiAgICBuZXh0KCkge1xuICAgICAgICBpZiAodGhpcy5oZWFwLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmZyb20gPSB0aGlzLnRvID0gMTAwMDAwMDAwMCAvKiBDLkZhciAqLztcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5yYW5rID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgdG9wID0gdGhpcy5oZWFwWzBdO1xuICAgICAgICAgICAgdGhpcy5mcm9tID0gdG9wLmZyb207XG4gICAgICAgICAgICB0aGlzLnRvID0gdG9wLnRvO1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRvcC52YWx1ZTtcbiAgICAgICAgICAgIHRoaXMucmFuayA9IHRvcC5yYW5rO1xuICAgICAgICAgICAgaWYgKHRvcC52YWx1ZSlcbiAgICAgICAgICAgICAgICB0b3AubmV4dCgpO1xuICAgICAgICAgICAgaGVhcEJ1YmJsZSh0aGlzLmhlYXAsIDApO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gaGVhcEJ1YmJsZShoZWFwLCBpbmRleCkge1xuICAgIGZvciAobGV0IGN1ciA9IGhlYXBbaW5kZXhdOzspIHtcbiAgICAgICAgbGV0IGNoaWxkSW5kZXggPSAoaW5kZXggPDwgMSkgKyAxO1xuICAgICAgICBpZiAoY2hpbGRJbmRleCA+PSBoZWFwLmxlbmd0aClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBsZXQgY2hpbGQgPSBoZWFwW2NoaWxkSW5kZXhdO1xuICAgICAgICBpZiAoY2hpbGRJbmRleCArIDEgPCBoZWFwLmxlbmd0aCAmJiBjaGlsZC5jb21wYXJlKGhlYXBbY2hpbGRJbmRleCArIDFdKSA+PSAwKSB7XG4gICAgICAgICAgICBjaGlsZCA9IGhlYXBbY2hpbGRJbmRleCArIDFdO1xuICAgICAgICAgICAgY2hpbGRJbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXIuY29tcGFyZShjaGlsZCkgPCAwKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGhlYXBbY2hpbGRJbmRleF0gPSBjdXI7XG4gICAgICAgIGhlYXBbaW5kZXhdID0gY2hpbGQ7XG4gICAgICAgIGluZGV4ID0gY2hpbGRJbmRleDtcbiAgICB9XG59XG5jbGFzcyBTcGFuQ3Vyc29yIHtcbiAgICBjb25zdHJ1Y3RvcihzZXRzLCBza2lwLCBtaW5Qb2ludCkge1xuICAgICAgICB0aGlzLm1pblBvaW50ID0gbWluUG9pbnQ7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gW107XG4gICAgICAgIHRoaXMuYWN0aXZlVG8gPSBbXTtcbiAgICAgICAgdGhpcy5hY3RpdmVSYW5rID0gW107XG4gICAgICAgIHRoaXMubWluQWN0aXZlID0gLTE7XG4gICAgICAgIC8vIEEgY3VycmVudGx5IGFjdGl2ZSBwb2ludCByYW5nZSwgaWYgYW55XG4gICAgICAgIHRoaXMucG9pbnQgPSBudWxsO1xuICAgICAgICB0aGlzLnBvaW50RnJvbSA9IDA7XG4gICAgICAgIHRoaXMucG9pbnRSYW5rID0gMDtcbiAgICAgICAgdGhpcy50byA9IC0xMDAwMDAwMDAwIC8qIEMuRmFyICovO1xuICAgICAgICB0aGlzLmVuZFNpZGUgPSAwO1xuICAgICAgICAvLyBUaGUgYW1vdW50IG9mIG9wZW4gYWN0aXZlIHJhbmdlcyBhdCB0aGUgc3RhcnQgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAgICAvLyBOb3QgaW5jbHVkaW5nIHBvaW50cy5cbiAgICAgICAgdGhpcy5vcGVuU3RhcnQgPSAtMTtcbiAgICAgICAgdGhpcy5jdXJzb3IgPSBIZWFwQ3Vyc29yLmZyb20oc2V0cywgc2tpcCwgbWluUG9pbnQpO1xuICAgIH1cbiAgICBnb3RvKHBvcywgc2lkZSA9IC0xMDAwMDAwMDAwIC8qIEMuRmFyICovKSB7XG4gICAgICAgIHRoaXMuY3Vyc29yLmdvdG8ocG9zLCBzaWRlKTtcbiAgICAgICAgdGhpcy5hY3RpdmUubGVuZ3RoID0gdGhpcy5hY3RpdmVUby5sZW5ndGggPSB0aGlzLmFjdGl2ZVJhbmsubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5taW5BY3RpdmUgPSAtMTtcbiAgICAgICAgdGhpcy50byA9IHBvcztcbiAgICAgICAgdGhpcy5lbmRTaWRlID0gc2lkZTtcbiAgICAgICAgdGhpcy5vcGVuU3RhcnQgPSAtMTtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBmb3J3YXJkKHBvcywgc2lkZSkge1xuICAgICAgICB3aGlsZSAodGhpcy5taW5BY3RpdmUgPiAtMSAmJiAodGhpcy5hY3RpdmVUb1t0aGlzLm1pbkFjdGl2ZV0gLSBwb3MgfHwgdGhpcy5hY3RpdmVbdGhpcy5taW5BY3RpdmVdLmVuZFNpZGUgLSBzaWRlKSA8IDApXG4gICAgICAgICAgICB0aGlzLnJlbW92ZUFjdGl2ZSh0aGlzLm1pbkFjdGl2ZSk7XG4gICAgICAgIHRoaXMuY3Vyc29yLmZvcndhcmQocG9zLCBzaWRlKTtcbiAgICB9XG4gICAgcmVtb3ZlQWN0aXZlKGluZGV4KSB7XG4gICAgICAgIHJlbW92ZSh0aGlzLmFjdGl2ZSwgaW5kZXgpO1xuICAgICAgICByZW1vdmUodGhpcy5hY3RpdmVUbywgaW5kZXgpO1xuICAgICAgICByZW1vdmUodGhpcy5hY3RpdmVSYW5rLCBpbmRleCk7XG4gICAgICAgIHRoaXMubWluQWN0aXZlID0gZmluZE1pbkluZGV4KHRoaXMuYWN0aXZlLCB0aGlzLmFjdGl2ZVRvKTtcbiAgICB9XG4gICAgYWRkQWN0aXZlKHRyYWNrT3Blbikge1xuICAgICAgICBsZXQgaSA9IDAsIHsgdmFsdWUsIHRvLCByYW5rIH0gPSB0aGlzLmN1cnNvcjtcbiAgICAgICAgd2hpbGUgKGkgPCB0aGlzLmFjdGl2ZVJhbmsubGVuZ3RoICYmIHRoaXMuYWN0aXZlUmFua1tpXSA8PSByYW5rKVxuICAgICAgICAgICAgaSsrO1xuICAgICAgICBpbnNlcnQodGhpcy5hY3RpdmUsIGksIHZhbHVlKTtcbiAgICAgICAgaW5zZXJ0KHRoaXMuYWN0aXZlVG8sIGksIHRvKTtcbiAgICAgICAgaW5zZXJ0KHRoaXMuYWN0aXZlUmFuaywgaSwgcmFuayk7XG4gICAgICAgIGlmICh0cmFja09wZW4pXG4gICAgICAgICAgICBpbnNlcnQodHJhY2tPcGVuLCBpLCB0aGlzLmN1cnNvci5mcm9tKTtcbiAgICAgICAgdGhpcy5taW5BY3RpdmUgPSBmaW5kTWluSW5kZXgodGhpcy5hY3RpdmUsIHRoaXMuYWN0aXZlVG8pO1xuICAgIH1cbiAgICAvLyBBZnRlciBjYWxsaW5nIHRoaXMsIGlmIGB0aGlzLnBvaW50YCAhPSBudWxsLCB0aGUgbmV4dCByYW5nZSBpcyBhXG4gICAgLy8gcG9pbnQuIE90aGVyd2lzZSwgaXQncyBhIHJlZ3VsYXIgcmFuZ2UsIGNvdmVyZWQgYnkgYHRoaXMuYWN0aXZlYC5cbiAgICBuZXh0KCkge1xuICAgICAgICBsZXQgZnJvbSA9IHRoaXMudG8sIHdhc1BvaW50ID0gdGhpcy5wb2ludDtcbiAgICAgICAgdGhpcy5wb2ludCA9IG51bGw7XG4gICAgICAgIGxldCB0cmFja09wZW4gPSB0aGlzLm9wZW5TdGFydCA8IDAgPyBbXSA6IG51bGw7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGxldCBhID0gdGhpcy5taW5BY3RpdmU7XG4gICAgICAgICAgICBpZiAoYSA+IC0xICYmICh0aGlzLmFjdGl2ZVRvW2FdIC0gdGhpcy5jdXJzb3IuZnJvbSB8fCB0aGlzLmFjdGl2ZVthXS5lbmRTaWRlIC0gdGhpcy5jdXJzb3Iuc3RhcnRTaWRlKSA8IDApIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hY3RpdmVUb1thXSA+IGZyb20pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50byA9IHRoaXMuYWN0aXZlVG9bYV07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW5kU2lkZSA9IHRoaXMuYWN0aXZlW2FdLmVuZFNpZGU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUFjdGl2ZShhKTtcbiAgICAgICAgICAgICAgICBpZiAodHJhY2tPcGVuKVxuICAgICAgICAgICAgICAgICAgICByZW1vdmUodHJhY2tPcGVuLCBhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCF0aGlzLmN1cnNvci52YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMudG8gPSB0aGlzLmVuZFNpZGUgPSAxMDAwMDAwMDAwIC8qIEMuRmFyICovO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5jdXJzb3IuZnJvbSA+IGZyb20pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRvID0gdGhpcy5jdXJzb3IuZnJvbTtcbiAgICAgICAgICAgICAgICB0aGlzLmVuZFNpZGUgPSB0aGlzLmN1cnNvci5zdGFydFNpZGU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dFZhbCA9IHRoaXMuY3Vyc29yLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICghbmV4dFZhbC5wb2ludCkgeyAvLyBPcGVuaW5nIGEgcmFuZ2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRBY3RpdmUodHJhY2tPcGVuKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJzb3IubmV4dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh3YXNQb2ludCAmJiB0aGlzLmN1cnNvci50byA9PSB0aGlzLnRvICYmIHRoaXMuY3Vyc29yLmZyb20gPCB0aGlzLmN1cnNvci50bykge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgYW55IG5vbi1lbXB0eSBwb2ludHMgdGhhdCBlbmQgcHJlY2lzZWx5IGF0IHRoZSBlbmQgb2YgdGhlIHByZXYgcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJzb3IubmV4dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHsgLy8gTmV3IHBvaW50XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9pbnQgPSBuZXh0VmFsO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvaW50RnJvbSA9IHRoaXMuY3Vyc29yLmZyb207XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9pbnRSYW5rID0gdGhpcy5jdXJzb3IucmFuaztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50byA9IHRoaXMuY3Vyc29yLnRvO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVuZFNpZGUgPSBuZXh0VmFsLmVuZFNpZGU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yLm5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mb3J3YXJkKHRoaXMudG8sIHRoaXMuZW5kU2lkZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhY2tPcGVuKSB7XG4gICAgICAgICAgICB0aGlzLm9wZW5TdGFydCA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdHJhY2tPcGVuLmxlbmd0aCAtIDE7IGkgPj0gMCAmJiB0cmFja09wZW5baV0gPCBmcm9tOyBpLS0pXG4gICAgICAgICAgICAgICAgdGhpcy5vcGVuU3RhcnQrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICBhY3RpdmVGb3JQb2ludCh0bykge1xuICAgICAgICBpZiAoIXRoaXMuYWN0aXZlLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFjdGl2ZTtcbiAgICAgICAgbGV0IGFjdGl2ZSA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5hY3RpdmUubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFjdGl2ZVJhbmtbaV0gPCB0aGlzLnBvaW50UmFuaylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGlmICh0aGlzLmFjdGl2ZVRvW2ldID4gdG8gfHwgdGhpcy5hY3RpdmVUb1tpXSA9PSB0byAmJiB0aGlzLmFjdGl2ZVtpXS5lbmRTaWRlID49IHRoaXMucG9pbnQuZW5kU2lkZSlcbiAgICAgICAgICAgICAgICBhY3RpdmUucHVzaCh0aGlzLmFjdGl2ZVtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjdGl2ZS5yZXZlcnNlKCk7XG4gICAgfVxuICAgIG9wZW5FbmQodG8pIHtcbiAgICAgICAgbGV0IG9wZW4gPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5hY3RpdmVUby5sZW5ndGggLSAxOyBpID49IDAgJiYgdGhpcy5hY3RpdmVUb1tpXSA+IHRvOyBpLS0pXG4gICAgICAgICAgICBvcGVuKys7XG4gICAgICAgIHJldHVybiBvcGVuO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbXBhcmUoYSwgc3RhcnRBLCBiLCBzdGFydEIsIGxlbmd0aCwgY29tcGFyYXRvcikge1xuICAgIGEuZ290byhzdGFydEEpO1xuICAgIGIuZ290byhzdGFydEIpO1xuICAgIGxldCBlbmRCID0gc3RhcnRCICsgbGVuZ3RoO1xuICAgIGxldCBwb3MgPSBzdGFydEIsIGRQb3MgPSBzdGFydEIgLSBzdGFydEE7XG4gICAgZm9yICg7Oykge1xuICAgICAgICBsZXQgZGlmZiA9IChhLnRvICsgZFBvcykgLSBiLnRvIHx8IGEuZW5kU2lkZSAtIGIuZW5kU2lkZTtcbiAgICAgICAgbGV0IGVuZCA9IGRpZmYgPCAwID8gYS50byArIGRQb3MgOiBiLnRvLCBjbGlwRW5kID0gTWF0aC5taW4oZW5kLCBlbmRCKTtcbiAgICAgICAgaWYgKGEucG9pbnQgfHwgYi5wb2ludCkge1xuICAgICAgICAgICAgaWYgKCEoYS5wb2ludCAmJiBiLnBvaW50ICYmIChhLnBvaW50ID09IGIucG9pbnQgfHwgYS5wb2ludC5lcShiLnBvaW50KSkgJiZcbiAgICAgICAgICAgICAgICBzYW1lVmFsdWVzKGEuYWN0aXZlRm9yUG9pbnQoYS50byksIGIuYWN0aXZlRm9yUG9pbnQoYi50bykpKSlcbiAgICAgICAgICAgICAgICBjb21wYXJhdG9yLmNvbXBhcmVQb2ludChwb3MsIGNsaXBFbmQsIGEucG9pbnQsIGIucG9pbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGNsaXBFbmQgPiBwb3MgJiYgIXNhbWVWYWx1ZXMoYS5hY3RpdmUsIGIuYWN0aXZlKSlcbiAgICAgICAgICAgICAgICBjb21wYXJhdG9yLmNvbXBhcmVSYW5nZShwb3MsIGNsaXBFbmQsIGEuYWN0aXZlLCBiLmFjdGl2ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZCA+IGVuZEIpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgcG9zID0gZW5kO1xuICAgICAgICBpZiAoZGlmZiA8PSAwKVxuICAgICAgICAgICAgYS5uZXh0KCk7XG4gICAgICAgIGlmIChkaWZmID49IDApXG4gICAgICAgICAgICBiLm5leHQoKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzYW1lVmFsdWVzKGEsIGIpIHtcbiAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmIChhW2ldICE9IGJbaV0gJiYgIWFbaV0uZXEoYltpXSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiByZW1vdmUoYXJyYXksIGluZGV4KSB7XG4gICAgZm9yIChsZXQgaSA9IGluZGV4LCBlID0gYXJyYXkubGVuZ3RoIC0gMTsgaSA8IGU7IGkrKylcbiAgICAgICAgYXJyYXlbaV0gPSBhcnJheVtpICsgMV07XG4gICAgYXJyYXkucG9wKCk7XG59XG5mdW5jdGlvbiBpbnNlcnQoYXJyYXksIGluZGV4LCB2YWx1ZSkge1xuICAgIGZvciAobGV0IGkgPSBhcnJheS5sZW5ndGggLSAxOyBpID49IGluZGV4OyBpLS0pXG4gICAgICAgIGFycmF5W2kgKyAxXSA9IGFycmF5W2ldO1xuICAgIGFycmF5W2luZGV4XSA9IHZhbHVlO1xufVxuZnVuY3Rpb24gZmluZE1pbkluZGV4KHZhbHVlLCBhcnJheSkge1xuICAgIGxldCBmb3VuZCA9IC0xLCBmb3VuZFBvcyA9IDEwMDAwMDAwMDAgLyogQy5GYXIgKi87XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKylcbiAgICAgICAgaWYgKChhcnJheVtpXSAtIGZvdW5kUG9zIHx8IHZhbHVlW2ldLmVuZFNpZGUgLSB2YWx1ZVtmb3VuZF0uZW5kU2lkZSkgPCAwKSB7XG4gICAgICAgICAgICBmb3VuZCA9IGk7XG4gICAgICAgICAgICBmb3VuZFBvcyA9IGFycmF5W2ldO1xuICAgICAgICB9XG4gICAgcmV0dXJuIGZvdW5kO1xufVxuXG4vKipcbkNvdW50IHRoZSBjb2x1bW4gcG9zaXRpb24gYXQgdGhlIGdpdmVuIG9mZnNldCBpbnRvIHRoZSBzdHJpbmcsXG50YWtpbmcgZXh0ZW5kaW5nIGNoYXJhY3RlcnMgYW5kIHRhYiBzaXplIGludG8gYWNjb3VudC5cbiovXG5mdW5jdGlvbiBjb3VudENvbHVtbihzdHJpbmcsIHRhYlNpemUsIHRvID0gc3RyaW5nLmxlbmd0aCkge1xuICAgIGxldCBuID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRvOykge1xuICAgICAgICBpZiAoc3RyaW5nLmNoYXJDb2RlQXQoaSkgPT0gOSkge1xuICAgICAgICAgICAgbiArPSB0YWJTaXplIC0gKG4gJSB0YWJTaXplKTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG4rKztcbiAgICAgICAgICAgIGkgPSBmaW5kQ2x1c3RlckJyZWFrKHN0cmluZywgaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG47XG59XG4vKipcbkZpbmQgdGhlIG9mZnNldCB0aGF0IGNvcnJlc3BvbmRzIHRvIHRoZSBnaXZlbiBjb2x1bW4gcG9zaXRpb24gaW4gYVxuc3RyaW5nLCB0YWtpbmcgZXh0ZW5kaW5nIGNoYXJhY3RlcnMgYW5kIHRhYiBzaXplIGludG8gYWNjb3VudC4gQnlcbmRlZmF1bHQsIHRoZSBzdHJpbmcgbGVuZ3RoIGlzIHJldHVybmVkIHdoZW4gaXQgaXMgdG9vIHNob3J0IHRvXG5yZWFjaCB0aGUgY29sdW1uLiBQYXNzIGBzdHJpY3RgIHRydWUgdG8gbWFrZSBpdCByZXR1cm4gLTEgaW4gdGhhdFxuc2l0dWF0aW9uLlxuKi9cbmZ1bmN0aW9uIGZpbmRDb2x1bW4oc3RyaW5nLCBjb2wsIHRhYlNpemUsIHN0cmljdCkge1xuICAgIGZvciAobGV0IGkgPSAwLCBuID0gMDs7KSB7XG4gICAgICAgIGlmIChuID49IGNvbClcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICBpZiAoaSA9PSBzdHJpbmcubGVuZ3RoKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIG4gKz0gc3RyaW5nLmNoYXJDb2RlQXQoaSkgPT0gOSA/IHRhYlNpemUgLSAobiAlIHRhYlNpemUpIDogMTtcbiAgICAgICAgaSA9IGZpbmRDbHVzdGVyQnJlYWsoc3RyaW5nLCBpKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cmljdCA9PT0gdHJ1ZSA/IC0xIDogc3RyaW5nLmxlbmd0aDtcbn1cblxuZXhwb3J0IHsgQW5ub3RhdGlvbiwgQW5ub3RhdGlvblR5cGUsIENoYW5nZURlc2MsIENoYW5nZVNldCwgQ2hhckNhdGVnb3J5LCBDb21wYXJ0bWVudCwgRWRpdG9yU2VsZWN0aW9uLCBFZGl0b3JTdGF0ZSwgRmFjZXQsIExpbmUsIE1hcE1vZGUsIFByZWMsIFJhbmdlLCBSYW5nZVNldCwgUmFuZ2VTZXRCdWlsZGVyLCBSYW5nZVZhbHVlLCBTZWxlY3Rpb25SYW5nZSwgU3RhdGVFZmZlY3QsIFN0YXRlRWZmZWN0VHlwZSwgU3RhdGVGaWVsZCwgVGV4dCwgVHJhbnNhY3Rpb24sIGNvZGVQb2ludEF0LCBjb2RlUG9pbnRTaXplLCBjb21iaW5lQ29uZmlnLCBjb3VudENvbHVtbiwgZmluZENsdXN0ZXJCcmVhaywgZmluZENvbHVtbiwgZnJvbUNvZGVQb2ludCB9O1xuIl0sIm5hbWVzIjpbIlRleHQiLCJsaW5lQXQiLCJwb3MiLCJsZW5ndGgiLCJSYW5nZUVycm9yIiwibGluZUlubmVyIiwibGluZSIsIm4iLCJsaW5lcyIsInJlcGxhY2UiLCJmcm9tIiwidG8iLCJ0ZXh0IiwicGFydHMiLCJkZWNvbXBvc2UiLCJUZXh0Tm9kZSIsImFwcGVuZCIsIm90aGVyIiwic2xpY2UiLCJlcSIsInN0YXJ0Iiwic2NhbklkZW50aWNhbCIsImVuZCIsImEiLCJSYXdUZXh0Q3Vyc29yIiwiYiIsInNraXAiLCJuZXh0IiwibGluZUJyZWFrIiwiZG9uZSIsInZhbHVlIiwiaXRlciIsImRpciIsIml0ZXJSYW5nZSIsIlBhcnRpYWxUZXh0Q3Vyc29yIiwiaXRlckxpbmVzIiwiaW5uZXIiLCJNYXRoIiwibWF4IiwiTGluZUN1cnNvciIsInRvU3RyaW5nIiwic2xpY2VTdHJpbmciLCJ0b0pTT04iLCJmbGF0dGVuIiwiY29uc3RydWN0b3IiLCJvZiIsImVtcHR5IiwiVGV4dExlYWYiLCJzcGxpdCIsInRleHRMZW5ndGgiLCJjaGlsZHJlbiIsInRhcmdldCIsImlzTGluZSIsIm9mZnNldCIsImkiLCJzdHJpbmciLCJMaW5lIiwib3BlbiIsInNsaWNlVGV4dCIsIm1pbiIsInByZXYiLCJwb3AiLCJqb2luZWQiLCJhcHBlbmRUZXh0IiwicHVzaCIsIm1pZCIsIm5ld0xlbiIsImxpbmVTZXAiLCJyZXN1bHQiLCJwYXJ0IiwibGVuIiwiY2hpbGQiLCJlbmRMaW5lIiwiY2hpbGRPcGVuIiwidXBkYXRlZCIsInRvdGFsTGluZXMiLCJjb3B5IiwiaUEiLCJpQiIsImVBIiwiZUIiLCJjaEEiLCJjaEIiLCJyZWR1Y2UiLCJsIiwiY2giLCJmbGF0IiwiY2h1bmsiLCJtYXhDaHVuayIsIm1pbkNodW5rIiwiY2h1bmtlZCIsImN1cnJlbnRMaW5lcyIsImN1cnJlbnRMZW4iLCJjdXJyZW50Q2h1bmsiLCJhZGQiLCJsYXN0Iiwibm9kZSIsImZsdXNoIiwiY29uY2F0IiwiZmlyc3QiLCJub2RlcyIsIm9mZnNldHMiLCJuZXh0SW5uZXIiLCJ0b3AiLCJvZmZzZXRWYWx1ZSIsInNpemUiLCJjdXJzb3IiLCJsaW1pdCIsImFmdGVyQnJlYWsiLCJTeW1ib2wiLCJwcm90b3R5cGUiLCJpdGVyYXRvciIsIm51bWJlciIsImV4dGVuZCIsIm1hcCIsInMiLCJwYXJzZUludCIsImlzRXh0ZW5kaW5nQ2hhciIsImNvZGUiLCJpc1JlZ2lvbmFsSW5kaWNhdG9yIiwiWldKIiwiZmluZENsdXN0ZXJCcmVhayIsInN0ciIsImZvcndhcmQiLCJpbmNsdWRlRXh0ZW5kaW5nIiwibmV4dENsdXN0ZXJCcmVhayIsInByZXZDbHVzdGVyQnJlYWsiLCJzdXJyb2dhdGVMb3ciLCJjaGFyQ29kZUF0Iiwic3Vycm9nYXRlSGlnaCIsImNvZGVQb2ludEF0IiwiY29kZVBvaW50U2l6ZSIsImNvdW50QmVmb3JlIiwiZm91bmQiLCJjb2RlMCIsImNvZGUxIiwiZnJvbUNvZGVQb2ludCIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsIkRlZmF1bHRTcGxpdCIsIk1hcE1vZGUiLCJDaGFuZ2VEZXNjIiwic2VjdGlvbnMiLCJuZXdMZW5ndGgiLCJpbnMiLCJpdGVyR2FwcyIsImYiLCJwb3NBIiwicG9zQiIsIml0ZXJDaGFuZ2VkUmFuZ2VzIiwiaW5kaXZpZHVhbCIsIml0ZXJDaGFuZ2VzIiwiaW52ZXJ0ZWREZXNjIiwiY29tcG9zZURlc2MiLCJjb21wb3NlU2V0cyIsIm1hcERlc2MiLCJiZWZvcmUiLCJtYXBTZXQiLCJtYXBQb3MiLCJhc3NvYyIsIm1vZGUiLCJTaW1wbGUiLCJlbmRBIiwiVHJhY2tEZWwiLCJUcmFja0JlZm9yZSIsIlRyYWNrQWZ0ZXIiLCJ0b3VjaGVzUmFuZ2UiLCJmcm9tSlNPTiIsImpzb24iLCJBcnJheSIsImlzQXJyYXkiLCJzb21lIiwiY3JlYXRlIiwiQ2hhbmdlU2V0IiwiaW5zZXJ0ZWQiLCJhcHBseSIsImRvYyIsImZyb21BIiwidG9BIiwiZnJvbUIiLCJfdG9CIiwiaW52ZXJ0IiwiaW5kZXgiLCJjb21wb3NlIiwiZGVzYyIsImZpbHRlciIsInJhbmdlcyIsInJlc3VsdFNlY3Rpb25zIiwicmVzdWx0SW5zZXJ0ZWQiLCJmaWx0ZXJlZFNlY3Rpb25zIiwiU2VjdGlvbkl0ZXIiLCJhZGRTZWN0aW9uIiwib2ZmIiwiYWRkSW5zZXJ0IiwiY2hhbmdlcyIsImZpbHRlcmVkIiwidG90YWwiLCJmb3JjZSIsInNldCIsInByb2Nlc3MiLCJzcGVjIiwic3ViIiwiaW5zZXJ0IiwiaW5zVGV4dCIsImluc0xlbiIsImUiLCJjcmVhdGVTZXQiLCJmb3JjZUpvaW4iLCJ2YWx1ZXMiLCJlbmRCIiwic2V0QSIsInNldEIiLCJta1NldCIsInBpZWNlIiwibGVmdCIsIkVycm9yIiwibGVuMiIsInNlY3Rpb25MZW4iLCJpbnNCIiwidGV4dEJpdCIsImZvcndhcmQyIiwidW5kZWZpbmVkIiwiU2VsZWN0aW9uUmFuZ2UiLCJmbGFncyIsImFuY2hvciIsImhlYWQiLCJiaWRpTGV2ZWwiLCJsZXZlbCIsImdvYWxDb2x1bW4iLCJjaGFuZ2UiLCJFZGl0b3JTZWxlY3Rpb24iLCJyYW5nZSIsImFicyIsIm1haW5JbmRleCIsInIiLCJtYWluIiwiYXNTaW5nbGUiLCJhZGRSYW5nZSIsInJlcGxhY2VSYW5nZSIsIndoaWNoIiwic2luZ2xlIiwibm9ybWFsaXplZCIsInNvcnQiLCJpbmRleE9mIiwic3BsaWNlIiwiY2hlY2tTZWxlY3Rpb24iLCJzZWxlY3Rpb24iLCJkb2NMZW5ndGgiLCJuZXh0SUQiLCJGYWNldCIsImNvbWJpbmUiLCJjb21wYXJlSW5wdXQiLCJjb21wYXJlIiwiaXNTdGF0aWMiLCJlbmFibGVzIiwiaWQiLCJkZWZhdWx0IiwiZXh0ZW5zaW9ucyIsInJlYWRlciIsImRlZmluZSIsImNvbmZpZyIsInNhbWVBcnJheSIsInN0YXRpYyIsIkZhY2V0UHJvdmlkZXIiLCJjb21wdXRlIiwiZGVwcyIsImdldCIsImNvbXB1dGVOIiwiZmllbGQiLCJ4Iiwic3RhdGUiLCJldmVyeSIsImRlcGVuZGVuY2llcyIsImZhY2V0IiwidHlwZSIsImR5bmFtaWNTbG90IiwiYWRkcmVzc2VzIiwiX2EiLCJnZXR0ZXIiLCJpZHgiLCJtdWx0aSIsImRlcERvYyIsImRlcFNlbCIsImRlcEFkZHJzIiwiZGVwIiwidXBkYXRlIiwidHIiLCJkb2NDaGFuZ2VkIiwiZW5zdXJlQWxsIiwibmV3VmFsIiwiY29tcGFyZUFycmF5IiwicmVjb25maWd1cmUiLCJvbGRTdGF0ZSIsIm9sZEFkZHIiLCJhZGRyZXNzIiwib2xkVmFsIiwiZ2V0QWRkciIsIlN0YXRlRmllbGQiLCJhZGRycyIsImNoYW5nZWQiLCJhZGRyIiwiZW5zdXJlQWRkciIsImR5bmFtaWNGYWNldFNsb3QiLCJwcm92aWRlcnMiLCJwcm92aWRlckFkZHJzIiwicCIsInByb3ZpZGVyVHlwZXMiLCJkeW5hbWljIiwidmFsIiwiZGVwQ2hhbmdlZCIsIm9sZFByb3ZpZGVycyIsImZhY2V0cyIsIm9sZFZhbHVlIiwiaW5pdEZpZWxkIiwiY3JlYXRlRiIsInVwZGF0ZUYiLCJjb21wYXJlRiIsInByb3ZpZGVzIiwicHJvdmlkZSIsImluaXQiLCJmaW5kIiwic2xvdCIsImV4dGVuc2lvbiIsIlByZWNfIiwibG93ZXN0IiwibG93IiwiaGlnaCIsImhpZ2hlc3QiLCJwcmVjIiwiZXh0IiwiUHJlY0V4dGVuc2lvbiIsIlByZWMiLCJDb21wYXJ0bWVudCIsIkNvbXBhcnRtZW50SW5zdGFuY2UiLCJjb250ZW50IiwiY29tcGFydG1lbnQiLCJjb21wYXJ0bWVudHMiLCJDb25maWd1cmF0aW9uIiwiYmFzZSIsImR5bmFtaWNTbG90cyIsInN0YXRpY1ZhbHVlcyIsInN0YXR1c1RlbXBsYXRlIiwic3RhdGljRmFjZXQiLCJyZXNvbHZlIiwiZmllbGRzIiwiT2JqZWN0IiwibmV3Q29tcGFydG1lbnRzIiwiTWFwIiwib2xkRmFjZXRzIiwic2VlbiIsImtub3duIiwiZGVsZXRlIiwiaGFzIiwic3RhdHVzIiwiY29tcHV0ZVNsb3QiLCJsYW5ndWFnZURhdGEiLCJhbGxvd011bHRpcGxlU2VsZWN0aW9ucyIsInYiLCJsaW5lU2VwYXJhdG9yIiwiY2hhbmdlRmlsdGVyIiwidHJhbnNhY3Rpb25GaWx0ZXIiLCJ0cmFuc2FjdGlvbkV4dGVuZGVyIiwicmVhZE9ubHkiLCJBbm5vdGF0aW9uIiwiQW5ub3RhdGlvblR5cGUiLCJTdGF0ZUVmZmVjdFR5cGUiLCJTdGF0ZUVmZmVjdCIsIm1hcHBpbmciLCJtYXBwZWQiLCJpcyIsIm1hcEVmZmVjdHMiLCJlZmZlY3RzIiwiZWZmZWN0IiwiYXBwZW5kQ29uZmlnIiwiVHJhbnNhY3Rpb24iLCJzdGFydFN0YXRlIiwiYW5ub3RhdGlvbnMiLCJzY3JvbGxJbnRvVmlldyIsIl9kb2MiLCJfc3RhdGUiLCJ0aW1lIiwiRGF0ZSIsIm5vdyIsIm5ld0RvYyIsIm5ld1NlbGVjdGlvbiIsImFwcGx5VHJhbnNhY3Rpb24iLCJhbm5vdGF0aW9uIiwiYW5uIiwicmVjb25maWd1cmVkIiwiaXNVc2VyRXZlbnQiLCJldmVudCIsInVzZXJFdmVudCIsImFkZFRvSGlzdG9yeSIsInJlbW90ZSIsImpvaW5SYW5nZXMiLCJtZXJnZVRyYW5zYWN0aW9uIiwic2VxdWVudGlhbCIsIm1hcEZvckEiLCJtYXBGb3JCIiwicmVzb2x2ZVRyYW5zYWN0aW9uSW5uZXIiLCJkb2NTaXplIiwic2VsIiwiYXNBcnJheSIsInJlc29sdmVUcmFuc2FjdGlvbiIsInNwZWNzIiwic2VxIiwiZXh0ZW5kVHJhbnNhY3Rpb24iLCJmaWx0ZXJUcmFuc2FjdGlvbiIsImJhY2siLCJmaWx0ZXJzIiwiZXh0ZW5kZXJzIiwia2V5cyIsIm5vbmUiLCJDaGFyQ2F0ZWdvcnkiLCJub25BU0NJSVNpbmdsZUNhc2VXb3JkQ2hhciIsIndvcmRDaGFyIiwiUmVnRXhwIiwiXyIsImhhc1dvcmRDaGFyIiwidGVzdCIsInRvVXBwZXJDYXNlIiwidG9Mb3dlckNhc2UiLCJtYWtlQ2F0ZWdvcml6ZXIiLCJ3b3JkQ2hhcnMiLCJjaGFyIiwiU3BhY2UiLCJXb3JkIiwiT3RoZXIiLCJFZGl0b3JTdGF0ZSIsInJlcXVpcmUiLCJjb25mIiwiZm9yRWFjaCIsImtleSIsInN0YXJ0VmFsdWVzIiwiaW50ZXJtZWRpYXRlU3RhdGUiLCJyZXBsYWNlU2VsZWN0aW9uIiwidG9UZXh0IiwiY2hhbmdlQnlSYW5nZSIsInJlc3VsdDEiLCJuZXdDaGFuZ2VzIiwibmV3TWFwcGVkIiwiaiIsIm1hcEJ5Iiwic2xpY2VEb2MiLCJwcm9wIiwiZmllbGRJbml0IiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiY29uZmlndXJhdGlvbiIsInRhYlNpemUiLCJwaHJhc2UiLCJwaHJhc2VzIiwibSIsImxhbmd1YWdlRGF0YUF0IiwibmFtZSIsInNpZGUiLCJwcm92aWRlciIsImNoYXJDYXRlZ29yaXplciIsImF0Iiwiam9pbiIsIndvcmRBdCIsImNhdCIsImtBIiwia0IiLCJrIiwiY29tYmluZUNvbmZpZyIsImNvbmZpZ3MiLCJkZWZhdWx0cyIsImN1cnJlbnQiLCJSYW5nZVZhbHVlIiwiUmFuZ2UiLCJzdGFydFNpZGUiLCJlbmRTaWRlIiwicG9pbnQiLCJtYXBNb2RlIiwiY21wUmFuZ2UiLCJDaHVuayIsIm1heFBvaW50IiwiZmluZEluZGV4Iiwic3RhcnRBdCIsImFyciIsImxvIiwiaGkiLCJkaWZmIiwiYmV0d2VlbiIsIm5ld1BvcyIsImN1ckZyb20iLCJjdXJUbyIsIm5ld0Zyb20iLCJuZXdUbyIsIlJhbmdlU2V0IiwiY2h1bmtQb3MiLCJuZXh0TGF5ZXIiLCJjaHVua0VuZCIsImlzRW1wdHkiLCJ1cGRhdGVTcGVjIiwiZmlsdGVyRnJvbSIsImZpbHRlclRvIiwiY3VyIiwiTGF5ZXJDdXJzb3IiLCJnb3RvIiwic3BpbGwiLCJidWlsZGVyIiwiUmFuZ2VTZXRCdWlsZGVyIiwiYWRkSW5uZXIiLCJyYW5nZUluZGV4IiwiY2h1bmtJbmRleCIsImFkZENodW5rIiwibmV4dENodW5rIiwiZmluaXNoSW5uZXIiLCJjaHVua3MiLCJ0b3VjaCIsIkhlYXBDdXJzb3IiLCJzZXRzIiwib2xkU2V0cyIsIm5ld1NldHMiLCJ0ZXh0RGlmZiIsImNvbXBhcmF0b3IiLCJtaW5Qb2ludFNpemUiLCJzaGFyZWRDaHVua3MiLCJmaW5kU2hhcmVkQ2h1bmtzIiwic2lkZUEiLCJTcGFuQ3Vyc29yIiwic2lkZUIiLCJzYW1lVmFsdWVzIiwiYWN0aXZlIiwic3BhbnMiLCJvcGVuUmFuZ2VzIiwib3BlblN0YXJ0IiwiYWN0aXZlRm9yUG9pbnQiLCJvcGVuQ291bnQiLCJwb2ludEZyb20iLCJwb2ludFJhbmsiLCJvcGVuRW5kIiwic3BhbiIsImJ1aWxkIiwibGF6eVNvcnQiLCJmaW5pc2giLCJmaW5pc2hDaHVuayIsIm5ld0FycmF5cyIsImNodW5rU3RhcnQiLCJzZXRNYXhQb2ludCIsImxhc3RGcm9tIiwibGFzdFRvIiwiaW5BIiwic2hhcmVkIiwiU2V0IiwibGF5ZXIiLCJtaW5Qb2ludCIsInJhbmsiLCJnb3RvSW5uZXIiLCJzZXRSYW5nZUluZGV4IiwiaGVhcCIsImhlYXBCdWJibGUiLCJjaGlsZEluZGV4IiwiYWN0aXZlVG8iLCJhY3RpdmVSYW5rIiwibWluQWN0aXZlIiwicmVtb3ZlQWN0aXZlIiwicmVtb3ZlIiwiZmluZE1pbkluZGV4IiwiYWRkQWN0aXZlIiwidHJhY2tPcGVuIiwid2FzUG9pbnQiLCJuZXh0VmFsIiwicmV2ZXJzZSIsInN0YXJ0QSIsInN0YXJ0QiIsImRQb3MiLCJjbGlwRW5kIiwiY29tcGFyZVBvaW50IiwiY29tcGFyZVJhbmdlIiwiYXJyYXkiLCJmb3VuZFBvcyIsImNvdW50Q29sdW1uIiwiZmluZENvbHVtbiIsImNvbCIsInN0cmljdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@codemirror/state/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@codemirror/theme-one-dark/dist/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@codemirror/theme-one-dark/dist/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   color: () => (/* binding */ color),\n/* harmony export */   oneDark: () => (/* binding */ oneDark),\n/* harmony export */   oneDarkHighlightStyle: () => (/* binding */ oneDarkHighlightStyle),\n/* harmony export */   oneDarkTheme: () => (/* binding */ oneDarkTheme)\n/* harmony export */ });\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/view */ \"(ssr)/./node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _codemirror_language__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/language */ \"(ssr)/./node_modules/@codemirror/language/dist/index.js\");\n/* harmony import */ var _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/highlight */ \"(ssr)/./node_modules/@lezer/highlight/dist/index.js\");\n\n\n\n// Using https://github.com/one-dark/vscode-one-dark-theme/ as reference for the colors\nconst chalky = \"#e5c07b\", coral = \"#e06c75\", cyan = \"#56b6c2\", invalid = \"#ffffff\", ivory = \"#abb2bf\", stone = \"#7d8799\", malibu = \"#61afef\", sage = \"#98c379\", whiskey = \"#d19a66\", violet = \"#c678dd\", darkBackground = \"#21252b\", highlightBackground = \"#2c313a\", background = \"#282c34\", tooltipBackground = \"#353a42\", selection = \"#3E4451\", cursor = \"#528bff\";\n/**\nThe colors used in the theme, as CSS color strings.\n*/ const color = {\n    chalky,\n    coral,\n    cyan,\n    invalid,\n    ivory,\n    stone,\n    malibu,\n    sage,\n    whiskey,\n    violet,\n    darkBackground,\n    highlightBackground,\n    background,\n    tooltipBackground,\n    selection,\n    cursor\n};\n/**\nThe editor theme styles for One Dark.\n*/ const oneDarkTheme = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.EditorView.theme({\n    \"&\": {\n        color: ivory,\n        backgroundColor: background\n    },\n    \".cm-content\": {\n        caretColor: cursor\n    },\n    \".cm-cursor, .cm-dropCursor\": {\n        borderLeftColor: cursor\n    },\n    \"&.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection\": {\n        backgroundColor: selection\n    },\n    \".cm-panels\": {\n        backgroundColor: darkBackground,\n        color: ivory\n    },\n    \".cm-panels.cm-panels-top\": {\n        borderBottom: \"2px solid black\"\n    },\n    \".cm-panels.cm-panels-bottom\": {\n        borderTop: \"2px solid black\"\n    },\n    \".cm-searchMatch\": {\n        backgroundColor: \"#72a1ff59\",\n        outline: \"1px solid #457dff\"\n    },\n    \".cm-searchMatch.cm-searchMatch-selected\": {\n        backgroundColor: \"#6199ff2f\"\n    },\n    \".cm-activeLine\": {\n        backgroundColor: \"#6699ff0b\"\n    },\n    \".cm-selectionMatch\": {\n        backgroundColor: \"#aafe661a\"\n    },\n    \"&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket\": {\n        backgroundColor: \"#bad0f847\"\n    },\n    \".cm-gutters\": {\n        backgroundColor: background,\n        color: stone,\n        border: \"none\"\n    },\n    \".cm-activeLineGutter\": {\n        backgroundColor: highlightBackground\n    },\n    \".cm-foldPlaceholder\": {\n        backgroundColor: \"transparent\",\n        border: \"none\",\n        color: \"#ddd\"\n    },\n    \".cm-tooltip\": {\n        border: \"none\",\n        backgroundColor: tooltipBackground\n    },\n    \".cm-tooltip .cm-tooltip-arrow:before\": {\n        borderTopColor: \"transparent\",\n        borderBottomColor: \"transparent\"\n    },\n    \".cm-tooltip .cm-tooltip-arrow:after\": {\n        borderTopColor: tooltipBackground,\n        borderBottomColor: tooltipBackground\n    },\n    \".cm-tooltip-autocomplete\": {\n        \"& > ul > li[aria-selected]\": {\n            backgroundColor: highlightBackground,\n            color: ivory\n        }\n    }\n}, {\n    dark: true\n});\n/**\nThe highlighting style for code in the One Dark theme.\n*/ const oneDarkHighlightStyle = /*@__PURE__*/ _codemirror_language__WEBPACK_IMPORTED_MODULE_2__.HighlightStyle.define([\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.keyword,\n        color: violet\n    },\n    {\n        tag: [\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.name,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.deleted,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.character,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.propertyName,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.macroName\n        ],\n        color: coral\n    },\n    {\n        tag: [\n            /*@__PURE__*/ _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.function(_lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.variableName),\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.labelName\n        ],\n        color: malibu\n    },\n    {\n        tag: [\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.color,\n            /*@__PURE__*/ _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.constant(_lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.name),\n            /*@__PURE__*/ _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.standard(_lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.name)\n        ],\n        color: whiskey\n    },\n    {\n        tag: [\n            /*@__PURE__*/ _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.definition(_lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.name),\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.separator\n        ],\n        color: ivory\n    },\n    {\n        tag: [\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.typeName,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.className,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.number,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.changed,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.annotation,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.modifier,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.self,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.namespace\n        ],\n        color: chalky\n    },\n    {\n        tag: [\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.operator,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.operatorKeyword,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.url,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.escape,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.regexp,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.link,\n            /*@__PURE__*/ _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.special(_lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.string)\n        ],\n        color: cyan\n    },\n    {\n        tag: [\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.meta,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.comment\n        ],\n        color: stone\n    },\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.strong,\n        fontWeight: \"bold\"\n    },\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.emphasis,\n        fontStyle: \"italic\"\n    },\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.strikethrough,\n        textDecoration: \"line-through\"\n    },\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.link,\n        color: stone,\n        textDecoration: \"underline\"\n    },\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.heading,\n        fontWeight: \"bold\",\n        color: coral\n    },\n    {\n        tag: [\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.atom,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.bool,\n            /*@__PURE__*/ _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.special(_lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.variableName)\n        ],\n        color: whiskey\n    },\n    {\n        tag: [\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.processingInstruction,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.string,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.inserted\n        ],\n        color: sage\n    },\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.invalid,\n        color: invalid\n    }\n]);\n/**\nExtension to enable the One Dark theme (both the editor theme and\nthe highlight style).\n*/ const oneDark = [\n    oneDarkTheme,\n    /*@__PURE__*/ (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_2__.syntaxHighlighting)(oneDarkHighlightStyle)\n];\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvdGhlbWUtb25lLWRhcmsvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQThDO0FBQzRCO0FBQ2xDO0FBRXhDLHVGQUF1RjtBQUN2RixNQUFNSSxTQUFTLFdBQVdDLFFBQVEsV0FBV0MsT0FBTyxXQUFXQyxVQUFVLFdBQVdDLFFBQVEsV0FBV0MsUUFBUSxXQUMvR0MsU0FBUyxXQUFXQyxPQUFPLFdBQVdDLFVBQVUsV0FBV0MsU0FBUyxXQUFXQyxpQkFBaUIsV0FBV0Msc0JBQXNCLFdBQVdDLGFBQWEsV0FBV0Msb0JBQW9CLFdBQVdDLFlBQVksV0FBV0MsU0FBUztBQUNuTzs7QUFFQSxHQUNBLE1BQU1DLFFBQVE7SUFDVmhCO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0FBQ0o7QUFDQTs7QUFFQSxHQUNBLE1BQU1FLGVBQWUsV0FBVyxHQUFFckIsd0RBQVVBLENBQUNzQixLQUFLLENBQUM7SUFDL0MsS0FBSztRQUNERixPQUFPWjtRQUNQZSxpQkFBaUJQO0lBQ3JCO0lBQ0EsZUFBZTtRQUNYUSxZQUFZTDtJQUNoQjtJQUNBLDhCQUE4QjtRQUFFTSxpQkFBaUJOO0lBQU87SUFDeEQsOEhBQThIO1FBQUVJLGlCQUFpQkw7SUFBVTtJQUMzSixjQUFjO1FBQUVLLGlCQUFpQlQ7UUFBZ0JNLE9BQU9aO0lBQU07SUFDOUQsNEJBQTRCO1FBQUVrQixjQUFjO0lBQWtCO0lBQzlELCtCQUErQjtRQUFFQyxXQUFXO0lBQWtCO0lBQzlELG1CQUFtQjtRQUNmSixpQkFBaUI7UUFDakJLLFNBQVM7SUFDYjtJQUNBLDJDQUEyQztRQUN2Q0wsaUJBQWlCO0lBQ3JCO0lBQ0Esa0JBQWtCO1FBQUVBLGlCQUFpQjtJQUFZO0lBQ2pELHNCQUFzQjtRQUFFQSxpQkFBaUI7SUFBWTtJQUNyRCx5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Q3ZCO1FBQUVqQyxLQUFLaEMsa0RBQUlBLENBQUNrRSxRQUFRO1FBQ2hCQyxXQUFXO0lBQVM7SUFDeEI7UUFBRW5DLEtBQUtoQyxrREFBSUEsQ0FBQ29FLGFBQWE7UUFDckJDLGdCQUFnQjtJQUFlO0lBQ25DO1FBQUVyQyxLQUFLaEMsa0RBQUlBLENBQUMyRCxJQUFJO1FBQ1oxQyxPQUFPWDtRQUNQK0QsZ0JBQWdCO0lBQVk7SUFDaEM7UUFBRXJDLEtBQUtoQyxrREFBSUEsQ0FBQ3NFLE9BQU87UUFDZkwsWUFBWTtRQUNaaEQsT0FBT2Y7SUFBTTtJQUNqQjtRQUFFOEIsS0FBSztZQUFDaEMsa0RBQUlBLENBQUN1RSxJQUFJO1lBQUV2RSxrREFBSUEsQ0FBQ3dFLElBQUk7WUFBRSxXQUFXLEdBQUV4RSxrREFBSUEsQ0FBQzRELE9BQU8sQ0FBQzVELGtEQUFJQSxDQUFDd0MsWUFBWTtTQUFFO1FBQ3ZFdkIsT0FBT1I7SUFBUTtJQUNuQjtRQUFFdUIsS0FBSztZQUFDaEMsa0RBQUlBLENBQUN5RSxxQkFBcUI7WUFBRXpFLGtEQUFJQSxDQUFDNkQsTUFBTTtZQUFFN0Qsa0RBQUlBLENBQUMwRSxRQUFRO1NBQUM7UUFDM0R6RCxPQUFPVDtJQUFLO0lBQ2hCO1FBQUV3QixLQUFLaEMsa0RBQUlBLENBQUNJLE9BQU87UUFDZmEsT0FBT2I7SUFBUTtDQUN0QjtBQUNEOzs7QUFHQSxHQUNBLE1BQU11RSxVQUFVO0lBQUN6RDtJQUFjLFdBQVcsR0FBRW5CLHdFQUFrQkEsQ0FBQytCO0NBQXVCO0FBRXZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHl0aG9uLW9ubGluZS1lZGl0b3IvLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvdGhlbWUtb25lLWRhcmsvZGlzdC9pbmRleC5qcz9iNzhkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEVkaXRvclZpZXcgfSBmcm9tICdAY29kZW1pcnJvci92aWV3JztcbmltcG9ydCB7IEhpZ2hsaWdodFN0eWxlLCBzeW50YXhIaWdobGlnaHRpbmcgfSBmcm9tICdAY29kZW1pcnJvci9sYW5ndWFnZSc7XG5pbXBvcnQgeyB0YWdzIH0gZnJvbSAnQGxlemVyL2hpZ2hsaWdodCc7XG5cbi8vIFVzaW5nIGh0dHBzOi8vZ2l0aHViLmNvbS9vbmUtZGFyay92c2NvZGUtb25lLWRhcmstdGhlbWUvIGFzIHJlZmVyZW5jZSBmb3IgdGhlIGNvbG9yc1xuY29uc3QgY2hhbGt5ID0gXCIjZTVjMDdiXCIsIGNvcmFsID0gXCIjZTA2Yzc1XCIsIGN5YW4gPSBcIiM1NmI2YzJcIiwgaW52YWxpZCA9IFwiI2ZmZmZmZlwiLCBpdm9yeSA9IFwiI2FiYjJiZlwiLCBzdG9uZSA9IFwiIzdkODc5OVwiLCAvLyBCcmlnaHRlbmVkIGNvbXBhcmVkIHRvIG9yaWdpbmFsIHRvIGluY3JlYXNlIGNvbnRyYXN0XG5tYWxpYnUgPSBcIiM2MWFmZWZcIiwgc2FnZSA9IFwiIzk4YzM3OVwiLCB3aGlza2V5ID0gXCIjZDE5YTY2XCIsIHZpb2xldCA9IFwiI2M2NzhkZFwiLCBkYXJrQmFja2dyb3VuZCA9IFwiIzIxMjUyYlwiLCBoaWdobGlnaHRCYWNrZ3JvdW5kID0gXCIjMmMzMTNhXCIsIGJhY2tncm91bmQgPSBcIiMyODJjMzRcIiwgdG9vbHRpcEJhY2tncm91bmQgPSBcIiMzNTNhNDJcIiwgc2VsZWN0aW9uID0gXCIjM0U0NDUxXCIsIGN1cnNvciA9IFwiIzUyOGJmZlwiO1xuLyoqXG5UaGUgY29sb3JzIHVzZWQgaW4gdGhlIHRoZW1lLCBhcyBDU1MgY29sb3Igc3RyaW5ncy5cbiovXG5jb25zdCBjb2xvciA9IHtcbiAgICBjaGFsa3ksXG4gICAgY29yYWwsXG4gICAgY3lhbixcbiAgICBpbnZhbGlkLFxuICAgIGl2b3J5LFxuICAgIHN0b25lLFxuICAgIG1hbGlidSxcbiAgICBzYWdlLFxuICAgIHdoaXNrZXksXG4gICAgdmlvbGV0LFxuICAgIGRhcmtCYWNrZ3JvdW5kLFxuICAgIGhpZ2hsaWdodEJhY2tncm91bmQsXG4gICAgYmFja2dyb3VuZCxcbiAgICB0b29sdGlwQmFja2dyb3VuZCxcbiAgICBzZWxlY3Rpb24sXG4gICAgY3Vyc29yXG59O1xuLyoqXG5UaGUgZWRpdG9yIHRoZW1lIHN0eWxlcyBmb3IgT25lIERhcmsuXG4qL1xuY29uc3Qgb25lRGFya1RoZW1lID0gLypAX19QVVJFX18qL0VkaXRvclZpZXcudGhlbWUoe1xuICAgIFwiJlwiOiB7XG4gICAgICAgIGNvbG9yOiBpdm9yeSxcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBiYWNrZ3JvdW5kXG4gICAgfSxcbiAgICBcIi5jbS1jb250ZW50XCI6IHtcbiAgICAgICAgY2FyZXRDb2xvcjogY3Vyc29yXG4gICAgfSxcbiAgICBcIi5jbS1jdXJzb3IsIC5jbS1kcm9wQ3Vyc29yXCI6IHsgYm9yZGVyTGVmdENvbG9yOiBjdXJzb3IgfSxcbiAgICBcIiYuY20tZm9jdXNlZCA+IC5jbS1zY3JvbGxlciA+IC5jbS1zZWxlY3Rpb25MYXllciAuY20tc2VsZWN0aW9uQmFja2dyb3VuZCwgLmNtLXNlbGVjdGlvbkJhY2tncm91bmQsIC5jbS1jb250ZW50IDo6c2VsZWN0aW9uXCI6IHsgYmFja2dyb3VuZENvbG9yOiBzZWxlY3Rpb24gfSxcbiAgICBcIi5jbS1wYW5lbHNcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IGRhcmtCYWNrZ3JvdW5kLCBjb2xvcjogaXZvcnkgfSxcbiAgICBcIi5jbS1wYW5lbHMuY20tcGFuZWxzLXRvcFwiOiB7IGJvcmRlckJvdHRvbTogXCIycHggc29saWQgYmxhY2tcIiB9LFxuICAgIFwiLmNtLXBhbmVscy5jbS1wYW5lbHMtYm90dG9tXCI6IHsgYm9yZGVyVG9wOiBcIjJweCBzb2xpZCBibGFja1wiIH0sXG4gICAgXCIuY20tc2VhcmNoTWF0Y2hcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiIzcyYTFmZjU5XCIsXG4gICAgICAgIG91dGxpbmU6IFwiMXB4IHNvbGlkICM0NTdkZmZcIlxuICAgIH0sXG4gICAgXCIuY20tc2VhcmNoTWF0Y2guY20tc2VhcmNoTWF0Y2gtc2VsZWN0ZWRcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiIzYxOTlmZjJmXCJcbiAgICB9LFxuICAgIFwiLmNtLWFjdGl2ZUxpbmVcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwiIzY2OTlmZjBiXCIgfSxcbiAgICBcIi5jbS1zZWxlY3Rpb25NYXRjaFwiOiB7IGJhY2tncm91bmRDb2xvcjogXCIjYWFmZTY2MWFcIiB9LFxuICAgIFwiJi5jbS1mb2N1c2VkIC5jbS1tYXRjaGluZ0JyYWNrZXQsICYuY20tZm9jdXNlZCAuY20tbm9ubWF0Y2hpbmdCcmFja2V0XCI6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiNiYWQwZjg0N1wiXG4gICAgfSxcbiAgICBcIi5jbS1ndXR0ZXJzXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBiYWNrZ3JvdW5kLFxuICAgICAgICBjb2xvcjogc3RvbmUsXG4gICAgICAgIGJvcmRlcjogXCJub25lXCJcbiAgICB9LFxuICAgIFwiLmNtLWFjdGl2ZUxpbmVHdXR0ZXJcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGhpZ2hsaWdodEJhY2tncm91bmRcbiAgICB9LFxuICAgIFwiLmNtLWZvbGRQbGFjZWhvbGRlclwiOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCJ0cmFuc3BhcmVudFwiLFxuICAgICAgICBib3JkZXI6IFwibm9uZVwiLFxuICAgICAgICBjb2xvcjogXCIjZGRkXCJcbiAgICB9LFxuICAgIFwiLmNtLXRvb2x0aXBcIjoge1xuICAgICAgICBib3JkZXI6IFwibm9uZVwiLFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRvb2x0aXBCYWNrZ3JvdW5kXG4gICAgfSxcbiAgICBcIi5jbS10b29sdGlwIC5jbS10b29sdGlwLWFycm93OmJlZm9yZVwiOiB7XG4gICAgICAgIGJvcmRlclRvcENvbG9yOiBcInRyYW5zcGFyZW50XCIsXG4gICAgICAgIGJvcmRlckJvdHRvbUNvbG9yOiBcInRyYW5zcGFyZW50XCJcbiAgICB9LFxuICAgIFwiLmNtLXRvb2x0aXAgLmNtLXRvb2x0aXAtYXJyb3c6YWZ0ZXJcIjoge1xuICAgICAgICBib3JkZXJUb3BDb2xvcjogdG9vbHRpcEJhY2tncm91bmQsXG4gICAgICAgIGJvcmRlckJvdHRvbUNvbG9yOiB0b29sdGlwQmFja2dyb3VuZFxuICAgIH0sXG4gICAgXCIuY20tdG9vbHRpcC1hdXRvY29tcGxldGVcIjoge1xuICAgICAgICBcIiYgPiB1bCA+IGxpW2FyaWEtc2VsZWN0ZWRdXCI6IHtcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogaGlnaGxpZ2h0QmFja2dyb3VuZCxcbiAgICAgICAgICAgIGNvbG9yOiBpdm9yeVxuICAgICAgICB9XG4gICAgfVxufSwgeyBkYXJrOiB0cnVlIH0pO1xuLyoqXG5UaGUgaGlnaGxpZ2h0aW5nIHN0eWxlIGZvciBjb2RlIGluIHRoZSBPbmUgRGFyayB0aGVtZS5cbiovXG5jb25zdCBvbmVEYXJrSGlnaGxpZ2h0U3R5bGUgPSAvKkBfX1BVUkVfXyovSGlnaGxpZ2h0U3R5bGUuZGVmaW5lKFtcbiAgICB7IHRhZzogdGFncy5rZXl3b3JkLFxuICAgICAgICBjb2xvcjogdmlvbGV0IH0sXG4gICAgeyB0YWc6IFt0YWdzLm5hbWUsIHRhZ3MuZGVsZXRlZCwgdGFncy5jaGFyYWN0ZXIsIHRhZ3MucHJvcGVydHlOYW1lLCB0YWdzLm1hY3JvTmFtZV0sXG4gICAgICAgIGNvbG9yOiBjb3JhbCB9LFxuICAgIHsgdGFnOiBbLypAX19QVVJFX18qL3RhZ3MuZnVuY3Rpb24odGFncy52YXJpYWJsZU5hbWUpLCB0YWdzLmxhYmVsTmFtZV0sXG4gICAgICAgIGNvbG9yOiBtYWxpYnUgfSxcbiAgICB7IHRhZzogW3RhZ3MuY29sb3IsIC8qQF9fUFVSRV9fKi90YWdzLmNvbnN0YW50KHRhZ3MubmFtZSksIC8qQF9fUFVSRV9fKi90YWdzLnN0YW5kYXJkKHRhZ3MubmFtZSldLFxuICAgICAgICBjb2xvcjogd2hpc2tleSB9LFxuICAgIHsgdGFnOiBbLypAX19QVVJFX18qL3RhZ3MuZGVmaW5pdGlvbih0YWdzLm5hbWUpLCB0YWdzLnNlcGFyYXRvcl0sXG4gICAgICAgIGNvbG9yOiBpdm9yeSB9LFxuICAgIHsgdGFnOiBbdGFncy50eXBlTmFtZSwgdGFncy5jbGFzc05hbWUsIHRhZ3MubnVtYmVyLCB0YWdzLmNoYW5nZWQsIHRhZ3MuYW5ub3RhdGlvbiwgdGFncy5tb2RpZmllciwgdGFncy5zZWxmLCB0YWdzLm5hbWVzcGFjZV0sXG4gICAgICAgIGNvbG9yOiBjaGFsa3kgfSxcbiAgICB7IHRhZzogW3RhZ3Mub3BlcmF0b3IsIHRhZ3Mub3BlcmF0b3JLZXl3b3JkLCB0YWdzLnVybCwgdGFncy5lc2NhcGUsIHRhZ3MucmVnZXhwLCB0YWdzLmxpbmssIC8qQF9fUFVSRV9fKi90YWdzLnNwZWNpYWwodGFncy5zdHJpbmcpXSxcbiAgICAgICAgY29sb3I6IGN5YW4gfSxcbiAgICB7IHRhZzogW3RhZ3MubWV0YSwgdGFncy5jb21tZW50XSxcbiAgICAgICAgY29sb3I6IHN0b25lIH0sXG4gICAgeyB0YWc6IHRhZ3Muc3Ryb25nLFxuICAgICAgICBmb250V2VpZ2h0OiBcImJvbGRcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmVtcGhhc2lzLFxuICAgICAgICBmb250U3R5bGU6IFwiaXRhbGljXCIgfSxcbiAgICB7IHRhZzogdGFncy5zdHJpa2V0aHJvdWdoLFxuICAgICAgICB0ZXh0RGVjb3JhdGlvbjogXCJsaW5lLXRocm91Z2hcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmxpbmssXG4gICAgICAgIGNvbG9yOiBzdG9uZSxcbiAgICAgICAgdGV4dERlY29yYXRpb246IFwidW5kZXJsaW5lXCIgfSxcbiAgICB7IHRhZzogdGFncy5oZWFkaW5nLFxuICAgICAgICBmb250V2VpZ2h0OiBcImJvbGRcIixcbiAgICAgICAgY29sb3I6IGNvcmFsIH0sXG4gICAgeyB0YWc6IFt0YWdzLmF0b20sIHRhZ3MuYm9vbCwgLypAX19QVVJFX18qL3RhZ3Muc3BlY2lhbCh0YWdzLnZhcmlhYmxlTmFtZSldLFxuICAgICAgICBjb2xvcjogd2hpc2tleSB9LFxuICAgIHsgdGFnOiBbdGFncy5wcm9jZXNzaW5nSW5zdHJ1Y3Rpb24sIHRhZ3Muc3RyaW5nLCB0YWdzLmluc2VydGVkXSxcbiAgICAgICAgY29sb3I6IHNhZ2UgfSxcbiAgICB7IHRhZzogdGFncy5pbnZhbGlkLFxuICAgICAgICBjb2xvcjogaW52YWxpZCB9LFxuXSk7XG4vKipcbkV4dGVuc2lvbiB0byBlbmFibGUgdGhlIE9uZSBEYXJrIHRoZW1lIChib3RoIHRoZSBlZGl0b3IgdGhlbWUgYW5kXG50aGUgaGlnaGxpZ2h0IHN0eWxlKS5cbiovXG5jb25zdCBvbmVEYXJrID0gW29uZURhcmtUaGVtZSwgLypAX19QVVJFX18qL3N5bnRheEhpZ2hsaWdodGluZyhvbmVEYXJrSGlnaGxpZ2h0U3R5bGUpXTtcblxuZXhwb3J0IHsgY29sb3IsIG9uZURhcmssIG9uZURhcmtIaWdobGlnaHRTdHlsZSwgb25lRGFya1RoZW1lIH07XG4iXSwibmFtZXMiOlsiRWRpdG9yVmlldyIsIkhpZ2hsaWdodFN0eWxlIiwic3ludGF4SGlnaGxpZ2h0aW5nIiwidGFncyIsImNoYWxreSIsImNvcmFsIiwiY3lhbiIsImludmFsaWQiLCJpdm9yeSIsInN0b25lIiwibWFsaWJ1Iiwic2FnZSIsIndoaXNrZXkiLCJ2aW9sZXQiLCJkYXJrQmFja2dyb3VuZCIsImhpZ2hsaWdodEJhY2tncm91bmQiLCJiYWNrZ3JvdW5kIiwidG9vbHRpcEJhY2tncm91bmQiLCJzZWxlY3Rpb24iLCJjdXJzb3IiLCJjb2xvciIsIm9uZURhcmtUaGVtZSIsInRoZW1lIiwiYmFja2dyb3VuZENvbG9yIiwiY2FyZXRDb2xvciIsImJvcmRlckxlZnRDb2xvciIsImJvcmRlckJvdHRvbSIsImJvcmRlclRvcCIsIm91dGxpbmUiLCJib3JkZXIiLCJib3JkZXJUb3BDb2xvciIsImJvcmRlckJvdHRvbUNvbG9yIiwiZGFyayIsIm9uZURhcmtIaWdobGlnaHRTdHlsZSIsImRlZmluZSIsInRhZyIsImtleXdvcmQiLCJuYW1lIiwiZGVsZXRlZCIsImNoYXJhY3RlciIsInByb3BlcnR5TmFtZSIsIm1hY3JvTmFtZSIsImZ1bmN0aW9uIiwidmFyaWFibGVOYW1lIiwibGFiZWxOYW1lIiwiY29uc3RhbnQiLCJzdGFuZGFyZCIsImRlZmluaXRpb24iLCJzZXBhcmF0b3IiLCJ0eXBlTmFtZSIsImNsYXNzTmFtZSIsIm51bWJlciIsImNoYW5nZWQiLCJhbm5vdGF0aW9uIiwibW9kaWZpZXIiLCJzZWxmIiwibmFtZXNwYWNlIiwib3BlcmF0b3IiLCJvcGVyYXRvcktleXdvcmQiLCJ1cmwiLCJlc2NhcGUiLCJyZWdleHAiLCJsaW5rIiwic3BlY2lhbCIsInN0cmluZyIsIm1ldGEiLCJjb21tZW50Iiwic3Ryb25nIiwiZm9udFdlaWdodCIsImVtcGhhc2lzIiwiZm9udFN0eWxlIiwic3RyaWtldGhyb3VnaCIsInRleHREZWNvcmF0aW9uIiwiaGVhZGluZyIsImF0b20iLCJib29sIiwicHJvY2Vzc2luZ0luc3RydWN0aW9uIiwiaW5zZXJ0ZWQiLCJvbmVEYXJrIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@codemirror/theme-one-dark/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@codemirror/view/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@codemirror/view/dist/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BidiSpan: () => (/* binding */ BidiSpan),\n/* harmony export */   BlockInfo: () => (/* binding */ BlockInfo),\n/* harmony export */   BlockType: () => (/* binding */ BlockType),\n/* harmony export */   Decoration: () => (/* binding */ Decoration),\n/* harmony export */   Direction: () => (/* binding */ Direction),\n/* harmony export */   EditorView: () => (/* binding */ EditorView),\n/* harmony export */   GutterMarker: () => (/* binding */ GutterMarker),\n/* harmony export */   MatchDecorator: () => (/* binding */ MatchDecorator),\n/* harmony export */   RectangleMarker: () => (/* binding */ RectangleMarker),\n/* harmony export */   ViewPlugin: () => (/* binding */ ViewPlugin),\n/* harmony export */   ViewUpdate: () => (/* binding */ ViewUpdate),\n/* harmony export */   WidgetType: () => (/* binding */ WidgetType),\n/* harmony export */   __test: () => (/* binding */ __test),\n/* harmony export */   closeHoverTooltips: () => (/* binding */ closeHoverTooltips),\n/* harmony export */   crosshairCursor: () => (/* binding */ crosshairCursor),\n/* harmony export */   drawSelection: () => (/* binding */ drawSelection),\n/* harmony export */   dropCursor: () => (/* binding */ dropCursor),\n/* harmony export */   getDrawSelectionConfig: () => (/* binding */ getDrawSelectionConfig),\n/* harmony export */   getPanel: () => (/* binding */ getPanel),\n/* harmony export */   getTooltip: () => (/* binding */ getTooltip),\n/* harmony export */   gutter: () => (/* binding */ gutter),\n/* harmony export */   gutterLineClass: () => (/* binding */ gutterLineClass),\n/* harmony export */   gutters: () => (/* binding */ gutters),\n/* harmony export */   hasHoverTooltips: () => (/* binding */ hasHoverTooltips),\n/* harmony export */   highlightActiveLine: () => (/* binding */ highlightActiveLine),\n/* harmony export */   highlightActiveLineGutter: () => (/* binding */ highlightActiveLineGutter),\n/* harmony export */   highlightSpecialChars: () => (/* binding */ highlightSpecialChars),\n/* harmony export */   highlightTrailingWhitespace: () => (/* binding */ highlightTrailingWhitespace),\n/* harmony export */   highlightWhitespace: () => (/* binding */ highlightWhitespace),\n/* harmony export */   hoverTooltip: () => (/* binding */ hoverTooltip),\n/* harmony export */   keymap: () => (/* binding */ keymap),\n/* harmony export */   layer: () => (/* binding */ layer),\n/* harmony export */   lineNumberMarkers: () => (/* binding */ lineNumberMarkers),\n/* harmony export */   lineNumbers: () => (/* binding */ lineNumbers),\n/* harmony export */   logException: () => (/* binding */ logException),\n/* harmony export */   panels: () => (/* binding */ panels),\n/* harmony export */   placeholder: () => (/* binding */ placeholder),\n/* harmony export */   rectangularSelection: () => (/* binding */ rectangularSelection),\n/* harmony export */   repositionTooltips: () => (/* binding */ repositionTooltips),\n/* harmony export */   runScopeHandlers: () => (/* binding */ runScopeHandlers),\n/* harmony export */   scrollPastEnd: () => (/* binding */ scrollPastEnd),\n/* harmony export */   showPanel: () => (/* binding */ showPanel),\n/* harmony export */   showTooltip: () => (/* binding */ showTooltip),\n/* harmony export */   tooltips: () => (/* binding */ tooltips)\n/* harmony export */ });\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/state */ \"(ssr)/./node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var style_mod__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! style-mod */ \"(ssr)/./node_modules/style-mod/src/style-mod.js\");\n/* harmony import */ var w3c_keyname__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! w3c-keyname */ \"(ssr)/./node_modules/w3c-keyname/index.js\");\n\n\n\nfunction getSelection(root) {\n    let target;\n    // Browsers differ on whether shadow roots have a getSelection\n    // method. If it exists, use that, otherwise, call it on the\n    // document.\n    if (root.nodeType == 11) {\n        target = root.getSelection ? root : root.ownerDocument;\n    } else {\n        target = root;\n    }\n    return target.getSelection();\n}\nfunction contains(dom, node) {\n    return node ? dom == node || dom.contains(node.nodeType != 1 ? node.parentNode : node) : false;\n}\nfunction deepActiveElement(doc) {\n    let elt = doc.activeElement;\n    while(elt && elt.shadowRoot)elt = elt.shadowRoot.activeElement;\n    return elt;\n}\nfunction hasSelection(dom, selection) {\n    if (!selection.anchorNode) return false;\n    try {\n        // Firefox will raise 'permission denied' errors when accessing\n        // properties of `sel.anchorNode` when it's in a generated CSS\n        // element.\n        return contains(dom, selection.anchorNode);\n    } catch (_) {\n        return false;\n    }\n}\nfunction clientRectsFor(dom) {\n    if (dom.nodeType == 3) return textRange(dom, 0, dom.nodeValue.length).getClientRects();\n    else if (dom.nodeType == 1) return dom.getClientRects();\n    else return [];\n}\n// Scans forward and backward through DOM positions equivalent to the\n// given one to see if the two are in the same place (i.e. after a\n// text node vs at the end of that text node)\nfunction isEquivalentPosition(node, off, targetNode, targetOff) {\n    return targetNode ? scanFor(node, off, targetNode, targetOff, -1) || scanFor(node, off, targetNode, targetOff, 1) : false;\n}\nfunction domIndex(node) {\n    for(var index = 0;; index++){\n        node = node.previousSibling;\n        if (!node) return index;\n    }\n}\nfunction scanFor(node, off, targetNode, targetOff, dir) {\n    for(;;){\n        if (node == targetNode && off == targetOff) return true;\n        if (off == (dir < 0 ? 0 : maxOffset(node))) {\n            if (node.nodeName == \"DIV\") return false;\n            let parent = node.parentNode;\n            if (!parent || parent.nodeType != 1) return false;\n            off = domIndex(node) + (dir < 0 ? 0 : 1);\n            node = parent;\n        } else if (node.nodeType == 1) {\n            node = node.childNodes[off + (dir < 0 ? -1 : 0)];\n            if (node.nodeType == 1 && node.contentEditable == \"false\") return false;\n            off = dir < 0 ? maxOffset(node) : 0;\n        } else {\n            return false;\n        }\n    }\n}\nfunction maxOffset(node) {\n    return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;\n}\nfunction flattenRect(rect, left) {\n    let x = left ? rect.left : rect.right;\n    return {\n        left: x,\n        right: x,\n        top: rect.top,\n        bottom: rect.bottom\n    };\n}\nfunction windowRect(win) {\n    return {\n        left: 0,\n        right: win.innerWidth,\n        top: 0,\n        bottom: win.innerHeight\n    };\n}\nfunction getScale(elt, rect) {\n    let scaleX = rect.width / elt.offsetWidth;\n    let scaleY = rect.height / elt.offsetHeight;\n    if (scaleX > 0.995 && scaleX < 1.005 || !isFinite(scaleX) || Math.abs(rect.width - elt.offsetWidth) < 1) scaleX = 1;\n    if (scaleY > 0.995 && scaleY < 1.005 || !isFinite(scaleY) || Math.abs(rect.height - elt.offsetHeight) < 1) scaleY = 1;\n    return {\n        scaleX,\n        scaleY\n    };\n}\nfunction scrollRectIntoView(dom, rect, side, x, y, xMargin, yMargin, ltr) {\n    let doc = dom.ownerDocument, win = doc.defaultView || window;\n    for(let cur = dom, stop = false; cur && !stop;){\n        if (cur.nodeType == 1) {\n            let bounding, top = cur == doc.body;\n            let scaleX = 1, scaleY = 1;\n            if (top) {\n                bounding = windowRect(win);\n            } else {\n                if (/^(fixed|sticky)$/.test(getComputedStyle(cur).position)) stop = true;\n                if (cur.scrollHeight <= cur.clientHeight && cur.scrollWidth <= cur.clientWidth) {\n                    cur = cur.assignedSlot || cur.parentNode;\n                    continue;\n                }\n                let rect = cur.getBoundingClientRect();\n                ({ scaleX, scaleY } = getScale(cur, rect));\n                // Make sure scrollbar width isn't included in the rectangle\n                bounding = {\n                    left: rect.left,\n                    right: rect.left + cur.clientWidth * scaleX,\n                    top: rect.top,\n                    bottom: rect.top + cur.clientHeight * scaleY\n                };\n            }\n            let moveX = 0, moveY = 0;\n            if (y == \"nearest\") {\n                if (rect.top < bounding.top) {\n                    moveY = -(bounding.top - rect.top + yMargin);\n                    if (side > 0 && rect.bottom > bounding.bottom + moveY) moveY = rect.bottom - bounding.bottom + moveY + yMargin;\n                } else if (rect.bottom > bounding.bottom) {\n                    moveY = rect.bottom - bounding.bottom + yMargin;\n                    if (side < 0 && rect.top - moveY < bounding.top) moveY = -(bounding.top + moveY - rect.top + yMargin);\n                }\n            } else {\n                let rectHeight = rect.bottom - rect.top, boundingHeight = bounding.bottom - bounding.top;\n                let targetTop = y == \"center\" && rectHeight <= boundingHeight ? rect.top + rectHeight / 2 - boundingHeight / 2 : y == \"start\" || y == \"center\" && side < 0 ? rect.top - yMargin : rect.bottom - boundingHeight + yMargin;\n                moveY = targetTop - bounding.top;\n            }\n            if (x == \"nearest\") {\n                if (rect.left < bounding.left) {\n                    moveX = -(bounding.left - rect.left + xMargin);\n                    if (side > 0 && rect.right > bounding.right + moveX) moveX = rect.right - bounding.right + moveX + xMargin;\n                } else if (rect.right > bounding.right) {\n                    moveX = rect.right - bounding.right + xMargin;\n                    if (side < 0 && rect.left < bounding.left + moveX) moveX = -(bounding.left + moveX - rect.left + xMargin);\n                }\n            } else {\n                let targetLeft = x == \"center\" ? rect.left + (rect.right - rect.left) / 2 - (bounding.right - bounding.left) / 2 : x == \"start\" == ltr ? rect.left - xMargin : rect.right - (bounding.right - bounding.left) + xMargin;\n                moveX = targetLeft - bounding.left;\n            }\n            if (moveX || moveY) {\n                if (top) {\n                    win.scrollBy(moveX, moveY);\n                } else {\n                    let movedX = 0, movedY = 0;\n                    if (moveY) {\n                        let start = cur.scrollTop;\n                        cur.scrollTop += moveY / scaleY;\n                        movedY = (cur.scrollTop - start) * scaleY;\n                    }\n                    if (moveX) {\n                        let start = cur.scrollLeft;\n                        cur.scrollLeft += moveX / scaleX;\n                        movedX = (cur.scrollLeft - start) * scaleX;\n                    }\n                    rect = {\n                        left: rect.left - movedX,\n                        top: rect.top - movedY,\n                        right: rect.right - movedX,\n                        bottom: rect.bottom - movedY\n                    };\n                    if (movedX && Math.abs(movedX - moveX) < 1) x = \"nearest\";\n                    if (movedY && Math.abs(movedY - moveY) < 1) y = \"nearest\";\n                }\n            }\n            if (top) break;\n            cur = cur.assignedSlot || cur.parentNode;\n        } else if (cur.nodeType == 11) {\n            cur = cur.host;\n        } else {\n            break;\n        }\n    }\n}\nfunction scrollableParent(dom) {\n    let doc = dom.ownerDocument;\n    for(let cur = dom.parentNode; cur;){\n        if (cur == doc.body) {\n            break;\n        } else if (cur.nodeType == 1) {\n            if (cur.scrollHeight > cur.clientHeight || cur.scrollWidth > cur.clientWidth) return cur;\n            cur = cur.assignedSlot || cur.parentNode;\n        } else if (cur.nodeType == 11) {\n            cur = cur.host;\n        } else {\n            break;\n        }\n    }\n    return null;\n}\nclass DOMSelectionState {\n    constructor(){\n        this.anchorNode = null;\n        this.anchorOffset = 0;\n        this.focusNode = null;\n        this.focusOffset = 0;\n    }\n    eq(domSel) {\n        return this.anchorNode == domSel.anchorNode && this.anchorOffset == domSel.anchorOffset && this.focusNode == domSel.focusNode && this.focusOffset == domSel.focusOffset;\n    }\n    setRange(range) {\n        let { anchorNode, focusNode } = range;\n        // Clip offsets to node size to avoid crashes when Safari reports bogus offsets (#1152)\n        this.set(anchorNode, Math.min(range.anchorOffset, anchorNode ? maxOffset(anchorNode) : 0), focusNode, Math.min(range.focusOffset, focusNode ? maxOffset(focusNode) : 0));\n    }\n    set(anchorNode, anchorOffset, focusNode, focusOffset) {\n        this.anchorNode = anchorNode;\n        this.anchorOffset = anchorOffset;\n        this.focusNode = focusNode;\n        this.focusOffset = focusOffset;\n    }\n}\nlet preventScrollSupported = null;\n// Feature-detects support for .focus({preventScroll: true}), and uses\n// a fallback kludge when not supported.\nfunction focusPreventScroll(dom) {\n    if (dom.setActive) return dom.setActive(); // in IE\n    if (preventScrollSupported) return dom.focus(preventScrollSupported);\n    let stack = [];\n    for(let cur = dom; cur; cur = cur.parentNode){\n        stack.push(cur, cur.scrollTop, cur.scrollLeft);\n        if (cur == cur.ownerDocument) break;\n    }\n    dom.focus(preventScrollSupported == null ? {\n        get preventScroll () {\n            preventScrollSupported = {\n                preventScroll: true\n            };\n            return true;\n        }\n    } : undefined);\n    if (!preventScrollSupported) {\n        preventScrollSupported = false;\n        for(let i = 0; i < stack.length;){\n            let elt = stack[i++], top = stack[i++], left = stack[i++];\n            if (elt.scrollTop != top) elt.scrollTop = top;\n            if (elt.scrollLeft != left) elt.scrollLeft = left;\n        }\n    }\n}\nlet scratchRange;\nfunction textRange(node, from, to = from) {\n    let range = scratchRange || (scratchRange = document.createRange());\n    range.setEnd(node, to);\n    range.setStart(node, from);\n    return range;\n}\nfunction dispatchKey(elt, name, code) {\n    let options = {\n        key: name,\n        code: name,\n        keyCode: code,\n        which: code,\n        cancelable: true\n    };\n    let down = new KeyboardEvent(\"keydown\", options);\n    down.synthetic = true;\n    elt.dispatchEvent(down);\n    let up = new KeyboardEvent(\"keyup\", options);\n    up.synthetic = true;\n    elt.dispatchEvent(up);\n    return down.defaultPrevented || up.defaultPrevented;\n}\nfunction getRoot(node) {\n    while(node){\n        if (node && (node.nodeType == 9 || node.nodeType == 11 && node.host)) return node;\n        node = node.assignedSlot || node.parentNode;\n    }\n    return null;\n}\nfunction clearAttributes(node) {\n    while(node.attributes.length)node.removeAttributeNode(node.attributes[0]);\n}\nfunction atElementStart(doc, selection) {\n    let node = selection.focusNode, offset = selection.focusOffset;\n    if (!node || selection.anchorNode != node || selection.anchorOffset != offset) return false;\n    // Safari can report bogus offsets (#1152)\n    offset = Math.min(offset, maxOffset(node));\n    for(;;){\n        if (offset) {\n            if (node.nodeType != 1) return false;\n            let prev = node.childNodes[offset - 1];\n            if (prev.contentEditable == \"false\") offset--;\n            else {\n                node = prev;\n                offset = maxOffset(node);\n            }\n        } else if (node == doc) {\n            return true;\n        } else {\n            offset = domIndex(node);\n            node = node.parentNode;\n        }\n    }\n}\nfunction isScrolledToBottom(elt) {\n    return elt.scrollTop > Math.max(1, elt.scrollHeight - elt.clientHeight - 4);\n}\nclass DOMPos {\n    constructor(node, offset, precise = true){\n        this.node = node;\n        this.offset = offset;\n        this.precise = precise;\n    }\n    static before(dom, precise) {\n        return new DOMPos(dom.parentNode, domIndex(dom), precise);\n    }\n    static after(dom, precise) {\n        return new DOMPos(dom.parentNode, domIndex(dom) + 1, precise);\n    }\n}\nconst noChildren = [];\nclass ContentView {\n    constructor(){\n        this.parent = null;\n        this.dom = null;\n        this.flags = 2 /* ViewFlag.NodeDirty */ ;\n    }\n    get overrideDOMText() {\n        return null;\n    }\n    get posAtStart() {\n        return this.parent ? this.parent.posBefore(this) : 0;\n    }\n    get posAtEnd() {\n        return this.posAtStart + this.length;\n    }\n    posBefore(view) {\n        let pos = this.posAtStart;\n        for (let child of this.children){\n            if (child == view) return pos;\n            pos += child.length + child.breakAfter;\n        }\n        throw new RangeError(\"Invalid child in posBefore\");\n    }\n    posAfter(view) {\n        return this.posBefore(view) + view.length;\n    }\n    sync(view, track) {\n        if (this.flags & 2 /* ViewFlag.NodeDirty */ ) {\n            let parent = this.dom;\n            let prev = null, next;\n            for (let child of this.children){\n                if (child.flags & 7 /* ViewFlag.Dirty */ ) {\n                    if (!child.dom && (next = prev ? prev.nextSibling : parent.firstChild)) {\n                        let contentView = ContentView.get(next);\n                        if (!contentView || !contentView.parent && contentView.canReuseDOM(child)) child.reuseDOM(next);\n                    }\n                    child.sync(view, track);\n                    child.flags &= ~7 /* ViewFlag.Dirty */ ;\n                }\n                next = prev ? prev.nextSibling : parent.firstChild;\n                if (track && !track.written && track.node == parent && next != child.dom) track.written = true;\n                if (child.dom.parentNode == parent) {\n                    while(next && next != child.dom)next = rm$1(next);\n                } else {\n                    parent.insertBefore(child.dom, next);\n                }\n                prev = child.dom;\n            }\n            next = prev ? prev.nextSibling : parent.firstChild;\n            if (next && track && track.node == parent) track.written = true;\n            while(next)next = rm$1(next);\n        } else if (this.flags & 1 /* ViewFlag.ChildDirty */ ) {\n            for (let child of this.children)if (child.flags & 7 /* ViewFlag.Dirty */ ) {\n                child.sync(view, track);\n                child.flags &= ~7 /* ViewFlag.Dirty */ ;\n            }\n        }\n    }\n    reuseDOM(_dom) {}\n    localPosFromDOM(node, offset) {\n        let after;\n        if (node == this.dom) {\n            after = this.dom.childNodes[offset];\n        } else {\n            let bias = maxOffset(node) == 0 ? 0 : offset == 0 ? -1 : 1;\n            for(;;){\n                let parent = node.parentNode;\n                if (parent == this.dom) break;\n                if (bias == 0 && parent.firstChild != parent.lastChild) {\n                    if (node == parent.firstChild) bias = -1;\n                    else bias = 1;\n                }\n                node = parent;\n            }\n            if (bias < 0) after = node;\n            else after = node.nextSibling;\n        }\n        if (after == this.dom.firstChild) return 0;\n        while(after && !ContentView.get(after))after = after.nextSibling;\n        if (!after) return this.length;\n        for(let i = 0, pos = 0;; i++){\n            let child = this.children[i];\n            if (child.dom == after) return pos;\n            pos += child.length + child.breakAfter;\n        }\n    }\n    domBoundsAround(from, to, offset = 0) {\n        let fromI = -1, fromStart = -1, toI = -1, toEnd = -1;\n        for(let i = 0, pos = offset, prevEnd = offset; i < this.children.length; i++){\n            let child = this.children[i], end = pos + child.length;\n            if (pos < from && end > to) return child.domBoundsAround(from, to, pos);\n            if (end >= from && fromI == -1) {\n                fromI = i;\n                fromStart = pos;\n            }\n            if (pos > to && child.dom.parentNode == this.dom) {\n                toI = i;\n                toEnd = prevEnd;\n                break;\n            }\n            prevEnd = end;\n            pos = end + child.breakAfter;\n        }\n        return {\n            from: fromStart,\n            to: toEnd < 0 ? offset + this.length : toEnd,\n            startDOM: (fromI ? this.children[fromI - 1].dom.nextSibling : null) || this.dom.firstChild,\n            endDOM: toI < this.children.length && toI >= 0 ? this.children[toI].dom : null\n        };\n    }\n    markDirty(andParent = false) {\n        this.flags |= 2 /* ViewFlag.NodeDirty */ ;\n        this.markParentsDirty(andParent);\n    }\n    markParentsDirty(childList) {\n        for(let parent = this.parent; parent; parent = parent.parent){\n            if (childList) parent.flags |= 2 /* ViewFlag.NodeDirty */ ;\n            if (parent.flags & 1 /* ViewFlag.ChildDirty */ ) return;\n            parent.flags |= 1 /* ViewFlag.ChildDirty */ ;\n            childList = false;\n        }\n    }\n    setParent(parent) {\n        if (this.parent != parent) {\n            this.parent = parent;\n            if (this.flags & 7 /* ViewFlag.Dirty */ ) this.markParentsDirty(true);\n        }\n    }\n    setDOM(dom) {\n        if (this.dom == dom) return;\n        if (this.dom) this.dom.cmView = null;\n        this.dom = dom;\n        dom.cmView = this;\n    }\n    get rootView() {\n        for(let v = this;;){\n            let parent = v.parent;\n            if (!parent) return v;\n            v = parent;\n        }\n    }\n    replaceChildren(from, to, children = noChildren) {\n        this.markDirty();\n        for(let i = from; i < to; i++){\n            let child = this.children[i];\n            if (child.parent == this && children.indexOf(child) < 0) child.destroy();\n        }\n        this.children.splice(from, to - from, ...children);\n        for(let i = 0; i < children.length; i++)children[i].setParent(this);\n    }\n    ignoreMutation(_rec) {\n        return false;\n    }\n    ignoreEvent(_event) {\n        return false;\n    }\n    childCursor(pos = this.length) {\n        return new ChildCursor(this.children, pos, this.children.length);\n    }\n    childPos(pos, bias = 1) {\n        return this.childCursor().findPos(pos, bias);\n    }\n    toString() {\n        let name = this.constructor.name.replace(\"View\", \"\");\n        return name + (this.children.length ? \"(\" + this.children.join() + \")\" : this.length ? \"[\" + (name == \"Text\" ? this.text : this.length) + \"]\" : \"\") + (this.breakAfter ? \"#\" : \"\");\n    }\n    static get(node) {\n        return node.cmView;\n    }\n    get isEditable() {\n        return true;\n    }\n    get isWidget() {\n        return false;\n    }\n    get isHidden() {\n        return false;\n    }\n    merge(from, to, source, hasStart, openStart, openEnd) {\n        return false;\n    }\n    become(other) {\n        return false;\n    }\n    canReuseDOM(other) {\n        return other.constructor == this.constructor && !((this.flags | other.flags) & 8 /* ViewFlag.Composition */ );\n    }\n    // When this is a zero-length view with a side, this should return a\n    // number <= 0 to indicate it is before its position, or a\n    // number > 0 when after its position.\n    getSide() {\n        return 0;\n    }\n    destroy() {\n        for (let child of this.children)child.destroy();\n        this.parent = null;\n    }\n}\nContentView.prototype.breakAfter = 0;\n// Remove a DOM node and return its next sibling.\nfunction rm$1(dom) {\n    let next = dom.nextSibling;\n    dom.parentNode.removeChild(dom);\n    return next;\n}\nclass ChildCursor {\n    constructor(children, pos, i){\n        this.children = children;\n        this.pos = pos;\n        this.i = i;\n        this.off = 0;\n    }\n    findPos(pos, bias = 1) {\n        for(;;){\n            if (pos > this.pos || pos == this.pos && (bias > 0 || this.i == 0 || this.children[this.i - 1].breakAfter)) {\n                this.off = pos - this.pos;\n                return this;\n            }\n            let next = this.children[--this.i];\n            this.pos -= next.length + next.breakAfter;\n        }\n    }\n}\nfunction replaceRange(parent, fromI, fromOff, toI, toOff, insert, breakAtStart, openStart, openEnd) {\n    let { children } = parent;\n    let before = children.length ? children[fromI] : null;\n    let last = insert.length ? insert[insert.length - 1] : null;\n    let breakAtEnd = last ? last.breakAfter : breakAtStart;\n    // Change within a single child\n    if (fromI == toI && before && !breakAtStart && !breakAtEnd && insert.length < 2 && before.merge(fromOff, toOff, insert.length ? last : null, fromOff == 0, openStart, openEnd)) return;\n    if (toI < children.length) {\n        let after = children[toI];\n        // Make sure the end of the child after the update is preserved in `after`\n        if (after && (toOff < after.length || after.breakAfter && (last === null || last === void 0 ? void 0 : last.breakAfter))) {\n            // If we're splitting a child, separate part of it to avoid that\n            // being mangled when updating the child before the update.\n            if (fromI == toI) {\n                after = after.split(toOff);\n                toOff = 0;\n            }\n            // If the element after the replacement should be merged with\n            // the last replacing element, update `content`\n            if (!breakAtEnd && last && after.merge(0, toOff, last, true, 0, openEnd)) {\n                insert[insert.length - 1] = after;\n            } else {\n                // Remove the start of the after element, if necessary, and\n                // add it to `content`.\n                if (toOff || after.children.length && !after.children[0].length) after.merge(0, toOff, null, false, 0, openEnd);\n                insert.push(after);\n            }\n        } else if (after === null || after === void 0 ? void 0 : after.breakAfter) {\n            // The element at `toI` is entirely covered by this range.\n            // Preserve its line break, if any.\n            if (last) last.breakAfter = 1;\n            else breakAtStart = 1;\n        }\n        // Since we've handled the next element from the current elements\n        // now, make sure `toI` points after that.\n        toI++;\n    }\n    if (before) {\n        before.breakAfter = breakAtStart;\n        if (fromOff > 0) {\n            if (!breakAtStart && insert.length && before.merge(fromOff, before.length, insert[0], false, openStart, 0)) {\n                before.breakAfter = insert.shift().breakAfter;\n            } else if (fromOff < before.length || before.children.length && before.children[before.children.length - 1].length == 0) {\n                before.merge(fromOff, before.length, null, false, openStart, 0);\n            }\n            fromI++;\n        }\n    }\n    // Try to merge widgets on the boundaries of the replacement\n    while(fromI < toI && insert.length){\n        if (children[toI - 1].become(insert[insert.length - 1])) {\n            toI--;\n            insert.pop();\n            openEnd = insert.length ? 0 : openStart;\n        } else if (children[fromI].become(insert[0])) {\n            fromI++;\n            insert.shift();\n            openStart = insert.length ? 0 : openEnd;\n        } else {\n            break;\n        }\n    }\n    if (!insert.length && fromI && toI < children.length && !children[fromI - 1].breakAfter && children[toI].merge(0, 0, children[fromI - 1], false, openStart, openEnd)) fromI--;\n    if (fromI < toI || insert.length) parent.replaceChildren(fromI, toI, insert);\n}\nfunction mergeChildrenInto(parent, from, to, insert, openStart, openEnd) {\n    let cur = parent.childCursor();\n    let { i: toI, off: toOff } = cur.findPos(to, 1);\n    let { i: fromI, off: fromOff } = cur.findPos(from, -1);\n    let dLen = from - to;\n    for (let view of insert)dLen += view.length;\n    parent.length += dLen;\n    replaceRange(parent, fromI, fromOff, toI, toOff, insert, 0, openStart, openEnd);\n}\nlet nav = typeof navigator != \"undefined\" ? navigator : {\n    userAgent: \"\",\n    vendor: \"\",\n    platform: \"\"\n};\nlet doc = typeof document != \"undefined\" ? document : {\n    documentElement: {\n        style: {}\n    }\n};\nconst ie_edge = /*@__PURE__*/ /Edge\\/(\\d+)/.exec(nav.userAgent);\nconst ie_upto10 = /*@__PURE__*/ /MSIE \\d/.test(nav.userAgent);\nconst ie_11up = /*@__PURE__*/ /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(nav.userAgent);\nconst ie = !!(ie_upto10 || ie_11up || ie_edge);\nconst gecko = !ie && /*@__PURE__*/ /gecko\\/(\\d+)/i.test(nav.userAgent);\nconst chrome = !ie && /*@__PURE__*/ /Chrome\\/(\\d+)/.exec(nav.userAgent);\nconst webkit = \"webkitFontSmoothing\" in doc.documentElement.style;\nconst safari = !ie && /*@__PURE__*/ /Apple Computer/.test(nav.vendor);\nconst ios = safari && /*@__PURE__*/ (/Mobile\\/\\w+/.test(nav.userAgent) || nav.maxTouchPoints > 2);\nvar browser = {\n    mac: ios || /*@__PURE__*/ /Mac/.test(nav.platform),\n    windows: /*@__PURE__*/ /Win/.test(nav.platform),\n    linux: /*@__PURE__*/ /Linux|X11/.test(nav.platform),\n    ie,\n    ie_version: ie_upto10 ? doc.documentMode || 6 : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0,\n    gecko,\n    gecko_version: gecko ? +/*@__PURE__*/ (/Firefox\\/(\\d+)/.exec(nav.userAgent) || [\n        0,\n        0\n    ])[1] : 0,\n    chrome: !!chrome,\n    chrome_version: chrome ? +chrome[1] : 0,\n    ios,\n    android: /*@__PURE__*/ /Android\\b/.test(nav.userAgent),\n    webkit,\n    safari,\n    webkit_version: webkit ? +/*@__PURE__*/ (/\\bAppleWebKit\\/(\\d+)/.exec(navigator.userAgent) || [\n        0,\n        0\n    ])[1] : 0,\n    tabSize: doc.documentElement.style.tabSize != null ? \"tab-size\" : \"-moz-tab-size\"\n};\nconst MaxJoinLen = 256;\nclass TextView extends ContentView {\n    constructor(text){\n        super();\n        this.text = text;\n    }\n    get length() {\n        return this.text.length;\n    }\n    createDOM(textDOM) {\n        this.setDOM(textDOM || document.createTextNode(this.text));\n    }\n    sync(view, track) {\n        if (!this.dom) this.createDOM();\n        if (this.dom.nodeValue != this.text) {\n            if (track && track.node == this.dom) track.written = true;\n            this.dom.nodeValue = this.text;\n        }\n    }\n    reuseDOM(dom) {\n        if (dom.nodeType == 3) this.createDOM(dom);\n    }\n    merge(from, to, source) {\n        if (this.flags & 8 /* ViewFlag.Composition */  || source && (!(source instanceof TextView) || this.length - (to - from) + source.length > MaxJoinLen || source.flags & 8 /* ViewFlag.Composition */ )) return false;\n        this.text = this.text.slice(0, from) + (source ? source.text : \"\") + this.text.slice(to);\n        this.markDirty();\n        return true;\n    }\n    split(from) {\n        let result = new TextView(this.text.slice(from));\n        this.text = this.text.slice(0, from);\n        this.markDirty();\n        result.flags |= this.flags & 8 /* ViewFlag.Composition */ ;\n        return result;\n    }\n    localPosFromDOM(node, offset) {\n        return node == this.dom ? offset : offset ? this.text.length : 0;\n    }\n    domAtPos(pos) {\n        return new DOMPos(this.dom, pos);\n    }\n    domBoundsAround(_from, _to, offset) {\n        return {\n            from: offset,\n            to: offset + this.length,\n            startDOM: this.dom,\n            endDOM: this.dom.nextSibling\n        };\n    }\n    coordsAt(pos, side) {\n        return textCoords(this.dom, pos, side);\n    }\n}\nclass MarkView extends ContentView {\n    constructor(mark, children = [], length = 0){\n        super();\n        this.mark = mark;\n        this.children = children;\n        this.length = length;\n        for (let ch of children)ch.setParent(this);\n    }\n    setAttrs(dom) {\n        clearAttributes(dom);\n        if (this.mark.class) dom.className = this.mark.class;\n        if (this.mark.attrs) for(let name in this.mark.attrs)dom.setAttribute(name, this.mark.attrs[name]);\n        return dom;\n    }\n    canReuseDOM(other) {\n        return super.canReuseDOM(other) && !((this.flags | other.flags) & 8 /* ViewFlag.Composition */ );\n    }\n    reuseDOM(node) {\n        if (node.nodeName == this.mark.tagName.toUpperCase()) {\n            this.setDOM(node);\n            this.flags |= 4 /* ViewFlag.AttrsDirty */  | 2 /* ViewFlag.NodeDirty */ ;\n        }\n    }\n    sync(view, track) {\n        if (!this.dom) this.setDOM(this.setAttrs(document.createElement(this.mark.tagName)));\n        else if (this.flags & 4 /* ViewFlag.AttrsDirty */ ) this.setAttrs(this.dom);\n        super.sync(view, track);\n    }\n    merge(from, to, source, _hasStart, openStart, openEnd) {\n        if (source && (!(source instanceof MarkView && source.mark.eq(this.mark)) || from && openStart <= 0 || to < this.length && openEnd <= 0)) return false;\n        mergeChildrenInto(this, from, to, source ? source.children : [], openStart - 1, openEnd - 1);\n        this.markDirty();\n        return true;\n    }\n    split(from) {\n        let result = [], off = 0, detachFrom = -1, i = 0;\n        for (let elt of this.children){\n            let end = off + elt.length;\n            if (end > from) result.push(off < from ? elt.split(from - off) : elt);\n            if (detachFrom < 0 && off >= from) detachFrom = i;\n            off = end;\n            i++;\n        }\n        let length = this.length - from;\n        this.length = from;\n        if (detachFrom > -1) {\n            this.children.length = detachFrom;\n            this.markDirty();\n        }\n        return new MarkView(this.mark, result, length);\n    }\n    domAtPos(pos) {\n        return inlineDOMAtPos(this, pos);\n    }\n    coordsAt(pos, side) {\n        return coordsInChildren(this, pos, side);\n    }\n}\nfunction textCoords(text, pos, side) {\n    let length = text.nodeValue.length;\n    if (pos > length) pos = length;\n    let from = pos, to = pos, flatten = 0;\n    if (pos == 0 && side < 0 || pos == length && side >= 0) {\n        if (!(browser.chrome || browser.gecko)) {\n            if (pos) {\n                from--;\n                flatten = 1;\n            } else if (to < length) {\n                to++;\n                flatten = -1;\n            }\n        }\n    } else {\n        if (side < 0) from--;\n        else if (to < length) to++;\n    }\n    let rects = textRange(text, from, to).getClientRects();\n    if (!rects.length) return null;\n    let rect = rects[(flatten ? flatten < 0 : side >= 0) ? 0 : rects.length - 1];\n    if (browser.safari && !flatten && rect.width == 0) rect = Array.prototype.find.call(rects, (r)=>r.width) || rect;\n    return flatten ? flattenRect(rect, flatten < 0) : rect || null;\n}\n// Also used for collapsed ranges that don't have a placeholder widget!\nclass WidgetView extends ContentView {\n    static create(widget, length, side) {\n        return new WidgetView(widget, length, side);\n    }\n    constructor(widget, length, side){\n        super();\n        this.widget = widget;\n        this.length = length;\n        this.side = side;\n        this.prevWidget = null;\n    }\n    split(from) {\n        let result = WidgetView.create(this.widget, this.length - from, this.side);\n        this.length -= from;\n        return result;\n    }\n    sync(view) {\n        if (!this.dom || !this.widget.updateDOM(this.dom, view)) {\n            if (this.dom && this.prevWidget) this.prevWidget.destroy(this.dom);\n            this.prevWidget = null;\n            this.setDOM(this.widget.toDOM(view));\n            this.dom.contentEditable = \"false\";\n        }\n    }\n    getSide() {\n        return this.side;\n    }\n    merge(from, to, source, hasStart, openStart, openEnd) {\n        if (source && (!(source instanceof WidgetView) || !this.widget.compare(source.widget) || from > 0 && openStart <= 0 || to < this.length && openEnd <= 0)) return false;\n        this.length = from + (source ? source.length : 0) + (this.length - to);\n        return true;\n    }\n    become(other) {\n        if (other instanceof WidgetView && other.side == this.side && this.widget.constructor == other.widget.constructor) {\n            if (!this.widget.compare(other.widget)) this.markDirty(true);\n            if (this.dom && !this.prevWidget) this.prevWidget = this.widget;\n            this.widget = other.widget;\n            this.length = other.length;\n            return true;\n        }\n        return false;\n    }\n    ignoreMutation() {\n        return true;\n    }\n    ignoreEvent(event) {\n        return this.widget.ignoreEvent(event);\n    }\n    get overrideDOMText() {\n        if (this.length == 0) return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Text.empty;\n        let top = this;\n        while(top.parent)top = top.parent;\n        let { view } = top, text = view && view.state.doc, start = this.posAtStart;\n        return text ? text.slice(start, start + this.length) : _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Text.empty;\n    }\n    domAtPos(pos) {\n        return (this.length ? pos == 0 : this.side > 0) ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);\n    }\n    domBoundsAround() {\n        return null;\n    }\n    coordsAt(pos, side) {\n        let custom = this.widget.coordsAt(this.dom, pos, side);\n        if (custom) return custom;\n        let rects = this.dom.getClientRects(), rect = null;\n        if (!rects.length) return null;\n        let fromBack = this.side ? this.side < 0 : pos > 0;\n        for(let i = fromBack ? rects.length - 1 : 0;; i += fromBack ? -1 : 1){\n            rect = rects[i];\n            if (pos > 0 ? i == 0 : i == rects.length - 1 || rect.top < rect.bottom) break;\n        }\n        return flattenRect(rect, !fromBack);\n    }\n    get isEditable() {\n        return false;\n    }\n    get isWidget() {\n        return true;\n    }\n    get isHidden() {\n        return this.widget.isHidden;\n    }\n    destroy() {\n        super.destroy();\n        if (this.dom) this.widget.destroy(this.dom);\n    }\n}\n// These are drawn around uneditable widgets to avoid a number of\n// browser bugs that show up when the cursor is directly next to\n// uneditable inline content.\nclass WidgetBufferView extends ContentView {\n    constructor(side){\n        super();\n        this.side = side;\n    }\n    get length() {\n        return 0;\n    }\n    merge() {\n        return false;\n    }\n    become(other) {\n        return other instanceof WidgetBufferView && other.side == this.side;\n    }\n    split() {\n        return new WidgetBufferView(this.side);\n    }\n    sync() {\n        if (!this.dom) {\n            let dom = document.createElement(\"img\");\n            dom.className = \"cm-widgetBuffer\";\n            dom.setAttribute(\"aria-hidden\", \"true\");\n            this.setDOM(dom);\n        }\n    }\n    getSide() {\n        return this.side;\n    }\n    domAtPos(pos) {\n        return this.side > 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom);\n    }\n    localPosFromDOM() {\n        return 0;\n    }\n    domBoundsAround() {\n        return null;\n    }\n    coordsAt(pos) {\n        return this.dom.getBoundingClientRect();\n    }\n    get overrideDOMText() {\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Text.empty;\n    }\n    get isHidden() {\n        return true;\n    }\n}\nTextView.prototype.children = WidgetView.prototype.children = WidgetBufferView.prototype.children = noChildren;\nfunction inlineDOMAtPos(parent, pos) {\n    let dom = parent.dom, { children } = parent, i = 0;\n    for(let off = 0; i < children.length; i++){\n        let child = children[i], end = off + child.length;\n        if (end == off && child.getSide() <= 0) continue;\n        if (pos > off && pos < end && child.dom.parentNode == dom) return child.domAtPos(pos - off);\n        if (pos <= off) break;\n        off = end;\n    }\n    for(let j = i; j > 0; j--){\n        let prev = children[j - 1];\n        if (prev.dom.parentNode == dom) return prev.domAtPos(prev.length);\n    }\n    for(let j = i; j < children.length; j++){\n        let next = children[j];\n        if (next.dom.parentNode == dom) return next.domAtPos(0);\n    }\n    return new DOMPos(dom, 0);\n}\n// Assumes `view`, if a mark view, has precisely 1 child.\nfunction joinInlineInto(parent, view, open) {\n    let last, { children } = parent;\n    if (open > 0 && view instanceof MarkView && children.length && (last = children[children.length - 1]) instanceof MarkView && last.mark.eq(view.mark)) {\n        joinInlineInto(last, view.children[0], open - 1);\n    } else {\n        children.push(view);\n        view.setParent(parent);\n    }\n    parent.length += view.length;\n}\nfunction coordsInChildren(view, pos, side) {\n    let before = null, beforePos = -1, after = null, afterPos = -1;\n    function scan(view, pos) {\n        for(let i = 0, off = 0; i < view.children.length && off <= pos; i++){\n            let child = view.children[i], end = off + child.length;\n            if (end >= pos) {\n                if (child.children.length) {\n                    scan(child, pos - off);\n                } else if ((!after || after.isHidden && side > 0) && (end > pos || off == end && child.getSide() > 0)) {\n                    after = child;\n                    afterPos = pos - off;\n                } else if (off < pos || off == end && child.getSide() < 0 && !child.isHidden) {\n                    before = child;\n                    beforePos = pos - off;\n                }\n            }\n            off = end;\n        }\n    }\n    scan(view, pos);\n    let target = (side < 0 ? before : after) || before || after;\n    if (target) return target.coordsAt(Math.max(0, target == before ? beforePos : afterPos), side);\n    return fallbackRect(view);\n}\nfunction fallbackRect(view) {\n    let last = view.dom.lastChild;\n    if (!last) return view.dom.getBoundingClientRect();\n    let rects = clientRectsFor(last);\n    return rects[rects.length - 1] || null;\n}\nfunction combineAttrs(source, target) {\n    for(let name in source){\n        if (name == \"class\" && target.class) target.class += \" \" + source.class;\n        else if (name == \"style\" && target.style) target.style += \";\" + source.style;\n        else target[name] = source[name];\n    }\n    return target;\n}\nconst noAttrs = /*@__PURE__*/ Object.create(null);\nfunction attrsEq(a, b, ignore) {\n    if (a == b) return true;\n    if (!a) a = noAttrs;\n    if (!b) b = noAttrs;\n    let keysA = Object.keys(a), keysB = Object.keys(b);\n    if (keysA.length - (ignore && keysA.indexOf(ignore) > -1 ? 1 : 0) != keysB.length - (ignore && keysB.indexOf(ignore) > -1 ? 1 : 0)) return false;\n    for (let key of keysA){\n        if (key != ignore && (keysB.indexOf(key) == -1 || a[key] !== b[key])) return false;\n    }\n    return true;\n}\nfunction updateAttrs(dom, prev, attrs) {\n    let changed = false;\n    if (prev) {\n        for(let name in prev)if (!(attrs && name in attrs)) {\n            changed = true;\n            if (name == \"style\") dom.style.cssText = \"\";\n            else dom.removeAttribute(name);\n        }\n    }\n    if (attrs) {\n        for(let name in attrs)if (!(prev && prev[name] == attrs[name])) {\n            changed = true;\n            if (name == \"style\") dom.style.cssText = attrs[name];\n            else dom.setAttribute(name, attrs[name]);\n        }\n    }\n    return changed;\n}\nfunction getAttrs(dom) {\n    let attrs = Object.create(null);\n    for(let i = 0; i < dom.attributes.length; i++){\n        let attr = dom.attributes[i];\n        attrs[attr.name] = attr.value;\n    }\n    return attrs;\n}\nclass LineView extends ContentView {\n    constructor(){\n        super(...arguments);\n        this.children = [];\n        this.length = 0;\n        this.prevAttrs = undefined;\n        this.attrs = null;\n        this.breakAfter = 0;\n    }\n    // Consumes source\n    merge(from, to, source, hasStart, openStart, openEnd) {\n        if (source) {\n            if (!(source instanceof LineView)) return false;\n            if (!this.dom) source.transferDOM(this); // Reuse source.dom when appropriate\n        }\n        if (hasStart) this.setDeco(source ? source.attrs : null);\n        mergeChildrenInto(this, from, to, source ? source.children : [], openStart, openEnd);\n        return true;\n    }\n    split(at) {\n        let end = new LineView;\n        end.breakAfter = this.breakAfter;\n        if (this.length == 0) return end;\n        let { i, off } = this.childPos(at);\n        if (off) {\n            end.append(this.children[i].split(off), 0);\n            this.children[i].merge(off, this.children[i].length, null, false, 0, 0);\n            i++;\n        }\n        for(let j = i; j < this.children.length; j++)end.append(this.children[j], 0);\n        while(i > 0 && this.children[i - 1].length == 0)this.children[--i].destroy();\n        this.children.length = i;\n        this.markDirty();\n        this.length = at;\n        return end;\n    }\n    transferDOM(other) {\n        if (!this.dom) return;\n        this.markDirty();\n        other.setDOM(this.dom);\n        other.prevAttrs = this.prevAttrs === undefined ? this.attrs : this.prevAttrs;\n        this.prevAttrs = undefined;\n        this.dom = null;\n    }\n    setDeco(attrs) {\n        if (!attrsEq(this.attrs, attrs)) {\n            if (this.dom) {\n                this.prevAttrs = this.attrs;\n                this.markDirty();\n            }\n            this.attrs = attrs;\n        }\n    }\n    append(child, openStart) {\n        joinInlineInto(this, child, openStart);\n    }\n    // Only called when building a line view in ContentBuilder\n    addLineDeco(deco) {\n        let attrs = deco.spec.attributes, cls = deco.spec.class;\n        if (attrs) this.attrs = combineAttrs(attrs, this.attrs || {});\n        if (cls) this.attrs = combineAttrs({\n            class: cls\n        }, this.attrs || {});\n    }\n    domAtPos(pos) {\n        return inlineDOMAtPos(this, pos);\n    }\n    reuseDOM(node) {\n        if (node.nodeName == \"DIV\") {\n            this.setDOM(node);\n            this.flags |= 4 /* ViewFlag.AttrsDirty */  | 2 /* ViewFlag.NodeDirty */ ;\n        }\n    }\n    sync(view, track) {\n        var _a;\n        if (!this.dom) {\n            this.setDOM(document.createElement(\"div\"));\n            this.dom.className = \"cm-line\";\n            this.prevAttrs = this.attrs ? null : undefined;\n        } else if (this.flags & 4 /* ViewFlag.AttrsDirty */ ) {\n            clearAttributes(this.dom);\n            this.dom.className = \"cm-line\";\n            this.prevAttrs = this.attrs ? null : undefined;\n        }\n        if (this.prevAttrs !== undefined) {\n            updateAttrs(this.dom, this.prevAttrs, this.attrs);\n            this.dom.classList.add(\"cm-line\");\n            this.prevAttrs = undefined;\n        }\n        super.sync(view, track);\n        let last = this.dom.lastChild;\n        while(last && ContentView.get(last) instanceof MarkView)last = last.lastChild;\n        if (!last || !this.length || last.nodeName != \"BR\" && ((_a = ContentView.get(last)) === null || _a === void 0 ? void 0 : _a.isEditable) == false && (!browser.ios || !this.children.some((ch)=>ch instanceof TextView))) {\n            let hack = document.createElement(\"BR\");\n            hack.cmIgnore = true;\n            this.dom.appendChild(hack);\n        }\n    }\n    measureTextSize() {\n        if (this.children.length == 0 || this.length > 20) return null;\n        let totalWidth = 0, textHeight;\n        for (let child of this.children){\n            if (!(child instanceof TextView) || /[^ -~]/.test(child.text)) return null;\n            let rects = clientRectsFor(child.dom);\n            if (rects.length != 1) return null;\n            totalWidth += rects[0].width;\n            textHeight = rects[0].height;\n        }\n        return !totalWidth ? null : {\n            lineHeight: this.dom.getBoundingClientRect().height,\n            charWidth: totalWidth / this.length,\n            textHeight\n        };\n    }\n    coordsAt(pos, side) {\n        let rect = coordsInChildren(this, pos, side);\n        // Correct rectangle height for empty lines when the returned\n        // height is larger than the text height.\n        if (!this.children.length && rect && this.parent) {\n            let { heightOracle } = this.parent.view.viewState, height = rect.bottom - rect.top;\n            if (Math.abs(height - heightOracle.lineHeight) < 2 && heightOracle.textHeight < height) {\n                let dist = (height - heightOracle.textHeight) / 2;\n                return {\n                    top: rect.top + dist,\n                    bottom: rect.bottom - dist,\n                    left: rect.left,\n                    right: rect.left\n                };\n            }\n        }\n        return rect;\n    }\n    become(_other) {\n        return false;\n    }\n    covers() {\n        return true;\n    }\n    static find(docView, pos) {\n        for(let i = 0, off = 0; i < docView.children.length; i++){\n            let block = docView.children[i], end = off + block.length;\n            if (end >= pos) {\n                if (block instanceof LineView) return block;\n                if (end > pos) break;\n            }\n            off = end + block.breakAfter;\n        }\n        return null;\n    }\n}\nclass BlockWidgetView extends ContentView {\n    constructor(widget, length, deco){\n        super();\n        this.widget = widget;\n        this.length = length;\n        this.deco = deco;\n        this.breakAfter = 0;\n        this.prevWidget = null;\n    }\n    merge(from, to, source, _takeDeco, openStart, openEnd) {\n        if (source && (!(source instanceof BlockWidgetView) || !this.widget.compare(source.widget) || from > 0 && openStart <= 0 || to < this.length && openEnd <= 0)) return false;\n        this.length = from + (source ? source.length : 0) + (this.length - to);\n        return true;\n    }\n    domAtPos(pos) {\n        return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);\n    }\n    split(at) {\n        let len = this.length - at;\n        this.length = at;\n        let end = new BlockWidgetView(this.widget, len, this.deco);\n        end.breakAfter = this.breakAfter;\n        return end;\n    }\n    get children() {\n        return noChildren;\n    }\n    sync(view) {\n        if (!this.dom || !this.widget.updateDOM(this.dom, view)) {\n            if (this.dom && this.prevWidget) this.prevWidget.destroy(this.dom);\n            this.prevWidget = null;\n            this.setDOM(this.widget.toDOM(view));\n            this.dom.contentEditable = \"false\";\n        }\n    }\n    get overrideDOMText() {\n        return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Text.empty;\n    }\n    domBoundsAround() {\n        return null;\n    }\n    become(other) {\n        if (other instanceof BlockWidgetView && other.widget.constructor == this.widget.constructor) {\n            if (!other.widget.compare(this.widget)) this.markDirty(true);\n            if (this.dom && !this.prevWidget) this.prevWidget = this.widget;\n            this.widget = other.widget;\n            this.length = other.length;\n            this.deco = other.deco;\n            this.breakAfter = other.breakAfter;\n            return true;\n        }\n        return false;\n    }\n    ignoreMutation() {\n        return true;\n    }\n    ignoreEvent(event) {\n        return this.widget.ignoreEvent(event);\n    }\n    get isEditable() {\n        return false;\n    }\n    get isWidget() {\n        return true;\n    }\n    coordsAt(pos, side) {\n        return this.widget.coordsAt(this.dom, pos, side);\n    }\n    destroy() {\n        super.destroy();\n        if (this.dom) this.widget.destroy(this.dom);\n    }\n    covers(side) {\n        let { startSide, endSide } = this.deco;\n        return startSide == endSide ? false : side < 0 ? startSide < 0 : endSide > 0;\n    }\n}\n/**\nWidgets added to the content are described by subclasses of this\nclass. Using a description object like that makes it possible to\ndelay creating of the DOM structure for a widget until it is\nneeded, and to avoid redrawing widgets even if the decorations\nthat define them are recreated.\n*/ class WidgetType {\n    /**\n    Compare this instance to another instance of the same type.\n    (TypeScript can't express this, but only instances of the same\n    specific class will be passed to this method.) This is used to\n    avoid redrawing widgets when they are replaced by a new\n    decoration of the same type. The default implementation just\n    returns `false`, which will cause new instances of the widget to\n    always be redrawn.\n    */ eq(widget) {\n        return false;\n    }\n    /**\n    Update a DOM element created by a widget of the same type (but\n    different, non-`eq` content) to reflect this widget. May return\n    true to indicate that it could update, false to indicate it\n    couldn't (in which case the widget will be redrawn). The default\n    implementation just returns false.\n    */ updateDOM(dom, view) {\n        return false;\n    }\n    /**\n    @internal\n    */ compare(other) {\n        return this == other || this.constructor == other.constructor && this.eq(other);\n    }\n    /**\n    The estimated height this widget will have, to be used when\n    estimating the height of content that hasn't been drawn. May\n    return -1 to indicate you don't know. The default implementation\n    returns -1.\n    */ get estimatedHeight() {\n        return -1;\n    }\n    /**\n    For inline widgets that are displayed inline (as opposed to\n    `inline-block`) and introduce line breaks (through `<br>` tags\n    or textual newlines), this must indicate the amount of line\n    breaks they introduce. Defaults to 0.\n    */ get lineBreaks() {\n        return 0;\n    }\n    /**\n    Can be used to configure which kinds of events inside the widget\n    should be ignored by the editor. The default is to ignore all\n    events.\n    */ ignoreEvent(event) {\n        return true;\n    }\n    /**\n    Override the way screen coordinates for positions at/in the\n    widget are found. `pos` will be the offset into the widget, and\n    `side` the side of the position that is being queried—less than\n    zero for before, greater than zero for after, and zero for\n    directly at that position.\n    */ coordsAt(dom, pos, side) {\n        return null;\n    }\n    /**\n    @internal\n    */ get isHidden() {\n        return false;\n    }\n    /**\n    This is called when the an instance of the widget is removed\n    from the editor view.\n    */ destroy(dom) {}\n}\n/**\nThe different types of blocks that can occur in an editor view.\n*/ var BlockType = /*@__PURE__*/ function(BlockType) {\n    /**\n    A line of text.\n    */ BlockType[BlockType[\"Text\"] = 0] = \"Text\";\n    /**\n    A block widget associated with the position after it.\n    */ BlockType[BlockType[\"WidgetBefore\"] = 1] = \"WidgetBefore\";\n    /**\n    A block widget associated with the position before it.\n    */ BlockType[BlockType[\"WidgetAfter\"] = 2] = \"WidgetAfter\";\n    /**\n    A block widget [replacing](https://codemirror.net/6/docs/ref/#view.Decoration^replace) a range of content.\n    */ BlockType[BlockType[\"WidgetRange\"] = 3] = \"WidgetRange\";\n    return BlockType;\n}(BlockType || (BlockType = {}));\n/**\nA decoration provides information on how to draw or style a piece\nof content. You'll usually use it wrapped in a\n[`Range`](https://codemirror.net/6/docs/ref/#state.Range), which adds a start and end position.\n@nonabstract\n*/ class Decoration extends _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeValue {\n    constructor(/**\n    @internal\n    */ startSide, /**\n    @internal\n    */ endSide, /**\n    @internal\n    */ widget, /**\n    The config object used to create this decoration. You can\n    include additional properties in there to store metadata about\n    your decoration.\n    */ spec){\n        super();\n        this.startSide = startSide;\n        this.endSide = endSide;\n        this.widget = widget;\n        this.spec = spec;\n    }\n    /**\n    @internal\n    */ get heightRelevant() {\n        return false;\n    }\n    /**\n    Create a mark decoration, which influences the styling of the\n    content in its range. Nested mark decorations will cause nested\n    DOM elements to be created. Nesting order is determined by\n    precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), with\n    the higher-precedence decorations creating the inner DOM nodes.\n    Such elements are split on line boundaries and on the boundaries\n    of lower-precedence decorations.\n    */ static mark(spec) {\n        return new MarkDecoration(spec);\n    }\n    /**\n    Create a widget decoration, which displays a DOM element at the\n    given position.\n    */ static widget(spec) {\n        let side = Math.max(-10000, Math.min(10000, spec.side || 0)), block = !!spec.block;\n        side += block && !spec.inlineOrder ? side > 0 ? 300000000 /* Side.BlockAfter */  : -400000000 /* Side.BlockBefore */  : side > 0 ? 100000000 /* Side.InlineAfter */  : -100000000 /* Side.InlineBefore */ ;\n        return new PointDecoration(spec, side, side, block, spec.widget || null, false);\n    }\n    /**\n    Create a replace decoration which replaces the given range with\n    a widget, or simply hides it.\n    */ static replace(spec) {\n        let block = !!spec.block, startSide, endSide;\n        if (spec.isBlockGap) {\n            startSide = -500000000 /* Side.GapStart */ ;\n            endSide = 400000000 /* Side.GapEnd */ ;\n        } else {\n            let { start, end } = getInclusive(spec, block);\n            startSide = (start ? block ? -300000000 /* Side.BlockIncStart */  : -1 /* Side.InlineIncStart */  : 500000000 /* Side.NonIncStart */ ) - 1;\n            endSide = (end ? block ? 200000000 /* Side.BlockIncEnd */  : 1 /* Side.InlineIncEnd */  : -600000000 /* Side.NonIncEnd */ ) + 1;\n        }\n        return new PointDecoration(spec, startSide, endSide, block, spec.widget || null, true);\n    }\n    /**\n    Create a line decoration, which can add DOM attributes to the\n    line starting at the given position.\n    */ static line(spec) {\n        return new LineDecoration(spec);\n    }\n    /**\n    Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given\n    decorated range or ranges. If the ranges aren't already sorted,\n    pass `true` for `sort` to make the library sort them for you.\n    */ static set(of, sort = false) {\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.of(of, sort);\n    }\n    /**\n    @internal\n    */ hasHeight() {\n        return this.widget ? this.widget.estimatedHeight > -1 : false;\n    }\n}\n/**\nThe empty set of decorations.\n*/ Decoration.none = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.empty;\nclass MarkDecoration extends Decoration {\n    constructor(spec){\n        let { start, end } = getInclusive(spec);\n        super(start ? -1 /* Side.InlineIncStart */  : 500000000 /* Side.NonIncStart */ , end ? 1 /* Side.InlineIncEnd */  : -600000000 /* Side.NonIncEnd */ , null, spec);\n        this.tagName = spec.tagName || \"span\";\n        this.class = spec.class || \"\";\n        this.attrs = spec.attributes || null;\n    }\n    eq(other) {\n        var _a, _b;\n        return this == other || other instanceof MarkDecoration && this.tagName == other.tagName && (this.class || ((_a = this.attrs) === null || _a === void 0 ? void 0 : _a.class)) == (other.class || ((_b = other.attrs) === null || _b === void 0 ? void 0 : _b.class)) && attrsEq(this.attrs, other.attrs, \"class\");\n    }\n    range(from, to = from) {\n        if (from >= to) throw new RangeError(\"Mark decorations may not be empty\");\n        return super.range(from, to);\n    }\n}\nMarkDecoration.prototype.point = false;\nclass LineDecoration extends Decoration {\n    constructor(spec){\n        super(-200000000 /* Side.Line */ , -200000000 /* Side.Line */ , null, spec);\n    }\n    eq(other) {\n        return other instanceof LineDecoration && this.spec.class == other.spec.class && attrsEq(this.spec.attributes, other.spec.attributes);\n    }\n    range(from, to = from) {\n        if (to != from) throw new RangeError(\"Line decoration ranges must be zero-length\");\n        return super.range(from, to);\n    }\n}\nLineDecoration.prototype.mapMode = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.MapMode.TrackBefore;\nLineDecoration.prototype.point = true;\nclass PointDecoration extends Decoration {\n    constructor(spec, startSide, endSide, block, widget, isReplace){\n        super(startSide, endSide, widget, spec);\n        this.block = block;\n        this.isReplace = isReplace;\n        this.mapMode = !block ? _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.MapMode.TrackDel : startSide <= 0 ? _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.MapMode.TrackBefore : _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.MapMode.TrackAfter;\n    }\n    // Only relevant when this.block == true\n    get type() {\n        return this.startSide != this.endSide ? BlockType.WidgetRange : this.startSide <= 0 ? BlockType.WidgetBefore : BlockType.WidgetAfter;\n    }\n    get heightRelevant() {\n        return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);\n    }\n    eq(other) {\n        return other instanceof PointDecoration && widgetsEq(this.widget, other.widget) && this.block == other.block && this.startSide == other.startSide && this.endSide == other.endSide;\n    }\n    range(from, to = from) {\n        if (this.isReplace && (from > to || from == to && this.startSide > 0 && this.endSide <= 0)) throw new RangeError(\"Invalid range for replacement decoration\");\n        if (!this.isReplace && to != from) throw new RangeError(\"Widget decorations can only have zero-length ranges\");\n        return super.range(from, to);\n    }\n}\nPointDecoration.prototype.point = true;\nfunction getInclusive(spec, block = false) {\n    let { inclusiveStart: start, inclusiveEnd: end } = spec;\n    if (start == null) start = spec.inclusive;\n    if (end == null) end = spec.inclusive;\n    return {\n        start: start !== null && start !== void 0 ? start : block,\n        end: end !== null && end !== void 0 ? end : block\n    };\n}\nfunction widgetsEq(a, b) {\n    return a == b || !!(a && b && a.compare(b));\n}\nfunction addRange(from, to, ranges, margin = 0) {\n    let last = ranges.length - 1;\n    if (last >= 0 && ranges[last] + margin >= from) ranges[last] = Math.max(ranges[last], to);\n    else ranges.push(from, to);\n}\nclass ContentBuilder {\n    constructor(doc, pos, end, disallowBlockEffectsFor){\n        this.doc = doc;\n        this.pos = pos;\n        this.end = end;\n        this.disallowBlockEffectsFor = disallowBlockEffectsFor;\n        this.content = [];\n        this.curLine = null;\n        this.breakAtStart = 0;\n        this.pendingBuffer = 0 /* Buf.No */ ;\n        this.bufferMarks = [];\n        // Set to false directly after a widget that covers the position after it\n        this.atCursorPos = true;\n        this.openStart = -1;\n        this.openEnd = -1;\n        this.text = \"\";\n        this.textOff = 0;\n        this.cursor = doc.iter();\n        this.skip = pos;\n    }\n    posCovered() {\n        if (this.content.length == 0) return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;\n        let last = this.content[this.content.length - 1];\n        return !(last.breakAfter || last instanceof BlockWidgetView && last.deco.endSide < 0);\n    }\n    getLine() {\n        if (!this.curLine) {\n            this.content.push(this.curLine = new LineView);\n            this.atCursorPos = true;\n        }\n        return this.curLine;\n    }\n    flushBuffer(active = this.bufferMarks) {\n        if (this.pendingBuffer) {\n            this.curLine.append(wrapMarks(new WidgetBufferView(-1), active), active.length);\n            this.pendingBuffer = 0 /* Buf.No */ ;\n        }\n    }\n    addBlockWidget(view) {\n        this.flushBuffer();\n        this.curLine = null;\n        this.content.push(view);\n    }\n    finish(openEnd) {\n        if (this.pendingBuffer && openEnd <= this.bufferMarks.length) this.flushBuffer();\n        else this.pendingBuffer = 0 /* Buf.No */ ;\n        if (!this.posCovered() && !(openEnd && this.content.length && this.content[this.content.length - 1] instanceof BlockWidgetView)) this.getLine();\n    }\n    buildText(length, active, openStart) {\n        while(length > 0){\n            if (this.textOff == this.text.length) {\n                let { value, lineBreak, done } = this.cursor.next(this.skip);\n                this.skip = 0;\n                if (done) throw new Error(\"Ran out of text content when drawing inline views\");\n                if (lineBreak) {\n                    if (!this.posCovered()) this.getLine();\n                    if (this.content.length) this.content[this.content.length - 1].breakAfter = 1;\n                    else this.breakAtStart = 1;\n                    this.flushBuffer();\n                    this.curLine = null;\n                    this.atCursorPos = true;\n                    length--;\n                    continue;\n                } else {\n                    this.text = value;\n                    this.textOff = 0;\n                }\n            }\n            let take = Math.min(this.text.length - this.textOff, length, 512 /* T.Chunk */ );\n            this.flushBuffer(active.slice(active.length - openStart));\n            this.getLine().append(wrapMarks(new TextView(this.text.slice(this.textOff, this.textOff + take)), active), openStart);\n            this.atCursorPos = true;\n            this.textOff += take;\n            length -= take;\n            openStart = 0;\n        }\n    }\n    span(from, to, active, openStart) {\n        this.buildText(to - from, active, openStart);\n        this.pos = to;\n        if (this.openStart < 0) this.openStart = openStart;\n    }\n    point(from, to, deco, active, openStart, index) {\n        if (this.disallowBlockEffectsFor[index] && deco instanceof PointDecoration) {\n            if (deco.block) throw new RangeError(\"Block decorations may not be specified via plugins\");\n            if (to > this.doc.lineAt(this.pos).to) throw new RangeError(\"Decorations that replace line breaks may not be specified via plugins\");\n        }\n        let len = to - from;\n        if (deco instanceof PointDecoration) {\n            if (deco.block) {\n                if (deco.startSide > 0 && !this.posCovered()) this.getLine();\n                this.addBlockWidget(new BlockWidgetView(deco.widget || new NullWidget(\"div\"), len, deco));\n            } else {\n                let view = WidgetView.create(deco.widget || new NullWidget(\"span\"), len, len ? 0 : deco.startSide);\n                let cursorBefore = this.atCursorPos && !view.isEditable && openStart <= active.length && (from < to || deco.startSide > 0);\n                let cursorAfter = !view.isEditable && (from < to || openStart > active.length || deco.startSide <= 0);\n                let line = this.getLine();\n                if (this.pendingBuffer == 2 /* Buf.IfCursor */  && !cursorBefore && !view.isEditable) this.pendingBuffer = 0 /* Buf.No */ ;\n                this.flushBuffer(active);\n                if (cursorBefore) {\n                    line.append(wrapMarks(new WidgetBufferView(1), active), openStart);\n                    openStart = active.length + Math.max(0, openStart - active.length);\n                }\n                line.append(wrapMarks(view, active), openStart);\n                this.atCursorPos = cursorAfter;\n                this.pendingBuffer = !cursorAfter ? 0 /* Buf.No */  : from < to || openStart > active.length ? 1 /* Buf.Yes */  : 2 /* Buf.IfCursor */ ;\n                if (this.pendingBuffer) this.bufferMarks = active.slice();\n            }\n        } else if (this.doc.lineAt(this.pos).from == this.pos) {\n            this.getLine().addLineDeco(deco);\n        }\n        if (len) {\n            // Advance the iterator past the replaced content\n            if (this.textOff + len <= this.text.length) {\n                this.textOff += len;\n            } else {\n                this.skip += len - (this.text.length - this.textOff);\n                this.text = \"\";\n                this.textOff = 0;\n            }\n            this.pos = to;\n        }\n        if (this.openStart < 0) this.openStart = openStart;\n    }\n    static build(text, from, to, decorations, dynamicDecorationMap) {\n        let builder = new ContentBuilder(text, from, to, dynamicDecorationMap);\n        builder.openEnd = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.spans(decorations, from, to, builder);\n        if (builder.openStart < 0) builder.openStart = builder.openEnd;\n        builder.finish(builder.openEnd);\n        return builder;\n    }\n}\nfunction wrapMarks(view, active) {\n    for (let mark of active)view = new MarkView(mark, [\n        view\n    ], view.length);\n    return view;\n}\nclass NullWidget extends WidgetType {\n    constructor(tag){\n        super();\n        this.tag = tag;\n    }\n    eq(other) {\n        return other.tag == this.tag;\n    }\n    toDOM() {\n        return document.createElement(this.tag);\n    }\n    updateDOM(elt) {\n        return elt.nodeName.toLowerCase() == this.tag;\n    }\n    get isHidden() {\n        return true;\n    }\n}\nconst clickAddsSelectionRange = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst dragMovesSelection$1 = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst mouseSelectionStyle = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst exceptionSink = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst updateListener = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst inputHandler = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst focusChangeEffect = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst perLineTextDirection = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    combine: (values)=>values.some((x)=>x)\n});\nconst nativeSelectionHidden = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    combine: (values)=>values.some((x)=>x)\n});\nclass ScrollTarget {\n    constructor(range, y = \"nearest\", x = \"nearest\", yMargin = 5, xMargin = 5, // This data structure is abused to also store precise scroll\n    // snapshots, instead of a `scrollIntoView` request. When this\n    // flag is `true`, `range` points at a position in the reference\n    // line, `yMargin` holds the difference between the top of that\n    // line and the top of the editor, and `xMargin` holds the\n    // editor's `scrollLeft`.\n    isSnapshot = false){\n        this.range = range;\n        this.y = y;\n        this.x = x;\n        this.yMargin = yMargin;\n        this.xMargin = xMargin;\n        this.isSnapshot = isSnapshot;\n    }\n    map(changes) {\n        return changes.empty ? this : new ScrollTarget(this.range.map(changes), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);\n    }\n    clip(state) {\n        return this.range.to <= state.doc.length ? this : new ScrollTarget(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(state.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);\n    }\n}\nconst scrollIntoView = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.define({\n    map: (t, ch)=>t.map(ch)\n});\n/**\nLog or report an unhandled exception in client code. Should\nprobably only be used by extension code that allows client code to\nprovide functions, and calls those functions in a context where an\nexception can't be propagated to calling code in a reasonable way\n(for example when in an event handler).\n\nEither calls a handler registered with\n[`EditorView.exceptionSink`](https://codemirror.net/6/docs/ref/#view.EditorView^exceptionSink),\n`window.onerror`, if defined, or `console.error` (in which case\nit'll pass `context`, when given, as first argument).\n*/ function logException(state, exception, context) {\n    let handler = state.facet(exceptionSink);\n    if (handler.length) handler[0](exception);\n    else if (window.onerror) window.onerror(String(exception), context, undefined, undefined, exception);\n    else if (context) console.error(context + \":\", exception);\n    else console.error(exception);\n}\nconst editable = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    combine: (values)=>values.length ? values[0] : true\n});\nlet nextPluginID = 0;\nconst viewPlugin = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\n/**\nView plugins associate stateful values with a view. They can\ninfluence the way the content is drawn, and are notified of things\nthat happen in the view.\n*/ class ViewPlugin {\n    constructor(/**\n    @internal\n    */ id, /**\n    @internal\n    */ create, /**\n    @internal\n    */ domEventHandlers, /**\n    @internal\n    */ domEventObservers, buildExtensions){\n        this.id = id;\n        this.create = create;\n        this.domEventHandlers = domEventHandlers;\n        this.domEventObservers = domEventObservers;\n        this.extension = buildExtensions(this);\n    }\n    /**\n    Define a plugin from a constructor function that creates the\n    plugin's value, given an editor view.\n    */ static define(create, spec) {\n        const { eventHandlers, eventObservers, provide, decorations: deco } = spec || {};\n        return new ViewPlugin(nextPluginID++, create, eventHandlers, eventObservers, (plugin)=>{\n            let ext = [\n                viewPlugin.of(plugin)\n            ];\n            if (deco) ext.push(decorations.of((view)=>{\n                let pluginInst = view.plugin(plugin);\n                return pluginInst ? deco(pluginInst) : Decoration.none;\n            }));\n            if (provide) ext.push(provide(plugin));\n            return ext;\n        });\n    }\n    /**\n    Create a plugin for a class whose constructor takes a single\n    editor view as argument.\n    */ static fromClass(cls, spec) {\n        return ViewPlugin.define((view)=>new cls(view), spec);\n    }\n}\nclass PluginInstance {\n    constructor(spec){\n        this.spec = spec;\n        // When starting an update, all plugins have this field set to the\n        // update object, indicating they need to be updated. When finished\n        // updating, it is set to `false`. Retrieving a plugin that needs to\n        // be updated with `view.plugin` forces an eager update.\n        this.mustUpdate = null;\n        // This is null when the plugin is initially created, but\n        // initialized on the first update.\n        this.value = null;\n    }\n    update(view) {\n        if (!this.value) {\n            if (this.spec) {\n                try {\n                    this.value = this.spec.create(view);\n                } catch (e) {\n                    logException(view.state, e, \"CodeMirror plugin crashed\");\n                    this.deactivate();\n                }\n            }\n        } else if (this.mustUpdate) {\n            let update = this.mustUpdate;\n            this.mustUpdate = null;\n            if (this.value.update) {\n                try {\n                    this.value.update(update);\n                } catch (e) {\n                    logException(update.state, e, \"CodeMirror plugin crashed\");\n                    if (this.value.destroy) try {\n                        this.value.destroy();\n                    } catch (_) {}\n                    this.deactivate();\n                }\n            }\n        }\n        return this;\n    }\n    destroy(view) {\n        var _a;\n        if ((_a = this.value) === null || _a === void 0 ? void 0 : _a.destroy) {\n            try {\n                this.value.destroy();\n            } catch (e) {\n                logException(view.state, e, \"CodeMirror plugin crashed\");\n            }\n        }\n    }\n    deactivate() {\n        this.spec = this.value = null;\n    }\n}\nconst editorAttributes = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst contentAttributes = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\n// Provide decorations\nconst decorations = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst atomicRanges = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst bidiIsolatedRanges = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nfunction getIsolatedRanges(view, from, to) {\n    let isolates = view.state.facet(bidiIsolatedRanges);\n    if (!isolates.length) return isolates;\n    let sets = isolates.map((i)=>i instanceof Function ? i(view) : i);\n    let result = [];\n    _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.spans(sets, from, to, {\n        point () {},\n        span (from, to, active, open) {\n            let level = result;\n            for(let i = active.length - 1; i >= 0; i--, open--){\n                let iso = active[i].spec.bidiIsolate, update;\n                if (iso == null) continue;\n                if (open > 0 && level.length && (update = level[level.length - 1]).to == from && update.direction == iso) {\n                    update.to = to;\n                    level = update.inner;\n                } else {\n                    let add = {\n                        from,\n                        to,\n                        direction: iso,\n                        inner: []\n                    };\n                    level.push(add);\n                    level = add.inner;\n                }\n            }\n        }\n    });\n    return result;\n}\nconst scrollMargins = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nfunction getScrollMargins(view) {\n    let left = 0, right = 0, top = 0, bottom = 0;\n    for (let source of view.state.facet(scrollMargins)){\n        let m = source(view);\n        if (m) {\n            if (m.left != null) left = Math.max(left, m.left);\n            if (m.right != null) right = Math.max(right, m.right);\n            if (m.top != null) top = Math.max(top, m.top);\n            if (m.bottom != null) bottom = Math.max(bottom, m.bottom);\n        }\n    }\n    return {\n        left,\n        right,\n        top,\n        bottom\n    };\n}\nconst styleModule = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nclass ChangedRange {\n    constructor(fromA, toA, fromB, toB){\n        this.fromA = fromA;\n        this.toA = toA;\n        this.fromB = fromB;\n        this.toB = toB;\n    }\n    join(other) {\n        return new ChangedRange(Math.min(this.fromA, other.fromA), Math.max(this.toA, other.toA), Math.min(this.fromB, other.fromB), Math.max(this.toB, other.toB));\n    }\n    addToSet(set) {\n        let i = set.length, me = this;\n        for(; i > 0; i--){\n            let range = set[i - 1];\n            if (range.fromA > me.toA) continue;\n            if (range.toA < me.fromA) break;\n            me = me.join(range);\n            set.splice(i - 1, 1);\n        }\n        set.splice(i, 0, me);\n        return set;\n    }\n    static extendWithRanges(diff, ranges) {\n        if (ranges.length == 0) return diff;\n        let result = [];\n        for(let dI = 0, rI = 0, posA = 0, posB = 0;; dI++){\n            let next = dI == diff.length ? null : diff[dI], off = posA - posB;\n            let end = next ? next.fromB : 1e9;\n            while(rI < ranges.length && ranges[rI] < end){\n                let from = ranges[rI], to = ranges[rI + 1];\n                let fromB = Math.max(posB, from), toB = Math.min(end, to);\n                if (fromB <= toB) new ChangedRange(fromB + off, toB + off, fromB, toB).addToSet(result);\n                if (to > end) break;\n                else rI += 2;\n            }\n            if (!next) return result;\n            new ChangedRange(next.fromA, next.toA, next.fromB, next.toB).addToSet(result);\n            posA = next.toA;\n            posB = next.toB;\n        }\n    }\n}\n/**\nView [plugins](https://codemirror.net/6/docs/ref/#view.ViewPlugin) are given instances of this\nclass, which describe what happened, whenever the view is updated.\n*/ class ViewUpdate {\n    constructor(/**\n    The editor view that the update is associated with.\n    */ view, /**\n    The new editor state.\n    */ state, /**\n    The transactions involved in the update. May be empty.\n    */ transactions){\n        this.view = view;\n        this.state = state;\n        this.transactions = transactions;\n        /**\n        @internal\n        */ this.flags = 0;\n        this.startState = view.state;\n        this.changes = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.ChangeSet.empty(this.startState.doc.length);\n        for (let tr of transactions)this.changes = this.changes.compose(tr.changes);\n        let changedRanges = [];\n        this.changes.iterChangedRanges((fromA, toA, fromB, toB)=>changedRanges.push(new ChangedRange(fromA, toA, fromB, toB)));\n        this.changedRanges = changedRanges;\n    }\n    /**\n    @internal\n    */ static create(view, state, transactions) {\n        return new ViewUpdate(view, state, transactions);\n    }\n    /**\n    Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or\n    [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this\n    update.\n    */ get viewportChanged() {\n        return (this.flags & 4 /* UpdateFlag.Viewport */ ) > 0;\n    }\n    /**\n    Indicates whether the height of a block element in the editor\n    changed in this update.\n    */ get heightChanged() {\n        return (this.flags & 2 /* UpdateFlag.Height */ ) > 0;\n    }\n    /**\n    Returns true when the document was modified or the size of the\n    editor, or elements within the editor, changed.\n    */ get geometryChanged() {\n        return this.docChanged || (this.flags & (8 /* UpdateFlag.Geometry */  | 2 /* UpdateFlag.Height */ )) > 0;\n    }\n    /**\n    True when this update indicates a focus change.\n    */ get focusChanged() {\n        return (this.flags & 1 /* UpdateFlag.Focus */ ) > 0;\n    }\n    /**\n    Whether the document changed in this update.\n    */ get docChanged() {\n        return !this.changes.empty;\n    }\n    /**\n    Whether the selection was explicitly set in this update.\n    */ get selectionSet() {\n        return this.transactions.some((tr)=>tr.selection);\n    }\n    /**\n    @internal\n    */ get empty() {\n        return this.flags == 0 && this.transactions.length == 0;\n    }\n}\n/**\nUsed to indicate [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).\n*/ var Direction = /*@__PURE__*/ function(Direction) {\n    // (These are chosen to match the base levels, in bidi algorithm\n    // terms, of spans in that direction.)\n    /**\n    Left-to-right.\n    */ Direction[Direction[\"LTR\"] = 0] = \"LTR\";\n    /**\n    Right-to-left.\n    */ Direction[Direction[\"RTL\"] = 1] = \"RTL\";\n    return Direction;\n}(Direction || (Direction = {}));\nconst LTR = Direction.LTR, RTL = Direction.RTL;\n// Decode a string with each type encoded as log2(type)\nfunction dec(str) {\n    let result = [];\n    for(let i = 0; i < str.length; i++)result.push(1 << +str[i]);\n    return result;\n}\n// Character types for codepoints 0 to 0xf8\nconst LowTypes = /*@__PURE__*/ dec(\"88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008\");\n// Character types for codepoints 0x600 to 0x6f9\nconst ArabicTypes = /*@__PURE__*/ dec(\"4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333\");\nconst Brackets = /*@__PURE__*/ Object.create(null), BracketStack = [];\n// There's a lot more in\n// https://www.unicode.org/Public/UCD/latest/ucd/BidiBrackets.txt,\n// which are left out to keep code size down.\nfor (let p of [\n    \"()\",\n    \"[]\",\n    \"{}\"\n]){\n    let l = /*@__PURE__*/ p.charCodeAt(0), r = /*@__PURE__*/ p.charCodeAt(1);\n    Brackets[l] = r;\n    Brackets[r] = -l;\n}\nfunction charType(ch) {\n    return ch <= 0xf7 ? LowTypes[ch] : 0x590 <= ch && ch <= 0x5f4 ? 2 /* T.R */  : 0x600 <= ch && ch <= 0x6f9 ? ArabicTypes[ch - 0x600] : 0x6ee <= ch && ch <= 0x8ac ? 4 /* T.AL */  : 0x2000 <= ch && ch <= 0x200c ? 256 /* T.NI */  : 0xfb50 <= ch && ch <= 0xfdff ? 4 /* T.AL */  : 1 /* T.L */ ;\n}\nconst BidiRE = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac\\ufb50-\\ufdff]/;\n/**\nRepresents a contiguous range of text that has a single direction\n(as in left-to-right or right-to-left).\n*/ class BidiSpan {\n    /**\n    The direction of this span.\n    */ get dir() {\n        return this.level % 2 ? RTL : LTR;\n    }\n    /**\n    @internal\n    */ constructor(/**\n    The start of the span (relative to the start of the line).\n    */ from, /**\n    The end of the span.\n    */ to, /**\n    The [\"bidi\n    level\"](https://unicode.org/reports/tr9/#Basic_Display_Algorithm)\n    of the span (in this context, 0 means\n    left-to-right, 1 means right-to-left, 2 means left-to-right\n    number inside right-to-left text).\n    */ level){\n        this.from = from;\n        this.to = to;\n        this.level = level;\n    }\n    /**\n    @internal\n    */ side(end, dir) {\n        return this.dir == dir == end ? this.to : this.from;\n    }\n    /**\n    @internal\n    */ static find(order, index, level, assoc) {\n        let maybe = -1;\n        for(let i = 0; i < order.length; i++){\n            let span = order[i];\n            if (span.from <= index && span.to >= index) {\n                if (span.level == level) return i;\n                // When multiple spans match, if assoc != 0, take the one that\n                // covers that side, otherwise take the one with the minimum\n                // level.\n                if (maybe < 0 || (assoc != 0 ? assoc < 0 ? span.from < index : span.to > index : order[maybe].level > span.level)) maybe = i;\n            }\n        }\n        if (maybe < 0) throw new RangeError(\"Index out of range\");\n        return maybe;\n    }\n}\nfunction isolatesEq(a, b) {\n    if (a.length != b.length) return false;\n    for(let i = 0; i < a.length; i++){\n        let iA = a[i], iB = b[i];\n        if (iA.from != iB.from || iA.to != iB.to || iA.direction != iB.direction || !isolatesEq(iA.inner, iB.inner)) return false;\n    }\n    return true;\n}\n// Reused array of character types\nconst types = [];\n// Fill in the character types (in `types`) from `from` to `to` and\n// apply W normalization rules.\nfunction computeCharTypes(line, rFrom, rTo, isolates, outerType) {\n    for(let iI = 0; iI <= isolates.length; iI++){\n        let from = iI ? isolates[iI - 1].to : rFrom, to = iI < isolates.length ? isolates[iI].from : rTo;\n        let prevType = iI ? 256 /* T.NI */  : outerType;\n        // W1. Examine each non-spacing mark (NSM) in the level run, and\n        // change the type of the NSM to the type of the previous\n        // character. If the NSM is at the start of the level run, it will\n        // get the type of sor.\n        // W2. Search backwards from each instance of a European number\n        // until the first strong type (R, L, AL, or sor) is found. If an\n        // AL is found, change the type of the European number to Arabic\n        // number.\n        // W3. Change all ALs to R.\n        // (Left after this: L, R, EN, AN, ET, CS, NI)\n        for(let i = from, prev = prevType, prevStrong = prevType; i < to; i++){\n            let type = charType(line.charCodeAt(i));\n            if (type == 512 /* T.NSM */ ) type = prev;\n            else if (type == 8 /* T.EN */  && prevStrong == 4 /* T.AL */ ) type = 16 /* T.AN */ ;\n            types[i] = type == 4 /* T.AL */  ? 2 /* T.R */  : type;\n            if (type & 7 /* T.Strong */ ) prevStrong = type;\n            prev = type;\n        }\n        // W5. A sequence of European terminators adjacent to European\n        // numbers changes to all European numbers.\n        // W6. Otherwise, separators and terminators change to Other\n        // Neutral.\n        // W7. Search backwards from each instance of a European number\n        // until the first strong type (R, L, or sor) is found. If an L is\n        // found, then change the type of the European number to L.\n        // (Left after this: L, R, EN+AN, NI)\n        for(let i = from, prev = prevType, prevStrong = prevType; i < to; i++){\n            let type = types[i];\n            if (type == 128 /* T.CS */ ) {\n                if (i < to - 1 && prev == types[i + 1] && prev & 24 /* T.Num */ ) type = types[i] = prev;\n                else types[i] = 256 /* T.NI */ ;\n            } else if (type == 64 /* T.ET */ ) {\n                let end = i + 1;\n                while(end < to && types[end] == 64 /* T.ET */ )end++;\n                let replace = i && prev == 8 /* T.EN */  || end < rTo && types[end] == 8 /* T.EN */  ? prevStrong == 1 /* T.L */  ? 1 /* T.L */  : 8 /* T.EN */  : 256 /* T.NI */ ;\n                for(let j = i; j < end; j++)types[j] = replace;\n                i = end - 1;\n            } else if (type == 8 /* T.EN */  && prevStrong == 1 /* T.L */ ) {\n                types[i] = 1 /* T.L */ ;\n            }\n            prev = type;\n            if (type & 7 /* T.Strong */ ) prevStrong = type;\n        }\n    }\n}\n// Process brackets throughout a run sequence.\nfunction processBracketPairs(line, rFrom, rTo, isolates, outerType) {\n    let oppositeType = outerType == 1 /* T.L */  ? 2 /* T.R */  : 1 /* T.L */ ;\n    for(let iI = 0, sI = 0, context = 0; iI <= isolates.length; iI++){\n        let from = iI ? isolates[iI - 1].to : rFrom, to = iI < isolates.length ? isolates[iI].from : rTo;\n        // N0. Process bracket pairs in an isolating run sequence\n        // sequentially in the logical order of the text positions of the\n        // opening paired brackets using the logic given below. Within this\n        // scope, bidirectional types EN and AN are treated as R.\n        for(let i = from, ch, br, type; i < to; i++){\n            // Keeps [startIndex, type, strongSeen] triples for each open\n            // bracket on BracketStack.\n            if (br = Brackets[ch = line.charCodeAt(i)]) {\n                if (br < 0) {\n                    for(let sJ = sI - 3; sJ >= 0; sJ -= 3){\n                        if (BracketStack[sJ + 1] == -br) {\n                            let flags = BracketStack[sJ + 2];\n                            let type = flags & 2 /* Bracketed.EmbedInside */  ? outerType : !(flags & 4 /* Bracketed.OppositeInside */ ) ? 0 : flags & 1 /* Bracketed.OppositeBefore */  ? oppositeType : outerType;\n                            if (type) types[i] = types[BracketStack[sJ]] = type;\n                            sI = sJ;\n                            break;\n                        }\n                    }\n                } else if (BracketStack.length == 189 /* Bracketed.MaxDepth */ ) {\n                    break;\n                } else {\n                    BracketStack[sI++] = i;\n                    BracketStack[sI++] = ch;\n                    BracketStack[sI++] = context;\n                }\n            } else if ((type = types[i]) == 2 /* T.R */  || type == 1 /* T.L */ ) {\n                let embed = type == outerType;\n                context = embed ? 0 : 1 /* Bracketed.OppositeBefore */ ;\n                for(let sJ = sI - 3; sJ >= 0; sJ -= 3){\n                    let cur = BracketStack[sJ + 2];\n                    if (cur & 2 /* Bracketed.EmbedInside */ ) break;\n                    if (embed) {\n                        BracketStack[sJ + 2] |= 2 /* Bracketed.EmbedInside */ ;\n                    } else {\n                        if (cur & 4 /* Bracketed.OppositeInside */ ) break;\n                        BracketStack[sJ + 2] |= 4 /* Bracketed.OppositeInside */ ;\n                    }\n                }\n            }\n        }\n    }\n}\nfunction processNeutrals(rFrom, rTo, isolates, outerType) {\n    for(let iI = 0, prev = outerType; iI <= isolates.length; iI++){\n        let from = iI ? isolates[iI - 1].to : rFrom, to = iI < isolates.length ? isolates[iI].from : rTo;\n        // N1. A sequence of neutrals takes the direction of the\n        // surrounding strong text if the text on both sides has the same\n        // direction. European and Arabic numbers act as if they were R in\n        // terms of their influence on neutrals. Start-of-level-run (sor)\n        // and end-of-level-run (eor) are used at level run boundaries.\n        // N2. Any remaining neutrals take the embedding direction.\n        // (Left after this: L, R, EN+AN)\n        for(let i = from; i < to;){\n            let type = types[i];\n            if (type == 256 /* T.NI */ ) {\n                let end = i + 1;\n                for(;;){\n                    if (end == to) {\n                        if (iI == isolates.length) break;\n                        end = isolates[iI++].to;\n                        to = iI < isolates.length ? isolates[iI].from : rTo;\n                    } else if (types[end] == 256 /* T.NI */ ) {\n                        end++;\n                    } else {\n                        break;\n                    }\n                }\n                let beforeL = prev == 1 /* T.L */ ;\n                let afterL = (end < rTo ? types[end] : outerType) == 1 /* T.L */ ;\n                let replace = beforeL == afterL ? beforeL ? 1 /* T.L */  : 2 /* T.R */  : outerType;\n                for(let j = end, jI = iI, fromJ = jI ? isolates[jI - 1].to : rFrom; j > i;){\n                    if (j == fromJ) {\n                        j = isolates[--jI].from;\n                        fromJ = jI ? isolates[jI - 1].to : rFrom;\n                    }\n                    types[--j] = replace;\n                }\n                i = end;\n            } else {\n                prev = type;\n                i++;\n            }\n        }\n    }\n}\n// Find the contiguous ranges of character types in a given range, and\n// emit spans for them. Flip the order of the spans as appropriate\n// based on the level, and call through to compute the spans for\n// isolates at the proper point.\nfunction emitSpans(line, from, to, level, baseLevel, isolates, order) {\n    let ourType = level % 2 ? 2 /* T.R */  : 1 /* T.L */ ;\n    if (level % 2 == baseLevel % 2) {\n        for(let iCh = from, iI = 0; iCh < to;){\n            // Scan a section of characters in direction ourType, unless\n            // there's another type of char right after iCh, in which case\n            // we scan a section of other characters (which, if ourType ==\n            // T.L, may contain both T.R and T.AN chars).\n            let sameDir = true, isNum = false;\n            if (iI == isolates.length || iCh < isolates[iI].from) {\n                let next = types[iCh];\n                if (next != ourType) {\n                    sameDir = false;\n                    isNum = next == 16 /* T.AN */ ;\n                }\n            }\n            // Holds an array of isolates to pass to a recursive call if we\n            // must recurse (to distinguish T.AN inside an RTL section in\n            // LTR text), null if we can emit directly\n            let recurse = !sameDir && ourType == 1 /* T.L */  ? [] : null;\n            let localLevel = sameDir ? level : level + 1;\n            let iScan = iCh;\n            run: for(;;){\n                if (iI < isolates.length && iScan == isolates[iI].from) {\n                    if (isNum) break run;\n                    let iso = isolates[iI];\n                    // Scan ahead to verify that there is another char in this dir after the isolate(s)\n                    if (!sameDir) for(let upto = iso.to, jI = iI + 1;;){\n                        if (upto == to) break run;\n                        if (jI < isolates.length && isolates[jI].from == upto) upto = isolates[jI++].to;\n                        else if (types[upto] == ourType) break run;\n                        else break;\n                    }\n                    iI++;\n                    if (recurse) {\n                        recurse.push(iso);\n                    } else {\n                        if (iso.from > iCh) order.push(new BidiSpan(iCh, iso.from, localLevel));\n                        let dirSwap = iso.direction == LTR != !(localLevel % 2);\n                        computeSectionOrder(line, dirSwap ? level + 1 : level, baseLevel, iso.inner, iso.from, iso.to, order);\n                        iCh = iso.to;\n                    }\n                    iScan = iso.to;\n                } else if (iScan == to || (sameDir ? types[iScan] != ourType : types[iScan] == ourType)) {\n                    break;\n                } else {\n                    iScan++;\n                }\n            }\n            if (recurse) emitSpans(line, iCh, iScan, level + 1, baseLevel, recurse, order);\n            else if (iCh < iScan) order.push(new BidiSpan(iCh, iScan, localLevel));\n            iCh = iScan;\n        }\n    } else {\n        // Iterate in reverse to flip the span order. Same code again, but\n        // going from the back of the section to the front\n        for(let iCh = to, iI = isolates.length; iCh > from;){\n            let sameDir = true, isNum = false;\n            if (!iI || iCh > isolates[iI - 1].to) {\n                let next = types[iCh - 1];\n                if (next != ourType) {\n                    sameDir = false;\n                    isNum = next == 16 /* T.AN */ ;\n                }\n            }\n            let recurse = !sameDir && ourType == 1 /* T.L */  ? [] : null;\n            let localLevel = sameDir ? level : level + 1;\n            let iScan = iCh;\n            run: for(;;){\n                if (iI && iScan == isolates[iI - 1].to) {\n                    if (isNum) break run;\n                    let iso = isolates[--iI];\n                    // Scan ahead to verify that there is another char in this dir after the isolate(s)\n                    if (!sameDir) for(let upto = iso.from, jI = iI;;){\n                        if (upto == from) break run;\n                        if (jI && isolates[jI - 1].to == upto) upto = isolates[--jI].from;\n                        else if (types[upto - 1] == ourType) break run;\n                        else break;\n                    }\n                    if (recurse) {\n                        recurse.push(iso);\n                    } else {\n                        if (iso.to < iCh) order.push(new BidiSpan(iso.to, iCh, localLevel));\n                        let dirSwap = iso.direction == LTR != !(localLevel % 2);\n                        computeSectionOrder(line, dirSwap ? level + 1 : level, baseLevel, iso.inner, iso.from, iso.to, order);\n                        iCh = iso.from;\n                    }\n                    iScan = iso.from;\n                } else if (iScan == from || (sameDir ? types[iScan - 1] != ourType : types[iScan - 1] == ourType)) {\n                    break;\n                } else {\n                    iScan--;\n                }\n            }\n            if (recurse) emitSpans(line, iScan, iCh, level + 1, baseLevel, recurse, order);\n            else if (iScan < iCh) order.push(new BidiSpan(iScan, iCh, localLevel));\n            iCh = iScan;\n        }\n    }\n}\nfunction computeSectionOrder(line, level, baseLevel, isolates, from, to, order) {\n    let outerType = level % 2 ? 2 /* T.R */  : 1 /* T.L */ ;\n    computeCharTypes(line, from, to, isolates, outerType);\n    processBracketPairs(line, from, to, isolates, outerType);\n    processNeutrals(from, to, isolates, outerType);\n    emitSpans(line, from, to, level, baseLevel, isolates, order);\n}\nfunction computeOrder(line, direction, isolates) {\n    if (!line) return [\n        new BidiSpan(0, 0, direction == RTL ? 1 : 0)\n    ];\n    if (direction == LTR && !isolates.length && !BidiRE.test(line)) return trivialOrder(line.length);\n    if (isolates.length) while(line.length > types.length)types[types.length] = 256 /* T.NI */ ; // Make sure types array has no gaps\n    let order = [], level = direction == LTR ? 0 : 1;\n    computeSectionOrder(line, level, level, isolates, 0, line.length, order);\n    return order;\n}\nfunction trivialOrder(length) {\n    return [\n        new BidiSpan(0, length, 0)\n    ];\n}\nlet movedOver = \"\";\nfunction moveVisually(line, order, dir, start, forward) {\n    var _a;\n    let startIndex = start.head - line.from, spanI = -1;\n    if (startIndex == 0) {\n        if (!forward || !line.length) return null;\n        if (order[0].level != dir) {\n            startIndex = order[0].side(false, dir);\n            spanI = 0;\n        }\n    } else if (startIndex == line.length) {\n        if (forward) return null;\n        let last = order[order.length - 1];\n        if (last.level != dir) {\n            startIndex = last.side(true, dir);\n            spanI = order.length - 1;\n        }\n    }\n    if (spanI < 0) spanI = BidiSpan.find(order, startIndex, (_a = start.bidiLevel) !== null && _a !== void 0 ? _a : -1, start.assoc);\n    let span = order[spanI];\n    // End of span. (But not end of line--that was checked for above.)\n    if (startIndex == span.side(forward, dir)) {\n        span = order[spanI += forward ? 1 : -1];\n        startIndex = span.side(!forward, dir);\n    }\n    let indexForward = forward == (span.dir == dir);\n    let nextIndex = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.findClusterBreak)(line.text, startIndex, indexForward);\n    movedOver = line.text.slice(Math.min(startIndex, nextIndex), Math.max(startIndex, nextIndex));\n    if (nextIndex > span.from && nextIndex < span.to) return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(nextIndex + line.from, indexForward ? -1 : 1, span.level);\n    let nextSpan = spanI == (forward ? order.length - 1 : 0) ? null : order[spanI + (forward ? 1 : -1)];\n    if (!nextSpan && span.level != dir) return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(forward ? line.to : line.from, forward ? -1 : 1, dir);\n    if (nextSpan && nextSpan.level < span.level) return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(nextSpan.side(!forward, dir) + line.from, forward ? 1 : -1, nextSpan.level);\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(nextIndex + line.from, forward ? -1 : 1, span.level);\n}\nclass DocView extends ContentView {\n    get length() {\n        return this.view.state.doc.length;\n    }\n    constructor(view){\n        super();\n        this.view = view;\n        this.decorations = [];\n        this.dynamicDecorationMap = [];\n        this.domChanged = null;\n        this.hasComposition = null;\n        this.markedForComposition = new Set;\n        // Track a minimum width for the editor. When measuring sizes in\n        // measureVisibleLineHeights, this is updated to point at the width\n        // of a given element and its extent in the document. When a change\n        // happens in that range, these are reset. That way, once we've seen\n        // a line/element of a given length, we keep the editor wide enough\n        // to fit at least that element, until it is changed, at which point\n        // we forget it again.\n        this.minWidth = 0;\n        this.minWidthFrom = 0;\n        this.minWidthTo = 0;\n        // Track whether the DOM selection was set in a lossy way, so that\n        // we don't mess it up when reading it back it\n        this.impreciseAnchor = null;\n        this.impreciseHead = null;\n        this.forceSelection = false;\n        // Used by the resize observer to ignore resizes that we caused\n        // ourselves\n        this.lastUpdate = Date.now();\n        this.setDOM(view.contentDOM);\n        this.children = [\n            new LineView\n        ];\n        this.children[0].setParent(this);\n        this.updateDeco();\n        this.updateInner([\n            new ChangedRange(0, 0, 0, view.state.doc.length)\n        ], 0, null);\n    }\n    // Update the document view to a given state.\n    update(update) {\n        var _a;\n        let changedRanges = update.changedRanges;\n        if (this.minWidth > 0 && changedRanges.length) {\n            if (!changedRanges.every(({ fromA, toA })=>toA < this.minWidthFrom || fromA > this.minWidthTo)) {\n                this.minWidth = this.minWidthFrom = this.minWidthTo = 0;\n            } else {\n                this.minWidthFrom = update.changes.mapPos(this.minWidthFrom, 1);\n                this.minWidthTo = update.changes.mapPos(this.minWidthTo, 1);\n            }\n        }\n        let readCompositionAt = -1;\n        if (this.view.inputState.composing >= 0) {\n            if ((_a = this.domChanged) === null || _a === void 0 ? void 0 : _a.newSel) readCompositionAt = this.domChanged.newSel.head;\n            else if (!touchesComposition(update.changes, this.hasComposition) && !update.selectionSet) readCompositionAt = update.state.selection.main.head;\n        }\n        let composition = readCompositionAt > -1 ? findCompositionRange(this.view, update.changes, readCompositionAt) : null;\n        this.domChanged = null;\n        if (this.hasComposition) {\n            this.markedForComposition.clear();\n            let { from, to } = this.hasComposition;\n            changedRanges = new ChangedRange(from, to, update.changes.mapPos(from, -1), update.changes.mapPos(to, 1)).addToSet(changedRanges.slice());\n        }\n        this.hasComposition = composition ? {\n            from: composition.range.fromB,\n            to: composition.range.toB\n        } : null;\n        // When the DOM nodes around the selection are moved to another\n        // parent, Chrome sometimes reports a different selection through\n        // getSelection than the one that it actually shows to the user.\n        // This forces a selection update when lines are joined to work\n        // around that. Issue #54\n        if ((browser.ie || browser.chrome) && !composition && update && update.state.doc.lines != update.startState.doc.lines) this.forceSelection = true;\n        let prevDeco = this.decorations, deco = this.updateDeco();\n        let decoDiff = findChangedDeco(prevDeco, deco, update.changes);\n        changedRanges = ChangedRange.extendWithRanges(changedRanges, decoDiff);\n        if (!(this.flags & 7 /* ViewFlag.Dirty */ ) && changedRanges.length == 0) {\n            return false;\n        } else {\n            this.updateInner(changedRanges, update.startState.doc.length, composition);\n            if (update.transactions.length) this.lastUpdate = Date.now();\n            return true;\n        }\n    }\n    // Used by update and the constructor do perform the actual DOM\n    // update\n    updateInner(changes, oldLength, composition) {\n        this.view.viewState.mustMeasureContent = true;\n        this.updateChildren(changes, oldLength, composition);\n        let { observer } = this.view;\n        observer.ignore(()=>{\n            // Lock the height during redrawing, since Chrome sometimes\n            // messes with the scroll position during DOM mutation (though\n            // no relayout is triggered and I cannot imagine how it can\n            // recompute the scroll position without a layout)\n            this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + \"px\";\n            this.dom.style.flexBasis = this.minWidth ? this.minWidth + \"px\" : \"\";\n            // Chrome will sometimes, when DOM mutations occur directly\n            // around the selection, get confused and report a different\n            // selection from the one it displays (issue #218). This tries\n            // to detect that situation.\n            let track = browser.chrome || browser.ios ? {\n                node: observer.selectionRange.focusNode,\n                written: false\n            } : undefined;\n            this.sync(this.view, track);\n            this.flags &= ~7 /* ViewFlag.Dirty */ ;\n            if (track && (track.written || observer.selectionRange.focusNode != track.node)) this.forceSelection = true;\n            this.dom.style.height = \"\";\n        });\n        this.markedForComposition.forEach((cView)=>cView.flags &= ~8 /* ViewFlag.Composition */ );\n        let gaps = [];\n        if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length) {\n            for (let child of this.children)if (child instanceof BlockWidgetView && child.widget instanceof BlockGapWidget) gaps.push(child.dom);\n        }\n        observer.updateGaps(gaps);\n    }\n    updateChildren(changes, oldLength, composition) {\n        let ranges = composition ? composition.range.addToSet(changes.slice()) : changes;\n        let cursor = this.childCursor(oldLength);\n        for(let i = ranges.length - 1;; i--){\n            let next = i >= 0 ? ranges[i] : null;\n            if (!next) break;\n            let { fromA, toA, fromB, toB } = next, content, breakAtStart, openStart, openEnd;\n            if (composition && composition.range.fromB < toB && composition.range.toB > fromB) {\n                let before = ContentBuilder.build(this.view.state.doc, fromB, composition.range.fromB, this.decorations, this.dynamicDecorationMap);\n                let after = ContentBuilder.build(this.view.state.doc, composition.range.toB, toB, this.decorations, this.dynamicDecorationMap);\n                breakAtStart = before.breakAtStart;\n                openStart = before.openStart;\n                openEnd = after.openEnd;\n                let compLine = this.compositionView(composition);\n                if (after.breakAtStart) {\n                    compLine.breakAfter = 1;\n                } else if (after.content.length && compLine.merge(compLine.length, compLine.length, after.content[0], false, after.openStart, 0)) {\n                    compLine.breakAfter = after.content[0].breakAfter;\n                    after.content.shift();\n                }\n                if (before.content.length && compLine.merge(0, 0, before.content[before.content.length - 1], true, 0, before.openEnd)) {\n                    before.content.pop();\n                }\n                content = before.content.concat(compLine).concat(after.content);\n            } else {\n                ({ content, breakAtStart, openStart, openEnd } = ContentBuilder.build(this.view.state.doc, fromB, toB, this.decorations, this.dynamicDecorationMap));\n            }\n            let { i: toI, off: toOff } = cursor.findPos(toA, 1);\n            let { i: fromI, off: fromOff } = cursor.findPos(fromA, -1);\n            replaceRange(this, fromI, fromOff, toI, toOff, content, breakAtStart, openStart, openEnd);\n        }\n        if (composition) this.fixCompositionDOM(composition);\n    }\n    compositionView(composition) {\n        let cur = new TextView(composition.text.nodeValue);\n        cur.flags |= 8 /* ViewFlag.Composition */ ;\n        for (let { deco } of composition.marks)cur = new MarkView(deco, [\n            cur\n        ], cur.length);\n        let line = new LineView;\n        line.append(cur, 0);\n        return line;\n    }\n    fixCompositionDOM(composition) {\n        let fix = (dom, cView)=>{\n            cView.flags |= 8 /* ViewFlag.Composition */  | (cView.children.some((c)=>c.flags & 7 /* ViewFlag.Dirty */ ) ? 1 /* ViewFlag.ChildDirty */  : 0);\n            this.markedForComposition.add(cView);\n            let prev = ContentView.get(dom);\n            if (prev && prev != cView) prev.dom = null;\n            cView.setDOM(dom);\n        };\n        let pos = this.childPos(composition.range.fromB, 1);\n        let cView = this.children[pos.i];\n        fix(composition.line, cView);\n        for(let i = composition.marks.length - 1; i >= -1; i--){\n            pos = cView.childPos(pos.off, 1);\n            cView = cView.children[pos.i];\n            fix(i >= 0 ? composition.marks[i].node : composition.text, cView);\n        }\n    }\n    // Sync the DOM selection to this.state.selection\n    updateSelection(mustRead = false, fromPointer = false) {\n        if (mustRead || !this.view.observer.selectionRange.focusNode) this.view.observer.readSelectionRange();\n        let activeElt = this.view.root.activeElement, focused = activeElt == this.dom;\n        let selectionNotFocus = !focused && hasSelection(this.dom, this.view.observer.selectionRange) && !(activeElt && this.dom.contains(activeElt));\n        if (!(focused || fromPointer || selectionNotFocus)) return;\n        let force = this.forceSelection;\n        this.forceSelection = false;\n        let main = this.view.state.selection.main;\n        let anchor = this.moveToLine(this.domAtPos(main.anchor));\n        let head = main.empty ? anchor : this.moveToLine(this.domAtPos(main.head));\n        // Always reset on Firefox when next to an uneditable node to\n        // avoid invisible cursor bugs (#111)\n        if (browser.gecko && main.empty && !this.hasComposition && betweenUneditable(anchor)) {\n            let dummy = document.createTextNode(\"\");\n            this.view.observer.ignore(()=>anchor.node.insertBefore(dummy, anchor.node.childNodes[anchor.offset] || null));\n            anchor = head = new DOMPos(dummy, 0);\n            force = true;\n        }\n        let domSel = this.view.observer.selectionRange;\n        // If the selection is already here, or in an equivalent position, don't touch it\n        if (force || !domSel.focusNode || !isEquivalentPosition(anchor.node, anchor.offset, domSel.anchorNode, domSel.anchorOffset) || !isEquivalentPosition(head.node, head.offset, domSel.focusNode, domSel.focusOffset)) {\n            this.view.observer.ignore(()=>{\n                // Chrome Android will hide the virtual keyboard when tapping\n                // inside an uneditable node, and not bring it back when we\n                // move the cursor to its proper position. This tries to\n                // restore the keyboard by cycling focus.\n                if (browser.android && browser.chrome && this.dom.contains(domSel.focusNode) && inUneditable(domSel.focusNode, this.dom)) {\n                    this.dom.blur();\n                    this.dom.focus({\n                        preventScroll: true\n                    });\n                }\n                let rawSel = getSelection(this.view.root);\n                if (!rawSel) ;\n                else if (main.empty) {\n                    // Work around https://bugzilla.mozilla.org/show_bug.cgi?id=1612076\n                    if (browser.gecko) {\n                        let nextTo = nextToUneditable(anchor.node, anchor.offset);\n                        if (nextTo && nextTo != (1 /* NextTo.Before */  | 2 /* NextTo.After */ )) {\n                            let text = nearbyTextNode(anchor.node, anchor.offset, nextTo == 1 /* NextTo.Before */  ? 1 : -1);\n                            if (text) anchor = new DOMPos(text.node, text.offset);\n                        }\n                    }\n                    rawSel.collapse(anchor.node, anchor.offset);\n                    if (main.bidiLevel != null && rawSel.caretBidiLevel !== undefined) rawSel.caretBidiLevel = main.bidiLevel;\n                } else if (rawSel.extend) {\n                    // Selection.extend can be used to create an 'inverted' selection\n                    // (one where the focus is before the anchor), but not all\n                    // browsers support it yet.\n                    rawSel.collapse(anchor.node, anchor.offset);\n                    // Safari will ignore the call above when the editor is\n                    // hidden, and then raise an error on the call to extend\n                    // (#940).\n                    try {\n                        rawSel.extend(head.node, head.offset);\n                    } catch (_) {}\n                } else {\n                    // Primitive (IE) way\n                    let range = document.createRange();\n                    if (main.anchor > main.head) [anchor, head] = [\n                        head,\n                        anchor\n                    ];\n                    range.setEnd(head.node, head.offset);\n                    range.setStart(anchor.node, anchor.offset);\n                    rawSel.removeAllRanges();\n                    rawSel.addRange(range);\n                }\n                if (selectionNotFocus && this.view.root.activeElement == this.dom) {\n                    this.dom.blur();\n                    if (activeElt) activeElt.focus();\n                }\n            });\n            this.view.observer.setSelectionRange(anchor, head);\n        }\n        this.impreciseAnchor = anchor.precise ? null : new DOMPos(domSel.anchorNode, domSel.anchorOffset);\n        this.impreciseHead = head.precise ? null : new DOMPos(domSel.focusNode, domSel.focusOffset);\n    }\n    enforceCursorAssoc() {\n        if (this.hasComposition) return;\n        let { view } = this, cursor = view.state.selection.main;\n        let sel = getSelection(view.root);\n        let { anchorNode, anchorOffset } = view.observer.selectionRange;\n        if (!sel || !cursor.empty || !cursor.assoc || !sel.modify) return;\n        let line = LineView.find(this, cursor.head);\n        if (!line) return;\n        let lineStart = line.posAtStart;\n        if (cursor.head == lineStart || cursor.head == lineStart + line.length) return;\n        let before = this.coordsAt(cursor.head, -1), after = this.coordsAt(cursor.head, 1);\n        if (!before || !after || before.bottom > after.top) return;\n        let dom = this.domAtPos(cursor.head + cursor.assoc);\n        sel.collapse(dom.node, dom.offset);\n        sel.modify(\"move\", cursor.assoc < 0 ? \"forward\" : \"backward\", \"lineboundary\");\n        // This can go wrong in corner cases like single-character lines,\n        // so check and reset if necessary.\n        view.observer.readSelectionRange();\n        let newRange = view.observer.selectionRange;\n        if (view.docView.posFromDOM(newRange.anchorNode, newRange.anchorOffset) != cursor.from) sel.collapse(anchorNode, anchorOffset);\n    }\n    // If a position is in/near a block widget, move it to a nearby text\n    // line, since we don't want the cursor inside a block widget.\n    moveToLine(pos) {\n        // Block widgets will return positions before/after them, which\n        // are thus directly in the document DOM element.\n        let dom = this.dom, newPos;\n        if (pos.node != dom) return pos;\n        for(let i = pos.offset; !newPos && i < dom.childNodes.length; i++){\n            let view = ContentView.get(dom.childNodes[i]);\n            if (view instanceof LineView) newPos = view.domAtPos(0);\n        }\n        for(let i = pos.offset - 1; !newPos && i >= 0; i--){\n            let view = ContentView.get(dom.childNodes[i]);\n            if (view instanceof LineView) newPos = view.domAtPos(view.length);\n        }\n        return newPos ? new DOMPos(newPos.node, newPos.offset, true) : pos;\n    }\n    nearest(dom) {\n        for(let cur = dom; cur;){\n            let domView = ContentView.get(cur);\n            if (domView && domView.rootView == this) return domView;\n            cur = cur.parentNode;\n        }\n        return null;\n    }\n    posFromDOM(node, offset) {\n        let view = this.nearest(node);\n        if (!view) throw new RangeError(\"Trying to find position for a DOM position outside of the document\");\n        return view.localPosFromDOM(node, offset) + view.posAtStart;\n    }\n    domAtPos(pos) {\n        let { i, off } = this.childCursor().findPos(pos, -1);\n        for(; i < this.children.length - 1;){\n            let child = this.children[i];\n            if (off < child.length || child instanceof LineView) break;\n            i++;\n            off = 0;\n        }\n        return this.children[i].domAtPos(off);\n    }\n    coordsAt(pos, side) {\n        let best = null, bestPos = 0;\n        for(let off = this.length, i = this.children.length - 1; i >= 0; i--){\n            let child = this.children[i], end = off - child.breakAfter, start = end - child.length;\n            if (end < pos) break;\n            if (start <= pos && (start < pos || child.covers(-1)) && (end > pos || child.covers(1)) && (!best || child instanceof LineView && !(best instanceof LineView && side >= 0))) {\n                best = child;\n                bestPos = start;\n            }\n            off = start;\n        }\n        return best ? best.coordsAt(pos - bestPos, side) : null;\n    }\n    coordsForChar(pos) {\n        let { i, off } = this.childPos(pos, 1), child = this.children[i];\n        if (!(child instanceof LineView)) return null;\n        while(child.children.length){\n            let { i, off: childOff } = child.childPos(off, 1);\n            for(;; i++){\n                if (i == child.children.length) return null;\n                if ((child = child.children[i]).length) break;\n            }\n            off = childOff;\n        }\n        if (!(child instanceof TextView)) return null;\n        let end = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.findClusterBreak)(child.text, off);\n        if (end == off) return null;\n        let rects = textRange(child.dom, off, end).getClientRects();\n        for(let i = 0; i < rects.length; i++){\n            let rect = rects[i];\n            if (i == rects.length - 1 || rect.top < rect.bottom && rect.left < rect.right) return rect;\n        }\n        return null;\n    }\n    measureVisibleLineHeights(viewport) {\n        let result = [], { from, to } = viewport;\n        let contentWidth = this.view.contentDOM.clientWidth;\n        let isWider = contentWidth > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1;\n        let widest = -1, ltr = this.view.textDirection == Direction.LTR;\n        for(let pos = 0, i = 0; i < this.children.length; i++){\n            let child = this.children[i], end = pos + child.length;\n            if (end > to) break;\n            if (pos >= from) {\n                let childRect = child.dom.getBoundingClientRect();\n                result.push(childRect.height);\n                if (isWider) {\n                    let last = child.dom.lastChild;\n                    let rects = last ? clientRectsFor(last) : [];\n                    if (rects.length) {\n                        let rect = rects[rects.length - 1];\n                        let width = ltr ? rect.right - childRect.left : childRect.right - rect.left;\n                        if (width > widest) {\n                            widest = width;\n                            this.minWidth = contentWidth;\n                            this.minWidthFrom = pos;\n                            this.minWidthTo = end;\n                        }\n                    }\n                }\n            }\n            pos = end + child.breakAfter;\n        }\n        return result;\n    }\n    textDirectionAt(pos) {\n        let { i } = this.childPos(pos, 1);\n        return getComputedStyle(this.children[i].dom).direction == \"rtl\" ? Direction.RTL : Direction.LTR;\n    }\n    measureTextSize() {\n        for (let child of this.children){\n            if (child instanceof LineView) {\n                let measure = child.measureTextSize();\n                if (measure) return measure;\n            }\n        }\n        // If no workable line exists, force a layout of a measurable element\n        let dummy = document.createElement(\"div\"), lineHeight, charWidth, textHeight;\n        dummy.className = \"cm-line\";\n        dummy.style.width = \"99999px\";\n        dummy.style.position = \"absolute\";\n        dummy.textContent = \"abc def ghi jkl mno pqr stu\";\n        this.view.observer.ignore(()=>{\n            this.dom.appendChild(dummy);\n            let rect = clientRectsFor(dummy.firstChild)[0];\n            lineHeight = dummy.getBoundingClientRect().height;\n            charWidth = rect ? rect.width / 27 : 7;\n            textHeight = rect ? rect.height : lineHeight;\n            dummy.remove();\n        });\n        return {\n            lineHeight,\n            charWidth,\n            textHeight\n        };\n    }\n    childCursor(pos = this.length) {\n        // Move back to start of last element when possible, so that\n        // `ChildCursor.findPos` doesn't have to deal with the edge case\n        // of being after the last element.\n        let i = this.children.length;\n        if (i) pos -= this.children[--i].length;\n        return new ChildCursor(this.children, pos, i);\n    }\n    computeBlockGapDeco() {\n        let deco = [], vs = this.view.viewState;\n        for(let pos = 0, i = 0;; i++){\n            let next = i == vs.viewports.length ? null : vs.viewports[i];\n            let end = next ? next.from - 1 : this.length;\n            if (end > pos) {\n                let height = (vs.lineBlockAt(end).bottom - vs.lineBlockAt(pos).top) / this.view.scaleY;\n                deco.push(Decoration.replace({\n                    widget: new BlockGapWidget(height),\n                    block: true,\n                    inclusive: true,\n                    isBlockGap: true\n                }).range(pos, end));\n            }\n            if (!next) break;\n            pos = next.to + 1;\n        }\n        return Decoration.set(deco);\n    }\n    updateDeco() {\n        let allDeco = this.view.state.facet(decorations).map((d, i)=>{\n            let dynamic = this.dynamicDecorationMap[i] = typeof d == \"function\";\n            return dynamic ? d(this.view) : d;\n        });\n        for(let i = allDeco.length; i < allDeco.length + 3; i++)this.dynamicDecorationMap[i] = false;\n        return this.decorations = [\n            ...allDeco,\n            this.computeBlockGapDeco(),\n            this.view.viewState.lineGapDeco\n        ];\n    }\n    scrollIntoView(target) {\n        if (target.isSnapshot) {\n            let ref = this.view.viewState.lineBlockAt(target.range.head);\n            this.view.scrollDOM.scrollTop = ref.top - target.yMargin;\n            this.view.scrollDOM.scrollLeft = target.xMargin;\n            return;\n        }\n        let { range } = target;\n        let rect = this.coordsAt(range.head, range.empty ? range.assoc : range.head > range.anchor ? -1 : 1), other;\n        if (!rect) return;\n        if (!range.empty && (other = this.coordsAt(range.anchor, range.anchor > range.head ? -1 : 1))) rect = {\n            left: Math.min(rect.left, other.left),\n            top: Math.min(rect.top, other.top),\n            right: Math.max(rect.right, other.right),\n            bottom: Math.max(rect.bottom, other.bottom)\n        };\n        let margins = getScrollMargins(this.view);\n        let targetRect = {\n            left: rect.left - margins.left,\n            top: rect.top - margins.top,\n            right: rect.right + margins.right,\n            bottom: rect.bottom + margins.bottom\n        };\n        let { offsetWidth, offsetHeight } = this.view.scrollDOM;\n        scrollRectIntoView(this.view.scrollDOM, targetRect, range.head < range.anchor ? -1 : 1, target.x, target.y, Math.max(Math.min(target.xMargin, offsetWidth), -offsetWidth), Math.max(Math.min(target.yMargin, offsetHeight), -offsetHeight), this.view.textDirection == Direction.LTR);\n    }\n}\nfunction betweenUneditable(pos) {\n    return pos.node.nodeType == 1 && pos.node.firstChild && (pos.offset == 0 || pos.node.childNodes[pos.offset - 1].contentEditable == \"false\") && (pos.offset == pos.node.childNodes.length || pos.node.childNodes[pos.offset].contentEditable == \"false\");\n}\nclass BlockGapWidget extends WidgetType {\n    constructor(height){\n        super();\n        this.height = height;\n    }\n    toDOM() {\n        let elt = document.createElement(\"div\");\n        this.updateDOM(elt);\n        return elt;\n    }\n    eq(other) {\n        return other.height == this.height;\n    }\n    updateDOM(elt) {\n        elt.style.height = this.height + \"px\";\n        return true;\n    }\n    get estimatedHeight() {\n        return this.height;\n    }\n}\nfunction findCompositionNode(view, headPos) {\n    let sel = view.observer.selectionRange;\n    let textNode = sel.focusNode && nearbyTextNode(sel.focusNode, sel.focusOffset, 0);\n    if (!textNode) return null;\n    let from = headPos - textNode.offset;\n    return {\n        from,\n        to: from + textNode.node.nodeValue.length,\n        node: textNode.node\n    };\n}\nfunction findCompositionRange(view, changes, headPos) {\n    let found = findCompositionNode(view, headPos);\n    if (!found) return null;\n    let { node: textNode, from, to } = found, text = textNode.nodeValue;\n    // Don't try to preserve multi-line compositions\n    if (/[\\n\\r]/.test(text)) return null;\n    if (view.state.doc.sliceString(found.from, found.to) != text) return null;\n    let inv = changes.invertedDesc;\n    let range = new ChangedRange(inv.mapPos(from), inv.mapPos(to), from, to);\n    let marks = [];\n    for(let parent = textNode.parentNode;; parent = parent.parentNode){\n        let parentView = ContentView.get(parent);\n        if (parentView instanceof MarkView) marks.push({\n            node: parent,\n            deco: parentView.mark\n        });\n        else if (parentView instanceof LineView || parent.nodeName == \"DIV\" && parent.parentNode == view.contentDOM) return {\n            range,\n            text: textNode,\n            marks,\n            line: parent\n        };\n        else if (parent != view.contentDOM) marks.push({\n            node: parent,\n            deco: new MarkDecoration({\n                inclusive: true,\n                attributes: getAttrs(parent),\n                tagName: parent.tagName.toLowerCase()\n            })\n        });\n        else return null;\n    }\n}\nfunction nearbyTextNode(startNode, startOffset, side) {\n    if (side <= 0) for(let node = startNode, offset = startOffset;;){\n        if (node.nodeType == 3) return {\n            node: node,\n            offset: offset\n        };\n        if (node.nodeType == 1 && offset > 0) {\n            node = node.childNodes[offset - 1];\n            offset = maxOffset(node);\n        } else {\n            break;\n        }\n    }\n    if (side >= 0) for(let node = startNode, offset = startOffset;;){\n        if (node.nodeType == 3) return {\n            node: node,\n            offset: offset\n        };\n        if (node.nodeType == 1 && offset < node.childNodes.length && side >= 0) {\n            node = node.childNodes[offset];\n            offset = 0;\n        } else {\n            break;\n        }\n    }\n    return null;\n}\nfunction nextToUneditable(node, offset) {\n    if (node.nodeType != 1) return 0;\n    return (offset && node.childNodes[offset - 1].contentEditable == \"false\" ? 1 /* NextTo.Before */  : 0) | (offset < node.childNodes.length && node.childNodes[offset].contentEditable == \"false\" ? 2 /* NextTo.After */  : 0);\n}\nlet DecorationComparator$1 = class DecorationComparator {\n    constructor(){\n        this.changes = [];\n    }\n    compareRange(from, to) {\n        addRange(from, to, this.changes);\n    }\n    comparePoint(from, to) {\n        addRange(from, to, this.changes);\n    }\n};\nfunction findChangedDeco(a, b, diff) {\n    let comp = new DecorationComparator$1;\n    _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.compare(a, b, diff, comp);\n    return comp.changes;\n}\nfunction inUneditable(node, inside) {\n    for(let cur = node; cur && cur != inside; cur = cur.assignedSlot || cur.parentNode){\n        if (cur.nodeType == 1 && cur.contentEditable == \"false\") {\n            return true;\n        }\n    }\n    return false;\n}\nfunction touchesComposition(changes, composition) {\n    let touched = false;\n    if (composition) changes.iterChangedRanges((from, to)=>{\n        if (from < composition.to && to > composition.from) touched = true;\n    });\n    return touched;\n}\nfunction groupAt(state, pos, bias = 1) {\n    let categorize = state.charCategorizer(pos);\n    let line = state.doc.lineAt(pos), linePos = pos - line.from;\n    if (line.length == 0) return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(pos);\n    if (linePos == 0) bias = 1;\n    else if (linePos == line.length) bias = -1;\n    let from = linePos, to = linePos;\n    if (bias < 0) from = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.findClusterBreak)(line.text, linePos, false);\n    else to = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.findClusterBreak)(line.text, linePos);\n    let cat = categorize(line.text.slice(from, to));\n    while(from > 0){\n        let prev = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.findClusterBreak)(line.text, from, false);\n        if (categorize(line.text.slice(prev, from)) != cat) break;\n        from = prev;\n    }\n    while(to < line.length){\n        let next = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.findClusterBreak)(line.text, to);\n        if (categorize(line.text.slice(to, next)) != cat) break;\n        to = next;\n    }\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.range(from + line.from, to + line.from);\n}\n// Search the DOM for the {node, offset} position closest to the given\n// coordinates. Very inefficient and crude, but can usually be avoided\n// by calling caret(Position|Range)FromPoint instead.\nfunction getdx(x, rect) {\n    return rect.left > x ? rect.left - x : Math.max(0, x - rect.right);\n}\nfunction getdy(y, rect) {\n    return rect.top > y ? rect.top - y : Math.max(0, y - rect.bottom);\n}\nfunction yOverlap(a, b) {\n    return a.top < b.bottom - 1 && a.bottom > b.top + 1;\n}\nfunction upTop(rect, top) {\n    return top < rect.top ? {\n        top,\n        left: rect.left,\n        right: rect.right,\n        bottom: rect.bottom\n    } : rect;\n}\nfunction upBot(rect, bottom) {\n    return bottom > rect.bottom ? {\n        top: rect.top,\n        left: rect.left,\n        right: rect.right,\n        bottom\n    } : rect;\n}\nfunction domPosAtCoords(parent, x, y) {\n    let closest, closestRect, closestX, closestY, closestOverlap = false;\n    let above, below, aboveRect, belowRect;\n    for(let child = parent.firstChild; child; child = child.nextSibling){\n        let rects = clientRectsFor(child);\n        for(let i = 0; i < rects.length; i++){\n            let rect = rects[i];\n            if (closestRect && yOverlap(closestRect, rect)) rect = upTop(upBot(rect, closestRect.bottom), closestRect.top);\n            let dx = getdx(x, rect), dy = getdy(y, rect);\n            if (dx == 0 && dy == 0) return child.nodeType == 3 ? domPosInText(child, x, y) : domPosAtCoords(child, x, y);\n            if (!closest || closestY > dy || closestY == dy && closestX > dx) {\n                closest = child;\n                closestRect = rect;\n                closestX = dx;\n                closestY = dy;\n                let side = dy ? y < rect.top ? -1 : 1 : dx ? x < rect.left ? -1 : 1 : 0;\n                closestOverlap = !side || (side > 0 ? i < rects.length - 1 : i > 0);\n            }\n            if (dx == 0) {\n                if (y > rect.bottom && (!aboveRect || aboveRect.bottom < rect.bottom)) {\n                    above = child;\n                    aboveRect = rect;\n                } else if (y < rect.top && (!belowRect || belowRect.top > rect.top)) {\n                    below = child;\n                    belowRect = rect;\n                }\n            } else if (aboveRect && yOverlap(aboveRect, rect)) {\n                aboveRect = upBot(aboveRect, rect.bottom);\n            } else if (belowRect && yOverlap(belowRect, rect)) {\n                belowRect = upTop(belowRect, rect.top);\n            }\n        }\n    }\n    if (aboveRect && aboveRect.bottom >= y) {\n        closest = above;\n        closestRect = aboveRect;\n    } else if (belowRect && belowRect.top <= y) {\n        closest = below;\n        closestRect = belowRect;\n    }\n    if (!closest) return {\n        node: parent,\n        offset: 0\n    };\n    let clipX = Math.max(closestRect.left, Math.min(closestRect.right, x));\n    if (closest.nodeType == 3) return domPosInText(closest, clipX, y);\n    if (closestOverlap && closest.contentEditable != \"false\") return domPosAtCoords(closest, clipX, y);\n    let offset = Array.prototype.indexOf.call(parent.childNodes, closest) + (x >= (closestRect.left + closestRect.right) / 2 ? 1 : 0);\n    return {\n        node: parent,\n        offset\n    };\n}\nfunction domPosInText(node, x, y) {\n    let len = node.nodeValue.length;\n    let closestOffset = -1, closestDY = 1e9, generalSide = 0;\n    for(let i = 0; i < len; i++){\n        let rects = textRange(node, i, i + 1).getClientRects();\n        for(let j = 0; j < rects.length; j++){\n            let rect = rects[j];\n            if (rect.top == rect.bottom) continue;\n            if (!generalSide) generalSide = x - rect.left;\n            let dy = (rect.top > y ? rect.top - y : y - rect.bottom) - 1;\n            if (rect.left - 1 <= x && rect.right + 1 >= x && dy < closestDY) {\n                let right = x >= (rect.left + rect.right) / 2, after = right;\n                if (browser.chrome || browser.gecko) {\n                    // Check for RTL on browsers that support getting client\n                    // rects for empty ranges.\n                    let rectBefore = textRange(node, i).getBoundingClientRect();\n                    if (rectBefore.left == rect.right) after = !right;\n                }\n                if (dy <= 0) return {\n                    node,\n                    offset: i + (after ? 1 : 0)\n                };\n                closestOffset = i + (after ? 1 : 0);\n                closestDY = dy;\n            }\n        }\n    }\n    return {\n        node,\n        offset: closestOffset > -1 ? closestOffset : generalSide > 0 ? node.nodeValue.length : 0\n    };\n}\nfunction posAtCoords(view, coords, precise, bias = -1) {\n    var _a, _b;\n    let content = view.contentDOM.getBoundingClientRect(), docTop = content.top + view.viewState.paddingTop;\n    let block, { docHeight } = view.viewState;\n    let { x, y } = coords, yOffset = y - docTop;\n    if (yOffset < 0) return 0;\n    if (yOffset > docHeight) return view.state.doc.length;\n    // Scan for a text block near the queried y position\n    for(let halfLine = view.viewState.heightOracle.textHeight / 2, bounced = false;;){\n        block = view.elementAtHeight(yOffset);\n        if (block.type == BlockType.Text) break;\n        for(;;){\n            // Move the y position out of this block\n            yOffset = bias > 0 ? block.bottom + halfLine : block.top - halfLine;\n            if (yOffset >= 0 && yOffset <= docHeight) break;\n            // If the document consists entirely of replaced widgets, we\n            // won't find a text block, so return 0\n            if (bounced) return precise ? null : 0;\n            bounced = true;\n            bias = -bias;\n        }\n    }\n    y = docTop + yOffset;\n    let lineStart = block.from;\n    // If this is outside of the rendered viewport, we can't determine a position\n    if (lineStart < view.viewport.from) return view.viewport.from == 0 ? 0 : precise ? null : posAtCoordsImprecise(view, content, block, x, y);\n    if (lineStart > view.viewport.to) return view.viewport.to == view.state.doc.length ? view.state.doc.length : precise ? null : posAtCoordsImprecise(view, content, block, x, y);\n    // Prefer ShadowRootOrDocument.elementFromPoint if present, fall back to document if not\n    let doc = view.dom.ownerDocument;\n    let root = view.root.elementFromPoint ? view.root : doc;\n    let element = root.elementFromPoint(x, y);\n    if (element && !view.contentDOM.contains(element)) element = null;\n    // If the element is unexpected, clip x at the sides of the content area and try again\n    if (!element) {\n        x = Math.max(content.left + 1, Math.min(content.right - 1, x));\n        element = root.elementFromPoint(x, y);\n        if (element && !view.contentDOM.contains(element)) element = null;\n    }\n    // There's visible editor content under the point, so we can try\n    // using caret(Position|Range)FromPoint as a shortcut\n    let node, offset = -1;\n    if (element && ((_a = view.docView.nearest(element)) === null || _a === void 0 ? void 0 : _a.isEditable) != false) {\n        if (doc.caretPositionFromPoint) {\n            let pos = doc.caretPositionFromPoint(x, y);\n            if (pos) ({ offsetNode: node, offset } = pos);\n        } else if (doc.caretRangeFromPoint) {\n            let range = doc.caretRangeFromPoint(x, y);\n            if (range) {\n                ({ startContainer: node, startOffset: offset } = range);\n                if (!view.contentDOM.contains(node) || browser.safari && isSuspiciousSafariCaretResult(node, offset, x) || browser.chrome && isSuspiciousChromeCaretResult(node, offset, x)) node = undefined;\n            }\n        }\n    }\n    // No luck, do our own (potentially expensive) search\n    if (!node || !view.docView.dom.contains(node)) {\n        let line = LineView.find(view.docView, lineStart);\n        if (!line) return yOffset > block.top + block.height / 2 ? block.to : block.from;\n        ({ node, offset } = domPosAtCoords(line.dom, x, y));\n    }\n    let nearest = view.docView.nearest(node);\n    if (!nearest) return null;\n    if (nearest.isWidget && ((_b = nearest.dom) === null || _b === void 0 ? void 0 : _b.nodeType) == 1) {\n        let rect = nearest.dom.getBoundingClientRect();\n        return coords.y < rect.top || coords.y <= rect.bottom && coords.x <= (rect.left + rect.right) / 2 ? nearest.posAtStart : nearest.posAtEnd;\n    } else {\n        return nearest.localPosFromDOM(node, offset) + nearest.posAtStart;\n    }\n}\nfunction posAtCoordsImprecise(view, contentRect, block, x, y) {\n    let into = Math.round((x - contentRect.left) * view.defaultCharacterWidth);\n    if (view.lineWrapping && block.height > view.defaultLineHeight * 1.5) {\n        let textHeight = view.viewState.heightOracle.textHeight;\n        let line = Math.floor((y - block.top - (view.defaultLineHeight - textHeight) * 0.5) / textHeight);\n        into += line * view.viewState.heightOracle.lineLength;\n    }\n    let content = view.state.sliceDoc(block.from, block.to);\n    return block.from + (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.findColumn)(content, into, view.state.tabSize);\n}\n// In case of a high line height, Safari's caretRangeFromPoint treats\n// the space between lines as belonging to the last character of the\n// line before. This is used to detect such a result so that it can be\n// ignored (issue #401).\nfunction isSuspiciousSafariCaretResult(node, offset, x) {\n    let len;\n    if (node.nodeType != 3 || offset != (len = node.nodeValue.length)) return false;\n    for(let next = node.nextSibling; next; next = next.nextSibling)if (next.nodeType != 1 || next.nodeName != \"BR\") return false;\n    return textRange(node, len - 1, len).getBoundingClientRect().left > x;\n}\n// Chrome will move positions between lines to the start of the next line\nfunction isSuspiciousChromeCaretResult(node, offset, x) {\n    if (offset != 0) return false;\n    for(let cur = node;;){\n        let parent = cur.parentNode;\n        if (!parent || parent.nodeType != 1 || parent.firstChild != cur) return false;\n        if (parent.classList.contains(\"cm-line\")) break;\n        cur = parent;\n    }\n    let rect = node.nodeType == 1 ? node.getBoundingClientRect() : textRange(node, 0, Math.max(node.nodeValue.length, 1)).getBoundingClientRect();\n    return x - rect.left > 5;\n}\nfunction blockAt(view, pos) {\n    let line = view.lineBlockAt(pos);\n    if (Array.isArray(line.type)) for (let l of line.type){\n        if (l.to > pos || l.to == pos && (l.to == line.to || l.type == BlockType.Text)) return l;\n    }\n    return line;\n}\nfunction moveToLineBoundary(view, start, forward, includeWrap) {\n    let line = blockAt(view, start.head);\n    let coords = !includeWrap || line.type != BlockType.Text || !(view.lineWrapping || line.widgetLineBreaks) ? null : view.coordsAtPos(start.assoc < 0 && start.head > line.from ? start.head - 1 : start.head);\n    if (coords) {\n        let editorRect = view.dom.getBoundingClientRect();\n        let direction = view.textDirectionAt(line.from);\n        let pos = view.posAtCoords({\n            x: forward == (direction == Direction.LTR) ? editorRect.right - 1 : editorRect.left + 1,\n            y: (coords.top + coords.bottom) / 2\n        });\n        if (pos != null) return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(pos, forward ? -1 : 1);\n    }\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(forward ? line.to : line.from, forward ? -1 : 1);\n}\nfunction moveByChar(view, start, forward, by) {\n    let line = view.state.doc.lineAt(start.head), spans = view.bidiSpans(line);\n    let direction = view.textDirectionAt(line.from);\n    for(let cur = start, check = null;;){\n        let next = moveVisually(line, spans, direction, cur, forward), char = movedOver;\n        if (!next) {\n            if (line.number == (forward ? view.state.doc.lines : 1)) return cur;\n            char = \"\\n\";\n            line = view.state.doc.line(line.number + (forward ? 1 : -1));\n            spans = view.bidiSpans(line);\n            next = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(forward ? line.from : line.to);\n        }\n        if (!check) {\n            if (!by) return next;\n            check = by(char);\n        } else if (!check(char)) {\n            return cur;\n        }\n        cur = next;\n    }\n}\nfunction byGroup(view, pos, start) {\n    let categorize = view.state.charCategorizer(pos);\n    let cat = categorize(start);\n    return (next)=>{\n        let nextCat = categorize(next);\n        if (cat == _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.CharCategory.Space) cat = nextCat;\n        return cat == nextCat;\n    };\n}\nfunction moveVertically(view, start, forward, distance) {\n    let startPos = start.head, dir = forward ? 1 : -1;\n    if (startPos == (forward ? view.state.doc.length : 0)) return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(startPos, start.assoc);\n    let goal = start.goalColumn, startY;\n    let rect = view.contentDOM.getBoundingClientRect();\n    let startCoords = view.coordsAtPos(startPos, start.assoc || -1), docTop = view.documentTop;\n    if (startCoords) {\n        if (goal == null) goal = startCoords.left - rect.left;\n        startY = dir < 0 ? startCoords.top : startCoords.bottom;\n    } else {\n        let line = view.viewState.lineBlockAt(startPos);\n        if (goal == null) goal = Math.min(rect.right - rect.left, view.defaultCharacterWidth * (startPos - line.from));\n        startY = (dir < 0 ? line.top : line.bottom) + docTop;\n    }\n    let resolvedGoal = rect.left + goal;\n    let dist = distance !== null && distance !== void 0 ? distance : view.viewState.heightOracle.textHeight >> 1;\n    for(let extra = 0;; extra += 10){\n        let curY = startY + (dist + extra) * dir;\n        let pos = posAtCoords(view, {\n            x: resolvedGoal,\n            y: curY\n        }, false, dir);\n        if (curY < rect.top || curY > rect.bottom || (dir < 0 ? pos < startPos : pos > startPos)) {\n            let charRect = view.docView.coordsForChar(pos);\n            let assoc = !charRect || curY < charRect.top ? -1 : 1;\n            return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(pos, assoc, undefined, goal);\n        }\n    }\n}\nfunction skipAtomicRanges(atoms, pos, bias) {\n    for(;;){\n        let moved = 0;\n        for (let set of atoms){\n            set.between(pos - 1, pos + 1, (from, to, value)=>{\n                if (pos > from && pos < to) {\n                    let side = moved || bias || (pos - from < to - pos ? -1 : 1);\n                    pos = side < 0 ? from : to;\n                    moved = side;\n                }\n            });\n        }\n        if (!moved) return pos;\n    }\n}\nfunction skipAtoms(view, oldPos, pos) {\n    let newPos = skipAtomicRanges(view.state.facet(atomicRanges).map((f)=>f(view)), pos.from, oldPos.head > pos.from ? -1 : 1);\n    return newPos == pos.from ? pos : _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(newPos, newPos < pos.from ? 1 : -1);\n}\n// This will also be where dragging info and such goes\nclass InputState {\n    setSelectionOrigin(origin) {\n        this.lastSelectionOrigin = origin;\n        this.lastSelectionTime = Date.now();\n    }\n    constructor(view){\n        this.view = view;\n        this.lastKeyCode = 0;\n        this.lastKeyTime = 0;\n        this.lastTouchTime = 0;\n        this.lastFocusTime = 0;\n        this.lastScrollTop = 0;\n        this.lastScrollLeft = 0;\n        // On iOS, some keys need to have their default behavior happen\n        // (after which we retroactively handle them and reset the DOM) to\n        // avoid messing up the virtual keyboard state.\n        this.pendingIOSKey = undefined;\n        this.lastSelectionOrigin = null;\n        this.lastSelectionTime = 0;\n        this.lastEscPress = 0;\n        this.lastContextMenu = 0;\n        this.scrollHandlers = [];\n        this.handlers = Object.create(null);\n        // -1 means not in a composition. Otherwise, this counts the number\n        // of changes made during the composition. The count is used to\n        // avoid treating the start state of the composition, before any\n        // changes have been made, as part of the composition.\n        this.composing = -1;\n        // Tracks whether the next change should be marked as starting the\n        // composition (null means no composition, true means next is the\n        // first, false means first has already been marked for this\n        // composition)\n        this.compositionFirstChange = null;\n        // End time of the previous composition\n        this.compositionEndedAt = 0;\n        // Used in a kludge to detect when an Enter keypress should be\n        // considered part of the composition on Safari, which fires events\n        // in the wrong order\n        this.compositionPendingKey = false;\n        // Used to categorize changes as part of a composition, even when\n        // the mutation events fire shortly after the compositionend event\n        this.compositionPendingChange = false;\n        this.mouseSelection = null;\n        // When a drag from the editor is active, this points at the range\n        // being dragged.\n        this.draggedContent = null;\n        this.handleEvent = this.handleEvent.bind(this);\n        this.notifiedFocused = view.hasFocus;\n        // On Safari adding an input event handler somehow prevents an\n        // issue where the composition vanishes when you press enter.\n        if (browser.safari) view.contentDOM.addEventListener(\"input\", ()=>null);\n        if (browser.gecko) firefoxCopyCutHack(view.contentDOM.ownerDocument);\n    }\n    handleEvent(event) {\n        if (!eventBelongsToEditor(this.view, event) || this.ignoreDuringComposition(event)) return;\n        if (event.type == \"keydown\" && this.keydown(event)) return;\n        this.runHandlers(event.type, event);\n    }\n    runHandlers(type, event) {\n        let handlers = this.handlers[type];\n        if (handlers) {\n            for (let observer of handlers.observers)observer(this.view, event);\n            for (let handler of handlers.handlers){\n                if (event.defaultPrevented) break;\n                if (handler(this.view, event)) {\n                    event.preventDefault();\n                    break;\n                }\n            }\n        }\n    }\n    ensureHandlers(plugins) {\n        let handlers = computeHandlers(plugins), prev = this.handlers, dom = this.view.contentDOM;\n        for(let type in handlers)if (type != \"scroll\") {\n            let passive = !handlers[type].handlers.length;\n            let exists = prev[type];\n            if (exists && passive != !exists.handlers.length) {\n                dom.removeEventListener(type, this.handleEvent);\n                exists = null;\n            }\n            if (!exists) dom.addEventListener(type, this.handleEvent, {\n                passive\n            });\n        }\n        for(let type in prev)if (type != \"scroll\" && !handlers[type]) dom.removeEventListener(type, this.handleEvent);\n        this.handlers = handlers;\n    }\n    keydown(event) {\n        // Must always run, even if a custom handler handled the event\n        this.lastKeyCode = event.keyCode;\n        this.lastKeyTime = Date.now();\n        if (event.keyCode == 9 && Date.now() < this.lastEscPress + 2000) return true;\n        if (event.keyCode != 27 && modifierCodes.indexOf(event.keyCode) < 0) this.view.inputState.lastEscPress = 0;\n        // Chrome for Android usually doesn't fire proper key events, but\n        // occasionally does, usually surrounded by a bunch of complicated\n        // composition changes. When an enter or backspace key event is\n        // seen, hold off on handling DOM events for a bit, and then\n        // dispatch it.\n        if (browser.android && browser.chrome && !event.synthetic && (event.keyCode == 13 || event.keyCode == 8)) {\n            this.view.observer.delayAndroidKey(event.key, event.keyCode);\n            return true;\n        }\n        // Preventing the default behavior of Enter on iOS makes the\n        // virtual keyboard get stuck in the wrong (lowercase)\n        // state. So we let it go through, and then, in\n        // applyDOMChange, notify key handlers of it and reset to\n        // the state they produce.\n        let pending;\n        if (browser.ios && !event.synthetic && !event.altKey && !event.metaKey && ((pending = PendingKeys.find((key)=>key.keyCode == event.keyCode)) && !event.ctrlKey || EmacsyPendingKeys.indexOf(event.key) > -1 && event.ctrlKey && !event.shiftKey)) {\n            this.pendingIOSKey = pending || event;\n            setTimeout(()=>this.flushIOSKey(), 250);\n            return true;\n        }\n        if (event.keyCode != 229) this.view.observer.forceFlush();\n        return false;\n    }\n    flushIOSKey() {\n        let key = this.pendingIOSKey;\n        if (!key) return false;\n        this.pendingIOSKey = undefined;\n        return dispatchKey(this.view.contentDOM, key.key, key.keyCode);\n    }\n    ignoreDuringComposition(event) {\n        if (!/^key/.test(event.type)) return false;\n        if (this.composing > 0) return true;\n        // See https://www.stum.de/2016/06/24/handling-ime-events-in-javascript/.\n        // On some input method editors (IMEs), the Enter key is used to\n        // confirm character selection. On Safari, when Enter is pressed,\n        // compositionend and keydown events are sometimes emitted in the\n        // wrong order. The key event should still be ignored, even when\n        // it happens after the compositionend event.\n        if (browser.safari && !browser.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100) {\n            this.compositionPendingKey = false;\n            return true;\n        }\n        return false;\n    }\n    startMouseSelection(mouseSelection) {\n        if (this.mouseSelection) this.mouseSelection.destroy();\n        this.mouseSelection = mouseSelection;\n    }\n    update(update) {\n        if (this.mouseSelection) this.mouseSelection.update(update);\n        if (this.draggedContent && update.docChanged) this.draggedContent = this.draggedContent.map(update.changes);\n        if (update.transactions.length) this.lastKeyCode = this.lastSelectionTime = 0;\n    }\n    destroy() {\n        if (this.mouseSelection) this.mouseSelection.destroy();\n    }\n}\nfunction bindHandler(plugin, handler) {\n    return (view, event)=>{\n        try {\n            return handler.call(plugin, event, view);\n        } catch (e) {\n            logException(view.state, e);\n        }\n    };\n}\nfunction computeHandlers(plugins) {\n    let result = Object.create(null);\n    function record(type) {\n        return result[type] || (result[type] = {\n            observers: [],\n            handlers: []\n        });\n    }\n    for (let plugin of plugins){\n        let spec = plugin.spec;\n        if (spec && spec.domEventHandlers) for(let type in spec.domEventHandlers){\n            let f = spec.domEventHandlers[type];\n            if (f) record(type).handlers.push(bindHandler(plugin.value, f));\n        }\n        if (spec && spec.domEventObservers) for(let type in spec.domEventObservers){\n            let f = spec.domEventObservers[type];\n            if (f) record(type).observers.push(bindHandler(plugin.value, f));\n        }\n    }\n    for(let type in handlers)record(type).handlers.push(handlers[type]);\n    for(let type in observers)record(type).observers.push(observers[type]);\n    return result;\n}\nconst PendingKeys = [\n    {\n        key: \"Backspace\",\n        keyCode: 8,\n        inputType: \"deleteContentBackward\"\n    },\n    {\n        key: \"Enter\",\n        keyCode: 13,\n        inputType: \"insertParagraph\"\n    },\n    {\n        key: \"Enter\",\n        keyCode: 13,\n        inputType: \"insertLineBreak\"\n    },\n    {\n        key: \"Delete\",\n        keyCode: 46,\n        inputType: \"deleteContentForward\"\n    }\n];\nconst EmacsyPendingKeys = \"dthko\";\n// Key codes for modifier keys\nconst modifierCodes = [\n    16,\n    17,\n    18,\n    20,\n    91,\n    92,\n    224,\n    225\n];\nconst dragScrollMargin = 6;\nfunction dragScrollSpeed(dist) {\n    return Math.max(0, dist) * 0.7 + 8;\n}\nfunction dist(a, b) {\n    return Math.max(Math.abs(a.clientX - b.clientX), Math.abs(a.clientY - b.clientY));\n}\nclass MouseSelection {\n    constructor(view, startEvent, style, mustSelect){\n        this.view = view;\n        this.startEvent = startEvent;\n        this.style = style;\n        this.mustSelect = mustSelect;\n        this.scrollSpeed = {\n            x: 0,\n            y: 0\n        };\n        this.scrolling = -1;\n        this.lastEvent = startEvent;\n        this.scrollParent = scrollableParent(view.contentDOM);\n        this.atoms = view.state.facet(atomicRanges).map((f)=>f(view));\n        let doc = view.contentDOM.ownerDocument;\n        doc.addEventListener(\"mousemove\", this.move = this.move.bind(this));\n        doc.addEventListener(\"mouseup\", this.up = this.up.bind(this));\n        this.extend = startEvent.shiftKey;\n        this.multiple = view.state.facet(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorState.allowMultipleSelections) && addsSelectionRange(view, startEvent);\n        this.dragging = isInPrimarySelection(view, startEvent) && getClickType(startEvent) == 1 ? null : false;\n    }\n    start(event) {\n        // When clicking outside of the selection, immediately apply the\n        // effect of starting the selection\n        if (this.dragging === false) this.select(event);\n    }\n    move(event) {\n        var _a;\n        if (event.buttons == 0) return this.destroy();\n        if (this.dragging || this.dragging == null && dist(this.startEvent, event) < 10) return;\n        this.select(this.lastEvent = event);\n        let sx = 0, sy = 0;\n        let rect = ((_a = this.scrollParent) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect()) || {\n            left: 0,\n            top: 0,\n            right: this.view.win.innerWidth,\n            bottom: this.view.win.innerHeight\n        };\n        let margins = getScrollMargins(this.view);\n        if (event.clientX - margins.left <= rect.left + dragScrollMargin) sx = -dragScrollSpeed(rect.left - event.clientX);\n        else if (event.clientX + margins.right >= rect.right - dragScrollMargin) sx = dragScrollSpeed(event.clientX - rect.right);\n        if (event.clientY - margins.top <= rect.top + dragScrollMargin) sy = -dragScrollSpeed(rect.top - event.clientY);\n        else if (event.clientY + margins.bottom >= rect.bottom - dragScrollMargin) sy = dragScrollSpeed(event.clientY - rect.bottom);\n        this.setScrollSpeed(sx, sy);\n    }\n    up(event) {\n        if (this.dragging == null) this.select(this.lastEvent);\n        if (!this.dragging) event.preventDefault();\n        this.destroy();\n    }\n    destroy() {\n        this.setScrollSpeed(0, 0);\n        let doc = this.view.contentDOM.ownerDocument;\n        doc.removeEventListener(\"mousemove\", this.move);\n        doc.removeEventListener(\"mouseup\", this.up);\n        this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null;\n    }\n    setScrollSpeed(sx, sy) {\n        this.scrollSpeed = {\n            x: sx,\n            y: sy\n        };\n        if (sx || sy) {\n            if (this.scrolling < 0) this.scrolling = setInterval(()=>this.scroll(), 50);\n        } else if (this.scrolling > -1) {\n            clearInterval(this.scrolling);\n            this.scrolling = -1;\n        }\n    }\n    scroll() {\n        if (this.scrollParent) {\n            this.scrollParent.scrollLeft += this.scrollSpeed.x;\n            this.scrollParent.scrollTop += this.scrollSpeed.y;\n        } else {\n            this.view.win.scrollBy(this.scrollSpeed.x, this.scrollSpeed.y);\n        }\n        if (this.dragging === false) this.select(this.lastEvent);\n    }\n    skipAtoms(sel) {\n        let ranges = null;\n        for(let i = 0; i < sel.ranges.length; i++){\n            let range = sel.ranges[i], updated = null;\n            if (range.empty) {\n                let pos = skipAtomicRanges(this.atoms, range.from, 0);\n                if (pos != range.from) updated = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(pos, -1);\n            } else {\n                let from = skipAtomicRanges(this.atoms, range.from, -1);\n                let to = skipAtomicRanges(this.atoms, range.to, 1);\n                if (from != range.from || to != range.to) updated = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.range(range.from == range.anchor ? from : to, range.from == range.head ? from : to);\n            }\n            if (updated) {\n                if (!ranges) ranges = sel.ranges.slice();\n                ranges[i] = updated;\n            }\n        }\n        return ranges ? _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.create(ranges, sel.mainIndex) : sel;\n    }\n    select(event) {\n        let { view } = this, selection = this.skipAtoms(this.style.get(event, this.extend, this.multiple));\n        if (this.mustSelect || !selection.eq(view.state.selection) || selection.main.assoc != view.state.selection.main.assoc && this.dragging === false) this.view.dispatch({\n            selection,\n            userEvent: \"select.pointer\"\n        });\n        this.mustSelect = false;\n    }\n    update(update) {\n        if (this.style.update(update)) setTimeout(()=>this.select(this.lastEvent), 20);\n    }\n}\nfunction addsSelectionRange(view, event) {\n    let facet = view.state.facet(clickAddsSelectionRange);\n    return facet.length ? facet[0](event) : browser.mac ? event.metaKey : event.ctrlKey;\n}\nfunction dragMovesSelection(view, event) {\n    let facet = view.state.facet(dragMovesSelection$1);\n    return facet.length ? facet[0](event) : browser.mac ? !event.altKey : !event.ctrlKey;\n}\nfunction isInPrimarySelection(view, event) {\n    let { main } = view.state.selection;\n    if (main.empty) return false;\n    // On boundary clicks, check whether the coordinates are inside the\n    // selection's client rectangles\n    let sel = getSelection(view.root);\n    if (!sel || sel.rangeCount == 0) return true;\n    let rects = sel.getRangeAt(0).getClientRects();\n    for(let i = 0; i < rects.length; i++){\n        let rect = rects[i];\n        if (rect.left <= event.clientX && rect.right >= event.clientX && rect.top <= event.clientY && rect.bottom >= event.clientY) return true;\n    }\n    return false;\n}\nfunction eventBelongsToEditor(view, event) {\n    if (!event.bubbles) return true;\n    if (event.defaultPrevented) return false;\n    for(let node = event.target, cView; node != view.contentDOM; node = node.parentNode)if (!node || node.nodeType == 11 || (cView = ContentView.get(node)) && cView.ignoreEvent(event)) return false;\n    return true;\n}\nconst handlers = /*@__PURE__*/ Object.create(null);\nconst observers = /*@__PURE__*/ Object.create(null);\n// This is very crude, but unfortunately both these browsers _pretend_\n// that they have a clipboard API—all the objects and methods are\n// there, they just don't work, and they are hard to test.\nconst brokenClipboardAPI = browser.ie && browser.ie_version < 15 || browser.ios && browser.webkit_version < 604;\nfunction capturePaste(view) {\n    let parent = view.dom.parentNode;\n    if (!parent) return;\n    let target = parent.appendChild(document.createElement(\"textarea\"));\n    target.style.cssText = \"position: fixed; left: -10000px; top: 10px\";\n    target.focus();\n    setTimeout(()=>{\n        view.focus();\n        target.remove();\n        doPaste(view, target.value);\n    }, 50);\n}\nfunction doPaste(view, input) {\n    let { state } = view, changes, i = 1, text = state.toText(input);\n    let byLine = text.lines == state.selection.ranges.length;\n    let linewise = lastLinewiseCopy != null && state.selection.ranges.every((r)=>r.empty) && lastLinewiseCopy == text.toString();\n    if (linewise) {\n        let lastLine = -1;\n        changes = state.changeByRange((range)=>{\n            let line = state.doc.lineAt(range.from);\n            if (line.from == lastLine) return {\n                range\n            };\n            lastLine = line.from;\n            let insert = state.toText((byLine ? text.line(i++).text : input) + state.lineBreak);\n            return {\n                changes: {\n                    from: line.from,\n                    insert\n                },\n                range: _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(range.from + insert.length)\n            };\n        });\n    } else if (byLine) {\n        changes = state.changeByRange((range)=>{\n            let line = text.line(i++);\n            return {\n                changes: {\n                    from: range.from,\n                    to: range.to,\n                    insert: line.text\n                },\n                range: _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(range.from + line.length)\n            };\n        });\n    } else {\n        changes = state.replaceSelection(text);\n    }\n    view.dispatch(changes, {\n        userEvent: \"input.paste\",\n        scrollIntoView: true\n    });\n}\nobservers.scroll = (view)=>{\n    view.inputState.lastScrollTop = view.scrollDOM.scrollTop;\n    view.inputState.lastScrollLeft = view.scrollDOM.scrollLeft;\n};\nhandlers.keydown = (view, event)=>{\n    view.inputState.setSelectionOrigin(\"select\");\n    if (event.keyCode == 27) view.inputState.lastEscPress = Date.now();\n    return false;\n};\nobservers.touchstart = (view, e)=>{\n    view.inputState.lastTouchTime = Date.now();\n    view.inputState.setSelectionOrigin(\"select.pointer\");\n};\nobservers.touchmove = (view)=>{\n    view.inputState.setSelectionOrigin(\"select.pointer\");\n};\nhandlers.mousedown = (view, event)=>{\n    view.observer.flush();\n    if (view.inputState.lastTouchTime > Date.now() - 2000) return false; // Ignore touch interaction\n    let style = null;\n    for (let makeStyle of view.state.facet(mouseSelectionStyle)){\n        style = makeStyle(view, event);\n        if (style) break;\n    }\n    if (!style && event.button == 0) style = basicMouseSelection(view, event);\n    if (style) {\n        let mustFocus = !view.hasFocus;\n        view.inputState.startMouseSelection(new MouseSelection(view, event, style, mustFocus));\n        if (mustFocus) view.observer.ignore(()=>focusPreventScroll(view.contentDOM));\n        let mouseSel = view.inputState.mouseSelection;\n        if (mouseSel) {\n            mouseSel.start(event);\n            return mouseSel.dragging === false;\n        }\n    }\n    return false;\n};\nfunction rangeForClick(view, pos, bias, type) {\n    if (type == 1) {\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(pos, bias);\n    } else if (type == 2) {\n        return groupAt(view.state, pos, bias);\n    } else {\n        let visual = LineView.find(view.docView, pos), line = view.state.doc.lineAt(visual ? visual.posAtEnd : pos);\n        let from = visual ? visual.posAtStart : line.from, to = visual ? visual.posAtEnd : line.to;\n        if (to < view.state.doc.length && to == line.to) to++;\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.range(from, to);\n    }\n}\nlet insideY = (y, rect)=>y >= rect.top && y <= rect.bottom;\nlet inside = (x, y, rect)=>insideY(y, rect) && x >= rect.left && x <= rect.right;\n// Try to determine, for the given coordinates, associated with the\n// given position, whether they are related to the element before or\n// the element after the position.\nfunction findPositionSide(view, pos, x, y) {\n    let line = LineView.find(view.docView, pos);\n    if (!line) return 1;\n    let off = pos - line.posAtStart;\n    // Line boundaries point into the line\n    if (off == 0) return 1;\n    if (off == line.length) return -1;\n    // Positions on top of an element point at that element\n    let before = line.coordsAt(off, -1);\n    if (before && inside(x, y, before)) return -1;\n    let after = line.coordsAt(off, 1);\n    if (after && inside(x, y, after)) return 1;\n    // This is probably a line wrap point. Pick before if the point is\n    // beside it.\n    return before && insideY(y, before) ? -1 : 1;\n}\nfunction queryPos(view, event) {\n    let pos = view.posAtCoords({\n        x: event.clientX,\n        y: event.clientY\n    }, false);\n    return {\n        pos,\n        bias: findPositionSide(view, pos, event.clientX, event.clientY)\n    };\n}\nconst BadMouseDetail = browser.ie && browser.ie_version <= 11;\nlet lastMouseDown = null, lastMouseDownCount = 0, lastMouseDownTime = 0;\nfunction getClickType(event) {\n    if (!BadMouseDetail) return event.detail;\n    let last = lastMouseDown, lastTime = lastMouseDownTime;\n    lastMouseDown = event;\n    lastMouseDownTime = Date.now();\n    return lastMouseDownCount = !last || lastTime > Date.now() - 400 && Math.abs(last.clientX - event.clientX) < 2 && Math.abs(last.clientY - event.clientY) < 2 ? (lastMouseDownCount + 1) % 3 : 1;\n}\nfunction basicMouseSelection(view, event) {\n    let start = queryPos(view, event), type = getClickType(event);\n    let startSel = view.state.selection;\n    return {\n        update (update) {\n            if (update.docChanged) {\n                start.pos = update.changes.mapPos(start.pos);\n                startSel = startSel.map(update.changes);\n            }\n        },\n        get (event, extend, multiple) {\n            let cur = queryPos(view, event), removed;\n            let range = rangeForClick(view, cur.pos, cur.bias, type);\n            if (start.pos != cur.pos && !extend) {\n                let startRange = rangeForClick(view, start.pos, start.bias, type);\n                let from = Math.min(startRange.from, range.from), to = Math.max(startRange.to, range.to);\n                range = from < range.from ? _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.range(from, to) : _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.range(to, from);\n            }\n            if (extend) return startSel.replaceRange(startSel.main.extend(range.from, range.to));\n            else if (multiple && type == 1 && startSel.ranges.length > 1 && (removed = removeRangeAround(startSel, cur.pos))) return removed;\n            else if (multiple) return startSel.addRange(range);\n            else return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.create([\n                range\n            ]);\n        }\n    };\n}\nfunction removeRangeAround(sel, pos) {\n    for(let i = 0; i < sel.ranges.length; i++){\n        let { from, to } = sel.ranges[i];\n        if (from <= pos && to >= pos) return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.create(sel.ranges.slice(0, i).concat(sel.ranges.slice(i + 1)), sel.mainIndex == i ? 0 : sel.mainIndex - (sel.mainIndex > i ? 1 : 0));\n    }\n    return null;\n}\nhandlers.dragstart = (view, event)=>{\n    let { selection: { main: range } } = view.state;\n    if (event.target.draggable) {\n        let cView = view.docView.nearest(event.target);\n        if (cView && cView.isWidget) {\n            let from = cView.posAtStart, to = from + cView.length;\n            if (from >= range.to || to <= range.from) range = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.range(from, to);\n        }\n    }\n    let { inputState } = view;\n    if (inputState.mouseSelection) inputState.mouseSelection.dragging = true;\n    inputState.draggedContent = range;\n    if (event.dataTransfer) {\n        event.dataTransfer.setData(\"Text\", view.state.sliceDoc(range.from, range.to));\n        event.dataTransfer.effectAllowed = \"copyMove\";\n    }\n    return false;\n};\nhandlers.dragend = (view)=>{\n    view.inputState.draggedContent = null;\n    return false;\n};\nfunction dropText(view, event, text, direct) {\n    if (!text) return;\n    let dropPos = view.posAtCoords({\n        x: event.clientX,\n        y: event.clientY\n    }, false);\n    let { draggedContent } = view.inputState;\n    let del = direct && draggedContent && dragMovesSelection(view, event) ? {\n        from: draggedContent.from,\n        to: draggedContent.to\n    } : null;\n    let ins = {\n        from: dropPos,\n        insert: text\n    };\n    let changes = view.state.changes(del ? [\n        del,\n        ins\n    ] : ins);\n    view.focus();\n    view.dispatch({\n        changes,\n        selection: {\n            anchor: changes.mapPos(dropPos, -1),\n            head: changes.mapPos(dropPos, 1)\n        },\n        userEvent: del ? \"move.drop\" : \"input.drop\"\n    });\n    view.inputState.draggedContent = null;\n}\nhandlers.drop = (view, event)=>{\n    if (!event.dataTransfer) return false;\n    if (view.state.readOnly) return true;\n    let files = event.dataTransfer.files;\n    if (files && files.length) {\n        let text = Array(files.length), read = 0;\n        let finishFile = ()=>{\n            if (++read == files.length) dropText(view, event, text.filter((s)=>s != null).join(view.state.lineBreak), false);\n        };\n        for(let i = 0; i < files.length; i++){\n            let reader = new FileReader;\n            reader.onerror = finishFile;\n            reader.onload = ()=>{\n                if (!/[\\x00-\\x08\\x0e-\\x1f]{2}/.test(reader.result)) text[i] = reader.result;\n                finishFile();\n            };\n            reader.readAsText(files[i]);\n        }\n        return true;\n    } else {\n        let text = event.dataTransfer.getData(\"Text\");\n        if (text) {\n            dropText(view, event, text, true);\n            return true;\n        }\n    }\n    return false;\n};\nhandlers.paste = (view, event)=>{\n    if (view.state.readOnly) return true;\n    view.observer.flush();\n    let data = brokenClipboardAPI ? null : event.clipboardData;\n    if (data) {\n        doPaste(view, data.getData(\"text/plain\") || data.getData(\"text/uri-text\"));\n        return true;\n    } else {\n        capturePaste(view);\n        return false;\n    }\n};\nfunction captureCopy(view, text) {\n    // The extra wrapper is somehow necessary on IE/Edge to prevent the\n    // content from being mangled when it is put onto the clipboard\n    let parent = view.dom.parentNode;\n    if (!parent) return;\n    let target = parent.appendChild(document.createElement(\"textarea\"));\n    target.style.cssText = \"position: fixed; left: -10000px; top: 10px\";\n    target.value = text;\n    target.focus();\n    target.selectionEnd = text.length;\n    target.selectionStart = 0;\n    setTimeout(()=>{\n        target.remove();\n        view.focus();\n    }, 50);\n}\nfunction copiedRange(state) {\n    let content = [], ranges = [], linewise = false;\n    for (let range of state.selection.ranges)if (!range.empty) {\n        content.push(state.sliceDoc(range.from, range.to));\n        ranges.push(range);\n    }\n    if (!content.length) {\n        // Nothing selected, do a line-wise copy\n        let upto = -1;\n        for (let { from } of state.selection.ranges){\n            let line = state.doc.lineAt(from);\n            if (line.number > upto) {\n                content.push(line.text);\n                ranges.push({\n                    from: line.from,\n                    to: Math.min(state.doc.length, line.to + 1)\n                });\n            }\n            upto = line.number;\n        }\n        linewise = true;\n    }\n    return {\n        text: content.join(state.lineBreak),\n        ranges,\n        linewise\n    };\n}\nlet lastLinewiseCopy = null;\nhandlers.copy = handlers.cut = (view, event)=>{\n    let { text, ranges, linewise } = copiedRange(view.state);\n    if (!text && !linewise) return false;\n    lastLinewiseCopy = linewise ? text : null;\n    if (event.type == \"cut\" && !view.state.readOnly) view.dispatch({\n        changes: ranges,\n        scrollIntoView: true,\n        userEvent: \"delete.cut\"\n    });\n    let data = brokenClipboardAPI ? null : event.clipboardData;\n    if (data) {\n        data.clearData();\n        data.setData(\"text/plain\", text);\n        return true;\n    } else {\n        captureCopy(view, text);\n        return false;\n    }\n};\nconst isFocusChange = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Annotation.define();\nfunction focusChangeTransaction(state, focus) {\n    let effects = [];\n    for (let getEffect of state.facet(focusChangeEffect)){\n        let effect = getEffect(state, focus);\n        if (effect) effects.push(effect);\n    }\n    return effects ? state.update({\n        effects,\n        annotations: isFocusChange.of(true)\n    }) : null;\n}\nfunction updateForFocusChange(view) {\n    setTimeout(()=>{\n        let focus = view.hasFocus;\n        if (focus != view.inputState.notifiedFocused) {\n            let tr = focusChangeTransaction(view.state, focus);\n            if (tr) view.dispatch(tr);\n            else view.update([]);\n        }\n    }, 10);\n}\nobservers.focus = (view)=>{\n    view.inputState.lastFocusTime = Date.now();\n    // When focusing reset the scroll position, move it back to where it was\n    if (!view.scrollDOM.scrollTop && (view.inputState.lastScrollTop || view.inputState.lastScrollLeft)) {\n        view.scrollDOM.scrollTop = view.inputState.lastScrollTop;\n        view.scrollDOM.scrollLeft = view.inputState.lastScrollLeft;\n    }\n    updateForFocusChange(view);\n};\nobservers.blur = (view)=>{\n    view.observer.clearSelectionRange();\n    updateForFocusChange(view);\n};\nobservers.compositionstart = observers.compositionupdate = (view)=>{\n    if (view.inputState.compositionFirstChange == null) view.inputState.compositionFirstChange = true;\n    if (view.inputState.composing < 0) {\n        // FIXME possibly set a timeout to clear it again on Android\n        view.inputState.composing = 0;\n    }\n};\nobservers.compositionend = (view)=>{\n    view.inputState.composing = -1;\n    view.inputState.compositionEndedAt = Date.now();\n    view.inputState.compositionPendingKey = true;\n    view.inputState.compositionPendingChange = view.observer.pendingRecords().length > 0;\n    view.inputState.compositionFirstChange = null;\n    if (browser.chrome && browser.android) {\n        // Delay flushing for a bit on Android because it'll often fire a\n        // bunch of contradictory changes in a row at end of compositon\n        view.observer.flushSoon();\n    } else if (view.inputState.compositionPendingChange) {\n        // If we found pending records, schedule a flush.\n        Promise.resolve().then(()=>view.observer.flush());\n    } else {\n        // Otherwise, make sure that, if no changes come in soon, the\n        // composition view is cleared.\n        setTimeout(()=>{\n            if (view.inputState.composing < 0 && view.docView.hasComposition) view.update([]);\n        }, 50);\n    }\n};\nobservers.contextmenu = (view)=>{\n    view.inputState.lastContextMenu = Date.now();\n};\nhandlers.beforeinput = (view, event)=>{\n    var _a;\n    // Because Chrome Android doesn't fire useful key events, use\n    // beforeinput to detect backspace (and possibly enter and delete,\n    // but those usually don't even seem to fire beforeinput events at\n    // the moment) and fake a key event for it.\n    //\n    // (preventDefault on beforeinput, though supported in the spec,\n    // seems to do nothing at all on Chrome).\n    let pending;\n    if (browser.chrome && browser.android && (pending = PendingKeys.find((key)=>key.inputType == event.inputType))) {\n        view.observer.delayAndroidKey(pending.key, pending.keyCode);\n        if (pending.key == \"Backspace\" || pending.key == \"Delete\") {\n            let startViewHeight = ((_a = window.visualViewport) === null || _a === void 0 ? void 0 : _a.height) || 0;\n            setTimeout(()=>{\n                var _a;\n                // Backspacing near uneditable nodes on Chrome Android sometimes\n                // closes the virtual keyboard. This tries to crudely detect\n                // that and refocus to get it back.\n                if ((((_a = window.visualViewport) === null || _a === void 0 ? void 0 : _a.height) || 0) > startViewHeight + 10 && view.hasFocus) {\n                    view.contentDOM.blur();\n                    view.focus();\n                }\n            }, 100);\n        }\n    }\n    return false;\n};\nconst appliedFirefoxHack = /*@__PURE__*/ new Set;\n// In Firefox, when cut/copy handlers are added to the document, that\n// somehow avoids a bug where those events aren't fired when the\n// selection is empty. See https://github.com/codemirror/dev/issues/1082\n// and https://bugzilla.mozilla.org/show_bug.cgi?id=995961\nfunction firefoxCopyCutHack(doc) {\n    if (!appliedFirefoxHack.has(doc)) {\n        appliedFirefoxHack.add(doc);\n        doc.addEventListener(\"copy\", ()=>{});\n        doc.addEventListener(\"cut\", ()=>{});\n    }\n}\nconst wrappingWhiteSpace = [\n    \"pre-wrap\",\n    \"normal\",\n    \"pre-line\",\n    \"break-spaces\"\n];\nclass HeightOracle {\n    constructor(lineWrapping){\n        this.lineWrapping = lineWrapping;\n        this.doc = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Text.empty;\n        this.heightSamples = {};\n        this.lineHeight = 14; // The height of an entire line (line-height)\n        this.charWidth = 7;\n        this.textHeight = 14; // The height of the actual font (font-size)\n        this.lineLength = 30;\n        // Used to track, during updateHeight, if any actual heights changed\n        this.heightChanged = false;\n    }\n    heightForGap(from, to) {\n        let lines = this.doc.lineAt(to).number - this.doc.lineAt(from).number + 1;\n        if (this.lineWrapping) lines += Math.max(0, Math.ceil((to - from - lines * this.lineLength * 0.5) / this.lineLength));\n        return this.lineHeight * lines;\n    }\n    heightForLine(length) {\n        if (!this.lineWrapping) return this.lineHeight;\n        let lines = 1 + Math.max(0, Math.ceil((length - this.lineLength) / (this.lineLength - 5)));\n        return lines * this.lineHeight;\n    }\n    setDoc(doc) {\n        this.doc = doc;\n        return this;\n    }\n    mustRefreshForWrapping(whiteSpace) {\n        return wrappingWhiteSpace.indexOf(whiteSpace) > -1 != this.lineWrapping;\n    }\n    mustRefreshForHeights(lineHeights) {\n        let newHeight = false;\n        for(let i = 0; i < lineHeights.length; i++){\n            let h = lineHeights[i];\n            if (h < 0) {\n                i++;\n            } else if (!this.heightSamples[Math.floor(h * 10)]) {\n                newHeight = true;\n                this.heightSamples[Math.floor(h * 10)] = true;\n            }\n        }\n        return newHeight;\n    }\n    refresh(whiteSpace, lineHeight, charWidth, textHeight, lineLength, knownHeights) {\n        let lineWrapping = wrappingWhiteSpace.indexOf(whiteSpace) > -1;\n        let changed = Math.round(lineHeight) != Math.round(this.lineHeight) || this.lineWrapping != lineWrapping;\n        this.lineWrapping = lineWrapping;\n        this.lineHeight = lineHeight;\n        this.charWidth = charWidth;\n        this.textHeight = textHeight;\n        this.lineLength = lineLength;\n        if (changed) {\n            this.heightSamples = {};\n            for(let i = 0; i < knownHeights.length; i++){\n                let h = knownHeights[i];\n                if (h < 0) i++;\n                else this.heightSamples[Math.floor(h * 10)] = true;\n            }\n        }\n        return changed;\n    }\n}\n// This object is used by `updateHeight` to make DOM measurements\n// arrive at the right nides. The `heights` array is a sequence of\n// block heights, starting from position `from`.\nclass MeasuredHeights {\n    constructor(from, heights){\n        this.from = from;\n        this.heights = heights;\n        this.index = 0;\n    }\n    get more() {\n        return this.index < this.heights.length;\n    }\n}\n/**\nRecord used to represent information about a block-level element\nin the editor view.\n*/ class BlockInfo {\n    /**\n    @internal\n    */ constructor(/**\n    The start of the element in the document.\n    */ from, /**\n    The length of the element.\n    */ length, /**\n    The top position of the element (relative to the top of the\n    document).\n    */ top, /**\n    Its height.\n    */ height, /**\n    @internal Weird packed field that holds an array of children\n    for composite blocks, a decoration for block widgets, and a\n    number indicating the amount of widget-create line breaks for\n    text blocks.\n    */ _content){\n        this.from = from;\n        this.length = length;\n        this.top = top;\n        this.height = height;\n        this._content = _content;\n    }\n    /**\n    The type of element this is. When querying lines, this may be\n    an array of all the blocks that make up the line.\n    */ get type() {\n        return typeof this._content == \"number\" ? BlockType.Text : Array.isArray(this._content) ? this._content : this._content.type;\n    }\n    /**\n    The end of the element as a document position.\n    */ get to() {\n        return this.from + this.length;\n    }\n    /**\n    The bottom position of the element.\n    */ get bottom() {\n        return this.top + this.height;\n    }\n    /**\n    If this is a widget block, this will return the widget\n    associated with it.\n    */ get widget() {\n        return this._content instanceof PointDecoration ? this._content.widget : null;\n    }\n    /**\n    If this is a textblock, this holds the number of line breaks\n    that appear in widgets inside the block.\n    */ get widgetLineBreaks() {\n        return typeof this._content == \"number\" ? this._content : 0;\n    }\n    /**\n    @internal\n    */ join(other) {\n        let content = (Array.isArray(this._content) ? this._content : [\n            this\n        ]).concat(Array.isArray(other._content) ? other._content : [\n            other\n        ]);\n        return new BlockInfo(this.from, this.length + other.length, this.top, this.height + other.height, content);\n    }\n}\nvar QueryType = /*@__PURE__*/ function(QueryType) {\n    QueryType[QueryType[\"ByPos\"] = 0] = \"ByPos\";\n    QueryType[QueryType[\"ByHeight\"] = 1] = \"ByHeight\";\n    QueryType[QueryType[\"ByPosNoHeight\"] = 2] = \"ByPosNoHeight\";\n    return QueryType;\n}(QueryType || (QueryType = {}));\nconst Epsilon = 1e-3;\nclass HeightMap {\n    constructor(length, height, flags = 2 /* Flag.Outdated */ ){\n        this.length = length;\n        this.height = height;\n        this.flags = flags;\n    }\n    get outdated() {\n        return (this.flags & 2 /* Flag.Outdated */ ) > 0;\n    }\n    set outdated(value) {\n        this.flags = (value ? 2 /* Flag.Outdated */  : 0) | this.flags & ~2 /* Flag.Outdated */ ;\n    }\n    setHeight(oracle, height) {\n        if (this.height != height) {\n            if (Math.abs(this.height - height) > Epsilon) oracle.heightChanged = true;\n            this.height = height;\n        }\n    }\n    // Base case is to replace a leaf node, which simply builds a tree\n    // from the new nodes and returns that (HeightMapBranch and\n    // HeightMapGap override this to actually use from/to)\n    replace(_from, _to, nodes) {\n        return HeightMap.of(nodes);\n    }\n    // Again, these are base cases, and are overridden for branch and gap nodes.\n    decomposeLeft(_to, result) {\n        result.push(this);\n    }\n    decomposeRight(_from, result) {\n        result.push(this);\n    }\n    applyChanges(decorations, oldDoc, oracle, changes) {\n        let me = this, doc = oracle.doc;\n        for(let i = changes.length - 1; i >= 0; i--){\n            let { fromA, toA, fromB, toB } = changes[i];\n            let start = me.lineAt(fromA, QueryType.ByPosNoHeight, oracle.setDoc(oldDoc), 0, 0);\n            let end = start.to >= toA ? start : me.lineAt(toA, QueryType.ByPosNoHeight, oracle, 0, 0);\n            toB += end.to - toA;\n            toA = end.to;\n            while(i > 0 && start.from <= changes[i - 1].toA){\n                fromA = changes[i - 1].fromA;\n                fromB = changes[i - 1].fromB;\n                i--;\n                if (fromA < start.from) start = me.lineAt(fromA, QueryType.ByPosNoHeight, oracle, 0, 0);\n            }\n            fromB += start.from - fromA;\n            fromA = start.from;\n            let nodes = NodeBuilder.build(oracle.setDoc(doc), decorations, fromB, toB);\n            me = me.replace(fromA, toA, nodes);\n        }\n        return me.updateHeight(oracle, 0);\n    }\n    static empty() {\n        return new HeightMapText(0, 0);\n    }\n    // nodes uses null values to indicate the position of line breaks.\n    // There are never line breaks at the start or end of the array, or\n    // two line breaks next to each other, and the array isn't allowed\n    // to be empty (same restrictions as return value from the builder).\n    static of(nodes) {\n        if (nodes.length == 1) return nodes[0];\n        let i = 0, j = nodes.length, before = 0, after = 0;\n        for(;;){\n            if (i == j) {\n                if (before > after * 2) {\n                    let split = nodes[i - 1];\n                    if (split.break) nodes.splice(--i, 1, split.left, null, split.right);\n                    else nodes.splice(--i, 1, split.left, split.right);\n                    j += 1 + split.break;\n                    before -= split.size;\n                } else if (after > before * 2) {\n                    let split = nodes[j];\n                    if (split.break) nodes.splice(j, 1, split.left, null, split.right);\n                    else nodes.splice(j, 1, split.left, split.right);\n                    j += 2 + split.break;\n                    after -= split.size;\n                } else {\n                    break;\n                }\n            } else if (before < after) {\n                let next = nodes[i++];\n                if (next) before += next.size;\n            } else {\n                let next = nodes[--j];\n                if (next) after += next.size;\n            }\n        }\n        let brk = 0;\n        if (nodes[i - 1] == null) {\n            brk = 1;\n            i--;\n        } else if (nodes[i] == null) {\n            brk = 1;\n            j++;\n        }\n        return new HeightMapBranch(HeightMap.of(nodes.slice(0, i)), brk, HeightMap.of(nodes.slice(j)));\n    }\n}\nHeightMap.prototype.size = 1;\nclass HeightMapBlock extends HeightMap {\n    constructor(length, height, deco){\n        super(length, height);\n        this.deco = deco;\n    }\n    blockAt(_height, _oracle, top, offset) {\n        return new BlockInfo(offset, this.length, top, this.height, this.deco || 0);\n    }\n    lineAt(_value, _type, oracle, top, offset) {\n        return this.blockAt(0, oracle, top, offset);\n    }\n    forEachLine(from, to, oracle, top, offset, f) {\n        if (from <= offset + this.length && to >= offset) f(this.blockAt(0, oracle, top, offset));\n    }\n    updateHeight(oracle, offset = 0, _force = false, measured) {\n        if (measured && measured.from <= offset && measured.more) this.setHeight(oracle, measured.heights[measured.index++]);\n        this.outdated = false;\n        return this;\n    }\n    toString() {\n        return `block(${this.length})`;\n    }\n}\nclass HeightMapText extends HeightMapBlock {\n    constructor(length, height){\n        super(length, height, null);\n        this.collapsed = 0; // Amount of collapsed content in the line\n        this.widgetHeight = 0; // Maximum inline widget height\n        this.breaks = 0; // Number of widget-introduced line breaks on the line\n    }\n    blockAt(_height, _oracle, top, offset) {\n        return new BlockInfo(offset, this.length, top, this.height, this.breaks);\n    }\n    replace(_from, _to, nodes) {\n        let node = nodes[0];\n        if (nodes.length == 1 && (node instanceof HeightMapText || node instanceof HeightMapGap && node.flags & 4 /* Flag.SingleLine */ ) && Math.abs(this.length - node.length) < 10) {\n            if (node instanceof HeightMapGap) node = new HeightMapText(node.length, this.height);\n            else node.height = this.height;\n            if (!this.outdated) node.outdated = false;\n            return node;\n        } else {\n            return HeightMap.of(nodes);\n        }\n    }\n    updateHeight(oracle, offset = 0, force = false, measured) {\n        if (measured && measured.from <= offset && measured.more) this.setHeight(oracle, measured.heights[measured.index++]);\n        else if (force || this.outdated) this.setHeight(oracle, Math.max(this.widgetHeight, oracle.heightForLine(this.length - this.collapsed)) + this.breaks * oracle.lineHeight);\n        this.outdated = false;\n        return this;\n    }\n    toString() {\n        return `line(${this.length}${this.collapsed ? -this.collapsed : \"\"}${this.widgetHeight ? \":\" + this.widgetHeight : \"\"})`;\n    }\n}\nclass HeightMapGap extends HeightMap {\n    constructor(length){\n        super(length, 0);\n    }\n    heightMetrics(oracle, offset) {\n        let firstLine = oracle.doc.lineAt(offset).number, lastLine = oracle.doc.lineAt(offset + this.length).number;\n        let lines = lastLine - firstLine + 1;\n        let perLine, perChar = 0;\n        if (oracle.lineWrapping) {\n            let totalPerLine = Math.min(this.height, oracle.lineHeight * lines);\n            perLine = totalPerLine / lines;\n            if (this.length > lines + 1) perChar = (this.height - totalPerLine) / (this.length - lines - 1);\n        } else {\n            perLine = this.height / lines;\n        }\n        return {\n            firstLine,\n            lastLine,\n            perLine,\n            perChar\n        };\n    }\n    blockAt(height, oracle, top, offset) {\n        let { firstLine, lastLine, perLine, perChar } = this.heightMetrics(oracle, offset);\n        if (oracle.lineWrapping) {\n            let guess = offset + Math.round(Math.max(0, Math.min(1, (height - top) / this.height)) * this.length);\n            let line = oracle.doc.lineAt(guess), lineHeight = perLine + line.length * perChar;\n            let lineTop = Math.max(top, height - lineHeight / 2);\n            return new BlockInfo(line.from, line.length, lineTop, lineHeight, 0);\n        } else {\n            let line = Math.max(0, Math.min(lastLine - firstLine, Math.floor((height - top) / perLine)));\n            let { from, length } = oracle.doc.line(firstLine + line);\n            return new BlockInfo(from, length, top + perLine * line, perLine, 0);\n        }\n    }\n    lineAt(value, type, oracle, top, offset) {\n        if (type == QueryType.ByHeight) return this.blockAt(value, oracle, top, offset);\n        if (type == QueryType.ByPosNoHeight) {\n            let { from, to } = oracle.doc.lineAt(value);\n            return new BlockInfo(from, to - from, 0, 0, 0);\n        }\n        let { firstLine, perLine, perChar } = this.heightMetrics(oracle, offset);\n        let line = oracle.doc.lineAt(value), lineHeight = perLine + line.length * perChar;\n        let linesAbove = line.number - firstLine;\n        let lineTop = top + perLine * linesAbove + perChar * (line.from - offset - linesAbove);\n        return new BlockInfo(line.from, line.length, Math.max(top, Math.min(lineTop, top + this.height - lineHeight)), lineHeight, 0);\n    }\n    forEachLine(from, to, oracle, top, offset, f) {\n        from = Math.max(from, offset);\n        to = Math.min(to, offset + this.length);\n        let { firstLine, perLine, perChar } = this.heightMetrics(oracle, offset);\n        for(let pos = from, lineTop = top; pos <= to;){\n            let line = oracle.doc.lineAt(pos);\n            if (pos == from) {\n                let linesAbove = line.number - firstLine;\n                lineTop += perLine * linesAbove + perChar * (from - offset - linesAbove);\n            }\n            let lineHeight = perLine + perChar * line.length;\n            f(new BlockInfo(line.from, line.length, lineTop, lineHeight, 0));\n            lineTop += lineHeight;\n            pos = line.to + 1;\n        }\n    }\n    replace(from, to, nodes) {\n        let after = this.length - to;\n        if (after > 0) {\n            let last = nodes[nodes.length - 1];\n            if (last instanceof HeightMapGap) nodes[nodes.length - 1] = new HeightMapGap(last.length + after);\n            else nodes.push(null, new HeightMapGap(after - 1));\n        }\n        if (from > 0) {\n            let first = nodes[0];\n            if (first instanceof HeightMapGap) nodes[0] = new HeightMapGap(from + first.length);\n            else nodes.unshift(new HeightMapGap(from - 1), null);\n        }\n        return HeightMap.of(nodes);\n    }\n    decomposeLeft(to, result) {\n        result.push(new HeightMapGap(to - 1), null);\n    }\n    decomposeRight(from, result) {\n        result.push(null, new HeightMapGap(this.length - from - 1));\n    }\n    updateHeight(oracle, offset = 0, force = false, measured) {\n        let end = offset + this.length;\n        if (measured && measured.from <= offset + this.length && measured.more) {\n            // Fill in part of this gap with measured lines. We know there\n            // can't be widgets or collapsed ranges in those lines, because\n            // they would already have been added to the heightmap (gaps\n            // only contain plain text).\n            let nodes = [], pos = Math.max(offset, measured.from), singleHeight = -1;\n            if (measured.from > offset) nodes.push(new HeightMapGap(measured.from - offset - 1).updateHeight(oracle, offset));\n            while(pos <= end && measured.more){\n                let len = oracle.doc.lineAt(pos).length;\n                if (nodes.length) nodes.push(null);\n                let height = measured.heights[measured.index++];\n                if (singleHeight == -1) singleHeight = height;\n                else if (Math.abs(height - singleHeight) >= Epsilon) singleHeight = -2;\n                let line = new HeightMapText(len, height);\n                line.outdated = false;\n                nodes.push(line);\n                pos += len + 1;\n            }\n            if (pos <= end) nodes.push(null, new HeightMapGap(end - pos).updateHeight(oracle, pos));\n            let result = HeightMap.of(nodes);\n            if (singleHeight < 0 || Math.abs(result.height - this.height) >= Epsilon || Math.abs(singleHeight - this.heightMetrics(oracle, offset).perLine) >= Epsilon) oracle.heightChanged = true;\n            return result;\n        } else if (force || this.outdated) {\n            this.setHeight(oracle, oracle.heightForGap(offset, offset + this.length));\n            this.outdated = false;\n        }\n        return this;\n    }\n    toString() {\n        return `gap(${this.length})`;\n    }\n}\nclass HeightMapBranch extends HeightMap {\n    constructor(left, brk, right){\n        super(left.length + brk + right.length, left.height + right.height, brk | (left.outdated || right.outdated ? 2 /* Flag.Outdated */  : 0));\n        this.left = left;\n        this.right = right;\n        this.size = left.size + right.size;\n    }\n    get break() {\n        return this.flags & 1 /* Flag.Break */ ;\n    }\n    blockAt(height, oracle, top, offset) {\n        let mid = top + this.left.height;\n        return height < mid ? this.left.blockAt(height, oracle, top, offset) : this.right.blockAt(height, oracle, mid, offset + this.left.length + this.break);\n    }\n    lineAt(value, type, oracle, top, offset) {\n        let rightTop = top + this.left.height, rightOffset = offset + this.left.length + this.break;\n        let left = type == QueryType.ByHeight ? value < rightTop : value < rightOffset;\n        let base = left ? this.left.lineAt(value, type, oracle, top, offset) : this.right.lineAt(value, type, oracle, rightTop, rightOffset);\n        if (this.break || (left ? base.to < rightOffset : base.from > rightOffset)) return base;\n        let subQuery = type == QueryType.ByPosNoHeight ? QueryType.ByPosNoHeight : QueryType.ByPos;\n        if (left) return base.join(this.right.lineAt(rightOffset, subQuery, oracle, rightTop, rightOffset));\n        else return this.left.lineAt(rightOffset, subQuery, oracle, top, offset).join(base);\n    }\n    forEachLine(from, to, oracle, top, offset, f) {\n        let rightTop = top + this.left.height, rightOffset = offset + this.left.length + this.break;\n        if (this.break) {\n            if (from < rightOffset) this.left.forEachLine(from, to, oracle, top, offset, f);\n            if (to >= rightOffset) this.right.forEachLine(from, to, oracle, rightTop, rightOffset, f);\n        } else {\n            let mid = this.lineAt(rightOffset, QueryType.ByPos, oracle, top, offset);\n            if (from < mid.from) this.left.forEachLine(from, mid.from - 1, oracle, top, offset, f);\n            if (mid.to >= from && mid.from <= to) f(mid);\n            if (to > mid.to) this.right.forEachLine(mid.to + 1, to, oracle, rightTop, rightOffset, f);\n        }\n    }\n    replace(from, to, nodes) {\n        let rightStart = this.left.length + this.break;\n        if (to < rightStart) return this.balanced(this.left.replace(from, to, nodes), this.right);\n        if (from > this.left.length) return this.balanced(this.left, this.right.replace(from - rightStart, to - rightStart, nodes));\n        let result = [];\n        if (from > 0) this.decomposeLeft(from, result);\n        let left = result.length;\n        for (let node of nodes)result.push(node);\n        if (from > 0) mergeGaps(result, left - 1);\n        if (to < this.length) {\n            let right = result.length;\n            this.decomposeRight(to, result);\n            mergeGaps(result, right);\n        }\n        return HeightMap.of(result);\n    }\n    decomposeLeft(to, result) {\n        let left = this.left.length;\n        if (to <= left) return this.left.decomposeLeft(to, result);\n        result.push(this.left);\n        if (this.break) {\n            left++;\n            if (to >= left) result.push(null);\n        }\n        if (to > left) this.right.decomposeLeft(to - left, result);\n    }\n    decomposeRight(from, result) {\n        let left = this.left.length, right = left + this.break;\n        if (from >= right) return this.right.decomposeRight(from - right, result);\n        if (from < left) this.left.decomposeRight(from, result);\n        if (this.break && from < right) result.push(null);\n        result.push(this.right);\n    }\n    balanced(left, right) {\n        if (left.size > 2 * right.size || right.size > 2 * left.size) return HeightMap.of(this.break ? [\n            left,\n            null,\n            right\n        ] : [\n            left,\n            right\n        ]);\n        this.left = left;\n        this.right = right;\n        this.height = left.height + right.height;\n        this.outdated = left.outdated || right.outdated;\n        this.size = left.size + right.size;\n        this.length = left.length + this.break + right.length;\n        return this;\n    }\n    updateHeight(oracle, offset = 0, force = false, measured) {\n        let { left, right } = this, rightStart = offset + left.length + this.break, rebalance = null;\n        if (measured && measured.from <= offset + left.length && measured.more) rebalance = left = left.updateHeight(oracle, offset, force, measured);\n        else left.updateHeight(oracle, offset, force);\n        if (measured && measured.from <= rightStart + right.length && measured.more) rebalance = right = right.updateHeight(oracle, rightStart, force, measured);\n        else right.updateHeight(oracle, rightStart, force);\n        if (rebalance) return this.balanced(left, right);\n        this.height = this.left.height + this.right.height;\n        this.outdated = false;\n        return this;\n    }\n    toString() {\n        return this.left + (this.break ? \" \" : \"-\") + this.right;\n    }\n}\nfunction mergeGaps(nodes, around) {\n    let before, after;\n    if (nodes[around] == null && (before = nodes[around - 1]) instanceof HeightMapGap && (after = nodes[around + 1]) instanceof HeightMapGap) nodes.splice(around - 1, 3, new HeightMapGap(before.length + 1 + after.length));\n}\nconst relevantWidgetHeight = 5;\nclass NodeBuilder {\n    constructor(pos, oracle){\n        this.pos = pos;\n        this.oracle = oracle;\n        this.nodes = [];\n        this.lineStart = -1;\n        this.lineEnd = -1;\n        this.covering = null;\n        this.writtenTo = pos;\n    }\n    get isCovered() {\n        return this.covering && this.nodes[this.nodes.length - 1] == this.covering;\n    }\n    span(_from, to) {\n        if (this.lineStart > -1) {\n            let end = Math.min(to, this.lineEnd), last = this.nodes[this.nodes.length - 1];\n            if (last instanceof HeightMapText) last.length += end - this.pos;\n            else if (end > this.pos || !this.isCovered) this.nodes.push(new HeightMapText(end - this.pos, -1));\n            this.writtenTo = end;\n            if (to > end) {\n                this.nodes.push(null);\n                this.writtenTo++;\n                this.lineStart = -1;\n            }\n        }\n        this.pos = to;\n    }\n    point(from, to, deco) {\n        if (from < to || deco.heightRelevant) {\n            let height = deco.widget ? deco.widget.estimatedHeight : 0;\n            let breaks = deco.widget ? deco.widget.lineBreaks : 0;\n            if (height < 0) height = this.oracle.lineHeight;\n            let len = to - from;\n            if (deco.block) {\n                this.addBlock(new HeightMapBlock(len, height, deco));\n            } else if (len || breaks || height >= relevantWidgetHeight) {\n                this.addLineDeco(height, breaks, len);\n            }\n        } else if (to > from) {\n            this.span(from, to);\n        }\n        if (this.lineEnd > -1 && this.lineEnd < this.pos) this.lineEnd = this.oracle.doc.lineAt(this.pos).to;\n    }\n    enterLine() {\n        if (this.lineStart > -1) return;\n        let { from, to } = this.oracle.doc.lineAt(this.pos);\n        this.lineStart = from;\n        this.lineEnd = to;\n        if (this.writtenTo < from) {\n            if (this.writtenTo < from - 1 || this.nodes[this.nodes.length - 1] == null) this.nodes.push(this.blankContent(this.writtenTo, from - 1));\n            this.nodes.push(null);\n        }\n        if (this.pos > from) this.nodes.push(new HeightMapText(this.pos - from, -1));\n        this.writtenTo = this.pos;\n    }\n    blankContent(from, to) {\n        let gap = new HeightMapGap(to - from);\n        if (this.oracle.doc.lineAt(from).to == to) gap.flags |= 4 /* Flag.SingleLine */ ;\n        return gap;\n    }\n    ensureLine() {\n        this.enterLine();\n        let last = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;\n        if (last instanceof HeightMapText) return last;\n        let line = new HeightMapText(0, -1);\n        this.nodes.push(line);\n        return line;\n    }\n    addBlock(block) {\n        this.enterLine();\n        let deco = block.deco;\n        if (deco && deco.startSide > 0 && !this.isCovered) this.ensureLine();\n        this.nodes.push(block);\n        this.writtenTo = this.pos = this.pos + block.length;\n        if (deco && deco.endSide > 0) this.covering = block;\n    }\n    addLineDeco(height, breaks, length) {\n        let line = this.ensureLine();\n        line.length += length;\n        line.collapsed += length;\n        line.widgetHeight = Math.max(line.widgetHeight, height);\n        line.breaks += breaks;\n        this.writtenTo = this.pos = this.pos + length;\n    }\n    finish(from) {\n        let last = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];\n        if (this.lineStart > -1 && !(last instanceof HeightMapText) && !this.isCovered) this.nodes.push(new HeightMapText(0, -1));\n        else if (this.writtenTo < this.pos || last == null) this.nodes.push(this.blankContent(this.writtenTo, this.pos));\n        let pos = from;\n        for (let node of this.nodes){\n            if (node instanceof HeightMapText) node.updateHeight(this.oracle, pos);\n            pos += node ? node.length : 1;\n        }\n        return this.nodes;\n    }\n    // Always called with a region that on both sides either stretches\n    // to a line break or the end of the document.\n    // The returned array uses null to indicate line breaks, but never\n    // starts or ends in a line break, or has multiple line breaks next\n    // to each other.\n    static build(oracle, decorations, from, to) {\n        let builder = new NodeBuilder(from, oracle);\n        _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.spans(decorations, from, to, builder, 0);\n        return builder.finish(from);\n    }\n}\nfunction heightRelevantDecoChanges(a, b, diff) {\n    let comp = new DecorationComparator;\n    _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.compare(a, b, diff, comp, 0);\n    return comp.changes;\n}\nclass DecorationComparator {\n    constructor(){\n        this.changes = [];\n    }\n    compareRange() {}\n    comparePoint(from, to, a, b) {\n        if (from < to || a && a.heightRelevant || b && b.heightRelevant) addRange(from, to, this.changes, 5);\n    }\n}\nfunction visiblePixelRange(dom, paddingTop) {\n    let rect = dom.getBoundingClientRect();\n    let doc = dom.ownerDocument, win = doc.defaultView || window;\n    let left = Math.max(0, rect.left), right = Math.min(win.innerWidth, rect.right);\n    let top = Math.max(0, rect.top), bottom = Math.min(win.innerHeight, rect.bottom);\n    for(let parent = dom.parentNode; parent && parent != doc.body;){\n        if (parent.nodeType == 1) {\n            let elt = parent;\n            let style = window.getComputedStyle(elt);\n            if ((elt.scrollHeight > elt.clientHeight || elt.scrollWidth > elt.clientWidth) && style.overflow != \"visible\") {\n                let parentRect = elt.getBoundingClientRect();\n                left = Math.max(left, parentRect.left);\n                right = Math.min(right, parentRect.right);\n                top = Math.max(top, parentRect.top);\n                bottom = parent == dom.parentNode ? parentRect.bottom : Math.min(bottom, parentRect.bottom);\n            }\n            parent = style.position == \"absolute\" || style.position == \"fixed\" ? elt.offsetParent : elt.parentNode;\n        } else if (parent.nodeType == 11) {\n            parent = parent.host;\n        } else {\n            break;\n        }\n    }\n    return {\n        left: left - rect.left,\n        right: Math.max(left, right) - rect.left,\n        top: top - (rect.top + paddingTop),\n        bottom: Math.max(top, bottom) - (rect.top + paddingTop)\n    };\n}\nfunction fullPixelRange(dom, paddingTop) {\n    let rect = dom.getBoundingClientRect();\n    return {\n        left: 0,\n        right: rect.right - rect.left,\n        top: paddingTop,\n        bottom: rect.bottom - (rect.top + paddingTop)\n    };\n}\n// Line gaps are placeholder widgets used to hide pieces of overlong\n// lines within the viewport, as a kludge to keep the editor\n// responsive when a ridiculously long line is loaded into it.\nclass LineGap {\n    constructor(from, to, size){\n        this.from = from;\n        this.to = to;\n        this.size = size;\n    }\n    static same(a, b) {\n        if (a.length != b.length) return false;\n        for(let i = 0; i < a.length; i++){\n            let gA = a[i], gB = b[i];\n            if (gA.from != gB.from || gA.to != gB.to || gA.size != gB.size) return false;\n        }\n        return true;\n    }\n    draw(viewState, wrapping) {\n        return Decoration.replace({\n            widget: new LineGapWidget(this.size * (wrapping ? viewState.scaleY : viewState.scaleX), wrapping)\n        }).range(this.from, this.to);\n    }\n}\nclass LineGapWidget extends WidgetType {\n    constructor(size, vertical){\n        super();\n        this.size = size;\n        this.vertical = vertical;\n    }\n    eq(other) {\n        return other.size == this.size && other.vertical == this.vertical;\n    }\n    toDOM() {\n        let elt = document.createElement(\"div\");\n        if (this.vertical) {\n            elt.style.height = this.size + \"px\";\n        } else {\n            elt.style.width = this.size + \"px\";\n            elt.style.height = \"2px\";\n            elt.style.display = \"inline-block\";\n        }\n        return elt;\n    }\n    get estimatedHeight() {\n        return this.vertical ? this.size : -1;\n    }\n}\nclass ViewState {\n    constructor(state){\n        this.state = state;\n        // These are contentDOM-local coordinates\n        this.pixelViewport = {\n            left: 0,\n            right: window.innerWidth,\n            top: 0,\n            bottom: 0\n        };\n        this.inView = true;\n        this.paddingTop = 0; // Padding above the document, scaled\n        this.paddingBottom = 0; // Padding below the document, scaled\n        this.contentDOMWidth = 0; // contentDOM.getBoundingClientRect().width\n        this.contentDOMHeight = 0; // contentDOM.getBoundingClientRect().height\n        this.editorHeight = 0; // scrollDOM.clientHeight, unscaled\n        this.editorWidth = 0; // scrollDOM.clientWidth, unscaled\n        this.scrollTop = 0; // Last seen scrollDOM.scrollTop, scaled\n        this.scrolledToBottom = true;\n        // The CSS-transformation scale of the editor (transformed size /\n        // concrete size)\n        this.scaleX = 1;\n        this.scaleY = 1;\n        // The vertical position (document-relative) to which to anchor the\n        // scroll position. -1 means anchor to the end of the document.\n        this.scrollAnchorPos = 0;\n        // The height at the anchor position. Set by the DOM update phase.\n        // -1 means no height available.\n        this.scrollAnchorHeight = -1;\n        // See VP.MaxDOMHeight\n        this.scaler = IdScaler;\n        this.scrollTarget = null;\n        // Briefly set to true when printing, to disable viewport limiting\n        this.printing = false;\n        // Flag set when editor content was redrawn, so that the next\n        // measure stage knows it must read DOM layout\n        this.mustMeasureContent = true;\n        this.defaultTextDirection = Direction.LTR;\n        this.visibleRanges = [];\n        // Cursor 'assoc' is only significant when the cursor is on a line\n        // wrap point, where it must stick to the character that it is\n        // associated with. Since browsers don't provide a reasonable\n        // interface to set or query this, when a selection is set that\n        // might cause this to be significant, this flag is set. The next\n        // measure phase will check whether the cursor is on a line-wrapping\n        // boundary and, if so, reset it to make sure it is positioned in\n        // the right place.\n        this.mustEnforceCursorAssoc = false;\n        let guessWrapping = state.facet(contentAttributes).some((v)=>typeof v != \"function\" && v.class == \"cm-lineWrapping\");\n        this.heightOracle = new HeightOracle(guessWrapping);\n        this.stateDeco = state.facet(decorations).filter((d)=>typeof d != \"function\");\n        this.heightMap = HeightMap.empty().applyChanges(this.stateDeco, _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Text.empty, this.heightOracle.setDoc(state.doc), [\n            new ChangedRange(0, 0, 0, state.doc.length)\n        ]);\n        this.viewport = this.getViewport(0, null);\n        this.updateViewportLines();\n        this.updateForViewport();\n        this.lineGaps = this.ensureLineGaps([]);\n        this.lineGapDeco = Decoration.set(this.lineGaps.map((gap)=>gap.draw(this, false)));\n        this.computeVisibleRanges();\n    }\n    updateForViewport() {\n        let viewports = [\n            this.viewport\n        ], { main } = this.state.selection;\n        for(let i = 0; i <= 1; i++){\n            let pos = i ? main.head : main.anchor;\n            if (!viewports.some(({ from, to })=>pos >= from && pos <= to)) {\n                let { from, to } = this.lineBlockAt(pos);\n                viewports.push(new Viewport(from, to));\n            }\n        }\n        this.viewports = viewports.sort((a, b)=>a.from - b.from);\n        this.scaler = this.heightMap.height <= 7000000 /* VP.MaxDOMHeight */  ? IdScaler : new BigScaler(this.heightOracle, this.heightMap, this.viewports);\n    }\n    updateViewportLines() {\n        this.viewportLines = [];\n        this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (block)=>{\n            this.viewportLines.push(this.scaler.scale == 1 ? block : scaleBlock(block, this.scaler));\n        });\n    }\n    update(update, scrollTarget = null) {\n        this.state = update.state;\n        let prevDeco = this.stateDeco;\n        this.stateDeco = this.state.facet(decorations).filter((d)=>typeof d != \"function\");\n        let contentChanges = update.changedRanges;\n        let heightChanges = ChangedRange.extendWithRanges(contentChanges, heightRelevantDecoChanges(prevDeco, this.stateDeco, update ? update.changes : _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.ChangeSet.empty(this.state.doc.length)));\n        let prevHeight = this.heightMap.height;\n        let scrollAnchor = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);\n        this.heightMap = this.heightMap.applyChanges(this.stateDeco, update.startState.doc, this.heightOracle.setDoc(this.state.doc), heightChanges);\n        if (this.heightMap.height != prevHeight) update.flags |= 2 /* UpdateFlag.Height */ ;\n        if (scrollAnchor) {\n            this.scrollAnchorPos = update.changes.mapPos(scrollAnchor.from, -1);\n            this.scrollAnchorHeight = scrollAnchor.top;\n        } else {\n            this.scrollAnchorPos = -1;\n            this.scrollAnchorHeight = this.heightMap.height;\n        }\n        let viewport = heightChanges.length ? this.mapViewport(this.viewport, update.changes) : this.viewport;\n        if (scrollTarget && (scrollTarget.range.head < viewport.from || scrollTarget.range.head > viewport.to) || !this.viewportIsAppropriate(viewport)) viewport = this.getViewport(0, scrollTarget);\n        let updateLines = !update.changes.empty || update.flags & 2 /* UpdateFlag.Height */  || viewport.from != this.viewport.from || viewport.to != this.viewport.to;\n        this.viewport = viewport;\n        this.updateForViewport();\n        if (updateLines) this.updateViewportLines();\n        if (this.lineGaps.length || this.viewport.to - this.viewport.from > 2000 /* LG.Margin */  << 1) this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, update.changes)));\n        update.flags |= this.computeVisibleRanges();\n        if (scrollTarget) this.scrollTarget = scrollTarget;\n        if (!this.mustEnforceCursorAssoc && update.selectionSet && update.view.lineWrapping && update.state.selection.main.empty && update.state.selection.main.assoc && !update.state.facet(nativeSelectionHidden)) this.mustEnforceCursorAssoc = true;\n    }\n    measure(view) {\n        let dom = view.contentDOM, style = window.getComputedStyle(dom);\n        let oracle = this.heightOracle;\n        let whiteSpace = style.whiteSpace;\n        this.defaultTextDirection = style.direction == \"rtl\" ? Direction.RTL : Direction.LTR;\n        let refresh = this.heightOracle.mustRefreshForWrapping(whiteSpace);\n        let domRect = dom.getBoundingClientRect();\n        let measureContent = refresh || this.mustMeasureContent || this.contentDOMHeight != domRect.height;\n        this.contentDOMHeight = domRect.height;\n        this.mustMeasureContent = false;\n        let result = 0, bias = 0;\n        if (domRect.width && domRect.height) {\n            let { scaleX, scaleY } = getScale(dom, domRect);\n            if (this.scaleX != scaleX || this.scaleY != scaleY) {\n                this.scaleX = scaleX;\n                this.scaleY = scaleY;\n                result |= 8 /* UpdateFlag.Geometry */ ;\n                refresh = measureContent = true;\n            }\n        }\n        // Vertical padding\n        let paddingTop = (parseInt(style.paddingTop) || 0) * this.scaleY;\n        let paddingBottom = (parseInt(style.paddingBottom) || 0) * this.scaleY;\n        if (this.paddingTop != paddingTop || this.paddingBottom != paddingBottom) {\n            this.paddingTop = paddingTop;\n            this.paddingBottom = paddingBottom;\n            result |= 8 /* UpdateFlag.Geometry */  | 2 /* UpdateFlag.Height */ ;\n        }\n        if (this.editorWidth != view.scrollDOM.clientWidth) {\n            if (oracle.lineWrapping) measureContent = true;\n            this.editorWidth = view.scrollDOM.clientWidth;\n            result |= 8 /* UpdateFlag.Geometry */ ;\n        }\n        let scrollTop = view.scrollDOM.scrollTop * this.scaleY;\n        if (this.scrollTop != scrollTop) {\n            this.scrollAnchorHeight = -1;\n            this.scrollTop = scrollTop;\n        }\n        this.scrolledToBottom = isScrolledToBottom(view.scrollDOM);\n        // Pixel viewport\n        let pixelViewport = (this.printing ? fullPixelRange : visiblePixelRange)(dom, this.paddingTop);\n        let dTop = pixelViewport.top - this.pixelViewport.top, dBottom = pixelViewport.bottom - this.pixelViewport.bottom;\n        this.pixelViewport = pixelViewport;\n        let inView = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;\n        if (inView != this.inView) {\n            this.inView = inView;\n            if (inView) measureContent = true;\n        }\n        if (!this.inView && !this.scrollTarget) return 0;\n        let contentWidth = domRect.width;\n        if (this.contentDOMWidth != contentWidth || this.editorHeight != view.scrollDOM.clientHeight) {\n            this.contentDOMWidth = domRect.width;\n            this.editorHeight = view.scrollDOM.clientHeight;\n            result |= 8 /* UpdateFlag.Geometry */ ;\n        }\n        if (measureContent) {\n            let lineHeights = view.docView.measureVisibleLineHeights(this.viewport);\n            if (oracle.mustRefreshForHeights(lineHeights)) refresh = true;\n            if (refresh || oracle.lineWrapping && Math.abs(contentWidth - this.contentDOMWidth) > oracle.charWidth) {\n                let { lineHeight, charWidth, textHeight } = view.docView.measureTextSize();\n                refresh = lineHeight > 0 && oracle.refresh(whiteSpace, lineHeight, charWidth, textHeight, contentWidth / charWidth, lineHeights);\n                if (refresh) {\n                    view.docView.minWidth = 0;\n                    result |= 8 /* UpdateFlag.Geometry */ ;\n                }\n            }\n            if (dTop > 0 && dBottom > 0) bias = Math.max(dTop, dBottom);\n            else if (dTop < 0 && dBottom < 0) bias = Math.min(dTop, dBottom);\n            oracle.heightChanged = false;\n            for (let vp of this.viewports){\n                let heights = vp.from == this.viewport.from ? lineHeights : view.docView.measureVisibleLineHeights(vp);\n                this.heightMap = (refresh ? HeightMap.empty().applyChanges(this.stateDeco, _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Text.empty, this.heightOracle, [\n                    new ChangedRange(0, 0, 0, view.state.doc.length)\n                ]) : this.heightMap).updateHeight(oracle, 0, refresh, new MeasuredHeights(vp.from, heights));\n            }\n            if (oracle.heightChanged) result |= 2 /* UpdateFlag.Height */ ;\n        }\n        let viewportChange = !this.viewportIsAppropriate(this.viewport, bias) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);\n        if (viewportChange) this.viewport = this.getViewport(bias, this.scrollTarget);\n        this.updateForViewport();\n        if (result & 2 /* UpdateFlag.Height */  || viewportChange) this.updateViewportLines();\n        if (this.lineGaps.length || this.viewport.to - this.viewport.from > 2000 /* LG.Margin */  << 1) this.updateLineGaps(this.ensureLineGaps(refresh ? [] : this.lineGaps, view));\n        result |= this.computeVisibleRanges();\n        if (this.mustEnforceCursorAssoc) {\n            this.mustEnforceCursorAssoc = false;\n            // This is done in the read stage, because moving the selection\n            // to a line end is going to trigger a layout anyway, so it\n            // can't be a pure write. It should be rare that it does any\n            // writing.\n            view.docView.enforceCursorAssoc();\n        }\n        return result;\n    }\n    get visibleTop() {\n        return this.scaler.fromDOM(this.pixelViewport.top);\n    }\n    get visibleBottom() {\n        return this.scaler.fromDOM(this.pixelViewport.bottom);\n    }\n    getViewport(bias, scrollTarget) {\n        // This will divide VP.Margin between the top and the\n        // bottom, depending on the bias (the change in viewport position\n        // since the last update). It'll hold a number between 0 and 1\n        let marginTop = 0.5 - Math.max(-0.5, Math.min(0.5, bias / 1000 /* VP.Margin */  / 2));\n        let map = this.heightMap, oracle = this.heightOracle;\n        let { visibleTop, visibleBottom } = this;\n        let viewport = new Viewport(map.lineAt(visibleTop - marginTop * 1000 /* VP.Margin */ , QueryType.ByHeight, oracle, 0, 0).from, map.lineAt(visibleBottom + (1 - marginTop) * 1000 /* VP.Margin */ , QueryType.ByHeight, oracle, 0, 0).to);\n        // If scrollTarget is given, make sure the viewport includes that position\n        if (scrollTarget) {\n            let { head } = scrollTarget.range;\n            if (head < viewport.from || head > viewport.to) {\n                let viewHeight = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top);\n                let block = map.lineAt(head, QueryType.ByPos, oracle, 0, 0), topPos;\n                if (scrollTarget.y == \"center\") topPos = (block.top + block.bottom) / 2 - viewHeight / 2;\n                else if (scrollTarget.y == \"start\" || scrollTarget.y == \"nearest\" && head < viewport.from) topPos = block.top;\n                else topPos = block.bottom - viewHeight;\n                viewport = new Viewport(map.lineAt(topPos - 1000 /* VP.Margin */  / 2, QueryType.ByHeight, oracle, 0, 0).from, map.lineAt(topPos + viewHeight + 1000 /* VP.Margin */  / 2, QueryType.ByHeight, oracle, 0, 0).to);\n            }\n        }\n        return viewport;\n    }\n    mapViewport(viewport, changes) {\n        let from = changes.mapPos(viewport.from, -1), to = changes.mapPos(viewport.to, 1);\n        return new Viewport(this.heightMap.lineAt(from, QueryType.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(to, QueryType.ByPos, this.heightOracle, 0, 0).to);\n    }\n    // Checks if a given viewport covers the visible part of the\n    // document and not too much beyond that.\n    viewportIsAppropriate({ from, to }, bias = 0) {\n        if (!this.inView) return true;\n        let { top } = this.heightMap.lineAt(from, QueryType.ByPos, this.heightOracle, 0, 0);\n        let { bottom } = this.heightMap.lineAt(to, QueryType.ByPos, this.heightOracle, 0, 0);\n        let { visibleTop, visibleBottom } = this;\n        return (from == 0 || top <= visibleTop - Math.max(10 /* VP.MinCoverMargin */ , Math.min(-bias, 250 /* VP.MaxCoverMargin */ ))) && (to == this.state.doc.length || bottom >= visibleBottom + Math.max(10 /* VP.MinCoverMargin */ , Math.min(bias, 250 /* VP.MaxCoverMargin */ ))) && top > visibleTop - 2 * 1000 /* VP.Margin */  && bottom < visibleBottom + 2 * 1000 /* VP.Margin */ ;\n    }\n    mapLineGaps(gaps, changes) {\n        if (!gaps.length || changes.empty) return gaps;\n        let mapped = [];\n        for (let gap of gaps)if (!changes.touchesRange(gap.from, gap.to)) mapped.push(new LineGap(changes.mapPos(gap.from), changes.mapPos(gap.to), gap.size));\n        return mapped;\n    }\n    // Computes positions in the viewport where the start or end of a\n    // line should be hidden, trying to reuse existing line gaps when\n    // appropriate to avoid unneccesary redraws.\n    // Uses crude character-counting for the positioning and sizing,\n    // since actual DOM coordinates aren't always available and\n    // predictable. Relies on generous margins (see LG.Margin) to hide\n    // the artifacts this might produce from the user.\n    ensureLineGaps(current, mayMeasure) {\n        let wrapping = this.heightOracle.lineWrapping;\n        let margin = wrapping ? 10000 /* LG.MarginWrap */  : 2000 /* LG.Margin */ , halfMargin = margin >> 1, doubleMargin = margin << 1;\n        // The non-wrapping logic won't work at all in predominantly right-to-left text.\n        if (this.defaultTextDirection != Direction.LTR && !wrapping) return [];\n        let gaps = [];\n        let addGap = (from, to, line, structure)=>{\n            if (to - from < halfMargin) return;\n            let sel = this.state.selection.main, avoid = [\n                sel.from\n            ];\n            if (!sel.empty) avoid.push(sel.to);\n            for (let pos of avoid){\n                if (pos > from && pos < to) {\n                    addGap(from, pos - 10 /* LG.SelectionMargin */ , line, structure);\n                    addGap(pos + 10 /* LG.SelectionMargin */ , to, line, structure);\n                    return;\n                }\n            }\n            let gap = find(current, (gap)=>gap.from >= line.from && gap.to <= line.to && Math.abs(gap.from - from) < halfMargin && Math.abs(gap.to - to) < halfMargin && !avoid.some((pos)=>gap.from < pos && gap.to > pos));\n            if (!gap) {\n                // When scrolling down, snap gap ends to line starts to avoid shifts in wrapping\n                if (to < line.to && mayMeasure && wrapping && mayMeasure.visibleRanges.some((r)=>r.from <= to && r.to >= to)) {\n                    let lineStart = mayMeasure.moveToLineBoundary(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(to), false, true).head;\n                    if (lineStart > from) to = lineStart;\n                }\n                gap = new LineGap(from, to, this.gapSize(line, from, to, structure));\n            }\n            gaps.push(gap);\n        };\n        for (let line of this.viewportLines){\n            if (line.length < doubleMargin) continue;\n            let structure = lineStructure(line.from, line.to, this.stateDeco);\n            if (structure.total < doubleMargin) continue;\n            let target = this.scrollTarget ? this.scrollTarget.range.head : null;\n            let viewFrom, viewTo;\n            if (wrapping) {\n                let marginHeight = margin / this.heightOracle.lineLength * this.heightOracle.lineHeight;\n                let top, bot;\n                if (target != null) {\n                    let targetFrac = findFraction(structure, target);\n                    let spaceFrac = ((this.visibleBottom - this.visibleTop) / 2 + marginHeight) / line.height;\n                    top = targetFrac - spaceFrac;\n                    bot = targetFrac + spaceFrac;\n                } else {\n                    top = (this.visibleTop - line.top - marginHeight) / line.height;\n                    bot = (this.visibleBottom - line.top + marginHeight) / line.height;\n                }\n                viewFrom = findPosition(structure, top);\n                viewTo = findPosition(structure, bot);\n            } else {\n                let totalWidth = structure.total * this.heightOracle.charWidth;\n                let marginWidth = margin * this.heightOracle.charWidth;\n                let left, right;\n                if (target != null) {\n                    let targetFrac = findFraction(structure, target);\n                    let spaceFrac = ((this.pixelViewport.right - this.pixelViewport.left) / 2 + marginWidth) / totalWidth;\n                    left = targetFrac - spaceFrac;\n                    right = targetFrac + spaceFrac;\n                } else {\n                    left = (this.pixelViewport.left - marginWidth) / totalWidth;\n                    right = (this.pixelViewport.right + marginWidth) / totalWidth;\n                }\n                viewFrom = findPosition(structure, left);\n                viewTo = findPosition(structure, right);\n            }\n            if (viewFrom > line.from) addGap(line.from, viewFrom, line, structure);\n            if (viewTo < line.to) addGap(viewTo, line.to, line, structure);\n        }\n        return gaps;\n    }\n    gapSize(line, from, to, structure) {\n        let fraction = findFraction(structure, to) - findFraction(structure, from);\n        if (this.heightOracle.lineWrapping) {\n            return line.height * fraction;\n        } else {\n            return structure.total * this.heightOracle.charWidth * fraction;\n        }\n    }\n    updateLineGaps(gaps) {\n        if (!LineGap.same(gaps, this.lineGaps)) {\n            this.lineGaps = gaps;\n            this.lineGapDeco = Decoration.set(gaps.map((gap)=>gap.draw(this, this.heightOracle.lineWrapping)));\n        }\n    }\n    computeVisibleRanges() {\n        let deco = this.stateDeco;\n        if (this.lineGaps.length) deco = deco.concat(this.lineGapDeco);\n        let ranges = [];\n        _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.spans(deco, this.viewport.from, this.viewport.to, {\n            span (from, to) {\n                ranges.push({\n                    from,\n                    to\n                });\n            },\n            point () {}\n        }, 20);\n        let changed = ranges.length != this.visibleRanges.length || this.visibleRanges.some((r, i)=>r.from != ranges[i].from || r.to != ranges[i].to);\n        this.visibleRanges = ranges;\n        return changed ? 4 /* UpdateFlag.Viewport */  : 0;\n    }\n    lineBlockAt(pos) {\n        return pos >= this.viewport.from && pos <= this.viewport.to && this.viewportLines.find((b)=>b.from <= pos && b.to >= pos) || scaleBlock(this.heightMap.lineAt(pos, QueryType.ByPos, this.heightOracle, 0, 0), this.scaler);\n    }\n    lineBlockAtHeight(height) {\n        return scaleBlock(this.heightMap.lineAt(this.scaler.fromDOM(height), QueryType.ByHeight, this.heightOracle, 0, 0), this.scaler);\n    }\n    scrollAnchorAt(scrollTop) {\n        let block = this.lineBlockAtHeight(scrollTop + 8);\n        return block.from >= this.viewport.from || this.viewportLines[0].top - scrollTop > 200 ? block : this.viewportLines[0];\n    }\n    elementAtHeight(height) {\n        return scaleBlock(this.heightMap.blockAt(this.scaler.fromDOM(height), this.heightOracle, 0, 0), this.scaler);\n    }\n    get docHeight() {\n        return this.scaler.toDOM(this.heightMap.height);\n    }\n    get contentHeight() {\n        return this.docHeight + this.paddingTop + this.paddingBottom;\n    }\n}\nclass Viewport {\n    constructor(from, to){\n        this.from = from;\n        this.to = to;\n    }\n}\nfunction lineStructure(from, to, stateDeco) {\n    let ranges = [], pos = from, total = 0;\n    _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.spans(stateDeco, from, to, {\n        span () {},\n        point (from, to) {\n            if (from > pos) {\n                ranges.push({\n                    from: pos,\n                    to: from\n                });\n                total += from - pos;\n            }\n            pos = to;\n        }\n    }, 20); // We're only interested in collapsed ranges of a significant size\n    if (pos < to) {\n        ranges.push({\n            from: pos,\n            to\n        });\n        total += to - pos;\n    }\n    return {\n        total,\n        ranges\n    };\n}\nfunction findPosition({ total, ranges }, ratio) {\n    if (ratio <= 0) return ranges[0].from;\n    if (ratio >= 1) return ranges[ranges.length - 1].to;\n    let dist = Math.floor(total * ratio);\n    for(let i = 0;; i++){\n        let { from, to } = ranges[i], size = to - from;\n        if (dist <= size) return from + dist;\n        dist -= size;\n    }\n}\nfunction findFraction(structure, pos) {\n    let counted = 0;\n    for (let { from, to } of structure.ranges){\n        if (pos <= to) {\n            counted += pos - from;\n            break;\n        }\n        counted += to - from;\n    }\n    return counted / structure.total;\n}\nfunction find(array, f) {\n    for (let val of array)if (f(val)) return val;\n    return undefined;\n}\n// Don't scale when the document height is within the range of what\n// the DOM can handle.\nconst IdScaler = {\n    toDOM (n) {\n        return n;\n    },\n    fromDOM (n) {\n        return n;\n    },\n    scale: 1\n};\n// When the height is too big (> VP.MaxDOMHeight), scale down the\n// regions outside the viewports so that the total height is\n// VP.MaxDOMHeight.\nclass BigScaler {\n    constructor(oracle, heightMap, viewports){\n        let vpHeight = 0, base = 0, domBase = 0;\n        this.viewports = viewports.map(({ from, to })=>{\n            let top = heightMap.lineAt(from, QueryType.ByPos, oracle, 0, 0).top;\n            let bottom = heightMap.lineAt(to, QueryType.ByPos, oracle, 0, 0).bottom;\n            vpHeight += bottom - top;\n            return {\n                from,\n                to,\n                top,\n                bottom,\n                domTop: 0,\n                domBottom: 0\n            };\n        });\n        this.scale = (7000000 /* VP.MaxDOMHeight */  - vpHeight) / (heightMap.height - vpHeight);\n        for (let obj of this.viewports){\n            obj.domTop = domBase + (obj.top - base) * this.scale;\n            domBase = obj.domBottom = obj.domTop + (obj.bottom - obj.top);\n            base = obj.bottom;\n        }\n    }\n    toDOM(n) {\n        for(let i = 0, base = 0, domBase = 0;; i++){\n            let vp = i < this.viewports.length ? this.viewports[i] : null;\n            if (!vp || n < vp.top) return domBase + (n - base) * this.scale;\n            if (n <= vp.bottom) return vp.domTop + (n - vp.top);\n            base = vp.bottom;\n            domBase = vp.domBottom;\n        }\n    }\n    fromDOM(n) {\n        for(let i = 0, base = 0, domBase = 0;; i++){\n            let vp = i < this.viewports.length ? this.viewports[i] : null;\n            if (!vp || n < vp.domTop) return base + (n - domBase) / this.scale;\n            if (n <= vp.domBottom) return vp.top + (n - vp.domTop);\n            base = vp.bottom;\n            domBase = vp.domBottom;\n        }\n    }\n}\nfunction scaleBlock(block, scaler) {\n    if (scaler.scale == 1) return block;\n    let bTop = scaler.toDOM(block.top), bBottom = scaler.toDOM(block.bottom);\n    return new BlockInfo(block.from, block.length, bTop, bBottom - bTop, Array.isArray(block._content) ? block._content.map((b)=>scaleBlock(b, scaler)) : block._content);\n}\nconst theme = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    combine: (strs)=>strs.join(\" \")\n});\nconst darkTheme = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    combine: (values)=>values.indexOf(true) > -1\n});\nconst baseThemeID = /*@__PURE__*/ style_mod__WEBPACK_IMPORTED_MODULE_0__.StyleModule.newName(), baseLightID = /*@__PURE__*/ style_mod__WEBPACK_IMPORTED_MODULE_0__.StyleModule.newName(), baseDarkID = /*@__PURE__*/ style_mod__WEBPACK_IMPORTED_MODULE_0__.StyleModule.newName();\nconst lightDarkIDs = {\n    \"&light\": \".\" + baseLightID,\n    \"&dark\": \".\" + baseDarkID\n};\nfunction buildTheme(main, spec, scopes) {\n    return new style_mod__WEBPACK_IMPORTED_MODULE_0__.StyleModule(spec, {\n        finish (sel) {\n            return /&/.test(sel) ? sel.replace(/&\\w*/, (m)=>{\n                if (m == \"&\") return main;\n                if (!scopes || !scopes[m]) throw new RangeError(`Unsupported selector: ${m}`);\n                return scopes[m];\n            }) : main + \" \" + sel;\n        }\n    });\n}\nconst baseTheme$1 = /*@__PURE__*/ buildTheme(\".\" + baseThemeID, {\n    \"&\": {\n        position: \"relative !important\",\n        boxSizing: \"border-box\",\n        \"&.cm-focused\": {\n            // Provide a simple default outline to make sure a focused\n            // editor is visually distinct. Can't leave the default behavior\n            // because that will apply to the content element, which is\n            // inside the scrollable container and doesn't include the\n            // gutters. We also can't use an 'auto' outline, since those\n            // are, for some reason, drawn behind the element content, which\n            // will cause things like the active line background to cover\n            // the outline (#297).\n            outline: \"1px dotted #212121\"\n        },\n        display: \"flex !important\",\n        flexDirection: \"column\"\n    },\n    \".cm-scroller\": {\n        display: \"flex !important\",\n        alignItems: \"flex-start !important\",\n        fontFamily: \"monospace\",\n        lineHeight: 1.4,\n        height: \"100%\",\n        overflowX: \"auto\",\n        position: \"relative\",\n        zIndex: 0\n    },\n    \".cm-content\": {\n        margin: 0,\n        flexGrow: 2,\n        flexShrink: 0,\n        display: \"block\",\n        whiteSpace: \"pre\",\n        wordWrap: \"normal\",\n        boxSizing: \"border-box\",\n        minHeight: \"100%\",\n        padding: \"4px 0\",\n        outline: \"none\",\n        \"&[contenteditable=true]\": {\n            WebkitUserModify: \"read-write-plaintext-only\"\n        }\n    },\n    \".cm-lineWrapping\": {\n        whiteSpace_fallback: \"pre-wrap\",\n        whiteSpace: \"break-spaces\",\n        wordBreak: \"break-word\",\n        overflowWrap: \"anywhere\",\n        flexShrink: 1\n    },\n    \"&light .cm-content\": {\n        caretColor: \"black\"\n    },\n    \"&dark .cm-content\": {\n        caretColor: \"white\"\n    },\n    \".cm-line\": {\n        display: \"block\",\n        padding: \"0 2px 0 6px\"\n    },\n    \".cm-layer\": {\n        position: \"absolute\",\n        left: 0,\n        top: 0,\n        contain: \"size style\",\n        \"& > *\": {\n            position: \"absolute\"\n        }\n    },\n    \"&light .cm-selectionBackground\": {\n        background: \"#d9d9d9\"\n    },\n    \"&dark .cm-selectionBackground\": {\n        background: \"#222\"\n    },\n    \"&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground\": {\n        background: \"#d7d4f0\"\n    },\n    \"&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground\": {\n        background: \"#233\"\n    },\n    \".cm-cursorLayer\": {\n        pointerEvents: \"none\"\n    },\n    \"&.cm-focused > .cm-scroller > .cm-cursorLayer\": {\n        animation: \"steps(1) cm-blink 1.2s infinite\"\n    },\n    // Two animations defined so that we can switch between them to\n    // restart the animation without forcing another style\n    // recomputation.\n    \"@keyframes cm-blink\": {\n        \"0%\": {},\n        \"50%\": {\n            opacity: 0\n        },\n        \"100%\": {}\n    },\n    \"@keyframes cm-blink2\": {\n        \"0%\": {},\n        \"50%\": {\n            opacity: 0\n        },\n        \"100%\": {}\n    },\n    \".cm-cursor, .cm-dropCursor\": {\n        borderLeft: \"1.2px solid black\",\n        marginLeft: \"-0.6px\",\n        pointerEvents: \"none\"\n    },\n    \".cm-cursor\": {\n        display: \"none\"\n    },\n    \"&dark .cm-cursor\": {\n        borderLeftColor: \"#444\"\n    },\n    \".cm-dropCursor\": {\n        position: \"absolute\"\n    },\n    \"&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor\": {\n        display: \"block\"\n    },\n    \".cm-announced\": {\n        position: \"fixed\",\n        top: \"-10000px\"\n    },\n    \"@media print\": {\n        \".cm-announced\": {\n            display: \"none\"\n        }\n    },\n    \"&light .cm-activeLine\": {\n        backgroundColor: \"#cceeff44\"\n    },\n    \"&dark .cm-activeLine\": {\n        backgroundColor: \"#99eeff33\"\n    },\n    \"&light .cm-specialChar\": {\n        color: \"red\"\n    },\n    \"&dark .cm-specialChar\": {\n        color: \"#f78\"\n    },\n    \".cm-gutters\": {\n        flexShrink: 0,\n        display: \"flex\",\n        height: \"100%\",\n        boxSizing: \"border-box\",\n        insetInlineStart: 0,\n        zIndex: 200\n    },\n    \"&light .cm-gutters\": {\n        backgroundColor: \"#f5f5f5\",\n        color: \"#6c6c6c\",\n        borderRight: \"1px solid #ddd\"\n    },\n    \"&dark .cm-gutters\": {\n        backgroundColor: \"#333338\",\n        color: \"#ccc\"\n    },\n    \".cm-gutter\": {\n        display: \"flex !important\",\n        flexDirection: \"column\",\n        flexShrink: 0,\n        boxSizing: \"border-box\",\n        minHeight: \"100%\",\n        overflow: \"hidden\"\n    },\n    \".cm-gutterElement\": {\n        boxSizing: \"border-box\"\n    },\n    \".cm-lineNumbers .cm-gutterElement\": {\n        padding: \"0 3px 0 5px\",\n        minWidth: \"20px\",\n        textAlign: \"right\",\n        whiteSpace: \"nowrap\"\n    },\n    \"&light .cm-activeLineGutter\": {\n        backgroundColor: \"#e2f2ff\"\n    },\n    \"&dark .cm-activeLineGutter\": {\n        backgroundColor: \"#222227\"\n    },\n    \".cm-panels\": {\n        boxSizing: \"border-box\",\n        position: \"sticky\",\n        left: 0,\n        right: 0\n    },\n    \"&light .cm-panels\": {\n        backgroundColor: \"#f5f5f5\",\n        color: \"black\"\n    },\n    \"&light .cm-panels-top\": {\n        borderBottom: \"1px solid #ddd\"\n    },\n    \"&light .cm-panels-bottom\": {\n        borderTop: \"1px solid #ddd\"\n    },\n    \"&dark .cm-panels\": {\n        backgroundColor: \"#333338\",\n        color: \"white\"\n    },\n    \".cm-tab\": {\n        display: \"inline-block\",\n        overflow: \"hidden\",\n        verticalAlign: \"bottom\"\n    },\n    \".cm-widgetBuffer\": {\n        verticalAlign: \"text-top\",\n        height: \"1em\",\n        width: 0,\n        display: \"inline\"\n    },\n    \".cm-placeholder\": {\n        color: \"#888\",\n        display: \"inline-block\",\n        verticalAlign: \"top\"\n    },\n    \".cm-highlightSpace:before\": {\n        content: \"attr(data-display)\",\n        position: \"absolute\",\n        pointerEvents: \"none\",\n        color: \"#888\"\n    },\n    \".cm-highlightTab\": {\n        backgroundImage: `url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"200\" height=\"20\"><path stroke=\"%23888\" stroke-width=\"1\" fill=\"none\" d=\"M1 10H196L190 5M190 15L196 10M197 4L197 16\"/></svg>')`,\n        backgroundSize: \"auto 100%\",\n        backgroundPosition: \"right 90%\",\n        backgroundRepeat: \"no-repeat\"\n    },\n    \".cm-trailingSpace\": {\n        backgroundColor: \"#ff332255\"\n    },\n    \".cm-button\": {\n        verticalAlign: \"middle\",\n        color: \"inherit\",\n        fontSize: \"70%\",\n        padding: \".2em 1em\",\n        borderRadius: \"1px\"\n    },\n    \"&light .cm-button\": {\n        backgroundImage: \"linear-gradient(#eff1f5, #d9d9df)\",\n        border: \"1px solid #888\",\n        \"&:active\": {\n            backgroundImage: \"linear-gradient(#b4b4b4, #d0d3d6)\"\n        }\n    },\n    \"&dark .cm-button\": {\n        backgroundImage: \"linear-gradient(#393939, #111)\",\n        border: \"1px solid #888\",\n        \"&:active\": {\n            backgroundImage: \"linear-gradient(#111, #333)\"\n        }\n    },\n    \".cm-textfield\": {\n        verticalAlign: \"middle\",\n        color: \"inherit\",\n        fontSize: \"70%\",\n        border: \"1px solid silver\",\n        padding: \".2em .5em\"\n    },\n    \"&light .cm-textfield\": {\n        backgroundColor: \"white\"\n    },\n    \"&dark .cm-textfield\": {\n        border: \"1px solid #555\",\n        backgroundColor: \"inherit\"\n    }\n}, lightDarkIDs);\nconst LineBreakPlaceholder = \"￿\";\nclass DOMReader {\n    constructor(points, state){\n        this.points = points;\n        this.text = \"\";\n        this.lineSeparator = state.facet(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorState.lineSeparator);\n    }\n    append(text) {\n        this.text += text;\n    }\n    lineBreak() {\n        this.text += LineBreakPlaceholder;\n    }\n    readRange(start, end) {\n        if (!start) return this;\n        let parent = start.parentNode;\n        for(let cur = start;;){\n            this.findPointBefore(parent, cur);\n            let oldLen = this.text.length;\n            this.readNode(cur);\n            let next = cur.nextSibling;\n            if (next == end) break;\n            let view = ContentView.get(cur), nextView = ContentView.get(next);\n            if (view && nextView ? view.breakAfter : (view ? view.breakAfter : isBlockElement(cur)) || isBlockElement(next) && (cur.nodeName != \"BR\" || cur.cmIgnore) && this.text.length > oldLen) this.lineBreak();\n            cur = next;\n        }\n        this.findPointBefore(parent, end);\n        return this;\n    }\n    readTextNode(node) {\n        let text = node.nodeValue;\n        for (let point of this.points)if (point.node == node) point.pos = this.text.length + Math.min(point.offset, text.length);\n        for(let off = 0, re = this.lineSeparator ? null : /\\r\\n?|\\n/g;;){\n            let nextBreak = -1, breakSize = 1, m;\n            if (this.lineSeparator) {\n                nextBreak = text.indexOf(this.lineSeparator, off);\n                breakSize = this.lineSeparator.length;\n            } else if (m = re.exec(text)) {\n                nextBreak = m.index;\n                breakSize = m[0].length;\n            }\n            this.append(text.slice(off, nextBreak < 0 ? text.length : nextBreak));\n            if (nextBreak < 0) break;\n            this.lineBreak();\n            if (breakSize > 1) {\n                for (let point of this.points)if (point.node == node && point.pos > this.text.length) point.pos -= breakSize - 1;\n            }\n            off = nextBreak + breakSize;\n        }\n    }\n    readNode(node) {\n        if (node.cmIgnore) return;\n        let view = ContentView.get(node);\n        let fromView = view && view.overrideDOMText;\n        if (fromView != null) {\n            this.findPointInside(node, fromView.length);\n            for(let i = fromView.iter(); !i.next().done;){\n                if (i.lineBreak) this.lineBreak();\n                else this.append(i.value);\n            }\n        } else if (node.nodeType == 3) {\n            this.readTextNode(node);\n        } else if (node.nodeName == \"BR\") {\n            if (node.nextSibling) this.lineBreak();\n        } else if (node.nodeType == 1) {\n            this.readRange(node.firstChild, null);\n        }\n    }\n    findPointBefore(node, next) {\n        for (let point of this.points)if (point.node == node && node.childNodes[point.offset] == next) point.pos = this.text.length;\n    }\n    findPointInside(node, length) {\n        for (let point of this.points)if (node.nodeType == 3 ? point.node == node : node.contains(point.node)) point.pos = this.text.length + (isAtEnd(node, point.node, point.offset) ? length : 0);\n    }\n}\nfunction isAtEnd(parent, node, offset) {\n    for(;;){\n        if (!node || offset < maxOffset(node)) return false;\n        if (node == parent) return true;\n        offset = domIndex(node) + 1;\n        node = node.parentNode;\n    }\n}\nfunction isBlockElement(node) {\n    return node.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\\d|SECTION|PRE)$/.test(node.nodeName);\n}\nclass DOMPoint {\n    constructor(node, offset){\n        this.node = node;\n        this.offset = offset;\n        this.pos = -1;\n    }\n}\nclass DOMChange {\n    constructor(view, start, end, typeOver){\n        this.typeOver = typeOver;\n        this.bounds = null;\n        this.text = \"\";\n        let { impreciseHead: iHead, impreciseAnchor: iAnchor } = view.docView;\n        if (view.state.readOnly && start > -1) {\n            // Ignore changes when the editor is read-only\n            this.newSel = null;\n        } else if (start > -1 && (this.bounds = view.docView.domBoundsAround(start, end, 0))) {\n            let selPoints = iHead || iAnchor ? [] : selectionPoints(view);\n            let reader = new DOMReader(selPoints, view.state);\n            reader.readRange(this.bounds.startDOM, this.bounds.endDOM);\n            this.text = reader.text;\n            this.newSel = selectionFromPoints(selPoints, this.bounds.from);\n        } else {\n            let domSel = view.observer.selectionRange;\n            let head = iHead && iHead.node == domSel.focusNode && iHead.offset == domSel.focusOffset || !contains(view.contentDOM, domSel.focusNode) ? view.state.selection.main.head : view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset);\n            let anchor = iAnchor && iAnchor.node == domSel.anchorNode && iAnchor.offset == domSel.anchorOffset || !contains(view.contentDOM, domSel.anchorNode) ? view.state.selection.main.anchor : view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset);\n            this.newSel = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.single(anchor, head);\n        }\n    }\n}\nfunction applyDOMChange(view, domChange) {\n    let change;\n    let { newSel } = domChange, sel = view.state.selection.main;\n    let lastKey = view.inputState.lastKeyTime > Date.now() - 100 ? view.inputState.lastKeyCode : -1;\n    if (domChange.bounds) {\n        let { from, to } = domChange.bounds;\n        let preferredPos = sel.from, preferredSide = null;\n        // Prefer anchoring to end when Backspace is pressed (or, on\n        // Android, when something was deleted)\n        if (lastKey === 8 || browser.android && domChange.text.length < to - from) {\n            preferredPos = sel.to;\n            preferredSide = \"end\";\n        }\n        let diff = findDiff(view.state.doc.sliceString(from, to, LineBreakPlaceholder), domChange.text, preferredPos - from, preferredSide);\n        if (diff) {\n            // Chrome inserts two newlines when pressing shift-enter at the\n            // end of a line. DomChange drops one of those.\n            if (browser.chrome && lastKey == 13 && diff.toB == diff.from + 2 && domChange.text.slice(diff.from, diff.toB) == LineBreakPlaceholder + LineBreakPlaceholder) diff.toB--;\n            change = {\n                from: from + diff.from,\n                to: from + diff.toA,\n                insert: _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Text.of(domChange.text.slice(diff.from, diff.toB).split(LineBreakPlaceholder))\n            };\n        }\n    } else if (newSel && (!view.hasFocus && view.state.facet(editable) || newSel.main.eq(sel))) {\n        newSel = null;\n    }\n    if (!change && !newSel) return false;\n    if (!change && domChange.typeOver && !sel.empty && newSel && newSel.main.empty) {\n        // Heuristic to notice typing over a selected character\n        change = {\n            from: sel.from,\n            to: sel.to,\n            insert: view.state.doc.slice(sel.from, sel.to)\n        };\n    } else if (change && change.from >= sel.from && change.to <= sel.to && (change.from != sel.from || change.to != sel.to) && sel.to - sel.from - (change.to - change.from) <= 4) {\n        // If the change is inside the selection and covers most of it,\n        // assume it is a selection replace (with identical characters at\n        // the start/end not included in the diff)\n        change = {\n            from: sel.from,\n            to: sel.to,\n            insert: view.state.doc.slice(sel.from, change.from).append(change.insert).append(view.state.doc.slice(change.to, sel.to))\n        };\n    } else if ((browser.mac || browser.android) && change && change.from == change.to && change.from == sel.head - 1 && /^\\. ?$/.test(change.insert.toString()) && view.contentDOM.getAttribute(\"autocorrect\") == \"off\") {\n        // Detect insert-period-on-double-space Mac and Android behavior,\n        // and transform it into a regular space insert.\n        if (newSel && change.insert.length == 2) newSel = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);\n        change = {\n            from: sel.from,\n            to: sel.to,\n            insert: _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Text.of([\n                \" \"\n            ])\n        };\n    } else if (browser.chrome && change && change.from == change.to && change.from == sel.head && change.insert.toString() == \"\\n \" && view.lineWrapping) {\n        // In Chrome, if you insert a space at the start of a wrapped\n        // line, it will actually insert a newline and a space, causing a\n        // bogus new line to be created in CodeMirror (#968)\n        if (newSel) newSel = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);\n        change = {\n            from: sel.from,\n            to: sel.to,\n            insert: _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Text.of([\n                \" \"\n            ])\n        };\n    }\n    if (change) {\n        if (browser.ios && view.inputState.flushIOSKey()) return true;\n        // Android browsers don't fire reasonable key events for enter,\n        // backspace, or delete. So this detects changes that look like\n        // they're caused by those keys, and reinterprets them as key\n        // events. (Some of these keys are also handled by beforeinput\n        // events and the pendingAndroidKey mechanism, but that's not\n        // reliable in all situations.)\n        if (browser.android && (change.from == sel.from && change.to == sel.to && change.insert.length == 1 && change.insert.lines == 2 && dispatchKey(view.contentDOM, \"Enter\", 13) || (change.from == sel.from - 1 && change.to == sel.to && change.insert.length == 0 || lastKey == 8 && change.insert.length < change.to - change.from && change.to > sel.head) && dispatchKey(view.contentDOM, \"Backspace\", 8) || change.from == sel.from && change.to == sel.to + 1 && change.insert.length == 0 && dispatchKey(view.contentDOM, \"Delete\", 46))) return true;\n        let text = change.insert.toString();\n        if (view.inputState.composing >= 0) view.inputState.composing++;\n        let defaultTr;\n        let defaultInsert = ()=>defaultTr || (defaultTr = applyDefaultInsert(view, change, newSel));\n        if (!view.state.facet(inputHandler).some((h)=>h(view, change.from, change.to, text, defaultInsert))) view.dispatch(defaultInsert());\n        return true;\n    } else if (newSel && !newSel.main.eq(sel)) {\n        let scrollIntoView = false, userEvent = \"select\";\n        if (view.inputState.lastSelectionTime > Date.now() - 50) {\n            if (view.inputState.lastSelectionOrigin == \"select\") scrollIntoView = true;\n            userEvent = view.inputState.lastSelectionOrigin;\n        }\n        view.dispatch({\n            selection: newSel,\n            scrollIntoView,\n            userEvent\n        });\n        return true;\n    } else {\n        return false;\n    }\n}\nfunction applyDefaultInsert(view, change, newSel) {\n    let tr, startState = view.state, sel = startState.selection.main;\n    if (change.from >= sel.from && change.to <= sel.to && change.to - change.from >= (sel.to - sel.from) / 3 && (!newSel || newSel.main.empty && newSel.main.from == change.from + change.insert.length) && view.inputState.composing < 0) {\n        let before = sel.from < change.from ? startState.sliceDoc(sel.from, change.from) : \"\";\n        let after = sel.to > change.to ? startState.sliceDoc(change.to, sel.to) : \"\";\n        tr = startState.replaceSelection(view.state.toText(before + change.insert.sliceString(0, undefined, view.state.lineBreak) + after));\n    } else {\n        let changes = startState.changes(change);\n        let mainSel = newSel && newSel.main.to <= changes.newLength ? newSel.main : undefined;\n        // Try to apply a composition change to all cursors\n        if (startState.selection.ranges.length > 1 && view.inputState.composing >= 0 && change.to <= sel.to && change.to >= sel.to - 10) {\n            let replaced = view.state.sliceDoc(change.from, change.to);\n            let compositionRange, composition = newSel && findCompositionNode(view, newSel.main.head);\n            if (composition) {\n                let dLen = change.insert.length - (change.to - change.from);\n                compositionRange = {\n                    from: composition.from,\n                    to: composition.to - dLen\n                };\n            } else {\n                compositionRange = view.state.doc.lineAt(sel.head);\n            }\n            let offset = sel.to - change.to, size = sel.to - sel.from;\n            tr = startState.changeByRange((range)=>{\n                if (range.from == sel.from && range.to == sel.to) return {\n                    changes,\n                    range: mainSel || range.map(changes)\n                };\n                let to = range.to - offset, from = to - replaced.length;\n                if (range.to - range.from != size || view.state.sliceDoc(from, to) != replaced || // Unfortunately, there's no way to make multiple\n                // changes in the same node work without aborting\n                // composition, so cursors in the composition range are\n                // ignored.\n                range.to >= compositionRange.from && range.from <= compositionRange.to) return {\n                    range\n                };\n                let rangeChanges = startState.changes({\n                    from,\n                    to,\n                    insert: change.insert\n                }), selOff = range.to - sel.to;\n                return {\n                    changes: rangeChanges,\n                    range: !mainSel ? range.map(rangeChanges) : _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.range(Math.max(0, mainSel.anchor + selOff), Math.max(0, mainSel.head + selOff))\n                };\n            });\n        } else {\n            tr = {\n                changes,\n                selection: mainSel && startState.selection.replaceRange(mainSel)\n            };\n        }\n    }\n    let userEvent = \"input.type\";\n    if (view.composing || view.inputState.compositionPendingChange && view.inputState.compositionEndedAt > Date.now() - 50) {\n        view.inputState.compositionPendingChange = false;\n        userEvent += \".compose\";\n        if (view.inputState.compositionFirstChange) {\n            userEvent += \".start\";\n            view.inputState.compositionFirstChange = false;\n        }\n    }\n    return startState.update(tr, {\n        userEvent,\n        scrollIntoView: true\n    });\n}\nfunction findDiff(a, b, preferredPos, preferredSide) {\n    let minLen = Math.min(a.length, b.length);\n    let from = 0;\n    while(from < minLen && a.charCodeAt(from) == b.charCodeAt(from))from++;\n    if (from == minLen && a.length == b.length) return null;\n    let toA = a.length, toB = b.length;\n    while(toA > 0 && toB > 0 && a.charCodeAt(toA - 1) == b.charCodeAt(toB - 1)){\n        toA--;\n        toB--;\n    }\n    if (preferredSide == \"end\") {\n        let adjust = Math.max(0, from - Math.min(toA, toB));\n        preferredPos -= toA + adjust - from;\n    }\n    if (toA < from && a.length < b.length) {\n        let move = preferredPos <= from && preferredPos >= toA ? from - preferredPos : 0;\n        from -= move;\n        toB = from + (toB - toA);\n        toA = from;\n    } else if (toB < from) {\n        let move = preferredPos <= from && preferredPos >= toB ? from - preferredPos : 0;\n        from -= move;\n        toA = from + (toA - toB);\n        toB = from;\n    }\n    return {\n        from,\n        toA,\n        toB\n    };\n}\nfunction selectionPoints(view) {\n    let result = [];\n    if (view.root.activeElement != view.contentDOM) return result;\n    let { anchorNode, anchorOffset, focusNode, focusOffset } = view.observer.selectionRange;\n    if (anchorNode) {\n        result.push(new DOMPoint(anchorNode, anchorOffset));\n        if (focusNode != anchorNode || focusOffset != anchorOffset) result.push(new DOMPoint(focusNode, focusOffset));\n    }\n    return result;\n}\nfunction selectionFromPoints(points, base) {\n    if (points.length == 0) return null;\n    let anchor = points[0].pos, head = points.length == 2 ? points[1].pos : anchor;\n    return anchor > -1 && head > -1 ? _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.single(anchor + base, head + base) : null;\n}\nconst observeOptions = {\n    childList: true,\n    characterData: true,\n    subtree: true,\n    attributes: true,\n    characterDataOldValue: true\n};\n// IE11 has very broken mutation observers, so we also listen to\n// DOMCharacterDataModified there\nconst useCharData = browser.ie && browser.ie_version <= 11;\nclass DOMObserver {\n    constructor(view){\n        this.view = view;\n        this.active = false;\n        // The known selection. Kept in our own object, as opposed to just\n        // directly accessing the selection because:\n        //  - Safari doesn't report the right selection in shadow DOM\n        //  - Reading from the selection forces a DOM layout\n        //  - This way, we can ignore selectionchange events if we have\n        //    already seen the 'new' selection\n        this.selectionRange = new DOMSelectionState;\n        // Set when a selection change is detected, cleared on flush\n        this.selectionChanged = false;\n        this.delayedFlush = -1;\n        this.resizeTimeout = -1;\n        this.queue = [];\n        this.delayedAndroidKey = null;\n        this.flushingAndroidKey = -1;\n        this.lastChange = 0;\n        this.scrollTargets = [];\n        this.intersection = null;\n        this.resizeScroll = null;\n        this.intersecting = false;\n        this.gapIntersection = null;\n        this.gaps = [];\n        // Timeout for scheduling check of the parents that need scroll handlers\n        this.parentCheck = -1;\n        this.dom = view.contentDOM;\n        this.observer = new MutationObserver((mutations)=>{\n            for (let mut of mutations)this.queue.push(mut);\n            // IE11 will sometimes (on typing over a selection or\n            // backspacing out a single character text node) call the\n            // observer callback before actually updating the DOM.\n            //\n            // Unrelatedly, iOS Safari will, when ending a composition,\n            // sometimes first clear it, deliver the mutations, and then\n            // reinsert the finished text. CodeMirror's handling of the\n            // deletion will prevent the reinsertion from happening,\n            // breaking composition.\n            if ((browser.ie && browser.ie_version <= 11 || browser.ios && view.composing) && mutations.some((m)=>m.type == \"childList\" && m.removedNodes.length || m.type == \"characterData\" && m.oldValue.length > m.target.nodeValue.length)) this.flushSoon();\n            else this.flush();\n        });\n        if (useCharData) this.onCharData = (event)=>{\n            this.queue.push({\n                target: event.target,\n                type: \"characterData\",\n                oldValue: event.prevValue\n            });\n            this.flushSoon();\n        };\n        this.onSelectionChange = this.onSelectionChange.bind(this);\n        this.onResize = this.onResize.bind(this);\n        this.onPrint = this.onPrint.bind(this);\n        this.onScroll = this.onScroll.bind(this);\n        if (typeof ResizeObserver == \"function\") {\n            this.resizeScroll = new ResizeObserver(()=>{\n                var _a;\n                if (((_a = this.view.docView) === null || _a === void 0 ? void 0 : _a.lastUpdate) < Date.now() - 75) this.onResize();\n            });\n            this.resizeScroll.observe(view.scrollDOM);\n        }\n        this.addWindowListeners(this.win = view.win);\n        this.start();\n        if (typeof IntersectionObserver == \"function\") {\n            this.intersection = new IntersectionObserver((entries)=>{\n                if (this.parentCheck < 0) this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1000);\n                if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0 != this.intersecting) {\n                    this.intersecting = !this.intersecting;\n                    if (this.intersecting != this.view.inView) this.onScrollChanged(document.createEvent(\"Event\"));\n                }\n            }, {\n                threshold: [\n                    0,\n                    .001\n                ]\n            });\n            this.intersection.observe(this.dom);\n            this.gapIntersection = new IntersectionObserver((entries)=>{\n                if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0) this.onScrollChanged(document.createEvent(\"Event\"));\n            }, {});\n        }\n        this.listenForScroll();\n        this.readSelectionRange();\n    }\n    onScrollChanged(e) {\n        this.view.inputState.runHandlers(\"scroll\", e);\n        if (this.intersecting) this.view.measure();\n    }\n    onScroll(e) {\n        if (this.intersecting) this.flush(false);\n        this.onScrollChanged(e);\n    }\n    onResize() {\n        if (this.resizeTimeout < 0) this.resizeTimeout = setTimeout(()=>{\n            this.resizeTimeout = -1;\n            this.view.requestMeasure();\n        }, 50);\n    }\n    onPrint() {\n        this.view.viewState.printing = true;\n        this.view.measure();\n        setTimeout(()=>{\n            this.view.viewState.printing = false;\n            this.view.requestMeasure();\n        }, 500);\n    }\n    updateGaps(gaps) {\n        if (this.gapIntersection && (gaps.length != this.gaps.length || this.gaps.some((g, i)=>g != gaps[i]))) {\n            this.gapIntersection.disconnect();\n            for (let gap of gaps)this.gapIntersection.observe(gap);\n            this.gaps = gaps;\n        }\n    }\n    onSelectionChange(event) {\n        let wasChanged = this.selectionChanged;\n        if (!this.readSelectionRange() || this.delayedAndroidKey) return;\n        let { view } = this, sel = this.selectionRange;\n        if (view.state.facet(editable) ? view.root.activeElement != this.dom : !hasSelection(view.dom, sel)) return;\n        let context = sel.anchorNode && view.docView.nearest(sel.anchorNode);\n        if (context && context.ignoreEvent(event)) {\n            if (!wasChanged) this.selectionChanged = false;\n            return;\n        }\n        // Deletions on IE11 fire their events in the wrong order, giving\n        // us a selection change event before the DOM changes are\n        // reported.\n        // Chrome Android has a similar issue when backspacing out a\n        // selection (#645).\n        if ((browser.ie && browser.ie_version <= 11 || browser.android && browser.chrome) && !view.state.selection.main.empty && // (Selection.isCollapsed isn't reliable on IE)\n        sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset)) this.flushSoon();\n        else this.flush(false);\n    }\n    readSelectionRange() {\n        let { view } = this;\n        // The Selection object is broken in shadow roots in Safari. See\n        // https://github.com/codemirror/dev/issues/414\n        let range = browser.safari && view.root.nodeType == 11 && deepActiveElement(this.dom.ownerDocument) == this.dom && safariSelectionRangeHack(this.view) || getSelection(view.root);\n        if (!range || this.selectionRange.eq(range)) return false;\n        let local = hasSelection(this.dom, range);\n        // Detect the situation where the browser has, on focus, moved the\n        // selection to the start of the content element. Reset it to the\n        // position from the editor state.\n        if (local && !this.selectionChanged && view.inputState.lastFocusTime > Date.now() - 200 && view.inputState.lastTouchTime < Date.now() - 300 && atElementStart(this.dom, range)) {\n            this.view.inputState.lastFocusTime = 0;\n            view.docView.updateSelection();\n            return false;\n        }\n        this.selectionRange.setRange(range);\n        if (local) this.selectionChanged = true;\n        return true;\n    }\n    setSelectionRange(anchor, head) {\n        this.selectionRange.set(anchor.node, anchor.offset, head.node, head.offset);\n        this.selectionChanged = false;\n    }\n    clearSelectionRange() {\n        this.selectionRange.set(null, 0, null, 0);\n    }\n    listenForScroll() {\n        this.parentCheck = -1;\n        let i = 0, changed = null;\n        for(let dom = this.dom; dom;){\n            if (dom.nodeType == 1) {\n                if (!changed && i < this.scrollTargets.length && this.scrollTargets[i] == dom) i++;\n                else if (!changed) changed = this.scrollTargets.slice(0, i);\n                if (changed) changed.push(dom);\n                dom = dom.assignedSlot || dom.parentNode;\n            } else if (dom.nodeType == 11) {\n                dom = dom.host;\n            } else {\n                break;\n            }\n        }\n        if (i < this.scrollTargets.length && !changed) changed = this.scrollTargets.slice(0, i);\n        if (changed) {\n            for (let dom of this.scrollTargets)dom.removeEventListener(\"scroll\", this.onScroll);\n            for (let dom of this.scrollTargets = changed)dom.addEventListener(\"scroll\", this.onScroll);\n        }\n    }\n    ignore(f) {\n        if (!this.active) return f();\n        try {\n            this.stop();\n            return f();\n        } finally{\n            this.start();\n            this.clear();\n        }\n    }\n    start() {\n        if (this.active) return;\n        this.observer.observe(this.dom, observeOptions);\n        if (useCharData) this.dom.addEventListener(\"DOMCharacterDataModified\", this.onCharData);\n        this.active = true;\n    }\n    stop() {\n        if (!this.active) return;\n        this.active = false;\n        this.observer.disconnect();\n        if (useCharData) this.dom.removeEventListener(\"DOMCharacterDataModified\", this.onCharData);\n    }\n    // Throw away any pending changes\n    clear() {\n        this.processRecords();\n        this.queue.length = 0;\n        this.selectionChanged = false;\n    }\n    // Chrome Android, especially in combination with GBoard, not only\n    // doesn't reliably fire regular key events, but also often\n    // surrounds the effect of enter or backspace with a bunch of\n    // composition events that, when interrupted, cause text duplication\n    // or other kinds of corruption. This hack makes the editor back off\n    // from handling DOM changes for a moment when such a key is\n    // detected (via beforeinput or keydown), and then tries to flush\n    // them or, if that has no effect, dispatches the given key.\n    delayAndroidKey(key, keyCode) {\n        var _a;\n        if (!this.delayedAndroidKey) {\n            let flush = ()=>{\n                let key = this.delayedAndroidKey;\n                if (key) {\n                    this.clearDelayedAndroidKey();\n                    this.view.inputState.lastKeyCode = key.keyCode;\n                    this.view.inputState.lastKeyTime = Date.now();\n                    let flushed = this.flush();\n                    if (!flushed && key.force) dispatchKey(this.dom, key.key, key.keyCode);\n                }\n            };\n            this.flushingAndroidKey = this.view.win.requestAnimationFrame(flush);\n        }\n        // Since backspace beforeinput is sometimes signalled spuriously,\n        // Enter always takes precedence.\n        if (!this.delayedAndroidKey || key == \"Enter\") this.delayedAndroidKey = {\n            key,\n            keyCode,\n            // Only run the key handler when no changes are detected if\n            // this isn't coming right after another change, in which case\n            // it is probably part of a weird chain of updates, and should\n            // be ignored if it returns the DOM to its previous state.\n            force: this.lastChange < Date.now() - 50 || !!((_a = this.delayedAndroidKey) === null || _a === void 0 ? void 0 : _a.force)\n        };\n    }\n    clearDelayedAndroidKey() {\n        this.win.cancelAnimationFrame(this.flushingAndroidKey);\n        this.delayedAndroidKey = null;\n        this.flushingAndroidKey = -1;\n    }\n    flushSoon() {\n        if (this.delayedFlush < 0) this.delayedFlush = this.view.win.requestAnimationFrame(()=>{\n            this.delayedFlush = -1;\n            this.flush();\n        });\n    }\n    forceFlush() {\n        if (this.delayedFlush >= 0) {\n            this.view.win.cancelAnimationFrame(this.delayedFlush);\n            this.delayedFlush = -1;\n        }\n        this.flush();\n    }\n    pendingRecords() {\n        for (let mut of this.observer.takeRecords())this.queue.push(mut);\n        return this.queue;\n    }\n    processRecords() {\n        let records = this.pendingRecords();\n        if (records.length) this.queue = [];\n        let from = -1, to = -1, typeOver = false;\n        for (let record of records){\n            let range = this.readMutation(record);\n            if (!range) continue;\n            if (range.typeOver) typeOver = true;\n            if (from == -1) {\n                ({ from, to } = range);\n            } else {\n                from = Math.min(range.from, from);\n                to = Math.max(range.to, to);\n            }\n        }\n        return {\n            from,\n            to,\n            typeOver\n        };\n    }\n    readChange() {\n        let { from, to, typeOver } = this.processRecords();\n        let newSel = this.selectionChanged && hasSelection(this.dom, this.selectionRange);\n        if (from < 0 && !newSel) return null;\n        if (from > -1) this.lastChange = Date.now();\n        this.view.inputState.lastFocusTime = 0;\n        this.selectionChanged = false;\n        let change = new DOMChange(this.view, from, to, typeOver);\n        this.view.docView.domChanged = {\n            newSel: change.newSel ? change.newSel.main : null\n        };\n        return change;\n    }\n    // Apply pending changes, if any\n    flush(readSelection = true) {\n        // Completely hold off flushing when pending keys are set—the code\n        // managing those will make sure processRecords is called and the\n        // view is resynchronized after\n        if (this.delayedFlush >= 0 || this.delayedAndroidKey) return false;\n        if (readSelection) this.readSelectionRange();\n        let domChange = this.readChange();\n        if (!domChange) {\n            this.view.requestMeasure();\n            return false;\n        }\n        let startState = this.view.state;\n        let handled = applyDOMChange(this.view, domChange);\n        // The view wasn't updated\n        if (this.view.state == startState) this.view.update([]);\n        return handled;\n    }\n    readMutation(rec) {\n        let cView = this.view.docView.nearest(rec.target);\n        if (!cView || cView.ignoreMutation(rec)) return null;\n        cView.markDirty(rec.type == \"attributes\");\n        if (rec.type == \"attributes\") cView.flags |= 4 /* ViewFlag.AttrsDirty */ ;\n        if (rec.type == \"childList\") {\n            let childBefore = findChild(cView, rec.previousSibling || rec.target.previousSibling, -1);\n            let childAfter = findChild(cView, rec.nextSibling || rec.target.nextSibling, 1);\n            return {\n                from: childBefore ? cView.posAfter(childBefore) : cView.posAtStart,\n                to: childAfter ? cView.posBefore(childAfter) : cView.posAtEnd,\n                typeOver: false\n            };\n        } else if (rec.type == \"characterData\") {\n            return {\n                from: cView.posAtStart,\n                to: cView.posAtEnd,\n                typeOver: rec.target.nodeValue == rec.oldValue\n            };\n        } else {\n            return null;\n        }\n    }\n    setWindow(win) {\n        if (win != this.win) {\n            this.removeWindowListeners(this.win);\n            this.win = win;\n            this.addWindowListeners(this.win);\n        }\n    }\n    addWindowListeners(win) {\n        win.addEventListener(\"resize\", this.onResize);\n        win.addEventListener(\"beforeprint\", this.onPrint);\n        win.addEventListener(\"scroll\", this.onScroll);\n        win.document.addEventListener(\"selectionchange\", this.onSelectionChange);\n    }\n    removeWindowListeners(win) {\n        win.removeEventListener(\"scroll\", this.onScroll);\n        win.removeEventListener(\"resize\", this.onResize);\n        win.removeEventListener(\"beforeprint\", this.onPrint);\n        win.document.removeEventListener(\"selectionchange\", this.onSelectionChange);\n    }\n    destroy() {\n        var _a, _b, _c;\n        this.stop();\n        (_a = this.intersection) === null || _a === void 0 ? void 0 : _a.disconnect();\n        (_b = this.gapIntersection) === null || _b === void 0 ? void 0 : _b.disconnect();\n        (_c = this.resizeScroll) === null || _c === void 0 ? void 0 : _c.disconnect();\n        for (let dom of this.scrollTargets)dom.removeEventListener(\"scroll\", this.onScroll);\n        this.removeWindowListeners(this.win);\n        clearTimeout(this.parentCheck);\n        clearTimeout(this.resizeTimeout);\n        this.win.cancelAnimationFrame(this.delayedFlush);\n        this.win.cancelAnimationFrame(this.flushingAndroidKey);\n    }\n}\nfunction findChild(cView, dom, dir) {\n    while(dom){\n        let curView = ContentView.get(dom);\n        if (curView && curView.parent == cView) return curView;\n        let parent = dom.parentNode;\n        dom = parent != cView.dom ? parent : dir > 0 ? dom.nextSibling : dom.previousSibling;\n    }\n    return null;\n}\n// Used to work around a Safari Selection/shadow DOM bug (#414)\nfunction safariSelectionRangeHack(view) {\n    let found = null;\n    // Because Safari (at least in 2018-2021) doesn't provide regular\n    // access to the selection inside a shadowroot, we have to perform a\n    // ridiculous hack to get at it—using `execCommand` to trigger a\n    // `beforeInput` event so that we can read the target range from the\n    // event.\n    function read(event) {\n        event.preventDefault();\n        event.stopImmediatePropagation();\n        found = event.getTargetRanges()[0];\n    }\n    view.contentDOM.addEventListener(\"beforeinput\", read, true);\n    view.dom.ownerDocument.execCommand(\"indent\");\n    view.contentDOM.removeEventListener(\"beforeinput\", read, true);\n    if (!found) return null;\n    let anchorNode = found.startContainer, anchorOffset = found.startOffset;\n    let focusNode = found.endContainer, focusOffset = found.endOffset;\n    let curAnchor = view.docView.domAtPos(view.state.selection.main.anchor);\n    // Since such a range doesn't distinguish between anchor and head,\n    // use a heuristic that flips it around if its end matches the\n    // current anchor.\n    if (isEquivalentPosition(curAnchor.node, curAnchor.offset, focusNode, focusOffset)) [anchorNode, anchorOffset, focusNode, focusOffset] = [\n        focusNode,\n        focusOffset,\n        anchorNode,\n        anchorOffset\n    ];\n    return {\n        anchorNode,\n        anchorOffset,\n        focusNode,\n        focusOffset\n    };\n}\n// The editor's update state machine looks something like this:\n//\n//     Idle → Updating ⇆ Idle (unchecked) → Measuring → Idle\n//                                         ↑      ↓\n//                                         Updating (measure)\n//\n// The difference between 'Idle' and 'Idle (unchecked)' lies in\n// whether a layout check has been scheduled. A regular update through\n// the `update` method updates the DOM in a write-only fashion, and\n// relies on a check (scheduled with `requestAnimationFrame`) to make\n// sure everything is where it should be and the viewport covers the\n// visible code. That check continues to measure and then optionally\n// update until it reaches a coherent state.\n/**\nAn editor view represents the editor's user interface. It holds\nthe editable DOM surface, and possibly other elements such as the\nline number gutter. It handles events and dispatches state\ntransactions for editing actions.\n*/ class EditorView {\n    /**\n    The current editor state.\n    */ get state() {\n        return this.viewState.state;\n    }\n    /**\n    To be able to display large documents without consuming too much\n    memory or overloading the browser, CodeMirror only draws the\n    code that is visible (plus a margin around it) to the DOM. This\n    property tells you the extent of the current drawn viewport, in\n    document positions.\n    */ get viewport() {\n        return this.viewState.viewport;\n    }\n    /**\n    When there are, for example, large collapsed ranges in the\n    viewport, its size can be a lot bigger than the actual visible\n    content. Thus, if you are doing something like styling the\n    content in the viewport, it is preferable to only do so for\n    these ranges, which are the subset of the viewport that is\n    actually drawn.\n    */ get visibleRanges() {\n        return this.viewState.visibleRanges;\n    }\n    /**\n    Returns false when the editor is entirely scrolled out of view\n    or otherwise hidden.\n    */ get inView() {\n        return this.viewState.inView;\n    }\n    /**\n    Indicates whether the user is currently composing text via\n    [IME](https://en.wikipedia.org/wiki/Input_method), and at least\n    one change has been made in the current composition.\n    */ get composing() {\n        return this.inputState.composing > 0;\n    }\n    /**\n    Indicates whether the user is currently in composing state. Note\n    that on some platforms, like Android, this will be the case a\n    lot, since just putting the cursor on a word starts a\n    composition there.\n    */ get compositionStarted() {\n        return this.inputState.composing >= 0;\n    }\n    /**\n    The document or shadow root that the view lives in.\n    */ get root() {\n        return this._root;\n    }\n    /**\n    @internal\n    */ get win() {\n        return this.dom.ownerDocument.defaultView || window;\n    }\n    /**\n    Construct a new view. You'll want to either provide a `parent`\n    option, or put `view.dom` into your document after creating a\n    view, so that the user can see the editor.\n    */ constructor(config = {}){\n        this.plugins = [];\n        this.pluginMap = new Map;\n        this.editorAttrs = {};\n        this.contentAttrs = {};\n        this.bidiCache = [];\n        this.destroyed = false;\n        /**\n        @internal\n        */ this.updateState = 2 /* UpdateState.Updating */ ;\n        /**\n        @internal\n        */ this.measureScheduled = -1;\n        /**\n        @internal\n        */ this.measureRequests = [];\n        this.contentDOM = document.createElement(\"div\");\n        this.scrollDOM = document.createElement(\"div\");\n        this.scrollDOM.tabIndex = -1;\n        this.scrollDOM.className = \"cm-scroller\";\n        this.scrollDOM.appendChild(this.contentDOM);\n        this.announceDOM = document.createElement(\"div\");\n        this.announceDOM.className = \"cm-announced\";\n        this.announceDOM.setAttribute(\"aria-live\", \"polite\");\n        this.dom = document.createElement(\"div\");\n        this.dom.appendChild(this.announceDOM);\n        this.dom.appendChild(this.scrollDOM);\n        let { dispatch } = config;\n        this.dispatchTransactions = config.dispatchTransactions || dispatch && ((trs)=>trs.forEach((tr)=>dispatch(tr, this))) || ((trs)=>this.update(trs));\n        this.dispatch = this.dispatch.bind(this);\n        this._root = config.root || getRoot(config.parent) || document;\n        this.viewState = new ViewState(config.state || _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorState.create(config));\n        if (config.scrollTo && config.scrollTo.is(scrollIntoView)) this.viewState.scrollTarget = config.scrollTo.value.clip(this.viewState.state);\n        this.plugins = this.state.facet(viewPlugin).map((spec)=>new PluginInstance(spec));\n        for (let plugin of this.plugins)plugin.update(this);\n        this.observer = new DOMObserver(this);\n        this.inputState = new InputState(this);\n        this.inputState.ensureHandlers(this.plugins);\n        this.docView = new DocView(this);\n        this.mountStyles();\n        this.updateAttrs();\n        this.updateState = 0 /* UpdateState.Idle */ ;\n        this.requestMeasure();\n        if (config.parent) config.parent.appendChild(this.dom);\n    }\n    dispatch(...input) {\n        let trs = input.length == 1 && input[0] instanceof _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Transaction ? input : input.length == 1 && Array.isArray(input[0]) ? input[0] : [\n            this.state.update(...input)\n        ];\n        this.dispatchTransactions(trs, this);\n    }\n    /**\n    Update the view for the given array of transactions. This will\n    update the visible document and selection to match the state\n    produced by the transactions, and notify view plugins of the\n    change. You should usually call\n    [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this\n    as a primitive.\n    */ update(transactions) {\n        if (this.updateState != 0 /* UpdateState.Idle */ ) throw new Error(\"Calls to EditorView.update are not allowed while an update is in progress\");\n        let redrawn = false, attrsChanged = false, update;\n        let state = this.state;\n        for (let tr of transactions){\n            if (tr.startState != state) throw new RangeError(\"Trying to update state with a transaction that doesn't start from the previous state.\");\n            state = tr.state;\n        }\n        if (this.destroyed) {\n            this.viewState.state = state;\n            return;\n        }\n        let focus = this.hasFocus, focusFlag = 0, dispatchFocus = null;\n        if (transactions.some((tr)=>tr.annotation(isFocusChange))) {\n            this.inputState.notifiedFocused = focus;\n            // If a focus-change transaction is being dispatched, set this update flag.\n            focusFlag = 1 /* UpdateFlag.Focus */ ;\n        } else if (focus != this.inputState.notifiedFocused) {\n            this.inputState.notifiedFocused = focus;\n            // Schedule a separate focus transaction if necessary, otherwise\n            // add a flag to this update\n            dispatchFocus = focusChangeTransaction(state, focus);\n            if (!dispatchFocus) focusFlag = 1 /* UpdateFlag.Focus */ ;\n        }\n        // If there was a pending DOM change, eagerly read it and try to\n        // apply it after the given transactions.\n        let pendingKey = this.observer.delayedAndroidKey, domChange = null;\n        if (pendingKey) {\n            this.observer.clearDelayedAndroidKey();\n            domChange = this.observer.readChange();\n            // Only try to apply DOM changes if the transactions didn't\n            // change the doc or selection.\n            if (domChange && !this.state.doc.eq(state.doc) || !this.state.selection.eq(state.selection)) domChange = null;\n        } else {\n            this.observer.clear();\n        }\n        // When the phrases change, redraw the editor\n        if (state.facet(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorState.phrases) != this.state.facet(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorState.phrases)) return this.setState(state);\n        update = ViewUpdate.create(this, state, transactions);\n        update.flags |= focusFlag;\n        let scrollTarget = this.viewState.scrollTarget;\n        try {\n            this.updateState = 2 /* UpdateState.Updating */ ;\n            for (let tr of transactions){\n                if (scrollTarget) scrollTarget = scrollTarget.map(tr.changes);\n                if (tr.scrollIntoView) {\n                    let { main } = tr.state.selection;\n                    scrollTarget = new ScrollTarget(main.empty ? main : _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(main.head, main.head > main.anchor ? -1 : 1));\n                }\n                for (let e of tr.effects)if (e.is(scrollIntoView)) scrollTarget = e.value.clip(this.state);\n            }\n            this.viewState.update(update, scrollTarget);\n            this.bidiCache = CachedOrder.update(this.bidiCache, update.changes);\n            if (!update.empty) {\n                this.updatePlugins(update);\n                this.inputState.update(update);\n            }\n            redrawn = this.docView.update(update);\n            if (this.state.facet(styleModule) != this.styleModules) this.mountStyles();\n            attrsChanged = this.updateAttrs();\n            this.showAnnouncements(transactions);\n            this.docView.updateSelection(redrawn, transactions.some((tr)=>tr.isUserEvent(\"select.pointer\")));\n        } finally{\n            this.updateState = 0 /* UpdateState.Idle */ ;\n        }\n        if (update.startState.facet(theme) != update.state.facet(theme)) this.viewState.mustMeasureContent = true;\n        if (redrawn || attrsChanged || scrollTarget || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) this.requestMeasure();\n        if (!update.empty) for (let listener of this.state.facet(updateListener)){\n            try {\n                listener(update);\n            } catch (e) {\n                logException(this.state, e, \"update listener\");\n            }\n        }\n        if (dispatchFocus || domChange) Promise.resolve().then(()=>{\n            if (dispatchFocus && this.state == dispatchFocus.startState) this.dispatch(dispatchFocus);\n            if (domChange) {\n                if (!applyDOMChange(this, domChange) && pendingKey.force) dispatchKey(this.contentDOM, pendingKey.key, pendingKey.keyCode);\n            }\n        });\n    }\n    /**\n    Reset the view to the given state. (This will cause the entire\n    document to be redrawn and all view plugins to be reinitialized,\n    so you should probably only use it when the new state isn't\n    derived from the old state. Otherwise, use\n    [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)\n    */ setState(newState) {\n        if (this.updateState != 0 /* UpdateState.Idle */ ) throw new Error(\"Calls to EditorView.setState are not allowed while an update is in progress\");\n        if (this.destroyed) {\n            this.viewState.state = newState;\n            return;\n        }\n        this.updateState = 2 /* UpdateState.Updating */ ;\n        let hadFocus = this.hasFocus;\n        try {\n            for (let plugin of this.plugins)plugin.destroy(this);\n            this.viewState = new ViewState(newState);\n            this.plugins = newState.facet(viewPlugin).map((spec)=>new PluginInstance(spec));\n            this.pluginMap.clear();\n            for (let plugin of this.plugins)plugin.update(this);\n            this.docView.destroy();\n            this.docView = new DocView(this);\n            this.inputState.ensureHandlers(this.plugins);\n            this.mountStyles();\n            this.updateAttrs();\n            this.bidiCache = [];\n        } finally{\n            this.updateState = 0 /* UpdateState.Idle */ ;\n        }\n        if (hadFocus) this.focus();\n        this.requestMeasure();\n    }\n    updatePlugins(update) {\n        let prevSpecs = update.startState.facet(viewPlugin), specs = update.state.facet(viewPlugin);\n        if (prevSpecs != specs) {\n            let newPlugins = [];\n            for (let spec of specs){\n                let found = prevSpecs.indexOf(spec);\n                if (found < 0) {\n                    newPlugins.push(new PluginInstance(spec));\n                } else {\n                    let plugin = this.plugins[found];\n                    plugin.mustUpdate = update;\n                    newPlugins.push(plugin);\n                }\n            }\n            for (let plugin of this.plugins)if (plugin.mustUpdate != update) plugin.destroy(this);\n            this.plugins = newPlugins;\n            this.pluginMap.clear();\n        } else {\n            for (let p of this.plugins)p.mustUpdate = update;\n        }\n        for(let i = 0; i < this.plugins.length; i++)this.plugins[i].update(this);\n        if (prevSpecs != specs) this.inputState.ensureHandlers(this.plugins);\n    }\n    /**\n    @internal\n    */ measure(flush = true) {\n        if (this.destroyed) return;\n        if (this.measureScheduled > -1) this.win.cancelAnimationFrame(this.measureScheduled);\n        if (this.observer.delayedAndroidKey) {\n            this.measureScheduled = -1;\n            this.requestMeasure();\n            return;\n        }\n        this.measureScheduled = 0; // Prevent requestMeasure calls from scheduling another animation frame\n        if (flush) this.observer.forceFlush();\n        let updated = null;\n        let sDOM = this.scrollDOM, scrollTop = sDOM.scrollTop * this.scaleY;\n        let { scrollAnchorPos, scrollAnchorHeight } = this.viewState;\n        if (Math.abs(scrollTop - this.viewState.scrollTop) > 1) scrollAnchorHeight = -1;\n        this.viewState.scrollAnchorHeight = -1;\n        try {\n            for(let i = 0;; i++){\n                if (scrollAnchorHeight < 0) {\n                    if (isScrolledToBottom(sDOM)) {\n                        scrollAnchorPos = -1;\n                        scrollAnchorHeight = this.viewState.heightMap.height;\n                    } else {\n                        let block = this.viewState.scrollAnchorAt(scrollTop);\n                        scrollAnchorPos = block.from;\n                        scrollAnchorHeight = block.top;\n                    }\n                }\n                this.updateState = 1 /* UpdateState.Measuring */ ;\n                let changed = this.viewState.measure(this);\n                if (!changed && !this.measureRequests.length && this.viewState.scrollTarget == null) break;\n                if (i > 5) {\n                    console.warn(this.measureRequests.length ? \"Measure loop restarted more than 5 times\" : \"Viewport failed to stabilize\");\n                    break;\n                }\n                let measuring = [];\n                // Only run measure requests in this cycle when the viewport didn't change\n                if (!(changed & 4 /* UpdateFlag.Viewport */ )) [this.measureRequests, measuring] = [\n                    measuring,\n                    this.measureRequests\n                ];\n                let measured = measuring.map((m)=>{\n                    try {\n                        return m.read(this);\n                    } catch (e) {\n                        logException(this.state, e);\n                        return BadMeasure;\n                    }\n                });\n                let update = ViewUpdate.create(this, this.state, []), redrawn = false;\n                update.flags |= changed;\n                if (!updated) updated = update;\n                else updated.flags |= changed;\n                this.updateState = 2 /* UpdateState.Updating */ ;\n                if (!update.empty) {\n                    this.updatePlugins(update);\n                    this.inputState.update(update);\n                    this.updateAttrs();\n                    redrawn = this.docView.update(update);\n                }\n                for(let i = 0; i < measuring.length; i++)if (measured[i] != BadMeasure) {\n                    try {\n                        let m = measuring[i];\n                        if (m.write) m.write(measured[i], this);\n                    } catch (e) {\n                        logException(this.state, e);\n                    }\n                }\n                if (redrawn) this.docView.updateSelection(true);\n                if (!update.viewportChanged && this.measureRequests.length == 0) {\n                    if (this.viewState.editorHeight) {\n                        if (this.viewState.scrollTarget) {\n                            this.docView.scrollIntoView(this.viewState.scrollTarget);\n                            this.viewState.scrollTarget = null;\n                            scrollAnchorHeight = -1;\n                            continue;\n                        } else {\n                            let newAnchorHeight = scrollAnchorPos < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(scrollAnchorPos).top;\n                            let diff = newAnchorHeight - scrollAnchorHeight;\n                            if (diff > 1 || diff < -1) {\n                                scrollTop = scrollTop + diff;\n                                sDOM.scrollTop = scrollTop / this.scaleY;\n                                scrollAnchorHeight = -1;\n                                continue;\n                            }\n                        }\n                    }\n                    break;\n                }\n            }\n        } finally{\n            this.updateState = 0 /* UpdateState.Idle */ ;\n            this.measureScheduled = -1;\n        }\n        if (updated && !updated.empty) for (let listener of this.state.facet(updateListener))listener(updated);\n    }\n    /**\n    Get the CSS classes for the currently active editor themes.\n    */ get themeClasses() {\n        return baseThemeID + \" \" + (this.state.facet(darkTheme) ? baseDarkID : baseLightID) + \" \" + this.state.facet(theme);\n    }\n    updateAttrs() {\n        let editorAttrs = attrsFromFacet(this, editorAttributes, {\n            class: \"cm-editor\" + (this.hasFocus ? \" cm-focused \" : \" \") + this.themeClasses\n        });\n        let contentAttrs = {\n            spellcheck: \"false\",\n            autocorrect: \"off\",\n            autocapitalize: \"off\",\n            translate: \"no\",\n            contenteditable: !this.state.facet(editable) ? \"false\" : \"true\",\n            class: \"cm-content\",\n            style: `${browser.tabSize}: ${this.state.tabSize}`,\n            role: \"textbox\",\n            \"aria-multiline\": \"true\"\n        };\n        if (this.state.readOnly) contentAttrs[\"aria-readonly\"] = \"true\";\n        attrsFromFacet(this, contentAttributes, contentAttrs);\n        let changed = this.observer.ignore(()=>{\n            let changedContent = updateAttrs(this.contentDOM, this.contentAttrs, contentAttrs);\n            let changedEditor = updateAttrs(this.dom, this.editorAttrs, editorAttrs);\n            return changedContent || changedEditor;\n        });\n        this.editorAttrs = editorAttrs;\n        this.contentAttrs = contentAttrs;\n        return changed;\n    }\n    showAnnouncements(trs) {\n        let first = true;\n        for (let tr of trs)for (let effect of tr.effects)if (effect.is(EditorView.announce)) {\n            if (first) this.announceDOM.textContent = \"\";\n            first = false;\n            let div = this.announceDOM.appendChild(document.createElement(\"div\"));\n            div.textContent = effect.value;\n        }\n    }\n    mountStyles() {\n        this.styleModules = this.state.facet(styleModule);\n        let nonce = this.state.facet(EditorView.cspNonce);\n        style_mod__WEBPACK_IMPORTED_MODULE_0__.StyleModule.mount(this.root, this.styleModules.concat(baseTheme$1).reverse(), nonce ? {\n            nonce\n        } : undefined);\n    }\n    readMeasured() {\n        if (this.updateState == 2 /* UpdateState.Updating */ ) throw new Error(\"Reading the editor layout isn't allowed during an update\");\n        if (this.updateState == 0 /* UpdateState.Idle */  && this.measureScheduled > -1) this.measure(false);\n    }\n    /**\n    Schedule a layout measurement, optionally providing callbacks to\n    do custom DOM measuring followed by a DOM write phase. Using\n    this is preferable reading DOM layout directly from, for\n    example, an event handler, because it'll make sure measuring and\n    drawing done by other components is synchronized, avoiding\n    unnecessary DOM layout computations.\n    */ requestMeasure(request) {\n        if (this.measureScheduled < 0) this.measureScheduled = this.win.requestAnimationFrame(()=>this.measure());\n        if (request) {\n            if (this.measureRequests.indexOf(request) > -1) return;\n            if (request.key != null) for(let i = 0; i < this.measureRequests.length; i++){\n                if (this.measureRequests[i].key === request.key) {\n                    this.measureRequests[i] = request;\n                    return;\n                }\n            }\n            this.measureRequests.push(request);\n        }\n    }\n    /**\n    Get the value of a specific plugin, if present. Note that\n    plugins that crash can be dropped from a view, so even when you\n    know you registered a given plugin, it is recommended to check\n    the return value of this method.\n    */ plugin(plugin) {\n        let known = this.pluginMap.get(plugin);\n        if (known === undefined || known && known.spec != plugin) this.pluginMap.set(plugin, known = this.plugins.find((p)=>p.spec == plugin) || null);\n        return known && known.update(this).value;\n    }\n    /**\n    The top position of the document, in screen coordinates. This\n    may be negative when the editor is scrolled down. Points\n    directly to the top of the first line, not above the padding.\n    */ get documentTop() {\n        return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;\n    }\n    /**\n    Reports the padding above and below the document.\n    */ get documentPadding() {\n        return {\n            top: this.viewState.paddingTop,\n            bottom: this.viewState.paddingBottom\n        };\n    }\n    /**\n    If the editor is transformed with CSS, this provides the scale\n    along the X axis. Otherwise, it will just be 1. Note that\n    transforms other than translation and scaling are not supported.\n    */ get scaleX() {\n        return this.viewState.scaleX;\n    }\n    /**\n    Provide the CSS transformed scale along the Y axis.\n    */ get scaleY() {\n        return this.viewState.scaleY;\n    }\n    /**\n    Find the text line or block widget at the given vertical\n    position (which is interpreted as relative to the [top of the\n    document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop)).\n    */ elementAtHeight(height) {\n        this.readMeasured();\n        return this.viewState.elementAtHeight(height);\n    }\n    /**\n    Find the line block (see\n    [`lineBlockAt`](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) at the given\n    height, again interpreted relative to the [top of the\n    document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop).\n    */ lineBlockAtHeight(height) {\n        this.readMeasured();\n        return this.viewState.lineBlockAtHeight(height);\n    }\n    /**\n    Get the extent and vertical position of all [line\n    blocks](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) in the viewport. Positions\n    are relative to the [top of the\n    document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop);\n    */ get viewportLineBlocks() {\n        return this.viewState.viewportLines;\n    }\n    /**\n    Find the line block around the given document position. A line\n    block is a range delimited on both sides by either a\n    non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^replace) line breaks, or the\n    start/end of the document. It will usually just hold a line of\n    text, but may be broken into multiple textblocks by block\n    widgets.\n    */ lineBlockAt(pos) {\n        return this.viewState.lineBlockAt(pos);\n    }\n    /**\n    The editor's total content height.\n    */ get contentHeight() {\n        return this.viewState.contentHeight;\n    }\n    /**\n    Move a cursor position by [grapheme\n    cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak). `forward` determines whether\n    the motion is away from the line start, or towards it. In\n    bidirectional text, the line is traversed in visual order, using\n    the editor's [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).\n    When the start position was the last one on the line, the\n    returned position will be across the line break. If there is no\n    further line, the original position is returned.\n    \n    By default, this method moves over a single cluster. The\n    optional `by` argument can be used to move across more. It will\n    be called with the first cluster as argument, and should return\n    a predicate that determines, for each subsequent cluster,\n    whether it should also be moved over.\n    */ moveByChar(start, forward, by) {\n        return skipAtoms(this, start, moveByChar(this, start, forward, by));\n    }\n    /**\n    Move a cursor position across the next group of either\n    [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter\n    non-whitespace characters.\n    */ moveByGroup(start, forward) {\n        return skipAtoms(this, start, moveByChar(this, start, forward, (initial)=>byGroup(this, start.head, initial)));\n    }\n    /**\n    Move to the next line boundary in the given direction. If\n    `includeWrap` is true, line wrapping is on, and there is a\n    further wrap point on the current line, the wrap point will be\n    returned. Otherwise this function will return the start or end\n    of the line.\n    */ moveToLineBoundary(start, forward, includeWrap = true) {\n        return moveToLineBoundary(this, start, forward, includeWrap);\n    }\n    /**\n    Move a cursor position vertically. When `distance` isn't given,\n    it defaults to moving to the next line (including wrapped\n    lines). Otherwise, `distance` should provide a positive distance\n    in pixels.\n    \n    When `start` has a\n    [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical\n    motion will use that as a target horizontal position. Otherwise,\n    the cursor's own horizontal position is used. The returned\n    cursor will have its goal column set to whichever column was\n    used.\n    */ moveVertically(start, forward, distance) {\n        return skipAtoms(this, start, moveVertically(this, start, forward, distance));\n    }\n    /**\n    Find the DOM parent node and offset (child offset if `node` is\n    an element, character offset when it is a text node) at the\n    given document position.\n    \n    Note that for positions that aren't currently in\n    `visibleRanges`, the resulting DOM position isn't necessarily\n    meaningful (it may just point before or after a placeholder\n    element).\n    */ domAtPos(pos) {\n        return this.docView.domAtPos(pos);\n    }\n    /**\n    Find the document position at the given DOM node. Can be useful\n    for associating positions with DOM events. Will raise an error\n    when `node` isn't part of the editor content.\n    */ posAtDOM(node, offset = 0) {\n        return this.docView.posFromDOM(node, offset);\n    }\n    posAtCoords(coords, precise = true) {\n        this.readMeasured();\n        return posAtCoords(this, coords, precise);\n    }\n    /**\n    Get the screen coordinates at the given document position.\n    `side` determines whether the coordinates are based on the\n    element before (-1) or after (1) the position (if no element is\n    available on the given side, the method will transparently use\n    another strategy to get reasonable coordinates).\n    */ coordsAtPos(pos, side = 1) {\n        this.readMeasured();\n        let rect = this.docView.coordsAt(pos, side);\n        if (!rect || rect.left == rect.right) return rect;\n        let line = this.state.doc.lineAt(pos), order = this.bidiSpans(line);\n        let span = order[BidiSpan.find(order, pos - line.from, -1, side)];\n        return flattenRect(rect, span.dir == Direction.LTR == side > 0);\n    }\n    /**\n    Return the rectangle around a given character. If `pos` does not\n    point in front of a character that is in the viewport and\n    rendered (i.e. not replaced, not a line break), this will return\n    null. For space characters that are a line wrap point, this will\n    return the position before the line break.\n    */ coordsForChar(pos) {\n        this.readMeasured();\n        return this.docView.coordsForChar(pos);\n    }\n    /**\n    The default width of a character in the editor. May not\n    accurately reflect the width of all characters (given variable\n    width fonts or styling of invididual ranges).\n    */ get defaultCharacterWidth() {\n        return this.viewState.heightOracle.charWidth;\n    }\n    /**\n    The default height of a line in the editor. May not be accurate\n    for all lines.\n    */ get defaultLineHeight() {\n        return this.viewState.heightOracle.lineHeight;\n    }\n    /**\n    The text direction\n    ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)\n    CSS property) of the editor's content element.\n    */ get textDirection() {\n        return this.viewState.defaultTextDirection;\n    }\n    /**\n    Find the text direction of the block at the given position, as\n    assigned by CSS. If\n    [`perLineTextDirection`](https://codemirror.net/6/docs/ref/#view.EditorView^perLineTextDirection)\n    isn't enabled, or the given position is outside of the viewport,\n    this will always return the same as\n    [`textDirection`](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). Note that\n    this may trigger a DOM layout.\n    */ textDirectionAt(pos) {\n        let perLine = this.state.facet(perLineTextDirection);\n        if (!perLine || pos < this.viewport.from || pos > this.viewport.to) return this.textDirection;\n        this.readMeasured();\n        return this.docView.textDirectionAt(pos);\n    }\n    /**\n    Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)\n    (as determined by the\n    [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)\n    CSS property of its content element).\n    */ get lineWrapping() {\n        return this.viewState.heightOracle.lineWrapping;\n    }\n    /**\n    Returns the bidirectional text structure of the given line\n    (which should be in the current document) as an array of span\n    objects. The order of these spans matches the [text\n    direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)—if that is\n    left-to-right, the leftmost spans come first, otherwise the\n    rightmost spans come first.\n    */ bidiSpans(line) {\n        if (line.length > MaxBidiLine) return trivialOrder(line.length);\n        let dir = this.textDirectionAt(line.from), isolates;\n        for (let entry of this.bidiCache){\n            if (entry.from == line.from && entry.dir == dir && (entry.fresh || isolatesEq(entry.isolates, isolates = getIsolatedRanges(this, line.from, line.to)))) return entry.order;\n        }\n        if (!isolates) isolates = getIsolatedRanges(this, line.from, line.to);\n        let order = computeOrder(line.text, dir, isolates);\n        this.bidiCache.push(new CachedOrder(line.from, line.to, dir, isolates, true, order));\n        return order;\n    }\n    /**\n    Check whether the editor has focus.\n    */ get hasFocus() {\n        var _a;\n        // Safari return false for hasFocus when the context menu is open\n        // or closing, which leads us to ignore selection changes from the\n        // context menu because it looks like the editor isn't focused.\n        // This kludges around that.\n        return (this.dom.ownerDocument.hasFocus() || browser.safari && ((_a = this.inputState) === null || _a === void 0 ? void 0 : _a.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;\n    }\n    /**\n    Put focus on the editor.\n    */ focus() {\n        this.observer.ignore(()=>{\n            focusPreventScroll(this.contentDOM);\n            this.docView.updateSelection();\n        });\n    }\n    /**\n    Update the [root](https://codemirror.net/6/docs/ref/##view.EditorViewConfig.root) in which the editor lives. This is only\n    necessary when moving the editor's existing DOM to a new window or shadow root.\n    */ setRoot(root) {\n        if (this._root != root) {\n            this._root = root;\n            this.observer.setWindow((root.nodeType == 9 ? root : root.ownerDocument).defaultView || window);\n            this.mountStyles();\n        }\n    }\n    /**\n    Clean up this editor view, removing its element from the\n    document, unregistering event handlers, and notifying\n    plugins. The view instance can no longer be used after\n    calling this.\n    */ destroy() {\n        for (let plugin of this.plugins)plugin.destroy(this);\n        this.plugins = [];\n        this.inputState.destroy();\n        this.docView.destroy();\n        this.dom.remove();\n        this.observer.destroy();\n        if (this.measureScheduled > -1) this.win.cancelAnimationFrame(this.measureScheduled);\n        this.destroyed = true;\n    }\n    /**\n    Returns an effect that can be\n    [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a transaction to\n    cause it to scroll the given position or range into view.\n    */ static scrollIntoView(pos, options = {}) {\n        return scrollIntoView.of(new ScrollTarget(typeof pos == \"number\" ? _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(pos) : pos, options.y, options.x, options.yMargin, options.xMargin));\n    }\n    /**\n    Return an effect that resets the editor to its current (at the\n    time this method was called) scroll position. Note that this\n    only affects the editor's own scrollable element, not parents.\n    See also\n    [`EditorViewConfig.scrollTo`](https://codemirror.net/6/docs/ref/#view.EditorViewConfig.scrollTo).\n    \n    The effect should be used with a document identical to the one\n    it was created for. Failing to do so is not an error, but may\n    not scroll to the expected position. You can\n    [map](https://codemirror.net/6/docs/ref/#state.StateEffect.map) the effect to account for changes.\n    */ scrollSnapshot() {\n        let { scrollTop, scrollLeft } = this.scrollDOM;\n        let ref = this.viewState.scrollAnchorAt(scrollTop);\n        return scrollIntoView.of(new ScrollTarget(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(ref.from), \"start\", \"start\", ref.top - scrollTop, scrollLeft, true));\n    }\n    /**\n    Returns an extension that can be used to add DOM event handlers.\n    The value should be an object mapping event names to handler\n    functions. For any given event, such functions are ordered by\n    extension precedence, and the first handler to return true will\n    be assumed to have handled that event, and no other handlers or\n    built-in behavior will be activated for it. These are registered\n    on the [content element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except\n    for `scroll` handlers, which will be called any time the\n    editor's [scroll element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of\n    its parent nodes is scrolled.\n    */ static domEventHandlers(handlers) {\n        return ViewPlugin.define(()=>({}), {\n            eventHandlers: handlers\n        });\n    }\n    /**\n    Create an extension that registers DOM event observers. Contrary\n    to event [handlers](https://codemirror.net/6/docs/ref/#view.EditorView^domEventHandlers),\n    observers can't be prevented from running by a higher-precedence\n    handler returning true. They also don't prevent other handlers\n    and observers from running when they return true, and should not\n    call `preventDefault`.\n    */ static domEventObservers(observers) {\n        return ViewPlugin.define(()=>({}), {\n            eventObservers: observers\n        });\n    }\n    /**\n    Create a theme extension. The first argument can be a\n    [`style-mod`](https://github.com/marijnh/style-mod#documentation)\n    style spec providing the styles for the theme. These will be\n    prefixed with a generated class for the style.\n    \n    Because the selectors will be prefixed with a scope class, rule\n    that directly match the editor's [wrapper\n    element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)—to which the scope class will be\n    added—need to be explicitly differentiated by adding an `&` to\n    the selector for that element—for example\n    `&.cm-focused`.\n    \n    When `dark` is set to true, the theme will be marked as dark,\n    which will cause the `&dark` rules from [base\n    themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to\n    `&light` when a light theme is active).\n    */ static theme(spec, options) {\n        let prefix = style_mod__WEBPACK_IMPORTED_MODULE_0__.StyleModule.newName();\n        let result = [\n            theme.of(prefix),\n            styleModule.of(buildTheme(`.${prefix}`, spec))\n        ];\n        if (options && options.dark) result.push(darkTheme.of(true));\n        return result;\n    }\n    /**\n    Create an extension that adds styles to the base theme. Like\n    with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the\n    place of the editor wrapper element when directly targeting\n    that. You can also use `&dark` or `&light` instead to only\n    target editors with a dark or light theme.\n    */ static baseTheme(spec) {\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Prec.lowest(styleModule.of(buildTheme(\".\" + baseThemeID, spec, lightDarkIDs)));\n    }\n    /**\n    Retrieve an editor view instance from the view's DOM\n    representation.\n    */ static findFromDOM(dom) {\n        var _a;\n        let content = dom.querySelector(\".cm-content\");\n        let cView = content && ContentView.get(content) || ContentView.get(dom);\n        return ((_a = cView === null || cView === void 0 ? void 0 : cView.rootView) === null || _a === void 0 ? void 0 : _a.view) || null;\n    }\n}\n/**\nFacet to add a [style\nmodule](https://github.com/marijnh/style-mod#documentation) to\nan editor view. The view will ensure that the module is\nmounted in its [document\nroot](https://codemirror.net/6/docs/ref/#view.EditorView.constructor^config.root).\n*/ EditorView.styleModule = styleModule;\n/**\nAn input handler can override the way changes to the editable\nDOM content are handled. Handlers are passed the document\npositions between which the change was found, and the new\ncontent. When one returns true, no further input handlers are\ncalled and the default behavior is prevented.\n\nThe `insert` argument can be used to get the default transaction\nthat would be applied for this input. This can be useful when\ndispatching the custom behavior as a separate transaction.\n*/ EditorView.inputHandler = inputHandler;\n/**\nThis facet can be used to provide functions that create effects\nto be dispatched when the editor's focus state changes.\n*/ EditorView.focusChangeEffect = focusChangeEffect;\n/**\nBy default, the editor assumes all its content has the same\n[text direction](https://codemirror.net/6/docs/ref/#view.Direction). Configure this with a `true`\nvalue to make it read the text direction of every (rendered)\nline separately.\n*/ EditorView.perLineTextDirection = perLineTextDirection;\n/**\nAllows you to provide a function that should be called when the\nlibrary catches an exception from an extension (mostly from view\nplugins, but may be used by other extensions to route exceptions\nfrom user-code-provided callbacks). This is mostly useful for\ndebugging and logging. See [`logException`](https://codemirror.net/6/docs/ref/#view.logException).\n*/ EditorView.exceptionSink = exceptionSink;\n/**\nA facet that can be used to register a function to be called\nevery time the view updates.\n*/ EditorView.updateListener = updateListener;\n/**\nFacet that controls whether the editor content DOM is editable.\nWhen its highest-precedence value is `false`, the element will\nnot have its `contenteditable` attribute set. (Note that this\ndoesn't affect API calls that change the editor content, even\nwhen those are bound to keys or buttons. See the\n[`readOnly`](https://codemirror.net/6/docs/ref/#state.EditorState.readOnly) facet for that.)\n*/ EditorView.editable = editable;\n/**\nAllows you to influence the way mouse selection happens. The\nfunctions in this facet will be called for a `mousedown` event\non the editor, and can return an object that overrides the way a\nselection is computed from that mouse click or drag.\n*/ EditorView.mouseSelectionStyle = mouseSelectionStyle;\n/**\nFacet used to configure whether a given selection drag event\nshould move or copy the selection. The given predicate will be\ncalled with the `mousedown` event, and can return `true` when\nthe drag should move the content.\n*/ EditorView.dragMovesSelection = dragMovesSelection$1;\n/**\nFacet used to configure whether a given selecting click adds a\nnew range to the existing selection or replaces it entirely. The\ndefault behavior is to check `event.metaKey` on macOS, and\n`event.ctrlKey` elsewhere.\n*/ EditorView.clickAddsSelectionRange = clickAddsSelectionRange;\n/**\nA facet that determines which [decorations](https://codemirror.net/6/docs/ref/#view.Decoration)\nare shown in the view. Decorations can be provided in two\nways—directly, or via a function that takes an editor view.\n\nOnly decoration sets provided directly are allowed to influence\nthe editor's vertical layout structure. The ones provided as\nfunctions are called _after_ the new viewport has been computed,\nand thus **must not** introduce block widgets or replacing\ndecorations that cover line breaks.\n\nIf you want decorated ranges to behave like atomic units for\ncursor motion and deletion purposes, also provide the range set\ncontaining the decorations to\n[`EditorView.atomicRanges`](https://codemirror.net/6/docs/ref/#view.EditorView^atomicRanges).\n*/ EditorView.decorations = decorations;\n/**\nUsed to provide ranges that should be treated as atoms as far as\ncursor motion is concerned. This causes methods like\n[`moveByChar`](https://codemirror.net/6/docs/ref/#view.EditorView.moveByChar) and\n[`moveVertically`](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) (and the\ncommands built on top of them) to skip across such regions when\na selection endpoint would enter them. This does _not_ prevent\ndirect programmatic [selection\nupdates](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) from moving into such\nregions.\n*/ EditorView.atomicRanges = atomicRanges;\n/**\nWhen range decorations add a `unicode-bidi: isolate` style, they\nshould also include a\n[`bidiIsolate`](https://codemirror.net/6/docs/ref/#view.MarkDecorationSpec.bidiIsolate) property\nin their decoration spec, and be exposed through this facet, so\nthat the editor can compute the proper text order. (Other values\nfor `unicode-bidi`, except of course `normal`, are not\nsupported.)\n*/ EditorView.bidiIsolatedRanges = bidiIsolatedRanges;\n/**\nFacet that allows extensions to provide additional scroll\nmargins (space around the sides of the scrolling element that\nshould be considered invisible). This can be useful when the\nplugin introduces elements that cover part of that element (for\nexample a horizontally fixed gutter).\n*/ EditorView.scrollMargins = scrollMargins;\n/**\nThis facet records whether a dark theme is active. The extension\nreturned by [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme) automatically\nincludes an instance of this when the `dark` option is set to\ntrue.\n*/ EditorView.darkTheme = darkTheme;\n/**\nProvides a Content Security Policy nonce to use when creating\nthe style sheets for the editor. Holds the empty string when no\nnonce has been provided.\n*/ EditorView.cspNonce = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    combine: (values)=>values.length ? values[0] : \"\"\n});\n/**\nFacet that provides additional DOM attributes for the editor's\neditable DOM element.\n*/ EditorView.contentAttributes = contentAttributes;\n/**\nFacet that provides DOM attributes for the editor's outer\nelement.\n*/ EditorView.editorAttributes = editorAttributes;\n/**\nAn extension that enables line wrapping in the editor (by\nsetting CSS `white-space` to `pre-wrap` in the content).\n*/ EditorView.lineWrapping = /*@__PURE__*/ EditorView.contentAttributes.of({\n    \"class\": \"cm-lineWrapping\"\n});\n/**\nState effect used to include screen reader announcements in a\ntransaction. These will be added to the DOM in a visually hidden\nelement with `aria-live=\"polite\"` set, and should be used to\ndescribe effects that are visually obvious but may not be\nnoticed by screen reader users (such as moving to the next\nsearch match).\n*/ EditorView.announce = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.define();\n// Maximum line length for which we compute accurate bidi info\nconst MaxBidiLine = 4096;\nconst BadMeasure = {};\nclass CachedOrder {\n    constructor(from, to, dir, isolates, fresh, order){\n        this.from = from;\n        this.to = to;\n        this.dir = dir;\n        this.isolates = isolates;\n        this.fresh = fresh;\n        this.order = order;\n    }\n    static update(cache, changes) {\n        if (changes.empty && !cache.some((c)=>c.fresh)) return cache;\n        let result = [], lastDir = cache.length ? cache[cache.length - 1].dir : Direction.LTR;\n        for(let i = Math.max(0, cache.length - 10); i < cache.length; i++){\n            let entry = cache[i];\n            if (entry.dir == lastDir && !changes.touchesRange(entry.from, entry.to)) result.push(new CachedOrder(changes.mapPos(entry.from, 1), changes.mapPos(entry.to, -1), entry.dir, entry.isolates, false, entry.order));\n        }\n        return result;\n    }\n}\nfunction attrsFromFacet(view, facet, base) {\n    for(let sources = view.state.facet(facet), i = sources.length - 1; i >= 0; i--){\n        let source = sources[i], value = typeof source == \"function\" ? source(view) : source;\n        if (value) combineAttrs(value, base);\n    }\n    return base;\n}\nconst currentPlatform = browser.mac ? \"mac\" : browser.windows ? \"win\" : browser.linux ? \"linux\" : \"key\";\nfunction normalizeKeyName(name, platform) {\n    const parts = name.split(/-(?!$)/);\n    let result = parts[parts.length - 1];\n    if (result == \"Space\") result = \" \";\n    let alt, ctrl, shift, meta;\n    for(let i = 0; i < parts.length - 1; ++i){\n        const mod = parts[i];\n        if (/^(cmd|meta|m)$/i.test(mod)) meta = true;\n        else if (/^a(lt)?$/i.test(mod)) alt = true;\n        else if (/^(c|ctrl|control)$/i.test(mod)) ctrl = true;\n        else if (/^s(hift)?$/i.test(mod)) shift = true;\n        else if (/^mod$/i.test(mod)) {\n            if (platform == \"mac\") meta = true;\n            else ctrl = true;\n        } else throw new Error(\"Unrecognized modifier name: \" + mod);\n    }\n    if (alt) result = \"Alt-\" + result;\n    if (ctrl) result = \"Ctrl-\" + result;\n    if (meta) result = \"Meta-\" + result;\n    if (shift) result = \"Shift-\" + result;\n    return result;\n}\nfunction modifiers(name, event, shift) {\n    if (event.altKey) name = \"Alt-\" + name;\n    if (event.ctrlKey) name = \"Ctrl-\" + name;\n    if (event.metaKey) name = \"Meta-\" + name;\n    if (shift !== false && event.shiftKey) name = \"Shift-\" + name;\n    return name;\n}\nconst handleKeyEvents = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Prec.default(/*@__PURE__*/ EditorView.domEventHandlers({\n    keydown (event, view) {\n        return runHandlers(getKeymap(view.state), event, view, \"editor\");\n    }\n}));\n/**\nFacet used for registering keymaps.\n\nYou can add multiple keymaps to an editor. Their priorities\ndetermine their precedence (the ones specified early or with high\npriority get checked first). When a handler has returned `true`\nfor a given key, no further handlers are called.\n*/ const keymap = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    enables: handleKeyEvents\n});\nconst Keymaps = /*@__PURE__*/ new WeakMap();\n// This is hidden behind an indirection, rather than directly computed\n// by the facet, to keep internal types out of the facet's type.\nfunction getKeymap(state) {\n    let bindings = state.facet(keymap);\n    let map = Keymaps.get(bindings);\n    if (!map) Keymaps.set(bindings, map = buildKeymap(bindings.reduce((a, b)=>a.concat(b), [])));\n    return map;\n}\n/**\nRun the key handlers registered for a given scope. The event\nobject should be a `\"keydown\"` event. Returns true if any of the\nhandlers handled it.\n*/ function runScopeHandlers(view, event, scope) {\n    return runHandlers(getKeymap(view.state), event, view, scope);\n}\nlet storedPrefix = null;\nconst PrefixTimeout = 4000;\nfunction buildKeymap(bindings, platform = currentPlatform) {\n    let bound = Object.create(null);\n    let isPrefix = Object.create(null);\n    let checkPrefix = (name, is)=>{\n        let current = isPrefix[name];\n        if (current == null) isPrefix[name] = is;\n        else if (current != is) throw new Error(\"Key binding \" + name + \" is used both as a regular binding and as a multi-stroke prefix\");\n    };\n    let add = (scope, key, command, preventDefault, stopPropagation)=>{\n        var _a, _b;\n        let scopeObj = bound[scope] || (bound[scope] = Object.create(null));\n        let parts = key.split(/ (?!$)/).map((k)=>normalizeKeyName(k, platform));\n        for(let i = 1; i < parts.length; i++){\n            let prefix = parts.slice(0, i).join(\" \");\n            checkPrefix(prefix, true);\n            if (!scopeObj[prefix]) scopeObj[prefix] = {\n                preventDefault: true,\n                stopPropagation: false,\n                run: [\n                    (view)=>{\n                        let ourObj = storedPrefix = {\n                            view,\n                            prefix,\n                            scope\n                        };\n                        setTimeout(()=>{\n                            if (storedPrefix == ourObj) storedPrefix = null;\n                        }, PrefixTimeout);\n                        return true;\n                    }\n                ]\n            };\n        }\n        let full = parts.join(\" \");\n        checkPrefix(full, false);\n        let binding = scopeObj[full] || (scopeObj[full] = {\n            preventDefault: false,\n            stopPropagation: false,\n            run: ((_b = (_a = scopeObj._any) === null || _a === void 0 ? void 0 : _a.run) === null || _b === void 0 ? void 0 : _b.slice()) || []\n        });\n        if (command) binding.run.push(command);\n        if (preventDefault) binding.preventDefault = true;\n        if (stopPropagation) binding.stopPropagation = true;\n    };\n    for (let b of bindings){\n        let scopes = b.scope ? b.scope.split(\" \") : [\n            \"editor\"\n        ];\n        if (b.any) for (let scope of scopes){\n            let scopeObj = bound[scope] || (bound[scope] = Object.create(null));\n            if (!scopeObj._any) scopeObj._any = {\n                preventDefault: false,\n                stopPropagation: false,\n                run: []\n            };\n            for(let key in scopeObj)scopeObj[key].run.push(b.any);\n        }\n        let name = b[platform] || b.key;\n        if (!name) continue;\n        for (let scope of scopes){\n            add(scope, name, b.run, b.preventDefault, b.stopPropagation);\n            if (b.shift) add(scope, \"Shift-\" + name, b.shift, b.preventDefault, b.stopPropagation);\n        }\n    }\n    return bound;\n}\nfunction runHandlers(map, event, view, scope) {\n    let name = (0,w3c_keyname__WEBPACK_IMPORTED_MODULE_1__.keyName)(event);\n    let charCode = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.codePointAt)(name, 0), isChar = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.codePointSize)(charCode) == name.length && name != \" \";\n    let prefix = \"\", handled = false, prevented = false, stopPropagation = false;\n    if (storedPrefix && storedPrefix.view == view && storedPrefix.scope == scope) {\n        prefix = storedPrefix.prefix + \" \";\n        if (modifierCodes.indexOf(event.keyCode) < 0) {\n            prevented = true;\n            storedPrefix = null;\n        }\n    }\n    let ran = new Set;\n    let runFor = (binding)=>{\n        if (binding) {\n            for (let cmd of binding.run)if (!ran.has(cmd)) {\n                ran.add(cmd);\n                if (cmd(view, event)) {\n                    if (binding.stopPropagation) stopPropagation = true;\n                    return true;\n                }\n            }\n            if (binding.preventDefault) {\n                if (binding.stopPropagation) stopPropagation = true;\n                prevented = true;\n            }\n        }\n        return false;\n    };\n    let scopeObj = map[scope], baseName, shiftName;\n    if (scopeObj) {\n        if (runFor(scopeObj[prefix + modifiers(name, event, !isChar)])) {\n            handled = true;\n        } else if (isChar && (event.altKey || event.metaKey || event.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows\n        !(browser.windows && event.ctrlKey && event.altKey) && (baseName = w3c_keyname__WEBPACK_IMPORTED_MODULE_1__.base[event.keyCode]) && baseName != name) {\n            if (runFor(scopeObj[prefix + modifiers(baseName, event, true)])) {\n                handled = true;\n            } else if (event.shiftKey && (shiftName = w3c_keyname__WEBPACK_IMPORTED_MODULE_1__.shift[event.keyCode]) != name && shiftName != baseName && runFor(scopeObj[prefix + modifiers(shiftName, event, false)])) {\n                handled = true;\n            }\n        } else if (isChar && event.shiftKey && runFor(scopeObj[prefix + modifiers(name, event, true)])) {\n            handled = true;\n        }\n        if (!handled && runFor(scopeObj._any)) handled = true;\n    }\n    if (prevented) handled = true;\n    if (handled && stopPropagation) event.stopPropagation();\n    return handled;\n}\n/**\nImplementation of [`LayerMarker`](https://codemirror.net/6/docs/ref/#view.LayerMarker) that creates\na rectangle at a given set of coordinates.\n*/ class RectangleMarker {\n    /**\n    Create a marker with the given class and dimensions. If `width`\n    is null, the DOM element will get no width style.\n    */ constructor(className, /**\n    The left position of the marker (in pixels, document-relative).\n    */ left, /**\n    The top position of the marker.\n    */ top, /**\n    The width of the marker, or null if it shouldn't get a width assigned.\n    */ width, /**\n    The height of the marker.\n    */ height){\n        this.className = className;\n        this.left = left;\n        this.top = top;\n        this.width = width;\n        this.height = height;\n    }\n    draw() {\n        let elt = document.createElement(\"div\");\n        elt.className = this.className;\n        this.adjust(elt);\n        return elt;\n    }\n    update(elt, prev) {\n        if (prev.className != this.className) return false;\n        this.adjust(elt);\n        return true;\n    }\n    adjust(elt) {\n        elt.style.left = this.left + \"px\";\n        elt.style.top = this.top + \"px\";\n        if (this.width != null) elt.style.width = this.width + \"px\";\n        elt.style.height = this.height + \"px\";\n    }\n    eq(p) {\n        return this.left == p.left && this.top == p.top && this.width == p.width && this.height == p.height && this.className == p.className;\n    }\n    /**\n    Create a set of rectangles for the given selection range,\n    assigning them theclass`className`. Will create a single\n    rectangle for empty ranges, and a set of selection-style\n    rectangles covering the range's content (in a bidi-aware\n    way) for non-empty ones.\n    */ static forRange(view, className, range) {\n        if (range.empty) {\n            let pos = view.coordsAtPos(range.head, range.assoc || 1);\n            if (!pos) return [];\n            let base = getBase(view);\n            return [\n                new RectangleMarker(className, pos.left - base.left, pos.top - base.top, null, pos.bottom - pos.top)\n            ];\n        } else {\n            return rectanglesForRange(view, className, range);\n        }\n    }\n}\nfunction getBase(view) {\n    let rect = view.scrollDOM.getBoundingClientRect();\n    let left = view.textDirection == Direction.LTR ? rect.left : rect.right - view.scrollDOM.clientWidth * view.scaleX;\n    return {\n        left: left - view.scrollDOM.scrollLeft * view.scaleX,\n        top: rect.top - view.scrollDOM.scrollTop * view.scaleY\n    };\n}\nfunction wrappedLine(view, pos, inside) {\n    let range = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(pos);\n    return {\n        from: Math.max(inside.from, view.moveToLineBoundary(range, false, true).from),\n        to: Math.min(inside.to, view.moveToLineBoundary(range, true, true).from),\n        type: BlockType.Text\n    };\n}\nfunction rectanglesForRange(view, className, range) {\n    if (range.to <= view.viewport.from || range.from >= view.viewport.to) return [];\n    let from = Math.max(range.from, view.viewport.from), to = Math.min(range.to, view.viewport.to);\n    let ltr = view.textDirection == Direction.LTR;\n    let content = view.contentDOM, contentRect = content.getBoundingClientRect(), base = getBase(view);\n    let lineElt = content.querySelector(\".cm-line\"), lineStyle = lineElt && window.getComputedStyle(lineElt);\n    let leftSide = contentRect.left + (lineStyle ? parseInt(lineStyle.paddingLeft) + Math.min(0, parseInt(lineStyle.textIndent)) : 0);\n    let rightSide = contentRect.right - (lineStyle ? parseInt(lineStyle.paddingRight) : 0);\n    let startBlock = blockAt(view, from), endBlock = blockAt(view, to);\n    let visualStart = startBlock.type == BlockType.Text ? startBlock : null;\n    let visualEnd = endBlock.type == BlockType.Text ? endBlock : null;\n    if (visualStart && (view.lineWrapping || startBlock.widgetLineBreaks)) visualStart = wrappedLine(view, from, visualStart);\n    if (visualEnd && (view.lineWrapping || endBlock.widgetLineBreaks)) visualEnd = wrappedLine(view, to, visualEnd);\n    if (visualStart && visualEnd && visualStart.from == visualEnd.from) {\n        return pieces(drawForLine(range.from, range.to, visualStart));\n    } else {\n        let top = visualStart ? drawForLine(range.from, null, visualStart) : drawForWidget(startBlock, false);\n        let bottom = visualEnd ? drawForLine(null, range.to, visualEnd) : drawForWidget(endBlock, true);\n        let between = [];\n        if ((visualStart || startBlock).to < (visualEnd || endBlock).from - (visualStart && visualEnd ? 1 : 0) || startBlock.widgetLineBreaks > 1 && top.bottom + view.defaultLineHeight / 2 < bottom.top) between.push(piece(leftSide, top.bottom, rightSide, bottom.top));\n        else if (top.bottom < bottom.top && view.elementAtHeight((top.bottom + bottom.top) / 2).type == BlockType.Text) top.bottom = bottom.top = (top.bottom + bottom.top) / 2;\n        return pieces(top).concat(between).concat(pieces(bottom));\n    }\n    function piece(left, top, right, bottom) {\n        return new RectangleMarker(className, left - base.left, top - base.top - 0.01 /* C.Epsilon */ , right - left, bottom - top + 0.01 /* C.Epsilon */ );\n    }\n    function pieces({ top, bottom, horizontal }) {\n        let pieces = [];\n        for(let i = 0; i < horizontal.length; i += 2)pieces.push(piece(horizontal[i], top, horizontal[i + 1], bottom));\n        return pieces;\n    }\n    // Gets passed from/to in line-local positions\n    function drawForLine(from, to, line) {\n        let top = 1e9, bottom = -1e9, horizontal = [];\n        function addSpan(from, fromOpen, to, toOpen, dir) {\n            // Passing 2/-2 is a kludge to force the view to return\n            // coordinates on the proper side of block widgets, since\n            // normalizing the side there, though appropriate for most\n            // coordsAtPos queries, would break selection drawing.\n            let fromCoords = view.coordsAtPos(from, from == line.to ? -2 : 2);\n            let toCoords = view.coordsAtPos(to, to == line.from ? 2 : -2);\n            if (!fromCoords || !toCoords) return;\n            top = Math.min(fromCoords.top, toCoords.top, top);\n            bottom = Math.max(fromCoords.bottom, toCoords.bottom, bottom);\n            if (dir == Direction.LTR) horizontal.push(ltr && fromOpen ? leftSide : fromCoords.left, ltr && toOpen ? rightSide : toCoords.right);\n            else horizontal.push(!ltr && toOpen ? leftSide : toCoords.left, !ltr && fromOpen ? rightSide : fromCoords.right);\n        }\n        let start = from !== null && from !== void 0 ? from : line.from, end = to !== null && to !== void 0 ? to : line.to;\n        // Split the range by visible range and document line\n        for (let r of view.visibleRanges)if (r.to > start && r.from < end) {\n            for(let pos = Math.max(r.from, start), endPos = Math.min(r.to, end);;){\n                let docLine = view.state.doc.lineAt(pos);\n                for (let span of view.bidiSpans(docLine)){\n                    let spanFrom = span.from + docLine.from, spanTo = span.to + docLine.from;\n                    if (spanFrom >= endPos) break;\n                    if (spanTo > pos) addSpan(Math.max(spanFrom, pos), from == null && spanFrom <= start, Math.min(spanTo, endPos), to == null && spanTo >= end, span.dir);\n                }\n                pos = docLine.to + 1;\n                if (pos >= endPos) break;\n            }\n        }\n        if (horizontal.length == 0) addSpan(start, from == null, end, to == null, view.textDirection);\n        return {\n            top,\n            bottom,\n            horizontal\n        };\n    }\n    function drawForWidget(block, top) {\n        let y = contentRect.top + (top ? block.top : block.bottom);\n        return {\n            top: y,\n            bottom: y,\n            horizontal: []\n        };\n    }\n}\nfunction sameMarker(a, b) {\n    return a.constructor == b.constructor && a.eq(b);\n}\nclass LayerView {\n    constructor(view, layer){\n        this.view = view;\n        this.layer = layer;\n        this.drawn = [];\n        this.scaleX = 1;\n        this.scaleY = 1;\n        this.measureReq = {\n            read: this.measure.bind(this),\n            write: this.draw.bind(this)\n        };\n        this.dom = view.scrollDOM.appendChild(document.createElement(\"div\"));\n        this.dom.classList.add(\"cm-layer\");\n        if (layer.above) this.dom.classList.add(\"cm-layer-above\");\n        if (layer.class) this.dom.classList.add(layer.class);\n        this.scale();\n        this.dom.setAttribute(\"aria-hidden\", \"true\");\n        this.setOrder(view.state);\n        view.requestMeasure(this.measureReq);\n        if (layer.mount) layer.mount(this.dom, view);\n    }\n    update(update) {\n        if (update.startState.facet(layerOrder) != update.state.facet(layerOrder)) this.setOrder(update.state);\n        if (this.layer.update(update, this.dom) || update.geometryChanged) {\n            this.scale();\n            update.view.requestMeasure(this.measureReq);\n        }\n    }\n    setOrder(state) {\n        let pos = 0, order = state.facet(layerOrder);\n        while(pos < order.length && order[pos] != this.layer)pos++;\n        this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - pos);\n    }\n    measure() {\n        return this.layer.markers(this.view);\n    }\n    scale() {\n        let { scaleX, scaleY } = this.view;\n        if (scaleX != this.scaleX || scaleY != this.scaleY) {\n            this.scaleX = scaleX;\n            this.scaleY = scaleY;\n            this.dom.style.transform = `scale(${1 / scaleX}, ${1 / scaleY})`;\n        }\n    }\n    draw(markers) {\n        if (markers.length != this.drawn.length || markers.some((p, i)=>!sameMarker(p, this.drawn[i]))) {\n            let old = this.dom.firstChild, oldI = 0;\n            for (let marker of markers){\n                if (marker.update && old && marker.constructor && this.drawn[oldI].constructor && marker.update(old, this.drawn[oldI])) {\n                    old = old.nextSibling;\n                    oldI++;\n                } else {\n                    this.dom.insertBefore(marker.draw(), old);\n                }\n            }\n            while(old){\n                let next = old.nextSibling;\n                old.remove();\n                old = next;\n            }\n            this.drawn = markers;\n        }\n    }\n    destroy() {\n        if (this.layer.destroy) this.layer.destroy(this.dom, this.view);\n        this.dom.remove();\n    }\n}\nconst layerOrder = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\n/**\nDefine a layer.\n*/ function layer(config) {\n    return [\n        ViewPlugin.define((v)=>new LayerView(v, config)),\n        layerOrder.of(config)\n    ];\n}\nconst CanHidePrimary = !browser.ios; // FIXME test IE\nconst selectionConfig = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    combine (configs) {\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.combineConfig)(configs, {\n            cursorBlinkRate: 1200,\n            drawRangeCursor: true\n        }, {\n            cursorBlinkRate: (a, b)=>Math.min(a, b),\n            drawRangeCursor: (a, b)=>a || b\n        });\n    }\n});\n/**\nReturns an extension that hides the browser's native selection and\ncursor, replacing the selection with a background behind the text\n(with the `cm-selectionBackground` class), and the\ncursors with elements overlaid over the code (using\n`cm-cursor-primary` and `cm-cursor-secondary`).\n\nThis allows the editor to display secondary selection ranges, and\ntends to produce a type of selection more in line with that users\nexpect in a text editor (the native selection styling will often\nleave gaps between lines and won't fill the horizontal space after\na line when the selection continues past it).\n\nIt does have a performance cost, in that it requires an extra DOM\nlayout cycle for many updates (the selection is drawn based on DOM\nlayout information that's only available after laying out the\ncontent).\n*/ function drawSelection(config = {}) {\n    return [\n        selectionConfig.of(config),\n        cursorLayer,\n        selectionLayer,\n        hideNativeSelection,\n        nativeSelectionHidden.of(true)\n    ];\n}\n/**\nRetrieve the [`drawSelection`](https://codemirror.net/6/docs/ref/#view.drawSelection) configuration\nfor this state. (Note that this will return a set of defaults even\nif `drawSelection` isn't enabled.)\n*/ function getDrawSelectionConfig(state) {\n    return state.facet(selectionConfig);\n}\nfunction configChanged(update) {\n    return update.startState.facet(selectionConfig) != update.state.facet(selectionConfig);\n}\nconst cursorLayer = /*@__PURE__*/ layer({\n    above: true,\n    markers (view) {\n        let { state } = view, conf = state.facet(selectionConfig);\n        let cursors = [];\n        for (let r of state.selection.ranges){\n            let prim = r == state.selection.main;\n            if (r.empty ? !prim || CanHidePrimary : conf.drawRangeCursor) {\n                let className = prim ? \"cm-cursor cm-cursor-primary\" : \"cm-cursor cm-cursor-secondary\";\n                let cursor = r.empty ? r : _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(r.head, r.head > r.anchor ? -1 : 1);\n                for (let piece of RectangleMarker.forRange(view, className, cursor))cursors.push(piece);\n            }\n        }\n        return cursors;\n    },\n    update (update, dom) {\n        if (update.transactions.some((tr)=>tr.selection)) dom.style.animationName = dom.style.animationName == \"cm-blink\" ? \"cm-blink2\" : \"cm-blink\";\n        let confChange = configChanged(update);\n        if (confChange) setBlinkRate(update.state, dom);\n        return update.docChanged || update.selectionSet || confChange;\n    },\n    mount (dom, view) {\n        setBlinkRate(view.state, dom);\n    },\n    class: \"cm-cursorLayer\"\n});\nfunction setBlinkRate(state, dom) {\n    dom.style.animationDuration = state.facet(selectionConfig).cursorBlinkRate + \"ms\";\n}\nconst selectionLayer = /*@__PURE__*/ layer({\n    above: false,\n    markers (view) {\n        return view.state.selection.ranges.map((r)=>r.empty ? [] : RectangleMarker.forRange(view, \"cm-selectionBackground\", r)).reduce((a, b)=>a.concat(b));\n    },\n    update (update, dom) {\n        return update.docChanged || update.selectionSet || update.viewportChanged || configChanged(update);\n    },\n    class: \"cm-selectionLayer\"\n});\nconst themeSpec = {\n    \".cm-line\": {\n        \"& ::selection\": {\n            backgroundColor: \"transparent !important\"\n        },\n        \"&::selection\": {\n            backgroundColor: \"transparent !important\"\n        }\n    }\n};\nif (CanHidePrimary) {\n    themeSpec[\".cm-line\"].caretColor = \"transparent !important\";\n    themeSpec[\".cm-content\"] = {\n        caretColor: \"transparent !important\"\n    };\n}\nconst hideNativeSelection = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Prec.highest(/*@__PURE__*/ EditorView.theme(themeSpec));\nconst setDropCursorPos = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.define({\n    map (pos, mapping) {\n        return pos == null ? null : mapping.mapPos(pos);\n    }\n});\nconst dropCursorPos = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateField.define({\n    create () {\n        return null;\n    },\n    update (pos, tr) {\n        if (pos != null) pos = tr.changes.mapPos(pos);\n        return tr.effects.reduce((pos, e)=>e.is(setDropCursorPos) ? e.value : pos, pos);\n    }\n});\nconst drawDropCursor = /*@__PURE__*/ ViewPlugin.fromClass(class {\n    constructor(view){\n        this.view = view;\n        this.cursor = null;\n        this.measureReq = {\n            read: this.readPos.bind(this),\n            write: this.drawCursor.bind(this)\n        };\n    }\n    update(update) {\n        var _a;\n        let cursorPos = update.state.field(dropCursorPos);\n        if (cursorPos == null) {\n            if (this.cursor != null) {\n                (_a = this.cursor) === null || _a === void 0 ? void 0 : _a.remove();\n                this.cursor = null;\n            }\n        } else {\n            if (!this.cursor) {\n                this.cursor = this.view.scrollDOM.appendChild(document.createElement(\"div\"));\n                this.cursor.className = \"cm-dropCursor\";\n            }\n            if (update.startState.field(dropCursorPos) != cursorPos || update.docChanged || update.geometryChanged) this.view.requestMeasure(this.measureReq);\n        }\n    }\n    readPos() {\n        let { view } = this;\n        let pos = view.state.field(dropCursorPos);\n        let rect = pos != null && view.coordsAtPos(pos);\n        if (!rect) return null;\n        let outer = view.scrollDOM.getBoundingClientRect();\n        return {\n            left: rect.left - outer.left + view.scrollDOM.scrollLeft * view.scaleX,\n            top: rect.top - outer.top + view.scrollDOM.scrollTop * view.scaleY,\n            height: rect.bottom - rect.top\n        };\n    }\n    drawCursor(pos) {\n        if (this.cursor) {\n            let { scaleX, scaleY } = this.view;\n            if (pos) {\n                this.cursor.style.left = pos.left / scaleX + \"px\";\n                this.cursor.style.top = pos.top / scaleY + \"px\";\n                this.cursor.style.height = pos.height / scaleY + \"px\";\n            } else {\n                this.cursor.style.left = \"-100000px\";\n            }\n        }\n    }\n    destroy() {\n        if (this.cursor) this.cursor.remove();\n    }\n    setDropPos(pos) {\n        if (this.view.state.field(dropCursorPos) != pos) this.view.dispatch({\n            effects: setDropCursorPos.of(pos)\n        });\n    }\n}, {\n    eventObservers: {\n        dragover (event) {\n            this.setDropPos(this.view.posAtCoords({\n                x: event.clientX,\n                y: event.clientY\n            }));\n        },\n        dragleave (event) {\n            if (event.target == this.view.contentDOM || !this.view.contentDOM.contains(event.relatedTarget)) this.setDropPos(null);\n        },\n        dragend () {\n            this.setDropPos(null);\n        },\n        drop () {\n            this.setDropPos(null);\n        }\n    }\n});\n/**\nDraws a cursor at the current drop position when something is\ndragged over the editor.\n*/ function dropCursor() {\n    return [\n        dropCursorPos,\n        drawDropCursor\n    ];\n}\nfunction iterMatches(doc, re, from, to, f) {\n    re.lastIndex = 0;\n    for(let cursor = doc.iterRange(from, to), pos = from, m; !cursor.next().done; pos += cursor.value.length){\n        if (!cursor.lineBreak) while(m = re.exec(cursor.value))f(pos + m.index, m);\n    }\n}\nfunction matchRanges(view, maxLength) {\n    let visible = view.visibleRanges;\n    if (visible.length == 1 && visible[0].from == view.viewport.from && visible[0].to == view.viewport.to) return visible;\n    let result = [];\n    for (let { from, to } of visible){\n        from = Math.max(view.state.doc.lineAt(from).from, from - maxLength);\n        to = Math.min(view.state.doc.lineAt(to).to, to + maxLength);\n        if (result.length && result[result.length - 1].to >= from) result[result.length - 1].to = to;\n        else result.push({\n            from,\n            to\n        });\n    }\n    return result;\n}\n/**\nHelper class used to make it easier to maintain decorations on\nvisible code that matches a given regular expression. To be used\nin a [view plugin](https://codemirror.net/6/docs/ref/#view.ViewPlugin). Instances of this object\nrepresent a matching configuration.\n*/ class MatchDecorator {\n    /**\n    Create a decorator.\n    */ constructor(config){\n        const { regexp, decoration, decorate, boundary, maxLength = 1000 } = config;\n        if (!regexp.global) throw new RangeError(\"The regular expression given to MatchDecorator should have its 'g' flag set\");\n        this.regexp = regexp;\n        if (decorate) {\n            this.addMatch = (match, view, from, add)=>decorate(add, from, from + match[0].length, match, view);\n        } else if (typeof decoration == \"function\") {\n            this.addMatch = (match, view, from, add)=>{\n                let deco = decoration(match, view, from);\n                if (deco) add(from, from + match[0].length, deco);\n            };\n        } else if (decoration) {\n            this.addMatch = (match, _view, from, add)=>add(from, from + match[0].length, decoration);\n        } else {\n            throw new RangeError(\"Either 'decorate' or 'decoration' should be provided to MatchDecorator\");\n        }\n        this.boundary = boundary;\n        this.maxLength = maxLength;\n    }\n    /**\n    Compute the full set of decorations for matches in the given\n    view's viewport. You'll want to call this when initializing your\n    plugin.\n    */ createDeco(view) {\n        let build = new _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSetBuilder(), add = build.add.bind(build);\n        for (let { from, to } of matchRanges(view, this.maxLength))iterMatches(view.state.doc, this.regexp, from, to, (from, m)=>this.addMatch(m, view, from, add));\n        return build.finish();\n    }\n    /**\n    Update a set of decorations for a view update. `deco` _must_ be\n    the set of decorations produced by _this_ `MatchDecorator` for\n    the view state before the update.\n    */ updateDeco(update, deco) {\n        let changeFrom = 1e9, changeTo = -1;\n        if (update.docChanged) update.changes.iterChanges((_f, _t, from, to)=>{\n            if (to > update.view.viewport.from && from < update.view.viewport.to) {\n                changeFrom = Math.min(from, changeFrom);\n                changeTo = Math.max(to, changeTo);\n            }\n        });\n        if (update.viewportChanged || changeTo - changeFrom > 1000) return this.createDeco(update.view);\n        if (changeTo > -1) return this.updateRange(update.view, deco.map(update.changes), changeFrom, changeTo);\n        return deco;\n    }\n    updateRange(view, deco, updateFrom, updateTo) {\n        for (let r of view.visibleRanges){\n            let from = Math.max(r.from, updateFrom), to = Math.min(r.to, updateTo);\n            if (to > from) {\n                let fromLine = view.state.doc.lineAt(from), toLine = fromLine.to < to ? view.state.doc.lineAt(to) : fromLine;\n                let start = Math.max(r.from, fromLine.from), end = Math.min(r.to, toLine.to);\n                if (this.boundary) {\n                    for(; from > fromLine.from; from--)if (this.boundary.test(fromLine.text[from - 1 - fromLine.from])) {\n                        start = from;\n                        break;\n                    }\n                    for(; to < toLine.to; to++)if (this.boundary.test(toLine.text[to - toLine.from])) {\n                        end = to;\n                        break;\n                    }\n                }\n                let ranges = [], m;\n                let add = (from, to, deco)=>ranges.push(deco.range(from, to));\n                if (fromLine == toLine) {\n                    this.regexp.lastIndex = start - fromLine.from;\n                    while((m = this.regexp.exec(fromLine.text)) && m.index < end - fromLine.from)this.addMatch(m, view, m.index + fromLine.from, add);\n                } else {\n                    iterMatches(view.state.doc, this.regexp, start, end, (from, m)=>this.addMatch(m, view, from, add));\n                }\n                deco = deco.update({\n                    filterFrom: start,\n                    filterTo: end,\n                    filter: (from, to)=>from < start || to > end,\n                    add: ranges\n                });\n            }\n        }\n        return deco;\n    }\n}\nconst UnicodeRegexpSupport = /x/.unicode != null ? \"gu\" : \"g\";\nconst Specials = /*@__PURE__*/ new RegExp(\"[\\x00-\\b\\n-\\x1f\\x7f-\\x9f\\xad؜​‎‏\\u2028\\u2029‭‮⁦⁧⁩\\uFEFF￹-￼]\", UnicodeRegexpSupport);\nconst Names = {\n    0: \"null\",\n    7: \"bell\",\n    8: \"backspace\",\n    10: \"newline\",\n    11: \"vertical tab\",\n    13: \"carriage return\",\n    27: \"escape\",\n    8203: \"zero width space\",\n    8204: \"zero width non-joiner\",\n    8205: \"zero width joiner\",\n    8206: \"left-to-right mark\",\n    8207: \"right-to-left mark\",\n    8232: \"line separator\",\n    8237: \"left-to-right override\",\n    8238: \"right-to-left override\",\n    8294: \"left-to-right isolate\",\n    8295: \"right-to-left isolate\",\n    8297: \"pop directional isolate\",\n    8233: \"paragraph separator\",\n    65279: \"zero width no-break space\",\n    65532: \"object replacement\"\n};\nlet _supportsTabSize = null;\nfunction supportsTabSize() {\n    var _a;\n    if (_supportsTabSize == null && typeof document != \"undefined\" && document.body) {\n        let styles = document.body.style;\n        _supportsTabSize = ((_a = styles.tabSize) !== null && _a !== void 0 ? _a : styles.MozTabSize) != null;\n    }\n    return _supportsTabSize || false;\n}\nconst specialCharConfig = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    combine (configs) {\n        let config = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.combineConfig)(configs, {\n            render: null,\n            specialChars: Specials,\n            addSpecialChars: null\n        });\n        if (config.replaceTabs = !supportsTabSize()) config.specialChars = new RegExp(\"\t|\" + config.specialChars.source, UnicodeRegexpSupport);\n        if (config.addSpecialChars) config.specialChars = new RegExp(config.specialChars.source + \"|\" + config.addSpecialChars.source, UnicodeRegexpSupport);\n        return config;\n    }\n});\n/**\nReturns an extension that installs highlighting of special\ncharacters.\n*/ function highlightSpecialChars(/**\nConfiguration options.\n*/ config = {}) {\n    return [\n        specialCharConfig.of(config),\n        specialCharPlugin()\n    ];\n}\nlet _plugin = null;\nfunction specialCharPlugin() {\n    return _plugin || (_plugin = ViewPlugin.fromClass(class {\n        constructor(view){\n            this.view = view;\n            this.decorations = Decoration.none;\n            this.decorationCache = Object.create(null);\n            this.decorator = this.makeDecorator(view.state.facet(specialCharConfig));\n            this.decorations = this.decorator.createDeco(view);\n        }\n        makeDecorator(conf) {\n            return new MatchDecorator({\n                regexp: conf.specialChars,\n                decoration: (m, view, pos)=>{\n                    let { doc } = view.state;\n                    let code = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.codePointAt)(m[0], 0);\n                    if (code == 9) {\n                        let line = doc.lineAt(pos);\n                        let size = view.state.tabSize, col = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.countColumn)(line.text, size, pos - line.from);\n                        return Decoration.replace({\n                            widget: new TabWidget((size - col % size) * this.view.defaultCharacterWidth / this.view.scaleX)\n                        });\n                    }\n                    return this.decorationCache[code] || (this.decorationCache[code] = Decoration.replace({\n                        widget: new SpecialCharWidget(conf, code)\n                    }));\n                },\n                boundary: conf.replaceTabs ? undefined : /[^]/\n            });\n        }\n        update(update) {\n            let conf = update.state.facet(specialCharConfig);\n            if (update.startState.facet(specialCharConfig) != conf) {\n                this.decorator = this.makeDecorator(conf);\n                this.decorations = this.decorator.createDeco(update.view);\n            } else {\n                this.decorations = this.decorator.updateDeco(update, this.decorations);\n            }\n        }\n    }, {\n        decorations: (v)=>v.decorations\n    }));\n}\nconst DefaultPlaceholder = \"•\";\n// Assigns placeholder characters from the Control Pictures block to\n// ASCII control characters\nfunction placeholder$1(code) {\n    if (code >= 32) return DefaultPlaceholder;\n    if (code == 10) return \"␤\";\n    return String.fromCharCode(9216 + code);\n}\nclass SpecialCharWidget extends WidgetType {\n    constructor(options, code){\n        super();\n        this.options = options;\n        this.code = code;\n    }\n    eq(other) {\n        return other.code == this.code;\n    }\n    toDOM(view) {\n        let ph = placeholder$1(this.code);\n        let desc = view.state.phrase(\"Control character\") + \" \" + (Names[this.code] || \"0x\" + this.code.toString(16));\n        let custom = this.options.render && this.options.render(this.code, desc, ph);\n        if (custom) return custom;\n        let span = document.createElement(\"span\");\n        span.textContent = ph;\n        span.title = desc;\n        span.setAttribute(\"aria-label\", desc);\n        span.className = \"cm-specialChar\";\n        return span;\n    }\n    ignoreEvent() {\n        return false;\n    }\n}\nclass TabWidget extends WidgetType {\n    constructor(width){\n        super();\n        this.width = width;\n    }\n    eq(other) {\n        return other.width == this.width;\n    }\n    toDOM() {\n        let span = document.createElement(\"span\");\n        span.textContent = \"\t\";\n        span.className = \"cm-tab\";\n        span.style.width = this.width + \"px\";\n        return span;\n    }\n    ignoreEvent() {\n        return false;\n    }\n}\nconst plugin = /*@__PURE__*/ ViewPlugin.fromClass(class {\n    constructor(){\n        this.height = 1000;\n        this.attrs = {\n            style: \"padding-bottom: 1000px\"\n        };\n    }\n    update(update) {\n        let { view } = update;\n        let height = view.viewState.editorHeight * view.scaleY - view.defaultLineHeight - view.documentPadding.top - 0.5;\n        if (height >= 0 && height != this.height) {\n            this.height = height;\n            this.attrs = {\n                style: `padding-bottom: ${height}px`\n            };\n        }\n    }\n});\n/**\nReturns an extension that makes sure the content has a bottom\nmargin equivalent to the height of the editor, minus one line\nheight, so that every line in the document can be scrolled to the\ntop of the editor.\n\nThis is only meaningful when the editor is scrollable, and should\nnot be enabled in editors that take the size of their content.\n*/ function scrollPastEnd() {\n    return [\n        plugin,\n        contentAttributes.of((view)=>{\n            var _a;\n            return ((_a = view.plugin(plugin)) === null || _a === void 0 ? void 0 : _a.attrs) || null;\n        })\n    ];\n}\n/**\nMark lines that have a cursor on them with the `\"cm-activeLine\"`\nDOM class.\n*/ function highlightActiveLine() {\n    return activeLineHighlighter;\n}\nconst lineDeco = /*@__PURE__*/ Decoration.line({\n    class: \"cm-activeLine\"\n});\nconst activeLineHighlighter = /*@__PURE__*/ ViewPlugin.fromClass(class {\n    constructor(view){\n        this.decorations = this.getDeco(view);\n    }\n    update(update) {\n        if (update.docChanged || update.selectionSet) this.decorations = this.getDeco(update.view);\n    }\n    getDeco(view) {\n        let lastLineStart = -1, deco = [];\n        for (let r of view.state.selection.ranges){\n            let line = view.lineBlockAt(r.head);\n            if (line.from > lastLineStart) {\n                deco.push(lineDeco.range(line.from));\n                lastLineStart = line.from;\n            }\n        }\n        return Decoration.set(deco);\n    }\n}, {\n    decorations: (v)=>v.decorations\n});\nclass Placeholder extends WidgetType {\n    constructor(content){\n        super();\n        this.content = content;\n    }\n    toDOM() {\n        let wrap = document.createElement(\"span\");\n        wrap.className = \"cm-placeholder\";\n        wrap.style.pointerEvents = \"none\";\n        wrap.appendChild(typeof this.content == \"string\" ? document.createTextNode(this.content) : this.content);\n        if (typeof this.content == \"string\") wrap.setAttribute(\"aria-label\", \"placeholder \" + this.content);\n        else wrap.setAttribute(\"aria-hidden\", \"true\");\n        return wrap;\n    }\n    coordsAt(dom) {\n        let rects = dom.firstChild ? clientRectsFor(dom.firstChild) : [];\n        if (!rects.length) return null;\n        let style = window.getComputedStyle(dom.parentNode);\n        let rect = flattenRect(rects[0], style.direction != \"rtl\");\n        let lineHeight = parseInt(style.lineHeight);\n        if (rect.bottom - rect.top > lineHeight * 1.5) return {\n            left: rect.left,\n            right: rect.right,\n            top: rect.top,\n            bottom: rect.top + lineHeight\n        };\n        return rect;\n    }\n    ignoreEvent() {\n        return false;\n    }\n}\n/**\nExtension that enables a placeholder—a piece of example content\nto show when the editor is empty.\n*/ function placeholder(content) {\n    return ViewPlugin.fromClass(class {\n        constructor(view){\n            this.view = view;\n            this.placeholder = content ? Decoration.set([\n                Decoration.widget({\n                    widget: new Placeholder(content),\n                    side: 1\n                }).range(0)\n            ]) : Decoration.none;\n        }\n        get decorations() {\n            return this.view.state.doc.length ? Decoration.none : this.placeholder;\n        }\n    }, {\n        decorations: (v)=>v.decorations\n    });\n}\n// Don't compute precise column positions for line offsets above this\n// (since it could get expensive). Assume offset==column for them.\nconst MaxOff = 2000;\nfunction rectangleFor(state, a, b) {\n    let startLine = Math.min(a.line, b.line), endLine = Math.max(a.line, b.line);\n    let ranges = [];\n    if (a.off > MaxOff || b.off > MaxOff || a.col < 0 || b.col < 0) {\n        let startOff = Math.min(a.off, b.off), endOff = Math.max(a.off, b.off);\n        for(let i = startLine; i <= endLine; i++){\n            let line = state.doc.line(i);\n            if (line.length <= endOff) ranges.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.range(line.from + startOff, line.to + endOff));\n        }\n    } else {\n        let startCol = Math.min(a.col, b.col), endCol = Math.max(a.col, b.col);\n        for(let i = startLine; i <= endLine; i++){\n            let line = state.doc.line(i);\n            let start = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.findColumn)(line.text, startCol, state.tabSize, true);\n            if (start < 0) {\n                ranges.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(line.to));\n            } else {\n                let end = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.findColumn)(line.text, endCol, state.tabSize);\n                ranges.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.range(line.from + start, line.from + end));\n            }\n        }\n    }\n    return ranges;\n}\nfunction absoluteColumn(view, x) {\n    let ref = view.coordsAtPos(view.viewport.from);\n    return ref ? Math.round(Math.abs((ref.left - x) / view.defaultCharacterWidth)) : -1;\n}\nfunction getPos(view, event) {\n    let offset = view.posAtCoords({\n        x: event.clientX,\n        y: event.clientY\n    }, false);\n    let line = view.state.doc.lineAt(offset), off = offset - line.from;\n    let col = off > MaxOff ? -1 : off == line.length ? absoluteColumn(view, event.clientX) : (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.countColumn)(line.text, view.state.tabSize, offset - line.from);\n    return {\n        line: line.number,\n        col,\n        off\n    };\n}\nfunction rectangleSelectionStyle(view, event) {\n    let start = getPos(view, event), startSel = view.state.selection;\n    if (!start) return null;\n    return {\n        update (update) {\n            if (update.docChanged) {\n                let newStart = update.changes.mapPos(update.startState.doc.line(start.line).from);\n                let newLine = update.state.doc.lineAt(newStart);\n                start = {\n                    line: newLine.number,\n                    col: start.col,\n                    off: Math.min(start.off, newLine.length)\n                };\n                startSel = startSel.map(update.changes);\n            }\n        },\n        get (event, _extend, multiple) {\n            let cur = getPos(view, event);\n            if (!cur) return startSel;\n            let ranges = rectangleFor(view.state, start, cur);\n            if (!ranges.length) return startSel;\n            if (multiple) return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.create(ranges.concat(startSel.ranges));\n            else return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.create(ranges);\n        }\n    };\n}\n/**\nCreate an extension that enables rectangular selections. By\ndefault, it will react to left mouse drag with the Alt key held\ndown. When such a selection occurs, the text within the rectangle\nthat was dragged over will be selected, as one selection\n[range](https://codemirror.net/6/docs/ref/#state.SelectionRange) per line.\n*/ function rectangularSelection(options) {\n    let filter = (options === null || options === void 0 ? void 0 : options.eventFilter) || ((e)=>e.altKey && e.button == 0);\n    return EditorView.mouseSelectionStyle.of((view, event)=>filter(event) ? rectangleSelectionStyle(view, event) : null);\n}\nconst keys = {\n    Alt: [\n        18,\n        (e)=>!!e.altKey\n    ],\n    Control: [\n        17,\n        (e)=>!!e.ctrlKey\n    ],\n    Shift: [\n        16,\n        (e)=>!!e.shiftKey\n    ],\n    Meta: [\n        91,\n        (e)=>!!e.metaKey\n    ]\n};\nconst showCrosshair = {\n    style: \"cursor: crosshair\"\n};\n/**\nReturns an extension that turns the pointer cursor into a\ncrosshair when a given modifier key, defaulting to Alt, is held\ndown. Can serve as a visual hint that rectangular selection is\ngoing to happen when paired with\n[`rectangularSelection`](https://codemirror.net/6/docs/ref/#view.rectangularSelection).\n*/ function crosshairCursor(options = {}) {\n    let [code, getter] = keys[options.key || \"Alt\"];\n    let plugin = ViewPlugin.fromClass(class {\n        constructor(view){\n            this.view = view;\n            this.isDown = false;\n        }\n        set(isDown) {\n            if (this.isDown != isDown) {\n                this.isDown = isDown;\n                this.view.update([]);\n            }\n        }\n    }, {\n        eventObservers: {\n            keydown (e) {\n                this.set(e.keyCode == code || getter(e));\n            },\n            keyup (e) {\n                if (e.keyCode == code || !getter(e)) this.set(false);\n            },\n            mousemove (e) {\n                this.set(getter(e));\n            }\n        }\n    });\n    return [\n        plugin,\n        EditorView.contentAttributes.of((view)=>{\n            var _a;\n            return ((_a = view.plugin(plugin)) === null || _a === void 0 ? void 0 : _a.isDown) ? showCrosshair : null;\n        })\n    ];\n}\nconst Outside = \"-10000px\";\nclass TooltipViewManager {\n    constructor(view, facet, createTooltipView){\n        this.facet = facet;\n        this.createTooltipView = createTooltipView;\n        this.input = view.state.facet(facet);\n        this.tooltips = this.input.filter((t)=>t);\n        this.tooltipViews = this.tooltips.map(createTooltipView);\n    }\n    update(update, above) {\n        var _a;\n        let input = update.state.facet(this.facet);\n        let tooltips = input.filter((x)=>x);\n        if (input === this.input) {\n            for (let t of this.tooltipViews)if (t.update) t.update(update);\n            return false;\n        }\n        let tooltipViews = [], newAbove = above ? [] : null;\n        for(let i = 0; i < tooltips.length; i++){\n            let tip = tooltips[i], known = -1;\n            if (!tip) continue;\n            for(let i = 0; i < this.tooltips.length; i++){\n                let other = this.tooltips[i];\n                if (other && other.create == tip.create) known = i;\n            }\n            if (known < 0) {\n                tooltipViews[i] = this.createTooltipView(tip);\n                if (newAbove) newAbove[i] = !!tip.above;\n            } else {\n                let tooltipView = tooltipViews[i] = this.tooltipViews[known];\n                if (newAbove) newAbove[i] = above[known];\n                if (tooltipView.update) tooltipView.update(update);\n            }\n        }\n        for (let t of this.tooltipViews)if (tooltipViews.indexOf(t) < 0) {\n            t.dom.remove();\n            (_a = t.destroy) === null || _a === void 0 ? void 0 : _a.call(t);\n        }\n        if (above) {\n            newAbove.forEach((val, i)=>above[i] = val);\n            above.length = newAbove.length;\n        }\n        this.input = input;\n        this.tooltips = tooltips;\n        this.tooltipViews = tooltipViews;\n        return true;\n    }\n}\n/**\nCreates an extension that configures tooltip behavior.\n*/ function tooltips(config = {}) {\n    return tooltipConfig.of(config);\n}\nfunction windowSpace(view) {\n    let { win } = view;\n    return {\n        top: 0,\n        left: 0,\n        bottom: win.innerHeight,\n        right: win.innerWidth\n    };\n}\nconst tooltipConfig = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    combine: (values)=>{\n        var _a, _b, _c;\n        return {\n            position: browser.ios ? \"absolute\" : ((_a = values.find((conf)=>conf.position)) === null || _a === void 0 ? void 0 : _a.position) || \"fixed\",\n            parent: ((_b = values.find((conf)=>conf.parent)) === null || _b === void 0 ? void 0 : _b.parent) || null,\n            tooltipSpace: ((_c = values.find((conf)=>conf.tooltipSpace)) === null || _c === void 0 ? void 0 : _c.tooltipSpace) || windowSpace\n        };\n    }\n});\nconst knownHeight = /*@__PURE__*/ new WeakMap();\nconst tooltipPlugin = /*@__PURE__*/ ViewPlugin.fromClass(class {\n    constructor(view){\n        this.view = view;\n        this.above = [];\n        this.inView = true;\n        this.madeAbsolute = false;\n        this.lastTransaction = 0;\n        this.measureTimeout = -1;\n        let config = view.state.facet(tooltipConfig);\n        this.position = config.position;\n        this.parent = config.parent;\n        this.classes = view.themeClasses;\n        this.createContainer();\n        this.measureReq = {\n            read: this.readMeasure.bind(this),\n            write: this.writeMeasure.bind(this),\n            key: this\n        };\n        this.manager = new TooltipViewManager(view, showTooltip, (t)=>this.createTooltip(t));\n        this.intersectionObserver = typeof IntersectionObserver == \"function\" ? new IntersectionObserver((entries)=>{\n            if (Date.now() > this.lastTransaction - 50 && entries.length > 0 && entries[entries.length - 1].intersectionRatio < 1) this.measureSoon();\n        }, {\n            threshold: [\n                1\n            ]\n        }) : null;\n        this.observeIntersection();\n        view.win.addEventListener(\"resize\", this.measureSoon = this.measureSoon.bind(this));\n        this.maybeMeasure();\n    }\n    createContainer() {\n        if (this.parent) {\n            this.container = document.createElement(\"div\");\n            this.container.style.position = \"relative\";\n            this.container.className = this.view.themeClasses;\n            this.parent.appendChild(this.container);\n        } else {\n            this.container = this.view.dom;\n        }\n    }\n    observeIntersection() {\n        if (this.intersectionObserver) {\n            this.intersectionObserver.disconnect();\n            for (let tooltip of this.manager.tooltipViews)this.intersectionObserver.observe(tooltip.dom);\n        }\n    }\n    measureSoon() {\n        if (this.measureTimeout < 0) this.measureTimeout = setTimeout(()=>{\n            this.measureTimeout = -1;\n            this.maybeMeasure();\n        }, 50);\n    }\n    update(update) {\n        if (update.transactions.length) this.lastTransaction = Date.now();\n        let updated = this.manager.update(update, this.above);\n        if (updated) this.observeIntersection();\n        let shouldMeasure = updated || update.geometryChanged;\n        let newConfig = update.state.facet(tooltipConfig);\n        if (newConfig.position != this.position && !this.madeAbsolute) {\n            this.position = newConfig.position;\n            for (let t of this.manager.tooltipViews)t.dom.style.position = this.position;\n            shouldMeasure = true;\n        }\n        if (newConfig.parent != this.parent) {\n            if (this.parent) this.container.remove();\n            this.parent = newConfig.parent;\n            this.createContainer();\n            for (let t of this.manager.tooltipViews)this.container.appendChild(t.dom);\n            shouldMeasure = true;\n        } else if (this.parent && this.view.themeClasses != this.classes) {\n            this.classes = this.container.className = this.view.themeClasses;\n        }\n        if (shouldMeasure) this.maybeMeasure();\n    }\n    createTooltip(tooltip) {\n        let tooltipView = tooltip.create(this.view);\n        tooltipView.dom.classList.add(\"cm-tooltip\");\n        if (tooltip.arrow && !tooltipView.dom.querySelector(\".cm-tooltip > .cm-tooltip-arrow\")) {\n            let arrow = document.createElement(\"div\");\n            arrow.className = \"cm-tooltip-arrow\";\n            tooltipView.dom.appendChild(arrow);\n        }\n        tooltipView.dom.style.position = this.position;\n        tooltipView.dom.style.top = Outside;\n        tooltipView.dom.style.left = \"0px\";\n        this.container.appendChild(tooltipView.dom);\n        if (tooltipView.mount) tooltipView.mount(this.view);\n        return tooltipView;\n    }\n    destroy() {\n        var _a, _b;\n        this.view.win.removeEventListener(\"resize\", this.measureSoon);\n        for (let tooltipView of this.manager.tooltipViews){\n            tooltipView.dom.remove();\n            (_a = tooltipView.destroy) === null || _a === void 0 ? void 0 : _a.call(tooltipView);\n        }\n        if (this.parent) this.container.remove();\n        (_b = this.intersectionObserver) === null || _b === void 0 ? void 0 : _b.disconnect();\n        clearTimeout(this.measureTimeout);\n    }\n    readMeasure() {\n        let editor = this.view.dom.getBoundingClientRect();\n        let scaleX = 1, scaleY = 1, makeAbsolute = false;\n        if (this.position == \"fixed\" && this.manager.tooltipViews.length) {\n            let { dom } = this.manager.tooltipViews[0];\n            if (browser.gecko) {\n                // Firefox sets the element's `offsetParent` to the\n                // transformed element when a transform interferes with fixed\n                // positioning.\n                makeAbsolute = dom.offsetParent != this.container.ownerDocument.body;\n            } else {\n                // On other browsers, we have to awkwardly try and use other\n                // information to detect a transform.\n                if (this.view.scaleX != 1 || this.view.scaleY != 1) {\n                    makeAbsolute = true;\n                } else if (dom.style.top == Outside && dom.style.left == \"0px\") {\n                    let rect = dom.getBoundingClientRect();\n                    makeAbsolute = Math.abs(rect.top + 10000) > 1 || Math.abs(rect.left) > 1;\n                }\n            }\n        }\n        if (makeAbsolute || this.position == \"absolute\") {\n            if (this.parent) {\n                let rect = this.parent.getBoundingClientRect();\n                if (rect.width && rect.height) {\n                    scaleX = rect.width / this.parent.offsetWidth;\n                    scaleY = rect.height / this.parent.offsetHeight;\n                }\n            } else {\n                ({ scaleX, scaleY } = this.view.viewState);\n            }\n        }\n        return {\n            editor,\n            parent: this.parent ? this.container.getBoundingClientRect() : editor,\n            pos: this.manager.tooltips.map((t, i)=>{\n                let tv = this.manager.tooltipViews[i];\n                return tv.getCoords ? tv.getCoords(t.pos) : this.view.coordsAtPos(t.pos);\n            }),\n            size: this.manager.tooltipViews.map(({ dom })=>dom.getBoundingClientRect()),\n            space: this.view.state.facet(tooltipConfig).tooltipSpace(this.view),\n            scaleX,\n            scaleY,\n            makeAbsolute\n        };\n    }\n    writeMeasure(measured) {\n        var _a;\n        if (measured.makeAbsolute) {\n            this.madeAbsolute = true;\n            this.position = \"absolute\";\n            for (let t of this.manager.tooltipViews)t.dom.style.position = \"absolute\";\n        }\n        let { editor, space, scaleX, scaleY } = measured;\n        let others = [];\n        for(let i = 0; i < this.manager.tooltips.length; i++){\n            let tooltip = this.manager.tooltips[i], tView = this.manager.tooltipViews[i], { dom } = tView;\n            let pos = measured.pos[i], size = measured.size[i];\n            // Hide tooltips that are outside of the editor.\n            if (!pos || pos.bottom <= Math.max(editor.top, space.top) || pos.top >= Math.min(editor.bottom, space.bottom) || pos.right < Math.max(editor.left, space.left) - .1 || pos.left > Math.min(editor.right, space.right) + .1) {\n                dom.style.top = Outside;\n                continue;\n            }\n            let arrow = tooltip.arrow ? tView.dom.querySelector(\".cm-tooltip-arrow\") : null;\n            let arrowHeight = arrow ? 7 /* Arrow.Size */  : 0;\n            let width = size.right - size.left, height = (_a = knownHeight.get(tView)) !== null && _a !== void 0 ? _a : size.bottom - size.top;\n            let offset = tView.offset || noOffset, ltr = this.view.textDirection == Direction.LTR;\n            let left = size.width > space.right - space.left ? ltr ? space.left : space.right - size.width : ltr ? Math.min(pos.left - (arrow ? 14 /* Arrow.Offset */  : 0) + offset.x, space.right - width) : Math.max(space.left, pos.left - width + (arrow ? 14 /* Arrow.Offset */  : 0) - offset.x);\n            let above = this.above[i];\n            if (!tooltip.strictSide && (above ? pos.top - (size.bottom - size.top) - offset.y < space.top : pos.bottom + (size.bottom - size.top) + offset.y > space.bottom) && above == space.bottom - pos.bottom > pos.top - space.top) above = this.above[i] = !above;\n            let spaceVert = (above ? pos.top - space.top : space.bottom - pos.bottom) - arrowHeight;\n            if (spaceVert < height && tView.resize !== false) {\n                if (spaceVert < this.view.defaultLineHeight) {\n                    dom.style.top = Outside;\n                    continue;\n                }\n                knownHeight.set(tView, height);\n                dom.style.height = (height = spaceVert) / scaleY + \"px\";\n            } else if (dom.style.height) {\n                dom.style.height = \"\";\n            }\n            let top = above ? pos.top - height - arrowHeight - offset.y : pos.bottom + arrowHeight + offset.y;\n            let right = left + width;\n            if (tView.overlap !== true) {\n                for (let r of others)if (r.left < right && r.right > left && r.top < top + height && r.bottom > top) top = above ? r.top - height - 2 - arrowHeight : r.bottom + arrowHeight + 2;\n            }\n            if (this.position == \"absolute\") {\n                dom.style.top = (top - measured.parent.top) / scaleY + \"px\";\n                dom.style.left = (left - measured.parent.left) / scaleX + \"px\";\n            } else {\n                dom.style.top = top / scaleY + \"px\";\n                dom.style.left = left / scaleX + \"px\";\n            }\n            if (arrow) {\n                let arrowLeft = pos.left + (ltr ? offset.x : -offset.x) - (left + 14 /* Arrow.Offset */  - 7 /* Arrow.Size */ );\n                arrow.style.left = arrowLeft / scaleX + \"px\";\n            }\n            if (tView.overlap !== true) others.push({\n                left,\n                top,\n                right,\n                bottom: top + height\n            });\n            dom.classList.toggle(\"cm-tooltip-above\", above);\n            dom.classList.toggle(\"cm-tooltip-below\", !above);\n            if (tView.positioned) tView.positioned(measured.space);\n        }\n    }\n    maybeMeasure() {\n        if (this.manager.tooltips.length) {\n            if (this.view.inView) this.view.requestMeasure(this.measureReq);\n            if (this.inView != this.view.inView) {\n                this.inView = this.view.inView;\n                if (!this.inView) for (let tv of this.manager.tooltipViews)tv.dom.style.top = Outside;\n            }\n        }\n    }\n}, {\n    eventObservers: {\n        scroll () {\n            this.maybeMeasure();\n        }\n    }\n});\nconst baseTheme = /*@__PURE__*/ EditorView.baseTheme({\n    \".cm-tooltip\": {\n        zIndex: 100,\n        boxSizing: \"border-box\"\n    },\n    \"&light .cm-tooltip\": {\n        border: \"1px solid #bbb\",\n        backgroundColor: \"#f5f5f5\"\n    },\n    \"&light .cm-tooltip-section:not(:first-child)\": {\n        borderTop: \"1px solid #bbb\"\n    },\n    \"&dark .cm-tooltip\": {\n        backgroundColor: \"#333338\",\n        color: \"white\"\n    },\n    \".cm-tooltip-arrow\": {\n        height: `${7 /* Arrow.Size */ }px`,\n        width: `${7 /* Arrow.Size */  * 2}px`,\n        position: \"absolute\",\n        zIndex: -1,\n        overflow: \"hidden\",\n        \"&:before, &:after\": {\n            content: \"''\",\n            position: \"absolute\",\n            width: 0,\n            height: 0,\n            borderLeft: `${7 /* Arrow.Size */ }px solid transparent`,\n            borderRight: `${7 /* Arrow.Size */ }px solid transparent`\n        },\n        \".cm-tooltip-above &\": {\n            bottom: `-${7 /* Arrow.Size */ }px`,\n            \"&:before\": {\n                borderTop: `${7 /* Arrow.Size */ }px solid #bbb`\n            },\n            \"&:after\": {\n                borderTop: `${7 /* Arrow.Size */ }px solid #f5f5f5`,\n                bottom: \"1px\"\n            }\n        },\n        \".cm-tooltip-below &\": {\n            top: `-${7 /* Arrow.Size */ }px`,\n            \"&:before\": {\n                borderBottom: `${7 /* Arrow.Size */ }px solid #bbb`\n            },\n            \"&:after\": {\n                borderBottom: `${7 /* Arrow.Size */ }px solid #f5f5f5`,\n                top: \"1px\"\n            }\n        }\n    },\n    \"&dark .cm-tooltip .cm-tooltip-arrow\": {\n        \"&:before\": {\n            borderTopColor: \"#333338\",\n            borderBottomColor: \"#333338\"\n        },\n        \"&:after\": {\n            borderTopColor: \"transparent\",\n            borderBottomColor: \"transparent\"\n        }\n    }\n});\nconst noOffset = {\n    x: 0,\n    y: 0\n};\n/**\nFacet to which an extension can add a value to show a tooltip.\n*/ const showTooltip = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    enables: [\n        tooltipPlugin,\n        baseTheme\n    ]\n});\nconst showHoverTooltip = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nclass HoverTooltipHost {\n    // Needs to be static so that host tooltip instances always match\n    static create(view) {\n        return new HoverTooltipHost(view);\n    }\n    constructor(view){\n        this.view = view;\n        this.mounted = false;\n        this.dom = document.createElement(\"div\");\n        this.dom.classList.add(\"cm-tooltip-hover\");\n        this.manager = new TooltipViewManager(view, showHoverTooltip, (t)=>this.createHostedView(t));\n    }\n    createHostedView(tooltip) {\n        let hostedView = tooltip.create(this.view);\n        hostedView.dom.classList.add(\"cm-tooltip-section\");\n        this.dom.appendChild(hostedView.dom);\n        if (this.mounted && hostedView.mount) hostedView.mount(this.view);\n        return hostedView;\n    }\n    mount(view) {\n        for (let hostedView of this.manager.tooltipViews){\n            if (hostedView.mount) hostedView.mount(view);\n        }\n        this.mounted = true;\n    }\n    positioned(space) {\n        for (let hostedView of this.manager.tooltipViews){\n            if (hostedView.positioned) hostedView.positioned(space);\n        }\n    }\n    update(update) {\n        this.manager.update(update);\n    }\n    destroy() {\n        var _a;\n        for (let t of this.manager.tooltipViews)(_a = t.destroy) === null || _a === void 0 ? void 0 : _a.call(t);\n    }\n    passProp(name) {\n        let value = undefined;\n        for (let view of this.manager.tooltipViews){\n            let given = view[name];\n            if (given !== undefined) {\n                if (value === undefined) value = given;\n                else if (value !== given) return undefined;\n            }\n        }\n        return value;\n    }\n    get offset() {\n        return this.passProp(\"offset\");\n    }\n    get getCoords() {\n        return this.passProp(\"getCoords\");\n    }\n    get overlap() {\n        return this.passProp(\"overlap\");\n    }\n    get resize() {\n        return this.passProp(\"resize\");\n    }\n}\nconst showHoverTooltipHost = /*@__PURE__*/ showTooltip.compute([\n    showHoverTooltip\n], (state)=>{\n    let tooltips = state.facet(showHoverTooltip).filter((t)=>t);\n    if (tooltips.length === 0) return null;\n    return {\n        pos: Math.min(...tooltips.map((t)=>t.pos)),\n        end: Math.max(...tooltips.map((t)=>{\n            var _a;\n            return (_a = t.end) !== null && _a !== void 0 ? _a : t.pos;\n        })),\n        create: HoverTooltipHost.create,\n        above: tooltips[0].above,\n        arrow: tooltips.some((t)=>t.arrow)\n    };\n});\nclass HoverPlugin {\n    constructor(view, source, field, setHover, hoverTime){\n        this.view = view;\n        this.source = source;\n        this.field = field;\n        this.setHover = setHover;\n        this.hoverTime = hoverTime;\n        this.hoverTimeout = -1;\n        this.restartTimeout = -1;\n        this.pending = null;\n        this.lastMove = {\n            x: 0,\n            y: 0,\n            target: view.dom,\n            time: 0\n        };\n        this.checkHover = this.checkHover.bind(this);\n        view.dom.addEventListener(\"mouseleave\", this.mouseleave = this.mouseleave.bind(this));\n        view.dom.addEventListener(\"mousemove\", this.mousemove = this.mousemove.bind(this));\n    }\n    update() {\n        if (this.pending) {\n            this.pending = null;\n            clearTimeout(this.restartTimeout);\n            this.restartTimeout = setTimeout(()=>this.startHover(), 20);\n        }\n    }\n    get active() {\n        return this.view.state.field(this.field);\n    }\n    checkHover() {\n        this.hoverTimeout = -1;\n        if (this.active) return;\n        let hovered = Date.now() - this.lastMove.time;\n        if (hovered < this.hoverTime) this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - hovered);\n        else this.startHover();\n    }\n    startHover() {\n        clearTimeout(this.restartTimeout);\n        let { view, lastMove } = this;\n        let desc = view.docView.nearest(lastMove.target);\n        if (!desc) return;\n        let pos, side = 1;\n        if (desc instanceof WidgetView) {\n            pos = desc.posAtStart;\n        } else {\n            pos = view.posAtCoords(lastMove);\n            if (pos == null) return;\n            let posCoords = view.coordsAtPos(pos);\n            if (!posCoords || lastMove.y < posCoords.top || lastMove.y > posCoords.bottom || lastMove.x < posCoords.left - view.defaultCharacterWidth || lastMove.x > posCoords.right + view.defaultCharacterWidth) return;\n            let bidi = view.bidiSpans(view.state.doc.lineAt(pos)).find((s)=>s.from <= pos && s.to >= pos);\n            let rtl = bidi && bidi.dir == Direction.RTL ? -1 : 1;\n            side = lastMove.x < posCoords.left ? -rtl : rtl;\n        }\n        let open = this.source(view, pos, side);\n        if (open === null || open === void 0 ? void 0 : open.then) {\n            let pending = this.pending = {\n                pos\n            };\n            open.then((result)=>{\n                if (this.pending == pending) {\n                    this.pending = null;\n                    if (result) view.dispatch({\n                        effects: this.setHover.of(result)\n                    });\n                }\n            }, (e)=>logException(view.state, e, \"hover tooltip\"));\n        } else if (open) {\n            view.dispatch({\n                effects: this.setHover.of(open)\n            });\n        }\n    }\n    get tooltip() {\n        let plugin = this.view.plugin(tooltipPlugin);\n        let index = plugin ? plugin.manager.tooltips.findIndex((t)=>t.create == HoverTooltipHost.create) : -1;\n        return index > -1 ? plugin.manager.tooltipViews[index] : null;\n    }\n    mousemove(event) {\n        var _a;\n        this.lastMove = {\n            x: event.clientX,\n            y: event.clientY,\n            target: event.target,\n            time: Date.now()\n        };\n        if (this.hoverTimeout < 0) this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime);\n        let { active, tooltip } = this;\n        if (active && tooltip && !isInTooltip(tooltip.dom, event) || this.pending) {\n            let { pos } = active || this.pending, end = (_a = active === null || active === void 0 ? void 0 : active.end) !== null && _a !== void 0 ? _a : pos;\n            if (pos == end ? this.view.posAtCoords(this.lastMove) != pos : !isOverRange(this.view, pos, end, event.clientX, event.clientY)) {\n                this.view.dispatch({\n                    effects: this.setHover.of(null)\n                });\n                this.pending = null;\n            }\n        }\n    }\n    mouseleave(event) {\n        clearTimeout(this.hoverTimeout);\n        this.hoverTimeout = -1;\n        let { active } = this;\n        if (active) {\n            let { tooltip } = this;\n            let inTooltip = tooltip && tooltip.dom.contains(event.relatedTarget);\n            if (!inTooltip) this.view.dispatch({\n                effects: this.setHover.of(null)\n            });\n            else this.watchTooltipLeave(tooltip.dom);\n        }\n    }\n    watchTooltipLeave(tooltip) {\n        let watch = (event)=>{\n            tooltip.removeEventListener(\"mouseleave\", watch);\n            if (this.active && !this.view.dom.contains(event.relatedTarget)) this.view.dispatch({\n                effects: this.setHover.of(null)\n            });\n        };\n        tooltip.addEventListener(\"mouseleave\", watch);\n    }\n    destroy() {\n        clearTimeout(this.hoverTimeout);\n        this.view.dom.removeEventListener(\"mouseleave\", this.mouseleave);\n        this.view.dom.removeEventListener(\"mousemove\", this.mousemove);\n    }\n}\nconst tooltipMargin = 4;\nfunction isInTooltip(tooltip, event) {\n    let rect = tooltip.getBoundingClientRect();\n    return event.clientX >= rect.left - tooltipMargin && event.clientX <= rect.right + tooltipMargin && event.clientY >= rect.top - tooltipMargin && event.clientY <= rect.bottom + tooltipMargin;\n}\nfunction isOverRange(view, from, to, x, y, margin) {\n    let rect = view.scrollDOM.getBoundingClientRect();\n    let docBottom = view.documentTop + view.documentPadding.top + view.contentHeight;\n    if (rect.left > x || rect.right < x || rect.top > y || Math.min(rect.bottom, docBottom) < y) return false;\n    let pos = view.posAtCoords({\n        x,\n        y\n    }, false);\n    return pos >= from && pos <= to;\n}\n/**\nSet up a hover tooltip, which shows up when the pointer hovers\nover ranges of text. The callback is called when the mouse hovers\nover the document text. It should, if there is a tooltip\nassociated with position `pos`, return the tooltip description\n(either directly or in a promise). The `side` argument indicates\non which side of the position the pointer is—it will be -1 if the\npointer is before the position, 1 if after the position.\n\nNote that all hover tooltips are hosted within a single tooltip\ncontainer element. This allows multiple tooltips over the same\nrange to be \"merged\" together without overlapping.\n*/ function hoverTooltip(source, options = {}) {\n    let setHover = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.define();\n    let hoverState = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateField.define({\n        create () {\n            return null;\n        },\n        update (value, tr) {\n            if (value && (options.hideOnChange && (tr.docChanged || tr.selection) || options.hideOn && options.hideOn(tr, value))) return null;\n            if (value && tr.docChanged) {\n                let newPos = tr.changes.mapPos(value.pos, -1, _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.MapMode.TrackDel);\n                if (newPos == null) return null;\n                let copy = Object.assign(Object.create(null), value);\n                copy.pos = newPos;\n                if (value.end != null) copy.end = tr.changes.mapPos(value.end);\n                value = copy;\n            }\n            for (let effect of tr.effects){\n                if (effect.is(setHover)) value = effect.value;\n                if (effect.is(closeHoverTooltipEffect)) value = null;\n            }\n            return value;\n        },\n        provide: (f)=>showHoverTooltip.from(f)\n    });\n    return [\n        hoverState,\n        ViewPlugin.define((view)=>new HoverPlugin(view, source, hoverState, setHover, options.hoverTime || 300 /* Hover.Time */ )),\n        showHoverTooltipHost\n    ];\n}\n/**\nGet the active tooltip view for a given tooltip, if available.\n*/ function getTooltip(view, tooltip) {\n    let plugin = view.plugin(tooltipPlugin);\n    if (!plugin) return null;\n    let found = plugin.manager.tooltips.indexOf(tooltip);\n    return found < 0 ? null : plugin.manager.tooltipViews[found];\n}\n/**\nReturns true if any hover tooltips are currently active.\n*/ function hasHoverTooltips(state) {\n    return state.facet(showHoverTooltip).some((x)=>x);\n}\nconst closeHoverTooltipEffect = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.define();\n/**\nTransaction effect that closes all hover tooltips.\n*/ const closeHoverTooltips = /*@__PURE__*/ closeHoverTooltipEffect.of(null);\n/**\nTell the tooltip extension to recompute the position of the active\ntooltips. This can be useful when something happens (such as a\nre-positioning or CSS change affecting the editor) that could\ninvalidate the existing tooltip positions.\n*/ function repositionTooltips(view) {\n    let plugin = view.plugin(tooltipPlugin);\n    if (plugin) plugin.maybeMeasure();\n}\nconst panelConfig = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    combine (configs) {\n        let topContainer, bottomContainer;\n        for (let c of configs){\n            topContainer = topContainer || c.topContainer;\n            bottomContainer = bottomContainer || c.bottomContainer;\n        }\n        return {\n            topContainer,\n            bottomContainer\n        };\n    }\n});\n/**\nConfigures the panel-managing extension.\n*/ function panels(config) {\n    return config ? [\n        panelConfig.of(config)\n    ] : [];\n}\n/**\nGet the active panel created by the given constructor, if any.\nThis can be useful when you need access to your panels' DOM\nstructure.\n*/ function getPanel(view, panel) {\n    let plugin = view.plugin(panelPlugin);\n    let index = plugin ? plugin.specs.indexOf(panel) : -1;\n    return index > -1 ? plugin.panels[index] : null;\n}\nconst panelPlugin = /*@__PURE__*/ ViewPlugin.fromClass(class {\n    constructor(view){\n        this.input = view.state.facet(showPanel);\n        this.specs = this.input.filter((s)=>s);\n        this.panels = this.specs.map((spec)=>spec(view));\n        let conf = view.state.facet(panelConfig);\n        this.top = new PanelGroup(view, true, conf.topContainer);\n        this.bottom = new PanelGroup(view, false, conf.bottomContainer);\n        this.top.sync(this.panels.filter((p)=>p.top));\n        this.bottom.sync(this.panels.filter((p)=>!p.top));\n        for (let p of this.panels){\n            p.dom.classList.add(\"cm-panel\");\n            if (p.mount) p.mount();\n        }\n    }\n    update(update) {\n        let conf = update.state.facet(panelConfig);\n        if (this.top.container != conf.topContainer) {\n            this.top.sync([]);\n            this.top = new PanelGroup(update.view, true, conf.topContainer);\n        }\n        if (this.bottom.container != conf.bottomContainer) {\n            this.bottom.sync([]);\n            this.bottom = new PanelGroup(update.view, false, conf.bottomContainer);\n        }\n        this.top.syncClasses();\n        this.bottom.syncClasses();\n        let input = update.state.facet(showPanel);\n        if (input != this.input) {\n            let specs = input.filter((x)=>x);\n            let panels = [], top = [], bottom = [], mount = [];\n            for (let spec of specs){\n                let known = this.specs.indexOf(spec), panel;\n                if (known < 0) {\n                    panel = spec(update.view);\n                    mount.push(panel);\n                } else {\n                    panel = this.panels[known];\n                    if (panel.update) panel.update(update);\n                }\n                panels.push(panel);\n                (panel.top ? top : bottom).push(panel);\n            }\n            this.specs = specs;\n            this.panels = panels;\n            this.top.sync(top);\n            this.bottom.sync(bottom);\n            for (let p of mount){\n                p.dom.classList.add(\"cm-panel\");\n                if (p.mount) p.mount();\n            }\n        } else {\n            for (let p of this.panels)if (p.update) p.update(update);\n        }\n    }\n    destroy() {\n        this.top.sync([]);\n        this.bottom.sync([]);\n    }\n}, {\n    provide: (plugin)=>EditorView.scrollMargins.of((view)=>{\n            let value = view.plugin(plugin);\n            return value && {\n                top: value.top.scrollMargin(),\n                bottom: value.bottom.scrollMargin()\n            };\n        })\n});\nclass PanelGroup {\n    constructor(view, top, container){\n        this.view = view;\n        this.top = top;\n        this.container = container;\n        this.dom = undefined;\n        this.classes = \"\";\n        this.panels = [];\n        this.syncClasses();\n    }\n    sync(panels) {\n        for (let p of this.panels)if (p.destroy && panels.indexOf(p) < 0) p.destroy();\n        this.panels = panels;\n        this.syncDOM();\n    }\n    syncDOM() {\n        if (this.panels.length == 0) {\n            if (this.dom) {\n                this.dom.remove();\n                this.dom = undefined;\n            }\n            return;\n        }\n        if (!this.dom) {\n            this.dom = document.createElement(\"div\");\n            this.dom.className = this.top ? \"cm-panels cm-panels-top\" : \"cm-panels cm-panels-bottom\";\n            this.dom.style[this.top ? \"top\" : \"bottom\"] = \"0\";\n            let parent = this.container || this.view.dom;\n            parent.insertBefore(this.dom, this.top ? parent.firstChild : null);\n        }\n        let curDOM = this.dom.firstChild;\n        for (let panel of this.panels){\n            if (panel.dom.parentNode == this.dom) {\n                while(curDOM != panel.dom)curDOM = rm(curDOM);\n                curDOM = curDOM.nextSibling;\n            } else {\n                this.dom.insertBefore(panel.dom, curDOM);\n            }\n        }\n        while(curDOM)curDOM = rm(curDOM);\n    }\n    scrollMargin() {\n        return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);\n    }\n    syncClasses() {\n        if (!this.container || this.classes == this.view.themeClasses) return;\n        for (let cls of this.classes.split(\" \"))if (cls) this.container.classList.remove(cls);\n        for (let cls of (this.classes = this.view.themeClasses).split(\" \"))if (cls) this.container.classList.add(cls);\n    }\n}\nfunction rm(node) {\n    let next = node.nextSibling;\n    node.remove();\n    return next;\n}\n/**\nOpening a panel is done by providing a constructor function for\nthe panel through this facet. (The panel is closed again when its\nconstructor is no longer provided.) Values of `null` are ignored.\n*/ const showPanel = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    enables: panelPlugin\n});\n/**\nA gutter marker represents a bit of information attached to a line\nin a specific gutter. Your own custom markers have to extend this\nclass.\n*/ class GutterMarker extends _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeValue {\n    /**\n    @internal\n    */ compare(other) {\n        return this == other || this.constructor == other.constructor && this.eq(other);\n    }\n    /**\n    Compare this marker to another marker of the same type.\n    */ eq(other) {\n        return false;\n    }\n    /**\n    Called if the marker has a `toDOM` method and its representation\n    was removed from a gutter.\n    */ destroy(dom) {}\n}\nGutterMarker.prototype.elementClass = \"\";\nGutterMarker.prototype.toDOM = undefined;\nGutterMarker.prototype.mapMode = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.MapMode.TrackBefore;\nGutterMarker.prototype.startSide = GutterMarker.prototype.endSide = -1;\nGutterMarker.prototype.point = true;\n/**\nFacet used to add a class to all gutter elements for a given line.\nMarkers given to this facet should _only_ define an\n[`elementclass`](https://codemirror.net/6/docs/ref/#view.GutterMarker.elementClass), not a\n[`toDOM`](https://codemirror.net/6/docs/ref/#view.GutterMarker.toDOM) (or the marker will appear\nin all gutters for the line).\n*/ const gutterLineClass = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst defaults = {\n    class: \"\",\n    renderEmptyElements: false,\n    elementStyle: \"\",\n    markers: ()=>_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.empty,\n    lineMarker: ()=>null,\n    widgetMarker: ()=>null,\n    lineMarkerChange: null,\n    initialSpacer: null,\n    updateSpacer: null,\n    domEventHandlers: {}\n};\nconst activeGutters = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\n/**\nDefine an editor gutter. The order in which the gutters appear is\ndetermined by their extension priority.\n*/ function gutter(config) {\n    return [\n        gutters(),\n        activeGutters.of(Object.assign(Object.assign({}, defaults), config))\n    ];\n}\nconst unfixGutters = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    combine: (values)=>values.some((x)=>x)\n});\n/**\nThe gutter-drawing plugin is automatically enabled when you add a\ngutter, but you can use this function to explicitly configure it.\n\nUnless `fixed` is explicitly set to `false`, the gutters are\nfixed, meaning they don't scroll along with the content\nhorizontally (except on Internet Explorer, which doesn't support\nCSS [`position:\nsticky`](https://developer.mozilla.org/en-US/docs/Web/CSS/position#sticky)).\n*/ function gutters(config) {\n    let result = [\n        gutterView\n    ];\n    if (config && config.fixed === false) result.push(unfixGutters.of(true));\n    return result;\n}\nconst gutterView = /*@__PURE__*/ ViewPlugin.fromClass(class {\n    constructor(view){\n        this.view = view;\n        this.prevViewport = view.viewport;\n        this.dom = document.createElement(\"div\");\n        this.dom.className = \"cm-gutters\";\n        this.dom.setAttribute(\"aria-hidden\", \"true\");\n        this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + \"px\";\n        this.gutters = view.state.facet(activeGutters).map((conf)=>new SingleGutterView(view, conf));\n        for (let gutter of this.gutters)this.dom.appendChild(gutter.dom);\n        this.fixed = !view.state.facet(unfixGutters);\n        if (this.fixed) {\n            // FIXME IE11 fallback, which doesn't support position: sticky,\n            // by using position: relative + event handlers that realign the\n            // gutter (or just force fixed=false on IE11?)\n            this.dom.style.position = \"sticky\";\n        }\n        this.syncGutters(false);\n        view.scrollDOM.insertBefore(this.dom, view.contentDOM);\n    }\n    update(update) {\n        if (this.updateGutters(update)) {\n            // Detach during sync when the viewport changed significantly\n            // (such as during scrolling), since for large updates that is\n            // faster.\n            let vpA = this.prevViewport, vpB = update.view.viewport;\n            let vpOverlap = Math.min(vpA.to, vpB.to) - Math.max(vpA.from, vpB.from);\n            this.syncGutters(vpOverlap < (vpB.to - vpB.from) * 0.8);\n        }\n        if (update.geometryChanged) this.dom.style.minHeight = this.view.contentHeight + \"px\";\n        if (this.view.state.facet(unfixGutters) != !this.fixed) {\n            this.fixed = !this.fixed;\n            this.dom.style.position = this.fixed ? \"sticky\" : \"\";\n        }\n        this.prevViewport = update.view.viewport;\n    }\n    syncGutters(detach) {\n        let after = this.dom.nextSibling;\n        if (detach) this.dom.remove();\n        let lineClasses = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.iter(this.view.state.facet(gutterLineClass), this.view.viewport.from);\n        let classSet = [];\n        let contexts = this.gutters.map((gutter)=>new UpdateContext(gutter, this.view.viewport, -this.view.documentPadding.top));\n        for (let line of this.view.viewportLineBlocks){\n            if (classSet.length) classSet = [];\n            if (Array.isArray(line.type)) {\n                let first = true;\n                for (let b of line.type){\n                    if (b.type == BlockType.Text && first) {\n                        advanceCursor(lineClasses, classSet, b.from);\n                        for (let cx of contexts)cx.line(this.view, b, classSet);\n                        first = false;\n                    } else if (b.widget) {\n                        for (let cx of contexts)cx.widget(this.view, b);\n                    }\n                }\n            } else if (line.type == BlockType.Text) {\n                advanceCursor(lineClasses, classSet, line.from);\n                for (let cx of contexts)cx.line(this.view, line, classSet);\n            } else if (line.widget) {\n                for (let cx of contexts)cx.widget(this.view, line);\n            }\n        }\n        for (let cx of contexts)cx.finish();\n        if (detach) this.view.scrollDOM.insertBefore(this.dom, after);\n    }\n    updateGutters(update) {\n        let prev = update.startState.facet(activeGutters), cur = update.state.facet(activeGutters);\n        let change = update.docChanged || update.heightChanged || update.viewportChanged || !_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.eq(update.startState.facet(gutterLineClass), update.state.facet(gutterLineClass), update.view.viewport.from, update.view.viewport.to);\n        if (prev == cur) {\n            for (let gutter of this.gutters)if (gutter.update(update)) change = true;\n        } else {\n            change = true;\n            let gutters = [];\n            for (let conf of cur){\n                let known = prev.indexOf(conf);\n                if (known < 0) {\n                    gutters.push(new SingleGutterView(this.view, conf));\n                } else {\n                    this.gutters[known].update(update);\n                    gutters.push(this.gutters[known]);\n                }\n            }\n            for (let g of this.gutters){\n                g.dom.remove();\n                if (gutters.indexOf(g) < 0) g.destroy();\n            }\n            for (let g of gutters)this.dom.appendChild(g.dom);\n            this.gutters = gutters;\n        }\n        return change;\n    }\n    destroy() {\n        for (let view of this.gutters)view.destroy();\n        this.dom.remove();\n    }\n}, {\n    provide: (plugin)=>EditorView.scrollMargins.of((view)=>{\n            let value = view.plugin(plugin);\n            if (!value || value.gutters.length == 0 || !value.fixed) return null;\n            return view.textDirection == Direction.LTR ? {\n                left: value.dom.offsetWidth * view.scaleX\n            } : {\n                right: value.dom.offsetWidth * view.scaleX\n            };\n        })\n});\nfunction asArray(val) {\n    return Array.isArray(val) ? val : [\n        val\n    ];\n}\nfunction advanceCursor(cursor, collect, pos) {\n    while(cursor.value && cursor.from <= pos){\n        if (cursor.from == pos) collect.push(cursor.value);\n        cursor.next();\n    }\n}\nclass UpdateContext {\n    constructor(gutter, viewport, height){\n        this.gutter = gutter;\n        this.height = height;\n        this.i = 0;\n        this.cursor = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.iter(gutter.markers, viewport.from);\n    }\n    addElement(view, block, markers) {\n        let { gutter } = this, above = (block.top - this.height) / view.scaleY, height = block.height / view.scaleY;\n        if (this.i == gutter.elements.length) {\n            let newElt = new GutterElement(view, height, above, markers);\n            gutter.elements.push(newElt);\n            gutter.dom.appendChild(newElt.dom);\n        } else {\n            gutter.elements[this.i].update(view, height, above, markers);\n        }\n        this.height = block.bottom;\n        this.i++;\n    }\n    line(view, line, extraMarkers) {\n        let localMarkers = [];\n        advanceCursor(this.cursor, localMarkers, line.from);\n        if (extraMarkers.length) localMarkers = localMarkers.concat(extraMarkers);\n        let forLine = this.gutter.config.lineMarker(view, line, localMarkers);\n        if (forLine) localMarkers.unshift(forLine);\n        let gutter = this.gutter;\n        if (localMarkers.length == 0 && !gutter.config.renderEmptyElements) return;\n        this.addElement(view, line, localMarkers);\n    }\n    widget(view, block) {\n        let marker = this.gutter.config.widgetMarker(view, block.widget, block);\n        if (marker) this.addElement(view, block, [\n            marker\n        ]);\n    }\n    finish() {\n        let gutter = this.gutter;\n        while(gutter.elements.length > this.i){\n            let last = gutter.elements.pop();\n            gutter.dom.removeChild(last.dom);\n            last.destroy();\n        }\n    }\n}\nclass SingleGutterView {\n    constructor(view, config){\n        this.view = view;\n        this.config = config;\n        this.elements = [];\n        this.spacer = null;\n        this.dom = document.createElement(\"div\");\n        this.dom.className = \"cm-gutter\" + (this.config.class ? \" \" + this.config.class : \"\");\n        for(let prop in config.domEventHandlers){\n            this.dom.addEventListener(prop, (event)=>{\n                let target = event.target, y;\n                if (target != this.dom && this.dom.contains(target)) {\n                    while(target.parentNode != this.dom)target = target.parentNode;\n                    let rect = target.getBoundingClientRect();\n                    y = (rect.top + rect.bottom) / 2;\n                } else {\n                    y = event.clientY;\n                }\n                let line = view.lineBlockAtHeight(y - view.documentTop);\n                if (config.domEventHandlers[prop](view, line, event)) event.preventDefault();\n            });\n        }\n        this.markers = asArray(config.markers(view));\n        if (config.initialSpacer) {\n            this.spacer = new GutterElement(view, 0, 0, [\n                config.initialSpacer(view)\n            ]);\n            this.dom.appendChild(this.spacer.dom);\n            this.spacer.dom.style.cssText += \"visibility: hidden; pointer-events: none\";\n        }\n    }\n    update(update) {\n        let prevMarkers = this.markers;\n        this.markers = asArray(this.config.markers(update.view));\n        if (this.spacer && this.config.updateSpacer) {\n            let updated = this.config.updateSpacer(this.spacer.markers[0], update);\n            if (updated != this.spacer.markers[0]) this.spacer.update(update.view, 0, 0, [\n                updated\n            ]);\n        }\n        let vp = update.view.viewport;\n        return !_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.eq(this.markers, prevMarkers, vp.from, vp.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(update) : false);\n    }\n    destroy() {\n        for (let elt of this.elements)elt.destroy();\n    }\n}\nclass GutterElement {\n    constructor(view, height, above, markers){\n        this.height = -1;\n        this.above = 0;\n        this.markers = [];\n        this.dom = document.createElement(\"div\");\n        this.dom.className = \"cm-gutterElement\";\n        this.update(view, height, above, markers);\n    }\n    update(view, height, above, markers) {\n        if (this.height != height) {\n            this.height = height;\n            this.dom.style.height = height + \"px\";\n        }\n        if (this.above != above) this.dom.style.marginTop = (this.above = above) ? above + \"px\" : \"\";\n        if (!sameMarkers(this.markers, markers)) this.setMarkers(view, markers);\n    }\n    setMarkers(view, markers) {\n        let cls = \"cm-gutterElement\", domPos = this.dom.firstChild;\n        for(let iNew = 0, iOld = 0;;){\n            let skipTo = iOld, marker = iNew < markers.length ? markers[iNew++] : null, matched = false;\n            if (marker) {\n                let c = marker.elementClass;\n                if (c) cls += \" \" + c;\n                for(let i = iOld; i < this.markers.length; i++)if (this.markers[i].compare(marker)) {\n                    skipTo = i;\n                    matched = true;\n                    break;\n                }\n            } else {\n                skipTo = this.markers.length;\n            }\n            while(iOld < skipTo){\n                let next = this.markers[iOld++];\n                if (next.toDOM) {\n                    next.destroy(domPos);\n                    let after = domPos.nextSibling;\n                    domPos.remove();\n                    domPos = after;\n                }\n            }\n            if (!marker) break;\n            if (marker.toDOM) {\n                if (matched) domPos = domPos.nextSibling;\n                else this.dom.insertBefore(marker.toDOM(view), domPos);\n            }\n            if (matched) iOld++;\n        }\n        this.dom.className = cls;\n        this.markers = markers;\n    }\n    destroy() {\n        this.setMarkers(null, []); // First argument not used unless creating markers\n    }\n}\nfunction sameMarkers(a, b) {\n    if (a.length != b.length) return false;\n    for(let i = 0; i < a.length; i++)if (!a[i].compare(b[i])) return false;\n    return true;\n}\n/**\nFacet used to provide markers to the line number gutter.\n*/ const lineNumberMarkers = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst lineNumberConfig = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    combine (values) {\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.combineConfig)(values, {\n            formatNumber: String,\n            domEventHandlers: {}\n        }, {\n            domEventHandlers (a, b) {\n                let result = Object.assign({}, a);\n                for(let event in b){\n                    let exists = result[event], add = b[event];\n                    result[event] = exists ? (view, line, event)=>exists(view, line, event) || add(view, line, event) : add;\n                }\n                return result;\n            }\n        });\n    }\n});\nclass NumberMarker extends GutterMarker {\n    constructor(number){\n        super();\n        this.number = number;\n    }\n    eq(other) {\n        return this.number == other.number;\n    }\n    toDOM() {\n        return document.createTextNode(this.number);\n    }\n}\nfunction formatNumber(view, number) {\n    return view.state.facet(lineNumberConfig).formatNumber(number, view.state);\n}\nconst lineNumberGutter = /*@__PURE__*/ activeGutters.compute([\n    lineNumberConfig\n], (state)=>({\n        class: \"cm-lineNumbers\",\n        renderEmptyElements: false,\n        markers (view) {\n            return view.state.facet(lineNumberMarkers);\n        },\n        lineMarker (view, line, others) {\n            if (others.some((m)=>m.toDOM)) return null;\n            return new NumberMarker(formatNumber(view, view.state.doc.lineAt(line.from).number));\n        },\n        widgetMarker: ()=>null,\n        lineMarkerChange: (update)=>update.startState.facet(lineNumberConfig) != update.state.facet(lineNumberConfig),\n        initialSpacer (view) {\n            return new NumberMarker(formatNumber(view, maxLineNumber(view.state.doc.lines)));\n        },\n        updateSpacer (spacer, update) {\n            let max = formatNumber(update.view, maxLineNumber(update.view.state.doc.lines));\n            return max == spacer.number ? spacer : new NumberMarker(max);\n        },\n        domEventHandlers: state.facet(lineNumberConfig).domEventHandlers\n    }));\n/**\nCreate a line number gutter extension.\n*/ function lineNumbers(config = {}) {\n    return [\n        lineNumberConfig.of(config),\n        gutters(),\n        lineNumberGutter\n    ];\n}\nfunction maxLineNumber(lines) {\n    let last = 9;\n    while(last < lines)last = last * 10 + 9;\n    return last;\n}\nconst activeLineGutterMarker = /*@__PURE__*/ new class extends GutterMarker {\n    constructor(){\n        super(...arguments);\n        this.elementClass = \"cm-activeLineGutter\";\n    }\n};\nconst activeLineGutterHighlighter = /*@__PURE__*/ gutterLineClass.compute([\n    \"selection\"\n], (state)=>{\n    let marks = [], last = -1;\n    for (let range of state.selection.ranges){\n        let linePos = state.doc.lineAt(range.head).from;\n        if (linePos > last) {\n            last = linePos;\n            marks.push(activeLineGutterMarker.range(linePos));\n        }\n    }\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.of(marks);\n});\n/**\nReturns an extension that adds a `cm-activeLineGutter` class to\nall gutter elements on the [active\nline](https://codemirror.net/6/docs/ref/#view.highlightActiveLine).\n*/ function highlightActiveLineGutter() {\n    return activeLineGutterHighlighter;\n}\nconst WhitespaceDeco = /*@__PURE__*/ new Map();\nfunction getWhitespaceDeco(space) {\n    let deco = WhitespaceDeco.get(space);\n    if (!deco) WhitespaceDeco.set(space, deco = Decoration.mark({\n        attributes: space === \"\t\" ? {\n            class: \"cm-highlightTab\"\n        } : {\n            class: \"cm-highlightSpace\",\n            \"data-display\": space.replace(/ /g, \"\\xb7\")\n        }\n    }));\n    return deco;\n}\nfunction matcher(decorator) {\n    return ViewPlugin.define((view)=>({\n            decorations: decorator.createDeco(view),\n            update (u) {\n                this.decorations = decorator.updateDeco(u, this.decorations);\n            }\n        }), {\n        decorations: (v)=>v.decorations\n    });\n}\nconst whitespaceHighlighter = /*@__PURE__*/ matcher(/*@__PURE__*/ new MatchDecorator({\n    regexp: /\\t| +/g,\n    decoration: (match)=>getWhitespaceDeco(match[0]),\n    boundary: /\\S/\n}));\n/**\nReturns an extension that highlights whitespace, adding a\n`cm-highlightSpace` class to stretches of spaces, and a\n`cm-highlightTab` class to individual tab characters. By default,\nthe former are shown as faint dots, and the latter as arrows.\n*/ function highlightWhitespace() {\n    return whitespaceHighlighter;\n}\nconst trailingHighlighter = /*@__PURE__*/ matcher(/*@__PURE__*/ new MatchDecorator({\n    regexp: /\\s+$/g,\n    decoration: /*@__PURE__*/ Decoration.mark({\n        class: \"cm-trailingSpace\"\n    }),\n    boundary: /\\S/\n}));\n/**\nReturns an extension that adds a `cm-trailingSpace` class to all\ntrailing whitespace.\n*/ function highlightTrailingWhitespace() {\n    return trailingHighlighter;\n}\n/**\n@internal\n*/ const __test = {\n    HeightMap,\n    HeightOracle,\n    MeasuredHeights,\n    QueryType,\n    ChangedRange,\n    computeOrder,\n    moveVisually\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3Ivdmlldy9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXFTO0FBQzdQO0FBQ1c7QUFFbkQsU0FBU3lCLGFBQWFDLElBQUk7SUFDdEIsSUFBSUM7SUFDSiw4REFBOEQ7SUFDOUQsNERBQTREO0lBQzVELFlBQVk7SUFDWixJQUFJRCxLQUFLRSxRQUFRLElBQUksSUFBSTtRQUNyQkQsU0FBU0QsS0FBS0QsWUFBWSxHQUFHQyxPQUFPQSxLQUFLRyxhQUFhO0lBQzFELE9BQ0s7UUFDREYsU0FBU0Q7SUFDYjtJQUNBLE9BQU9DLE9BQU9GLFlBQVk7QUFDOUI7QUFDQSxTQUFTSyxTQUFTQyxHQUFHLEVBQUVDLElBQUk7SUFDdkIsT0FBT0EsT0FBT0QsT0FBT0MsUUFBUUQsSUFBSUQsUUFBUSxDQUFDRSxLQUFLSixRQUFRLElBQUksSUFBSUksS0FBS0MsVUFBVSxHQUFHRCxRQUFRO0FBQzdGO0FBQ0EsU0FBU0Usa0JBQWtCQyxHQUFHO0lBQzFCLElBQUlDLE1BQU1ELElBQUlFLGFBQWE7SUFDM0IsTUFBT0QsT0FBT0EsSUFBSUUsVUFBVSxDQUN4QkYsTUFBTUEsSUFBSUUsVUFBVSxDQUFDRCxhQUFhO0lBQ3RDLE9BQU9EO0FBQ1g7QUFDQSxTQUFTRyxhQUFhUixHQUFHLEVBQUVTLFNBQVM7SUFDaEMsSUFBSSxDQUFDQSxVQUFVQyxVQUFVLEVBQ3JCLE9BQU87SUFDWCxJQUFJO1FBQ0EsK0RBQStEO1FBQy9ELDhEQUE4RDtRQUM5RCxXQUFXO1FBQ1gsT0FBT1gsU0FBU0MsS0FBS1MsVUFBVUMsVUFBVTtJQUM3QyxFQUNBLE9BQU9DLEdBQUc7UUFDTixPQUFPO0lBQ1g7QUFDSjtBQUNBLFNBQVNDLGVBQWVaLEdBQUc7SUFDdkIsSUFBSUEsSUFBSUgsUUFBUSxJQUFJLEdBQ2hCLE9BQU9nQixVQUFVYixLQUFLLEdBQUdBLElB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STtZQUNBQSxPQUFPO1lBQ1AsZ0JBQWdCdzNDLE1BQU1oOEMsT0FBTyxDQUFDLE1BQU07UUFDeEM7SUFDSjtJQUNKLE9BQU9zSTtBQUNYO0FBQ0EsU0FBUzY3QyxRQUFRdE4sU0FBUztJQUN0QixPQUFPdm1DLFdBQVc5QixNQUFNLENBQUM5UixDQUFBQSxPQUFTO1lBQzlCdVIsYUFBYTRvQyxVQUFVL0IsVUFBVSxDQUFDcDRDO1lBQ2xDMlUsUUFBTyt5QyxDQUFDO2dCQUNKLElBQUksQ0FBQ24yQyxXQUFXLEdBQUc0b0MsVUFBVTE5QixVQUFVLENBQUNpckMsR0FBRyxJQUFJLENBQUNuMkMsV0FBVztZQUMvRDtRQUNKLElBQUk7UUFDQUEsYUFBYS9PLENBQUFBLElBQUtBLEVBQUUrTyxXQUFXO0lBQ25DO0FBQ0o7QUFDQSxNQUFNbzJDLHdCQUF3QixXQUFXLEdBQUVGLFFBQVEsV0FBVyxHQUFFLElBQUk5UCxlQUFlO0lBQy9FQyxRQUFRO0lBQ1JDLFlBQVlLLENBQUFBLFFBQVNzUCxrQkFBa0J0UCxLQUFLLENBQUMsRUFBRTtJQUMvQ0gsVUFBVTtBQUNkO0FBQ0E7Ozs7O0FBS0EsR0FDQSxTQUFTNlA7SUFDTCxPQUFPRDtBQUNYO0FBQ0EsTUFBTUUsc0JBQXNCLFdBQVcsR0FBRUosUUFBUSxXQUFXLEdBQUUsSUFBSTlQLGVBQWU7SUFDN0VDLFFBQVE7SUFDUkMsWUFBWSxXQUFXLEdBQUVscUMsV0FBV2hHLElBQUksQ0FBQztRQUFFRyxPQUFPO0lBQW1CO0lBQ3JFaXdDLFVBQVU7QUFDZDtBQUNBOzs7QUFHQSxHQUNBLFNBQVMrUDtJQUNMLE9BQU9EO0FBQ1g7QUFFQTs7QUFFQSxHQUNBLE1BQU1FLFNBQVM7SUFBRWx5QjtJQUFXckI7SUFBY2M7SUFBaUJLO0lBQVc1ZjtJQUFjK0U7SUFBY0c7QUFBYTtBQUVpaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9weXRob24tb25saW5lLWVkaXRvci8uL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci92aWV3L2Rpc3QvaW5kZXguanM/ODdjMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBUZXh0LCBSYW5nZVNldCwgTWFwTW9kZSwgUmFuZ2VWYWx1ZSwgRmFjZXQsIFN0YXRlRWZmZWN0LCBDaGFuZ2VTZXQsIEVkaXRvclNlbGVjdGlvbiwgZmluZENsdXN0ZXJCcmVhaywgZmluZENvbHVtbiwgQ2hhckNhdGVnb3J5LCBBbm5vdGF0aW9uLCBFZGl0b3JTdGF0ZSwgVHJhbnNhY3Rpb24sIFByZWMsIGNvZGVQb2ludEF0LCBjb2RlUG9pbnRTaXplLCBjb21iaW5lQ29uZmlnLCBTdGF0ZUZpZWxkLCBSYW5nZVNldEJ1aWxkZXIsIGNvdW50Q29sdW1uIH0gZnJvbSAnQGNvZGVtaXJyb3Ivc3RhdGUnO1xuaW1wb3J0IHsgU3R5bGVNb2R1bGUgfSBmcm9tICdzdHlsZS1tb2QnO1xuaW1wb3J0IHsga2V5TmFtZSwgYmFzZSwgc2hpZnQgfSBmcm9tICd3M2Mta2V5bmFtZSc7XG5cbmZ1bmN0aW9uIGdldFNlbGVjdGlvbihyb290KSB7XG4gICAgbGV0IHRhcmdldDtcbiAgICAvLyBCcm93c2VycyBkaWZmZXIgb24gd2hldGhlciBzaGFkb3cgcm9vdHMgaGF2ZSBhIGdldFNlbGVjdGlvblxuICAgIC8vIG1ldGhvZC4gSWYgaXQgZXhpc3RzLCB1c2UgdGhhdCwgb3RoZXJ3aXNlLCBjYWxsIGl0IG9uIHRoZVxuICAgIC8vIGRvY3VtZW50LlxuICAgIGlmIChyb290Lm5vZGVUeXBlID09IDExKSB7IC8vIFNoYWRvdyByb290XG4gICAgICAgIHRhcmdldCA9IHJvb3QuZ2V0U2VsZWN0aW9uID8gcm9vdCA6IHJvb3Qub3duZXJEb2N1bWVudDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRhcmdldCA9IHJvb3Q7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQuZ2V0U2VsZWN0aW9uKCk7XG59XG5mdW5jdGlvbiBjb250YWlucyhkb20sIG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZSA/IGRvbSA9PSBub2RlIHx8IGRvbS5jb250YWlucyhub2RlLm5vZGVUeXBlICE9IDEgPyBub2RlLnBhcmVudE5vZGUgOiBub2RlKSA6IGZhbHNlO1xufVxuZnVuY3Rpb24gZGVlcEFjdGl2ZUVsZW1lbnQoZG9jKSB7XG4gICAgbGV0IGVsdCA9IGRvYy5hY3RpdmVFbGVtZW50O1xuICAgIHdoaWxlIChlbHQgJiYgZWx0LnNoYWRvd1Jvb3QpXG4gICAgICAgIGVsdCA9IGVsdC5zaGFkb3dSb290LmFjdGl2ZUVsZW1lbnQ7XG4gICAgcmV0dXJuIGVsdDtcbn1cbmZ1bmN0aW9uIGhhc1NlbGVjdGlvbihkb20sIHNlbGVjdGlvbikge1xuICAgIGlmICghc2VsZWN0aW9uLmFuY2hvck5vZGUpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgICAvLyBGaXJlZm94IHdpbGwgcmFpc2UgJ3Blcm1pc3Npb24gZGVuaWVkJyBlcnJvcnMgd2hlbiBhY2Nlc3NpbmdcbiAgICAgICAgLy8gcHJvcGVydGllcyBvZiBgc2VsLmFuY2hvck5vZGVgIHdoZW4gaXQncyBpbiBhIGdlbmVyYXRlZCBDU1NcbiAgICAgICAgLy8gZWxlbWVudC5cbiAgICAgICAgcmV0dXJuIGNvbnRhaW5zKGRvbSwgc2VsZWN0aW9uLmFuY2hvck5vZGUpO1xuICAgIH1cbiAgICBjYXRjaCAoXykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gY2xpZW50UmVjdHNGb3IoZG9tKSB7XG4gICAgaWYgKGRvbS5ub2RlVHlwZSA9PSAzKVxuICAgICAgICByZXR1cm4gdGV4dFJhbmdlKGRvbSwgMCwgZG9tLm5vZGVWYWx1ZS5sZW5ndGgpLmdldENsaWVudFJlY3RzKCk7XG4gICAgZWxzZSBpZiAoZG9tLm5vZGVUeXBlID09IDEpXG4gICAgICAgIHJldHVybiBkb20uZ2V0Q2xpZW50UmVjdHMoKTtcbiAgICBlbHNlXG4gICAgICAgIHJldHVybiBbXTtcbn1cbi8vIFNjYW5zIGZvcndhcmQgYW5kIGJhY2t3YXJkIHRocm91Z2ggRE9NIHBvc2l0aW9ucyBlcXVpdmFsZW50IHRvIHRoZVxuLy8gZ2l2ZW4gb25lIHRvIHNlZSBpZiB0aGUgdHdvIGFyZSBpbiB0aGUgc2FtZSBwbGFjZSAoaS5lLiBhZnRlciBhXG4vLyB0ZXh0IG5vZGUgdnMgYXQgdGhlIGVuZCBvZiB0aGF0IHRleHQgbm9kZSlcbmZ1bmN0aW9uIGlzRXF1aXZhbGVudFBvc2l0aW9uKG5vZGUsIG9mZiwgdGFyZ2V0Tm9kZSwgdGFyZ2V0T2ZmKSB7XG4gICAgcmV0dXJuIHRhcmdldE5vZGUgPyAoc2NhbkZvcihub2RlLCBvZmYsIHRhcmdldE5vZGUsIHRhcmdldE9mZiwgLTEpIHx8XG4gICAgICAgIHNjYW5Gb3Iobm9kZSwgb2ZmLCB0YXJnZXROb2RlLCB0YXJnZXRPZmYsIDEpKSA6IGZhbHNlO1xufVxuZnVuY3Rpb24gZG9tSW5kZXgobm9kZSkge1xuICAgIGZvciAodmFyIGluZGV4ID0gMDs7IGluZGV4KyspIHtcbiAgICAgICAgbm9kZSA9IG5vZGUucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxufVxuZnVuY3Rpb24gc2NhbkZvcihub2RlLCBvZmYsIHRhcmdldE5vZGUsIHRhcmdldE9mZiwgZGlyKSB7XG4gICAgZm9yICg7Oykge1xuICAgICAgICBpZiAobm9kZSA9PSB0YXJnZXROb2RlICYmIG9mZiA9PSB0YXJnZXRPZmYpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKG9mZiA9PSAoZGlyIDwgMCA/IDAgOiBtYXhPZmZzZXQobm9kZSkpKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlTmFtZSA9PSBcIkRJVlwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICBpZiAoIXBhcmVudCB8fCBwYXJlbnQubm9kZVR5cGUgIT0gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBvZmYgPSBkb21JbmRleChub2RlKSArIChkaXIgPCAwID8gMCA6IDEpO1xuICAgICAgICAgICAgbm9kZSA9IHBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlLm5vZGVUeXBlID09IDEpIHtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLmNoaWxkTm9kZXNbb2ZmICsgKGRpciA8IDAgPyAtMSA6IDApXTtcbiAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09IDEgJiYgbm9kZS5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIG9mZiA9IGRpciA8IDAgPyBtYXhPZmZzZXQobm9kZSkgOiAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gbWF4T2Zmc2V0KG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PSAzID8gbm9kZS5ub2RlVmFsdWUubGVuZ3RoIDogbm9kZS5jaGlsZE5vZGVzLmxlbmd0aDtcbn1cbmZ1bmN0aW9uIGZsYXR0ZW5SZWN0KHJlY3QsIGxlZnQpIHtcbiAgICBsZXQgeCA9IGxlZnQgPyByZWN0LmxlZnQgOiByZWN0LnJpZ2h0O1xuICAgIHJldHVybiB7IGxlZnQ6IHgsIHJpZ2h0OiB4LCB0b3A6IHJlY3QudG9wLCBib3R0b206IHJlY3QuYm90dG9tIH07XG59XG5mdW5jdGlvbiB3aW5kb3dSZWN0KHdpbikge1xuICAgIHJldHVybiB7IGxlZnQ6IDAsIHJpZ2h0OiB3aW4uaW5uZXJXaWR0aCxcbiAgICAgICAgdG9wOiAwLCBib3R0b206IHdpbi5pbm5lckhlaWdodCB9O1xufVxuZnVuY3Rpb24gZ2V0U2NhbGUoZWx0LCByZWN0KSB7XG4gICAgbGV0IHNjYWxlWCA9IHJlY3Qud2lkdGggLyBlbHQub2Zmc2V0V2lkdGg7XG4gICAgbGV0IHNjYWxlWSA9IHJlY3QuaGVpZ2h0IC8gZWx0Lm9mZnNldEhlaWdodDtcbiAgICBpZiAoc2NhbGVYID4gMC45OTUgJiYgc2NhbGVYIDwgMS4wMDUgfHwgIWlzRmluaXRlKHNjYWxlWCkgfHwgTWF0aC5hYnMocmVjdC53aWR0aCAtIGVsdC5vZmZzZXRXaWR0aCkgPCAxKVxuICAgICAgICBzY2FsZVggPSAxO1xuICAgIGlmIChzY2FsZVkgPiAwLjk5NSAmJiBzY2FsZVkgPCAxLjAwNSB8fCAhaXNGaW5pdGUoc2NhbGVZKSB8fCBNYXRoLmFicyhyZWN0LmhlaWdodCAtIGVsdC5vZmZzZXRIZWlnaHQpIDwgMSlcbiAgICAgICAgc2NhbGVZID0gMTtcbiAgICByZXR1cm4geyBzY2FsZVgsIHNjYWxlWSB9O1xufVxuZnVuY3Rpb24gc2Nyb2xsUmVjdEludG9WaWV3KGRvbSwgcmVjdCwgc2lkZSwgeCwgeSwgeE1hcmdpbiwgeU1hcmdpbiwgbHRyKSB7XG4gICAgbGV0IGRvYyA9IGRvbS5vd25lckRvY3VtZW50LCB3aW4gPSBkb2MuZGVmYXVsdFZpZXcgfHwgd2luZG93O1xuICAgIGZvciAobGV0IGN1ciA9IGRvbSwgc3RvcCA9IGZhbHNlOyBjdXIgJiYgIXN0b3A7KSB7XG4gICAgICAgIGlmIChjdXIubm9kZVR5cGUgPT0gMSkgeyAvLyBFbGVtZW50XG4gICAgICAgICAgICBsZXQgYm91bmRpbmcsIHRvcCA9IGN1ciA9PSBkb2MuYm9keTtcbiAgICAgICAgICAgIGxldCBzY2FsZVggPSAxLCBzY2FsZVkgPSAxO1xuICAgICAgICAgICAgaWYgKHRvcCkge1xuICAgICAgICAgICAgICAgIGJvdW5kaW5nID0gd2luZG93UmVjdCh3aW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKC9eKGZpeGVkfHN0aWNreSkkLy50ZXN0KGdldENvbXB1dGVkU3R5bGUoY3VyKS5wb3NpdGlvbikpXG4gICAgICAgICAgICAgICAgICAgIHN0b3AgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChjdXIuc2Nyb2xsSGVpZ2h0IDw9IGN1ci5jbGllbnRIZWlnaHQgJiYgY3VyLnNjcm9sbFdpZHRoIDw9IGN1ci5jbGllbnRXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICBjdXIgPSBjdXIuYXNzaWduZWRTbG90IHx8IGN1ci5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHJlY3QgPSBjdXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgKHsgc2NhbGVYLCBzY2FsZVkgfSA9IGdldFNjYWxlKGN1ciwgcmVjdCkpO1xuICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBzY3JvbGxiYXIgd2lkdGggaXNuJ3QgaW5jbHVkZWQgaW4gdGhlIHJlY3RhbmdsZVxuICAgICAgICAgICAgICAgIGJvdW5kaW5nID0geyBsZWZ0OiByZWN0LmxlZnQsIHJpZ2h0OiByZWN0LmxlZnQgKyBjdXIuY2xpZW50V2lkdGggKiBzY2FsZVgsXG4gICAgICAgICAgICAgICAgICAgIHRvcDogcmVjdC50b3AsIGJvdHRvbTogcmVjdC50b3AgKyBjdXIuY2xpZW50SGVpZ2h0ICogc2NhbGVZIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbW92ZVggPSAwLCBtb3ZlWSA9IDA7XG4gICAgICAgICAgICBpZiAoeSA9PSBcIm5lYXJlc3RcIikge1xuICAgICAgICAgICAgICAgIGlmIChyZWN0LnRvcCA8IGJvdW5kaW5nLnRvcCkge1xuICAgICAgICAgICAgICAgICAgICBtb3ZlWSA9IC0oYm91bmRpbmcudG9wIC0gcmVjdC50b3AgKyB5TWFyZ2luKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpZGUgPiAwICYmIHJlY3QuYm90dG9tID4gYm91bmRpbmcuYm90dG9tICsgbW92ZVkpXG4gICAgICAgICAgICAgICAgICAgICAgICBtb3ZlWSA9IHJlY3QuYm90dG9tIC0gYm91bmRpbmcuYm90dG9tICsgbW92ZVkgKyB5TWFyZ2luO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZWN0LmJvdHRvbSA+IGJvdW5kaW5nLmJvdHRvbSkge1xuICAgICAgICAgICAgICAgICAgICBtb3ZlWSA9IHJlY3QuYm90dG9tIC0gYm91bmRpbmcuYm90dG9tICsgeU1hcmdpbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpZGUgPCAwICYmIChyZWN0LnRvcCAtIG1vdmVZKSA8IGJvdW5kaW5nLnRvcClcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdmVZID0gLShib3VuZGluZy50b3AgKyBtb3ZlWSAtIHJlY3QudG9wICsgeU1hcmdpbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlY3RIZWlnaHQgPSByZWN0LmJvdHRvbSAtIHJlY3QudG9wLCBib3VuZGluZ0hlaWdodCA9IGJvdW5kaW5nLmJvdHRvbSAtIGJvdW5kaW5nLnRvcDtcbiAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0VG9wID0geSA9PSBcImNlbnRlclwiICYmIHJlY3RIZWlnaHQgPD0gYm91bmRpbmdIZWlnaHQgPyByZWN0LnRvcCArIHJlY3RIZWlnaHQgLyAyIC0gYm91bmRpbmdIZWlnaHQgLyAyIDpcbiAgICAgICAgICAgICAgICAgICAgeSA9PSBcInN0YXJ0XCIgfHwgeSA9PSBcImNlbnRlclwiICYmIHNpZGUgPCAwID8gcmVjdC50b3AgLSB5TWFyZ2luIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY3QuYm90dG9tIC0gYm91bmRpbmdIZWlnaHQgKyB5TWFyZ2luO1xuICAgICAgICAgICAgICAgIG1vdmVZID0gdGFyZ2V0VG9wIC0gYm91bmRpbmcudG9wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHggPT0gXCJuZWFyZXN0XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVjdC5sZWZ0IDwgYm91bmRpbmcubGVmdCkge1xuICAgICAgICAgICAgICAgICAgICBtb3ZlWCA9IC0oYm91bmRpbmcubGVmdCAtIHJlY3QubGVmdCArIHhNYXJnaW4pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2lkZSA+IDAgJiYgcmVjdC5yaWdodCA+IGJvdW5kaW5nLnJpZ2h0ICsgbW92ZVgpXG4gICAgICAgICAgICAgICAgICAgICAgICBtb3ZlWCA9IHJlY3QucmlnaHQgLSBib3VuZGluZy5yaWdodCArIG1vdmVYICsgeE1hcmdpbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVjdC5yaWdodCA+IGJvdW5kaW5nLnJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIG1vdmVYID0gcmVjdC5yaWdodCAtIGJvdW5kaW5nLnJpZ2h0ICsgeE1hcmdpbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpZGUgPCAwICYmIHJlY3QubGVmdCA8IGJvdW5kaW5nLmxlZnQgKyBtb3ZlWClcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdmVYID0gLShib3VuZGluZy5sZWZ0ICsgbW92ZVggLSByZWN0LmxlZnQgKyB4TWFyZ2luKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0TGVmdCA9IHggPT0gXCJjZW50ZXJcIiA/IHJlY3QubGVmdCArIChyZWN0LnJpZ2h0IC0gcmVjdC5sZWZ0KSAvIDIgLSAoYm91bmRpbmcucmlnaHQgLSBib3VuZGluZy5sZWZ0KSAvIDIgOlxuICAgICAgICAgICAgICAgICAgICAoeCA9PSBcInN0YXJ0XCIpID09IGx0ciA/IHJlY3QubGVmdCAtIHhNYXJnaW4gOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjdC5yaWdodCAtIChib3VuZGluZy5yaWdodCAtIGJvdW5kaW5nLmxlZnQpICsgeE1hcmdpbjtcbiAgICAgICAgICAgICAgICBtb3ZlWCA9IHRhcmdldExlZnQgLSBib3VuZGluZy5sZWZ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1vdmVYIHx8IG1vdmVZKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRvcCkge1xuICAgICAgICAgICAgICAgICAgICB3aW4uc2Nyb2xsQnkobW92ZVgsIG1vdmVZKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBtb3ZlZFggPSAwLCBtb3ZlZFkgPSAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAobW92ZVkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzdGFydCA9IGN1ci5zY3JvbGxUb3A7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXIuc2Nyb2xsVG9wICs9IG1vdmVZIC8gc2NhbGVZO1xuICAgICAgICAgICAgICAgICAgICAgICAgbW92ZWRZID0gKGN1ci5zY3JvbGxUb3AgLSBzdGFydCkgKiBzY2FsZVk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vdmVYKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3RhcnQgPSBjdXIuc2Nyb2xsTGVmdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1ci5zY3JvbGxMZWZ0ICs9IG1vdmVYIC8gc2NhbGVYO1xuICAgICAgICAgICAgICAgICAgICAgICAgbW92ZWRYID0gKGN1ci5zY3JvbGxMZWZ0IC0gc3RhcnQpICogc2NhbGVYO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlY3QgPSB7IGxlZnQ6IHJlY3QubGVmdCAtIG1vdmVkWCwgdG9wOiByZWN0LnRvcCAtIG1vdmVkWSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiByZWN0LnJpZ2h0IC0gbW92ZWRYLCBib3R0b206IHJlY3QuYm90dG9tIC0gbW92ZWRZIH07XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb3ZlZFggJiYgTWF0aC5hYnMobW92ZWRYIC0gbW92ZVgpIDwgMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSBcIm5lYXJlc3RcIjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vdmVkWSAmJiBNYXRoLmFicyhtb3ZlZFkgLSBtb3ZlWSkgPCAxKVxuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IFwibmVhcmVzdFwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b3ApXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjdXIgPSBjdXIuYXNzaWduZWRTbG90IHx8IGN1ci5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGN1ci5ub2RlVHlwZSA9PSAxMSkgeyAvLyBBIHNoYWRvdyByb290XG4gICAgICAgICAgICBjdXIgPSBjdXIuaG9zdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gc2Nyb2xsYWJsZVBhcmVudChkb20pIHtcbiAgICBsZXQgZG9jID0gZG9tLm93bmVyRG9jdW1lbnQ7XG4gICAgZm9yIChsZXQgY3VyID0gZG9tLnBhcmVudE5vZGU7IGN1cjspIHtcbiAgICAgICAgaWYgKGN1ciA9PSBkb2MuYm9keSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3VyLm5vZGVUeXBlID09IDEpIHtcbiAgICAgICAgICAgIGlmIChjdXIuc2Nyb2xsSGVpZ2h0ID4gY3VyLmNsaWVudEhlaWdodCB8fCBjdXIuc2Nyb2xsV2lkdGggPiBjdXIuY2xpZW50V2lkdGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1cjtcbiAgICAgICAgICAgIGN1ciA9IGN1ci5hc3NpZ25lZFNsb3QgfHwgY3VyLnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3VyLm5vZGVUeXBlID09IDExKSB7XG4gICAgICAgICAgICBjdXIgPSBjdXIuaG9zdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuY2xhc3MgRE9NU2VsZWN0aW9uU3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmFuY2hvck5vZGUgPSBudWxsO1xuICAgICAgICB0aGlzLmFuY2hvck9mZnNldCA9IDA7XG4gICAgICAgIHRoaXMuZm9jdXNOb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5mb2N1c09mZnNldCA9IDA7XG4gICAgfVxuICAgIGVxKGRvbVNlbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hbmNob3JOb2RlID09IGRvbVNlbC5hbmNob3JOb2RlICYmIHRoaXMuYW5jaG9yT2Zmc2V0ID09IGRvbVNlbC5hbmNob3JPZmZzZXQgJiZcbiAgICAgICAgICAgIHRoaXMuZm9jdXNOb2RlID09IGRvbVNlbC5mb2N1c05vZGUgJiYgdGhpcy5mb2N1c09mZnNldCA9PSBkb21TZWwuZm9jdXNPZmZzZXQ7XG4gICAgfVxuICAgIHNldFJhbmdlKHJhbmdlKSB7XG4gICAgICAgIGxldCB7IGFuY2hvck5vZGUsIGZvY3VzTm9kZSB9ID0gcmFuZ2U7XG4gICAgICAgIC8vIENsaXAgb2Zmc2V0cyB0byBub2RlIHNpemUgdG8gYXZvaWQgY3Jhc2hlcyB3aGVuIFNhZmFyaSByZXBvcnRzIGJvZ3VzIG9mZnNldHMgKCMxMTUyKVxuICAgICAgICB0aGlzLnNldChhbmNob3JOb2RlLCBNYXRoLm1pbihyYW5nZS5hbmNob3JPZmZzZXQsIGFuY2hvck5vZGUgPyBtYXhPZmZzZXQoYW5jaG9yTm9kZSkgOiAwKSwgZm9jdXNOb2RlLCBNYXRoLm1pbihyYW5nZS5mb2N1c09mZnNldCwgZm9jdXNOb2RlID8gbWF4T2Zmc2V0KGZvY3VzTm9kZSkgOiAwKSk7XG4gICAgfVxuICAgIHNldChhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQsIGZvY3VzTm9kZSwgZm9jdXNPZmZzZXQpIHtcbiAgICAgICAgdGhpcy5hbmNob3JOb2RlID0gYW5jaG9yTm9kZTtcbiAgICAgICAgdGhpcy5hbmNob3JPZmZzZXQgPSBhbmNob3JPZmZzZXQ7XG4gICAgICAgIHRoaXMuZm9jdXNOb2RlID0gZm9jdXNOb2RlO1xuICAgICAgICB0aGlzLmZvY3VzT2Zmc2V0ID0gZm9jdXNPZmZzZXQ7XG4gICAgfVxufVxubGV0IHByZXZlbnRTY3JvbGxTdXBwb3J0ZWQgPSBudWxsO1xuLy8gRmVhdHVyZS1kZXRlY3RzIHN1cHBvcnQgZm9yIC5mb2N1cyh7cHJldmVudFNjcm9sbDogdHJ1ZX0pLCBhbmQgdXNlc1xuLy8gYSBmYWxsYmFjayBrbHVkZ2Ugd2hlbiBub3Qgc3VwcG9ydGVkLlxuZnVuY3Rpb24gZm9jdXNQcmV2ZW50U2Nyb2xsKGRvbSkge1xuICAgIGlmIChkb20uc2V0QWN0aXZlKVxuICAgICAgICByZXR1cm4gZG9tLnNldEFjdGl2ZSgpOyAvLyBpbiBJRVxuICAgIGlmIChwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkKVxuICAgICAgICByZXR1cm4gZG9tLmZvY3VzKHByZXZlbnRTY3JvbGxTdXBwb3J0ZWQpO1xuICAgIGxldCBzdGFjayA9IFtdO1xuICAgIGZvciAobGV0IGN1ciA9IGRvbTsgY3VyOyBjdXIgPSBjdXIucGFyZW50Tm9kZSkge1xuICAgICAgICBzdGFjay5wdXNoKGN1ciwgY3VyLnNjcm9sbFRvcCwgY3VyLnNjcm9sbExlZnQpO1xuICAgICAgICBpZiAoY3VyID09IGN1ci5vd25lckRvY3VtZW50KVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGRvbS5mb2N1cyhwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkID09IG51bGwgPyB7XG4gICAgICAgIGdldCBwcmV2ZW50U2Nyb2xsKCkge1xuICAgICAgICAgICAgcHJldmVudFNjcm9sbFN1cHBvcnRlZCA9IHsgcHJldmVudFNjcm9sbDogdHJ1ZSB9O1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9IDogdW5kZWZpbmVkKTtcbiAgICBpZiAoIXByZXZlbnRTY3JvbGxTdXBwb3J0ZWQpIHtcbiAgICAgICAgcHJldmVudFNjcm9sbFN1cHBvcnRlZCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDspIHtcbiAgICAgICAgICAgIGxldCBlbHQgPSBzdGFja1tpKytdLCB0b3AgPSBzdGFja1tpKytdLCBsZWZ0ID0gc3RhY2tbaSsrXTtcbiAgICAgICAgICAgIGlmIChlbHQuc2Nyb2xsVG9wICE9IHRvcClcbiAgICAgICAgICAgICAgICBlbHQuc2Nyb2xsVG9wID0gdG9wO1xuICAgICAgICAgICAgaWYgKGVsdC5zY3JvbGxMZWZ0ICE9IGxlZnQpXG4gICAgICAgICAgICAgICAgZWx0LnNjcm9sbExlZnQgPSBsZWZ0O1xuICAgICAgICB9XG4gICAgfVxufVxubGV0IHNjcmF0Y2hSYW5nZTtcbmZ1bmN0aW9uIHRleHRSYW5nZShub2RlLCBmcm9tLCB0byA9IGZyb20pIHtcbiAgICBsZXQgcmFuZ2UgPSBzY3JhdGNoUmFuZ2UgfHwgKHNjcmF0Y2hSYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCkpO1xuICAgIHJhbmdlLnNldEVuZChub2RlLCB0byk7XG4gICAgcmFuZ2Uuc2V0U3RhcnQobm9kZSwgZnJvbSk7XG4gICAgcmV0dXJuIHJhbmdlO1xufVxuZnVuY3Rpb24gZGlzcGF0Y2hLZXkoZWx0LCBuYW1lLCBjb2RlKSB7XG4gICAgbGV0IG9wdGlvbnMgPSB7IGtleTogbmFtZSwgY29kZTogbmFtZSwga2V5Q29kZTogY29kZSwgd2hpY2g6IGNvZGUsIGNhbmNlbGFibGU6IHRydWUgfTtcbiAgICBsZXQgZG93biA9IG5ldyBLZXlib2FyZEV2ZW50KFwia2V5ZG93blwiLCBvcHRpb25zKTtcbiAgICBkb3duLnN5bnRoZXRpYyA9IHRydWU7XG4gICAgZWx0LmRpc3BhdGNoRXZlbnQoZG93bik7XG4gICAgbGV0IHVwID0gbmV3IEtleWJvYXJkRXZlbnQoXCJrZXl1cFwiLCBvcHRpb25zKTtcbiAgICB1cC5zeW50aGV0aWMgPSB0cnVlO1xuICAgIGVsdC5kaXNwYXRjaEV2ZW50KHVwKTtcbiAgICByZXR1cm4gZG93bi5kZWZhdWx0UHJldmVudGVkIHx8IHVwLmRlZmF1bHRQcmV2ZW50ZWQ7XG59XG5mdW5jdGlvbiBnZXRSb290KG5vZGUpIHtcbiAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICBpZiAobm9kZSAmJiAobm9kZS5ub2RlVHlwZSA9PSA5IHx8IG5vZGUubm9kZVR5cGUgPT0gMTEgJiYgbm9kZS5ob3N0KSlcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICBub2RlID0gbm9kZS5hc3NpZ25lZFNsb3QgfHwgbm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGNsZWFyQXR0cmlidXRlcyhub2RlKSB7XG4gICAgd2hpbGUgKG5vZGUuYXR0cmlidXRlcy5sZW5ndGgpXG4gICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlTm9kZShub2RlLmF0dHJpYnV0ZXNbMF0pO1xufVxuZnVuY3Rpb24gYXRFbGVtZW50U3RhcnQoZG9jLCBzZWxlY3Rpb24pIHtcbiAgICBsZXQgbm9kZSA9IHNlbGVjdGlvbi5mb2N1c05vZGUsIG9mZnNldCA9IHNlbGVjdGlvbi5mb2N1c09mZnNldDtcbiAgICBpZiAoIW5vZGUgfHwgc2VsZWN0aW9uLmFuY2hvck5vZGUgIT0gbm9kZSB8fCBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0ICE9IG9mZnNldClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIC8vIFNhZmFyaSBjYW4gcmVwb3J0IGJvZ3VzIG9mZnNldHMgKCMxMTUyKVxuICAgIG9mZnNldCA9IE1hdGgubWluKG9mZnNldCwgbWF4T2Zmc2V0KG5vZGUpKTtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGlmIChvZmZzZXQpIHtcbiAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlICE9IDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgbGV0IHByZXYgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0IC0gMV07XG4gICAgICAgICAgICBpZiAocHJldi5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKVxuICAgICAgICAgICAgICAgIG9mZnNldC0tO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IHByZXY7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0KG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUgPT0gZG9jKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9mZnNldCA9IGRvbUluZGV4KG5vZGUpO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGlzU2Nyb2xsZWRUb0JvdHRvbShlbHQpIHtcbiAgICByZXR1cm4gZWx0LnNjcm9sbFRvcCA+IE1hdGgubWF4KDEsIGVsdC5zY3JvbGxIZWlnaHQgLSBlbHQuY2xpZW50SGVpZ2h0IC0gNCk7XG59XG5cbmNsYXNzIERPTVBvcyB7XG4gICAgY29uc3RydWN0b3Iobm9kZSwgb2Zmc2V0LCBwcmVjaXNlID0gdHJ1ZSkge1xuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgdGhpcy5wcmVjaXNlID0gcHJlY2lzZTtcbiAgICB9XG4gICAgc3RhdGljIGJlZm9yZShkb20sIHByZWNpc2UpIHsgcmV0dXJuIG5ldyBET01Qb3MoZG9tLnBhcmVudE5vZGUsIGRvbUluZGV4KGRvbSksIHByZWNpc2UpOyB9XG4gICAgc3RhdGljIGFmdGVyKGRvbSwgcHJlY2lzZSkgeyByZXR1cm4gbmV3IERPTVBvcyhkb20ucGFyZW50Tm9kZSwgZG9tSW5kZXgoZG9tKSArIDEsIHByZWNpc2UpOyB9XG59XG5jb25zdCBub0NoaWxkcmVuID0gW107XG5jbGFzcyBDb250ZW50VmlldyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5kb20gPSBudWxsO1xuICAgICAgICB0aGlzLmZsYWdzID0gMiAvKiBWaWV3RmxhZy5Ob2RlRGlydHkgKi87XG4gICAgfVxuICAgIGdldCBvdmVycmlkZURPTVRleHQoKSB7IHJldHVybiBudWxsOyB9XG4gICAgZ2V0IHBvc0F0U3RhcnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudCA/IHRoaXMucGFyZW50LnBvc0JlZm9yZSh0aGlzKSA6IDA7XG4gICAgfVxuICAgIGdldCBwb3NBdEVuZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zQXRTdGFydCArIHRoaXMubGVuZ3RoO1xuICAgIH1cbiAgICBwb3NCZWZvcmUodmlldykge1xuICAgICAgICBsZXQgcG9zID0gdGhpcy5wb3NBdFN0YXJ0O1xuICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiB0aGlzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQgPT0gdmlldylcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9zO1xuICAgICAgICAgICAgcG9zICs9IGNoaWxkLmxlbmd0aCArIGNoaWxkLmJyZWFrQWZ0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGNoaWxkIGluIHBvc0JlZm9yZVwiKTtcbiAgICB9XG4gICAgcG9zQWZ0ZXIodmlldykge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3NCZWZvcmUodmlldykgKyB2aWV3Lmxlbmd0aDtcbiAgICB9XG4gICAgc3luYyh2aWV3LCB0cmFjaykge1xuICAgICAgICBpZiAodGhpcy5mbGFncyAmIDIgLyogVmlld0ZsYWcuTm9kZURpcnR5ICovKSB7XG4gICAgICAgICAgICBsZXQgcGFyZW50ID0gdGhpcy5kb207XG4gICAgICAgICAgICBsZXQgcHJldiA9IG51bGwsIG5leHQ7XG4gICAgICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiB0aGlzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLmZsYWdzICYgNyAvKiBWaWV3RmxhZy5EaXJ0eSAqLykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNoaWxkLmRvbSAmJiAobmV4dCA9IHByZXYgPyBwcmV2Lm5leHRTaWJsaW5nIDogcGFyZW50LmZpcnN0Q2hpbGQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY29udGVudFZpZXcgPSBDb250ZW50Vmlldy5nZXQobmV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbnRlbnRWaWV3IHx8ICFjb250ZW50Vmlldy5wYXJlbnQgJiYgY29udGVudFZpZXcuY2FuUmV1c2VET00oY2hpbGQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkLnJldXNlRE9NKG5leHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLnN5bmModmlldywgdHJhY2spO1xuICAgICAgICAgICAgICAgICAgICBjaGlsZC5mbGFncyAmPSB+NyAvKiBWaWV3RmxhZy5EaXJ0eSAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV4dCA9IHByZXYgPyBwcmV2Lm5leHRTaWJsaW5nIDogcGFyZW50LmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgaWYgKHRyYWNrICYmICF0cmFjay53cml0dGVuICYmIHRyYWNrLm5vZGUgPT0gcGFyZW50ICYmIG5leHQgIT0gY2hpbGQuZG9tKVxuICAgICAgICAgICAgICAgICAgICB0cmFjay53cml0dGVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQuZG9tLnBhcmVudE5vZGUgPT0gcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChuZXh0ICYmIG5leHQgIT0gY2hpbGQuZG9tKVxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCA9IHJtJDEobmV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKGNoaWxkLmRvbSwgbmV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByZXYgPSBjaGlsZC5kb207XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXh0ID0gcHJldiA/IHByZXYubmV4dFNpYmxpbmcgOiBwYXJlbnQuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIGlmIChuZXh0ICYmIHRyYWNrICYmIHRyYWNrLm5vZGUgPT0gcGFyZW50KVxuICAgICAgICAgICAgICAgIHRyYWNrLndyaXR0ZW4gPSB0cnVlO1xuICAgICAgICAgICAgd2hpbGUgKG5leHQpXG4gICAgICAgICAgICAgICAgbmV4dCA9IHJtJDEobmV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5mbGFncyAmIDEgLyogVmlld0ZsYWcuQ2hpbGREaXJ0eSAqLykge1xuICAgICAgICAgICAgZm9yIChsZXQgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbilcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQuZmxhZ3MgJiA3IC8qIFZpZXdGbGFnLkRpcnR5ICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLnN5bmModmlldywgdHJhY2spO1xuICAgICAgICAgICAgICAgICAgICBjaGlsZC5mbGFncyAmPSB+NyAvKiBWaWV3RmxhZy5EaXJ0eSAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV1c2VET00oX2RvbSkgeyB9XG4gICAgbG9jYWxQb3NGcm9tRE9NKG5vZGUsIG9mZnNldCkge1xuICAgICAgICBsZXQgYWZ0ZXI7XG4gICAgICAgIGlmIChub2RlID09IHRoaXMuZG9tKSB7XG4gICAgICAgICAgICBhZnRlciA9IHRoaXMuZG9tLmNoaWxkTm9kZXNbb2Zmc2V0XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBiaWFzID0gbWF4T2Zmc2V0KG5vZGUpID09IDAgPyAwIDogb2Zmc2V0ID09IDAgPyAtMSA6IDE7XG4gICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgbGV0IHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50ID09IHRoaXMuZG9tKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAoYmlhcyA9PSAwICYmIHBhcmVudC5maXJzdENoaWxkICE9IHBhcmVudC5sYXN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUgPT0gcGFyZW50LmZpcnN0Q2hpbGQpXG4gICAgICAgICAgICAgICAgICAgICAgICBiaWFzID0gLTE7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGJpYXMgPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBub2RlID0gcGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJpYXMgPCAwKVxuICAgICAgICAgICAgICAgIGFmdGVyID0gbm9kZTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBhZnRlciA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFmdGVyID09IHRoaXMuZG9tLmZpcnN0Q2hpbGQpXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgd2hpbGUgKGFmdGVyICYmICFDb250ZW50Vmlldy5nZXQoYWZ0ZXIpKVxuICAgICAgICAgICAgYWZ0ZXIgPSBhZnRlci5uZXh0U2libGluZztcbiAgICAgICAgaWYgKCFhZnRlcilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBvcyA9IDA7OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV07XG4gICAgICAgICAgICBpZiAoY2hpbGQuZG9tID09IGFmdGVyKVxuICAgICAgICAgICAgICAgIHJldHVybiBwb3M7XG4gICAgICAgICAgICBwb3MgKz0gY2hpbGQubGVuZ3RoICsgY2hpbGQuYnJlYWtBZnRlcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkb21Cb3VuZHNBcm91bmQoZnJvbSwgdG8sIG9mZnNldCA9IDApIHtcbiAgICAgICAgbGV0IGZyb21JID0gLTEsIGZyb21TdGFydCA9IC0xLCB0b0kgPSAtMSwgdG9FbmQgPSAtMTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBvcyA9IG9mZnNldCwgcHJldkVuZCA9IG9mZnNldDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sIGVuZCA9IHBvcyArIGNoaWxkLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChwb3MgPCBmcm9tICYmIGVuZCA+IHRvKVxuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZC5kb21Cb3VuZHNBcm91bmQoZnJvbSwgdG8sIHBvcyk7XG4gICAgICAgICAgICBpZiAoZW5kID49IGZyb20gJiYgZnJvbUkgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBmcm9tSSA9IGk7XG4gICAgICAgICAgICAgICAgZnJvbVN0YXJ0ID0gcG9zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBvcyA+IHRvICYmIGNoaWxkLmRvbS5wYXJlbnROb2RlID09IHRoaXMuZG9tKSB7XG4gICAgICAgICAgICAgICAgdG9JID0gaTtcbiAgICAgICAgICAgICAgICB0b0VuZCA9IHByZXZFbmQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2RW5kID0gZW5kO1xuICAgICAgICAgICAgcG9zID0gZW5kICsgY2hpbGQuYnJlYWtBZnRlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBmcm9tOiBmcm9tU3RhcnQsIHRvOiB0b0VuZCA8IDAgPyBvZmZzZXQgKyB0aGlzLmxlbmd0aCA6IHRvRW5kLFxuICAgICAgICAgICAgc3RhcnRET006IChmcm9tSSA/IHRoaXMuY2hpbGRyZW5bZnJvbUkgLSAxXS5kb20ubmV4dFNpYmxpbmcgOiBudWxsKSB8fCB0aGlzLmRvbS5maXJzdENoaWxkLFxuICAgICAgICAgICAgZW5kRE9NOiB0b0kgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aCAmJiB0b0kgPj0gMCA/IHRoaXMuY2hpbGRyZW5bdG9JXS5kb20gOiBudWxsIH07XG4gICAgfVxuICAgIG1hcmtEaXJ0eShhbmRQYXJlbnQgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLmZsYWdzIHw9IDIgLyogVmlld0ZsYWcuTm9kZURpcnR5ICovO1xuICAgICAgICB0aGlzLm1hcmtQYXJlbnRzRGlydHkoYW5kUGFyZW50KTtcbiAgICB9XG4gICAgbWFya1BhcmVudHNEaXJ0eShjaGlsZExpc3QpIHtcbiAgICAgICAgZm9yIChsZXQgcGFyZW50ID0gdGhpcy5wYXJlbnQ7IHBhcmVudDsgcGFyZW50ID0gcGFyZW50LnBhcmVudCkge1xuICAgICAgICAgICAgaWYgKGNoaWxkTGlzdClcbiAgICAgICAgICAgICAgICBwYXJlbnQuZmxhZ3MgfD0gMiAvKiBWaWV3RmxhZy5Ob2RlRGlydHkgKi87XG4gICAgICAgICAgICBpZiAocGFyZW50LmZsYWdzICYgMSAvKiBWaWV3RmxhZy5DaGlsZERpcnR5ICovKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHBhcmVudC5mbGFncyB8PSAxIC8qIFZpZXdGbGFnLkNoaWxkRGlydHkgKi87XG4gICAgICAgICAgICBjaGlsZExpc3QgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRQYXJlbnQocGFyZW50KSB7XG4gICAgICAgIGlmICh0aGlzLnBhcmVudCAhPSBwYXJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICAgICAgaWYgKHRoaXMuZmxhZ3MgJiA3IC8qIFZpZXdGbGFnLkRpcnR5ICovKVxuICAgICAgICAgICAgICAgIHRoaXMubWFya1BhcmVudHNEaXJ0eSh0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRET00oZG9tKSB7XG4gICAgICAgIGlmICh0aGlzLmRvbSA9PSBkb20pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh0aGlzLmRvbSlcbiAgICAgICAgICAgIHRoaXMuZG9tLmNtVmlldyA9IG51bGw7XG4gICAgICAgIHRoaXMuZG9tID0gZG9tO1xuICAgICAgICBkb20uY21WaWV3ID0gdGhpcztcbiAgICB9XG4gICAgZ2V0IHJvb3RWaWV3KCkge1xuICAgICAgICBmb3IgKGxldCB2ID0gdGhpczs7KSB7XG4gICAgICAgICAgICBsZXQgcGFyZW50ID0gdi5wYXJlbnQ7XG4gICAgICAgICAgICBpZiAoIXBhcmVudClcbiAgICAgICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgICAgIHYgPSBwYXJlbnQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVwbGFjZUNoaWxkcmVuKGZyb20sIHRvLCBjaGlsZHJlbiA9IG5vQ2hpbGRyZW4pIHtcbiAgICAgICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IGZyb207IGkgPCB0bzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgaWYgKGNoaWxkLnBhcmVudCA9PSB0aGlzICYmIGNoaWxkcmVuLmluZGV4T2YoY2hpbGQpIDwgMClcbiAgICAgICAgICAgICAgICBjaGlsZC5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGlsZHJlbi5zcGxpY2UoZnJvbSwgdG8gLSBmcm9tLCAuLi5jaGlsZHJlbik7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBjaGlsZHJlbltpXS5zZXRQYXJlbnQodGhpcyk7XG4gICAgfVxuICAgIGlnbm9yZU11dGF0aW9uKF9yZWMpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgaWdub3JlRXZlbnQoX2V2ZW50KSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGNoaWxkQ3Vyc29yKHBvcyA9IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2hpbGRDdXJzb3IodGhpcy5jaGlsZHJlbiwgcG9zLCB0aGlzLmNoaWxkcmVuLmxlbmd0aCk7XG4gICAgfVxuICAgIGNoaWxkUG9zKHBvcywgYmlhcyA9IDEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRDdXJzb3IoKS5maW5kUG9zKHBvcywgYmlhcyk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBsZXQgbmFtZSA9IHRoaXMuY29uc3RydWN0b3IubmFtZS5yZXBsYWNlKFwiVmlld1wiLCBcIlwiKTtcbiAgICAgICAgcmV0dXJuIG5hbWUgKyAodGhpcy5jaGlsZHJlbi5sZW5ndGggPyBcIihcIiArIHRoaXMuY2hpbGRyZW4uam9pbigpICsgXCIpXCIgOlxuICAgICAgICAgICAgdGhpcy5sZW5ndGggPyBcIltcIiArIChuYW1lID09IFwiVGV4dFwiID8gdGhpcy50ZXh0IDogdGhpcy5sZW5ndGgpICsgXCJdXCIgOiBcIlwiKSArXG4gICAgICAgICAgICAodGhpcy5icmVha0FmdGVyID8gXCIjXCIgOiBcIlwiKTtcbiAgICB9XG4gICAgc3RhdGljIGdldChub2RlKSB7IHJldHVybiBub2RlLmNtVmlldzsgfVxuICAgIGdldCBpc0VkaXRhYmxlKCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgIGdldCBpc1dpZGdldCgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgZ2V0IGlzSGlkZGVuKCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBtZXJnZShmcm9tLCB0bywgc291cmNlLCBoYXNTdGFydCwgb3BlblN0YXJ0LCBvcGVuRW5kKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgYmVjb21lKG90aGVyKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGNhblJldXNlRE9NKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBvdGhlci5jb25zdHJ1Y3RvciA9PSB0aGlzLmNvbnN0cnVjdG9yICYmICEoKHRoaXMuZmxhZ3MgfCBvdGhlci5mbGFncykgJiA4IC8qIFZpZXdGbGFnLkNvbXBvc2l0aW9uICovKTtcbiAgICB9XG4gICAgLy8gV2hlbiB0aGlzIGlzIGEgemVyby1sZW5ndGggdmlldyB3aXRoIGEgc2lkZSwgdGhpcyBzaG91bGQgcmV0dXJuIGFcbiAgICAvLyBudW1iZXIgPD0gMCB0byBpbmRpY2F0ZSBpdCBpcyBiZWZvcmUgaXRzIHBvc2l0aW9uLCBvciBhXG4gICAgLy8gbnVtYmVyID4gMCB3aGVuIGFmdGVyIGl0cyBwb3NpdGlvbi5cbiAgICBnZXRTaWRlKCkgeyByZXR1cm4gMDsgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGZvciAobGV0IGNoaWxkIG9mIHRoaXMuY2hpbGRyZW4pXG4gICAgICAgICAgICBjaGlsZC5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICB9XG59XG5Db250ZW50Vmlldy5wcm90b3R5cGUuYnJlYWtBZnRlciA9IDA7XG4vLyBSZW1vdmUgYSBET00gbm9kZSBhbmQgcmV0dXJuIGl0cyBuZXh0IHNpYmxpbmcuXG5mdW5jdGlvbiBybSQxKGRvbSkge1xuICAgIGxldCBuZXh0ID0gZG9tLm5leHRTaWJsaW5nO1xuICAgIGRvbS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGRvbSk7XG4gICAgcmV0dXJuIG5leHQ7XG59XG5jbGFzcyBDaGlsZEN1cnNvciB7XG4gICAgY29uc3RydWN0b3IoY2hpbGRyZW4sIHBvcywgaSkge1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICB0aGlzLmkgPSBpO1xuICAgICAgICB0aGlzLm9mZiA9IDA7XG4gICAgfVxuICAgIGZpbmRQb3MocG9zLCBiaWFzID0gMSkge1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBpZiAocG9zID4gdGhpcy5wb3MgfHwgcG9zID09IHRoaXMucG9zICYmXG4gICAgICAgICAgICAgICAgKGJpYXMgPiAwIHx8IHRoaXMuaSA9PSAwIHx8IHRoaXMuY2hpbGRyZW5bdGhpcy5pIC0gMV0uYnJlYWtBZnRlcikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9mZiA9IHBvcyAtIHRoaXMucG9zO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG5leHQgPSB0aGlzLmNoaWxkcmVuWy0tdGhpcy5pXTtcbiAgICAgICAgICAgIHRoaXMucG9zIC09IG5leHQubGVuZ3RoICsgbmV4dC5icmVha0FmdGVyO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gcmVwbGFjZVJhbmdlKHBhcmVudCwgZnJvbUksIGZyb21PZmYsIHRvSSwgdG9PZmYsIGluc2VydCwgYnJlYWtBdFN0YXJ0LCBvcGVuU3RhcnQsIG9wZW5FbmQpIHtcbiAgICBsZXQgeyBjaGlsZHJlbiB9ID0gcGFyZW50O1xuICAgIGxldCBiZWZvcmUgPSBjaGlsZHJlbi5sZW5ndGggPyBjaGlsZHJlbltmcm9tSV0gOiBudWxsO1xuICAgIGxldCBsYXN0ID0gaW5zZXJ0Lmxlbmd0aCA/IGluc2VydFtpbnNlcnQubGVuZ3RoIC0gMV0gOiBudWxsO1xuICAgIGxldCBicmVha0F0RW5kID0gbGFzdCA/IGxhc3QuYnJlYWtBZnRlciA6IGJyZWFrQXRTdGFydDtcbiAgICAvLyBDaGFuZ2Ugd2l0aGluIGEgc2luZ2xlIGNoaWxkXG4gICAgaWYgKGZyb21JID09IHRvSSAmJiBiZWZvcmUgJiYgIWJyZWFrQXRTdGFydCAmJiAhYnJlYWtBdEVuZCAmJiBpbnNlcnQubGVuZ3RoIDwgMiAmJlxuICAgICAgICBiZWZvcmUubWVyZ2UoZnJvbU9mZiwgdG9PZmYsIGluc2VydC5sZW5ndGggPyBsYXN0IDogbnVsbCwgZnJvbU9mZiA9PSAwLCBvcGVuU3RhcnQsIG9wZW5FbmQpKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKHRvSSA8IGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICBsZXQgYWZ0ZXIgPSBjaGlsZHJlblt0b0ldO1xuICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIGVuZCBvZiB0aGUgY2hpbGQgYWZ0ZXIgdGhlIHVwZGF0ZSBpcyBwcmVzZXJ2ZWQgaW4gYGFmdGVyYFxuICAgICAgICBpZiAoYWZ0ZXIgJiYgKHRvT2ZmIDwgYWZ0ZXIubGVuZ3RoIHx8IGFmdGVyLmJyZWFrQWZ0ZXIgJiYgKGxhc3QgPT09IG51bGwgfHwgbGFzdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGFzdC5icmVha0FmdGVyKSkpIHtcbiAgICAgICAgICAgIC8vIElmIHdlJ3JlIHNwbGl0dGluZyBhIGNoaWxkLCBzZXBhcmF0ZSBwYXJ0IG9mIGl0IHRvIGF2b2lkIHRoYXRcbiAgICAgICAgICAgIC8vIGJlaW5nIG1hbmdsZWQgd2hlbiB1cGRhdGluZyB0aGUgY2hpbGQgYmVmb3JlIHRoZSB1cGRhdGUuXG4gICAgICAgICAgICBpZiAoZnJvbUkgPT0gdG9JKSB7XG4gICAgICAgICAgICAgICAgYWZ0ZXIgPSBhZnRlci5zcGxpdCh0b09mZik7XG4gICAgICAgICAgICAgICAgdG9PZmYgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgdGhlIGVsZW1lbnQgYWZ0ZXIgdGhlIHJlcGxhY2VtZW50IHNob3VsZCBiZSBtZXJnZWQgd2l0aFxuICAgICAgICAgICAgLy8gdGhlIGxhc3QgcmVwbGFjaW5nIGVsZW1lbnQsIHVwZGF0ZSBgY29udGVudGBcbiAgICAgICAgICAgIGlmICghYnJlYWtBdEVuZCAmJiBsYXN0ICYmIGFmdGVyLm1lcmdlKDAsIHRvT2ZmLCBsYXN0LCB0cnVlLCAwLCBvcGVuRW5kKSkge1xuICAgICAgICAgICAgICAgIGluc2VydFtpbnNlcnQubGVuZ3RoIC0gMV0gPSBhZnRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgc3RhcnQgb2YgdGhlIGFmdGVyIGVsZW1lbnQsIGlmIG5lY2Vzc2FyeSwgYW5kXG4gICAgICAgICAgICAgICAgLy8gYWRkIGl0IHRvIGBjb250ZW50YC5cbiAgICAgICAgICAgICAgICBpZiAodG9PZmYgfHwgYWZ0ZXIuY2hpbGRyZW4ubGVuZ3RoICYmICFhZnRlci5jaGlsZHJlblswXS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIGFmdGVyLm1lcmdlKDAsIHRvT2ZmLCBudWxsLCBmYWxzZSwgMCwgb3BlbkVuZCk7XG4gICAgICAgICAgICAgICAgaW5zZXJ0LnB1c2goYWZ0ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFmdGVyID09PSBudWxsIHx8IGFmdGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhZnRlci5icmVha0FmdGVyKSB7XG4gICAgICAgICAgICAvLyBUaGUgZWxlbWVudCBhdCBgdG9JYCBpcyBlbnRpcmVseSBjb3ZlcmVkIGJ5IHRoaXMgcmFuZ2UuXG4gICAgICAgICAgICAvLyBQcmVzZXJ2ZSBpdHMgbGluZSBicmVhaywgaWYgYW55LlxuICAgICAgICAgICAgaWYgKGxhc3QpXG4gICAgICAgICAgICAgICAgbGFzdC5icmVha0FmdGVyID0gMTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBicmVha0F0U3RhcnQgPSAxO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNpbmNlIHdlJ3ZlIGhhbmRsZWQgdGhlIG5leHQgZWxlbWVudCBmcm9tIHRoZSBjdXJyZW50IGVsZW1lbnRzXG4gICAgICAgIC8vIG5vdywgbWFrZSBzdXJlIGB0b0lgIHBvaW50cyBhZnRlciB0aGF0LlxuICAgICAgICB0b0krKztcbiAgICB9XG4gICAgaWYgKGJlZm9yZSkge1xuICAgICAgICBiZWZvcmUuYnJlYWtBZnRlciA9IGJyZWFrQXRTdGFydDtcbiAgICAgICAgaWYgKGZyb21PZmYgPiAwKSB7XG4gICAgICAgICAgICBpZiAoIWJyZWFrQXRTdGFydCAmJiBpbnNlcnQubGVuZ3RoICYmIGJlZm9yZS5tZXJnZShmcm9tT2ZmLCBiZWZvcmUubGVuZ3RoLCBpbnNlcnRbMF0sIGZhbHNlLCBvcGVuU3RhcnQsIDApKSB7XG4gICAgICAgICAgICAgICAgYmVmb3JlLmJyZWFrQWZ0ZXIgPSBpbnNlcnQuc2hpZnQoKS5icmVha0FmdGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZnJvbU9mZiA8IGJlZm9yZS5sZW5ndGggfHwgYmVmb3JlLmNoaWxkcmVuLmxlbmd0aCAmJiBiZWZvcmUuY2hpbGRyZW5bYmVmb3JlLmNoaWxkcmVuLmxlbmd0aCAtIDFdLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgYmVmb3JlLm1lcmdlKGZyb21PZmYsIGJlZm9yZS5sZW5ndGgsIG51bGwsIGZhbHNlLCBvcGVuU3RhcnQsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnJvbUkrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBUcnkgdG8gbWVyZ2Ugd2lkZ2V0cyBvbiB0aGUgYm91bmRhcmllcyBvZiB0aGUgcmVwbGFjZW1lbnRcbiAgICB3aGlsZSAoZnJvbUkgPCB0b0kgJiYgaW5zZXJ0Lmxlbmd0aCkge1xuICAgICAgICBpZiAoY2hpbGRyZW5bdG9JIC0gMV0uYmVjb21lKGluc2VydFtpbnNlcnQubGVuZ3RoIC0gMV0pKSB7XG4gICAgICAgICAgICB0b0ktLTtcbiAgICAgICAgICAgIGluc2VydC5wb3AoKTtcbiAgICAgICAgICAgIG9wZW5FbmQgPSBpbnNlcnQubGVuZ3RoID8gMCA6IG9wZW5TdGFydDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaGlsZHJlbltmcm9tSV0uYmVjb21lKGluc2VydFswXSkpIHtcbiAgICAgICAgICAgIGZyb21JKys7XG4gICAgICAgICAgICBpbnNlcnQuc2hpZnQoKTtcbiAgICAgICAgICAgIG9wZW5TdGFydCA9IGluc2VydC5sZW5ndGggPyAwIDogb3BlbkVuZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghaW5zZXJ0Lmxlbmd0aCAmJiBmcm9tSSAmJiB0b0kgPCBjaGlsZHJlbi5sZW5ndGggJiYgIWNoaWxkcmVuW2Zyb21JIC0gMV0uYnJlYWtBZnRlciAmJlxuICAgICAgICBjaGlsZHJlblt0b0ldLm1lcmdlKDAsIDAsIGNoaWxkcmVuW2Zyb21JIC0gMV0sIGZhbHNlLCBvcGVuU3RhcnQsIG9wZW5FbmQpKVxuICAgICAgICBmcm9tSS0tO1xuICAgIGlmIChmcm9tSSA8IHRvSSB8fCBpbnNlcnQubGVuZ3RoKVxuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkcmVuKGZyb21JLCB0b0ksIGluc2VydCk7XG59XG5mdW5jdGlvbiBtZXJnZUNoaWxkcmVuSW50byhwYXJlbnQsIGZyb20sIHRvLCBpbnNlcnQsIG9wZW5TdGFydCwgb3BlbkVuZCkge1xuICAgIGxldCBjdXIgPSBwYXJlbnQuY2hpbGRDdXJzb3IoKTtcbiAgICBsZXQgeyBpOiB0b0ksIG9mZjogdG9PZmYgfSA9IGN1ci5maW5kUG9zKHRvLCAxKTtcbiAgICBsZXQgeyBpOiBmcm9tSSwgb2ZmOiBmcm9tT2ZmIH0gPSBjdXIuZmluZFBvcyhmcm9tLCAtMSk7XG4gICAgbGV0IGRMZW4gPSBmcm9tIC0gdG87XG4gICAgZm9yIChsZXQgdmlldyBvZiBpbnNlcnQpXG4gICAgICAgIGRMZW4gKz0gdmlldy5sZW5ndGg7XG4gICAgcGFyZW50Lmxlbmd0aCArPSBkTGVuO1xuICAgIHJlcGxhY2VSYW5nZShwYXJlbnQsIGZyb21JLCBmcm9tT2ZmLCB0b0ksIHRvT2ZmLCBpbnNlcnQsIDAsIG9wZW5TdGFydCwgb3BlbkVuZCk7XG59XG5cbmxldCBuYXYgPSB0eXBlb2YgbmF2aWdhdG9yICE9IFwidW5kZWZpbmVkXCIgPyBuYXZpZ2F0b3IgOiB7IHVzZXJBZ2VudDogXCJcIiwgdmVuZG9yOiBcIlwiLCBwbGF0Zm9ybTogXCJcIiB9O1xubGV0IGRvYyA9IHR5cGVvZiBkb2N1bWVudCAhPSBcInVuZGVmaW5lZFwiID8gZG9jdW1lbnQgOiB7IGRvY3VtZW50RWxlbWVudDogeyBzdHlsZToge30gfSB9O1xuY29uc3QgaWVfZWRnZSA9IC8qQF9fUFVSRV9fKi8vRWRnZVxcLyhcXGQrKS8uZXhlYyhuYXYudXNlckFnZW50KTtcbmNvbnN0IGllX3VwdG8xMCA9IC8qQF9fUFVSRV9fKi8vTVNJRSBcXGQvLnRlc3QobmF2LnVzZXJBZ2VudCk7XG5jb25zdCBpZV8xMXVwID0gLypAX19QVVJFX18qLy9UcmlkZW50XFwvKD86WzctOV18XFxkezIsfSlcXC4uKnJ2OihcXGQrKS8uZXhlYyhuYXYudXNlckFnZW50KTtcbmNvbnN0IGllID0gISEoaWVfdXB0bzEwIHx8IGllXzExdXAgfHwgaWVfZWRnZSk7XG5jb25zdCBnZWNrbyA9ICFpZSAmJiAvKkBfX1BVUkVfXyovL2dlY2tvXFwvKFxcZCspL2kudGVzdChuYXYudXNlckFnZW50KTtcbmNvbnN0IGNocm9tZSA9ICFpZSAmJiAvKkBfX1BVUkVfXyovL0Nocm9tZVxcLyhcXGQrKS8uZXhlYyhuYXYudXNlckFnZW50KTtcbmNvbnN0IHdlYmtpdCA9IFwid2Via2l0Rm9udFNtb290aGluZ1wiIGluIGRvYy5kb2N1bWVudEVsZW1lbnQuc3R5bGU7XG5jb25zdCBzYWZhcmkgPSAhaWUgJiYgLypAX19QVVJFX18qLy9BcHBsZSBDb21wdXRlci8udGVzdChuYXYudmVuZG9yKTtcbmNvbnN0IGlvcyA9IHNhZmFyaSAmJiAoLypAX19QVVJFX18qLy9Nb2JpbGVcXC9cXHcrLy50ZXN0KG5hdi51c2VyQWdlbnQpIHx8IG5hdi5tYXhUb3VjaFBvaW50cyA+IDIpO1xudmFyIGJyb3dzZXIgPSB7XG4gICAgbWFjOiBpb3MgfHwgLypAX19QVVJFX18qLy9NYWMvLnRlc3QobmF2LnBsYXRmb3JtKSxcbiAgICB3aW5kb3dzOiAvKkBfX1BVUkVfXyovL1dpbi8udGVzdChuYXYucGxhdGZvcm0pLFxuICAgIGxpbnV4OiAvKkBfX1BVUkVfXyovL0xpbnV4fFgxMS8udGVzdChuYXYucGxhdGZvcm0pLFxuICAgIGllLFxuICAgIGllX3ZlcnNpb246IGllX3VwdG8xMCA/IGRvYy5kb2N1bWVudE1vZGUgfHwgNiA6IGllXzExdXAgPyAraWVfMTF1cFsxXSA6IGllX2VkZ2UgPyAraWVfZWRnZVsxXSA6IDAsXG4gICAgZ2Vja28sXG4gICAgZ2Vja29fdmVyc2lvbjogZ2Vja28gPyArKC8qQF9fUFVSRV9fKi8vRmlyZWZveFxcLyhcXGQrKS8uZXhlYyhuYXYudXNlckFnZW50KSB8fCBbMCwgMF0pWzFdIDogMCxcbiAgICBjaHJvbWU6ICEhY2hyb21lLFxuICAgIGNocm9tZV92ZXJzaW9uOiBjaHJvbWUgPyArY2hyb21lWzFdIDogMCxcbiAgICBpb3MsXG4gICAgYW5kcm9pZDogLypAX19QVVJFX18qLy9BbmRyb2lkXFxiLy50ZXN0KG5hdi51c2VyQWdlbnQpLFxuICAgIHdlYmtpdCxcbiAgICBzYWZhcmksXG4gICAgd2Via2l0X3ZlcnNpb246IHdlYmtpdCA/ICsoLypAX19QVVJFX18qLy9cXGJBcHBsZVdlYktpdFxcLyhcXGQrKS8uZXhlYyhuYXZpZ2F0b3IudXNlckFnZW50KSB8fCBbMCwgMF0pWzFdIDogMCxcbiAgICB0YWJTaXplOiBkb2MuZG9jdW1lbnRFbGVtZW50LnN0eWxlLnRhYlNpemUgIT0gbnVsbCA/IFwidGFiLXNpemVcIiA6IFwiLW1vei10YWItc2l6ZVwiXG59O1xuXG5jb25zdCBNYXhKb2luTGVuID0gMjU2O1xuY2xhc3MgVGV4dFZpZXcgZXh0ZW5kcyBDb250ZW50VmlldyB7XG4gICAgY29uc3RydWN0b3IodGV4dCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgIH1cbiAgICBnZXQgbGVuZ3RoKCkgeyByZXR1cm4gdGhpcy50ZXh0Lmxlbmd0aDsgfVxuICAgIGNyZWF0ZURPTSh0ZXh0RE9NKSB7XG4gICAgICAgIHRoaXMuc2V0RE9NKHRleHRET00gfHwgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGhpcy50ZXh0KSk7XG4gICAgfVxuICAgIHN5bmModmlldywgdHJhY2spIHtcbiAgICAgICAgaWYgKCF0aGlzLmRvbSlcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlRE9NKCk7XG4gICAgICAgIGlmICh0aGlzLmRvbS5ub2RlVmFsdWUgIT0gdGhpcy50ZXh0KSB7XG4gICAgICAgICAgICBpZiAodHJhY2sgJiYgdHJhY2subm9kZSA9PSB0aGlzLmRvbSlcbiAgICAgICAgICAgICAgICB0cmFjay53cml0dGVuID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZG9tLm5vZGVWYWx1ZSA9IHRoaXMudGV4dDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXVzZURPTShkb20pIHtcbiAgICAgICAgaWYgKGRvbS5ub2RlVHlwZSA9PSAzKVxuICAgICAgICAgICAgdGhpcy5jcmVhdGVET00oZG9tKTtcbiAgICB9XG4gICAgbWVyZ2UoZnJvbSwgdG8sIHNvdXJjZSkge1xuICAgICAgICBpZiAoKHRoaXMuZmxhZ3MgJiA4IC8qIFZpZXdGbGFnLkNvbXBvc2l0aW9uICovKSB8fFxuICAgICAgICAgICAgc291cmNlICYmICghKHNvdXJjZSBpbnN0YW5jZW9mIFRleHRWaWV3KSB8fFxuICAgICAgICAgICAgICAgIHRoaXMubGVuZ3RoIC0gKHRvIC0gZnJvbSkgKyBzb3VyY2UubGVuZ3RoID4gTWF4Sm9pbkxlbiB8fFxuICAgICAgICAgICAgICAgIChzb3VyY2UuZmxhZ3MgJiA4IC8qIFZpZXdGbGFnLkNvbXBvc2l0aW9uICovKSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMudGV4dCA9IHRoaXMudGV4dC5zbGljZSgwLCBmcm9tKSArIChzb3VyY2UgPyBzb3VyY2UudGV4dCA6IFwiXCIpICsgdGhpcy50ZXh0LnNsaWNlKHRvKTtcbiAgICAgICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHNwbGl0KGZyb20pIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IG5ldyBUZXh0Vmlldyh0aGlzLnRleHQuc2xpY2UoZnJvbSkpO1xuICAgICAgICB0aGlzLnRleHQgPSB0aGlzLnRleHQuc2xpY2UoMCwgZnJvbSk7XG4gICAgICAgIHRoaXMubWFya0RpcnR5KCk7XG4gICAgICAgIHJlc3VsdC5mbGFncyB8PSB0aGlzLmZsYWdzICYgOCAvKiBWaWV3RmxhZy5Db21wb3NpdGlvbiAqLztcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgbG9jYWxQb3NGcm9tRE9NKG5vZGUsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gbm9kZSA9PSB0aGlzLmRvbSA/IG9mZnNldCA6IG9mZnNldCA/IHRoaXMudGV4dC5sZW5ndGggOiAwO1xuICAgIH1cbiAgICBkb21BdFBvcyhwb3MpIHsgcmV0dXJuIG5ldyBET01Qb3ModGhpcy5kb20sIHBvcyk7IH1cbiAgICBkb21Cb3VuZHNBcm91bmQoX2Zyb20sIF90bywgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB7IGZyb206IG9mZnNldCwgdG86IG9mZnNldCArIHRoaXMubGVuZ3RoLCBzdGFydERPTTogdGhpcy5kb20sIGVuZERPTTogdGhpcy5kb20ubmV4dFNpYmxpbmcgfTtcbiAgICB9XG4gICAgY29vcmRzQXQocG9zLCBzaWRlKSB7XG4gICAgICAgIHJldHVybiB0ZXh0Q29vcmRzKHRoaXMuZG9tLCBwb3MsIHNpZGUpO1xuICAgIH1cbn1cbmNsYXNzIE1hcmtWaWV3IGV4dGVuZHMgQ29udGVudFZpZXcge1xuICAgIGNvbnN0cnVjdG9yKG1hcmssIGNoaWxkcmVuID0gW10sIGxlbmd0aCA9IDApIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5tYXJrID0gbWFyaztcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgY2ggb2YgY2hpbGRyZW4pXG4gICAgICAgICAgICBjaC5zZXRQYXJlbnQodGhpcyk7XG4gICAgfVxuICAgIHNldEF0dHJzKGRvbSkge1xuICAgICAgICBjbGVhckF0dHJpYnV0ZXMoZG9tKTtcbiAgICAgICAgaWYgKHRoaXMubWFyay5jbGFzcylcbiAgICAgICAgICAgIGRvbS5jbGFzc05hbWUgPSB0aGlzLm1hcmsuY2xhc3M7XG4gICAgICAgIGlmICh0aGlzLm1hcmsuYXR0cnMpXG4gICAgICAgICAgICBmb3IgKGxldCBuYW1lIGluIHRoaXMubWFyay5hdHRycylcbiAgICAgICAgICAgICAgICBkb20uc2V0QXR0cmlidXRlKG5hbWUsIHRoaXMubWFyay5hdHRyc1tuYW1lXSk7XG4gICAgICAgIHJldHVybiBkb207XG4gICAgfVxuICAgIGNhblJldXNlRE9NKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5jYW5SZXVzZURPTShvdGhlcikgJiYgISgodGhpcy5mbGFncyB8IG90aGVyLmZsYWdzKSAmIDggLyogVmlld0ZsYWcuQ29tcG9zaXRpb24gKi8pO1xuICAgIH1cbiAgICByZXVzZURPTShub2RlKSB7XG4gICAgICAgIGlmIChub2RlLm5vZGVOYW1lID09IHRoaXMubWFyay50YWdOYW1lLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RE9NKG5vZGUpO1xuICAgICAgICAgICAgdGhpcy5mbGFncyB8PSA0IC8qIFZpZXdGbGFnLkF0dHJzRGlydHkgKi8gfCAyIC8qIFZpZXdGbGFnLk5vZGVEaXJ0eSAqLztcbiAgICAgICAgfVxuICAgIH1cbiAgICBzeW5jKHZpZXcsIHRyYWNrKSB7XG4gICAgICAgIGlmICghdGhpcy5kb20pXG4gICAgICAgICAgICB0aGlzLnNldERPTSh0aGlzLnNldEF0dHJzKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGhpcy5tYXJrLnRhZ05hbWUpKSk7XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZmxhZ3MgJiA0IC8qIFZpZXdGbGFnLkF0dHJzRGlydHkgKi8pXG4gICAgICAgICAgICB0aGlzLnNldEF0dHJzKHRoaXMuZG9tKTtcbiAgICAgICAgc3VwZXIuc3luYyh2aWV3LCB0cmFjayk7XG4gICAgfVxuICAgIG1lcmdlKGZyb20sIHRvLCBzb3VyY2UsIF9oYXNTdGFydCwgb3BlblN0YXJ0LCBvcGVuRW5kKSB7XG4gICAgICAgIGlmIChzb3VyY2UgJiYgKCEoc291cmNlIGluc3RhbmNlb2YgTWFya1ZpZXcgJiYgc291cmNlLm1hcmsuZXEodGhpcy5tYXJrKSkgfHxcbiAgICAgICAgICAgIChmcm9tICYmIG9wZW5TdGFydCA8PSAwKSB8fCAodG8gPCB0aGlzLmxlbmd0aCAmJiBvcGVuRW5kIDw9IDApKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbWVyZ2VDaGlsZHJlbkludG8odGhpcywgZnJvbSwgdG8sIHNvdXJjZSA/IHNvdXJjZS5jaGlsZHJlbiA6IFtdLCBvcGVuU3RhcnQgLSAxLCBvcGVuRW5kIC0gMSk7XG4gICAgICAgIHRoaXMubWFya0RpcnR5KCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBzcGxpdChmcm9tKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXSwgb2ZmID0gMCwgZGV0YWNoRnJvbSA9IC0xLCBpID0gMDtcbiAgICAgICAgZm9yIChsZXQgZWx0IG9mIHRoaXMuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGxldCBlbmQgPSBvZmYgKyBlbHQubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGVuZCA+IGZyb20pXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gob2ZmIDwgZnJvbSA/IGVsdC5zcGxpdChmcm9tIC0gb2ZmKSA6IGVsdCk7XG4gICAgICAgICAgICBpZiAoZGV0YWNoRnJvbSA8IDAgJiYgb2ZmID49IGZyb20pXG4gICAgICAgICAgICAgICAgZGV0YWNoRnJvbSA9IGk7XG4gICAgICAgICAgICBvZmYgPSBlbmQ7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGxlbmd0aCA9IHRoaXMubGVuZ3RoIC0gZnJvbTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBmcm9tO1xuICAgICAgICBpZiAoZGV0YWNoRnJvbSA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuLmxlbmd0aCA9IGRldGFjaEZyb207XG4gICAgICAgICAgICB0aGlzLm1hcmtEaXJ0eSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgTWFya1ZpZXcodGhpcy5tYXJrLCByZXN1bHQsIGxlbmd0aCk7XG4gICAgfVxuICAgIGRvbUF0UG9zKHBvcykge1xuICAgICAgICByZXR1cm4gaW5saW5lRE9NQXRQb3ModGhpcywgcG9zKTtcbiAgICB9XG4gICAgY29vcmRzQXQocG9zLCBzaWRlKSB7XG4gICAgICAgIHJldHVybiBjb29yZHNJbkNoaWxkcmVuKHRoaXMsIHBvcywgc2lkZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gdGV4dENvb3Jkcyh0ZXh0LCBwb3MsIHNpZGUpIHtcbiAgICBsZXQgbGVuZ3RoID0gdGV4dC5ub2RlVmFsdWUubGVuZ3RoO1xuICAgIGlmIChwb3MgPiBsZW5ndGgpXG4gICAgICAgIHBvcyA9IGxlbmd0aDtcbiAgICBsZXQgZnJvbSA9IHBvcywgdG8gPSBwb3MsIGZsYXR0ZW4gPSAwO1xuICAgIGlmIChwb3MgPT0gMCAmJiBzaWRlIDwgMCB8fCBwb3MgPT0gbGVuZ3RoICYmIHNpZGUgPj0gMCkge1xuICAgICAgICBpZiAoIShicm93c2VyLmNocm9tZSB8fCBicm93c2VyLmdlY2tvKSkgeyAvLyBUaGVzZSBicm93c2VycyByZWxpYWJseSByZXR1cm4gdmFsaWQgcmVjdGFuZ2xlcyBmb3IgZW1wdHkgcmFuZ2VzXG4gICAgICAgICAgICBpZiAocG9zKSB7XG4gICAgICAgICAgICAgICAgZnJvbS0tO1xuICAgICAgICAgICAgICAgIGZsYXR0ZW4gPSAxO1xuICAgICAgICAgICAgfSAvLyBGSVhNRSB0aGlzIGlzIHdyb25nIGluIFJUTCB0ZXh0XG4gICAgICAgICAgICBlbHNlIGlmICh0byA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRvKys7XG4gICAgICAgICAgICAgICAgZmxhdHRlbiA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoc2lkZSA8IDApXG4gICAgICAgICAgICBmcm9tLS07XG4gICAgICAgIGVsc2UgaWYgKHRvIDwgbGVuZ3RoKVxuICAgICAgICAgICAgdG8rKztcbiAgICB9XG4gICAgbGV0IHJlY3RzID0gdGV4dFJhbmdlKHRleHQsIGZyb20sIHRvKS5nZXRDbGllbnRSZWN0cygpO1xuICAgIGlmICghcmVjdHMubGVuZ3RoKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgcmVjdCA9IHJlY3RzWyhmbGF0dGVuID8gZmxhdHRlbiA8IDAgOiBzaWRlID49IDApID8gMCA6IHJlY3RzLmxlbmd0aCAtIDFdO1xuICAgIGlmIChicm93c2VyLnNhZmFyaSAmJiAhZmxhdHRlbiAmJiByZWN0LndpZHRoID09IDApXG4gICAgICAgIHJlY3QgPSBBcnJheS5wcm90b3R5cGUuZmluZC5jYWxsKHJlY3RzLCByID0+IHIud2lkdGgpIHx8IHJlY3Q7XG4gICAgcmV0dXJuIGZsYXR0ZW4gPyBmbGF0dGVuUmVjdChyZWN0LCBmbGF0dGVuIDwgMCkgOiByZWN0IHx8IG51bGw7XG59XG4vLyBBbHNvIHVzZWQgZm9yIGNvbGxhcHNlZCByYW5nZXMgdGhhdCBkb24ndCBoYXZlIGEgcGxhY2Vob2xkZXIgd2lkZ2V0IVxuY2xhc3MgV2lkZ2V0VmlldyBleHRlbmRzIENvbnRlbnRWaWV3IHtcbiAgICBzdGF0aWMgY3JlYXRlKHdpZGdldCwgbGVuZ3RoLCBzaWRlKSB7XG4gICAgICAgIHJldHVybiBuZXcgV2lkZ2V0Vmlldyh3aWRnZXQsIGxlbmd0aCwgc2lkZSk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHdpZGdldCwgbGVuZ3RoLCBzaWRlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMud2lkZ2V0ID0gd2lkZ2V0O1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdGhpcy5zaWRlID0gc2lkZTtcbiAgICAgICAgdGhpcy5wcmV2V2lkZ2V0ID0gbnVsbDtcbiAgICB9XG4gICAgc3BsaXQoZnJvbSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gV2lkZ2V0Vmlldy5jcmVhdGUodGhpcy53aWRnZXQsIHRoaXMubGVuZ3RoIC0gZnJvbSwgdGhpcy5zaWRlKTtcbiAgICAgICAgdGhpcy5sZW5ndGggLT0gZnJvbTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgc3luYyh2aWV3KSB7XG4gICAgICAgIGlmICghdGhpcy5kb20gfHwgIXRoaXMud2lkZ2V0LnVwZGF0ZURPTSh0aGlzLmRvbSwgdmlldykpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRvbSAmJiB0aGlzLnByZXZXaWRnZXQpXG4gICAgICAgICAgICAgICAgdGhpcy5wcmV2V2lkZ2V0LmRlc3Ryb3kodGhpcy5kb20pO1xuICAgICAgICAgICAgdGhpcy5wcmV2V2lkZ2V0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuc2V0RE9NKHRoaXMud2lkZ2V0LnRvRE9NKHZpZXcpKTtcbiAgICAgICAgICAgIHRoaXMuZG9tLmNvbnRlbnRFZGl0YWJsZSA9IFwiZmFsc2VcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRTaWRlKCkgeyByZXR1cm4gdGhpcy5zaWRlOyB9XG4gICAgbWVyZ2UoZnJvbSwgdG8sIHNvdXJjZSwgaGFzU3RhcnQsIG9wZW5TdGFydCwgb3BlbkVuZCkge1xuICAgICAgICBpZiAoc291cmNlICYmICghKHNvdXJjZSBpbnN0YW5jZW9mIFdpZGdldFZpZXcpIHx8ICF0aGlzLndpZGdldC5jb21wYXJlKHNvdXJjZS53aWRnZXQpIHx8XG4gICAgICAgICAgICBmcm9tID4gMCAmJiBvcGVuU3RhcnQgPD0gMCB8fCB0byA8IHRoaXMubGVuZ3RoICYmIG9wZW5FbmQgPD0gMCkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gZnJvbSArIChzb3VyY2UgPyBzb3VyY2UubGVuZ3RoIDogMCkgKyAodGhpcy5sZW5ndGggLSB0byk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBiZWNvbWUob3RoZXIpIHtcbiAgICAgICAgaWYgKG90aGVyIGluc3RhbmNlb2YgV2lkZ2V0VmlldyAmJiBvdGhlci5zaWRlID09IHRoaXMuc2lkZSAmJlxuICAgICAgICAgICAgdGhpcy53aWRnZXQuY29uc3RydWN0b3IgPT0gb3RoZXIud2lkZ2V0LmNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMud2lkZ2V0LmNvbXBhcmUob3RoZXIud2lkZ2V0KSlcbiAgICAgICAgICAgICAgICB0aGlzLm1hcmtEaXJ0eSh0cnVlKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmRvbSAmJiAhdGhpcy5wcmV2V2lkZ2V0KVxuICAgICAgICAgICAgICAgIHRoaXMucHJldldpZGdldCA9IHRoaXMud2lkZ2V0O1xuICAgICAgICAgICAgdGhpcy53aWRnZXQgPSBvdGhlci53aWRnZXQ7XG4gICAgICAgICAgICB0aGlzLmxlbmd0aCA9IG90aGVyLmxlbmd0aDtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWdub3JlTXV0YXRpb24oKSB7IHJldHVybiB0cnVlOyB9XG4gICAgaWdub3JlRXZlbnQoZXZlbnQpIHsgcmV0dXJuIHRoaXMud2lkZ2V0Lmlnbm9yZUV2ZW50KGV2ZW50KTsgfVxuICAgIGdldCBvdmVycmlkZURPTVRleHQoKSB7XG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIFRleHQuZW1wdHk7XG4gICAgICAgIGxldCB0b3AgPSB0aGlzO1xuICAgICAgICB3aGlsZSAodG9wLnBhcmVudClcbiAgICAgICAgICAgIHRvcCA9IHRvcC5wYXJlbnQ7XG4gICAgICAgIGxldCB7IHZpZXcgfSA9IHRvcCwgdGV4dCA9IHZpZXcgJiYgdmlldy5zdGF0ZS5kb2MsIHN0YXJ0ID0gdGhpcy5wb3NBdFN0YXJ0O1xuICAgICAgICByZXR1cm4gdGV4dCA/IHRleHQuc2xpY2Uoc3RhcnQsIHN0YXJ0ICsgdGhpcy5sZW5ndGgpIDogVGV4dC5lbXB0eTtcbiAgICB9XG4gICAgZG9tQXRQb3MocG9zKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5sZW5ndGggPyBwb3MgPT0gMCA6IHRoaXMuc2lkZSA+IDApXG4gICAgICAgICAgICA/IERPTVBvcy5iZWZvcmUodGhpcy5kb20pXG4gICAgICAgICAgICA6IERPTVBvcy5hZnRlcih0aGlzLmRvbSwgcG9zID09IHRoaXMubGVuZ3RoKTtcbiAgICB9XG4gICAgZG9tQm91bmRzQXJvdW5kKCkgeyByZXR1cm4gbnVsbDsgfVxuICAgIGNvb3Jkc0F0KHBvcywgc2lkZSkge1xuICAgICAgICBsZXQgY3VzdG9tID0gdGhpcy53aWRnZXQuY29vcmRzQXQodGhpcy5kb20sIHBvcywgc2lkZSk7XG4gICAgICAgIGlmIChjdXN0b20pXG4gICAgICAgICAgICByZXR1cm4gY3VzdG9tO1xuICAgICAgICBsZXQgcmVjdHMgPSB0aGlzLmRvbS5nZXRDbGllbnRSZWN0cygpLCByZWN0ID0gbnVsbDtcbiAgICAgICAgaWYgKCFyZWN0cy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IGZyb21CYWNrID0gdGhpcy5zaWRlID8gdGhpcy5zaWRlIDwgMCA6IHBvcyA+IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSBmcm9tQmFjayA/IHJlY3RzLmxlbmd0aCAtIDEgOiAwOzsgaSArPSAoZnJvbUJhY2sgPyAtMSA6IDEpKSB7XG4gICAgICAgICAgICByZWN0ID0gcmVjdHNbaV07XG4gICAgICAgICAgICBpZiAocG9zID4gMCA/IGkgPT0gMCA6IGkgPT0gcmVjdHMubGVuZ3RoIC0gMSB8fCByZWN0LnRvcCA8IHJlY3QuYm90dG9tKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmbGF0dGVuUmVjdChyZWN0LCAhZnJvbUJhY2spO1xuICAgIH1cbiAgICBnZXQgaXNFZGl0YWJsZSgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgZ2V0IGlzV2lkZ2V0KCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgIGdldCBpc0hpZGRlbigpIHsgcmV0dXJuIHRoaXMud2lkZ2V0LmlzSGlkZGVuOyB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xuICAgICAgICBpZiAodGhpcy5kb20pXG4gICAgICAgICAgICB0aGlzLndpZGdldC5kZXN0cm95KHRoaXMuZG9tKTtcbiAgICB9XG59XG4vLyBUaGVzZSBhcmUgZHJhd24gYXJvdW5kIHVuZWRpdGFibGUgd2lkZ2V0cyB0byBhdm9pZCBhIG51bWJlciBvZlxuLy8gYnJvd3NlciBidWdzIHRoYXQgc2hvdyB1cCB3aGVuIHRoZSBjdXJzb3IgaXMgZGlyZWN0bHkgbmV4dCB0b1xuLy8gdW5lZGl0YWJsZSBpbmxpbmUgY29udGVudC5cbmNsYXNzIFdpZGdldEJ1ZmZlclZpZXcgZXh0ZW5kcyBDb250ZW50VmlldyB7XG4gICAgY29uc3RydWN0b3Ioc2lkZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnNpZGUgPSBzaWRlO1xuICAgIH1cbiAgICBnZXQgbGVuZ3RoKCkgeyByZXR1cm4gMDsgfVxuICAgIG1lcmdlKCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBiZWNvbWUob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIG90aGVyIGluc3RhbmNlb2YgV2lkZ2V0QnVmZmVyVmlldyAmJiBvdGhlci5zaWRlID09IHRoaXMuc2lkZTtcbiAgICB9XG4gICAgc3BsaXQoKSB7IHJldHVybiBuZXcgV2lkZ2V0QnVmZmVyVmlldyh0aGlzLnNpZGUpOyB9XG4gICAgc3luYygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRvbSkge1xuICAgICAgICAgICAgbGV0IGRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7XG4gICAgICAgICAgICBkb20uY2xhc3NOYW1lID0gXCJjbS13aWRnZXRCdWZmZXJcIjtcbiAgICAgICAgICAgIGRvbS5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCBcInRydWVcIik7XG4gICAgICAgICAgICB0aGlzLnNldERPTShkb20pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldFNpZGUoKSB7IHJldHVybiB0aGlzLnNpZGU7IH1cbiAgICBkb21BdFBvcyhwb3MpIHsgcmV0dXJuIHRoaXMuc2lkZSA+IDAgPyBET01Qb3MuYmVmb3JlKHRoaXMuZG9tKSA6IERPTVBvcy5hZnRlcih0aGlzLmRvbSk7IH1cbiAgICBsb2NhbFBvc0Zyb21ET00oKSB7IHJldHVybiAwOyB9XG4gICAgZG9tQm91bmRzQXJvdW5kKCkgeyByZXR1cm4gbnVsbDsgfVxuICAgIGNvb3Jkc0F0KHBvcykge1xuICAgICAgICByZXR1cm4gdGhpcy5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgfVxuICAgIGdldCBvdmVycmlkZURPTVRleHQoKSB7XG4gICAgICAgIHJldHVybiBUZXh0LmVtcHR5O1xuICAgIH1cbiAgICBnZXQgaXNIaWRkZW4oKSB7IHJldHVybiB0cnVlOyB9XG59XG5UZXh0Vmlldy5wcm90b3R5cGUuY2hpbGRyZW4gPSBXaWRnZXRWaWV3LnByb3RvdHlwZS5jaGlsZHJlbiA9IFdpZGdldEJ1ZmZlclZpZXcucHJvdG90eXBlLmNoaWxkcmVuID0gbm9DaGlsZHJlbjtcbmZ1bmN0aW9uIGlubGluZURPTUF0UG9zKHBhcmVudCwgcG9zKSB7XG4gICAgbGV0IGRvbSA9IHBhcmVudC5kb20sIHsgY2hpbGRyZW4gfSA9IHBhcmVudCwgaSA9IDA7XG4gICAgZm9yIChsZXQgb2ZmID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBjaGlsZCA9IGNoaWxkcmVuW2ldLCBlbmQgPSBvZmYgKyBjaGlsZC5sZW5ndGg7XG4gICAgICAgIGlmIChlbmQgPT0gb2ZmICYmIGNoaWxkLmdldFNpZGUoKSA8PSAwKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmIChwb3MgPiBvZmYgJiYgcG9zIDwgZW5kICYmIGNoaWxkLmRvbS5wYXJlbnROb2RlID09IGRvbSlcbiAgICAgICAgICAgIHJldHVybiBjaGlsZC5kb21BdFBvcyhwb3MgLSBvZmYpO1xuICAgICAgICBpZiAocG9zIDw9IG9mZilcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBvZmYgPSBlbmQ7XG4gICAgfVxuICAgIGZvciAobGV0IGogPSBpOyBqID4gMDsgai0tKSB7XG4gICAgICAgIGxldCBwcmV2ID0gY2hpbGRyZW5baiAtIDFdO1xuICAgICAgICBpZiAocHJldi5kb20ucGFyZW50Tm9kZSA9PSBkb20pXG4gICAgICAgICAgICByZXR1cm4gcHJldi5kb21BdFBvcyhwcmV2Lmxlbmd0aCk7XG4gICAgfVxuICAgIGZvciAobGV0IGogPSBpOyBqIDwgY2hpbGRyZW4ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgbGV0IG5leHQgPSBjaGlsZHJlbltqXTtcbiAgICAgICAgaWYgKG5leHQuZG9tLnBhcmVudE5vZGUgPT0gZG9tKVxuICAgICAgICAgICAgcmV0dXJuIG5leHQuZG9tQXRQb3MoMCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRE9NUG9zKGRvbSwgMCk7XG59XG4vLyBBc3N1bWVzIGB2aWV3YCwgaWYgYSBtYXJrIHZpZXcsIGhhcyBwcmVjaXNlbHkgMSBjaGlsZC5cbmZ1bmN0aW9uIGpvaW5JbmxpbmVJbnRvKHBhcmVudCwgdmlldywgb3Blbikge1xuICAgIGxldCBsYXN0LCB7IGNoaWxkcmVuIH0gPSBwYXJlbnQ7XG4gICAgaWYgKG9wZW4gPiAwICYmIHZpZXcgaW5zdGFuY2VvZiBNYXJrVmlldyAmJiBjaGlsZHJlbi5sZW5ndGggJiZcbiAgICAgICAgKGxhc3QgPSBjaGlsZHJlbltjaGlsZHJlbi5sZW5ndGggLSAxXSkgaW5zdGFuY2VvZiBNYXJrVmlldyAmJiBsYXN0Lm1hcmsuZXEodmlldy5tYXJrKSkge1xuICAgICAgICBqb2luSW5saW5lSW50byhsYXN0LCB2aWV3LmNoaWxkcmVuWzBdLCBvcGVuIC0gMSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjaGlsZHJlbi5wdXNoKHZpZXcpO1xuICAgICAgICB2aWV3LnNldFBhcmVudChwYXJlbnQpO1xuICAgIH1cbiAgICBwYXJlbnQubGVuZ3RoICs9IHZpZXcubGVuZ3RoO1xufVxuZnVuY3Rpb24gY29vcmRzSW5DaGlsZHJlbih2aWV3LCBwb3MsIHNpZGUpIHtcbiAgICBsZXQgYmVmb3JlID0gbnVsbCwgYmVmb3JlUG9zID0gLTEsIGFmdGVyID0gbnVsbCwgYWZ0ZXJQb3MgPSAtMTtcbiAgICBmdW5jdGlvbiBzY2FuKHZpZXcsIHBvcykge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgb2ZmID0gMDsgaSA8IHZpZXcuY2hpbGRyZW4ubGVuZ3RoICYmIG9mZiA8PSBwb3M7IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gdmlldy5jaGlsZHJlbltpXSwgZW5kID0gb2ZmICsgY2hpbGQubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGVuZCA+PSBwb3MpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjYW4oY2hpbGQsIHBvcyAtIG9mZik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCghYWZ0ZXIgfHwgYWZ0ZXIuaXNIaWRkZW4gJiYgc2lkZSA+IDApICYmXG4gICAgICAgICAgICAgICAgICAgIChlbmQgPiBwb3MgfHwgb2ZmID09IGVuZCAmJiBjaGlsZC5nZXRTaWRlKCkgPiAwKSkge1xuICAgICAgICAgICAgICAgICAgICBhZnRlciA9IGNoaWxkO1xuICAgICAgICAgICAgICAgICAgICBhZnRlclBvcyA9IHBvcyAtIG9mZjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob2ZmIDwgcG9zIHx8IChvZmYgPT0gZW5kICYmIGNoaWxkLmdldFNpZGUoKSA8IDApICYmICFjaGlsZC5pc0hpZGRlbikge1xuICAgICAgICAgICAgICAgICAgICBiZWZvcmUgPSBjaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgYmVmb3JlUG9zID0gcG9zIC0gb2ZmO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9mZiA9IGVuZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzY2FuKHZpZXcsIHBvcyk7XG4gICAgbGV0IHRhcmdldCA9IChzaWRlIDwgMCA/IGJlZm9yZSA6IGFmdGVyKSB8fCBiZWZvcmUgfHwgYWZ0ZXI7XG4gICAgaWYgKHRhcmdldClcbiAgICAgICAgcmV0dXJuIHRhcmdldC5jb29yZHNBdChNYXRoLm1heCgwLCB0YXJnZXQgPT0gYmVmb3JlID8gYmVmb3JlUG9zIDogYWZ0ZXJQb3MpLCBzaWRlKTtcbiAgICByZXR1cm4gZmFsbGJhY2tSZWN0KHZpZXcpO1xufVxuZnVuY3Rpb24gZmFsbGJhY2tSZWN0KHZpZXcpIHtcbiAgICBsZXQgbGFzdCA9IHZpZXcuZG9tLmxhc3RDaGlsZDtcbiAgICBpZiAoIWxhc3QpXG4gICAgICAgIHJldHVybiB2aWV3LmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBsZXQgcmVjdHMgPSBjbGllbnRSZWN0c0ZvcihsYXN0KTtcbiAgICByZXR1cm4gcmVjdHNbcmVjdHMubGVuZ3RoIC0gMV0gfHwgbnVsbDtcbn1cblxuZnVuY3Rpb24gY29tYmluZUF0dHJzKHNvdXJjZSwgdGFyZ2V0KSB7XG4gICAgZm9yIChsZXQgbmFtZSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKG5hbWUgPT0gXCJjbGFzc1wiICYmIHRhcmdldC5jbGFzcylcbiAgICAgICAgICAgIHRhcmdldC5jbGFzcyArPSBcIiBcIiArIHNvdXJjZS5jbGFzcztcbiAgICAgICAgZWxzZSBpZiAobmFtZSA9PSBcInN0eWxlXCIgJiYgdGFyZ2V0LnN0eWxlKVxuICAgICAgICAgICAgdGFyZ2V0LnN0eWxlICs9IFwiO1wiICsgc291cmNlLnN0eWxlO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0YXJnZXRbbmFtZV0gPSBzb3VyY2VbbmFtZV07XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59XG5jb25zdCBub0F0dHJzID0gLypAX19QVVJFX18qL09iamVjdC5jcmVhdGUobnVsbCk7XG5mdW5jdGlvbiBhdHRyc0VxKGEsIGIsIGlnbm9yZSkge1xuICAgIGlmIChhID09IGIpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmICghYSlcbiAgICAgICAgYSA9IG5vQXR0cnM7XG4gICAgaWYgKCFiKVxuICAgICAgICBiID0gbm9BdHRycztcbiAgICBsZXQga2V5c0EgPSBPYmplY3Qua2V5cyhhKSwga2V5c0IgPSBPYmplY3Qua2V5cyhiKTtcbiAgICBpZiAoa2V5c0EubGVuZ3RoIC0gKGlnbm9yZSAmJiBrZXlzQS5pbmRleE9mKGlnbm9yZSkgPiAtMSA/IDEgOiAwKSAhPVxuICAgICAgICBrZXlzQi5sZW5ndGggLSAoaWdub3JlICYmIGtleXNCLmluZGV4T2YoaWdub3JlKSA+IC0xID8gMSA6IDApKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQga2V5IG9mIGtleXNBKSB7XG4gICAgICAgIGlmIChrZXkgIT0gaWdub3JlICYmIChrZXlzQi5pbmRleE9mKGtleSkgPT0gLTEgfHwgYVtrZXldICE9PSBiW2tleV0pKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUF0dHJzKGRvbSwgcHJldiwgYXR0cnMpIHtcbiAgICBsZXQgY2hhbmdlZCA9IGZhbHNlO1xuICAgIGlmIChwcmV2KVxuICAgICAgICBmb3IgKGxldCBuYW1lIGluIHByZXYpXG4gICAgICAgICAgICBpZiAoIShhdHRycyAmJiBuYW1lIGluIGF0dHJzKSkge1xuICAgICAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChuYW1lID09IFwic3R5bGVcIilcbiAgICAgICAgICAgICAgICAgICAgZG9tLnN0eWxlLmNzc1RleHQgPSBcIlwiO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgZG9tLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICBpZiAoYXR0cnMpXG4gICAgICAgIGZvciAobGV0IG5hbWUgaW4gYXR0cnMpXG4gICAgICAgICAgICBpZiAoIShwcmV2ICYmIHByZXZbbmFtZV0gPT0gYXR0cnNbbmFtZV0pKSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUgPT0gXCJzdHlsZVwiKVxuICAgICAgICAgICAgICAgICAgICBkb20uc3R5bGUuY3NzVGV4dCA9IGF0dHJzW25hbWVdO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgZG9tLnNldEF0dHJpYnV0ZShuYW1lLCBhdHRyc1tuYW1lXSk7XG4gICAgICAgICAgICB9XG4gICAgcmV0dXJuIGNoYW5nZWQ7XG59XG5mdW5jdGlvbiBnZXRBdHRycyhkb20pIHtcbiAgICBsZXQgYXR0cnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZG9tLmF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGF0dHIgPSBkb20uYXR0cmlidXRlc1tpXTtcbiAgICAgICAgYXR0cnNbYXR0ci5uYW1lXSA9IGF0dHIudmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBhdHRycztcbn1cblxuY2xhc3MgTGluZVZpZXcgZXh0ZW5kcyBDb250ZW50VmlldyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLnByZXZBdHRycyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5hdHRycyA9IG51bGw7XG4gICAgICAgIHRoaXMuYnJlYWtBZnRlciA9IDA7XG4gICAgfVxuICAgIC8vIENvbnN1bWVzIHNvdXJjZVxuICAgIG1lcmdlKGZyb20sIHRvLCBzb3VyY2UsIGhhc1N0YXJ0LCBvcGVuU3RhcnQsIG9wZW5FbmQpIHtcbiAgICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKCEoc291cmNlIGluc3RhbmNlb2YgTGluZVZpZXcpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmICghdGhpcy5kb20pXG4gICAgICAgICAgICAgICAgc291cmNlLnRyYW5zZmVyRE9NKHRoaXMpOyAvLyBSZXVzZSBzb3VyY2UuZG9tIHdoZW4gYXBwcm9wcmlhdGVcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzU3RhcnQpXG4gICAgICAgICAgICB0aGlzLnNldERlY28oc291cmNlID8gc291cmNlLmF0dHJzIDogbnVsbCk7XG4gICAgICAgIG1lcmdlQ2hpbGRyZW5JbnRvKHRoaXMsIGZyb20sIHRvLCBzb3VyY2UgPyBzb3VyY2UuY2hpbGRyZW4gOiBbXSwgb3BlblN0YXJ0LCBvcGVuRW5kKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHNwbGl0KGF0KSB7XG4gICAgICAgIGxldCBlbmQgPSBuZXcgTGluZVZpZXc7XG4gICAgICAgIGVuZC5icmVha0FmdGVyID0gdGhpcy5icmVha0FmdGVyO1xuICAgICAgICBpZiAodGhpcy5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHJldHVybiBlbmQ7XG4gICAgICAgIGxldCB7IGksIG9mZiB9ID0gdGhpcy5jaGlsZFBvcyhhdCk7XG4gICAgICAgIGlmIChvZmYpIHtcbiAgICAgICAgICAgIGVuZC5hcHBlbmQodGhpcy5jaGlsZHJlbltpXS5zcGxpdChvZmYpLCAwKTtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5baV0ubWVyZ2Uob2ZmLCB0aGlzLmNoaWxkcmVuW2ldLmxlbmd0aCwgbnVsbCwgZmFsc2UsIDAsIDApO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGogPSBpOyBqIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGorKylcbiAgICAgICAgICAgIGVuZC5hcHBlbmQodGhpcy5jaGlsZHJlbltqXSwgMCk7XG4gICAgICAgIHdoaWxlIChpID4gMCAmJiB0aGlzLmNoaWxkcmVuW2kgLSAxXS5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5bLS1pXS5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4ubGVuZ3RoID0gaTtcbiAgICAgICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBhdDtcbiAgICAgICAgcmV0dXJuIGVuZDtcbiAgICB9XG4gICAgdHJhbnNmZXJET00ob3RoZXIpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRvbSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICAgICAgb3RoZXIuc2V0RE9NKHRoaXMuZG9tKTtcbiAgICAgICAgb3RoZXIucHJldkF0dHJzID0gdGhpcy5wcmV2QXR0cnMgPT09IHVuZGVmaW5lZCA/IHRoaXMuYXR0cnMgOiB0aGlzLnByZXZBdHRycztcbiAgICAgICAgdGhpcy5wcmV2QXR0cnMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuZG9tID0gbnVsbDtcbiAgICB9XG4gICAgc2V0RGVjbyhhdHRycykge1xuICAgICAgICBpZiAoIWF0dHJzRXEodGhpcy5hdHRycywgYXR0cnMpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kb20pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByZXZBdHRycyA9IHRoaXMuYXR0cnM7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYXR0cnMgPSBhdHRycztcbiAgICAgICAgfVxuICAgIH1cbiAgICBhcHBlbmQoY2hpbGQsIG9wZW5TdGFydCkge1xuICAgICAgICBqb2luSW5saW5lSW50byh0aGlzLCBjaGlsZCwgb3BlblN0YXJ0KTtcbiAgICB9XG4gICAgLy8gT25seSBjYWxsZWQgd2hlbiBidWlsZGluZyBhIGxpbmUgdmlldyBpbiBDb250ZW50QnVpbGRlclxuICAgIGFkZExpbmVEZWNvKGRlY28pIHtcbiAgICAgICAgbGV0IGF0dHJzID0gZGVjby5zcGVjLmF0dHJpYnV0ZXMsIGNscyA9IGRlY28uc3BlYy5jbGFzcztcbiAgICAgICAgaWYgKGF0dHJzKVxuICAgICAgICAgICAgdGhpcy5hdHRycyA9IGNvbWJpbmVBdHRycyhhdHRycywgdGhpcy5hdHRycyB8fCB7fSk7XG4gICAgICAgIGlmIChjbHMpXG4gICAgICAgICAgICB0aGlzLmF0dHJzID0gY29tYmluZUF0dHJzKHsgY2xhc3M6IGNscyB9LCB0aGlzLmF0dHJzIHx8IHt9KTtcbiAgICB9XG4gICAgZG9tQXRQb3MocG9zKSB7XG4gICAgICAgIHJldHVybiBpbmxpbmVET01BdFBvcyh0aGlzLCBwb3MpO1xuICAgIH1cbiAgICByZXVzZURPTShub2RlKSB7XG4gICAgICAgIGlmIChub2RlLm5vZGVOYW1lID09IFwiRElWXCIpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RE9NKG5vZGUpO1xuICAgICAgICAgICAgdGhpcy5mbGFncyB8PSA0IC8qIFZpZXdGbGFnLkF0dHJzRGlydHkgKi8gfCAyIC8qIFZpZXdGbGFnLk5vZGVEaXJ0eSAqLztcbiAgICAgICAgfVxuICAgIH1cbiAgICBzeW5jKHZpZXcsIHRyYWNrKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCF0aGlzLmRvbSkge1xuICAgICAgICAgICAgdGhpcy5zZXRET00oZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSk7XG4gICAgICAgICAgICB0aGlzLmRvbS5jbGFzc05hbWUgPSBcImNtLWxpbmVcIjtcbiAgICAgICAgICAgIHRoaXMucHJldkF0dHJzID0gdGhpcy5hdHRycyA/IG51bGwgOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5mbGFncyAmIDQgLyogVmlld0ZsYWcuQXR0cnNEaXJ0eSAqLykge1xuICAgICAgICAgICAgY2xlYXJBdHRyaWJ1dGVzKHRoaXMuZG9tKTtcbiAgICAgICAgICAgIHRoaXMuZG9tLmNsYXNzTmFtZSA9IFwiY20tbGluZVwiO1xuICAgICAgICAgICAgdGhpcy5wcmV2QXR0cnMgPSB0aGlzLmF0dHJzID8gbnVsbCA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wcmV2QXR0cnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdXBkYXRlQXR0cnModGhpcy5kb20sIHRoaXMucHJldkF0dHJzLCB0aGlzLmF0dHJzKTtcbiAgICAgICAgICAgIHRoaXMuZG9tLmNsYXNzTGlzdC5hZGQoXCJjbS1saW5lXCIpO1xuICAgICAgICAgICAgdGhpcy5wcmV2QXR0cnMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIuc3luYyh2aWV3LCB0cmFjayk7XG4gICAgICAgIGxldCBsYXN0ID0gdGhpcy5kb20ubGFzdENoaWxkO1xuICAgICAgICB3aGlsZSAobGFzdCAmJiBDb250ZW50Vmlldy5nZXQobGFzdCkgaW5zdGFuY2VvZiBNYXJrVmlldylcbiAgICAgICAgICAgIGxhc3QgPSBsYXN0Lmxhc3RDaGlsZDtcbiAgICAgICAgaWYgKCFsYXN0IHx8ICF0aGlzLmxlbmd0aCB8fFxuICAgICAgICAgICAgbGFzdC5ub2RlTmFtZSAhPSBcIkJSXCIgJiYgKChfYSA9IENvbnRlbnRWaWV3LmdldChsYXN0KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlzRWRpdGFibGUpID09IGZhbHNlICYmXG4gICAgICAgICAgICAgICAgKCFicm93c2VyLmlvcyB8fCAhdGhpcy5jaGlsZHJlbi5zb21lKGNoID0+IGNoIGluc3RhbmNlb2YgVGV4dFZpZXcpKSkge1xuICAgICAgICAgICAgbGV0IGhhY2sgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiQlJcIik7XG4gICAgICAgICAgICBoYWNrLmNtSWdub3JlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZG9tLmFwcGVuZENoaWxkKGhhY2spO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1lYXN1cmVUZXh0U2l6ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoID09IDAgfHwgdGhpcy5sZW5ndGggPiAyMClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgdG90YWxXaWR0aCA9IDAsIHRleHRIZWlnaHQ7XG4gICAgICAgIGZvciAobGV0IGNoaWxkIG9mIHRoaXMuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGlmICghKGNoaWxkIGluc3RhbmNlb2YgVGV4dFZpZXcpIHx8IC9bXiAtfl0vLnRlc3QoY2hpbGQudGV4dCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBsZXQgcmVjdHMgPSBjbGllbnRSZWN0c0ZvcihjaGlsZC5kb20pO1xuICAgICAgICAgICAgaWYgKHJlY3RzLmxlbmd0aCAhPSAxKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgdG90YWxXaWR0aCArPSByZWN0c1swXS53aWR0aDtcbiAgICAgICAgICAgIHRleHRIZWlnaHQgPSByZWN0c1swXS5oZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICF0b3RhbFdpZHRoID8gbnVsbCA6IHtcbiAgICAgICAgICAgIGxpbmVIZWlnaHQ6IHRoaXMuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCxcbiAgICAgICAgICAgIGNoYXJXaWR0aDogdG90YWxXaWR0aCAvIHRoaXMubGVuZ3RoLFxuICAgICAgICAgICAgdGV4dEhlaWdodFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb29yZHNBdChwb3MsIHNpZGUpIHtcbiAgICAgICAgbGV0IHJlY3QgPSBjb29yZHNJbkNoaWxkcmVuKHRoaXMsIHBvcywgc2lkZSk7XG4gICAgICAgIC8vIENvcnJlY3QgcmVjdGFuZ2xlIGhlaWdodCBmb3IgZW1wdHkgbGluZXMgd2hlbiB0aGUgcmV0dXJuZWRcbiAgICAgICAgLy8gaGVpZ2h0IGlzIGxhcmdlciB0aGFuIHRoZSB0ZXh0IGhlaWdodC5cbiAgICAgICAgaWYgKCF0aGlzLmNoaWxkcmVuLmxlbmd0aCAmJiByZWN0ICYmIHRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICBsZXQgeyBoZWlnaHRPcmFjbGUgfSA9IHRoaXMucGFyZW50LnZpZXcudmlld1N0YXRlLCBoZWlnaHQgPSByZWN0LmJvdHRvbSAtIHJlY3QudG9wO1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKGhlaWdodCAtIGhlaWdodE9yYWNsZS5saW5lSGVpZ2h0KSA8IDIgJiYgaGVpZ2h0T3JhY2xlLnRleHRIZWlnaHQgPCBoZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBsZXQgZGlzdCA9IChoZWlnaHQgLSBoZWlnaHRPcmFjbGUudGV4dEhlaWdodCkgLyAyO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHRvcDogcmVjdC50b3AgKyBkaXN0LCBib3R0b206IHJlY3QuYm90dG9tIC0gZGlzdCwgbGVmdDogcmVjdC5sZWZ0LCByaWdodDogcmVjdC5sZWZ0IH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgfVxuICAgIGJlY29tZShfb3RoZXIpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgY292ZXJzKCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgIHN0YXRpYyBmaW5kKGRvY1ZpZXcsIHBvcykge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgb2ZmID0gMDsgaSA8IGRvY1ZpZXcuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBibG9jayA9IGRvY1ZpZXcuY2hpbGRyZW5baV0sIGVuZCA9IG9mZiArIGJsb2NrLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChlbmQgPj0gcG9zKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJsb2NrIGluc3RhbmNlb2YgTGluZVZpZXcpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBibG9jaztcbiAgICAgICAgICAgICAgICBpZiAoZW5kID4gcG9zKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9mZiA9IGVuZCArIGJsb2NrLmJyZWFrQWZ0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuY2xhc3MgQmxvY2tXaWRnZXRWaWV3IGV4dGVuZHMgQ29udGVudFZpZXcge1xuICAgIGNvbnN0cnVjdG9yKHdpZGdldCwgbGVuZ3RoLCBkZWNvKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMud2lkZ2V0ID0gd2lkZ2V0O1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdGhpcy5kZWNvID0gZGVjbztcbiAgICAgICAgdGhpcy5icmVha0FmdGVyID0gMDtcbiAgICAgICAgdGhpcy5wcmV2V2lkZ2V0ID0gbnVsbDtcbiAgICB9XG4gICAgbWVyZ2UoZnJvbSwgdG8sIHNvdXJjZSwgX3Rha2VEZWNvLCBvcGVuU3RhcnQsIG9wZW5FbmQpIHtcbiAgICAgICAgaWYgKHNvdXJjZSAmJiAoIShzb3VyY2UgaW5zdGFuY2VvZiBCbG9ja1dpZGdldFZpZXcpIHx8ICF0aGlzLndpZGdldC5jb21wYXJlKHNvdXJjZS53aWRnZXQpIHx8XG4gICAgICAgICAgICBmcm9tID4gMCAmJiBvcGVuU3RhcnQgPD0gMCB8fCB0byA8IHRoaXMubGVuZ3RoICYmIG9wZW5FbmQgPD0gMCkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gZnJvbSArIChzb3VyY2UgPyBzb3VyY2UubGVuZ3RoIDogMCkgKyAodGhpcy5sZW5ndGggLSB0byk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBkb21BdFBvcyhwb3MpIHtcbiAgICAgICAgcmV0dXJuIHBvcyA9PSAwID8gRE9NUG9zLmJlZm9yZSh0aGlzLmRvbSkgOiBET01Qb3MuYWZ0ZXIodGhpcy5kb20sIHBvcyA9PSB0aGlzLmxlbmd0aCk7XG4gICAgfVxuICAgIHNwbGl0KGF0KSB7XG4gICAgICAgIGxldCBsZW4gPSB0aGlzLmxlbmd0aCAtIGF0O1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGF0O1xuICAgICAgICBsZXQgZW5kID0gbmV3IEJsb2NrV2lkZ2V0Vmlldyh0aGlzLndpZGdldCwgbGVuLCB0aGlzLmRlY28pO1xuICAgICAgICBlbmQuYnJlYWtBZnRlciA9IHRoaXMuYnJlYWtBZnRlcjtcbiAgICAgICAgcmV0dXJuIGVuZDtcbiAgICB9XG4gICAgZ2V0IGNoaWxkcmVuKCkgeyByZXR1cm4gbm9DaGlsZHJlbjsgfVxuICAgIHN5bmModmlldykge1xuICAgICAgICBpZiAoIXRoaXMuZG9tIHx8ICF0aGlzLndpZGdldC51cGRhdGVET00odGhpcy5kb20sIHZpZXcpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kb20gJiYgdGhpcy5wcmV2V2lkZ2V0KVxuICAgICAgICAgICAgICAgIHRoaXMucHJldldpZGdldC5kZXN0cm95KHRoaXMuZG9tKTtcbiAgICAgICAgICAgIHRoaXMucHJldldpZGdldCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnNldERPTSh0aGlzLndpZGdldC50b0RPTSh2aWV3KSk7XG4gICAgICAgICAgICB0aGlzLmRvbS5jb250ZW50RWRpdGFibGUgPSBcImZhbHNlXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IG92ZXJyaWRlRE9NVGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50ID8gdGhpcy5wYXJlbnQudmlldy5zdGF0ZS5kb2Muc2xpY2UodGhpcy5wb3NBdFN0YXJ0LCB0aGlzLnBvc0F0RW5kKSA6IFRleHQuZW1wdHk7XG4gICAgfVxuICAgIGRvbUJvdW5kc0Fyb3VuZCgpIHsgcmV0dXJuIG51bGw7IH1cbiAgICBiZWNvbWUob3RoZXIpIHtcbiAgICAgICAgaWYgKG90aGVyIGluc3RhbmNlb2YgQmxvY2tXaWRnZXRWaWV3ICYmXG4gICAgICAgICAgICBvdGhlci53aWRnZXQuY29uc3RydWN0b3IgPT0gdGhpcy53aWRnZXQuY29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgIGlmICghb3RoZXIud2lkZ2V0LmNvbXBhcmUodGhpcy53aWRnZXQpKVxuICAgICAgICAgICAgICAgIHRoaXMubWFya0RpcnR5KHRydWUpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZG9tICYmICF0aGlzLnByZXZXaWRnZXQpXG4gICAgICAgICAgICAgICAgdGhpcy5wcmV2V2lkZ2V0ID0gdGhpcy53aWRnZXQ7XG4gICAgICAgICAgICB0aGlzLndpZGdldCA9IG90aGVyLndpZGdldDtcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gb3RoZXIubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5kZWNvID0gb3RoZXIuZGVjbztcbiAgICAgICAgICAgIHRoaXMuYnJlYWtBZnRlciA9IG90aGVyLmJyZWFrQWZ0ZXI7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlnbm9yZU11dGF0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgIGlnbm9yZUV2ZW50KGV2ZW50KSB7IHJldHVybiB0aGlzLndpZGdldC5pZ25vcmVFdmVudChldmVudCk7IH1cbiAgICBnZXQgaXNFZGl0YWJsZSgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgZ2V0IGlzV2lkZ2V0KCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgIGNvb3Jkc0F0KHBvcywgc2lkZSkge1xuICAgICAgICByZXR1cm4gdGhpcy53aWRnZXQuY29vcmRzQXQodGhpcy5kb20sIHBvcywgc2lkZSk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICAgICAgaWYgKHRoaXMuZG9tKVxuICAgICAgICAgICAgdGhpcy53aWRnZXQuZGVzdHJveSh0aGlzLmRvbSk7XG4gICAgfVxuICAgIGNvdmVycyhzaWRlKSB7XG4gICAgICAgIGxldCB7IHN0YXJ0U2lkZSwgZW5kU2lkZSB9ID0gdGhpcy5kZWNvO1xuICAgICAgICByZXR1cm4gc3RhcnRTaWRlID09IGVuZFNpZGUgPyBmYWxzZSA6IHNpZGUgPCAwID8gc3RhcnRTaWRlIDwgMCA6IGVuZFNpZGUgPiAwO1xuICAgIH1cbn1cblxuLyoqXG5XaWRnZXRzIGFkZGVkIHRvIHRoZSBjb250ZW50IGFyZSBkZXNjcmliZWQgYnkgc3ViY2xhc3NlcyBvZiB0aGlzXG5jbGFzcy4gVXNpbmcgYSBkZXNjcmlwdGlvbiBvYmplY3QgbGlrZSB0aGF0IG1ha2VzIGl0IHBvc3NpYmxlIHRvXG5kZWxheSBjcmVhdGluZyBvZiB0aGUgRE9NIHN0cnVjdHVyZSBmb3IgYSB3aWRnZXQgdW50aWwgaXQgaXNcbm5lZWRlZCwgYW5kIHRvIGF2b2lkIHJlZHJhd2luZyB3aWRnZXRzIGV2ZW4gaWYgdGhlIGRlY29yYXRpb25zXG50aGF0IGRlZmluZSB0aGVtIGFyZSByZWNyZWF0ZWQuXG4qL1xuY2xhc3MgV2lkZ2V0VHlwZSB7XG4gICAgLyoqXG4gICAgQ29tcGFyZSB0aGlzIGluc3RhbmNlIHRvIGFub3RoZXIgaW5zdGFuY2Ugb2YgdGhlIHNhbWUgdHlwZS5cbiAgICAoVHlwZVNjcmlwdCBjYW4ndCBleHByZXNzIHRoaXMsIGJ1dCBvbmx5IGluc3RhbmNlcyBvZiB0aGUgc2FtZVxuICAgIHNwZWNpZmljIGNsYXNzIHdpbGwgYmUgcGFzc2VkIHRvIHRoaXMgbWV0aG9kLikgVGhpcyBpcyB1c2VkIHRvXG4gICAgYXZvaWQgcmVkcmF3aW5nIHdpZGdldHMgd2hlbiB0aGV5IGFyZSByZXBsYWNlZCBieSBhIG5ld1xuICAgIGRlY29yYXRpb24gb2YgdGhlIHNhbWUgdHlwZS4gVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24ganVzdFxuICAgIHJldHVybnMgYGZhbHNlYCwgd2hpY2ggd2lsbCBjYXVzZSBuZXcgaW5zdGFuY2VzIG9mIHRoZSB3aWRnZXQgdG9cbiAgICBhbHdheXMgYmUgcmVkcmF3bi5cbiAgICAqL1xuICAgIGVxKHdpZGdldCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAvKipcbiAgICBVcGRhdGUgYSBET00gZWxlbWVudCBjcmVhdGVkIGJ5IGEgd2lkZ2V0IG9mIHRoZSBzYW1lIHR5cGUgKGJ1dFxuICAgIGRpZmZlcmVudCwgbm9uLWBlcWAgY29udGVudCkgdG8gcmVmbGVjdCB0aGlzIHdpZGdldC4gTWF5IHJldHVyblxuICAgIHRydWUgdG8gaW5kaWNhdGUgdGhhdCBpdCBjb3VsZCB1cGRhdGUsIGZhbHNlIHRvIGluZGljYXRlIGl0XG4gICAgY291bGRuJ3QgKGluIHdoaWNoIGNhc2UgdGhlIHdpZGdldCB3aWxsIGJlIHJlZHJhd24pLiBUaGUgZGVmYXVsdFxuICAgIGltcGxlbWVudGF0aW9uIGp1c3QgcmV0dXJucyBmYWxzZS5cbiAgICAqL1xuICAgIHVwZGF0ZURPTShkb20sIHZpZXcpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb21wYXJlKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzID09IG90aGVyIHx8IHRoaXMuY29uc3RydWN0b3IgPT0gb3RoZXIuY29uc3RydWN0b3IgJiYgdGhpcy5lcShvdGhlcik7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBlc3RpbWF0ZWQgaGVpZ2h0IHRoaXMgd2lkZ2V0IHdpbGwgaGF2ZSwgdG8gYmUgdXNlZCB3aGVuXG4gICAgZXN0aW1hdGluZyB0aGUgaGVpZ2h0IG9mIGNvbnRlbnQgdGhhdCBoYXNuJ3QgYmVlbiBkcmF3bi4gTWF5XG4gICAgcmV0dXJuIC0xIHRvIGluZGljYXRlIHlvdSBkb24ndCBrbm93LiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvblxuICAgIHJldHVybnMgLTEuXG4gICAgKi9cbiAgICBnZXQgZXN0aW1hdGVkSGVpZ2h0KCkgeyByZXR1cm4gLTE7IH1cbiAgICAvKipcbiAgICBGb3IgaW5saW5lIHdpZGdldHMgdGhhdCBhcmUgZGlzcGxheWVkIGlubGluZSAoYXMgb3Bwb3NlZCB0b1xuICAgIGBpbmxpbmUtYmxvY2tgKSBhbmQgaW50cm9kdWNlIGxpbmUgYnJlYWtzICh0aHJvdWdoIGA8YnI+YCB0YWdzXG4gICAgb3IgdGV4dHVhbCBuZXdsaW5lcyksIHRoaXMgbXVzdCBpbmRpY2F0ZSB0aGUgYW1vdW50IG9mIGxpbmVcbiAgICBicmVha3MgdGhleSBpbnRyb2R1Y2UuIERlZmF1bHRzIHRvIDAuXG4gICAgKi9cbiAgICBnZXQgbGluZUJyZWFrcygpIHsgcmV0dXJuIDA7IH1cbiAgICAvKipcbiAgICBDYW4gYmUgdXNlZCB0byBjb25maWd1cmUgd2hpY2gga2luZHMgb2YgZXZlbnRzIGluc2lkZSB0aGUgd2lkZ2V0XG4gICAgc2hvdWxkIGJlIGlnbm9yZWQgYnkgdGhlIGVkaXRvci4gVGhlIGRlZmF1bHQgaXMgdG8gaWdub3JlIGFsbFxuICAgIGV2ZW50cy5cbiAgICAqL1xuICAgIGlnbm9yZUV2ZW50KGV2ZW50KSB7IHJldHVybiB0cnVlOyB9XG4gICAgLyoqXG4gICAgT3ZlcnJpZGUgdGhlIHdheSBzY3JlZW4gY29vcmRpbmF0ZXMgZm9yIHBvc2l0aW9ucyBhdC9pbiB0aGVcbiAgICB3aWRnZXQgYXJlIGZvdW5kLiBgcG9zYCB3aWxsIGJlIHRoZSBvZmZzZXQgaW50byB0aGUgd2lkZ2V0LCBhbmRcbiAgICBgc2lkZWAgdGhlIHNpZGUgb2YgdGhlIHBvc2l0aW9uIHRoYXQgaXMgYmVpbmcgcXVlcmllZOKAlGxlc3MgdGhhblxuICAgIHplcm8gZm9yIGJlZm9yZSwgZ3JlYXRlciB0aGFuIHplcm8gZm9yIGFmdGVyLCBhbmQgemVybyBmb3JcbiAgICBkaXJlY3RseSBhdCB0aGF0IHBvc2l0aW9uLlxuICAgICovXG4gICAgY29vcmRzQXQoZG9tLCBwb3MsIHNpZGUpIHsgcmV0dXJuIG51bGw7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGdldCBpc0hpZGRlbigpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgLyoqXG4gICAgVGhpcyBpcyBjYWxsZWQgd2hlbiB0aGUgYW4gaW5zdGFuY2Ugb2YgdGhlIHdpZGdldCBpcyByZW1vdmVkXG4gICAgZnJvbSB0aGUgZWRpdG9yIHZpZXcuXG4gICAgKi9cbiAgICBkZXN0cm95KGRvbSkgeyB9XG59XG4vKipcblRoZSBkaWZmZXJlbnQgdHlwZXMgb2YgYmxvY2tzIHRoYXQgY2FuIG9jY3VyIGluIGFuIGVkaXRvciB2aWV3LlxuKi9cbnZhciBCbG9ja1R5cGUgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChCbG9ja1R5cGUpIHtcbiAgICAvKipcbiAgICBBIGxpbmUgb2YgdGV4dC5cbiAgICAqL1xuICAgIEJsb2NrVHlwZVtCbG9ja1R5cGVbXCJUZXh0XCJdID0gMF0gPSBcIlRleHRcIjtcbiAgICAvKipcbiAgICBBIGJsb2NrIHdpZGdldCBhc3NvY2lhdGVkIHdpdGggdGhlIHBvc2l0aW9uIGFmdGVyIGl0LlxuICAgICovXG4gICAgQmxvY2tUeXBlW0Jsb2NrVHlwZVtcIldpZGdldEJlZm9yZVwiXSA9IDFdID0gXCJXaWRnZXRCZWZvcmVcIjtcbiAgICAvKipcbiAgICBBIGJsb2NrIHdpZGdldCBhc3NvY2lhdGVkIHdpdGggdGhlIHBvc2l0aW9uIGJlZm9yZSBpdC5cbiAgICAqL1xuICAgIEJsb2NrVHlwZVtCbG9ja1R5cGVbXCJXaWRnZXRBZnRlclwiXSA9IDJdID0gXCJXaWRnZXRBZnRlclwiO1xuICAgIC8qKlxuICAgIEEgYmxvY2sgd2lkZ2V0IFtyZXBsYWNpbmddKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5EZWNvcmF0aW9uXnJlcGxhY2UpIGEgcmFuZ2Ugb2YgY29udGVudC5cbiAgICAqL1xuICAgIEJsb2NrVHlwZVtCbG9ja1R5cGVbXCJXaWRnZXRSYW5nZVwiXSA9IDNdID0gXCJXaWRnZXRSYW5nZVwiO1xucmV0dXJuIEJsb2NrVHlwZX0pKEJsb2NrVHlwZSB8fCAoQmxvY2tUeXBlID0ge30pKTtcbi8qKlxuQSBkZWNvcmF0aW9uIHByb3ZpZGVzIGluZm9ybWF0aW9uIG9uIGhvdyB0byBkcmF3IG9yIHN0eWxlIGEgcGllY2Vcbm9mIGNvbnRlbnQuIFlvdSdsbCB1c3VhbGx5IHVzZSBpdCB3cmFwcGVkIGluIGFcbltgUmFuZ2VgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlJhbmdlKSwgd2hpY2ggYWRkcyBhIHN0YXJ0IGFuZCBlbmQgcG9zaXRpb24uXG5Abm9uYWJzdHJhY3RcbiovXG5jbGFzcyBEZWNvcmF0aW9uIGV4dGVuZHMgUmFuZ2VWYWx1ZSB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGFydFNpZGUsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZW5kU2lkZSwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB3aWRnZXQsIFxuICAgIC8qKlxuICAgIFRoZSBjb25maWcgb2JqZWN0IHVzZWQgdG8gY3JlYXRlIHRoaXMgZGVjb3JhdGlvbi4gWW91IGNhblxuICAgIGluY2x1ZGUgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIGluIHRoZXJlIHRvIHN0b3JlIG1ldGFkYXRhIGFib3V0XG4gICAgeW91ciBkZWNvcmF0aW9uLlxuICAgICovXG4gICAgc3BlYykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnN0YXJ0U2lkZSA9IHN0YXJ0U2lkZTtcbiAgICAgICAgdGhpcy5lbmRTaWRlID0gZW5kU2lkZTtcbiAgICAgICAgdGhpcy53aWRnZXQgPSB3aWRnZXQ7XG4gICAgICAgIHRoaXMuc3BlYyA9IHNwZWM7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZ2V0IGhlaWdodFJlbGV2YW50KCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBtYXJrIGRlY29yYXRpb24sIHdoaWNoIGluZmx1ZW5jZXMgdGhlIHN0eWxpbmcgb2YgdGhlXG4gICAgY29udGVudCBpbiBpdHMgcmFuZ2UuIE5lc3RlZCBtYXJrIGRlY29yYXRpb25zIHdpbGwgY2F1c2UgbmVzdGVkXG4gICAgRE9NIGVsZW1lbnRzIHRvIGJlIGNyZWF0ZWQuIE5lc3Rpbmcgb3JkZXIgaXMgZGV0ZXJtaW5lZCBieVxuICAgIHByZWNlZGVuY2Ugb2YgdGhlIFtmYWNldF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXdeZGVjb3JhdGlvbnMpLCB3aXRoXG4gICAgdGhlIGhpZ2hlci1wcmVjZWRlbmNlIGRlY29yYXRpb25zIGNyZWF0aW5nIHRoZSBpbm5lciBET00gbm9kZXMuXG4gICAgU3VjaCBlbGVtZW50cyBhcmUgc3BsaXQgb24gbGluZSBib3VuZGFyaWVzIGFuZCBvbiB0aGUgYm91bmRhcmllc1xuICAgIG9mIGxvd2VyLXByZWNlZGVuY2UgZGVjb3JhdGlvbnMuXG4gICAgKi9cbiAgICBzdGF0aWMgbWFyayhzcGVjKSB7XG4gICAgICAgIHJldHVybiBuZXcgTWFya0RlY29yYXRpb24oc3BlYyk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHdpZGdldCBkZWNvcmF0aW9uLCB3aGljaCBkaXNwbGF5cyBhIERPTSBlbGVtZW50IGF0IHRoZVxuICAgIGdpdmVuIHBvc2l0aW9uLlxuICAgICovXG4gICAgc3RhdGljIHdpZGdldChzcGVjKSB7XG4gICAgICAgIGxldCBzaWRlID0gTWF0aC5tYXgoLTEwMDAwLCBNYXRoLm1pbigxMDAwMCwgc3BlYy5zaWRlIHx8IDApKSwgYmxvY2sgPSAhIXNwZWMuYmxvY2s7XG4gICAgICAgIHNpZGUgKz0gKGJsb2NrICYmICFzcGVjLmlubGluZU9yZGVyKVxuICAgICAgICAgICAgPyAoc2lkZSA+IDAgPyAzMDAwMDAwMDAgLyogU2lkZS5CbG9ja0FmdGVyICovIDogLTQwMDAwMDAwMCAvKiBTaWRlLkJsb2NrQmVmb3JlICovKVxuICAgICAgICAgICAgOiAoc2lkZSA+IDAgPyAxMDAwMDAwMDAgLyogU2lkZS5JbmxpbmVBZnRlciAqLyA6IC0xMDAwMDAwMDAgLyogU2lkZS5JbmxpbmVCZWZvcmUgKi8pO1xuICAgICAgICByZXR1cm4gbmV3IFBvaW50RGVjb3JhdGlvbihzcGVjLCBzaWRlLCBzaWRlLCBibG9jaywgc3BlYy53aWRnZXQgfHwgbnVsbCwgZmFsc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSByZXBsYWNlIGRlY29yYXRpb24gd2hpY2ggcmVwbGFjZXMgdGhlIGdpdmVuIHJhbmdlIHdpdGhcbiAgICBhIHdpZGdldCwgb3Igc2ltcGx5IGhpZGVzIGl0LlxuICAgICovXG4gICAgc3RhdGljIHJlcGxhY2Uoc3BlYykge1xuICAgICAgICBsZXQgYmxvY2sgPSAhIXNwZWMuYmxvY2ssIHN0YXJ0U2lkZSwgZW5kU2lkZTtcbiAgICAgICAgaWYgKHNwZWMuaXNCbG9ja0dhcCkge1xuICAgICAgICAgICAgc3RhcnRTaWRlID0gLTUwMDAwMDAwMCAvKiBTaWRlLkdhcFN0YXJ0ICovO1xuICAgICAgICAgICAgZW5kU2lkZSA9IDQwMDAwMDAwMCAvKiBTaWRlLkdhcEVuZCAqLztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCB7IHN0YXJ0LCBlbmQgfSA9IGdldEluY2x1c2l2ZShzcGVjLCBibG9jayk7XG4gICAgICAgICAgICBzdGFydFNpZGUgPSAoc3RhcnQgPyAoYmxvY2sgPyAtMzAwMDAwMDAwIC8qIFNpZGUuQmxvY2tJbmNTdGFydCAqLyA6IC0xIC8qIFNpZGUuSW5saW5lSW5jU3RhcnQgKi8pIDogNTAwMDAwMDAwIC8qIFNpZGUuTm9uSW5jU3RhcnQgKi8pIC0gMTtcbiAgICAgICAgICAgIGVuZFNpZGUgPSAoZW5kID8gKGJsb2NrID8gMjAwMDAwMDAwIC8qIFNpZGUuQmxvY2tJbmNFbmQgKi8gOiAxIC8qIFNpZGUuSW5saW5lSW5jRW5kICovKSA6IC02MDAwMDAwMDAgLyogU2lkZS5Ob25JbmNFbmQgKi8pICsgMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFBvaW50RGVjb3JhdGlvbihzcGVjLCBzdGFydFNpZGUsIGVuZFNpZGUsIGJsb2NrLCBzcGVjLndpZGdldCB8fCBudWxsLCB0cnVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbGluZSBkZWNvcmF0aW9uLCB3aGljaCBjYW4gYWRkIERPTSBhdHRyaWJ1dGVzIHRvIHRoZVxuICAgIGxpbmUgc3RhcnRpbmcgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLlxuICAgICovXG4gICAgc3RhdGljIGxpbmUoc3BlYykge1xuICAgICAgICByZXR1cm4gbmV3IExpbmVEZWNvcmF0aW9uKHNwZWMpO1xuICAgIH1cbiAgICAvKipcbiAgICBCdWlsZCBhIFtgRGVjb3JhdGlvblNldGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5EZWNvcmF0aW9uU2V0KSBmcm9tIHRoZSBnaXZlblxuICAgIGRlY29yYXRlZCByYW5nZSBvciByYW5nZXMuIElmIHRoZSByYW5nZXMgYXJlbid0IGFscmVhZHkgc29ydGVkLFxuICAgIHBhc3MgYHRydWVgIGZvciBgc29ydGAgdG8gbWFrZSB0aGUgbGlicmFyeSBzb3J0IHRoZW0gZm9yIHlvdS5cbiAgICAqL1xuICAgIHN0YXRpYyBzZXQob2YsIHNvcnQgPSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gUmFuZ2VTZXQub2Yob2YsIHNvcnQpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGhhc0hlaWdodCgpIHsgcmV0dXJuIHRoaXMud2lkZ2V0ID8gdGhpcy53aWRnZXQuZXN0aW1hdGVkSGVpZ2h0ID4gLTEgOiBmYWxzZTsgfVxufVxuLyoqXG5UaGUgZW1wdHkgc2V0IG9mIGRlY29yYXRpb25zLlxuKi9cbkRlY29yYXRpb24ubm9uZSA9IFJhbmdlU2V0LmVtcHR5O1xuY2xhc3MgTWFya0RlY29yYXRpb24gZXh0ZW5kcyBEZWNvcmF0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihzcGVjKSB7XG4gICAgICAgIGxldCB7IHN0YXJ0LCBlbmQgfSA9IGdldEluY2x1c2l2ZShzcGVjKTtcbiAgICAgICAgc3VwZXIoc3RhcnQgPyAtMSAvKiBTaWRlLklubGluZUluY1N0YXJ0ICovIDogNTAwMDAwMDAwIC8qIFNpZGUuTm9uSW5jU3RhcnQgKi8sIGVuZCA/IDEgLyogU2lkZS5JbmxpbmVJbmNFbmQgKi8gOiAtNjAwMDAwMDAwIC8qIFNpZGUuTm9uSW5jRW5kICovLCBudWxsLCBzcGVjKTtcbiAgICAgICAgdGhpcy50YWdOYW1lID0gc3BlYy50YWdOYW1lIHx8IFwic3BhblwiO1xuICAgICAgICB0aGlzLmNsYXNzID0gc3BlYy5jbGFzcyB8fCBcIlwiO1xuICAgICAgICB0aGlzLmF0dHJzID0gc3BlYy5hdHRyaWJ1dGVzIHx8IG51bGw7XG4gICAgfVxuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiB0aGlzID09IG90aGVyIHx8XG4gICAgICAgICAgICBvdGhlciBpbnN0YW5jZW9mIE1hcmtEZWNvcmF0aW9uICYmXG4gICAgICAgICAgICAgICAgdGhpcy50YWdOYW1lID09IG90aGVyLnRhZ05hbWUgJiZcbiAgICAgICAgICAgICAgICAodGhpcy5jbGFzcyB8fCAoKF9hID0gdGhpcy5hdHRycykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNsYXNzKSkgPT0gKG90aGVyLmNsYXNzIHx8ICgoX2IgPSBvdGhlci5hdHRycykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNsYXNzKSkgJiZcbiAgICAgICAgICAgICAgICBhdHRyc0VxKHRoaXMuYXR0cnMsIG90aGVyLmF0dHJzLCBcImNsYXNzXCIpO1xuICAgIH1cbiAgICByYW5nZShmcm9tLCB0byA9IGZyb20pIHtcbiAgICAgICAgaWYgKGZyb20gPj0gdG8pXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk1hcmsgZGVjb3JhdGlvbnMgbWF5IG5vdCBiZSBlbXB0eVwiKTtcbiAgICAgICAgcmV0dXJuIHN1cGVyLnJhbmdlKGZyb20sIHRvKTtcbiAgICB9XG59XG5NYXJrRGVjb3JhdGlvbi5wcm90b3R5cGUucG9pbnQgPSBmYWxzZTtcbmNsYXNzIExpbmVEZWNvcmF0aW9uIGV4dGVuZHMgRGVjb3JhdGlvbiB7XG4gICAgY29uc3RydWN0b3Ioc3BlYykge1xuICAgICAgICBzdXBlcigtMjAwMDAwMDAwIC8qIFNpZGUuTGluZSAqLywgLTIwMDAwMDAwMCAvKiBTaWRlLkxpbmUgKi8sIG51bGwsIHNwZWMpO1xuICAgIH1cbiAgICBlcShvdGhlcikge1xuICAgICAgICByZXR1cm4gb3RoZXIgaW5zdGFuY2VvZiBMaW5lRGVjb3JhdGlvbiAmJlxuICAgICAgICAgICAgdGhpcy5zcGVjLmNsYXNzID09IG90aGVyLnNwZWMuY2xhc3MgJiZcbiAgICAgICAgICAgIGF0dHJzRXEodGhpcy5zcGVjLmF0dHJpYnV0ZXMsIG90aGVyLnNwZWMuYXR0cmlidXRlcyk7XG4gICAgfVxuICAgIHJhbmdlKGZyb20sIHRvID0gZnJvbSkge1xuICAgICAgICBpZiAodG8gIT0gZnJvbSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTGluZSBkZWNvcmF0aW9uIHJhbmdlcyBtdXN0IGJlIHplcm8tbGVuZ3RoXCIpO1xuICAgICAgICByZXR1cm4gc3VwZXIucmFuZ2UoZnJvbSwgdG8pO1xuICAgIH1cbn1cbkxpbmVEZWNvcmF0aW9uLnByb3RvdHlwZS5tYXBNb2RlID0gTWFwTW9kZS5UcmFja0JlZm9yZTtcbkxpbmVEZWNvcmF0aW9uLnByb3RvdHlwZS5wb2ludCA9IHRydWU7XG5jbGFzcyBQb2ludERlY29yYXRpb24gZXh0ZW5kcyBEZWNvcmF0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihzcGVjLCBzdGFydFNpZGUsIGVuZFNpZGUsIGJsb2NrLCB3aWRnZXQsIGlzUmVwbGFjZSkge1xuICAgICAgICBzdXBlcihzdGFydFNpZGUsIGVuZFNpZGUsIHdpZGdldCwgc3BlYyk7XG4gICAgICAgIHRoaXMuYmxvY2sgPSBibG9jaztcbiAgICAgICAgdGhpcy5pc1JlcGxhY2UgPSBpc1JlcGxhY2U7XG4gICAgICAgIHRoaXMubWFwTW9kZSA9ICFibG9jayA/IE1hcE1vZGUuVHJhY2tEZWwgOiBzdGFydFNpZGUgPD0gMCA/IE1hcE1vZGUuVHJhY2tCZWZvcmUgOiBNYXBNb2RlLlRyYWNrQWZ0ZXI7XG4gICAgfVxuICAgIC8vIE9ubHkgcmVsZXZhbnQgd2hlbiB0aGlzLmJsb2NrID09IHRydWVcbiAgICBnZXQgdHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRTaWRlICE9IHRoaXMuZW5kU2lkZSA/IEJsb2NrVHlwZS5XaWRnZXRSYW5nZVxuICAgICAgICAgICAgOiB0aGlzLnN0YXJ0U2lkZSA8PSAwID8gQmxvY2tUeXBlLldpZGdldEJlZm9yZSA6IEJsb2NrVHlwZS5XaWRnZXRBZnRlcjtcbiAgICB9XG4gICAgZ2V0IGhlaWdodFJlbGV2YW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ibG9jayB8fCAhIXRoaXMud2lkZ2V0ICYmICh0aGlzLndpZGdldC5lc3RpbWF0ZWRIZWlnaHQgPj0gNSB8fCB0aGlzLndpZGdldC5saW5lQnJlYWtzID4gMCk7XG4gICAgfVxuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBvdGhlciBpbnN0YW5jZW9mIFBvaW50RGVjb3JhdGlvbiAmJlxuICAgICAgICAgICAgd2lkZ2V0c0VxKHRoaXMud2lkZ2V0LCBvdGhlci53aWRnZXQpICYmXG4gICAgICAgICAgICB0aGlzLmJsb2NrID09IG90aGVyLmJsb2NrICYmXG4gICAgICAgICAgICB0aGlzLnN0YXJ0U2lkZSA9PSBvdGhlci5zdGFydFNpZGUgJiYgdGhpcy5lbmRTaWRlID09IG90aGVyLmVuZFNpZGU7XG4gICAgfVxuICAgIHJhbmdlKGZyb20sIHRvID0gZnJvbSkge1xuICAgICAgICBpZiAodGhpcy5pc1JlcGxhY2UgJiYgKGZyb20gPiB0byB8fCAoZnJvbSA9PSB0byAmJiB0aGlzLnN0YXJ0U2lkZSA+IDAgJiYgdGhpcy5lbmRTaWRlIDw9IDApKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCByYW5nZSBmb3IgcmVwbGFjZW1lbnQgZGVjb3JhdGlvblwiKTtcbiAgICAgICAgaWYgKCF0aGlzLmlzUmVwbGFjZSAmJiB0byAhPSBmcm9tKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJXaWRnZXQgZGVjb3JhdGlvbnMgY2FuIG9ubHkgaGF2ZSB6ZXJvLWxlbmd0aCByYW5nZXNcIik7XG4gICAgICAgIHJldHVybiBzdXBlci5yYW5nZShmcm9tLCB0byk7XG4gICAgfVxufVxuUG9pbnREZWNvcmF0aW9uLnByb3RvdHlwZS5wb2ludCA9IHRydWU7XG5mdW5jdGlvbiBnZXRJbmNsdXNpdmUoc3BlYywgYmxvY2sgPSBmYWxzZSkge1xuICAgIGxldCB7IGluY2x1c2l2ZVN0YXJ0OiBzdGFydCwgaW5jbHVzaXZlRW5kOiBlbmQgfSA9IHNwZWM7XG4gICAgaWYgKHN0YXJ0ID09IG51bGwpXG4gICAgICAgIHN0YXJ0ID0gc3BlYy5pbmNsdXNpdmU7XG4gICAgaWYgKGVuZCA9PSBudWxsKVxuICAgICAgICBlbmQgPSBzcGVjLmluY2x1c2l2ZTtcbiAgICByZXR1cm4geyBzdGFydDogc3RhcnQgIT09IG51bGwgJiYgc3RhcnQgIT09IHZvaWQgMCA/IHN0YXJ0IDogYmxvY2ssIGVuZDogZW5kICE9PSBudWxsICYmIGVuZCAhPT0gdm9pZCAwID8gZW5kIDogYmxvY2sgfTtcbn1cbmZ1bmN0aW9uIHdpZGdldHNFcShhLCBiKSB7XG4gICAgcmV0dXJuIGEgPT0gYiB8fCAhIShhICYmIGIgJiYgYS5jb21wYXJlKGIpKTtcbn1cbmZ1bmN0aW9uIGFkZFJhbmdlKGZyb20sIHRvLCByYW5nZXMsIG1hcmdpbiA9IDApIHtcbiAgICBsZXQgbGFzdCA9IHJhbmdlcy5sZW5ndGggLSAxO1xuICAgIGlmIChsYXN0ID49IDAgJiYgcmFuZ2VzW2xhc3RdICsgbWFyZ2luID49IGZyb20pXG4gICAgICAgIHJhbmdlc1tsYXN0XSA9IE1hdGgubWF4KHJhbmdlc1tsYXN0XSwgdG8pO1xuICAgIGVsc2VcbiAgICAgICAgcmFuZ2VzLnB1c2goZnJvbSwgdG8pO1xufVxuXG5jbGFzcyBDb250ZW50QnVpbGRlciB7XG4gICAgY29uc3RydWN0b3IoZG9jLCBwb3MsIGVuZCwgZGlzYWxsb3dCbG9ja0VmZmVjdHNGb3IpIHtcbiAgICAgICAgdGhpcy5kb2MgPSBkb2M7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICB0aGlzLmVuZCA9IGVuZDtcbiAgICAgICAgdGhpcy5kaXNhbGxvd0Jsb2NrRWZmZWN0c0ZvciA9IGRpc2FsbG93QmxvY2tFZmZlY3RzRm9yO1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBbXTtcbiAgICAgICAgdGhpcy5jdXJMaW5lID0gbnVsbDtcbiAgICAgICAgdGhpcy5icmVha0F0U3RhcnQgPSAwO1xuICAgICAgICB0aGlzLnBlbmRpbmdCdWZmZXIgPSAwIC8qIEJ1Zi5ObyAqLztcbiAgICAgICAgdGhpcy5idWZmZXJNYXJrcyA9IFtdO1xuICAgICAgICAvLyBTZXQgdG8gZmFsc2UgZGlyZWN0bHkgYWZ0ZXIgYSB3aWRnZXQgdGhhdCBjb3ZlcnMgdGhlIHBvc2l0aW9uIGFmdGVyIGl0XG4gICAgICAgIHRoaXMuYXRDdXJzb3JQb3MgPSB0cnVlO1xuICAgICAgICB0aGlzLm9wZW5TdGFydCA9IC0xO1xuICAgICAgICB0aGlzLm9wZW5FbmQgPSAtMTtcbiAgICAgICAgdGhpcy50ZXh0ID0gXCJcIjtcbiAgICAgICAgdGhpcy50ZXh0T2ZmID0gMDtcbiAgICAgICAgdGhpcy5jdXJzb3IgPSBkb2MuaXRlcigpO1xuICAgICAgICB0aGlzLnNraXAgPSBwb3M7XG4gICAgfVxuICAgIHBvc0NvdmVyZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnQubGVuZ3RoID09IDApXG4gICAgICAgICAgICByZXR1cm4gIXRoaXMuYnJlYWtBdFN0YXJ0ICYmIHRoaXMuZG9jLmxpbmVBdCh0aGlzLnBvcykuZnJvbSAhPSB0aGlzLnBvcztcbiAgICAgICAgbGV0IGxhc3QgPSB0aGlzLmNvbnRlbnRbdGhpcy5jb250ZW50Lmxlbmd0aCAtIDFdO1xuICAgICAgICByZXR1cm4gIShsYXN0LmJyZWFrQWZ0ZXIgfHwgbGFzdCBpbnN0YW5jZW9mIEJsb2NrV2lkZ2V0VmlldyAmJiBsYXN0LmRlY28uZW5kU2lkZSA8IDApO1xuICAgIH1cbiAgICBnZXRMaW5lKCkge1xuICAgICAgICBpZiAoIXRoaXMuY3VyTGluZSkge1xuICAgICAgICAgICAgdGhpcy5jb250ZW50LnB1c2godGhpcy5jdXJMaW5lID0gbmV3IExpbmVWaWV3KTtcbiAgICAgICAgICAgIHRoaXMuYXRDdXJzb3JQb3MgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmN1ckxpbmU7XG4gICAgfVxuICAgIGZsdXNoQnVmZmVyKGFjdGl2ZSA9IHRoaXMuYnVmZmVyTWFya3MpIHtcbiAgICAgICAgaWYgKHRoaXMucGVuZGluZ0J1ZmZlcikge1xuICAgICAgICAgICAgdGhpcy5jdXJMaW5lLmFwcGVuZCh3cmFwTWFya3MobmV3IFdpZGdldEJ1ZmZlclZpZXcoLTEpLCBhY3RpdmUpLCBhY3RpdmUubGVuZ3RoKTtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0J1ZmZlciA9IDAgLyogQnVmLk5vICovO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZEJsb2NrV2lkZ2V0KHZpZXcpIHtcbiAgICAgICAgdGhpcy5mbHVzaEJ1ZmZlcigpO1xuICAgICAgICB0aGlzLmN1ckxpbmUgPSBudWxsO1xuICAgICAgICB0aGlzLmNvbnRlbnQucHVzaCh2aWV3KTtcbiAgICB9XG4gICAgZmluaXNoKG9wZW5FbmQpIHtcbiAgICAgICAgaWYgKHRoaXMucGVuZGluZ0J1ZmZlciAmJiBvcGVuRW5kIDw9IHRoaXMuYnVmZmVyTWFya3MubGVuZ3RoKVxuICAgICAgICAgICAgdGhpcy5mbHVzaEJ1ZmZlcigpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdCdWZmZXIgPSAwIC8qIEJ1Zi5ObyAqLztcbiAgICAgICAgaWYgKCF0aGlzLnBvc0NvdmVyZWQoKSAmJlxuICAgICAgICAgICAgIShvcGVuRW5kICYmIHRoaXMuY29udGVudC5sZW5ndGggJiYgdGhpcy5jb250ZW50W3RoaXMuY29udGVudC5sZW5ndGggLSAxXSBpbnN0YW5jZW9mIEJsb2NrV2lkZ2V0VmlldykpXG4gICAgICAgICAgICB0aGlzLmdldExpbmUoKTtcbiAgICB9XG4gICAgYnVpbGRUZXh0KGxlbmd0aCwgYWN0aXZlLCBvcGVuU3RhcnQpIHtcbiAgICAgICAgd2hpbGUgKGxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnRleHRPZmYgPT0gdGhpcy50ZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGxldCB7IHZhbHVlLCBsaW5lQnJlYWssIGRvbmUgfSA9IHRoaXMuY3Vyc29yLm5leHQodGhpcy5za2lwKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNraXAgPSAwO1xuICAgICAgICAgICAgICAgIGlmIChkb25lKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSYW4gb3V0IG9mIHRleHQgY29udGVudCB3aGVuIGRyYXdpbmcgaW5saW5lIHZpZXdzXCIpO1xuICAgICAgICAgICAgICAgIGlmIChsaW5lQnJlYWspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnBvc0NvdmVyZWQoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0TGluZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb250ZW50Lmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGVudFt0aGlzLmNvbnRlbnQubGVuZ3RoIC0gMV0uYnJlYWtBZnRlciA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYnJlYWtBdFN0YXJ0ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mbHVzaEJ1ZmZlcigpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1ckxpbmUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0Q3Vyc29yUG9zID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoLS07XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50ZXh0ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGV4dE9mZiA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHRha2UgPSBNYXRoLm1pbih0aGlzLnRleHQubGVuZ3RoIC0gdGhpcy50ZXh0T2ZmLCBsZW5ndGgsIDUxMiAvKiBULkNodW5rICovKTtcbiAgICAgICAgICAgIHRoaXMuZmx1c2hCdWZmZXIoYWN0aXZlLnNsaWNlKGFjdGl2ZS5sZW5ndGggLSBvcGVuU3RhcnQpKTtcbiAgICAgICAgICAgIHRoaXMuZ2V0TGluZSgpLmFwcGVuZCh3cmFwTWFya3MobmV3IFRleHRWaWV3KHRoaXMudGV4dC5zbGljZSh0aGlzLnRleHRPZmYsIHRoaXMudGV4dE9mZiArIHRha2UpKSwgYWN0aXZlKSwgb3BlblN0YXJ0KTtcbiAgICAgICAgICAgIHRoaXMuYXRDdXJzb3JQb3MgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy50ZXh0T2ZmICs9IHRha2U7XG4gICAgICAgICAgICBsZW5ndGggLT0gdGFrZTtcbiAgICAgICAgICAgIG9wZW5TdGFydCA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3Bhbihmcm9tLCB0bywgYWN0aXZlLCBvcGVuU3RhcnQpIHtcbiAgICAgICAgdGhpcy5idWlsZFRleHQodG8gLSBmcm9tLCBhY3RpdmUsIG9wZW5TdGFydCk7XG4gICAgICAgIHRoaXMucG9zID0gdG87XG4gICAgICAgIGlmICh0aGlzLm9wZW5TdGFydCA8IDApXG4gICAgICAgICAgICB0aGlzLm9wZW5TdGFydCA9IG9wZW5TdGFydDtcbiAgICB9XG4gICAgcG9pbnQoZnJvbSwgdG8sIGRlY28sIGFjdGl2ZSwgb3BlblN0YXJ0LCBpbmRleCkge1xuICAgICAgICBpZiAodGhpcy5kaXNhbGxvd0Jsb2NrRWZmZWN0c0ZvcltpbmRleF0gJiYgZGVjbyBpbnN0YW5jZW9mIFBvaW50RGVjb3JhdGlvbikge1xuICAgICAgICAgICAgaWYgKGRlY28uYmxvY2spXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJCbG9jayBkZWNvcmF0aW9ucyBtYXkgbm90IGJlIHNwZWNpZmllZCB2aWEgcGx1Z2luc1wiKTtcbiAgICAgICAgICAgIGlmICh0byA+IHRoaXMuZG9jLmxpbmVBdCh0aGlzLnBvcykudG8pXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJEZWNvcmF0aW9ucyB0aGF0IHJlcGxhY2UgbGluZSBicmVha3MgbWF5IG5vdCBiZSBzcGVjaWZpZWQgdmlhIHBsdWdpbnNcIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGxlbiA9IHRvIC0gZnJvbTtcbiAgICAgICAgaWYgKGRlY28gaW5zdGFuY2VvZiBQb2ludERlY29yYXRpb24pIHtcbiAgICAgICAgICAgIGlmIChkZWNvLmJsb2NrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRlY28uc3RhcnRTaWRlID4gMCAmJiAhdGhpcy5wb3NDb3ZlcmVkKCkpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0TGluZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkQmxvY2tXaWRnZXQobmV3IEJsb2NrV2lkZ2V0VmlldyhkZWNvLndpZGdldCB8fCBuZXcgTnVsbFdpZGdldChcImRpdlwiKSwgbGVuLCBkZWNvKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgdmlldyA9IFdpZGdldFZpZXcuY3JlYXRlKGRlY28ud2lkZ2V0IHx8IG5ldyBOdWxsV2lkZ2V0KFwic3BhblwiKSwgbGVuLCBsZW4gPyAwIDogZGVjby5zdGFydFNpZGUpO1xuICAgICAgICAgICAgICAgIGxldCBjdXJzb3JCZWZvcmUgPSB0aGlzLmF0Q3Vyc29yUG9zICYmICF2aWV3LmlzRWRpdGFibGUgJiYgb3BlblN0YXJ0IDw9IGFjdGl2ZS5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgICAgKGZyb20gPCB0byB8fCBkZWNvLnN0YXJ0U2lkZSA+IDApO1xuICAgICAgICAgICAgICAgIGxldCBjdXJzb3JBZnRlciA9ICF2aWV3LmlzRWRpdGFibGUgJiYgKGZyb20gPCB0byB8fCBvcGVuU3RhcnQgPiBhY3RpdmUubGVuZ3RoIHx8IGRlY28uc3RhcnRTaWRlIDw9IDApO1xuICAgICAgICAgICAgICAgIGxldCBsaW5lID0gdGhpcy5nZXRMaW5lKCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZ0J1ZmZlciA9PSAyIC8qIEJ1Zi5JZkN1cnNvciAqLyAmJiAhY3Vyc29yQmVmb3JlICYmICF2aWV3LmlzRWRpdGFibGUpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0J1ZmZlciA9IDAgLyogQnVmLk5vICovO1xuICAgICAgICAgICAgICAgIHRoaXMuZmx1c2hCdWZmZXIoYWN0aXZlKTtcbiAgICAgICAgICAgICAgICBpZiAoY3Vyc29yQmVmb3JlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmUuYXBwZW5kKHdyYXBNYXJrcyhuZXcgV2lkZ2V0QnVmZmVyVmlldygxKSwgYWN0aXZlKSwgb3BlblN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgb3BlblN0YXJ0ID0gYWN0aXZlLmxlbmd0aCArIE1hdGgubWF4KDAsIG9wZW5TdGFydCAtIGFjdGl2ZS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsaW5lLmFwcGVuZCh3cmFwTWFya3ModmlldywgYWN0aXZlKSwgb3BlblN0YXJ0KTtcbiAgICAgICAgICAgICAgICB0aGlzLmF0Q3Vyc29yUG9zID0gY3Vyc29yQWZ0ZXI7XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nQnVmZmVyID0gIWN1cnNvckFmdGVyID8gMCAvKiBCdWYuTm8gKi8gOiBmcm9tIDwgdG8gfHwgb3BlblN0YXJ0ID4gYWN0aXZlLmxlbmd0aCA/IDEgLyogQnVmLlllcyAqLyA6IDIgLyogQnVmLklmQ3Vyc29yICovO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBlbmRpbmdCdWZmZXIpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyTWFya3MgPSBhY3RpdmUuc2xpY2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmRvYy5saW5lQXQodGhpcy5wb3MpLmZyb20gPT0gdGhpcy5wb3MpIHsgLy8gTGluZSBkZWNvcmF0aW9uXG4gICAgICAgICAgICB0aGlzLmdldExpbmUoKS5hZGRMaW5lRGVjbyhkZWNvKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuKSB7XG4gICAgICAgICAgICAvLyBBZHZhbmNlIHRoZSBpdGVyYXRvciBwYXN0IHRoZSByZXBsYWNlZCBjb250ZW50XG4gICAgICAgICAgICBpZiAodGhpcy50ZXh0T2ZmICsgbGVuIDw9IHRoaXMudGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRleHRPZmYgKz0gbGVuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5za2lwICs9IGxlbiAtICh0aGlzLnRleHQubGVuZ3RoIC0gdGhpcy50ZXh0T2ZmKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRleHQgPSBcIlwiO1xuICAgICAgICAgICAgICAgIHRoaXMudGV4dE9mZiA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnBvcyA9IHRvO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wZW5TdGFydCA8IDApXG4gICAgICAgICAgICB0aGlzLm9wZW5TdGFydCA9IG9wZW5TdGFydDtcbiAgICB9XG4gICAgc3RhdGljIGJ1aWxkKHRleHQsIGZyb20sIHRvLCBkZWNvcmF0aW9ucywgZHluYW1pY0RlY29yYXRpb25NYXApIHtcbiAgICAgICAgbGV0IGJ1aWxkZXIgPSBuZXcgQ29udGVudEJ1aWxkZXIodGV4dCwgZnJvbSwgdG8sIGR5bmFtaWNEZWNvcmF0aW9uTWFwKTtcbiAgICAgICAgYnVpbGRlci5vcGVuRW5kID0gUmFuZ2VTZXQuc3BhbnMoZGVjb3JhdGlvbnMsIGZyb20sIHRvLCBidWlsZGVyKTtcbiAgICAgICAgaWYgKGJ1aWxkZXIub3BlblN0YXJ0IDwgMClcbiAgICAgICAgICAgIGJ1aWxkZXIub3BlblN0YXJ0ID0gYnVpbGRlci5vcGVuRW5kO1xuICAgICAgICBidWlsZGVyLmZpbmlzaChidWlsZGVyLm9wZW5FbmQpO1xuICAgICAgICByZXR1cm4gYnVpbGRlcjtcbiAgICB9XG59XG5mdW5jdGlvbiB3cmFwTWFya3ModmlldywgYWN0aXZlKSB7XG4gICAgZm9yIChsZXQgbWFyayBvZiBhY3RpdmUpXG4gICAgICAgIHZpZXcgPSBuZXcgTWFya1ZpZXcobWFyaywgW3ZpZXddLCB2aWV3Lmxlbmd0aCk7XG4gICAgcmV0dXJuIHZpZXc7XG59XG5jbGFzcyBOdWxsV2lkZ2V0IGV4dGVuZHMgV2lkZ2V0VHlwZSB7XG4gICAgY29uc3RydWN0b3IodGFnKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudGFnID0gdGFnO1xuICAgIH1cbiAgICBlcShvdGhlcikgeyByZXR1cm4gb3RoZXIudGFnID09IHRoaXMudGFnOyB9XG4gICAgdG9ET00oKSB7IHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRoaXMudGFnKTsgfVxuICAgIHVwZGF0ZURPTShlbHQpIHsgcmV0dXJuIGVsdC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09IHRoaXMudGFnOyB9XG4gICAgZ2V0IGlzSGlkZGVuKCkgeyByZXR1cm4gdHJ1ZTsgfVxufVxuXG5jb25zdCBjbGlja0FkZHNTZWxlY3Rpb25SYW5nZSA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IGRyYWdNb3Zlc1NlbGVjdGlvbiQxID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgbW91c2VTZWxlY3Rpb25TdHlsZSA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IGV4Y2VwdGlvblNpbmsgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCB1cGRhdGVMaXN0ZW5lciA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IGlucHV0SGFuZGxlciA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IGZvY3VzQ2hhbmdlRWZmZWN0ID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgcGVyTGluZVRleHREaXJlY3Rpb24gPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lOiB2YWx1ZXMgPT4gdmFsdWVzLnNvbWUoeCA9PiB4KVxufSk7XG5jb25zdCBuYXRpdmVTZWxlY3Rpb25IaWRkZW4gPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lOiB2YWx1ZXMgPT4gdmFsdWVzLnNvbWUoeCA9PiB4KVxufSk7XG5jbGFzcyBTY3JvbGxUYXJnZXQge1xuICAgIGNvbnN0cnVjdG9yKHJhbmdlLCB5ID0gXCJuZWFyZXN0XCIsIHggPSBcIm5lYXJlc3RcIiwgeU1hcmdpbiA9IDUsIHhNYXJnaW4gPSA1LCBcbiAgICAvLyBUaGlzIGRhdGEgc3RydWN0dXJlIGlzIGFidXNlZCB0byBhbHNvIHN0b3JlIHByZWNpc2Ugc2Nyb2xsXG4gICAgLy8gc25hcHNob3RzLCBpbnN0ZWFkIG9mIGEgYHNjcm9sbEludG9WaWV3YCByZXF1ZXN0LiBXaGVuIHRoaXNcbiAgICAvLyBmbGFnIGlzIGB0cnVlYCwgYHJhbmdlYCBwb2ludHMgYXQgYSBwb3NpdGlvbiBpbiB0aGUgcmVmZXJlbmNlXG4gICAgLy8gbGluZSwgYHlNYXJnaW5gIGhvbGRzIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIHRvcCBvZiB0aGF0XG4gICAgLy8gbGluZSBhbmQgdGhlIHRvcCBvZiB0aGUgZWRpdG9yLCBhbmQgYHhNYXJnaW5gIGhvbGRzIHRoZVxuICAgIC8vIGVkaXRvcidzIGBzY3JvbGxMZWZ0YC5cbiAgICBpc1NuYXBzaG90ID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5yYW5nZSA9IHJhbmdlO1xuICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICB0aGlzLnlNYXJnaW4gPSB5TWFyZ2luO1xuICAgICAgICB0aGlzLnhNYXJnaW4gPSB4TWFyZ2luO1xuICAgICAgICB0aGlzLmlzU25hcHNob3QgPSBpc1NuYXBzaG90O1xuICAgIH1cbiAgICBtYXAoY2hhbmdlcykge1xuICAgICAgICByZXR1cm4gY2hhbmdlcy5lbXB0eSA/IHRoaXMgOlxuICAgICAgICAgICAgbmV3IFNjcm9sbFRhcmdldCh0aGlzLnJhbmdlLm1hcChjaGFuZ2VzKSwgdGhpcy55LCB0aGlzLngsIHRoaXMueU1hcmdpbiwgdGhpcy54TWFyZ2luLCB0aGlzLmlzU25hcHNob3QpO1xuICAgIH1cbiAgICBjbGlwKHN0YXRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJhbmdlLnRvIDw9IHN0YXRlLmRvYy5sZW5ndGggPyB0aGlzIDpcbiAgICAgICAgICAgIG5ldyBTY3JvbGxUYXJnZXQoRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihzdGF0ZS5kb2MubGVuZ3RoKSwgdGhpcy55LCB0aGlzLngsIHRoaXMueU1hcmdpbiwgdGhpcy54TWFyZ2luLCB0aGlzLmlzU25hcHNob3QpO1xuICAgIH1cbn1cbmNvbnN0IHNjcm9sbEludG9WaWV3ID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSh7IG1hcDogKHQsIGNoKSA9PiB0Lm1hcChjaCkgfSk7XG4vKipcbkxvZyBvciByZXBvcnQgYW4gdW5oYW5kbGVkIGV4Y2VwdGlvbiBpbiBjbGllbnQgY29kZS4gU2hvdWxkXG5wcm9iYWJseSBvbmx5IGJlIHVzZWQgYnkgZXh0ZW5zaW9uIGNvZGUgdGhhdCBhbGxvd3MgY2xpZW50IGNvZGUgdG9cbnByb3ZpZGUgZnVuY3Rpb25zLCBhbmQgY2FsbHMgdGhvc2UgZnVuY3Rpb25zIGluIGEgY29udGV4dCB3aGVyZSBhblxuZXhjZXB0aW9uIGNhbid0IGJlIHByb3BhZ2F0ZWQgdG8gY2FsbGluZyBjb2RlIGluIGEgcmVhc29uYWJsZSB3YXlcbihmb3IgZXhhbXBsZSB3aGVuIGluIGFuIGV2ZW50IGhhbmRsZXIpLlxuXG5FaXRoZXIgY2FsbHMgYSBoYW5kbGVyIHJlZ2lzdGVyZWQgd2l0aFxuW2BFZGl0b3JWaWV3LmV4Y2VwdGlvblNpbmtgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlld15leGNlcHRpb25TaW5rKSxcbmB3aW5kb3cub25lcnJvcmAsIGlmIGRlZmluZWQsIG9yIGBjb25zb2xlLmVycm9yYCAoaW4gd2hpY2ggY2FzZVxuaXQnbGwgcGFzcyBgY29udGV4dGAsIHdoZW4gZ2l2ZW4sIGFzIGZpcnN0IGFyZ3VtZW50KS5cbiovXG5mdW5jdGlvbiBsb2dFeGNlcHRpb24oc3RhdGUsIGV4Y2VwdGlvbiwgY29udGV4dCkge1xuICAgIGxldCBoYW5kbGVyID0gc3RhdGUuZmFjZXQoZXhjZXB0aW9uU2luayk7XG4gICAgaWYgKGhhbmRsZXIubGVuZ3RoKVxuICAgICAgICBoYW5kbGVyWzBdKGV4Y2VwdGlvbik7XG4gICAgZWxzZSBpZiAod2luZG93Lm9uZXJyb3IpXG4gICAgICAgIHdpbmRvdy5vbmVycm9yKFN0cmluZyhleGNlcHRpb24pLCBjb250ZXh0LCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZXhjZXB0aW9uKTtcbiAgICBlbHNlIGlmIChjb250ZXh0KVxuICAgICAgICBjb25zb2xlLmVycm9yKGNvbnRleHQgKyBcIjpcIiwgZXhjZXB0aW9uKTtcbiAgICBlbHNlXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXhjZXB0aW9uKTtcbn1cbmNvbnN0IGVkaXRhYmxlID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7IGNvbWJpbmU6IHZhbHVlcyA9PiB2YWx1ZXMubGVuZ3RoID8gdmFsdWVzWzBdIDogdHJ1ZSB9KTtcbmxldCBuZXh0UGx1Z2luSUQgPSAwO1xuY29uc3Qgdmlld1BsdWdpbiA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbi8qKlxuVmlldyBwbHVnaW5zIGFzc29jaWF0ZSBzdGF0ZWZ1bCB2YWx1ZXMgd2l0aCBhIHZpZXcuIFRoZXkgY2FuXG5pbmZsdWVuY2UgdGhlIHdheSB0aGUgY29udGVudCBpcyBkcmF3biwgYW5kIGFyZSBub3RpZmllZCBvZiB0aGluZ3NcbnRoYXQgaGFwcGVuIGluIHRoZSB2aWV3LlxuKi9cbmNsYXNzIFZpZXdQbHVnaW4ge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgaWQsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY3JlYXRlLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGRvbUV2ZW50SGFuZGxlcnMsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZG9tRXZlbnRPYnNlcnZlcnMsIGJ1aWxkRXh0ZW5zaW9ucykge1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMuY3JlYXRlID0gY3JlYXRlO1xuICAgICAgICB0aGlzLmRvbUV2ZW50SGFuZGxlcnMgPSBkb21FdmVudEhhbmRsZXJzO1xuICAgICAgICB0aGlzLmRvbUV2ZW50T2JzZXJ2ZXJzID0gZG9tRXZlbnRPYnNlcnZlcnM7XG4gICAgICAgIHRoaXMuZXh0ZW5zaW9uID0gYnVpbGRFeHRlbnNpb25zKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICBEZWZpbmUgYSBwbHVnaW4gZnJvbSBhIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyB0aGVcbiAgICBwbHVnaW4ncyB2YWx1ZSwgZ2l2ZW4gYW4gZWRpdG9yIHZpZXcuXG4gICAgKi9cbiAgICBzdGF0aWMgZGVmaW5lKGNyZWF0ZSwgc3BlYykge1xuICAgICAgICBjb25zdCB7IGV2ZW50SGFuZGxlcnMsIGV2ZW50T2JzZXJ2ZXJzLCBwcm92aWRlLCBkZWNvcmF0aW9uczogZGVjbyB9ID0gc3BlYyB8fCB7fTtcbiAgICAgICAgcmV0dXJuIG5ldyBWaWV3UGx1Z2luKG5leHRQbHVnaW5JRCsrLCBjcmVhdGUsIGV2ZW50SGFuZGxlcnMsIGV2ZW50T2JzZXJ2ZXJzLCBwbHVnaW4gPT4ge1xuICAgICAgICAgICAgbGV0IGV4dCA9IFt2aWV3UGx1Z2luLm9mKHBsdWdpbildO1xuICAgICAgICAgICAgaWYgKGRlY28pXG4gICAgICAgICAgICAgICAgZXh0LnB1c2goZGVjb3JhdGlvbnMub2YodmlldyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwbHVnaW5JbnN0ID0gdmlldy5wbHVnaW4ocGx1Z2luKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBsdWdpbkluc3QgPyBkZWNvKHBsdWdpbkluc3QpIDogRGVjb3JhdGlvbi5ub25lO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIGlmIChwcm92aWRlKVxuICAgICAgICAgICAgICAgIGV4dC5wdXNoKHByb3ZpZGUocGx1Z2luKSk7XG4gICAgICAgICAgICByZXR1cm4gZXh0O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgcGx1Z2luIGZvciBhIGNsYXNzIHdob3NlIGNvbnN0cnVjdG9yIHRha2VzIGEgc2luZ2xlXG4gICAgZWRpdG9yIHZpZXcgYXMgYXJndW1lbnQuXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUNsYXNzKGNscywgc3BlYykge1xuICAgICAgICByZXR1cm4gVmlld1BsdWdpbi5kZWZpbmUodmlldyA9PiBuZXcgY2xzKHZpZXcpLCBzcGVjKTtcbiAgICB9XG59XG5jbGFzcyBQbHVnaW5JbnN0YW5jZSB7XG4gICAgY29uc3RydWN0b3Ioc3BlYykge1xuICAgICAgICB0aGlzLnNwZWMgPSBzcGVjO1xuICAgICAgICAvLyBXaGVuIHN0YXJ0aW5nIGFuIHVwZGF0ZSwgYWxsIHBsdWdpbnMgaGF2ZSB0aGlzIGZpZWxkIHNldCB0byB0aGVcbiAgICAgICAgLy8gdXBkYXRlIG9iamVjdCwgaW5kaWNhdGluZyB0aGV5IG5lZWQgdG8gYmUgdXBkYXRlZC4gV2hlbiBmaW5pc2hlZFxuICAgICAgICAvLyB1cGRhdGluZywgaXQgaXMgc2V0IHRvIGBmYWxzZWAuIFJldHJpZXZpbmcgYSBwbHVnaW4gdGhhdCBuZWVkcyB0b1xuICAgICAgICAvLyBiZSB1cGRhdGVkIHdpdGggYHZpZXcucGx1Z2luYCBmb3JjZXMgYW4gZWFnZXIgdXBkYXRlLlxuICAgICAgICB0aGlzLm11c3RVcGRhdGUgPSBudWxsO1xuICAgICAgICAvLyBUaGlzIGlzIG51bGwgd2hlbiB0aGUgcGx1Z2luIGlzIGluaXRpYWxseSBjcmVhdGVkLCBidXRcbiAgICAgICAgLy8gaW5pdGlhbGl6ZWQgb24gdGhlIGZpcnN0IHVwZGF0ZS5cbiAgICAgICAgdGhpcy52YWx1ZSA9IG51bGw7XG4gICAgfVxuICAgIHVwZGF0ZSh2aWV3KSB7XG4gICAgICAgIGlmICghdGhpcy52YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3BlYykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLnNwZWMuY3JlYXRlKHZpZXcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dFeGNlcHRpb24odmlldy5zdGF0ZSwgZSwgXCJDb2RlTWlycm9yIHBsdWdpbiBjcmFzaGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlYWN0aXZhdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5tdXN0VXBkYXRlKSB7XG4gICAgICAgICAgICBsZXQgdXBkYXRlID0gdGhpcy5tdXN0VXBkYXRlO1xuICAgICAgICAgICAgdGhpcy5tdXN0VXBkYXRlID0gbnVsbDtcbiAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlLnVwZGF0ZSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUudXBkYXRlKHVwZGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ0V4Y2VwdGlvbih1cGRhdGUuc3RhdGUsIGUsIFwiQ29kZU1pcnJvciBwbHVnaW4gY3Jhc2hlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudmFsdWUuZGVzdHJveSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZS5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoXykgeyB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVhY3RpdmF0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGVzdHJveSh2aWV3KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKChfYSA9IHRoaXMudmFsdWUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZXN0cm95KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUuZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBsb2dFeGNlcHRpb24odmlldy5zdGF0ZSwgZSwgXCJDb2RlTWlycm9yIHBsdWdpbiBjcmFzaGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGRlYWN0aXZhdGUoKSB7XG4gICAgICAgIHRoaXMuc3BlYyA9IHRoaXMudmFsdWUgPSBudWxsO1xuICAgIH1cbn1cbmNvbnN0IGVkaXRvckF0dHJpYnV0ZXMgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCBjb250ZW50QXR0cmlidXRlcyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbi8vIFByb3ZpZGUgZGVjb3JhdGlvbnNcbmNvbnN0IGRlY29yYXRpb25zID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgYXRvbWljUmFuZ2VzID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgYmlkaUlzb2xhdGVkUmFuZ2VzID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuZnVuY3Rpb24gZ2V0SXNvbGF0ZWRSYW5nZXModmlldywgZnJvbSwgdG8pIHtcbiAgICBsZXQgaXNvbGF0ZXMgPSB2aWV3LnN0YXRlLmZhY2V0KGJpZGlJc29sYXRlZFJhbmdlcyk7XG4gICAgaWYgKCFpc29sYXRlcy5sZW5ndGgpXG4gICAgICAgIHJldHVybiBpc29sYXRlcztcbiAgICBsZXQgc2V0cyA9IGlzb2xhdGVzLm1hcChpID0+IGkgaW5zdGFuY2VvZiBGdW5jdGlvbiA/IGkodmlldykgOiBpKTtcbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgUmFuZ2VTZXQuc3BhbnMoc2V0cywgZnJvbSwgdG8sIHtcbiAgICAgICAgcG9pbnQoKSB7IH0sXG4gICAgICAgIHNwYW4oZnJvbSwgdG8sIGFjdGl2ZSwgb3Blbikge1xuICAgICAgICAgICAgbGV0IGxldmVsID0gcmVzdWx0O1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGFjdGl2ZS5sZW5ndGggLSAxOyBpID49IDA7IGktLSwgb3Blbi0tKSB7XG4gICAgICAgICAgICAgICAgbGV0IGlzbyA9IGFjdGl2ZVtpXS5zcGVjLmJpZGlJc29sYXRlLCB1cGRhdGU7XG4gICAgICAgICAgICAgICAgaWYgKGlzbyA9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBpZiAob3BlbiA+IDAgJiYgbGV2ZWwubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgICAgICh1cGRhdGUgPSBsZXZlbFtsZXZlbC5sZW5ndGggLSAxXSkudG8gPT0gZnJvbSAmJiB1cGRhdGUuZGlyZWN0aW9uID09IGlzbykge1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGUudG8gPSB0bztcbiAgICAgICAgICAgICAgICAgICAgbGV2ZWwgPSB1cGRhdGUuaW5uZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgYWRkID0geyBmcm9tLCB0bywgZGlyZWN0aW9uOiBpc28sIGlubmVyOiBbXSB9O1xuICAgICAgICAgICAgICAgICAgICBsZXZlbC5wdXNoKGFkZCk7XG4gICAgICAgICAgICAgICAgICAgIGxldmVsID0gYWRkLmlubmVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5jb25zdCBzY3JvbGxNYXJnaW5zID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuZnVuY3Rpb24gZ2V0U2Nyb2xsTWFyZ2lucyh2aWV3KSB7XG4gICAgbGV0IGxlZnQgPSAwLCByaWdodCA9IDAsIHRvcCA9IDAsIGJvdHRvbSA9IDA7XG4gICAgZm9yIChsZXQgc291cmNlIG9mIHZpZXcuc3RhdGUuZmFjZXQoc2Nyb2xsTWFyZ2lucykpIHtcbiAgICAgICAgbGV0IG0gPSBzb3VyY2Uodmlldyk7XG4gICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgICBpZiAobS5sZWZ0ICE9IG51bGwpXG4gICAgICAgICAgICAgICAgbGVmdCA9IE1hdGgubWF4KGxlZnQsIG0ubGVmdCk7XG4gICAgICAgICAgICBpZiAobS5yaWdodCAhPSBudWxsKVxuICAgICAgICAgICAgICAgIHJpZ2h0ID0gTWF0aC5tYXgocmlnaHQsIG0ucmlnaHQpO1xuICAgICAgICAgICAgaWYgKG0udG9wICE9IG51bGwpXG4gICAgICAgICAgICAgICAgdG9wID0gTWF0aC5tYXgodG9wLCBtLnRvcCk7XG4gICAgICAgICAgICBpZiAobS5ib3R0b20gIT0gbnVsbClcbiAgICAgICAgICAgICAgICBib3R0b20gPSBNYXRoLm1heChib3R0b20sIG0uYm90dG9tKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBsZWZ0LCByaWdodCwgdG9wLCBib3R0b20gfTtcbn1cbmNvbnN0IHN0eWxlTW9kdWxlID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY2xhc3MgQ2hhbmdlZFJhbmdlIHtcbiAgICBjb25zdHJ1Y3Rvcihmcm9tQSwgdG9BLCBmcm9tQiwgdG9CKSB7XG4gICAgICAgIHRoaXMuZnJvbUEgPSBmcm9tQTtcbiAgICAgICAgdGhpcy50b0EgPSB0b0E7XG4gICAgICAgIHRoaXMuZnJvbUIgPSBmcm9tQjtcbiAgICAgICAgdGhpcy50b0IgPSB0b0I7XG4gICAgfVxuICAgIGpvaW4ob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDaGFuZ2VkUmFuZ2UoTWF0aC5taW4odGhpcy5mcm9tQSwgb3RoZXIuZnJvbUEpLCBNYXRoLm1heCh0aGlzLnRvQSwgb3RoZXIudG9BKSwgTWF0aC5taW4odGhpcy5mcm9tQiwgb3RoZXIuZnJvbUIpLCBNYXRoLm1heCh0aGlzLnRvQiwgb3RoZXIudG9CKSk7XG4gICAgfVxuICAgIGFkZFRvU2V0KHNldCkge1xuICAgICAgICBsZXQgaSA9IHNldC5sZW5ndGgsIG1lID0gdGhpcztcbiAgICAgICAgZm9yICg7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCByYW5nZSA9IHNldFtpIC0gMV07XG4gICAgICAgICAgICBpZiAocmFuZ2UuZnJvbUEgPiBtZS50b0EpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAocmFuZ2UudG9BIDwgbWUuZnJvbUEpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBtZSA9IG1lLmpvaW4ocmFuZ2UpO1xuICAgICAgICAgICAgc2V0LnNwbGljZShpIC0gMSwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0LnNwbGljZShpLCAwLCBtZSk7XG4gICAgICAgIHJldHVybiBzZXQ7XG4gICAgfVxuICAgIHN0YXRpYyBleHRlbmRXaXRoUmFuZ2VzKGRpZmYsIHJhbmdlcykge1xuICAgICAgICBpZiAocmFuZ2VzLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGRpZmY7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgZEkgPSAwLCBySSA9IDAsIHBvc0EgPSAwLCBwb3NCID0gMDs7IGRJKyspIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gZEkgPT0gZGlmZi5sZW5ndGggPyBudWxsIDogZGlmZltkSV0sIG9mZiA9IHBvc0EgLSBwb3NCO1xuICAgICAgICAgICAgbGV0IGVuZCA9IG5leHQgPyBuZXh0LmZyb21CIDogMWU5O1xuICAgICAgICAgICAgd2hpbGUgKHJJIDwgcmFuZ2VzLmxlbmd0aCAmJiByYW5nZXNbckldIDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZyb20gPSByYW5nZXNbckldLCB0byA9IHJhbmdlc1tySSArIDFdO1xuICAgICAgICAgICAgICAgIGxldCBmcm9tQiA9IE1hdGgubWF4KHBvc0IsIGZyb20pLCB0b0IgPSBNYXRoLm1pbihlbmQsIHRvKTtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbUIgPD0gdG9CKVxuICAgICAgICAgICAgICAgICAgICBuZXcgQ2hhbmdlZFJhbmdlKGZyb21CICsgb2ZmLCB0b0IgKyBvZmYsIGZyb21CLCB0b0IpLmFkZFRvU2V0KHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgaWYgKHRvID4gZW5kKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHJJICs9IDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW5leHQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIG5ldyBDaGFuZ2VkUmFuZ2UobmV4dC5mcm9tQSwgbmV4dC50b0EsIG5leHQuZnJvbUIsIG5leHQudG9CKS5hZGRUb1NldChyZXN1bHQpO1xuICAgICAgICAgICAgcG9zQSA9IG5leHQudG9BO1xuICAgICAgICAgICAgcG9zQiA9IG5leHQudG9CO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG5WaWV3IFtwbHVnaW5zXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuVmlld1BsdWdpbikgYXJlIGdpdmVuIGluc3RhbmNlcyBvZiB0aGlzXG5jbGFzcywgd2hpY2ggZGVzY3JpYmUgd2hhdCBoYXBwZW5lZCwgd2hlbmV2ZXIgdGhlIHZpZXcgaXMgdXBkYXRlZC5cbiovXG5jbGFzcyBWaWV3VXBkYXRlIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgZWRpdG9yIHZpZXcgdGhhdCB0aGUgdXBkYXRlIGlzIGFzc29jaWF0ZWQgd2l0aC5cbiAgICAqL1xuICAgIHZpZXcsIFxuICAgIC8qKlxuICAgIFRoZSBuZXcgZWRpdG9yIHN0YXRlLlxuICAgICovXG4gICAgc3RhdGUsIFxuICAgIC8qKlxuICAgIFRoZSB0cmFuc2FjdGlvbnMgaW52b2x2ZWQgaW4gdGhlIHVwZGF0ZS4gTWF5IGJlIGVtcHR5LlxuICAgICovXG4gICAgdHJhbnNhY3Rpb25zKSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgdGhpcy50cmFuc2FjdGlvbnMgPSB0cmFuc2FjdGlvbnM7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mbGFncyA9IDA7XG4gICAgICAgIHRoaXMuc3RhcnRTdGF0ZSA9IHZpZXcuc3RhdGU7XG4gICAgICAgIHRoaXMuY2hhbmdlcyA9IENoYW5nZVNldC5lbXB0eSh0aGlzLnN0YXJ0U3RhdGUuZG9jLmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IHRyIG9mIHRyYW5zYWN0aW9ucylcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlcyA9IHRoaXMuY2hhbmdlcy5jb21wb3NlKHRyLmNoYW5nZXMpO1xuICAgICAgICBsZXQgY2hhbmdlZFJhbmdlcyA9IFtdO1xuICAgICAgICB0aGlzLmNoYW5nZXMuaXRlckNoYW5nZWRSYW5nZXMoKGZyb21BLCB0b0EsIGZyb21CLCB0b0IpID0+IGNoYW5nZWRSYW5nZXMucHVzaChuZXcgQ2hhbmdlZFJhbmdlKGZyb21BLCB0b0EsIGZyb21CLCB0b0IpKSk7XG4gICAgICAgIHRoaXMuY2hhbmdlZFJhbmdlcyA9IGNoYW5nZWRSYW5nZXM7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZSh2aWV3LCBzdGF0ZSwgdHJhbnNhY3Rpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgVmlld1VwZGF0ZSh2aWV3LCBzdGF0ZSwgdHJhbnNhY3Rpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGVsbHMgeW91IHdoZXRoZXIgdGhlIFt2aWV3cG9ydF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcudmlld3BvcnQpIG9yXG4gICAgW3Zpc2libGUgcmFuZ2VzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy52aXNpYmxlUmFuZ2VzKSBjaGFuZ2VkIGluIHRoaXNcbiAgICB1cGRhdGUuXG4gICAgKi9cbiAgICBnZXQgdmlld3BvcnRDaGFuZ2VkKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuZmxhZ3MgJiA0IC8qIFVwZGF0ZUZsYWcuVmlld3BvcnQgKi8pID4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGhlaWdodCBvZiBhIGJsb2NrIGVsZW1lbnQgaW4gdGhlIGVkaXRvclxuICAgIGNoYW5nZWQgaW4gdGhpcyB1cGRhdGUuXG4gICAgKi9cbiAgICBnZXQgaGVpZ2h0Q2hhbmdlZCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmZsYWdzICYgMiAvKiBVcGRhdGVGbGFnLkhlaWdodCAqLykgPiAwO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIHRydWUgd2hlbiB0aGUgZG9jdW1lbnQgd2FzIG1vZGlmaWVkIG9yIHRoZSBzaXplIG9mIHRoZVxuICAgIGVkaXRvciwgb3IgZWxlbWVudHMgd2l0aGluIHRoZSBlZGl0b3IsIGNoYW5nZWQuXG4gICAgKi9cbiAgICBnZXQgZ2VvbWV0cnlDaGFuZ2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kb2NDaGFuZ2VkIHx8ICh0aGlzLmZsYWdzICYgKDggLyogVXBkYXRlRmxhZy5HZW9tZXRyeSAqLyB8IDIgLyogVXBkYXRlRmxhZy5IZWlnaHQgKi8pKSA+IDA7XG4gICAgfVxuICAgIC8qKlxuICAgIFRydWUgd2hlbiB0aGlzIHVwZGF0ZSBpbmRpY2F0ZXMgYSBmb2N1cyBjaGFuZ2UuXG4gICAgKi9cbiAgICBnZXQgZm9jdXNDaGFuZ2VkKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuZmxhZ3MgJiAxIC8qIFVwZGF0ZUZsYWcuRm9jdXMgKi8pID4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgV2hldGhlciB0aGUgZG9jdW1lbnQgY2hhbmdlZCBpbiB0aGlzIHVwZGF0ZS5cbiAgICAqL1xuICAgIGdldCBkb2NDaGFuZ2VkKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuY2hhbmdlcy5lbXB0eTtcbiAgICB9XG4gICAgLyoqXG4gICAgV2hldGhlciB0aGUgc2VsZWN0aW9uIHdhcyBleHBsaWNpdGx5IHNldCBpbiB0aGlzIHVwZGF0ZS5cbiAgICAqL1xuICAgIGdldCBzZWxlY3Rpb25TZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zYWN0aW9ucy5zb21lKHRyID0+IHRyLnNlbGVjdGlvbik7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZ2V0IGVtcHR5KCkgeyByZXR1cm4gdGhpcy5mbGFncyA9PSAwICYmIHRoaXMudHJhbnNhY3Rpb25zLmxlbmd0aCA9PSAwOyB9XG59XG5cbi8qKlxuVXNlZCB0byBpbmRpY2F0ZSBbdGV4dCBkaXJlY3Rpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LnRleHREaXJlY3Rpb24pLlxuKi9cbnZhciBEaXJlY3Rpb24gPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChEaXJlY3Rpb24pIHtcbiAgICAvLyAoVGhlc2UgYXJlIGNob3NlbiB0byBtYXRjaCB0aGUgYmFzZSBsZXZlbHMsIGluIGJpZGkgYWxnb3JpdGhtXG4gICAgLy8gdGVybXMsIG9mIHNwYW5zIGluIHRoYXQgZGlyZWN0aW9uLilcbiAgICAvKipcbiAgICBMZWZ0LXRvLXJpZ2h0LlxuICAgICovXG4gICAgRGlyZWN0aW9uW0RpcmVjdGlvbltcIkxUUlwiXSA9IDBdID0gXCJMVFJcIjtcbiAgICAvKipcbiAgICBSaWdodC10by1sZWZ0LlxuICAgICovXG4gICAgRGlyZWN0aW9uW0RpcmVjdGlvbltcIlJUTFwiXSA9IDFdID0gXCJSVExcIjtcbnJldHVybiBEaXJlY3Rpb259KShEaXJlY3Rpb24gfHwgKERpcmVjdGlvbiA9IHt9KSk7XG5jb25zdCBMVFIgPSBEaXJlY3Rpb24uTFRSLCBSVEwgPSBEaXJlY3Rpb24uUlRMO1xuLy8gRGVjb2RlIGEgc3RyaW5nIHdpdGggZWFjaCB0eXBlIGVuY29kZWQgYXMgbG9nMih0eXBlKVxuZnVuY3Rpb24gZGVjKHN0cikge1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKylcbiAgICAgICAgcmVzdWx0LnB1c2goMSA8PCArc3RyW2ldKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8gQ2hhcmFjdGVyIHR5cGVzIGZvciBjb2RlcG9pbnRzIDAgdG8gMHhmOFxuY29uc3QgTG93VHlwZXMgPSAvKkBfX1BVUkVfXyovZGVjKFwiODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg2NjY4ODg4ODg3ODc4MzMzMzMzMzMzMzc4ODg4ODgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDg4ODg4ODAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODc4NjY2Njg4ODgwODg4ODg2NjMzODA4ODgzMDg4ODg4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDhcIik7XG4vLyBDaGFyYWN0ZXIgdHlwZXMgZm9yIGNvZGVwb2ludHMgMHg2MDAgdG8gMHg2ZjlcbmNvbnN0IEFyYWJpY1R5cGVzID0gLypAX19QVVJFX18qL2RlYyhcIjQ0NDQ0NDg4MjY2MjcyODg5OTk5OTk5OTk5OTIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjk5OTk5OTk5OTk5OTk5OTk5OTk5OTQ0NDQ0NDQ0NDQ2NDQyMjI4MjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI5OTk5OTk5NDk5OTk5OTkyMjk5ODk5OTkyMjMzMzMzMzMzMzNcIik7XG5jb25zdCBCcmFja2V0cyA9IC8qQF9fUFVSRV9fKi9PYmplY3QuY3JlYXRlKG51bGwpLCBCcmFja2V0U3RhY2sgPSBbXTtcbi8vIFRoZXJlJ3MgYSBsb3QgbW9yZSBpblxuLy8gaHR0cHM6Ly93d3cudW5pY29kZS5vcmcvUHVibGljL1VDRC9sYXRlc3QvdWNkL0JpZGlCcmFja2V0cy50eHQsXG4vLyB3aGljaCBhcmUgbGVmdCBvdXQgdG8ga2VlcCBjb2RlIHNpemUgZG93bi5cbmZvciAobGV0IHAgb2YgW1wiKClcIiwgXCJbXVwiLCBcInt9XCJdKSB7XG4gICAgbGV0IGwgPSAvKkBfX1BVUkVfXyovcC5jaGFyQ29kZUF0KDApLCByID0gLypAX19QVVJFX18qL3AuY2hhckNvZGVBdCgxKTtcbiAgICBCcmFja2V0c1tsXSA9IHI7XG4gICAgQnJhY2tldHNbcl0gPSAtbDtcbn1cbmZ1bmN0aW9uIGNoYXJUeXBlKGNoKSB7XG4gICAgcmV0dXJuIGNoIDw9IDB4ZjcgPyBMb3dUeXBlc1tjaF0gOlxuICAgICAgICAweDU5MCA8PSBjaCAmJiBjaCA8PSAweDVmNCA/IDIgLyogVC5SICovIDpcbiAgICAgICAgICAgIDB4NjAwIDw9IGNoICYmIGNoIDw9IDB4NmY5ID8gQXJhYmljVHlwZXNbY2ggLSAweDYwMF0gOlxuICAgICAgICAgICAgICAgIDB4NmVlIDw9IGNoICYmIGNoIDw9IDB4OGFjID8gNCAvKiBULkFMICovIDpcbiAgICAgICAgICAgICAgICAgICAgMHgyMDAwIDw9IGNoICYmIGNoIDw9IDB4MjAwYyA/IDI1NiAvKiBULk5JICovIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIDB4ZmI1MCA8PSBjaCAmJiBjaCA8PSAweGZkZmYgPyA0IC8qIFQuQUwgKi8gOiAxIC8qIFQuTCAqLztcbn1cbmNvbnN0IEJpZGlSRSA9IC9bXFx1MDU5MC1cXHUwNWY0XFx1MDYwMC1cXHUwNmZmXFx1MDcwMC1cXHUwOGFjXFx1ZmI1MC1cXHVmZGZmXS87XG4vKipcblJlcHJlc2VudHMgYSBjb250aWd1b3VzIHJhbmdlIG9mIHRleHQgdGhhdCBoYXMgYSBzaW5nbGUgZGlyZWN0aW9uXG4oYXMgaW4gbGVmdC10by1yaWdodCBvciByaWdodC10by1sZWZ0KS5cbiovXG5jbGFzcyBCaWRpU3BhbiB7XG4gICAgLyoqXG4gICAgVGhlIGRpcmVjdGlvbiBvZiB0aGlzIHNwYW4uXG4gICAgKi9cbiAgICBnZXQgZGlyKCkgeyByZXR1cm4gdGhpcy5sZXZlbCAlIDIgPyBSVEwgOiBMVFI7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBzdGFydCBvZiB0aGUgc3BhbiAocmVsYXRpdmUgdG8gdGhlIHN0YXJ0IG9mIHRoZSBsaW5lKS5cbiAgICAqL1xuICAgIGZyb20sIFxuICAgIC8qKlxuICAgIFRoZSBlbmQgb2YgdGhlIHNwYW4uXG4gICAgKi9cbiAgICB0bywgXG4gICAgLyoqXG4gICAgVGhlIFtcImJpZGlcbiAgICBsZXZlbFwiXShodHRwczovL3VuaWNvZGUub3JnL3JlcG9ydHMvdHI5LyNCYXNpY19EaXNwbGF5X0FsZ29yaXRobSlcbiAgICBvZiB0aGUgc3BhbiAoaW4gdGhpcyBjb250ZXh0LCAwIG1lYW5zXG4gICAgbGVmdC10by1yaWdodCwgMSBtZWFucyByaWdodC10by1sZWZ0LCAyIG1lYW5zIGxlZnQtdG8tcmlnaHRcbiAgICBudW1iZXIgaW5zaWRlIHJpZ2h0LXRvLWxlZnQgdGV4dCkuXG4gICAgKi9cbiAgICBsZXZlbCkge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMubGV2ZWwgPSBsZXZlbDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzaWRlKGVuZCwgZGlyKSB7IHJldHVybiAodGhpcy5kaXIgPT0gZGlyKSA9PSBlbmQgPyB0aGlzLnRvIDogdGhpcy5mcm9tOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgZmluZChvcmRlciwgaW5kZXgsIGxldmVsLCBhc3NvYykge1xuICAgICAgICBsZXQgbWF5YmUgPSAtMTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcmRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHNwYW4gPSBvcmRlcltpXTtcbiAgICAgICAgICAgIGlmIChzcGFuLmZyb20gPD0gaW5kZXggJiYgc3Bhbi50byA+PSBpbmRleCkge1xuICAgICAgICAgICAgICAgIGlmIChzcGFuLmxldmVsID09IGxldmVsKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICAvLyBXaGVuIG11bHRpcGxlIHNwYW5zIG1hdGNoLCBpZiBhc3NvYyAhPSAwLCB0YWtlIHRoZSBvbmUgdGhhdFxuICAgICAgICAgICAgICAgIC8vIGNvdmVycyB0aGF0IHNpZGUsIG90aGVyd2lzZSB0YWtlIHRoZSBvbmUgd2l0aCB0aGUgbWluaW11bVxuICAgICAgICAgICAgICAgIC8vIGxldmVsLlxuICAgICAgICAgICAgICAgIGlmIChtYXliZSA8IDAgfHwgKGFzc29jICE9IDAgPyAoYXNzb2MgPCAwID8gc3Bhbi5mcm9tIDwgaW5kZXggOiBzcGFuLnRvID4gaW5kZXgpIDogb3JkZXJbbWF5YmVdLmxldmVsID4gc3Bhbi5sZXZlbCkpXG4gICAgICAgICAgICAgICAgICAgIG1heWJlID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobWF5YmUgPCAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbmRleCBvdXQgb2YgcmFuZ2VcIik7XG4gICAgICAgIHJldHVybiBtYXliZTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc29sYXRlc0VxKGEsIGIpIHtcbiAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGlBID0gYVtpXSwgaUIgPSBiW2ldO1xuICAgICAgICBpZiAoaUEuZnJvbSAhPSBpQi5mcm9tIHx8IGlBLnRvICE9IGlCLnRvIHx8IGlBLmRpcmVjdGlvbiAhPSBpQi5kaXJlY3Rpb24gfHwgIWlzb2xhdGVzRXEoaUEuaW5uZXIsIGlCLmlubmVyKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vLyBSZXVzZWQgYXJyYXkgb2YgY2hhcmFjdGVyIHR5cGVzXG5jb25zdCB0eXBlcyA9IFtdO1xuLy8gRmlsbCBpbiB0aGUgY2hhcmFjdGVyIHR5cGVzIChpbiBgdHlwZXNgKSBmcm9tIGBmcm9tYCB0byBgdG9gIGFuZFxuLy8gYXBwbHkgVyBub3JtYWxpemF0aW9uIHJ1bGVzLlxuZnVuY3Rpb24gY29tcHV0ZUNoYXJUeXBlcyhsaW5lLCByRnJvbSwgclRvLCBpc29sYXRlcywgb3V0ZXJUeXBlKSB7XG4gICAgZm9yIChsZXQgaUkgPSAwOyBpSSA8PSBpc29sYXRlcy5sZW5ndGg7IGlJKyspIHtcbiAgICAgICAgbGV0IGZyb20gPSBpSSA/IGlzb2xhdGVzW2lJIC0gMV0udG8gOiByRnJvbSwgdG8gPSBpSSA8IGlzb2xhdGVzLmxlbmd0aCA/IGlzb2xhdGVzW2lJXS5mcm9tIDogclRvO1xuICAgICAgICBsZXQgcHJldlR5cGUgPSBpSSA/IDI1NiAvKiBULk5JICovIDogb3V0ZXJUeXBlO1xuICAgICAgICAvLyBXMS4gRXhhbWluZSBlYWNoIG5vbi1zcGFjaW5nIG1hcmsgKE5TTSkgaW4gdGhlIGxldmVsIHJ1biwgYW5kXG4gICAgICAgIC8vIGNoYW5nZSB0aGUgdHlwZSBvZiB0aGUgTlNNIHRvIHRoZSB0eXBlIG9mIHRoZSBwcmV2aW91c1xuICAgICAgICAvLyBjaGFyYWN0ZXIuIElmIHRoZSBOU00gaXMgYXQgdGhlIHN0YXJ0IG9mIHRoZSBsZXZlbCBydW4sIGl0IHdpbGxcbiAgICAgICAgLy8gZ2V0IHRoZSB0eXBlIG9mIHNvci5cbiAgICAgICAgLy8gVzIuIFNlYXJjaCBiYWNrd2FyZHMgZnJvbSBlYWNoIGluc3RhbmNlIG9mIGEgRXVyb3BlYW4gbnVtYmVyXG4gICAgICAgIC8vIHVudGlsIHRoZSBmaXJzdCBzdHJvbmcgdHlwZSAoUiwgTCwgQUwsIG9yIHNvcikgaXMgZm91bmQuIElmIGFuXG4gICAgICAgIC8vIEFMIGlzIGZvdW5kLCBjaGFuZ2UgdGhlIHR5cGUgb2YgdGhlIEV1cm9wZWFuIG51bWJlciB0byBBcmFiaWNcbiAgICAgICAgLy8gbnVtYmVyLlxuICAgICAgICAvLyBXMy4gQ2hhbmdlIGFsbCBBTHMgdG8gUi5cbiAgICAgICAgLy8gKExlZnQgYWZ0ZXIgdGhpczogTCwgUiwgRU4sIEFOLCBFVCwgQ1MsIE5JKVxuICAgICAgICBmb3IgKGxldCBpID0gZnJvbSwgcHJldiA9IHByZXZUeXBlLCBwcmV2U3Ryb25nID0gcHJldlR5cGU7IGkgPCB0bzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgdHlwZSA9IGNoYXJUeXBlKGxpbmUuY2hhckNvZGVBdChpKSk7XG4gICAgICAgICAgICBpZiAodHlwZSA9PSA1MTIgLyogVC5OU00gKi8pXG4gICAgICAgICAgICAgICAgdHlwZSA9IHByZXY7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09IDggLyogVC5FTiAqLyAmJiBwcmV2U3Ryb25nID09IDQgLyogVC5BTCAqLylcbiAgICAgICAgICAgICAgICB0eXBlID0gMTYgLyogVC5BTiAqLztcbiAgICAgICAgICAgIHR5cGVzW2ldID0gdHlwZSA9PSA0IC8qIFQuQUwgKi8gPyAyIC8qIFQuUiAqLyA6IHR5cGU7XG4gICAgICAgICAgICBpZiAodHlwZSAmIDcgLyogVC5TdHJvbmcgKi8pXG4gICAgICAgICAgICAgICAgcHJldlN0cm9uZyA9IHR5cGU7XG4gICAgICAgICAgICBwcmV2ID0gdHlwZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXNS4gQSBzZXF1ZW5jZSBvZiBFdXJvcGVhbiB0ZXJtaW5hdG9ycyBhZGphY2VudCB0byBFdXJvcGVhblxuICAgICAgICAvLyBudW1iZXJzIGNoYW5nZXMgdG8gYWxsIEV1cm9wZWFuIG51bWJlcnMuXG4gICAgICAgIC8vIFc2LiBPdGhlcndpc2UsIHNlcGFyYXRvcnMgYW5kIHRlcm1pbmF0b3JzIGNoYW5nZSB0byBPdGhlclxuICAgICAgICAvLyBOZXV0cmFsLlxuICAgICAgICAvLyBXNy4gU2VhcmNoIGJhY2t3YXJkcyBmcm9tIGVhY2ggaW5zdGFuY2Ugb2YgYSBFdXJvcGVhbiBudW1iZXJcbiAgICAgICAgLy8gdW50aWwgdGhlIGZpcnN0IHN0cm9uZyB0eXBlIChSLCBMLCBvciBzb3IpIGlzIGZvdW5kLiBJZiBhbiBMIGlzXG4gICAgICAgIC8vIGZvdW5kLCB0aGVuIGNoYW5nZSB0aGUgdHlwZSBvZiB0aGUgRXVyb3BlYW4gbnVtYmVyIHRvIEwuXG4gICAgICAgIC8vIChMZWZ0IGFmdGVyIHRoaXM6IEwsIFIsIEVOK0FOLCBOSSlcbiAgICAgICAgZm9yIChsZXQgaSA9IGZyb20sIHByZXYgPSBwcmV2VHlwZSwgcHJldlN0cm9uZyA9IHByZXZUeXBlOyBpIDwgdG87IGkrKykge1xuICAgICAgICAgICAgbGV0IHR5cGUgPSB0eXBlc1tpXTtcbiAgICAgICAgICAgIGlmICh0eXBlID09IDEyOCAvKiBULkNTICovKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPCB0byAtIDEgJiYgcHJldiA9PSB0eXBlc1tpICsgMV0gJiYgKHByZXYgJiAyNCAvKiBULk51bSAqLykpXG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPSB0eXBlc1tpXSA9IHByZXY7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0eXBlc1tpXSA9IDI1NiAvKiBULk5JICovO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PSA2NCAvKiBULkVUICovKSB7XG4gICAgICAgICAgICAgICAgbGV0IGVuZCA9IGkgKyAxO1xuICAgICAgICAgICAgICAgIHdoaWxlIChlbmQgPCB0byAmJiB0eXBlc1tlbmRdID09IDY0IC8qIFQuRVQgKi8pXG4gICAgICAgICAgICAgICAgICAgIGVuZCsrO1xuICAgICAgICAgICAgICAgIGxldCByZXBsYWNlID0gKGkgJiYgcHJldiA9PSA4IC8qIFQuRU4gKi8pIHx8IChlbmQgPCByVG8gJiYgdHlwZXNbZW5kXSA9PSA4IC8qIFQuRU4gKi8pID8gKHByZXZTdHJvbmcgPT0gMSAvKiBULkwgKi8gPyAxIC8qIFQuTCAqLyA6IDggLyogVC5FTiAqLykgOiAyNTYgLyogVC5OSSAqLztcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gaTsgaiA8IGVuZDsgaisrKVxuICAgICAgICAgICAgICAgICAgICB0eXBlc1tqXSA9IHJlcGxhY2U7XG4gICAgICAgICAgICAgICAgaSA9IGVuZCAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09IDggLyogVC5FTiAqLyAmJiBwcmV2U3Ryb25nID09IDEgLyogVC5MICovKSB7XG4gICAgICAgICAgICAgICAgdHlwZXNbaV0gPSAxIC8qIFQuTCAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXYgPSB0eXBlO1xuICAgICAgICAgICAgaWYgKHR5cGUgJiA3IC8qIFQuU3Ryb25nICovKVxuICAgICAgICAgICAgICAgIHByZXZTdHJvbmcgPSB0eXBlO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8gUHJvY2VzcyBicmFja2V0cyB0aHJvdWdob3V0IGEgcnVuIHNlcXVlbmNlLlxuZnVuY3Rpb24gcHJvY2Vzc0JyYWNrZXRQYWlycyhsaW5lLCByRnJvbSwgclRvLCBpc29sYXRlcywgb3V0ZXJUeXBlKSB7XG4gICAgbGV0IG9wcG9zaXRlVHlwZSA9IG91dGVyVHlwZSA9PSAxIC8qIFQuTCAqLyA/IDIgLyogVC5SICovIDogMSAvKiBULkwgKi87XG4gICAgZm9yIChsZXQgaUkgPSAwLCBzSSA9IDAsIGNvbnRleHQgPSAwOyBpSSA8PSBpc29sYXRlcy5sZW5ndGg7IGlJKyspIHtcbiAgICAgICAgbGV0IGZyb20gPSBpSSA/IGlzb2xhdGVzW2lJIC0gMV0udG8gOiByRnJvbSwgdG8gPSBpSSA8IGlzb2xhdGVzLmxlbmd0aCA/IGlzb2xhdGVzW2lJXS5mcm9tIDogclRvO1xuICAgICAgICAvLyBOMC4gUHJvY2VzcyBicmFja2V0IHBhaXJzIGluIGFuIGlzb2xhdGluZyBydW4gc2VxdWVuY2VcbiAgICAgICAgLy8gc2VxdWVudGlhbGx5IGluIHRoZSBsb2dpY2FsIG9yZGVyIG9mIHRoZSB0ZXh0IHBvc2l0aW9ucyBvZiB0aGVcbiAgICAgICAgLy8gb3BlbmluZyBwYWlyZWQgYnJhY2tldHMgdXNpbmcgdGhlIGxvZ2ljIGdpdmVuIGJlbG93LiBXaXRoaW4gdGhpc1xuICAgICAgICAvLyBzY29wZSwgYmlkaXJlY3Rpb25hbCB0eXBlcyBFTiBhbmQgQU4gYXJlIHRyZWF0ZWQgYXMgUi5cbiAgICAgICAgZm9yIChsZXQgaSA9IGZyb20sIGNoLCBiciwgdHlwZTsgaSA8IHRvOyBpKyspIHtcbiAgICAgICAgICAgIC8vIEtlZXBzIFtzdGFydEluZGV4LCB0eXBlLCBzdHJvbmdTZWVuXSB0cmlwbGVzIGZvciBlYWNoIG9wZW5cbiAgICAgICAgICAgIC8vIGJyYWNrZXQgb24gQnJhY2tldFN0YWNrLlxuICAgICAgICAgICAgaWYgKGJyID0gQnJhY2tldHNbY2ggPSBsaW5lLmNoYXJDb2RlQXQoaSldKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJyIDwgMCkgeyAvLyBDbG9zaW5nIGJyYWNrZXRcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgc0ogPSBzSSAtIDM7IHNKID49IDA7IHNKIC09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChCcmFja2V0U3RhY2tbc0ogKyAxXSA9PSAtYnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZmxhZ3MgPSBCcmFja2V0U3RhY2tbc0ogKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdHlwZSA9IChmbGFncyAmIDIgLyogQnJhY2tldGVkLkVtYmVkSW5zaWRlICovKSA/IG91dGVyVHlwZSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICEoZmxhZ3MgJiA0IC8qIEJyYWNrZXRlZC5PcHBvc2l0ZUluc2lkZSAqLykgPyAwIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChmbGFncyAmIDEgLyogQnJhY2tldGVkLk9wcG9zaXRlQmVmb3JlICovKSA/IG9wcG9zaXRlVHlwZSA6IG91dGVyVHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZXNbaV0gPSB0eXBlc1tCcmFja2V0U3RhY2tbc0pdXSA9IHR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc0kgPSBzSjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChCcmFja2V0U3RhY2subGVuZ3RoID09IDE4OSAvKiBCcmFja2V0ZWQuTWF4RGVwdGggKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBCcmFja2V0U3RhY2tbc0krK10gPSBpO1xuICAgICAgICAgICAgICAgICAgICBCcmFja2V0U3RhY2tbc0krK10gPSBjaDtcbiAgICAgICAgICAgICAgICAgICAgQnJhY2tldFN0YWNrW3NJKytdID0gY29udGV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgodHlwZSA9IHR5cGVzW2ldKSA9PSAyIC8qIFQuUiAqLyB8fCB0eXBlID09IDEgLyogVC5MICovKSB7XG4gICAgICAgICAgICAgICAgbGV0IGVtYmVkID0gdHlwZSA9PSBvdXRlclR5cGU7XG4gICAgICAgICAgICAgICAgY29udGV4dCA9IGVtYmVkID8gMCA6IDEgLyogQnJhY2tldGVkLk9wcG9zaXRlQmVmb3JlICovO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHNKID0gc0kgLSAzOyBzSiA+PSAwOyBzSiAtPSAzKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjdXIgPSBCcmFja2V0U3RhY2tbc0ogKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1ciAmIDIgLyogQnJhY2tldGVkLkVtYmVkSW5zaWRlICovKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbWJlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgQnJhY2tldFN0YWNrW3NKICsgMl0gfD0gMiAvKiBCcmFja2V0ZWQuRW1iZWRJbnNpZGUgKi87XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VyICYgNCAvKiBCcmFja2V0ZWQuT3Bwb3NpdGVJbnNpZGUgKi8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBCcmFja2V0U3RhY2tbc0ogKyAyXSB8PSA0IC8qIEJyYWNrZXRlZC5PcHBvc2l0ZUluc2lkZSAqLztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHByb2Nlc3NOZXV0cmFscyhyRnJvbSwgclRvLCBpc29sYXRlcywgb3V0ZXJUeXBlKSB7XG4gICAgZm9yIChsZXQgaUkgPSAwLCBwcmV2ID0gb3V0ZXJUeXBlOyBpSSA8PSBpc29sYXRlcy5sZW5ndGg7IGlJKyspIHtcbiAgICAgICAgbGV0IGZyb20gPSBpSSA/IGlzb2xhdGVzW2lJIC0gMV0udG8gOiByRnJvbSwgdG8gPSBpSSA8IGlzb2xhdGVzLmxlbmd0aCA/IGlzb2xhdGVzW2lJXS5mcm9tIDogclRvO1xuICAgICAgICAvLyBOMS4gQSBzZXF1ZW5jZSBvZiBuZXV0cmFscyB0YWtlcyB0aGUgZGlyZWN0aW9uIG9mIHRoZVxuICAgICAgICAvLyBzdXJyb3VuZGluZyBzdHJvbmcgdGV4dCBpZiB0aGUgdGV4dCBvbiBib3RoIHNpZGVzIGhhcyB0aGUgc2FtZVxuICAgICAgICAvLyBkaXJlY3Rpb24uIEV1cm9wZWFuIGFuZCBBcmFiaWMgbnVtYmVycyBhY3QgYXMgaWYgdGhleSB3ZXJlIFIgaW5cbiAgICAgICAgLy8gdGVybXMgb2YgdGhlaXIgaW5mbHVlbmNlIG9uIG5ldXRyYWxzLiBTdGFydC1vZi1sZXZlbC1ydW4gKHNvcilcbiAgICAgICAgLy8gYW5kIGVuZC1vZi1sZXZlbC1ydW4gKGVvcikgYXJlIHVzZWQgYXQgbGV2ZWwgcnVuIGJvdW5kYXJpZXMuXG4gICAgICAgIC8vIE4yLiBBbnkgcmVtYWluaW5nIG5ldXRyYWxzIHRha2UgdGhlIGVtYmVkZGluZyBkaXJlY3Rpb24uXG4gICAgICAgIC8vIChMZWZ0IGFmdGVyIHRoaXM6IEwsIFIsIEVOK0FOKVxuICAgICAgICBmb3IgKGxldCBpID0gZnJvbTsgaSA8IHRvOykge1xuICAgICAgICAgICAgbGV0IHR5cGUgPSB0eXBlc1tpXTtcbiAgICAgICAgICAgIGlmICh0eXBlID09IDI1NiAvKiBULk5JICovKSB7XG4gICAgICAgICAgICAgICAgbGV0IGVuZCA9IGkgKyAxO1xuICAgICAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVuZCA9PSB0bykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlJID09IGlzb2xhdGVzLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZCA9IGlzb2xhdGVzW2lJKytdLnRvO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG8gPSBpSSA8IGlzb2xhdGVzLmxlbmd0aCA/IGlzb2xhdGVzW2lJXS5mcm9tIDogclRvO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVzW2VuZF0gPT0gMjU2IC8qIFQuTkkgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGJlZm9yZUwgPSBwcmV2ID09IDEgLyogVC5MICovO1xuICAgICAgICAgICAgICAgIGxldCBhZnRlckwgPSAoZW5kIDwgclRvID8gdHlwZXNbZW5kXSA6IG91dGVyVHlwZSkgPT0gMSAvKiBULkwgKi87XG4gICAgICAgICAgICAgICAgbGV0IHJlcGxhY2UgPSBiZWZvcmVMID09IGFmdGVyTCA/IChiZWZvcmVMID8gMSAvKiBULkwgKi8gOiAyIC8qIFQuUiAqLykgOiBvdXRlclR5cGU7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IGVuZCwgakkgPSBpSSwgZnJvbUogPSBqSSA/IGlzb2xhdGVzW2pJIC0gMV0udG8gOiByRnJvbTsgaiA+IGk7KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChqID09IGZyb21KKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBqID0gaXNvbGF0ZXNbLS1qSV0uZnJvbTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyb21KID0gakkgPyBpc29sYXRlc1tqSSAtIDFdLnRvIDogckZyb207XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdHlwZXNbLS1qXSA9IHJlcGxhY2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGkgPSBlbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcmV2ID0gdHlwZTtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyBGaW5kIHRoZSBjb250aWd1b3VzIHJhbmdlcyBvZiBjaGFyYWN0ZXIgdHlwZXMgaW4gYSBnaXZlbiByYW5nZSwgYW5kXG4vLyBlbWl0IHNwYW5zIGZvciB0aGVtLiBGbGlwIHRoZSBvcmRlciBvZiB0aGUgc3BhbnMgYXMgYXBwcm9wcmlhdGVcbi8vIGJhc2VkIG9uIHRoZSBsZXZlbCwgYW5kIGNhbGwgdGhyb3VnaCB0byBjb21wdXRlIHRoZSBzcGFucyBmb3Jcbi8vIGlzb2xhdGVzIGF0IHRoZSBwcm9wZXIgcG9pbnQuXG5mdW5jdGlvbiBlbWl0U3BhbnMobGluZSwgZnJvbSwgdG8sIGxldmVsLCBiYXNlTGV2ZWwsIGlzb2xhdGVzLCBvcmRlcikge1xuICAgIGxldCBvdXJUeXBlID0gbGV2ZWwgJSAyID8gMiAvKiBULlIgKi8gOiAxIC8qIFQuTCAqLztcbiAgICBpZiAoKGxldmVsICUgMikgPT0gKGJhc2VMZXZlbCAlIDIpKSB7IC8vIFNhbWUgZGlyIGFzIGJhc2UgZGlyZWN0aW9uLCBkb24ndCBmbGlwXG4gICAgICAgIGZvciAobGV0IGlDaCA9IGZyb20sIGlJID0gMDsgaUNoIDwgdG87KSB7XG4gICAgICAgICAgICAvLyBTY2FuIGEgc2VjdGlvbiBvZiBjaGFyYWN0ZXJzIGluIGRpcmVjdGlvbiBvdXJUeXBlLCB1bmxlc3NcbiAgICAgICAgICAgIC8vIHRoZXJlJ3MgYW5vdGhlciB0eXBlIG9mIGNoYXIgcmlnaHQgYWZ0ZXIgaUNoLCBpbiB3aGljaCBjYXNlXG4gICAgICAgICAgICAvLyB3ZSBzY2FuIGEgc2VjdGlvbiBvZiBvdGhlciBjaGFyYWN0ZXJzICh3aGljaCwgaWYgb3VyVHlwZSA9PVxuICAgICAgICAgICAgLy8gVC5MLCBtYXkgY29udGFpbiBib3RoIFQuUiBhbmQgVC5BTiBjaGFycykuXG4gICAgICAgICAgICBsZXQgc2FtZURpciA9IHRydWUsIGlzTnVtID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoaUkgPT0gaXNvbGF0ZXMubGVuZ3RoIHx8IGlDaCA8IGlzb2xhdGVzW2lJXS5mcm9tKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSB0eXBlc1tpQ2hdO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0ICE9IG91clR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2FtZURpciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBpc051bSA9IG5leHQgPT0gMTYgLyogVC5BTiAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBIb2xkcyBhbiBhcnJheSBvZiBpc29sYXRlcyB0byBwYXNzIHRvIGEgcmVjdXJzaXZlIGNhbGwgaWYgd2VcbiAgICAgICAgICAgIC8vIG11c3QgcmVjdXJzZSAodG8gZGlzdGluZ3Vpc2ggVC5BTiBpbnNpZGUgYW4gUlRMIHNlY3Rpb24gaW5cbiAgICAgICAgICAgIC8vIExUUiB0ZXh0KSwgbnVsbCBpZiB3ZSBjYW4gZW1pdCBkaXJlY3RseVxuICAgICAgICAgICAgbGV0IHJlY3Vyc2UgPSAhc2FtZURpciAmJiBvdXJUeXBlID09IDEgLyogVC5MICovID8gW10gOiBudWxsO1xuICAgICAgICAgICAgbGV0IGxvY2FsTGV2ZWwgPSBzYW1lRGlyID8gbGV2ZWwgOiBsZXZlbCArIDE7XG4gICAgICAgICAgICBsZXQgaVNjYW4gPSBpQ2g7XG4gICAgICAgICAgICBydW46IGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICBpZiAoaUkgPCBpc29sYXRlcy5sZW5ndGggJiYgaVNjYW4gPT0gaXNvbGF0ZXNbaUldLmZyb20pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTnVtKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgcnVuO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaXNvID0gaXNvbGF0ZXNbaUldO1xuICAgICAgICAgICAgICAgICAgICAvLyBTY2FuIGFoZWFkIHRvIHZlcmlmeSB0aGF0IHRoZXJlIGlzIGFub3RoZXIgY2hhciBpbiB0aGlzIGRpciBhZnRlciB0aGUgaXNvbGF0ZShzKVxuICAgICAgICAgICAgICAgICAgICBpZiAoIXNhbWVEaXIpXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB1cHRvID0gaXNvLnRvLCBqSSA9IGlJICsgMTs7KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVwdG8gPT0gdG8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIHJ1bjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoakkgPCBpc29sYXRlcy5sZW5ndGggJiYgaXNvbGF0ZXNbakldLmZyb20gPT0gdXB0bylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXB0byA9IGlzb2xhdGVzW2pJKytdLnRvO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVzW3VwdG9dID09IG91clR5cGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIHJ1bjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpSSsrO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVjdXJzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjdXJzZS5wdXNoKGlzbyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNvLmZyb20gPiBpQ2gpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JkZXIucHVzaChuZXcgQmlkaVNwYW4oaUNoLCBpc28uZnJvbSwgbG9jYWxMZXZlbCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGRpclN3YXAgPSAoaXNvLmRpcmVjdGlvbiA9PSBMVFIpICE9ICEobG9jYWxMZXZlbCAlIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcHV0ZVNlY3Rpb25PcmRlcihsaW5lLCBkaXJTd2FwID8gbGV2ZWwgKyAxIDogbGV2ZWwsIGJhc2VMZXZlbCwgaXNvLmlubmVyLCBpc28uZnJvbSwgaXNvLnRvLCBvcmRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpQ2ggPSBpc28udG87XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaVNjYW4gPSBpc28udG87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlTY2FuID09IHRvIHx8IChzYW1lRGlyID8gdHlwZXNbaVNjYW5dICE9IG91clR5cGUgOiB0eXBlc1tpU2Nhbl0gPT0gb3VyVHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpU2NhbisrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZWN1cnNlKVxuICAgICAgICAgICAgICAgIGVtaXRTcGFucyhsaW5lLCBpQ2gsIGlTY2FuLCBsZXZlbCArIDEsIGJhc2VMZXZlbCwgcmVjdXJzZSwgb3JkZXIpO1xuICAgICAgICAgICAgZWxzZSBpZiAoaUNoIDwgaVNjYW4pXG4gICAgICAgICAgICAgICAgb3JkZXIucHVzaChuZXcgQmlkaVNwYW4oaUNoLCBpU2NhbiwgbG9jYWxMZXZlbCkpO1xuICAgICAgICAgICAgaUNoID0gaVNjYW47XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIEl0ZXJhdGUgaW4gcmV2ZXJzZSB0byBmbGlwIHRoZSBzcGFuIG9yZGVyLiBTYW1lIGNvZGUgYWdhaW4sIGJ1dFxuICAgICAgICAvLyBnb2luZyBmcm9tIHRoZSBiYWNrIG9mIHRoZSBzZWN0aW9uIHRvIHRoZSBmcm9udFxuICAgICAgICBmb3IgKGxldCBpQ2ggPSB0bywgaUkgPSBpc29sYXRlcy5sZW5ndGg7IGlDaCA+IGZyb207KSB7XG4gICAgICAgICAgICBsZXQgc2FtZURpciA9IHRydWUsIGlzTnVtID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoIWlJIHx8IGlDaCA+IGlzb2xhdGVzW2lJIC0gMV0udG8pIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IHR5cGVzW2lDaCAtIDFdO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0ICE9IG91clR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2FtZURpciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBpc051bSA9IG5leHQgPT0gMTYgLyogVC5BTiAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmVjdXJzZSA9ICFzYW1lRGlyICYmIG91clR5cGUgPT0gMSAvKiBULkwgKi8gPyBbXSA6IG51bGw7XG4gICAgICAgICAgICBsZXQgbG9jYWxMZXZlbCA9IHNhbWVEaXIgPyBsZXZlbCA6IGxldmVsICsgMTtcbiAgICAgICAgICAgIGxldCBpU2NhbiA9IGlDaDtcbiAgICAgICAgICAgIHJ1bjogZm9yICg7Oykge1xuICAgICAgICAgICAgICAgIGlmIChpSSAmJiBpU2NhbiA9PSBpc29sYXRlc1tpSSAtIDFdLnRvKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc051bSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIHJ1bjtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGlzbyA9IGlzb2xhdGVzWy0taUldO1xuICAgICAgICAgICAgICAgICAgICAvLyBTY2FuIGFoZWFkIHRvIHZlcmlmeSB0aGF0IHRoZXJlIGlzIGFub3RoZXIgY2hhciBpbiB0aGlzIGRpciBhZnRlciB0aGUgaXNvbGF0ZShzKVxuICAgICAgICAgICAgICAgICAgICBpZiAoIXNhbWVEaXIpXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB1cHRvID0gaXNvLmZyb20sIGpJID0gaUk7Oykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1cHRvID09IGZyb20pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIHJ1bjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoakkgJiYgaXNvbGF0ZXNbakkgLSAxXS50byA9PSB1cHRvKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cHRvID0gaXNvbGF0ZXNbLS1qSV0uZnJvbTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlc1t1cHRvIC0gMV0gPT0gb3VyVHlwZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgcnVuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWN1cnNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWN1cnNlLnB1c2goaXNvKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc28udG8gPCBpQ2gpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JkZXIucHVzaChuZXcgQmlkaVNwYW4oaXNvLnRvLCBpQ2gsIGxvY2FsTGV2ZWwpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkaXJTd2FwID0gKGlzby5kaXJlY3Rpb24gPT0gTFRSKSAhPSAhKGxvY2FsTGV2ZWwgJSAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXB1dGVTZWN0aW9uT3JkZXIobGluZSwgZGlyU3dhcCA/IGxldmVsICsgMSA6IGxldmVsLCBiYXNlTGV2ZWwsIGlzby5pbm5lciwgaXNvLmZyb20sIGlzby50bywgb3JkZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaUNoID0gaXNvLmZyb207XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaVNjYW4gPSBpc28uZnJvbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaVNjYW4gPT0gZnJvbSB8fCAoc2FtZURpciA/IHR5cGVzW2lTY2FuIC0gMV0gIT0gb3VyVHlwZSA6IHR5cGVzW2lTY2FuIC0gMV0gPT0gb3VyVHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpU2Nhbi0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZWN1cnNlKVxuICAgICAgICAgICAgICAgIGVtaXRTcGFucyhsaW5lLCBpU2NhbiwgaUNoLCBsZXZlbCArIDEsIGJhc2VMZXZlbCwgcmVjdXJzZSwgb3JkZXIpO1xuICAgICAgICAgICAgZWxzZSBpZiAoaVNjYW4gPCBpQ2gpXG4gICAgICAgICAgICAgICAgb3JkZXIucHVzaChuZXcgQmlkaVNwYW4oaVNjYW4sIGlDaCwgbG9jYWxMZXZlbCkpO1xuICAgICAgICAgICAgaUNoID0gaVNjYW47XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBjb21wdXRlU2VjdGlvbk9yZGVyKGxpbmUsIGxldmVsLCBiYXNlTGV2ZWwsIGlzb2xhdGVzLCBmcm9tLCB0bywgb3JkZXIpIHtcbiAgICBsZXQgb3V0ZXJUeXBlID0gKGxldmVsICUgMiA/IDIgLyogVC5SICovIDogMSAvKiBULkwgKi8pO1xuICAgIGNvbXB1dGVDaGFyVHlwZXMobGluZSwgZnJvbSwgdG8sIGlzb2xhdGVzLCBvdXRlclR5cGUpO1xuICAgIHByb2Nlc3NCcmFja2V0UGFpcnMobGluZSwgZnJvbSwgdG8sIGlzb2xhdGVzLCBvdXRlclR5cGUpO1xuICAgIHByb2Nlc3NOZXV0cmFscyhmcm9tLCB0bywgaXNvbGF0ZXMsIG91dGVyVHlwZSk7XG4gICAgZW1pdFNwYW5zKGxpbmUsIGZyb20sIHRvLCBsZXZlbCwgYmFzZUxldmVsLCBpc29sYXRlcywgb3JkZXIpO1xufVxuZnVuY3Rpb24gY29tcHV0ZU9yZGVyKGxpbmUsIGRpcmVjdGlvbiwgaXNvbGF0ZXMpIHtcbiAgICBpZiAoIWxpbmUpXG4gICAgICAgIHJldHVybiBbbmV3IEJpZGlTcGFuKDAsIDAsIGRpcmVjdGlvbiA9PSBSVEwgPyAxIDogMCldO1xuICAgIGlmIChkaXJlY3Rpb24gPT0gTFRSICYmICFpc29sYXRlcy5sZW5ndGggJiYgIUJpZGlSRS50ZXN0KGxpbmUpKVxuICAgICAgICByZXR1cm4gdHJpdmlhbE9yZGVyKGxpbmUubGVuZ3RoKTtcbiAgICBpZiAoaXNvbGF0ZXMubGVuZ3RoKVxuICAgICAgICB3aGlsZSAobGluZS5sZW5ndGggPiB0eXBlcy5sZW5ndGgpXG4gICAgICAgICAgICB0eXBlc1t0eXBlcy5sZW5ndGhdID0gMjU2IC8qIFQuTkkgKi87IC8vIE1ha2Ugc3VyZSB0eXBlcyBhcnJheSBoYXMgbm8gZ2Fwc1xuICAgIGxldCBvcmRlciA9IFtdLCBsZXZlbCA9IGRpcmVjdGlvbiA9PSBMVFIgPyAwIDogMTtcbiAgICBjb21wdXRlU2VjdGlvbk9yZGVyKGxpbmUsIGxldmVsLCBsZXZlbCwgaXNvbGF0ZXMsIDAsIGxpbmUubGVuZ3RoLCBvcmRlcik7XG4gICAgcmV0dXJuIG9yZGVyO1xufVxuZnVuY3Rpb24gdHJpdmlhbE9yZGVyKGxlbmd0aCkge1xuICAgIHJldHVybiBbbmV3IEJpZGlTcGFuKDAsIGxlbmd0aCwgMCldO1xufVxubGV0IG1vdmVkT3ZlciA9IFwiXCI7XG5mdW5jdGlvbiBtb3ZlVmlzdWFsbHkobGluZSwgb3JkZXIsIGRpciwgc3RhcnQsIGZvcndhcmQpIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IHN0YXJ0SW5kZXggPSBzdGFydC5oZWFkIC0gbGluZS5mcm9tLCBzcGFuSSA9IC0xO1xuICAgIGlmIChzdGFydEluZGV4ID09IDApIHtcbiAgICAgICAgaWYgKCFmb3J3YXJkIHx8ICFsaW5lLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBpZiAob3JkZXJbMF0ubGV2ZWwgIT0gZGlyKSB7XG4gICAgICAgICAgICBzdGFydEluZGV4ID0gb3JkZXJbMF0uc2lkZShmYWxzZSwgZGlyKTtcbiAgICAgICAgICAgIHNwYW5JID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChzdGFydEluZGV4ID09IGxpbmUubGVuZ3RoKSB7XG4gICAgICAgIGlmIChmb3J3YXJkKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCBsYXN0ID0gb3JkZXJbb3JkZXIubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChsYXN0LmxldmVsICE9IGRpcikge1xuICAgICAgICAgICAgc3RhcnRJbmRleCA9IGxhc3Quc2lkZSh0cnVlLCBkaXIpO1xuICAgICAgICAgICAgc3BhbkkgPSBvcmRlci5sZW5ndGggLSAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChzcGFuSSA8IDApXG4gICAgICAgIHNwYW5JID0gQmlkaVNwYW4uZmluZChvcmRlciwgc3RhcnRJbmRleCwgKF9hID0gc3RhcnQuYmlkaUxldmVsKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAtMSwgc3RhcnQuYXNzb2MpO1xuICAgIGxldCBzcGFuID0gb3JkZXJbc3BhbkldO1xuICAgIC8vIEVuZCBvZiBzcGFuLiAoQnV0IG5vdCBlbmQgb2YgbGluZS0tdGhhdCB3YXMgY2hlY2tlZCBmb3IgYWJvdmUuKVxuICAgIGlmIChzdGFydEluZGV4ID09IHNwYW4uc2lkZShmb3J3YXJkLCBkaXIpKSB7XG4gICAgICAgIHNwYW4gPSBvcmRlcltzcGFuSSArPSBmb3J3YXJkID8gMSA6IC0xXTtcbiAgICAgICAgc3RhcnRJbmRleCA9IHNwYW4uc2lkZSghZm9yd2FyZCwgZGlyKTtcbiAgICB9XG4gICAgbGV0IGluZGV4Rm9yd2FyZCA9IGZvcndhcmQgPT0gKHNwYW4uZGlyID09IGRpcik7XG4gICAgbGV0IG5leHRJbmRleCA9IGZpbmRDbHVzdGVyQnJlYWsobGluZS50ZXh0LCBzdGFydEluZGV4LCBpbmRleEZvcndhcmQpO1xuICAgIG1vdmVkT3ZlciA9IGxpbmUudGV4dC5zbGljZShNYXRoLm1pbihzdGFydEluZGV4LCBuZXh0SW5kZXgpLCBNYXRoLm1heChzdGFydEluZGV4LCBuZXh0SW5kZXgpKTtcbiAgICBpZiAobmV4dEluZGV4ID4gc3Bhbi5mcm9tICYmIG5leHRJbmRleCA8IHNwYW4udG8pXG4gICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKG5leHRJbmRleCArIGxpbmUuZnJvbSwgaW5kZXhGb3J3YXJkID8gLTEgOiAxLCBzcGFuLmxldmVsKTtcbiAgICBsZXQgbmV4dFNwYW4gPSBzcGFuSSA9PSAoZm9yd2FyZCA/IG9yZGVyLmxlbmd0aCAtIDEgOiAwKSA/IG51bGwgOiBvcmRlcltzcGFuSSArIChmb3J3YXJkID8gMSA6IC0xKV07XG4gICAgaWYgKCFuZXh0U3BhbiAmJiBzcGFuLmxldmVsICE9IGRpcilcbiAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jdXJzb3IoZm9yd2FyZCA/IGxpbmUudG8gOiBsaW5lLmZyb20sIGZvcndhcmQgPyAtMSA6IDEsIGRpcik7XG4gICAgaWYgKG5leHRTcGFuICYmIG5leHRTcGFuLmxldmVsIDwgc3Bhbi5sZXZlbClcbiAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jdXJzb3IobmV4dFNwYW4uc2lkZSghZm9yd2FyZCwgZGlyKSArIGxpbmUuZnJvbSwgZm9yd2FyZCA/IDEgOiAtMSwgbmV4dFNwYW4ubGV2ZWwpO1xuICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKG5leHRJbmRleCArIGxpbmUuZnJvbSwgZm9yd2FyZCA/IC0xIDogMSwgc3Bhbi5sZXZlbCk7XG59XG5cbmNsYXNzIERvY1ZpZXcgZXh0ZW5kcyBDb250ZW50VmlldyB7XG4gICAgZ2V0IGxlbmd0aCgpIHsgcmV0dXJuIHRoaXMudmlldy5zdGF0ZS5kb2MubGVuZ3RoOyB9XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gW107XG4gICAgICAgIHRoaXMuZHluYW1pY0RlY29yYXRpb25NYXAgPSBbXTtcbiAgICAgICAgdGhpcy5kb21DaGFuZ2VkID0gbnVsbDtcbiAgICAgICAgdGhpcy5oYXNDb21wb3NpdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMubWFya2VkRm9yQ29tcG9zaXRpb24gPSBuZXcgU2V0O1xuICAgICAgICAvLyBUcmFjayBhIG1pbmltdW0gd2lkdGggZm9yIHRoZSBlZGl0b3IuIFdoZW4gbWVhc3VyaW5nIHNpemVzIGluXG4gICAgICAgIC8vIG1lYXN1cmVWaXNpYmxlTGluZUhlaWdodHMsIHRoaXMgaXMgdXBkYXRlZCB0byBwb2ludCBhdCB0aGUgd2lkdGhcbiAgICAgICAgLy8gb2YgYSBnaXZlbiBlbGVtZW50IGFuZCBpdHMgZXh0ZW50IGluIHRoZSBkb2N1bWVudC4gV2hlbiBhIGNoYW5nZVxuICAgICAgICAvLyBoYXBwZW5zIGluIHRoYXQgcmFuZ2UsIHRoZXNlIGFyZSByZXNldC4gVGhhdCB3YXksIG9uY2Ugd2UndmUgc2VlblxuICAgICAgICAvLyBhIGxpbmUvZWxlbWVudCBvZiBhIGdpdmVuIGxlbmd0aCwgd2Uga2VlcCB0aGUgZWRpdG9yIHdpZGUgZW5vdWdoXG4gICAgICAgIC8vIHRvIGZpdCBhdCBsZWFzdCB0aGF0IGVsZW1lbnQsIHVudGlsIGl0IGlzIGNoYW5nZWQsIGF0IHdoaWNoIHBvaW50XG4gICAgICAgIC8vIHdlIGZvcmdldCBpdCBhZ2Fpbi5cbiAgICAgICAgdGhpcy5taW5XaWR0aCA9IDA7XG4gICAgICAgIHRoaXMubWluV2lkdGhGcm9tID0gMDtcbiAgICAgICAgdGhpcy5taW5XaWR0aFRvID0gMDtcbiAgICAgICAgLy8gVHJhY2sgd2hldGhlciB0aGUgRE9NIHNlbGVjdGlvbiB3YXMgc2V0IGluIGEgbG9zc3kgd2F5LCBzbyB0aGF0XG4gICAgICAgIC8vIHdlIGRvbid0IG1lc3MgaXQgdXAgd2hlbiByZWFkaW5nIGl0IGJhY2sgaXRcbiAgICAgICAgdGhpcy5pbXByZWNpc2VBbmNob3IgPSBudWxsO1xuICAgICAgICB0aGlzLmltcHJlY2lzZUhlYWQgPSBudWxsO1xuICAgICAgICB0aGlzLmZvcmNlU2VsZWN0aW9uID0gZmFsc2U7XG4gICAgICAgIC8vIFVzZWQgYnkgdGhlIHJlc2l6ZSBvYnNlcnZlciB0byBpZ25vcmUgcmVzaXplcyB0aGF0IHdlIGNhdXNlZFxuICAgICAgICAvLyBvdXJzZWx2ZXNcbiAgICAgICAgdGhpcy5sYXN0VXBkYXRlID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdGhpcy5zZXRET00odmlldy5jb250ZW50RE9NKTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IFtuZXcgTGluZVZpZXddO1xuICAgICAgICB0aGlzLmNoaWxkcmVuWzBdLnNldFBhcmVudCh0aGlzKTtcbiAgICAgICAgdGhpcy51cGRhdGVEZWNvKCk7XG4gICAgICAgIHRoaXMudXBkYXRlSW5uZXIoW25ldyBDaGFuZ2VkUmFuZ2UoMCwgMCwgMCwgdmlldy5zdGF0ZS5kb2MubGVuZ3RoKV0sIDAsIG51bGwpO1xuICAgIH1cbiAgICAvLyBVcGRhdGUgdGhlIGRvY3VtZW50IHZpZXcgdG8gYSBnaXZlbiBzdGF0ZS5cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgbGV0IGNoYW5nZWRSYW5nZXMgPSB1cGRhdGUuY2hhbmdlZFJhbmdlcztcbiAgICAgICAgaWYgKHRoaXMubWluV2lkdGggPiAwICYmIGNoYW5nZWRSYW5nZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoIWNoYW5nZWRSYW5nZXMuZXZlcnkoKHsgZnJvbUEsIHRvQSB9KSA9PiB0b0EgPCB0aGlzLm1pbldpZHRoRnJvbSB8fCBmcm9tQSA+IHRoaXMubWluV2lkdGhUbykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1pbldpZHRoID0gdGhpcy5taW5XaWR0aEZyb20gPSB0aGlzLm1pbldpZHRoVG8gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5taW5XaWR0aEZyb20gPSB1cGRhdGUuY2hhbmdlcy5tYXBQb3ModGhpcy5taW5XaWR0aEZyb20sIDEpO1xuICAgICAgICAgICAgICAgIHRoaXMubWluV2lkdGhUbyA9IHVwZGF0ZS5jaGFuZ2VzLm1hcFBvcyh0aGlzLm1pbldpZHRoVG8sIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCByZWFkQ29tcG9zaXRpb25BdCA9IC0xO1xuICAgICAgICBpZiAodGhpcy52aWV3LmlucHV0U3RhdGUuY29tcG9zaW5nID49IDApIHtcbiAgICAgICAgICAgIGlmICgoX2EgPSB0aGlzLmRvbUNoYW5nZWQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5uZXdTZWwpXG4gICAgICAgICAgICAgICAgcmVhZENvbXBvc2l0aW9uQXQgPSB0aGlzLmRvbUNoYW5nZWQubmV3U2VsLmhlYWQ7XG4gICAgICAgICAgICBlbHNlIGlmICghdG91Y2hlc0NvbXBvc2l0aW9uKHVwZGF0ZS5jaGFuZ2VzLCB0aGlzLmhhc0NvbXBvc2l0aW9uKSAmJiAhdXBkYXRlLnNlbGVjdGlvblNldClcbiAgICAgICAgICAgICAgICByZWFkQ29tcG9zaXRpb25BdCA9IHVwZGF0ZS5zdGF0ZS5zZWxlY3Rpb24ubWFpbi5oZWFkO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjb21wb3NpdGlvbiA9IHJlYWRDb21wb3NpdGlvbkF0ID4gLTEgPyBmaW5kQ29tcG9zaXRpb25SYW5nZSh0aGlzLnZpZXcsIHVwZGF0ZS5jaGFuZ2VzLCByZWFkQ29tcG9zaXRpb25BdCkgOiBudWxsO1xuICAgICAgICB0aGlzLmRvbUNoYW5nZWQgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5oYXNDb21wb3NpdGlvbikge1xuICAgICAgICAgICAgdGhpcy5tYXJrZWRGb3JDb21wb3NpdGlvbi5jbGVhcigpO1xuICAgICAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IHRoaXMuaGFzQ29tcG9zaXRpb247XG4gICAgICAgICAgICBjaGFuZ2VkUmFuZ2VzID0gbmV3IENoYW5nZWRSYW5nZShmcm9tLCB0bywgdXBkYXRlLmNoYW5nZXMubWFwUG9zKGZyb20sIC0xKSwgdXBkYXRlLmNoYW5nZXMubWFwUG9zKHRvLCAxKSlcbiAgICAgICAgICAgICAgICAuYWRkVG9TZXQoY2hhbmdlZFJhbmdlcy5zbGljZSgpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhhc0NvbXBvc2l0aW9uID0gY29tcG9zaXRpb24gPyB7IGZyb206IGNvbXBvc2l0aW9uLnJhbmdlLmZyb21CLCB0bzogY29tcG9zaXRpb24ucmFuZ2UudG9CIH0gOiBudWxsO1xuICAgICAgICAvLyBXaGVuIHRoZSBET00gbm9kZXMgYXJvdW5kIHRoZSBzZWxlY3Rpb24gYXJlIG1vdmVkIHRvIGFub3RoZXJcbiAgICAgICAgLy8gcGFyZW50LCBDaHJvbWUgc29tZXRpbWVzIHJlcG9ydHMgYSBkaWZmZXJlbnQgc2VsZWN0aW9uIHRocm91Z2hcbiAgICAgICAgLy8gZ2V0U2VsZWN0aW9uIHRoYW4gdGhlIG9uZSB0aGF0IGl0IGFjdHVhbGx5IHNob3dzIHRvIHRoZSB1c2VyLlxuICAgICAgICAvLyBUaGlzIGZvcmNlcyBhIHNlbGVjdGlvbiB1cGRhdGUgd2hlbiBsaW5lcyBhcmUgam9pbmVkIHRvIHdvcmtcbiAgICAgICAgLy8gYXJvdW5kIHRoYXQuIElzc3VlICM1NFxuICAgICAgICBpZiAoKGJyb3dzZXIuaWUgfHwgYnJvd3Nlci5jaHJvbWUpICYmICFjb21wb3NpdGlvbiAmJiB1cGRhdGUgJiZcbiAgICAgICAgICAgIHVwZGF0ZS5zdGF0ZS5kb2MubGluZXMgIT0gdXBkYXRlLnN0YXJ0U3RhdGUuZG9jLmxpbmVzKVxuICAgICAgICAgICAgdGhpcy5mb3JjZVNlbGVjdGlvbiA9IHRydWU7XG4gICAgICAgIGxldCBwcmV2RGVjbyA9IHRoaXMuZGVjb3JhdGlvbnMsIGRlY28gPSB0aGlzLnVwZGF0ZURlY28oKTtcbiAgICAgICAgbGV0IGRlY29EaWZmID0gZmluZENoYW5nZWREZWNvKHByZXZEZWNvLCBkZWNvLCB1cGRhdGUuY2hhbmdlcyk7XG4gICAgICAgIGNoYW5nZWRSYW5nZXMgPSBDaGFuZ2VkUmFuZ2UuZXh0ZW5kV2l0aFJhbmdlcyhjaGFuZ2VkUmFuZ2VzLCBkZWNvRGlmZik7XG4gICAgICAgIGlmICghKHRoaXMuZmxhZ3MgJiA3IC8qIFZpZXdGbGFnLkRpcnR5ICovKSAmJiBjaGFuZ2VkUmFuZ2VzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUlubmVyKGNoYW5nZWRSYW5nZXMsIHVwZGF0ZS5zdGFydFN0YXRlLmRvYy5sZW5ndGgsIGNvbXBvc2l0aW9uKTtcbiAgICAgICAgICAgIGlmICh1cGRhdGUudHJhbnNhY3Rpb25zLmxlbmd0aClcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RVcGRhdGUgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVXNlZCBieSB1cGRhdGUgYW5kIHRoZSBjb25zdHJ1Y3RvciBkbyBwZXJmb3JtIHRoZSBhY3R1YWwgRE9NXG4gICAgLy8gdXBkYXRlXG4gICAgdXBkYXRlSW5uZXIoY2hhbmdlcywgb2xkTGVuZ3RoLCBjb21wb3NpdGlvbikge1xuICAgICAgICB0aGlzLnZpZXcudmlld1N0YXRlLm11c3RNZWFzdXJlQ29udGVudCA9IHRydWU7XG4gICAgICAgIHRoaXMudXBkYXRlQ2hpbGRyZW4oY2hhbmdlcywgb2xkTGVuZ3RoLCBjb21wb3NpdGlvbik7XG4gICAgICAgIGxldCB7IG9ic2VydmVyIH0gPSB0aGlzLnZpZXc7XG4gICAgICAgIG9ic2VydmVyLmlnbm9yZSgoKSA9PiB7XG4gICAgICAgICAgICAvLyBMb2NrIHRoZSBoZWlnaHQgZHVyaW5nIHJlZHJhd2luZywgc2luY2UgQ2hyb21lIHNvbWV0aW1lc1xuICAgICAgICAgICAgLy8gbWVzc2VzIHdpdGggdGhlIHNjcm9sbCBwb3NpdGlvbiBkdXJpbmcgRE9NIG11dGF0aW9uICh0aG91Z2hcbiAgICAgICAgICAgIC8vIG5vIHJlbGF5b3V0IGlzIHRyaWdnZXJlZCBhbmQgSSBjYW5ub3QgaW1hZ2luZSBob3cgaXQgY2FuXG4gICAgICAgICAgICAvLyByZWNvbXB1dGUgdGhlIHNjcm9sbCBwb3NpdGlvbiB3aXRob3V0IGEgbGF5b3V0KVxuICAgICAgICAgICAgdGhpcy5kb20uc3R5bGUuaGVpZ2h0ID0gdGhpcy52aWV3LnZpZXdTdGF0ZS5jb250ZW50SGVpZ2h0IC8gdGhpcy52aWV3LnNjYWxlWSArIFwicHhcIjtcbiAgICAgICAgICAgIHRoaXMuZG9tLnN0eWxlLmZsZXhCYXNpcyA9IHRoaXMubWluV2lkdGggPyB0aGlzLm1pbldpZHRoICsgXCJweFwiIDogXCJcIjtcbiAgICAgICAgICAgIC8vIENocm9tZSB3aWxsIHNvbWV0aW1lcywgd2hlbiBET00gbXV0YXRpb25zIG9jY3VyIGRpcmVjdGx5XG4gICAgICAgICAgICAvLyBhcm91bmQgdGhlIHNlbGVjdGlvbiwgZ2V0IGNvbmZ1c2VkIGFuZCByZXBvcnQgYSBkaWZmZXJlbnRcbiAgICAgICAgICAgIC8vIHNlbGVjdGlvbiBmcm9tIHRoZSBvbmUgaXQgZGlzcGxheXMgKGlzc3VlICMyMTgpLiBUaGlzIHRyaWVzXG4gICAgICAgICAgICAvLyB0byBkZXRlY3QgdGhhdCBzaXR1YXRpb24uXG4gICAgICAgICAgICBsZXQgdHJhY2sgPSBicm93c2VyLmNocm9tZSB8fCBicm93c2VyLmlvcyA/IHsgbm9kZTogb2JzZXJ2ZXIuc2VsZWN0aW9uUmFuZ2UuZm9jdXNOb2RlLCB3cml0dGVuOiBmYWxzZSB9IDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5zeW5jKHRoaXMudmlldywgdHJhY2spO1xuICAgICAgICAgICAgdGhpcy5mbGFncyAmPSB+NyAvKiBWaWV3RmxhZy5EaXJ0eSAqLztcbiAgICAgICAgICAgIGlmICh0cmFjayAmJiAodHJhY2sud3JpdHRlbiB8fCBvYnNlcnZlci5zZWxlY3Rpb25SYW5nZS5mb2N1c05vZGUgIT0gdHJhY2subm9kZSkpXG4gICAgICAgICAgICAgICAgdGhpcy5mb3JjZVNlbGVjdGlvbiA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmRvbS5zdHlsZS5oZWlnaHQgPSBcIlwiO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tYXJrZWRGb3JDb21wb3NpdGlvbi5mb3JFYWNoKGNWaWV3ID0+IGNWaWV3LmZsYWdzICY9IH44IC8qIFZpZXdGbGFnLkNvbXBvc2l0aW9uICovKTtcbiAgICAgICAgbGV0IGdhcHMgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMudmlldy52aWV3cG9ydC5mcm9tIHx8IHRoaXMudmlldy52aWV3cG9ydC50byA8IHRoaXMudmlldy5zdGF0ZS5kb2MubGVuZ3RoKVxuICAgICAgICAgICAgZm9yIChsZXQgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbilcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBCbG9ja1dpZGdldFZpZXcgJiYgY2hpbGQud2lkZ2V0IGluc3RhbmNlb2YgQmxvY2tHYXBXaWRnZXQpXG4gICAgICAgICAgICAgICAgICAgIGdhcHMucHVzaChjaGlsZC5kb20pO1xuICAgICAgICBvYnNlcnZlci51cGRhdGVHYXBzKGdhcHMpO1xuICAgIH1cbiAgICB1cGRhdGVDaGlsZHJlbihjaGFuZ2VzLCBvbGRMZW5ndGgsIGNvbXBvc2l0aW9uKSB7XG4gICAgICAgIGxldCByYW5nZXMgPSBjb21wb3NpdGlvbiA/IGNvbXBvc2l0aW9uLnJhbmdlLmFkZFRvU2V0KGNoYW5nZXMuc2xpY2UoKSkgOiBjaGFuZ2VzO1xuICAgICAgICBsZXQgY3Vyc29yID0gdGhpcy5jaGlsZEN1cnNvcihvbGRMZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpID0gcmFuZ2VzLmxlbmd0aCAtIDE7OyBpLS0pIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gaSA+PSAwID8gcmFuZ2VzW2ldIDogbnVsbDtcbiAgICAgICAgICAgIGlmICghbmV4dClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGxldCB7IGZyb21BLCB0b0EsIGZyb21CLCB0b0IgfSA9IG5leHQsIGNvbnRlbnQsIGJyZWFrQXRTdGFydCwgb3BlblN0YXJ0LCBvcGVuRW5kO1xuICAgICAgICAgICAgaWYgKGNvbXBvc2l0aW9uICYmIGNvbXBvc2l0aW9uLnJhbmdlLmZyb21CIDwgdG9CICYmIGNvbXBvc2l0aW9uLnJhbmdlLnRvQiA+IGZyb21CKSB7XG4gICAgICAgICAgICAgICAgbGV0IGJlZm9yZSA9IENvbnRlbnRCdWlsZGVyLmJ1aWxkKHRoaXMudmlldy5zdGF0ZS5kb2MsIGZyb21CLCBjb21wb3NpdGlvbi5yYW5nZS5mcm9tQiwgdGhpcy5kZWNvcmF0aW9ucywgdGhpcy5keW5hbWljRGVjb3JhdGlvbk1hcCk7XG4gICAgICAgICAgICAgICAgbGV0IGFmdGVyID0gQ29udGVudEJ1aWxkZXIuYnVpbGQodGhpcy52aWV3LnN0YXRlLmRvYywgY29tcG9zaXRpb24ucmFuZ2UudG9CLCB0b0IsIHRoaXMuZGVjb3JhdGlvbnMsIHRoaXMuZHluYW1pY0RlY29yYXRpb25NYXApO1xuICAgICAgICAgICAgICAgIGJyZWFrQXRTdGFydCA9IGJlZm9yZS5icmVha0F0U3RhcnQ7XG4gICAgICAgICAgICAgICAgb3BlblN0YXJ0ID0gYmVmb3JlLm9wZW5TdGFydDtcbiAgICAgICAgICAgICAgICBvcGVuRW5kID0gYWZ0ZXIub3BlbkVuZDtcbiAgICAgICAgICAgICAgICBsZXQgY29tcExpbmUgPSB0aGlzLmNvbXBvc2l0aW9uVmlldyhjb21wb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgaWYgKGFmdGVyLmJyZWFrQXRTdGFydCkge1xuICAgICAgICAgICAgICAgICAgICBjb21wTGluZS5icmVha0FmdGVyID0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYWZ0ZXIuY29udGVudC5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgICAgY29tcExpbmUubWVyZ2UoY29tcExpbmUubGVuZ3RoLCBjb21wTGluZS5sZW5ndGgsIGFmdGVyLmNvbnRlbnRbMF0sIGZhbHNlLCBhZnRlci5vcGVuU3RhcnQsIDApKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBMaW5lLmJyZWFrQWZ0ZXIgPSBhZnRlci5jb250ZW50WzBdLmJyZWFrQWZ0ZXI7XG4gICAgICAgICAgICAgICAgICAgIGFmdGVyLmNvbnRlbnQuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGJlZm9yZS5jb250ZW50Lmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICAgICBjb21wTGluZS5tZXJnZSgwLCAwLCBiZWZvcmUuY29udGVudFtiZWZvcmUuY29udGVudC5sZW5ndGggLSAxXSwgdHJ1ZSwgMCwgYmVmb3JlLm9wZW5FbmQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJlZm9yZS5jb250ZW50LnBvcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250ZW50ID0gYmVmb3JlLmNvbnRlbnQuY29uY2F0KGNvbXBMaW5lKS5jb25jYXQoYWZ0ZXIuY29udGVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAoeyBjb250ZW50LCBicmVha0F0U3RhcnQsIG9wZW5TdGFydCwgb3BlbkVuZCB9ID1cbiAgICAgICAgICAgICAgICAgICAgQ29udGVudEJ1aWxkZXIuYnVpbGQodGhpcy52aWV3LnN0YXRlLmRvYywgZnJvbUIsIHRvQiwgdGhpcy5kZWNvcmF0aW9ucywgdGhpcy5keW5hbWljRGVjb3JhdGlvbk1hcCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHsgaTogdG9JLCBvZmY6IHRvT2ZmIH0gPSBjdXJzb3IuZmluZFBvcyh0b0EsIDEpO1xuICAgICAgICAgICAgbGV0IHsgaTogZnJvbUksIG9mZjogZnJvbU9mZiB9ID0gY3Vyc29yLmZpbmRQb3MoZnJvbUEsIC0xKTtcbiAgICAgICAgICAgIHJlcGxhY2VSYW5nZSh0aGlzLCBmcm9tSSwgZnJvbU9mZiwgdG9JLCB0b09mZiwgY29udGVudCwgYnJlYWtBdFN0YXJ0LCBvcGVuU3RhcnQsIG9wZW5FbmQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb21wb3NpdGlvbilcbiAgICAgICAgICAgIHRoaXMuZml4Q29tcG9zaXRpb25ET00oY29tcG9zaXRpb24pO1xuICAgIH1cbiAgICBjb21wb3NpdGlvblZpZXcoY29tcG9zaXRpb24pIHtcbiAgICAgICAgbGV0IGN1ciA9IG5ldyBUZXh0Vmlldyhjb21wb3NpdGlvbi50ZXh0Lm5vZGVWYWx1ZSk7XG4gICAgICAgIGN1ci5mbGFncyB8PSA4IC8qIFZpZXdGbGFnLkNvbXBvc2l0aW9uICovO1xuICAgICAgICBmb3IgKGxldCB7IGRlY28gfSBvZiBjb21wb3NpdGlvbi5tYXJrcylcbiAgICAgICAgICAgIGN1ciA9IG5ldyBNYXJrVmlldyhkZWNvLCBbY3VyXSwgY3VyLmxlbmd0aCk7XG4gICAgICAgIGxldCBsaW5lID0gbmV3IExpbmVWaWV3O1xuICAgICAgICBsaW5lLmFwcGVuZChjdXIsIDApO1xuICAgICAgICByZXR1cm4gbGluZTtcbiAgICB9XG4gICAgZml4Q29tcG9zaXRpb25ET00oY29tcG9zaXRpb24pIHtcbiAgICAgICAgbGV0IGZpeCA9IChkb20sIGNWaWV3KSA9PiB7XG4gICAgICAgICAgICBjVmlldy5mbGFncyB8PSA4IC8qIFZpZXdGbGFnLkNvbXBvc2l0aW9uICovIHwgKGNWaWV3LmNoaWxkcmVuLnNvbWUoYyA9PiBjLmZsYWdzICYgNyAvKiBWaWV3RmxhZy5EaXJ0eSAqLykgPyAxIC8qIFZpZXdGbGFnLkNoaWxkRGlydHkgKi8gOiAwKTtcbiAgICAgICAgICAgIHRoaXMubWFya2VkRm9yQ29tcG9zaXRpb24uYWRkKGNWaWV3KTtcbiAgICAgICAgICAgIGxldCBwcmV2ID0gQ29udGVudFZpZXcuZ2V0KGRvbSk7XG4gICAgICAgICAgICBpZiAocHJldiAmJiBwcmV2ICE9IGNWaWV3KVxuICAgICAgICAgICAgICAgIHByZXYuZG9tID0gbnVsbDtcbiAgICAgICAgICAgIGNWaWV3LnNldERPTShkb20pO1xuICAgICAgICB9O1xuICAgICAgICBsZXQgcG9zID0gdGhpcy5jaGlsZFBvcyhjb21wb3NpdGlvbi5yYW5nZS5mcm9tQiwgMSk7XG4gICAgICAgIGxldCBjVmlldyA9IHRoaXMuY2hpbGRyZW5bcG9zLmldO1xuICAgICAgICBmaXgoY29tcG9zaXRpb24ubGluZSwgY1ZpZXcpO1xuICAgICAgICBmb3IgKGxldCBpID0gY29tcG9zaXRpb24ubWFya3MubGVuZ3RoIC0gMTsgaSA+PSAtMTsgaS0tKSB7XG4gICAgICAgICAgICBwb3MgPSBjVmlldy5jaGlsZFBvcyhwb3Mub2ZmLCAxKTtcbiAgICAgICAgICAgIGNWaWV3ID0gY1ZpZXcuY2hpbGRyZW5bcG9zLmldO1xuICAgICAgICAgICAgZml4KGkgPj0gMCA/IGNvbXBvc2l0aW9uLm1hcmtzW2ldLm5vZGUgOiBjb21wb3NpdGlvbi50ZXh0LCBjVmlldyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gU3luYyB0aGUgRE9NIHNlbGVjdGlvbiB0byB0aGlzLnN0YXRlLnNlbGVjdGlvblxuICAgIHVwZGF0ZVNlbGVjdGlvbihtdXN0UmVhZCA9IGZhbHNlLCBmcm9tUG9pbnRlciA9IGZhbHNlKSB7XG4gICAgICAgIGlmIChtdXN0UmVhZCB8fCAhdGhpcy52aWV3Lm9ic2VydmVyLnNlbGVjdGlvblJhbmdlLmZvY3VzTm9kZSlcbiAgICAgICAgICAgIHRoaXMudmlldy5vYnNlcnZlci5yZWFkU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICAgICAgbGV0IGFjdGl2ZUVsdCA9IHRoaXMudmlldy5yb290LmFjdGl2ZUVsZW1lbnQsIGZvY3VzZWQgPSBhY3RpdmVFbHQgPT0gdGhpcy5kb207XG4gICAgICAgIGxldCBzZWxlY3Rpb25Ob3RGb2N1cyA9ICFmb2N1c2VkICYmXG4gICAgICAgICAgICBoYXNTZWxlY3Rpb24odGhpcy5kb20sIHRoaXMudmlldy5vYnNlcnZlci5zZWxlY3Rpb25SYW5nZSkgJiYgIShhY3RpdmVFbHQgJiYgdGhpcy5kb20uY29udGFpbnMoYWN0aXZlRWx0KSk7XG4gICAgICAgIGlmICghKGZvY3VzZWQgfHwgZnJvbVBvaW50ZXIgfHwgc2VsZWN0aW9uTm90Rm9jdXMpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgZm9yY2UgPSB0aGlzLmZvcmNlU2VsZWN0aW9uO1xuICAgICAgICB0aGlzLmZvcmNlU2VsZWN0aW9uID0gZmFsc2U7XG4gICAgICAgIGxldCBtYWluID0gdGhpcy52aWV3LnN0YXRlLnNlbGVjdGlvbi5tYWluO1xuICAgICAgICBsZXQgYW5jaG9yID0gdGhpcy5tb3ZlVG9MaW5lKHRoaXMuZG9tQXRQb3MobWFpbi5hbmNob3IpKTtcbiAgICAgICAgbGV0IGhlYWQgPSBtYWluLmVtcHR5ID8gYW5jaG9yIDogdGhpcy5tb3ZlVG9MaW5lKHRoaXMuZG9tQXRQb3MobWFpbi5oZWFkKSk7XG4gICAgICAgIC8vIEFsd2F5cyByZXNldCBvbiBGaXJlZm94IHdoZW4gbmV4dCB0byBhbiB1bmVkaXRhYmxlIG5vZGUgdG9cbiAgICAgICAgLy8gYXZvaWQgaW52aXNpYmxlIGN1cnNvciBidWdzICgjMTExKVxuICAgICAgICBpZiAoYnJvd3Nlci5nZWNrbyAmJiBtYWluLmVtcHR5ICYmICF0aGlzLmhhc0NvbXBvc2l0aW9uICYmIGJldHdlZW5VbmVkaXRhYmxlKGFuY2hvcikpIHtcbiAgICAgICAgICAgIGxldCBkdW1teSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXCIpO1xuICAgICAgICAgICAgdGhpcy52aWV3Lm9ic2VydmVyLmlnbm9yZSgoKSA9PiBhbmNob3Iubm9kZS5pbnNlcnRCZWZvcmUoZHVtbXksIGFuY2hvci5ub2RlLmNoaWxkTm9kZXNbYW5jaG9yLm9mZnNldF0gfHwgbnVsbCkpO1xuICAgICAgICAgICAgYW5jaG9yID0gaGVhZCA9IG5ldyBET01Qb3MoZHVtbXksIDApO1xuICAgICAgICAgICAgZm9yY2UgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkb21TZWwgPSB0aGlzLnZpZXcub2JzZXJ2ZXIuc2VsZWN0aW9uUmFuZ2U7XG4gICAgICAgIC8vIElmIHRoZSBzZWxlY3Rpb24gaXMgYWxyZWFkeSBoZXJlLCBvciBpbiBhbiBlcXVpdmFsZW50IHBvc2l0aW9uLCBkb24ndCB0b3VjaCBpdFxuICAgICAgICBpZiAoZm9yY2UgfHwgIWRvbVNlbC5mb2N1c05vZGUgfHxcbiAgICAgICAgICAgICFpc0VxdWl2YWxlbnRQb3NpdGlvbihhbmNob3Iubm9kZSwgYW5jaG9yLm9mZnNldCwgZG9tU2VsLmFuY2hvck5vZGUsIGRvbVNlbC5hbmNob3JPZmZzZXQpIHx8XG4gICAgICAgICAgICAhaXNFcXVpdmFsZW50UG9zaXRpb24oaGVhZC5ub2RlLCBoZWFkLm9mZnNldCwgZG9tU2VsLmZvY3VzTm9kZSwgZG9tU2VsLmZvY3VzT2Zmc2V0KSkge1xuICAgICAgICAgICAgdGhpcy52aWV3Lm9ic2VydmVyLmlnbm9yZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gQ2hyb21lIEFuZHJvaWQgd2lsbCBoaWRlIHRoZSB2aXJ0dWFsIGtleWJvYXJkIHdoZW4gdGFwcGluZ1xuICAgICAgICAgICAgICAgIC8vIGluc2lkZSBhbiB1bmVkaXRhYmxlIG5vZGUsIGFuZCBub3QgYnJpbmcgaXQgYmFjayB3aGVuIHdlXG4gICAgICAgICAgICAgICAgLy8gbW92ZSB0aGUgY3Vyc29yIHRvIGl0cyBwcm9wZXIgcG9zaXRpb24uIFRoaXMgdHJpZXMgdG9cbiAgICAgICAgICAgICAgICAvLyByZXN0b3JlIHRoZSBrZXlib2FyZCBieSBjeWNsaW5nIGZvY3VzLlxuICAgICAgICAgICAgICAgIGlmIChicm93c2VyLmFuZHJvaWQgJiYgYnJvd3Nlci5jaHJvbWUgJiYgdGhpcy5kb20uY29udGFpbnMoZG9tU2VsLmZvY3VzTm9kZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgaW5VbmVkaXRhYmxlKGRvbVNlbC5mb2N1c05vZGUsIHRoaXMuZG9tKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvbS5ibHVyKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9tLmZvY3VzKHsgcHJldmVudFNjcm9sbDogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHJhd1NlbCA9IGdldFNlbGVjdGlvbih0aGlzLnZpZXcucm9vdCk7XG4gICAgICAgICAgICAgICAgaWYgKCFyYXdTZWwpIDtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtYWluLmVtcHR5KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdvcmsgYXJvdW5kIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTE2MTIwNzZcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJyb3dzZXIuZ2Vja28pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBuZXh0VG8gPSBuZXh0VG9VbmVkaXRhYmxlKGFuY2hvci5ub2RlLCBhbmNob3Iub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0VG8gJiYgbmV4dFRvICE9ICgxIC8qIE5leHRUby5CZWZvcmUgKi8gfCAyIC8qIE5leHRUby5BZnRlciAqLykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdGV4dCA9IG5lYXJieVRleHROb2RlKGFuY2hvci5ub2RlLCBhbmNob3Iub2Zmc2V0LCBuZXh0VG8gPT0gMSAvKiBOZXh0VG8uQmVmb3JlICovID8gMSA6IC0xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGV4dClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5jaG9yID0gbmV3IERPTVBvcyh0ZXh0Lm5vZGUsIHRleHQub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByYXdTZWwuY29sbGFwc2UoYW5jaG9yLm5vZGUsIGFuY2hvci5vZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWFpbi5iaWRpTGV2ZWwgIT0gbnVsbCAmJiByYXdTZWwuY2FyZXRCaWRpTGV2ZWwgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhd1NlbC5jYXJldEJpZGlMZXZlbCA9IG1haW4uYmlkaUxldmVsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyYXdTZWwuZXh0ZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNlbGVjdGlvbi5leHRlbmQgY2FuIGJlIHVzZWQgdG8gY3JlYXRlIGFuICdpbnZlcnRlZCcgc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIC8vIChvbmUgd2hlcmUgdGhlIGZvY3VzIGlzIGJlZm9yZSB0aGUgYW5jaG9yKSwgYnV0IG5vdCBhbGxcbiAgICAgICAgICAgICAgICAgICAgLy8gYnJvd3NlcnMgc3VwcG9ydCBpdCB5ZXQuXG4gICAgICAgICAgICAgICAgICAgIHJhd1NlbC5jb2xsYXBzZShhbmNob3Iubm9kZSwgYW5jaG9yLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNhZmFyaSB3aWxsIGlnbm9yZSB0aGUgY2FsbCBhYm92ZSB3aGVuIHRoZSBlZGl0b3IgaXNcbiAgICAgICAgICAgICAgICAgICAgLy8gaGlkZGVuLCBhbmQgdGhlbiByYWlzZSBhbiBlcnJvciBvbiB0aGUgY2FsbCB0byBleHRlbmRcbiAgICAgICAgICAgICAgICAgICAgLy8gKCM5NDApLlxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmF3U2VsLmV4dGVuZChoZWFkLm5vZGUsIGhlYWQub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoXykgeyB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBQcmltaXRpdmUgKElFKSB3YXlcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1haW4uYW5jaG9yID4gbWFpbi5oZWFkKVxuICAgICAgICAgICAgICAgICAgICAgICAgW2FuY2hvciwgaGVhZF0gPSBbaGVhZCwgYW5jaG9yXTtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2Uuc2V0RW5kKGhlYWQubm9kZSwgaGVhZC5vZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICByYW5nZS5zZXRTdGFydChhbmNob3Iubm9kZSwgYW5jaG9yLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIHJhd1NlbC5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgcmF3U2VsLmFkZFJhbmdlKHJhbmdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvbk5vdEZvY3VzICYmIHRoaXMudmlldy5yb290LmFjdGl2ZUVsZW1lbnQgPT0gdGhpcy5kb20pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb20uYmx1cigpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aXZlRWx0KVxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlRWx0LmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnZpZXcub2JzZXJ2ZXIuc2V0U2VsZWN0aW9uUmFuZ2UoYW5jaG9yLCBoZWFkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmltcHJlY2lzZUFuY2hvciA9IGFuY2hvci5wcmVjaXNlID8gbnVsbCA6IG5ldyBET01Qb3MoZG9tU2VsLmFuY2hvck5vZGUsIGRvbVNlbC5hbmNob3JPZmZzZXQpO1xuICAgICAgICB0aGlzLmltcHJlY2lzZUhlYWQgPSBoZWFkLnByZWNpc2UgPyBudWxsIDogbmV3IERPTVBvcyhkb21TZWwuZm9jdXNOb2RlLCBkb21TZWwuZm9jdXNPZmZzZXQpO1xuICAgIH1cbiAgICBlbmZvcmNlQ3Vyc29yQXNzb2MoKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc0NvbXBvc2l0aW9uKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgeyB2aWV3IH0gPSB0aGlzLCBjdXJzb3IgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbi5tYWluO1xuICAgICAgICBsZXQgc2VsID0gZ2V0U2VsZWN0aW9uKHZpZXcucm9vdCk7XG4gICAgICAgIGxldCB7IGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCB9ID0gdmlldy5vYnNlcnZlci5zZWxlY3Rpb25SYW5nZTtcbiAgICAgICAgaWYgKCFzZWwgfHwgIWN1cnNvci5lbXB0eSB8fCAhY3Vyc29yLmFzc29jIHx8ICFzZWwubW9kaWZ5KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgbGluZSA9IExpbmVWaWV3LmZpbmQodGhpcywgY3Vyc29yLmhlYWQpO1xuICAgICAgICBpZiAoIWxpbmUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBsaW5lU3RhcnQgPSBsaW5lLnBvc0F0U3RhcnQ7XG4gICAgICAgIGlmIChjdXJzb3IuaGVhZCA9PSBsaW5lU3RhcnQgfHwgY3Vyc29yLmhlYWQgPT0gbGluZVN0YXJ0ICsgbGluZS5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBiZWZvcmUgPSB0aGlzLmNvb3Jkc0F0KGN1cnNvci5oZWFkLCAtMSksIGFmdGVyID0gdGhpcy5jb29yZHNBdChjdXJzb3IuaGVhZCwgMSk7XG4gICAgICAgIGlmICghYmVmb3JlIHx8ICFhZnRlciB8fCBiZWZvcmUuYm90dG9tID4gYWZ0ZXIudG9wKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgZG9tID0gdGhpcy5kb21BdFBvcyhjdXJzb3IuaGVhZCArIGN1cnNvci5hc3NvYyk7XG4gICAgICAgIHNlbC5jb2xsYXBzZShkb20ubm9kZSwgZG9tLm9mZnNldCk7XG4gICAgICAgIHNlbC5tb2RpZnkoXCJtb3ZlXCIsIGN1cnNvci5hc3NvYyA8IDAgPyBcImZvcndhcmRcIiA6IFwiYmFja3dhcmRcIiwgXCJsaW5lYm91bmRhcnlcIik7XG4gICAgICAgIC8vIFRoaXMgY2FuIGdvIHdyb25nIGluIGNvcm5lciBjYXNlcyBsaWtlIHNpbmdsZS1jaGFyYWN0ZXIgbGluZXMsXG4gICAgICAgIC8vIHNvIGNoZWNrIGFuZCByZXNldCBpZiBuZWNlc3NhcnkuXG4gICAgICAgIHZpZXcub2JzZXJ2ZXIucmVhZFNlbGVjdGlvblJhbmdlKCk7XG4gICAgICAgIGxldCBuZXdSYW5nZSA9IHZpZXcub2JzZXJ2ZXIuc2VsZWN0aW9uUmFuZ2U7XG4gICAgICAgIGlmICh2aWV3LmRvY1ZpZXcucG9zRnJvbURPTShuZXdSYW5nZS5hbmNob3JOb2RlLCBuZXdSYW5nZS5hbmNob3JPZmZzZXQpICE9IGN1cnNvci5mcm9tKVxuICAgICAgICAgICAgc2VsLmNvbGxhcHNlKGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCk7XG4gICAgfVxuICAgIC8vIElmIGEgcG9zaXRpb24gaXMgaW4vbmVhciBhIGJsb2NrIHdpZGdldCwgbW92ZSBpdCB0byBhIG5lYXJieSB0ZXh0XG4gICAgLy8gbGluZSwgc2luY2Ugd2UgZG9uJ3Qgd2FudCB0aGUgY3Vyc29yIGluc2lkZSBhIGJsb2NrIHdpZGdldC5cbiAgICBtb3ZlVG9MaW5lKHBvcykge1xuICAgICAgICAvLyBCbG9jayB3aWRnZXRzIHdpbGwgcmV0dXJuIHBvc2l0aW9ucyBiZWZvcmUvYWZ0ZXIgdGhlbSwgd2hpY2hcbiAgICAgICAgLy8gYXJlIHRodXMgZGlyZWN0bHkgaW4gdGhlIGRvY3VtZW50IERPTSBlbGVtZW50LlxuICAgICAgICBsZXQgZG9tID0gdGhpcy5kb20sIG5ld1BvcztcbiAgICAgICAgaWYgKHBvcy5ub2RlICE9IGRvbSlcbiAgICAgICAgICAgIHJldHVybiBwb3M7XG4gICAgICAgIGZvciAobGV0IGkgPSBwb3Mub2Zmc2V0OyAhbmV3UG9zICYmIGkgPCBkb20uY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHZpZXcgPSBDb250ZW50Vmlldy5nZXQoZG9tLmNoaWxkTm9kZXNbaV0pO1xuICAgICAgICAgICAgaWYgKHZpZXcgaW5zdGFuY2VvZiBMaW5lVmlldylcbiAgICAgICAgICAgICAgICBuZXdQb3MgPSB2aWV3LmRvbUF0UG9zKDApO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSBwb3Mub2Zmc2V0IC0gMTsgIW5ld1BvcyAmJiBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IHZpZXcgPSBDb250ZW50Vmlldy5nZXQoZG9tLmNoaWxkTm9kZXNbaV0pO1xuICAgICAgICAgICAgaWYgKHZpZXcgaW5zdGFuY2VvZiBMaW5lVmlldylcbiAgICAgICAgICAgICAgICBuZXdQb3MgPSB2aWV3LmRvbUF0UG9zKHZpZXcubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3UG9zID8gbmV3IERPTVBvcyhuZXdQb3Mubm9kZSwgbmV3UG9zLm9mZnNldCwgdHJ1ZSkgOiBwb3M7XG4gICAgfVxuICAgIG5lYXJlc3QoZG9tKSB7XG4gICAgICAgIGZvciAobGV0IGN1ciA9IGRvbTsgY3VyOykge1xuICAgICAgICAgICAgbGV0IGRvbVZpZXcgPSBDb250ZW50Vmlldy5nZXQoY3VyKTtcbiAgICAgICAgICAgIGlmIChkb21WaWV3ICYmIGRvbVZpZXcucm9vdFZpZXcgPT0gdGhpcylcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9tVmlldztcbiAgICAgICAgICAgIGN1ciA9IGN1ci5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBwb3NGcm9tRE9NKG5vZGUsIG9mZnNldCkge1xuICAgICAgICBsZXQgdmlldyA9IHRoaXMubmVhcmVzdChub2RlKTtcbiAgICAgICAgaWYgKCF2aWV3KVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUcnlpbmcgdG8gZmluZCBwb3NpdGlvbiBmb3IgYSBET00gcG9zaXRpb24gb3V0c2lkZSBvZiB0aGUgZG9jdW1lbnRcIik7XG4gICAgICAgIHJldHVybiB2aWV3LmxvY2FsUG9zRnJvbURPTShub2RlLCBvZmZzZXQpICsgdmlldy5wb3NBdFN0YXJ0O1xuICAgIH1cbiAgICBkb21BdFBvcyhwb3MpIHtcbiAgICAgICAgbGV0IHsgaSwgb2ZmIH0gPSB0aGlzLmNoaWxkQ3Vyc29yKCkuZmluZFBvcyhwb3MsIC0xKTtcbiAgICAgICAgZm9yICg7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDE7KSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgaWYgKG9mZiA8IGNoaWxkLmxlbmd0aCB8fCBjaGlsZCBpbnN0YW5jZW9mIExpbmVWaWV3KVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgb2ZmID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbltpXS5kb21BdFBvcyhvZmYpO1xuICAgIH1cbiAgICBjb29yZHNBdChwb3MsIHNpZGUpIHtcbiAgICAgICAgbGV0IGJlc3QgPSBudWxsLCBiZXN0UG9zID0gMDtcbiAgICAgICAgZm9yIChsZXQgb2ZmID0gdGhpcy5sZW5ndGgsIGkgPSB0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldLCBlbmQgPSBvZmYgLSBjaGlsZC5icmVha0FmdGVyLCBzdGFydCA9IGVuZCAtIGNoaWxkLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChlbmQgPCBwb3MpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpZiAoc3RhcnQgPD0gcG9zICYmIChzdGFydCA8IHBvcyB8fCBjaGlsZC5jb3ZlcnMoLTEpKSAmJiAoZW5kID4gcG9zIHx8IGNoaWxkLmNvdmVycygxKSkgJiZcbiAgICAgICAgICAgICAgICAoIWJlc3QgfHwgY2hpbGQgaW5zdGFuY2VvZiBMaW5lVmlldyAmJiAhKGJlc3QgaW5zdGFuY2VvZiBMaW5lVmlldyAmJiBzaWRlID49IDApKSkge1xuICAgICAgICAgICAgICAgIGJlc3QgPSBjaGlsZDtcbiAgICAgICAgICAgICAgICBiZXN0UG9zID0gc3RhcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmYgPSBzdGFydDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmVzdCA/IGJlc3QuY29vcmRzQXQocG9zIC0gYmVzdFBvcywgc2lkZSkgOiBudWxsO1xuICAgIH1cbiAgICBjb29yZHNGb3JDaGFyKHBvcykge1xuICAgICAgICBsZXQgeyBpLCBvZmYgfSA9IHRoaXMuY2hpbGRQb3MocG9zLCAxKSwgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgICAgICBpZiAoIShjaGlsZCBpbnN0YW5jZW9mIExpbmVWaWV3KSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB3aGlsZSAoY2hpbGQuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgeyBpLCBvZmY6IGNoaWxkT2ZmIH0gPSBjaGlsZC5jaGlsZFBvcyhvZmYsIDEpO1xuICAgICAgICAgICAgZm9yICg7OyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PSBjaGlsZC5jaGlsZHJlbi5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIGlmICgoY2hpbGQgPSBjaGlsZC5jaGlsZHJlbltpXSkubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9mZiA9IGNoaWxkT2ZmO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKGNoaWxkIGluc3RhbmNlb2YgVGV4dFZpZXcpKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCBlbmQgPSBmaW5kQ2x1c3RlckJyZWFrKGNoaWxkLnRleHQsIG9mZik7XG4gICAgICAgIGlmIChlbmQgPT0gb2ZmKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCByZWN0cyA9IHRleHRSYW5nZShjaGlsZC5kb20sIG9mZiwgZW5kKS5nZXRDbGllbnRSZWN0cygpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcmVjdCA9IHJlY3RzW2ldO1xuICAgICAgICAgICAgaWYgKGkgPT0gcmVjdHMubGVuZ3RoIC0gMSB8fCByZWN0LnRvcCA8IHJlY3QuYm90dG9tICYmIHJlY3QubGVmdCA8IHJlY3QucmlnaHQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIG1lYXN1cmVWaXNpYmxlTGluZUhlaWdodHModmlld3BvcnQpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdLCB7IGZyb20sIHRvIH0gPSB2aWV3cG9ydDtcbiAgICAgICAgbGV0IGNvbnRlbnRXaWR0aCA9IHRoaXMudmlldy5jb250ZW50RE9NLmNsaWVudFdpZHRoO1xuICAgICAgICBsZXQgaXNXaWRlciA9IGNvbnRlbnRXaWR0aCA+IE1hdGgubWF4KHRoaXMudmlldy5zY3JvbGxET00uY2xpZW50V2lkdGgsIHRoaXMubWluV2lkdGgpICsgMTtcbiAgICAgICAgbGV0IHdpZGVzdCA9IC0xLCBsdHIgPSB0aGlzLnZpZXcudGV4dERpcmVjdGlvbiA9PSBEaXJlY3Rpb24uTFRSO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSAwLCBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sIGVuZCA9IHBvcyArIGNoaWxkLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChlbmQgPiB0bylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGlmIChwb3MgPj0gZnJvbSkge1xuICAgICAgICAgICAgICAgIGxldCBjaGlsZFJlY3QgPSBjaGlsZC5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goY2hpbGRSZWN0LmhlaWdodCk7XG4gICAgICAgICAgICAgICAgaWYgKGlzV2lkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxhc3QgPSBjaGlsZC5kb20ubGFzdENoaWxkO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmVjdHMgPSBsYXN0ID8gY2xpZW50UmVjdHNGb3IobGFzdCkgOiBbXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlY3RzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlY3QgPSByZWN0c1tyZWN0cy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB3aWR0aCA9IGx0ciA/IHJlY3QucmlnaHQgLSBjaGlsZFJlY3QubGVmdCA6IGNoaWxkUmVjdC5yaWdodCAtIHJlY3QubGVmdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3aWR0aCA+IHdpZGVzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZGVzdCA9IHdpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWluV2lkdGggPSBjb250ZW50V2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5taW5XaWR0aEZyb20gPSBwb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5taW5XaWR0aFRvID0gZW5kO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zID0gZW5kICsgY2hpbGQuYnJlYWtBZnRlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICB0ZXh0RGlyZWN0aW9uQXQocG9zKSB7XG4gICAgICAgIGxldCB7IGkgfSA9IHRoaXMuY2hpbGRQb3MocG9zLCAxKTtcbiAgICAgICAgcmV0dXJuIGdldENvbXB1dGVkU3R5bGUodGhpcy5jaGlsZHJlbltpXS5kb20pLmRpcmVjdGlvbiA9PSBcInJ0bFwiID8gRGlyZWN0aW9uLlJUTCA6IERpcmVjdGlvbi5MVFI7XG4gICAgfVxuICAgIG1lYXN1cmVUZXh0U2l6ZSgpIHtcbiAgICAgICAgZm9yIChsZXQgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbikge1xuICAgICAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgTGluZVZpZXcpIHtcbiAgICAgICAgICAgICAgICBsZXQgbWVhc3VyZSA9IGNoaWxkLm1lYXN1cmVUZXh0U2l6ZSgpO1xuICAgICAgICAgICAgICAgIGlmIChtZWFzdXJlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWVhc3VyZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBubyB3b3JrYWJsZSBsaW5lIGV4aXN0cywgZm9yY2UgYSBsYXlvdXQgb2YgYSBtZWFzdXJhYmxlIGVsZW1lbnRcbiAgICAgICAgbGV0IGR1bW15ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSwgbGluZUhlaWdodCwgY2hhcldpZHRoLCB0ZXh0SGVpZ2h0O1xuICAgICAgICBkdW1teS5jbGFzc05hbWUgPSBcImNtLWxpbmVcIjtcbiAgICAgICAgZHVtbXkuc3R5bGUud2lkdGggPSBcIjk5OTk5cHhcIjtcbiAgICAgICAgZHVtbXkuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgICAgIGR1bW15LnRleHRDb250ZW50ID0gXCJhYmMgZGVmIGdoaSBqa2wgbW5vIHBxciBzdHVcIjtcbiAgICAgICAgdGhpcy52aWV3Lm9ic2VydmVyLmlnbm9yZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmRvbS5hcHBlbmRDaGlsZChkdW1teSk7XG4gICAgICAgICAgICBsZXQgcmVjdCA9IGNsaWVudFJlY3RzRm9yKGR1bW15LmZpcnN0Q2hpbGQpWzBdO1xuICAgICAgICAgICAgbGluZUhlaWdodCA9IGR1bW15LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtcbiAgICAgICAgICAgIGNoYXJXaWR0aCA9IHJlY3QgPyByZWN0LndpZHRoIC8gMjcgOiA3O1xuICAgICAgICAgICAgdGV4dEhlaWdodCA9IHJlY3QgPyByZWN0LmhlaWdodCA6IGxpbmVIZWlnaHQ7XG4gICAgICAgICAgICBkdW1teS5yZW1vdmUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7IGxpbmVIZWlnaHQsIGNoYXJXaWR0aCwgdGV4dEhlaWdodCB9O1xuICAgIH1cbiAgICBjaGlsZEN1cnNvcihwb3MgPSB0aGlzLmxlbmd0aCkge1xuICAgICAgICAvLyBNb3ZlIGJhY2sgdG8gc3RhcnQgb2YgbGFzdCBlbGVtZW50IHdoZW4gcG9zc2libGUsIHNvIHRoYXRcbiAgICAgICAgLy8gYENoaWxkQ3Vyc29yLmZpbmRQb3NgIGRvZXNuJ3QgaGF2ZSB0byBkZWFsIHdpdGggdGhlIGVkZ2UgY2FzZVxuICAgICAgICAvLyBvZiBiZWluZyBhZnRlciB0aGUgbGFzdCBlbGVtZW50LlxuICAgICAgICBsZXQgaSA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICBpZiAoaSlcbiAgICAgICAgICAgIHBvcyAtPSB0aGlzLmNoaWxkcmVuWy0taV0ubGVuZ3RoO1xuICAgICAgICByZXR1cm4gbmV3IENoaWxkQ3Vyc29yKHRoaXMuY2hpbGRyZW4sIHBvcywgaSk7XG4gICAgfVxuICAgIGNvbXB1dGVCbG9ja0dhcERlY28oKSB7XG4gICAgICAgIGxldCBkZWNvID0gW10sIHZzID0gdGhpcy52aWV3LnZpZXdTdGF0ZTtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMCwgaSA9IDA7OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gaSA9PSB2cy52aWV3cG9ydHMubGVuZ3RoID8gbnVsbCA6IHZzLnZpZXdwb3J0c1tpXTtcbiAgICAgICAgICAgIGxldCBlbmQgPSBuZXh0ID8gbmV4dC5mcm9tIC0gMSA6IHRoaXMubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGVuZCA+IHBvcykge1xuICAgICAgICAgICAgICAgIGxldCBoZWlnaHQgPSAodnMubGluZUJsb2NrQXQoZW5kKS5ib3R0b20gLSB2cy5saW5lQmxvY2tBdChwb3MpLnRvcCkgLyB0aGlzLnZpZXcuc2NhbGVZO1xuICAgICAgICAgICAgICAgIGRlY28ucHVzaChEZWNvcmF0aW9uLnJlcGxhY2Uoe1xuICAgICAgICAgICAgICAgICAgICB3aWRnZXQ6IG5ldyBCbG9ja0dhcFdpZGdldChoZWlnaHQpLFxuICAgICAgICAgICAgICAgICAgICBibG9jazogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBpc0Jsb2NrR2FwOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0pLnJhbmdlKHBvcywgZW5kKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW5leHQpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBwb3MgPSBuZXh0LnRvICsgMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5zZXQoZGVjbyk7XG4gICAgfVxuICAgIHVwZGF0ZURlY28oKSB7XG4gICAgICAgIGxldCBhbGxEZWNvID0gdGhpcy52aWV3LnN0YXRlLmZhY2V0KGRlY29yYXRpb25zKS5tYXAoKGQsIGkpID0+IHtcbiAgICAgICAgICAgIGxldCBkeW5hbWljID0gdGhpcy5keW5hbWljRGVjb3JhdGlvbk1hcFtpXSA9IHR5cGVvZiBkID09IFwiZnVuY3Rpb25cIjtcbiAgICAgICAgICAgIHJldHVybiBkeW5hbWljID8gZCh0aGlzLnZpZXcpIDogZDtcbiAgICAgICAgfSk7XG4gICAgICAgIGZvciAobGV0IGkgPSBhbGxEZWNvLmxlbmd0aDsgaSA8IGFsbERlY28ubGVuZ3RoICsgMzsgaSsrKVxuICAgICAgICAgICAgdGhpcy5keW5hbWljRGVjb3JhdGlvbk1hcFtpXSA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcy5kZWNvcmF0aW9ucyA9IFtcbiAgICAgICAgICAgIC4uLmFsbERlY28sXG4gICAgICAgICAgICB0aGlzLmNvbXB1dGVCbG9ja0dhcERlY28oKSxcbiAgICAgICAgICAgIHRoaXMudmlldy52aWV3U3RhdGUubGluZUdhcERlY29cbiAgICAgICAgXTtcbiAgICB9XG4gICAgc2Nyb2xsSW50b1ZpZXcodGFyZ2V0KSB7XG4gICAgICAgIGlmICh0YXJnZXQuaXNTbmFwc2hvdCkge1xuICAgICAgICAgICAgbGV0IHJlZiA9IHRoaXMudmlldy52aWV3U3RhdGUubGluZUJsb2NrQXQodGFyZ2V0LnJhbmdlLmhlYWQpO1xuICAgICAgICAgICAgdGhpcy52aWV3LnNjcm9sbERPTS5zY3JvbGxUb3AgPSByZWYudG9wIC0gdGFyZ2V0LnlNYXJnaW47XG4gICAgICAgICAgICB0aGlzLnZpZXcuc2Nyb2xsRE9NLnNjcm9sbExlZnQgPSB0YXJnZXQueE1hcmdpbjtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgeyByYW5nZSB9ID0gdGFyZ2V0O1xuICAgICAgICBsZXQgcmVjdCA9IHRoaXMuY29vcmRzQXQocmFuZ2UuaGVhZCwgcmFuZ2UuZW1wdHkgPyByYW5nZS5hc3NvYyA6IHJhbmdlLmhlYWQgPiByYW5nZS5hbmNob3IgPyAtMSA6IDEpLCBvdGhlcjtcbiAgICAgICAgaWYgKCFyZWN0KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoIXJhbmdlLmVtcHR5ICYmIChvdGhlciA9IHRoaXMuY29vcmRzQXQocmFuZ2UuYW5jaG9yLCByYW5nZS5hbmNob3IgPiByYW5nZS5oZWFkID8gLTEgOiAxKSkpXG4gICAgICAgICAgICByZWN0ID0geyBsZWZ0OiBNYXRoLm1pbihyZWN0LmxlZnQsIG90aGVyLmxlZnQpLCB0b3A6IE1hdGgubWluKHJlY3QudG9wLCBvdGhlci50b3ApLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiBNYXRoLm1heChyZWN0LnJpZ2h0LCBvdGhlci5yaWdodCksIGJvdHRvbTogTWF0aC5tYXgocmVjdC5ib3R0b20sIG90aGVyLmJvdHRvbSkgfTtcbiAgICAgICAgbGV0IG1hcmdpbnMgPSBnZXRTY3JvbGxNYXJnaW5zKHRoaXMudmlldyk7XG4gICAgICAgIGxldCB0YXJnZXRSZWN0ID0ge1xuICAgICAgICAgICAgbGVmdDogcmVjdC5sZWZ0IC0gbWFyZ2lucy5sZWZ0LCB0b3A6IHJlY3QudG9wIC0gbWFyZ2lucy50b3AsXG4gICAgICAgICAgICByaWdodDogcmVjdC5yaWdodCArIG1hcmdpbnMucmlnaHQsIGJvdHRvbTogcmVjdC5ib3R0b20gKyBtYXJnaW5zLmJvdHRvbVxuICAgICAgICB9O1xuICAgICAgICBsZXQgeyBvZmZzZXRXaWR0aCwgb2Zmc2V0SGVpZ2h0IH0gPSB0aGlzLnZpZXcuc2Nyb2xsRE9NO1xuICAgICAgICBzY3JvbGxSZWN0SW50b1ZpZXcodGhpcy52aWV3LnNjcm9sbERPTSwgdGFyZ2V0UmVjdCwgcmFuZ2UuaGVhZCA8IHJhbmdlLmFuY2hvciA/IC0xIDogMSwgdGFyZ2V0LngsIHRhcmdldC55LCBNYXRoLm1heChNYXRoLm1pbih0YXJnZXQueE1hcmdpbiwgb2Zmc2V0V2lkdGgpLCAtb2Zmc2V0V2lkdGgpLCBNYXRoLm1heChNYXRoLm1pbih0YXJnZXQueU1hcmdpbiwgb2Zmc2V0SGVpZ2h0KSwgLW9mZnNldEhlaWdodCksIHRoaXMudmlldy50ZXh0RGlyZWN0aW9uID09IERpcmVjdGlvbi5MVFIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGJldHdlZW5VbmVkaXRhYmxlKHBvcykge1xuICAgIHJldHVybiBwb3Mubm9kZS5ub2RlVHlwZSA9PSAxICYmIHBvcy5ub2RlLmZpcnN0Q2hpbGQgJiZcbiAgICAgICAgKHBvcy5vZmZzZXQgPT0gMCB8fCBwb3Mubm9kZS5jaGlsZE5vZGVzW3Bvcy5vZmZzZXQgLSAxXS5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKSAmJlxuICAgICAgICAocG9zLm9mZnNldCA9PSBwb3Mubm9kZS5jaGlsZE5vZGVzLmxlbmd0aCB8fCBwb3Mubm9kZS5jaGlsZE5vZGVzW3Bvcy5vZmZzZXRdLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpO1xufVxuY2xhc3MgQmxvY2tHYXBXaWRnZXQgZXh0ZW5kcyBXaWRnZXRUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcihoZWlnaHQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgfVxuICAgIHRvRE9NKCkge1xuICAgICAgICBsZXQgZWx0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy51cGRhdGVET00oZWx0KTtcbiAgICAgICAgcmV0dXJuIGVsdDtcbiAgICB9XG4gICAgZXEob3RoZXIpIHsgcmV0dXJuIG90aGVyLmhlaWdodCA9PSB0aGlzLmhlaWdodDsgfVxuICAgIHVwZGF0ZURPTShlbHQpIHtcbiAgICAgICAgZWx0LnN0eWxlLmhlaWdodCA9IHRoaXMuaGVpZ2h0ICsgXCJweFwiO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZ2V0IGVzdGltYXRlZEhlaWdodCgpIHsgcmV0dXJuIHRoaXMuaGVpZ2h0OyB9XG59XG5mdW5jdGlvbiBmaW5kQ29tcG9zaXRpb25Ob2RlKHZpZXcsIGhlYWRQb3MpIHtcbiAgICBsZXQgc2VsID0gdmlldy5vYnNlcnZlci5zZWxlY3Rpb25SYW5nZTtcbiAgICBsZXQgdGV4dE5vZGUgPSBzZWwuZm9jdXNOb2RlICYmIG5lYXJieVRleHROb2RlKHNlbC5mb2N1c05vZGUsIHNlbC5mb2N1c09mZnNldCwgMCk7XG4gICAgaWYgKCF0ZXh0Tm9kZSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IGZyb20gPSBoZWFkUG9zIC0gdGV4dE5vZGUub2Zmc2V0O1xuICAgIHJldHVybiB7IGZyb20sIHRvOiBmcm9tICsgdGV4dE5vZGUubm9kZS5ub2RlVmFsdWUubGVuZ3RoLCBub2RlOiB0ZXh0Tm9kZS5ub2RlIH07XG59XG5mdW5jdGlvbiBmaW5kQ29tcG9zaXRpb25SYW5nZSh2aWV3LCBjaGFuZ2VzLCBoZWFkUG9zKSB7XG4gICAgbGV0IGZvdW5kID0gZmluZENvbXBvc2l0aW9uTm9kZSh2aWV3LCBoZWFkUG9zKTtcbiAgICBpZiAoIWZvdW5kKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgeyBub2RlOiB0ZXh0Tm9kZSwgZnJvbSwgdG8gfSA9IGZvdW5kLCB0ZXh0ID0gdGV4dE5vZGUubm9kZVZhbHVlO1xuICAgIC8vIERvbid0IHRyeSB0byBwcmVzZXJ2ZSBtdWx0aS1saW5lIGNvbXBvc2l0aW9uc1xuICAgIGlmICgvW1xcblxccl0vLnRlc3QodGV4dCkpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGlmICh2aWV3LnN0YXRlLmRvYy5zbGljZVN0cmluZyhmb3VuZC5mcm9tLCBmb3VuZC50bykgIT0gdGV4dClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IGludiA9IGNoYW5nZXMuaW52ZXJ0ZWREZXNjO1xuICAgIGxldCByYW5nZSA9IG5ldyBDaGFuZ2VkUmFuZ2UoaW52Lm1hcFBvcyhmcm9tKSwgaW52Lm1hcFBvcyh0byksIGZyb20sIHRvKTtcbiAgICBsZXQgbWFya3MgPSBbXTtcbiAgICBmb3IgKGxldCBwYXJlbnQgPSB0ZXh0Tm9kZS5wYXJlbnROb2RlOzsgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgbGV0IHBhcmVudFZpZXcgPSBDb250ZW50Vmlldy5nZXQocGFyZW50KTtcbiAgICAgICAgaWYgKHBhcmVudFZpZXcgaW5zdGFuY2VvZiBNYXJrVmlldylcbiAgICAgICAgICAgIG1hcmtzLnB1c2goeyBub2RlOiBwYXJlbnQsIGRlY286IHBhcmVudFZpZXcubWFyayB9KTtcbiAgICAgICAgZWxzZSBpZiAocGFyZW50VmlldyBpbnN0YW5jZW9mIExpbmVWaWV3IHx8IHBhcmVudC5ub2RlTmFtZSA9PSBcIkRJVlwiICYmIHBhcmVudC5wYXJlbnROb2RlID09IHZpZXcuY29udGVudERPTSlcbiAgICAgICAgICAgIHJldHVybiB7IHJhbmdlLCB0ZXh0OiB0ZXh0Tm9kZSwgbWFya3MsIGxpbmU6IHBhcmVudCB9O1xuICAgICAgICBlbHNlIGlmIChwYXJlbnQgIT0gdmlldy5jb250ZW50RE9NKVxuICAgICAgICAgICAgbWFya3MucHVzaCh7IG5vZGU6IHBhcmVudCwgZGVjbzogbmV3IE1hcmtEZWNvcmF0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBnZXRBdHRycyhwYXJlbnQpLFxuICAgICAgICAgICAgICAgICAgICB0YWdOYW1lOiBwYXJlbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgICAgICAgfSkgfSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG5lYXJieVRleHROb2RlKHN0YXJ0Tm9kZSwgc3RhcnRPZmZzZXQsIHNpZGUpIHtcbiAgICBpZiAoc2lkZSA8PSAwKVxuICAgICAgICBmb3IgKGxldCBub2RlID0gc3RhcnROb2RlLCBvZmZzZXQgPSBzdGFydE9mZnNldDs7KSB7XG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAzKVxuICAgICAgICAgICAgICAgIHJldHVybiB7IG5vZGU6IG5vZGUsIG9mZnNldDogb2Zmc2V0IH07XG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAxICYmIG9mZnNldCA+IDApIHtcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldCAtIDFdO1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IG1heE9mZnNldChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgaWYgKHNpZGUgPj0gMClcbiAgICAgICAgZm9yIChsZXQgbm9kZSA9IHN0YXJ0Tm9kZSwgb2Zmc2V0ID0gc3RhcnRPZmZzZXQ7Oykge1xuICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMylcbiAgICAgICAgICAgICAgICByZXR1cm4geyBub2RlOiBub2RlLCBvZmZzZXQ6IG9mZnNldCB9O1xuICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSAmJiBvZmZzZXQgPCBub2RlLmNoaWxkTm9kZXMubGVuZ3RoICYmIHNpZGUgPj0gMCkge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0XTtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIG5leHRUb1VuZWRpdGFibGUobm9kZSwgb2Zmc2V0KSB7XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgIT0gMSlcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgcmV0dXJuIChvZmZzZXQgJiYgbm9kZS5jaGlsZE5vZGVzW29mZnNldCAtIDFdLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIgPyAxIC8qIE5leHRUby5CZWZvcmUgKi8gOiAwKSB8XG4gICAgICAgIChvZmZzZXQgPCBub2RlLmNoaWxkTm9kZXMubGVuZ3RoICYmIG5vZGUuY2hpbGROb2Rlc1tvZmZzZXRdLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIgPyAyIC8qIE5leHRUby5BZnRlciAqLyA6IDApO1xufVxubGV0IERlY29yYXRpb25Db21wYXJhdG9yJDEgPSBjbGFzcyBEZWNvcmF0aW9uQ29tcGFyYXRvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlcyA9IFtdO1xuICAgIH1cbiAgICBjb21wYXJlUmFuZ2UoZnJvbSwgdG8pIHsgYWRkUmFuZ2UoZnJvbSwgdG8sIHRoaXMuY2hhbmdlcyk7IH1cbiAgICBjb21wYXJlUG9pbnQoZnJvbSwgdG8pIHsgYWRkUmFuZ2UoZnJvbSwgdG8sIHRoaXMuY2hhbmdlcyk7IH1cbn07XG5mdW5jdGlvbiBmaW5kQ2hhbmdlZERlY28oYSwgYiwgZGlmZikge1xuICAgIGxldCBjb21wID0gbmV3IERlY29yYXRpb25Db21wYXJhdG9yJDE7XG4gICAgUmFuZ2VTZXQuY29tcGFyZShhLCBiLCBkaWZmLCBjb21wKTtcbiAgICByZXR1cm4gY29tcC5jaGFuZ2VzO1xufVxuZnVuY3Rpb24gaW5VbmVkaXRhYmxlKG5vZGUsIGluc2lkZSkge1xuICAgIGZvciAobGV0IGN1ciA9IG5vZGU7IGN1ciAmJiBjdXIgIT0gaW5zaWRlOyBjdXIgPSBjdXIuYXNzaWduZWRTbG90IHx8IGN1ci5wYXJlbnROb2RlKSB7XG4gICAgICAgIGlmIChjdXIubm9kZVR5cGUgPT0gMSAmJiBjdXIuY29udGVudEVkaXRhYmxlID09ICdmYWxzZScpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHRvdWNoZXNDb21wb3NpdGlvbihjaGFuZ2VzLCBjb21wb3NpdGlvbikge1xuICAgIGxldCB0b3VjaGVkID0gZmFsc2U7XG4gICAgaWYgKGNvbXBvc2l0aW9uKVxuICAgICAgICBjaGFuZ2VzLml0ZXJDaGFuZ2VkUmFuZ2VzKChmcm9tLCB0bykgPT4ge1xuICAgICAgICAgICAgaWYgKGZyb20gPCBjb21wb3NpdGlvbi50byAmJiB0byA+IGNvbXBvc2l0aW9uLmZyb20pXG4gICAgICAgICAgICAgICAgdG91Y2hlZCA9IHRydWU7XG4gICAgICAgIH0pO1xuICAgIHJldHVybiB0b3VjaGVkO1xufVxuXG5mdW5jdGlvbiBncm91cEF0KHN0YXRlLCBwb3MsIGJpYXMgPSAxKSB7XG4gICAgbGV0IGNhdGVnb3JpemUgPSBzdGF0ZS5jaGFyQ2F0ZWdvcml6ZXIocG9zKTtcbiAgICBsZXQgbGluZSA9IHN0YXRlLmRvYy5saW5lQXQocG9zKSwgbGluZVBvcyA9IHBvcyAtIGxpbmUuZnJvbTtcbiAgICBpZiAobGluZS5sZW5ndGggPT0gMClcbiAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocG9zKTtcbiAgICBpZiAobGluZVBvcyA9PSAwKVxuICAgICAgICBiaWFzID0gMTtcbiAgICBlbHNlIGlmIChsaW5lUG9zID09IGxpbmUubGVuZ3RoKVxuICAgICAgICBiaWFzID0gLTE7XG4gICAgbGV0IGZyb20gPSBsaW5lUG9zLCB0byA9IGxpbmVQb3M7XG4gICAgaWYgKGJpYXMgPCAwKVxuICAgICAgICBmcm9tID0gZmluZENsdXN0ZXJCcmVhayhsaW5lLnRleHQsIGxpbmVQb3MsIGZhbHNlKTtcbiAgICBlbHNlXG4gICAgICAgIHRvID0gZmluZENsdXN0ZXJCcmVhayhsaW5lLnRleHQsIGxpbmVQb3MpO1xuICAgIGxldCBjYXQgPSBjYXRlZ29yaXplKGxpbmUudGV4dC5zbGljZShmcm9tLCB0bykpO1xuICAgIHdoaWxlIChmcm9tID4gMCkge1xuICAgICAgICBsZXQgcHJldiA9IGZpbmRDbHVzdGVyQnJlYWsobGluZS50ZXh0LCBmcm9tLCBmYWxzZSk7XG4gICAgICAgIGlmIChjYXRlZ29yaXplKGxpbmUudGV4dC5zbGljZShwcmV2LCBmcm9tKSkgIT0gY2F0KVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGZyb20gPSBwcmV2O1xuICAgIH1cbiAgICB3aGlsZSAodG8gPCBsaW5lLmxlbmd0aCkge1xuICAgICAgICBsZXQgbmV4dCA9IGZpbmRDbHVzdGVyQnJlYWsobGluZS50ZXh0LCB0byk7XG4gICAgICAgIGlmIChjYXRlZ29yaXplKGxpbmUudGV4dC5zbGljZSh0bywgbmV4dCkpICE9IGNhdClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB0byA9IG5leHQ7XG4gICAgfVxuICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UoZnJvbSArIGxpbmUuZnJvbSwgdG8gKyBsaW5lLmZyb20pO1xufVxuLy8gU2VhcmNoIHRoZSBET00gZm9yIHRoZSB7bm9kZSwgb2Zmc2V0fSBwb3NpdGlvbiBjbG9zZXN0IHRvIHRoZSBnaXZlblxuLy8gY29vcmRpbmF0ZXMuIFZlcnkgaW5lZmZpY2llbnQgYW5kIGNydWRlLCBidXQgY2FuIHVzdWFsbHkgYmUgYXZvaWRlZFxuLy8gYnkgY2FsbGluZyBjYXJldChQb3NpdGlvbnxSYW5nZSlGcm9tUG9pbnQgaW5zdGVhZC5cbmZ1bmN0aW9uIGdldGR4KHgsIHJlY3QpIHtcbiAgICByZXR1cm4gcmVjdC5sZWZ0ID4geCA/IHJlY3QubGVmdCAtIHggOiBNYXRoLm1heCgwLCB4IC0gcmVjdC5yaWdodCk7XG59XG5mdW5jdGlvbiBnZXRkeSh5LCByZWN0KSB7XG4gICAgcmV0dXJuIHJlY3QudG9wID4geSA/IHJlY3QudG9wIC0geSA6IE1hdGgubWF4KDAsIHkgLSByZWN0LmJvdHRvbSk7XG59XG5mdW5jdGlvbiB5T3ZlcmxhcChhLCBiKSB7XG4gICAgcmV0dXJuIGEudG9wIDwgYi5ib3R0b20gLSAxICYmIGEuYm90dG9tID4gYi50b3AgKyAxO1xufVxuZnVuY3Rpb24gdXBUb3AocmVjdCwgdG9wKSB7XG4gICAgcmV0dXJuIHRvcCA8IHJlY3QudG9wID8geyB0b3AsIGxlZnQ6IHJlY3QubGVmdCwgcmlnaHQ6IHJlY3QucmlnaHQsIGJvdHRvbTogcmVjdC5ib3R0b20gfSA6IHJlY3Q7XG59XG5mdW5jdGlvbiB1cEJvdChyZWN0LCBib3R0b20pIHtcbiAgICByZXR1cm4gYm90dG9tID4gcmVjdC5ib3R0b20gPyB7IHRvcDogcmVjdC50b3AsIGxlZnQ6IHJlY3QubGVmdCwgcmlnaHQ6IHJlY3QucmlnaHQsIGJvdHRvbSB9IDogcmVjdDtcbn1cbmZ1bmN0aW9uIGRvbVBvc0F0Q29vcmRzKHBhcmVudCwgeCwgeSkge1xuICAgIGxldCBjbG9zZXN0LCBjbG9zZXN0UmVjdCwgY2xvc2VzdFgsIGNsb3Nlc3RZLCBjbG9zZXN0T3ZlcmxhcCA9IGZhbHNlO1xuICAgIGxldCBhYm92ZSwgYmVsb3csIGFib3ZlUmVjdCwgYmVsb3dSZWN0O1xuICAgIGZvciAobGV0IGNoaWxkID0gcGFyZW50LmZpcnN0Q2hpbGQ7IGNoaWxkOyBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nKSB7XG4gICAgICAgIGxldCByZWN0cyA9IGNsaWVudFJlY3RzRm9yKGNoaWxkKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHJlY3QgPSByZWN0c1tpXTtcbiAgICAgICAgICAgIGlmIChjbG9zZXN0UmVjdCAmJiB5T3ZlcmxhcChjbG9zZXN0UmVjdCwgcmVjdCkpXG4gICAgICAgICAgICAgICAgcmVjdCA9IHVwVG9wKHVwQm90KHJlY3QsIGNsb3Nlc3RSZWN0LmJvdHRvbSksIGNsb3Nlc3RSZWN0LnRvcCk7XG4gICAgICAgICAgICBsZXQgZHggPSBnZXRkeCh4LCByZWN0KSwgZHkgPSBnZXRkeSh5LCByZWN0KTtcbiAgICAgICAgICAgIGlmIChkeCA9PSAwICYmIGR5ID09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkLm5vZGVUeXBlID09IDMgPyBkb21Qb3NJblRleHQoY2hpbGQsIHgsIHkpIDogZG9tUG9zQXRDb29yZHMoY2hpbGQsIHgsIHkpO1xuICAgICAgICAgICAgaWYgKCFjbG9zZXN0IHx8IGNsb3Nlc3RZID4gZHkgfHwgY2xvc2VzdFkgPT0gZHkgJiYgY2xvc2VzdFggPiBkeCkge1xuICAgICAgICAgICAgICAgIGNsb3Nlc3QgPSBjaGlsZDtcbiAgICAgICAgICAgICAgICBjbG9zZXN0UmVjdCA9IHJlY3Q7XG4gICAgICAgICAgICAgICAgY2xvc2VzdFggPSBkeDtcbiAgICAgICAgICAgICAgICBjbG9zZXN0WSA9IGR5O1xuICAgICAgICAgICAgICAgIGxldCBzaWRlID0gZHkgPyAoeSA8IHJlY3QudG9wID8gLTEgOiAxKSA6IGR4ID8gKHggPCByZWN0LmxlZnQgPyAtMSA6IDEpIDogMDtcbiAgICAgICAgICAgICAgICBjbG9zZXN0T3ZlcmxhcCA9ICFzaWRlIHx8IChzaWRlID4gMCA/IGkgPCByZWN0cy5sZW5ndGggLSAxIDogaSA+IDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGR4ID09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoeSA+IHJlY3QuYm90dG9tICYmICghYWJvdmVSZWN0IHx8IGFib3ZlUmVjdC5ib3R0b20gPCByZWN0LmJvdHRvbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYWJvdmUgPSBjaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgYWJvdmVSZWN0ID0gcmVjdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoeSA8IHJlY3QudG9wICYmICghYmVsb3dSZWN0IHx8IGJlbG93UmVjdC50b3AgPiByZWN0LnRvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYmVsb3cgPSBjaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgYmVsb3dSZWN0ID0gcmVjdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhYm92ZVJlY3QgJiYgeU92ZXJsYXAoYWJvdmVSZWN0LCByZWN0KSkge1xuICAgICAgICAgICAgICAgIGFib3ZlUmVjdCA9IHVwQm90KGFib3ZlUmVjdCwgcmVjdC5ib3R0b20pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYmVsb3dSZWN0ICYmIHlPdmVybGFwKGJlbG93UmVjdCwgcmVjdCkpIHtcbiAgICAgICAgICAgICAgICBiZWxvd1JlY3QgPSB1cFRvcChiZWxvd1JlY3QsIHJlY3QudG9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoYWJvdmVSZWN0ICYmIGFib3ZlUmVjdC5ib3R0b20gPj0geSkge1xuICAgICAgICBjbG9zZXN0ID0gYWJvdmU7XG4gICAgICAgIGNsb3Nlc3RSZWN0ID0gYWJvdmVSZWN0O1xuICAgIH1cbiAgICBlbHNlIGlmIChiZWxvd1JlY3QgJiYgYmVsb3dSZWN0LnRvcCA8PSB5KSB7XG4gICAgICAgIGNsb3Nlc3QgPSBiZWxvdztcbiAgICAgICAgY2xvc2VzdFJlY3QgPSBiZWxvd1JlY3Q7XG4gICAgfVxuICAgIGlmICghY2xvc2VzdClcbiAgICAgICAgcmV0dXJuIHsgbm9kZTogcGFyZW50LCBvZmZzZXQ6IDAgfTtcbiAgICBsZXQgY2xpcFggPSBNYXRoLm1heChjbG9zZXN0UmVjdC5sZWZ0LCBNYXRoLm1pbihjbG9zZXN0UmVjdC5yaWdodCwgeCkpO1xuICAgIGlmIChjbG9zZXN0Lm5vZGVUeXBlID09IDMpXG4gICAgICAgIHJldHVybiBkb21Qb3NJblRleHQoY2xvc2VzdCwgY2xpcFgsIHkpO1xuICAgIGlmIChjbG9zZXN0T3ZlcmxhcCAmJiBjbG9zZXN0LmNvbnRlbnRFZGl0YWJsZSAhPSBcImZhbHNlXCIpXG4gICAgICAgIHJldHVybiBkb21Qb3NBdENvb3JkcyhjbG9zZXN0LCBjbGlwWCwgeSk7XG4gICAgbGV0IG9mZnNldCA9IEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwocGFyZW50LmNoaWxkTm9kZXMsIGNsb3Nlc3QpICtcbiAgICAgICAgKHggPj0gKGNsb3Nlc3RSZWN0LmxlZnQgKyBjbG9zZXN0UmVjdC5yaWdodCkgLyAyID8gMSA6IDApO1xuICAgIHJldHVybiB7IG5vZGU6IHBhcmVudCwgb2Zmc2V0IH07XG59XG5mdW5jdGlvbiBkb21Qb3NJblRleHQobm9kZSwgeCwgeSkge1xuICAgIGxldCBsZW4gPSBub2RlLm5vZGVWYWx1ZS5sZW5ndGg7XG4gICAgbGV0IGNsb3Nlc3RPZmZzZXQgPSAtMSwgY2xvc2VzdERZID0gMWU5LCBnZW5lcmFsU2lkZSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBsZXQgcmVjdHMgPSB0ZXh0UmFuZ2Uobm9kZSwgaSwgaSArIDEpLmdldENsaWVudFJlY3RzKCk7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcmVjdHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGxldCByZWN0ID0gcmVjdHNbal07XG4gICAgICAgICAgICBpZiAocmVjdC50b3AgPT0gcmVjdC5ib3R0b20pXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAoIWdlbmVyYWxTaWRlKVxuICAgICAgICAgICAgICAgIGdlbmVyYWxTaWRlID0geCAtIHJlY3QubGVmdDtcbiAgICAgICAgICAgIGxldCBkeSA9IChyZWN0LnRvcCA+IHkgPyByZWN0LnRvcCAtIHkgOiB5IC0gcmVjdC5ib3R0b20pIC0gMTtcbiAgICAgICAgICAgIGlmIChyZWN0LmxlZnQgLSAxIDw9IHggJiYgcmVjdC5yaWdodCArIDEgPj0geCAmJiBkeSA8IGNsb3Nlc3REWSkge1xuICAgICAgICAgICAgICAgIGxldCByaWdodCA9IHggPj0gKHJlY3QubGVmdCArIHJlY3QucmlnaHQpIC8gMiwgYWZ0ZXIgPSByaWdodDtcbiAgICAgICAgICAgICAgICBpZiAoYnJvd3Nlci5jaHJvbWUgfHwgYnJvd3Nlci5nZWNrbykge1xuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBmb3IgUlRMIG9uIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBnZXR0aW5nIGNsaWVudFxuICAgICAgICAgICAgICAgICAgICAvLyByZWN0cyBmb3IgZW1wdHkgcmFuZ2VzLlxuICAgICAgICAgICAgICAgICAgICBsZXQgcmVjdEJlZm9yZSA9IHRleHRSYW5nZShub2RlLCBpKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlY3RCZWZvcmUubGVmdCA9PSByZWN0LnJpZ2h0KVxuICAgICAgICAgICAgICAgICAgICAgICAgYWZ0ZXIgPSAhcmlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkeSA8PSAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBub2RlLCBvZmZzZXQ6IGkgKyAoYWZ0ZXIgPyAxIDogMCkgfTtcbiAgICAgICAgICAgICAgICBjbG9zZXN0T2Zmc2V0ID0gaSArIChhZnRlciA/IDEgOiAwKTtcbiAgICAgICAgICAgICAgICBjbG9zZXN0RFkgPSBkeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBub2RlLCBvZmZzZXQ6IGNsb3Nlc3RPZmZzZXQgPiAtMSA/IGNsb3Nlc3RPZmZzZXQgOiBnZW5lcmFsU2lkZSA+IDAgPyBub2RlLm5vZGVWYWx1ZS5sZW5ndGggOiAwIH07XG59XG5mdW5jdGlvbiBwb3NBdENvb3Jkcyh2aWV3LCBjb29yZHMsIHByZWNpc2UsIGJpYXMgPSAtMSkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgbGV0IGNvbnRlbnQgPSB2aWV3LmNvbnRlbnRET00uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGRvY1RvcCA9IGNvbnRlbnQudG9wICsgdmlldy52aWV3U3RhdGUucGFkZGluZ1RvcDtcbiAgICBsZXQgYmxvY2ssIHsgZG9jSGVpZ2h0IH0gPSB2aWV3LnZpZXdTdGF0ZTtcbiAgICBsZXQgeyB4LCB5IH0gPSBjb29yZHMsIHlPZmZzZXQgPSB5IC0gZG9jVG9wO1xuICAgIGlmICh5T2Zmc2V0IDwgMClcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgaWYgKHlPZmZzZXQgPiBkb2NIZWlnaHQpXG4gICAgICAgIHJldHVybiB2aWV3LnN0YXRlLmRvYy5sZW5ndGg7XG4gICAgLy8gU2NhbiBmb3IgYSB0ZXh0IGJsb2NrIG5lYXIgdGhlIHF1ZXJpZWQgeSBwb3NpdGlvblxuICAgIGZvciAobGV0IGhhbGZMaW5lID0gdmlldy52aWV3U3RhdGUuaGVpZ2h0T3JhY2xlLnRleHRIZWlnaHQgLyAyLCBib3VuY2VkID0gZmFsc2U7Oykge1xuICAgICAgICBibG9jayA9IHZpZXcuZWxlbWVudEF0SGVpZ2h0KHlPZmZzZXQpO1xuICAgICAgICBpZiAoYmxvY2sudHlwZSA9PSBCbG9ja1R5cGUuVGV4dClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAvLyBNb3ZlIHRoZSB5IHBvc2l0aW9uIG91dCBvZiB0aGlzIGJsb2NrXG4gICAgICAgICAgICB5T2Zmc2V0ID0gYmlhcyA+IDAgPyBibG9jay5ib3R0b20gKyBoYWxmTGluZSA6IGJsb2NrLnRvcCAtIGhhbGZMaW5lO1xuICAgICAgICAgICAgaWYgKHlPZmZzZXQgPj0gMCAmJiB5T2Zmc2V0IDw9IGRvY0hlaWdodClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vIElmIHRoZSBkb2N1bWVudCBjb25zaXN0cyBlbnRpcmVseSBvZiByZXBsYWNlZCB3aWRnZXRzLCB3ZVxuICAgICAgICAgICAgLy8gd29uJ3QgZmluZCBhIHRleHQgYmxvY2ssIHNvIHJldHVybiAwXG4gICAgICAgICAgICBpZiAoYm91bmNlZClcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJlY2lzZSA/IG51bGwgOiAwO1xuICAgICAgICAgICAgYm91bmNlZCA9IHRydWU7XG4gICAgICAgICAgICBiaWFzID0gLWJpYXM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgeSA9IGRvY1RvcCArIHlPZmZzZXQ7XG4gICAgbGV0IGxpbmVTdGFydCA9IGJsb2NrLmZyb207XG4gICAgLy8gSWYgdGhpcyBpcyBvdXRzaWRlIG9mIHRoZSByZW5kZXJlZCB2aWV3cG9ydCwgd2UgY2FuJ3QgZGV0ZXJtaW5lIGEgcG9zaXRpb25cbiAgICBpZiAobGluZVN0YXJ0IDwgdmlldy52aWV3cG9ydC5mcm9tKVxuICAgICAgICByZXR1cm4gdmlldy52aWV3cG9ydC5mcm9tID09IDAgPyAwIDogcHJlY2lzZSA/IG51bGwgOiBwb3NBdENvb3Jkc0ltcHJlY2lzZSh2aWV3LCBjb250ZW50LCBibG9jaywgeCwgeSk7XG4gICAgaWYgKGxpbmVTdGFydCA+IHZpZXcudmlld3BvcnQudG8pXG4gICAgICAgIHJldHVybiB2aWV3LnZpZXdwb3J0LnRvID09IHZpZXcuc3RhdGUuZG9jLmxlbmd0aCA/IHZpZXcuc3RhdGUuZG9jLmxlbmd0aCA6XG4gICAgICAgICAgICBwcmVjaXNlID8gbnVsbCA6IHBvc0F0Q29vcmRzSW1wcmVjaXNlKHZpZXcsIGNvbnRlbnQsIGJsb2NrLCB4LCB5KTtcbiAgICAvLyBQcmVmZXIgU2hhZG93Um9vdE9yRG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludCBpZiBwcmVzZW50LCBmYWxsIGJhY2sgdG8gZG9jdW1lbnQgaWYgbm90XG4gICAgbGV0IGRvYyA9IHZpZXcuZG9tLm93bmVyRG9jdW1lbnQ7XG4gICAgbGV0IHJvb3QgPSB2aWV3LnJvb3QuZWxlbWVudEZyb21Qb2ludCA/IHZpZXcucm9vdCA6IGRvYztcbiAgICBsZXQgZWxlbWVudCA9IHJvb3QuZWxlbWVudEZyb21Qb2ludCh4LCB5KTtcbiAgICBpZiAoZWxlbWVudCAmJiAhdmlldy5jb250ZW50RE9NLmNvbnRhaW5zKGVsZW1lbnQpKVxuICAgICAgICBlbGVtZW50ID0gbnVsbDtcbiAgICAvLyBJZiB0aGUgZWxlbWVudCBpcyB1bmV4cGVjdGVkLCBjbGlwIHggYXQgdGhlIHNpZGVzIG9mIHRoZSBjb250ZW50IGFyZWEgYW5kIHRyeSBhZ2FpblxuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICB4ID0gTWF0aC5tYXgoY29udGVudC5sZWZ0ICsgMSwgTWF0aC5taW4oY29udGVudC5yaWdodCAtIDEsIHgpKTtcbiAgICAgICAgZWxlbWVudCA9IHJvb3QuZWxlbWVudEZyb21Qb2ludCh4LCB5KTtcbiAgICAgICAgaWYgKGVsZW1lbnQgJiYgIXZpZXcuY29udGVudERPTS5jb250YWlucyhlbGVtZW50KSlcbiAgICAgICAgICAgIGVsZW1lbnQgPSBudWxsO1xuICAgIH1cbiAgICAvLyBUaGVyZSdzIHZpc2libGUgZWRpdG9yIGNvbnRlbnQgdW5kZXIgdGhlIHBvaW50LCBzbyB3ZSBjYW4gdHJ5XG4gICAgLy8gdXNpbmcgY2FyZXQoUG9zaXRpb258UmFuZ2UpRnJvbVBvaW50IGFzIGEgc2hvcnRjdXRcbiAgICBsZXQgbm9kZSwgb2Zmc2V0ID0gLTE7XG4gICAgaWYgKGVsZW1lbnQgJiYgKChfYSA9IHZpZXcuZG9jVmlldy5uZWFyZXN0KGVsZW1lbnQpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaXNFZGl0YWJsZSkgIT0gZmFsc2UpIHtcbiAgICAgICAgaWYgKGRvYy5jYXJldFBvc2l0aW9uRnJvbVBvaW50KSB7XG4gICAgICAgICAgICBsZXQgcG9zID0gZG9jLmNhcmV0UG9zaXRpb25Gcm9tUG9pbnQoeCwgeSk7XG4gICAgICAgICAgICBpZiAocG9zKVxuICAgICAgICAgICAgICAgICh7IG9mZnNldE5vZGU6IG5vZGUsIG9mZnNldCB9ID0gcG9zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkb2MuY2FyZXRSYW5nZUZyb21Qb2ludCkge1xuICAgICAgICAgICAgbGV0IHJhbmdlID0gZG9jLmNhcmV0UmFuZ2VGcm9tUG9pbnQoeCwgeSk7XG4gICAgICAgICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgICAgICAgICAoeyBzdGFydENvbnRhaW5lcjogbm9kZSwgc3RhcnRPZmZzZXQ6IG9mZnNldCB9ID0gcmFuZ2UpO1xuICAgICAgICAgICAgICAgIGlmICghdmlldy5jb250ZW50RE9NLmNvbnRhaW5zKG5vZGUpIHx8XG4gICAgICAgICAgICAgICAgICAgIGJyb3dzZXIuc2FmYXJpICYmIGlzU3VzcGljaW91c1NhZmFyaUNhcmV0UmVzdWx0KG5vZGUsIG9mZnNldCwgeCkgfHxcbiAgICAgICAgICAgICAgICAgICAgYnJvd3Nlci5jaHJvbWUgJiYgaXNTdXNwaWNpb3VzQ2hyb21lQ2FyZXRSZXN1bHQobm9kZSwgb2Zmc2V0LCB4KSlcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBObyBsdWNrLCBkbyBvdXIgb3duIChwb3RlbnRpYWxseSBleHBlbnNpdmUpIHNlYXJjaFxuICAgIGlmICghbm9kZSB8fCAhdmlldy5kb2NWaWV3LmRvbS5jb250YWlucyhub2RlKSkge1xuICAgICAgICBsZXQgbGluZSA9IExpbmVWaWV3LmZpbmQodmlldy5kb2NWaWV3LCBsaW5lU3RhcnQpO1xuICAgICAgICBpZiAoIWxpbmUpXG4gICAgICAgICAgICByZXR1cm4geU9mZnNldCA+IGJsb2NrLnRvcCArIGJsb2NrLmhlaWdodCAvIDIgPyBibG9jay50byA6IGJsb2NrLmZyb207XG4gICAgICAgICh7IG5vZGUsIG9mZnNldCB9ID0gZG9tUG9zQXRDb29yZHMobGluZS5kb20sIHgsIHkpKTtcbiAgICB9XG4gICAgbGV0IG5lYXJlc3QgPSB2aWV3LmRvY1ZpZXcubmVhcmVzdChub2RlKTtcbiAgICBpZiAoIW5lYXJlc3QpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGlmIChuZWFyZXN0LmlzV2lkZ2V0ICYmICgoX2IgPSBuZWFyZXN0LmRvbSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm5vZGVUeXBlKSA9PSAxKSB7XG4gICAgICAgIGxldCByZWN0ID0gbmVhcmVzdC5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHJldHVybiBjb29yZHMueSA8IHJlY3QudG9wIHx8IGNvb3Jkcy55IDw9IHJlY3QuYm90dG9tICYmIGNvb3Jkcy54IDw9IChyZWN0LmxlZnQgKyByZWN0LnJpZ2h0KSAvIDJcbiAgICAgICAgICAgID8gbmVhcmVzdC5wb3NBdFN0YXJ0IDogbmVhcmVzdC5wb3NBdEVuZDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBuZWFyZXN0LmxvY2FsUG9zRnJvbURPTShub2RlLCBvZmZzZXQpICsgbmVhcmVzdC5wb3NBdFN0YXJ0O1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBvc0F0Q29vcmRzSW1wcmVjaXNlKHZpZXcsIGNvbnRlbnRSZWN0LCBibG9jaywgeCwgeSkge1xuICAgIGxldCBpbnRvID0gTWF0aC5yb3VuZCgoeCAtIGNvbnRlbnRSZWN0LmxlZnQpICogdmlldy5kZWZhdWx0Q2hhcmFjdGVyV2lkdGgpO1xuICAgIGlmICh2aWV3LmxpbmVXcmFwcGluZyAmJiBibG9jay5oZWlnaHQgPiB2aWV3LmRlZmF1bHRMaW5lSGVpZ2h0ICogMS41KSB7XG4gICAgICAgIGxldCB0ZXh0SGVpZ2h0ID0gdmlldy52aWV3U3RhdGUuaGVpZ2h0T3JhY2xlLnRleHRIZWlnaHQ7XG4gICAgICAgIGxldCBsaW5lID0gTWF0aC5mbG9vcigoeSAtIGJsb2NrLnRvcCAtICh2aWV3LmRlZmF1bHRMaW5lSGVpZ2h0IC0gdGV4dEhlaWdodCkgKiAwLjUpIC8gdGV4dEhlaWdodCk7XG4gICAgICAgIGludG8gKz0gbGluZSAqIHZpZXcudmlld1N0YXRlLmhlaWdodE9yYWNsZS5saW5lTGVuZ3RoO1xuICAgIH1cbiAgICBsZXQgY29udGVudCA9IHZpZXcuc3RhdGUuc2xpY2VEb2MoYmxvY2suZnJvbSwgYmxvY2sudG8pO1xuICAgIHJldHVybiBibG9jay5mcm9tICsgZmluZENvbHVtbihjb250ZW50LCBpbnRvLCB2aWV3LnN0YXRlLnRhYlNpemUpO1xufVxuLy8gSW4gY2FzZSBvZiBhIGhpZ2ggbGluZSBoZWlnaHQsIFNhZmFyaSdzIGNhcmV0UmFuZ2VGcm9tUG9pbnQgdHJlYXRzXG4vLyB0aGUgc3BhY2UgYmV0d2VlbiBsaW5lcyBhcyBiZWxvbmdpbmcgdG8gdGhlIGxhc3QgY2hhcmFjdGVyIG9mIHRoZVxuLy8gbGluZSBiZWZvcmUuIFRoaXMgaXMgdXNlZCB0byBkZXRlY3Qgc3VjaCBhIHJlc3VsdCBzbyB0aGF0IGl0IGNhbiBiZVxuLy8gaWdub3JlZCAoaXNzdWUgIzQwMSkuXG5mdW5jdGlvbiBpc1N1c3BpY2lvdXNTYWZhcmlDYXJldFJlc3VsdChub2RlLCBvZmZzZXQsIHgpIHtcbiAgICBsZXQgbGVuO1xuICAgIGlmIChub2RlLm5vZGVUeXBlICE9IDMgfHwgb2Zmc2V0ICE9IChsZW4gPSBub2RlLm5vZGVWYWx1ZS5sZW5ndGgpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgbmV4dCA9IG5vZGUubmV4dFNpYmxpbmc7IG5leHQ7IG5leHQgPSBuZXh0Lm5leHRTaWJsaW5nKVxuICAgICAgICBpZiAobmV4dC5ub2RlVHlwZSAhPSAxIHx8IG5leHQubm9kZU5hbWUgIT0gXCJCUlwiKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0ZXh0UmFuZ2Uobm9kZSwgbGVuIC0gMSwgbGVuKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0ID4geDtcbn1cbi8vIENocm9tZSB3aWxsIG1vdmUgcG9zaXRpb25zIGJldHdlZW4gbGluZXMgdG8gdGhlIHN0YXJ0IG9mIHRoZSBuZXh0IGxpbmVcbmZ1bmN0aW9uIGlzU3VzcGljaW91c0Nocm9tZUNhcmV0UmVzdWx0KG5vZGUsIG9mZnNldCwgeCkge1xuICAgIGlmIChvZmZzZXQgIT0gMClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGN1ciA9IG5vZGU7Oykge1xuICAgICAgICBsZXQgcGFyZW50ID0gY3VyLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICghcGFyZW50IHx8IHBhcmVudC5ub2RlVHlwZSAhPSAxIHx8IHBhcmVudC5maXJzdENoaWxkICE9IGN1cilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHBhcmVudC5jbGFzc0xpc3QuY29udGFpbnMoXCJjbS1saW5lXCIpKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGN1ciA9IHBhcmVudDtcbiAgICB9XG4gICAgbGV0IHJlY3QgPSBub2RlLm5vZGVUeXBlID09IDEgPyBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICAgIDogdGV4dFJhbmdlKG5vZGUsIDAsIE1hdGgubWF4KG5vZGUubm9kZVZhbHVlLmxlbmd0aCwgMSkpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiB4IC0gcmVjdC5sZWZ0ID4gNTtcbn1cbmZ1bmN0aW9uIGJsb2NrQXQodmlldywgcG9zKSB7XG4gICAgbGV0IGxpbmUgPSB2aWV3LmxpbmVCbG9ja0F0KHBvcyk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobGluZS50eXBlKSlcbiAgICAgICAgZm9yIChsZXQgbCBvZiBsaW5lLnR5cGUpIHtcbiAgICAgICAgICAgIGlmIChsLnRvID4gcG9zIHx8IGwudG8gPT0gcG9zICYmIChsLnRvID09IGxpbmUudG8gfHwgbC50eXBlID09IEJsb2NrVHlwZS5UZXh0KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbDtcbiAgICAgICAgfVxuICAgIHJldHVybiBsaW5lO1xufVxuZnVuY3Rpb24gbW92ZVRvTGluZUJvdW5kYXJ5KHZpZXcsIHN0YXJ0LCBmb3J3YXJkLCBpbmNsdWRlV3JhcCkge1xuICAgIGxldCBsaW5lID0gYmxvY2tBdCh2aWV3LCBzdGFydC5oZWFkKTtcbiAgICBsZXQgY29vcmRzID0gIWluY2x1ZGVXcmFwIHx8IGxpbmUudHlwZSAhPSBCbG9ja1R5cGUuVGV4dCB8fCAhKHZpZXcubGluZVdyYXBwaW5nIHx8IGxpbmUud2lkZ2V0TGluZUJyZWFrcykgPyBudWxsXG4gICAgICAgIDogdmlldy5jb29yZHNBdFBvcyhzdGFydC5hc3NvYyA8IDAgJiYgc3RhcnQuaGVhZCA+IGxpbmUuZnJvbSA/IHN0YXJ0LmhlYWQgLSAxIDogc3RhcnQuaGVhZCk7XG4gICAgaWYgKGNvb3Jkcykge1xuICAgICAgICBsZXQgZWRpdG9yUmVjdCA9IHZpZXcuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBsZXQgZGlyZWN0aW9uID0gdmlldy50ZXh0RGlyZWN0aW9uQXQobGluZS5mcm9tKTtcbiAgICAgICAgbGV0IHBvcyA9IHZpZXcucG9zQXRDb29yZHMoeyB4OiBmb3J3YXJkID09IChkaXJlY3Rpb24gPT0gRGlyZWN0aW9uLkxUUikgPyBlZGl0b3JSZWN0LnJpZ2h0IC0gMSA6IGVkaXRvclJlY3QubGVmdCArIDEsXG4gICAgICAgICAgICB5OiAoY29vcmRzLnRvcCArIGNvb3Jkcy5ib3R0b20pIC8gMiB9KTtcbiAgICAgICAgaWYgKHBvcyAhPSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocG9zLCBmb3J3YXJkID8gLTEgOiAxKTtcbiAgICB9XG4gICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jdXJzb3IoZm9yd2FyZCA/IGxpbmUudG8gOiBsaW5lLmZyb20sIGZvcndhcmQgPyAtMSA6IDEpO1xufVxuZnVuY3Rpb24gbW92ZUJ5Q2hhcih2aWV3LCBzdGFydCwgZm9yd2FyZCwgYnkpIHtcbiAgICBsZXQgbGluZSA9IHZpZXcuc3RhdGUuZG9jLmxpbmVBdChzdGFydC5oZWFkKSwgc3BhbnMgPSB2aWV3LmJpZGlTcGFucyhsaW5lKTtcbiAgICBsZXQgZGlyZWN0aW9uID0gdmlldy50ZXh0RGlyZWN0aW9uQXQobGluZS5mcm9tKTtcbiAgICBmb3IgKGxldCBjdXIgPSBzdGFydCwgY2hlY2sgPSBudWxsOzspIHtcbiAgICAgICAgbGV0IG5leHQgPSBtb3ZlVmlzdWFsbHkobGluZSwgc3BhbnMsIGRpcmVjdGlvbiwgY3VyLCBmb3J3YXJkKSwgY2hhciA9IG1vdmVkT3ZlcjtcbiAgICAgICAgaWYgKCFuZXh0KSB7XG4gICAgICAgICAgICBpZiAobGluZS5udW1iZXIgPT0gKGZvcndhcmQgPyB2aWV3LnN0YXRlLmRvYy5saW5lcyA6IDEpKVxuICAgICAgICAgICAgICAgIHJldHVybiBjdXI7XG4gICAgICAgICAgICBjaGFyID0gXCJcXG5cIjtcbiAgICAgICAgICAgIGxpbmUgPSB2aWV3LnN0YXRlLmRvYy5saW5lKGxpbmUubnVtYmVyICsgKGZvcndhcmQgPyAxIDogLTEpKTtcbiAgICAgICAgICAgIHNwYW5zID0gdmlldy5iaWRpU3BhbnMobGluZSk7XG4gICAgICAgICAgICBuZXh0ID0gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihmb3J3YXJkID8gbGluZS5mcm9tIDogbGluZS50byk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjaGVjaykge1xuICAgICAgICAgICAgaWYgKCFieSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgIGNoZWNrID0gYnkoY2hhcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWNoZWNrKGNoYXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gY3VyO1xuICAgICAgICB9XG4gICAgICAgIGN1ciA9IG5leHQ7XG4gICAgfVxufVxuZnVuY3Rpb24gYnlHcm91cCh2aWV3LCBwb3MsIHN0YXJ0KSB7XG4gICAgbGV0IGNhdGVnb3JpemUgPSB2aWV3LnN0YXRlLmNoYXJDYXRlZ29yaXplcihwb3MpO1xuICAgIGxldCBjYXQgPSBjYXRlZ29yaXplKHN0YXJ0KTtcbiAgICByZXR1cm4gKG5leHQpID0+IHtcbiAgICAgICAgbGV0IG5leHRDYXQgPSBjYXRlZ29yaXplKG5leHQpO1xuICAgICAgICBpZiAoY2F0ID09IENoYXJDYXRlZ29yeS5TcGFjZSlcbiAgICAgICAgICAgIGNhdCA9IG5leHRDYXQ7XG4gICAgICAgIHJldHVybiBjYXQgPT0gbmV4dENhdDtcbiAgICB9O1xufVxuZnVuY3Rpb24gbW92ZVZlcnRpY2FsbHkodmlldywgc3RhcnQsIGZvcndhcmQsIGRpc3RhbmNlKSB7XG4gICAgbGV0IHN0YXJ0UG9zID0gc3RhcnQuaGVhZCwgZGlyID0gZm9yd2FyZCA/IDEgOiAtMTtcbiAgICBpZiAoc3RhcnRQb3MgPT0gKGZvcndhcmQgPyB2aWV3LnN0YXRlLmRvYy5sZW5ndGggOiAwKSlcbiAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jdXJzb3Ioc3RhcnRQb3MsIHN0YXJ0LmFzc29jKTtcbiAgICBsZXQgZ29hbCA9IHN0YXJ0LmdvYWxDb2x1bW4sIHN0YXJ0WTtcbiAgICBsZXQgcmVjdCA9IHZpZXcuY29udGVudERPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBsZXQgc3RhcnRDb29yZHMgPSB2aWV3LmNvb3Jkc0F0UG9zKHN0YXJ0UG9zLCBzdGFydC5hc3NvYyB8fCAtMSksIGRvY1RvcCA9IHZpZXcuZG9jdW1lbnRUb3A7XG4gICAgaWYgKHN0YXJ0Q29vcmRzKSB7XG4gICAgICAgIGlmIChnb2FsID09IG51bGwpXG4gICAgICAgICAgICBnb2FsID0gc3RhcnRDb29yZHMubGVmdCAtIHJlY3QubGVmdDtcbiAgICAgICAgc3RhcnRZID0gZGlyIDwgMCA/IHN0YXJ0Q29vcmRzLnRvcCA6IHN0YXJ0Q29vcmRzLmJvdHRvbTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCBsaW5lID0gdmlldy52aWV3U3RhdGUubGluZUJsb2NrQXQoc3RhcnRQb3MpO1xuICAgICAgICBpZiAoZ29hbCA9PSBudWxsKVxuICAgICAgICAgICAgZ29hbCA9IE1hdGgubWluKHJlY3QucmlnaHQgLSByZWN0LmxlZnQsIHZpZXcuZGVmYXVsdENoYXJhY3RlcldpZHRoICogKHN0YXJ0UG9zIC0gbGluZS5mcm9tKSk7XG4gICAgICAgIHN0YXJ0WSA9IChkaXIgPCAwID8gbGluZS50b3AgOiBsaW5lLmJvdHRvbSkgKyBkb2NUb3A7XG4gICAgfVxuICAgIGxldCByZXNvbHZlZEdvYWwgPSByZWN0LmxlZnQgKyBnb2FsO1xuICAgIGxldCBkaXN0ID0gZGlzdGFuY2UgIT09IG51bGwgJiYgZGlzdGFuY2UgIT09IHZvaWQgMCA/IGRpc3RhbmNlIDogKHZpZXcudmlld1N0YXRlLmhlaWdodE9yYWNsZS50ZXh0SGVpZ2h0ID4+IDEpO1xuICAgIGZvciAobGV0IGV4dHJhID0gMDs7IGV4dHJhICs9IDEwKSB7XG4gICAgICAgIGxldCBjdXJZID0gc3RhcnRZICsgKGRpc3QgKyBleHRyYSkgKiBkaXI7XG4gICAgICAgIGxldCBwb3MgPSBwb3NBdENvb3Jkcyh2aWV3LCB7IHg6IHJlc29sdmVkR29hbCwgeTogY3VyWSB9LCBmYWxzZSwgZGlyKTtcbiAgICAgICAgaWYgKGN1clkgPCByZWN0LnRvcCB8fCBjdXJZID4gcmVjdC5ib3R0b20gfHwgKGRpciA8IDAgPyBwb3MgPCBzdGFydFBvcyA6IHBvcyA+IHN0YXJ0UG9zKSkge1xuICAgICAgICAgICAgbGV0IGNoYXJSZWN0ID0gdmlldy5kb2NWaWV3LmNvb3Jkc0ZvckNoYXIocG9zKTtcbiAgICAgICAgICAgIGxldCBhc3NvYyA9ICFjaGFyUmVjdCB8fCBjdXJZIDwgY2hhclJlY3QudG9wID8gLTEgOiAxO1xuICAgICAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocG9zLCBhc3NvYywgdW5kZWZpbmVkLCBnb2FsKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHNraXBBdG9taWNSYW5nZXMoYXRvbXMsIHBvcywgYmlhcykge1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgbGV0IG1vdmVkID0gMDtcbiAgICAgICAgZm9yIChsZXQgc2V0IG9mIGF0b21zKSB7XG4gICAgICAgICAgICBzZXQuYmV0d2Vlbihwb3MgLSAxLCBwb3MgKyAxLCAoZnJvbSwgdG8sIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHBvcyA+IGZyb20gJiYgcG9zIDwgdG8pIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNpZGUgPSBtb3ZlZCB8fCBiaWFzIHx8IChwb3MgLSBmcm9tIDwgdG8gLSBwb3MgPyAtMSA6IDEpO1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSBzaWRlIDwgMCA/IGZyb20gOiB0bztcbiAgICAgICAgICAgICAgICAgICAgbW92ZWQgPSBzaWRlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbW92ZWQpXG4gICAgICAgICAgICByZXR1cm4gcG9zO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNraXBBdG9tcyh2aWV3LCBvbGRQb3MsIHBvcykge1xuICAgIGxldCBuZXdQb3MgPSBza2lwQXRvbWljUmFuZ2VzKHZpZXcuc3RhdGUuZmFjZXQoYXRvbWljUmFuZ2VzKS5tYXAoZiA9PiBmKHZpZXcpKSwgcG9zLmZyb20sIG9sZFBvcy5oZWFkID4gcG9zLmZyb20gPyAtMSA6IDEpO1xuICAgIHJldHVybiBuZXdQb3MgPT0gcG9zLmZyb20gPyBwb3MgOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKG5ld1BvcywgbmV3UG9zIDwgcG9zLmZyb20gPyAxIDogLTEpO1xufVxuXG4vLyBUaGlzIHdpbGwgYWxzbyBiZSB3aGVyZSBkcmFnZ2luZyBpbmZvIGFuZCBzdWNoIGdvZXNcbmNsYXNzIElucHV0U3RhdGUge1xuICAgIHNldFNlbGVjdGlvbk9yaWdpbihvcmlnaW4pIHtcbiAgICAgICAgdGhpcy5sYXN0U2VsZWN0aW9uT3JpZ2luID0gb3JpZ2luO1xuICAgICAgICB0aGlzLmxhc3RTZWxlY3Rpb25UaW1lID0gRGF0ZS5ub3coKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLmxhc3RLZXlDb2RlID0gMDtcbiAgICAgICAgdGhpcy5sYXN0S2V5VGltZSA9IDA7XG4gICAgICAgIHRoaXMubGFzdFRvdWNoVGltZSA9IDA7XG4gICAgICAgIHRoaXMubGFzdEZvY3VzVGltZSA9IDA7XG4gICAgICAgIHRoaXMubGFzdFNjcm9sbFRvcCA9IDA7XG4gICAgICAgIHRoaXMubGFzdFNjcm9sbExlZnQgPSAwO1xuICAgICAgICAvLyBPbiBpT1MsIHNvbWUga2V5cyBuZWVkIHRvIGhhdmUgdGhlaXIgZGVmYXVsdCBiZWhhdmlvciBoYXBwZW5cbiAgICAgICAgLy8gKGFmdGVyIHdoaWNoIHdlIHJldHJvYWN0aXZlbHkgaGFuZGxlIHRoZW0gYW5kIHJlc2V0IHRoZSBET00pIHRvXG4gICAgICAgIC8vIGF2b2lkIG1lc3NpbmcgdXAgdGhlIHZpcnR1YWwga2V5Ym9hcmQgc3RhdGUuXG4gICAgICAgIHRoaXMucGVuZGluZ0lPU0tleSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5sYXN0U2VsZWN0aW9uT3JpZ2luID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0U2VsZWN0aW9uVGltZSA9IDA7XG4gICAgICAgIHRoaXMubGFzdEVzY1ByZXNzID0gMDtcbiAgICAgICAgdGhpcy5sYXN0Q29udGV4dE1lbnUgPSAwO1xuICAgICAgICB0aGlzLnNjcm9sbEhhbmRsZXJzID0gW107XG4gICAgICAgIHRoaXMuaGFuZGxlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAvLyAtMSBtZWFucyBub3QgaW4gYSBjb21wb3NpdGlvbi4gT3RoZXJ3aXNlLCB0aGlzIGNvdW50cyB0aGUgbnVtYmVyXG4gICAgICAgIC8vIG9mIGNoYW5nZXMgbWFkZSBkdXJpbmcgdGhlIGNvbXBvc2l0aW9uLiBUaGUgY291bnQgaXMgdXNlZCB0b1xuICAgICAgICAvLyBhdm9pZCB0cmVhdGluZyB0aGUgc3RhcnQgc3RhdGUgb2YgdGhlIGNvbXBvc2l0aW9uLCBiZWZvcmUgYW55XG4gICAgICAgIC8vIGNoYW5nZXMgaGF2ZSBiZWVuIG1hZGUsIGFzIHBhcnQgb2YgdGhlIGNvbXBvc2l0aW9uLlxuICAgICAgICB0aGlzLmNvbXBvc2luZyA9IC0xO1xuICAgICAgICAvLyBUcmFja3Mgd2hldGhlciB0aGUgbmV4dCBjaGFuZ2Ugc2hvdWxkIGJlIG1hcmtlZCBhcyBzdGFydGluZyB0aGVcbiAgICAgICAgLy8gY29tcG9zaXRpb24gKG51bGwgbWVhbnMgbm8gY29tcG9zaXRpb24sIHRydWUgbWVhbnMgbmV4dCBpcyB0aGVcbiAgICAgICAgLy8gZmlyc3QsIGZhbHNlIG1lYW5zIGZpcnN0IGhhcyBhbHJlYWR5IGJlZW4gbWFya2VkIGZvciB0aGlzXG4gICAgICAgIC8vIGNvbXBvc2l0aW9uKVxuICAgICAgICB0aGlzLmNvbXBvc2l0aW9uRmlyc3RDaGFuZ2UgPSBudWxsO1xuICAgICAgICAvLyBFbmQgdGltZSBvZiB0aGUgcHJldmlvdXMgY29tcG9zaXRpb25cbiAgICAgICAgdGhpcy5jb21wb3NpdGlvbkVuZGVkQXQgPSAwO1xuICAgICAgICAvLyBVc2VkIGluIGEga2x1ZGdlIHRvIGRldGVjdCB3aGVuIGFuIEVudGVyIGtleXByZXNzIHNob3VsZCBiZVxuICAgICAgICAvLyBjb25zaWRlcmVkIHBhcnQgb2YgdGhlIGNvbXBvc2l0aW9uIG9uIFNhZmFyaSwgd2hpY2ggZmlyZXMgZXZlbnRzXG4gICAgICAgIC8vIGluIHRoZSB3cm9uZyBvcmRlclxuICAgICAgICB0aGlzLmNvbXBvc2l0aW9uUGVuZGluZ0tleSA9IGZhbHNlO1xuICAgICAgICAvLyBVc2VkIHRvIGNhdGVnb3JpemUgY2hhbmdlcyBhcyBwYXJ0IG9mIGEgY29tcG9zaXRpb24sIGV2ZW4gd2hlblxuICAgICAgICAvLyB0aGUgbXV0YXRpb24gZXZlbnRzIGZpcmUgc2hvcnRseSBhZnRlciB0aGUgY29tcG9zaXRpb25lbmQgZXZlbnRcbiAgICAgICAgdGhpcy5jb21wb3NpdGlvblBlbmRpbmdDaGFuZ2UgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5tb3VzZVNlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgIC8vIFdoZW4gYSBkcmFnIGZyb20gdGhlIGVkaXRvciBpcyBhY3RpdmUsIHRoaXMgcG9pbnRzIGF0IHRoZSByYW5nZVxuICAgICAgICAvLyBiZWluZyBkcmFnZ2VkLlxuICAgICAgICB0aGlzLmRyYWdnZWRDb250ZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5oYW5kbGVFdmVudCA9IHRoaXMuaGFuZGxlRXZlbnQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5ub3RpZmllZEZvY3VzZWQgPSB2aWV3Lmhhc0ZvY3VzO1xuICAgICAgICAvLyBPbiBTYWZhcmkgYWRkaW5nIGFuIGlucHV0IGV2ZW50IGhhbmRsZXIgc29tZWhvdyBwcmV2ZW50cyBhblxuICAgICAgICAvLyBpc3N1ZSB3aGVyZSB0aGUgY29tcG9zaXRpb24gdmFuaXNoZXMgd2hlbiB5b3UgcHJlc3MgZW50ZXIuXG4gICAgICAgIGlmIChicm93c2VyLnNhZmFyaSlcbiAgICAgICAgICAgIHZpZXcuY29udGVudERPTS5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgKCkgPT4gbnVsbCk7XG4gICAgICAgIGlmIChicm93c2VyLmdlY2tvKVxuICAgICAgICAgICAgZmlyZWZveENvcHlDdXRIYWNrKHZpZXcuY29udGVudERPTS5vd25lckRvY3VtZW50KTtcbiAgICB9XG4gICAgaGFuZGxlRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgaWYgKCFldmVudEJlbG9uZ3NUb0VkaXRvcih0aGlzLnZpZXcsIGV2ZW50KSB8fCB0aGlzLmlnbm9yZUR1cmluZ0NvbXBvc2l0aW9uKGV2ZW50KSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKGV2ZW50LnR5cGUgPT0gXCJrZXlkb3duXCIgJiYgdGhpcy5rZXlkb3duKGV2ZW50KSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5ydW5IYW5kbGVycyhldmVudC50eXBlLCBldmVudCk7XG4gICAgfVxuICAgIHJ1bkhhbmRsZXJzKHR5cGUsIGV2ZW50KSB7XG4gICAgICAgIGxldCBoYW5kbGVycyA9IHRoaXMuaGFuZGxlcnNbdHlwZV07XG4gICAgICAgIGlmIChoYW5kbGVycykge1xuICAgICAgICAgICAgZm9yIChsZXQgb2JzZXJ2ZXIgb2YgaGFuZGxlcnMub2JzZXJ2ZXJzKVxuICAgICAgICAgICAgICAgIG9ic2VydmVyKHRoaXMudmlldywgZXZlbnQpO1xuICAgICAgICAgICAgZm9yIChsZXQgaGFuZGxlciBvZiBoYW5kbGVycy5oYW5kbGVycykge1xuICAgICAgICAgICAgICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAoaGFuZGxlcih0aGlzLnZpZXcsIGV2ZW50KSkge1xuICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZW5zdXJlSGFuZGxlcnMocGx1Z2lucykge1xuICAgICAgICBsZXQgaGFuZGxlcnMgPSBjb21wdXRlSGFuZGxlcnMocGx1Z2lucyksIHByZXYgPSB0aGlzLmhhbmRsZXJzLCBkb20gPSB0aGlzLnZpZXcuY29udGVudERPTTtcbiAgICAgICAgZm9yIChsZXQgdHlwZSBpbiBoYW5kbGVycylcbiAgICAgICAgICAgIGlmICh0eXBlICE9IFwic2Nyb2xsXCIpIHtcbiAgICAgICAgICAgICAgICBsZXQgcGFzc2l2ZSA9ICFoYW5kbGVyc1t0eXBlXS5oYW5kbGVycy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgbGV0IGV4aXN0cyA9IHByZXZbdHlwZV07XG4gICAgICAgICAgICAgICAgaWYgKGV4aXN0cyAmJiBwYXNzaXZlICE9ICFleGlzdHMuaGFuZGxlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbS5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIHRoaXMuaGFuZGxlRXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICBleGlzdHMgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWV4aXN0cylcbiAgICAgICAgICAgICAgICAgICAgZG9tLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgdGhpcy5oYW5kbGVFdmVudCwgeyBwYXNzaXZlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCB0eXBlIGluIHByZXYpXG4gICAgICAgICAgICBpZiAodHlwZSAhPSBcInNjcm9sbFwiICYmICFoYW5kbGVyc1t0eXBlXSlcbiAgICAgICAgICAgICAgICBkb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCB0aGlzLmhhbmRsZUV2ZW50KTtcbiAgICAgICAgdGhpcy5oYW5kbGVycyA9IGhhbmRsZXJzO1xuICAgIH1cbiAgICBrZXlkb3duKGV2ZW50KSB7XG4gICAgICAgIC8vIE11c3QgYWx3YXlzIHJ1biwgZXZlbiBpZiBhIGN1c3RvbSBoYW5kbGVyIGhhbmRsZWQgdGhlIGV2ZW50XG4gICAgICAgIHRoaXMubGFzdEtleUNvZGUgPSBldmVudC5rZXlDb2RlO1xuICAgICAgICB0aGlzLmxhc3RLZXlUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT0gOSAmJiBEYXRlLm5vdygpIDwgdGhpcy5sYXN0RXNjUHJlc3MgKyAyMDAwKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChldmVudC5rZXlDb2RlICE9IDI3ICYmIG1vZGlmaWVyQ29kZXMuaW5kZXhPZihldmVudC5rZXlDb2RlKSA8IDApXG4gICAgICAgICAgICB0aGlzLnZpZXcuaW5wdXRTdGF0ZS5sYXN0RXNjUHJlc3MgPSAwO1xuICAgICAgICAvLyBDaHJvbWUgZm9yIEFuZHJvaWQgdXN1YWxseSBkb2Vzbid0IGZpcmUgcHJvcGVyIGtleSBldmVudHMsIGJ1dFxuICAgICAgICAvLyBvY2Nhc2lvbmFsbHkgZG9lcywgdXN1YWxseSBzdXJyb3VuZGVkIGJ5IGEgYnVuY2ggb2YgY29tcGxpY2F0ZWRcbiAgICAgICAgLy8gY29tcG9zaXRpb24gY2hhbmdlcy4gV2hlbiBhbiBlbnRlciBvciBiYWNrc3BhY2Uga2V5IGV2ZW50IGlzXG4gICAgICAgIC8vIHNlZW4sIGhvbGQgb2ZmIG9uIGhhbmRsaW5nIERPTSBldmVudHMgZm9yIGEgYml0LCBhbmQgdGhlblxuICAgICAgICAvLyBkaXNwYXRjaCBpdC5cbiAgICAgICAgaWYgKGJyb3dzZXIuYW5kcm9pZCAmJiBicm93c2VyLmNocm9tZSAmJiAhZXZlbnQuc3ludGhldGljICYmXG4gICAgICAgICAgICAoZXZlbnQua2V5Q29kZSA9PSAxMyB8fCBldmVudC5rZXlDb2RlID09IDgpKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXcub2JzZXJ2ZXIuZGVsYXlBbmRyb2lkS2V5KGV2ZW50LmtleSwgZXZlbnQua2V5Q29kZSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQcmV2ZW50aW5nIHRoZSBkZWZhdWx0IGJlaGF2aW9yIG9mIEVudGVyIG9uIGlPUyBtYWtlcyB0aGVcbiAgICAgICAgLy8gdmlydHVhbCBrZXlib2FyZCBnZXQgc3R1Y2sgaW4gdGhlIHdyb25nIChsb3dlcmNhc2UpXG4gICAgICAgIC8vIHN0YXRlLiBTbyB3ZSBsZXQgaXQgZ28gdGhyb3VnaCwgYW5kIHRoZW4sIGluXG4gICAgICAgIC8vIGFwcGx5RE9NQ2hhbmdlLCBub3RpZnkga2V5IGhhbmRsZXJzIG9mIGl0IGFuZCByZXNldCB0b1xuICAgICAgICAvLyB0aGUgc3RhdGUgdGhleSBwcm9kdWNlLlxuICAgICAgICBsZXQgcGVuZGluZztcbiAgICAgICAgaWYgKGJyb3dzZXIuaW9zICYmICFldmVudC5zeW50aGV0aWMgJiYgIWV2ZW50LmFsdEtleSAmJiAhZXZlbnQubWV0YUtleSAmJlxuICAgICAgICAgICAgKChwZW5kaW5nID0gUGVuZGluZ0tleXMuZmluZChrZXkgPT4ga2V5LmtleUNvZGUgPT0gZXZlbnQua2V5Q29kZSkpICYmICFldmVudC5jdHJsS2V5IHx8XG4gICAgICAgICAgICAgICAgRW1hY3N5UGVuZGluZ0tleXMuaW5kZXhPZihldmVudC5rZXkpID4gLTEgJiYgZXZlbnQuY3RybEtleSAmJiAhZXZlbnQuc2hpZnRLZXkpKSB7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdJT1NLZXkgPSBwZW5kaW5nIHx8IGV2ZW50O1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLmZsdXNoSU9TS2V5KCksIDI1MCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSAhPSAyMjkpXG4gICAgICAgICAgICB0aGlzLnZpZXcub2JzZXJ2ZXIuZm9yY2VGbHVzaCgpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZsdXNoSU9TS2V5KCkge1xuICAgICAgICBsZXQga2V5ID0gdGhpcy5wZW5kaW5nSU9TS2V5O1xuICAgICAgICBpZiAoIWtleSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy5wZW5kaW5nSU9TS2V5ID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gZGlzcGF0Y2hLZXkodGhpcy52aWV3LmNvbnRlbnRET00sIGtleS5rZXksIGtleS5rZXlDb2RlKTtcbiAgICB9XG4gICAgaWdub3JlRHVyaW5nQ29tcG9zaXRpb24oZXZlbnQpIHtcbiAgICAgICAgaWYgKCEvXmtleS8udGVzdChldmVudC50eXBlKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuY29tcG9zaW5nID4gMClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAvLyBTZWUgaHR0cHM6Ly93d3cuc3R1bS5kZS8yMDE2LzA2LzI0L2hhbmRsaW5nLWltZS1ldmVudHMtaW4tamF2YXNjcmlwdC8uXG4gICAgICAgIC8vIE9uIHNvbWUgaW5wdXQgbWV0aG9kIGVkaXRvcnMgKElNRXMpLCB0aGUgRW50ZXIga2V5IGlzIHVzZWQgdG9cbiAgICAgICAgLy8gY29uZmlybSBjaGFyYWN0ZXIgc2VsZWN0aW9uLiBPbiBTYWZhcmksIHdoZW4gRW50ZXIgaXMgcHJlc3NlZCxcbiAgICAgICAgLy8gY29tcG9zaXRpb25lbmQgYW5kIGtleWRvd24gZXZlbnRzIGFyZSBzb21ldGltZXMgZW1pdHRlZCBpbiB0aGVcbiAgICAgICAgLy8gd3Jvbmcgb3JkZXIuIFRoZSBrZXkgZXZlbnQgc2hvdWxkIHN0aWxsIGJlIGlnbm9yZWQsIGV2ZW4gd2hlblxuICAgICAgICAvLyBpdCBoYXBwZW5zIGFmdGVyIHRoZSBjb21wb3NpdGlvbmVuZCBldmVudC5cbiAgICAgICAgaWYgKGJyb3dzZXIuc2FmYXJpICYmICFicm93c2VyLmlvcyAmJiB0aGlzLmNvbXBvc2l0aW9uUGVuZGluZ0tleSAmJiBEYXRlLm5vdygpIC0gdGhpcy5jb21wb3NpdGlvbkVuZGVkQXQgPCAxMDApIHtcbiAgICAgICAgICAgIHRoaXMuY29tcG9zaXRpb25QZW5kaW5nS2V5ID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHN0YXJ0TW91c2VTZWxlY3Rpb24obW91c2VTZWxlY3Rpb24pIHtcbiAgICAgICAgaWYgKHRoaXMubW91c2VTZWxlY3Rpb24pXG4gICAgICAgICAgICB0aGlzLm1vdXNlU2VsZWN0aW9uLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5tb3VzZVNlbGVjdGlvbiA9IG1vdXNlU2VsZWN0aW9uO1xuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIGlmICh0aGlzLm1vdXNlU2VsZWN0aW9uKVxuICAgICAgICAgICAgdGhpcy5tb3VzZVNlbGVjdGlvbi51cGRhdGUodXBkYXRlKTtcbiAgICAgICAgaWYgKHRoaXMuZHJhZ2dlZENvbnRlbnQgJiYgdXBkYXRlLmRvY0NoYW5nZWQpXG4gICAgICAgICAgICB0aGlzLmRyYWdnZWRDb250ZW50ID0gdGhpcy5kcmFnZ2VkQ29udGVudC5tYXAodXBkYXRlLmNoYW5nZXMpO1xuICAgICAgICBpZiAodXBkYXRlLnRyYW5zYWN0aW9ucy5sZW5ndGgpXG4gICAgICAgICAgICB0aGlzLmxhc3RLZXlDb2RlID0gdGhpcy5sYXN0U2VsZWN0aW9uVGltZSA9IDA7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLm1vdXNlU2VsZWN0aW9uKVxuICAgICAgICAgICAgdGhpcy5tb3VzZVNlbGVjdGlvbi5kZXN0cm95KCk7XG4gICAgfVxufVxuZnVuY3Rpb24gYmluZEhhbmRsZXIocGx1Z2luLCBoYW5kbGVyKSB7XG4gICAgcmV0dXJuICh2aWV3LCBldmVudCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZXIuY2FsbChwbHVnaW4sIGV2ZW50LCB2aWV3KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbG9nRXhjZXB0aW9uKHZpZXcuc3RhdGUsIGUpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVIYW5kbGVycyhwbHVnaW5zKSB7XG4gICAgbGV0IHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZnVuY3Rpb24gcmVjb3JkKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdFt0eXBlXSB8fCAocmVzdWx0W3R5cGVdID0geyBvYnNlcnZlcnM6IFtdLCBoYW5kbGVyczogW10gfSk7XG4gICAgfVxuICAgIGZvciAobGV0IHBsdWdpbiBvZiBwbHVnaW5zKSB7XG4gICAgICAgIGxldCBzcGVjID0gcGx1Z2luLnNwZWM7XG4gICAgICAgIGlmIChzcGVjICYmIHNwZWMuZG9tRXZlbnRIYW5kbGVycylcbiAgICAgICAgICAgIGZvciAobGV0IHR5cGUgaW4gc3BlYy5kb21FdmVudEhhbmRsZXJzKSB7XG4gICAgICAgICAgICAgICAgbGV0IGYgPSBzcGVjLmRvbUV2ZW50SGFuZGxlcnNbdHlwZV07XG4gICAgICAgICAgICAgICAgaWYgKGYpXG4gICAgICAgICAgICAgICAgICAgIHJlY29yZCh0eXBlKS5oYW5kbGVycy5wdXNoKGJpbmRIYW5kbGVyKHBsdWdpbi52YWx1ZSwgZikpO1xuICAgICAgICAgICAgfVxuICAgICAgICBpZiAoc3BlYyAmJiBzcGVjLmRvbUV2ZW50T2JzZXJ2ZXJzKVxuICAgICAgICAgICAgZm9yIChsZXQgdHlwZSBpbiBzcGVjLmRvbUV2ZW50T2JzZXJ2ZXJzKSB7XG4gICAgICAgICAgICAgICAgbGV0IGYgPSBzcGVjLmRvbUV2ZW50T2JzZXJ2ZXJzW3R5cGVdO1xuICAgICAgICAgICAgICAgIGlmIChmKVxuICAgICAgICAgICAgICAgICAgICByZWNvcmQodHlwZSkub2JzZXJ2ZXJzLnB1c2goYmluZEhhbmRsZXIocGx1Z2luLnZhbHVlLCBmKSk7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IHR5cGUgaW4gaGFuZGxlcnMpXG4gICAgICAgIHJlY29yZCh0eXBlKS5oYW5kbGVycy5wdXNoKGhhbmRsZXJzW3R5cGVdKTtcbiAgICBmb3IgKGxldCB0eXBlIGluIG9ic2VydmVycylcbiAgICAgICAgcmVjb3JkKHR5cGUpLm9ic2VydmVycy5wdXNoKG9ic2VydmVyc1t0eXBlXSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IFBlbmRpbmdLZXlzID0gW1xuICAgIHsga2V5OiBcIkJhY2tzcGFjZVwiLCBrZXlDb2RlOiA4LCBpbnB1dFR5cGU6IFwiZGVsZXRlQ29udGVudEJhY2t3YXJkXCIgfSxcbiAgICB7IGtleTogXCJFbnRlclwiLCBrZXlDb2RlOiAxMywgaW5wdXRUeXBlOiBcImluc2VydFBhcmFncmFwaFwiIH0sXG4gICAgeyBrZXk6IFwiRW50ZXJcIiwga2V5Q29kZTogMTMsIGlucHV0VHlwZTogXCJpbnNlcnRMaW5lQnJlYWtcIiB9LFxuICAgIHsga2V5OiBcIkRlbGV0ZVwiLCBrZXlDb2RlOiA0NiwgaW5wdXRUeXBlOiBcImRlbGV0ZUNvbnRlbnRGb3J3YXJkXCIgfVxuXTtcbmNvbnN0IEVtYWNzeVBlbmRpbmdLZXlzID0gXCJkdGhrb1wiO1xuLy8gS2V5IGNvZGVzIGZvciBtb2RpZmllciBrZXlzXG5jb25zdCBtb2RpZmllckNvZGVzID0gWzE2LCAxNywgMTgsIDIwLCA5MSwgOTIsIDIyNCwgMjI1XTtcbmNvbnN0IGRyYWdTY3JvbGxNYXJnaW4gPSA2O1xuZnVuY3Rpb24gZHJhZ1Njcm9sbFNwZWVkKGRpc3QpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgoMCwgZGlzdCkgKiAwLjcgKyA4O1xufVxuZnVuY3Rpb24gZGlzdChhLCBiKSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KE1hdGguYWJzKGEuY2xpZW50WCAtIGIuY2xpZW50WCksIE1hdGguYWJzKGEuY2xpZW50WSAtIGIuY2xpZW50WSkpO1xufVxuY2xhc3MgTW91c2VTZWxlY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcsIHN0YXJ0RXZlbnQsIHN0eWxlLCBtdXN0U2VsZWN0KSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuc3RhcnRFdmVudCA9IHN0YXJ0RXZlbnQ7XG4gICAgICAgIHRoaXMuc3R5bGUgPSBzdHlsZTtcbiAgICAgICAgdGhpcy5tdXN0U2VsZWN0ID0gbXVzdFNlbGVjdDtcbiAgICAgICAgdGhpcy5zY3JvbGxTcGVlZCA9IHsgeDogMCwgeTogMCB9O1xuICAgICAgICB0aGlzLnNjcm9sbGluZyA9IC0xO1xuICAgICAgICB0aGlzLmxhc3RFdmVudCA9IHN0YXJ0RXZlbnQ7XG4gICAgICAgIHRoaXMuc2Nyb2xsUGFyZW50ID0gc2Nyb2xsYWJsZVBhcmVudCh2aWV3LmNvbnRlbnRET00pO1xuICAgICAgICB0aGlzLmF0b21zID0gdmlldy5zdGF0ZS5mYWNldChhdG9taWNSYW5nZXMpLm1hcChmID0+IGYodmlldykpO1xuICAgICAgICBsZXQgZG9jID0gdmlldy5jb250ZW50RE9NLm93bmVyRG9jdW1lbnQ7XG4gICAgICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMubW92ZSA9IHRoaXMubW92ZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHRoaXMudXAgPSB0aGlzLnVwLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmV4dGVuZCA9IHN0YXJ0RXZlbnQuc2hpZnRLZXk7XG4gICAgICAgIHRoaXMubXVsdGlwbGUgPSB2aWV3LnN0YXRlLmZhY2V0KEVkaXRvclN0YXRlLmFsbG93TXVsdGlwbGVTZWxlY3Rpb25zKSAmJiBhZGRzU2VsZWN0aW9uUmFuZ2Uodmlldywgc3RhcnRFdmVudCk7XG4gICAgICAgIHRoaXMuZHJhZ2dpbmcgPSBpc0luUHJpbWFyeVNlbGVjdGlvbih2aWV3LCBzdGFydEV2ZW50KSAmJiBnZXRDbGlja1R5cGUoc3RhcnRFdmVudCkgPT0gMSA/IG51bGwgOiBmYWxzZTtcbiAgICB9XG4gICAgc3RhcnQoZXZlbnQpIHtcbiAgICAgICAgLy8gV2hlbiBjbGlja2luZyBvdXRzaWRlIG9mIHRoZSBzZWxlY3Rpb24sIGltbWVkaWF0ZWx5IGFwcGx5IHRoZVxuICAgICAgICAvLyBlZmZlY3Qgb2Ygc3RhcnRpbmcgdGhlIHNlbGVjdGlvblxuICAgICAgICBpZiAodGhpcy5kcmFnZ2luZyA9PT0gZmFsc2UpXG4gICAgICAgICAgICB0aGlzLnNlbGVjdChldmVudCk7XG4gICAgfVxuICAgIG1vdmUoZXZlbnQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoZXZlbnQuYnV0dG9ucyA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICBpZiAodGhpcy5kcmFnZ2luZyB8fCB0aGlzLmRyYWdnaW5nID09IG51bGwgJiYgZGlzdCh0aGlzLnN0YXJ0RXZlbnQsIGV2ZW50KSA8IDEwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLnNlbGVjdCh0aGlzLmxhc3RFdmVudCA9IGV2ZW50KTtcbiAgICAgICAgbGV0IHN4ID0gMCwgc3kgPSAwO1xuICAgICAgICBsZXQgcmVjdCA9ICgoX2EgPSB0aGlzLnNjcm9sbFBhcmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKVxuICAgICAgICAgICAgfHwgeyBsZWZ0OiAwLCB0b3A6IDAsIHJpZ2h0OiB0aGlzLnZpZXcud2luLmlubmVyV2lkdGgsIGJvdHRvbTogdGhpcy52aWV3Lndpbi5pbm5lckhlaWdodCB9O1xuICAgICAgICBsZXQgbWFyZ2lucyA9IGdldFNjcm9sbE1hcmdpbnModGhpcy52aWV3KTtcbiAgICAgICAgaWYgKGV2ZW50LmNsaWVudFggLSBtYXJnaW5zLmxlZnQgPD0gcmVjdC5sZWZ0ICsgZHJhZ1Njcm9sbE1hcmdpbilcbiAgICAgICAgICAgIHN4ID0gLWRyYWdTY3JvbGxTcGVlZChyZWN0LmxlZnQgLSBldmVudC5jbGllbnRYKTtcbiAgICAgICAgZWxzZSBpZiAoZXZlbnQuY2xpZW50WCArIG1hcmdpbnMucmlnaHQgPj0gcmVjdC5yaWdodCAtIGRyYWdTY3JvbGxNYXJnaW4pXG4gICAgICAgICAgICBzeCA9IGRyYWdTY3JvbGxTcGVlZChldmVudC5jbGllbnRYIC0gcmVjdC5yaWdodCk7XG4gICAgICAgIGlmIChldmVudC5jbGllbnRZIC0gbWFyZ2lucy50b3AgPD0gcmVjdC50b3AgKyBkcmFnU2Nyb2xsTWFyZ2luKVxuICAgICAgICAgICAgc3kgPSAtZHJhZ1Njcm9sbFNwZWVkKHJlY3QudG9wIC0gZXZlbnQuY2xpZW50WSk7XG4gICAgICAgIGVsc2UgaWYgKGV2ZW50LmNsaWVudFkgKyBtYXJnaW5zLmJvdHRvbSA+PSByZWN0LmJvdHRvbSAtIGRyYWdTY3JvbGxNYXJnaW4pXG4gICAgICAgICAgICBzeSA9IGRyYWdTY3JvbGxTcGVlZChldmVudC5jbGllbnRZIC0gcmVjdC5ib3R0b20pO1xuICAgICAgICB0aGlzLnNldFNjcm9sbFNwZWVkKHN4LCBzeSk7XG4gICAgfVxuICAgIHVwKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmRyYWdnaW5nID09IG51bGwpXG4gICAgICAgICAgICB0aGlzLnNlbGVjdCh0aGlzLmxhc3RFdmVudCk7XG4gICAgICAgIGlmICghdGhpcy5kcmFnZ2luZylcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnNldFNjcm9sbFNwZWVkKDAsIDApO1xuICAgICAgICBsZXQgZG9jID0gdGhpcy52aWV3LmNvbnRlbnRET00ub3duZXJEb2N1bWVudDtcbiAgICAgICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy5tb3ZlKTtcbiAgICAgICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHRoaXMudXApO1xuICAgICAgICB0aGlzLnZpZXcuaW5wdXRTdGF0ZS5tb3VzZVNlbGVjdGlvbiA9IHRoaXMudmlldy5pbnB1dFN0YXRlLmRyYWdnZWRDb250ZW50ID0gbnVsbDtcbiAgICB9XG4gICAgc2V0U2Nyb2xsU3BlZWQoc3gsIHN5KSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsU3BlZWQgPSB7IHg6IHN4LCB5OiBzeSB9O1xuICAgICAgICBpZiAoc3ggfHwgc3kpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNjcm9sbGluZyA8IDApXG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxpbmcgPSBzZXRJbnRlcnZhbCgoKSA9PiB0aGlzLnNjcm9sbCgpLCA1MCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5zY3JvbGxpbmcgPiAtMSkge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnNjcm9sbGluZyk7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbGluZyA9IC0xO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNjcm9sbCgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2Nyb2xsUGFyZW50KSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbFBhcmVudC5zY3JvbGxMZWZ0ICs9IHRoaXMuc2Nyb2xsU3BlZWQueDtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsUGFyZW50LnNjcm9sbFRvcCArPSB0aGlzLnNjcm9sbFNwZWVkLnk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnZpZXcud2luLnNjcm9sbEJ5KHRoaXMuc2Nyb2xsU3BlZWQueCwgdGhpcy5zY3JvbGxTcGVlZC55KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kcmFnZ2luZyA9PT0gZmFsc2UpXG4gICAgICAgICAgICB0aGlzLnNlbGVjdCh0aGlzLmxhc3RFdmVudCk7XG4gICAgfVxuICAgIHNraXBBdG9tcyhzZWwpIHtcbiAgICAgICAgbGV0IHJhbmdlcyA9IG51bGw7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VsLnJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHJhbmdlID0gc2VsLnJhbmdlc1tpXSwgdXBkYXRlZCA9IG51bGw7XG4gICAgICAgICAgICBpZiAocmFuZ2UuZW1wdHkpIHtcbiAgICAgICAgICAgICAgICBsZXQgcG9zID0gc2tpcEF0b21pY1Jhbmdlcyh0aGlzLmF0b21zLCByYW5nZS5mcm9tLCAwKTtcbiAgICAgICAgICAgICAgICBpZiAocG9zICE9IHJhbmdlLmZyb20pXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZWQgPSBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHBvcywgLTEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGZyb20gPSBza2lwQXRvbWljUmFuZ2VzKHRoaXMuYXRvbXMsIHJhbmdlLmZyb20sIC0xKTtcbiAgICAgICAgICAgICAgICBsZXQgdG8gPSBza2lwQXRvbWljUmFuZ2VzKHRoaXMuYXRvbXMsIHJhbmdlLnRvLCAxKTtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbSAhPSByYW5nZS5mcm9tIHx8IHRvICE9IHJhbmdlLnRvKVxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVkID0gRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHJhbmdlLmZyb20gPT0gcmFuZ2UuYW5jaG9yID8gZnJvbSA6IHRvLCByYW5nZS5mcm9tID09IHJhbmdlLmhlYWQgPyBmcm9tIDogdG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVwZGF0ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJhbmdlcylcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2VzID0gc2VsLnJhbmdlcy5zbGljZSgpO1xuICAgICAgICAgICAgICAgIHJhbmdlc1tpXSA9IHVwZGF0ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJhbmdlcyA/IEVkaXRvclNlbGVjdGlvbi5jcmVhdGUocmFuZ2VzLCBzZWwubWFpbkluZGV4KSA6IHNlbDtcbiAgICB9XG4gICAgc2VsZWN0KGV2ZW50KSB7XG4gICAgICAgIGxldCB7IHZpZXcgfSA9IHRoaXMsIHNlbGVjdGlvbiA9IHRoaXMuc2tpcEF0b21zKHRoaXMuc3R5bGUuZ2V0KGV2ZW50LCB0aGlzLmV4dGVuZCwgdGhpcy5tdWx0aXBsZSkpO1xuICAgICAgICBpZiAodGhpcy5tdXN0U2VsZWN0IHx8ICFzZWxlY3Rpb24uZXEodmlldy5zdGF0ZS5zZWxlY3Rpb24pIHx8XG4gICAgICAgICAgICBzZWxlY3Rpb24ubWFpbi5hc3NvYyAhPSB2aWV3LnN0YXRlLnNlbGVjdGlvbi5tYWluLmFzc29jICYmIHRoaXMuZHJhZ2dpbmcgPT09IGZhbHNlKVxuICAgICAgICAgICAgdGhpcy52aWV3LmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24sXG4gICAgICAgICAgICAgICAgdXNlckV2ZW50OiBcInNlbGVjdC5wb2ludGVyXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB0aGlzLm11c3RTZWxlY3QgPSBmYWxzZTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBpZiAodGhpcy5zdHlsZS51cGRhdGUodXBkYXRlKSlcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5zZWxlY3QodGhpcy5sYXN0RXZlbnQpLCAyMCk7XG4gICAgfVxufVxuZnVuY3Rpb24gYWRkc1NlbGVjdGlvblJhbmdlKHZpZXcsIGV2ZW50KSB7XG4gICAgbGV0IGZhY2V0ID0gdmlldy5zdGF0ZS5mYWNldChjbGlja0FkZHNTZWxlY3Rpb25SYW5nZSk7XG4gICAgcmV0dXJuIGZhY2V0Lmxlbmd0aCA/IGZhY2V0WzBdKGV2ZW50KSA6IGJyb3dzZXIubWFjID8gZXZlbnQubWV0YUtleSA6IGV2ZW50LmN0cmxLZXk7XG59XG5mdW5jdGlvbiBkcmFnTW92ZXNTZWxlY3Rpb24odmlldywgZXZlbnQpIHtcbiAgICBsZXQgZmFjZXQgPSB2aWV3LnN0YXRlLmZhY2V0KGRyYWdNb3Zlc1NlbGVjdGlvbiQxKTtcbiAgICByZXR1cm4gZmFjZXQubGVuZ3RoID8gZmFjZXRbMF0oZXZlbnQpIDogYnJvd3Nlci5tYWMgPyAhZXZlbnQuYWx0S2V5IDogIWV2ZW50LmN0cmxLZXk7XG59XG5mdW5jdGlvbiBpc0luUHJpbWFyeVNlbGVjdGlvbih2aWV3LCBldmVudCkge1xuICAgIGxldCB7IG1haW4gfSA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICAgIGlmIChtYWluLmVtcHR5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgLy8gT24gYm91bmRhcnkgY2xpY2tzLCBjaGVjayB3aGV0aGVyIHRoZSBjb29yZGluYXRlcyBhcmUgaW5zaWRlIHRoZVxuICAgIC8vIHNlbGVjdGlvbidzIGNsaWVudCByZWN0YW5nbGVzXG4gICAgbGV0IHNlbCA9IGdldFNlbGVjdGlvbih2aWV3LnJvb3QpO1xuICAgIGlmICghc2VsIHx8IHNlbC5yYW5nZUNvdW50ID09IDApXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGxldCByZWN0cyA9IHNlbC5nZXRSYW5nZUF0KDApLmdldENsaWVudFJlY3RzKCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgcmVjdCA9IHJlY3RzW2ldO1xuICAgICAgICBpZiAocmVjdC5sZWZ0IDw9IGV2ZW50LmNsaWVudFggJiYgcmVjdC5yaWdodCA+PSBldmVudC5jbGllbnRYICYmXG4gICAgICAgICAgICByZWN0LnRvcCA8PSBldmVudC5jbGllbnRZICYmIHJlY3QuYm90dG9tID49IGV2ZW50LmNsaWVudFkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZXZlbnRCZWxvbmdzVG9FZGl0b3IodmlldywgZXZlbnQpIHtcbiAgICBpZiAoIWV2ZW50LmJ1YmJsZXMpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgbm9kZSA9IGV2ZW50LnRhcmdldCwgY1ZpZXc7IG5vZGUgIT0gdmlldy5jb250ZW50RE9NOyBub2RlID0gbm9kZS5wYXJlbnROb2RlKVxuICAgICAgICBpZiAoIW5vZGUgfHwgbm9kZS5ub2RlVHlwZSA9PSAxMSB8fCAoKGNWaWV3ID0gQ29udGVudFZpZXcuZ2V0KG5vZGUpKSAmJiBjVmlldy5pZ25vcmVFdmVudChldmVudCkpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufVxuY29uc3QgaGFuZGxlcnMgPSAvKkBfX1BVUkVfXyovT2JqZWN0LmNyZWF0ZShudWxsKTtcbmNvbnN0IG9ic2VydmVycyA9IC8qQF9fUFVSRV9fKi9PYmplY3QuY3JlYXRlKG51bGwpO1xuLy8gVGhpcyBpcyB2ZXJ5IGNydWRlLCBidXQgdW5mb3J0dW5hdGVseSBib3RoIHRoZXNlIGJyb3dzZXJzIF9wcmV0ZW5kX1xuLy8gdGhhdCB0aGV5IGhhdmUgYSBjbGlwYm9hcmQgQVBJ4oCUYWxsIHRoZSBvYmplY3RzIGFuZCBtZXRob2RzIGFyZVxuLy8gdGhlcmUsIHRoZXkganVzdCBkb24ndCB3b3JrLCBhbmQgdGhleSBhcmUgaGFyZCB0byB0ZXN0LlxuY29uc3QgYnJva2VuQ2xpcGJvYXJkQVBJID0gKGJyb3dzZXIuaWUgJiYgYnJvd3Nlci5pZV92ZXJzaW9uIDwgMTUpIHx8XG4gICAgKGJyb3dzZXIuaW9zICYmIGJyb3dzZXIud2Via2l0X3ZlcnNpb24gPCA2MDQpO1xuZnVuY3Rpb24gY2FwdHVyZVBhc3RlKHZpZXcpIHtcbiAgICBsZXQgcGFyZW50ID0gdmlldy5kb20ucGFyZW50Tm9kZTtcbiAgICBpZiAoIXBhcmVudClcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCB0YXJnZXQgPSBwYXJlbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRleHRhcmVhXCIpKTtcbiAgICB0YXJnZXQuc3R5bGUuY3NzVGV4dCA9IFwicG9zaXRpb246IGZpeGVkOyBsZWZ0OiAtMTAwMDBweDsgdG9wOiAxMHB4XCI7XG4gICAgdGFyZ2V0LmZvY3VzKCk7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHZpZXcuZm9jdXMoKTtcbiAgICAgICAgdGFyZ2V0LnJlbW92ZSgpO1xuICAgICAgICBkb1Bhc3RlKHZpZXcsIHRhcmdldC52YWx1ZSk7XG4gICAgfSwgNTApO1xufVxuZnVuY3Rpb24gZG9QYXN0ZSh2aWV3LCBpbnB1dCkge1xuICAgIGxldCB7IHN0YXRlIH0gPSB2aWV3LCBjaGFuZ2VzLCBpID0gMSwgdGV4dCA9IHN0YXRlLnRvVGV4dChpbnB1dCk7XG4gICAgbGV0IGJ5TGluZSA9IHRleHQubGluZXMgPT0gc3RhdGUuc2VsZWN0aW9uLnJhbmdlcy5sZW5ndGg7XG4gICAgbGV0IGxpbmV3aXNlID0gbGFzdExpbmV3aXNlQ29weSAhPSBudWxsICYmIHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMuZXZlcnkociA9PiByLmVtcHR5KSAmJiBsYXN0TGluZXdpc2VDb3B5ID09IHRleHQudG9TdHJpbmcoKTtcbiAgICBpZiAobGluZXdpc2UpIHtcbiAgICAgICAgbGV0IGxhc3RMaW5lID0gLTE7XG4gICAgICAgIGNoYW5nZXMgPSBzdGF0ZS5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+IHtcbiAgICAgICAgICAgIGxldCBsaW5lID0gc3RhdGUuZG9jLmxpbmVBdChyYW5nZS5mcm9tKTtcbiAgICAgICAgICAgIGlmIChsaW5lLmZyb20gPT0gbGFzdExpbmUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgcmFuZ2UgfTtcbiAgICAgICAgICAgIGxhc3RMaW5lID0gbGluZS5mcm9tO1xuICAgICAgICAgICAgbGV0IGluc2VydCA9IHN0YXRlLnRvVGV4dCgoYnlMaW5lID8gdGV4dC5saW5lKGkrKykudGV4dCA6IGlucHV0KSArIHN0YXRlLmxpbmVCcmVhayk7XG4gICAgICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiB7IGZyb206IGxpbmUuZnJvbSwgaW5zZXJ0IH0sXG4gICAgICAgICAgICAgICAgcmFuZ2U6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocmFuZ2UuZnJvbSArIGluc2VydC5sZW5ndGgpIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChieUxpbmUpIHtcbiAgICAgICAgY2hhbmdlcyA9IHN0YXRlLmNoYW5nZUJ5UmFuZ2UocmFuZ2UgPT4ge1xuICAgICAgICAgICAgbGV0IGxpbmUgPSB0ZXh0LmxpbmUoaSsrKTtcbiAgICAgICAgICAgIHJldHVybiB7IGNoYW5nZXM6IHsgZnJvbTogcmFuZ2UuZnJvbSwgdG86IHJhbmdlLnRvLCBpbnNlcnQ6IGxpbmUudGV4dCB9LFxuICAgICAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHJhbmdlLmZyb20gKyBsaW5lLmxlbmd0aCkgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjaGFuZ2VzID0gc3RhdGUucmVwbGFjZVNlbGVjdGlvbih0ZXh0KTtcbiAgICB9XG4gICAgdmlldy5kaXNwYXRjaChjaGFuZ2VzLCB7XG4gICAgICAgIHVzZXJFdmVudDogXCJpbnB1dC5wYXN0ZVwiLFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogdHJ1ZVxuICAgIH0pO1xufVxub2JzZXJ2ZXJzLnNjcm9sbCA9IHZpZXcgPT4ge1xuICAgIHZpZXcuaW5wdXRTdGF0ZS5sYXN0U2Nyb2xsVG9wID0gdmlldy5zY3JvbGxET00uc2Nyb2xsVG9wO1xuICAgIHZpZXcuaW5wdXRTdGF0ZS5sYXN0U2Nyb2xsTGVmdCA9IHZpZXcuc2Nyb2xsRE9NLnNjcm9sbExlZnQ7XG59O1xuaGFuZGxlcnMua2V5ZG93biA9ICh2aWV3LCBldmVudCkgPT4ge1xuICAgIHZpZXcuaW5wdXRTdGF0ZS5zZXRTZWxlY3Rpb25PcmlnaW4oXCJzZWxlY3RcIik7XG4gICAgaWYgKGV2ZW50LmtleUNvZGUgPT0gMjcpXG4gICAgICAgIHZpZXcuaW5wdXRTdGF0ZS5sYXN0RXNjUHJlc3MgPSBEYXRlLm5vdygpO1xuICAgIHJldHVybiBmYWxzZTtcbn07XG5vYnNlcnZlcnMudG91Y2hzdGFydCA9ICh2aWV3LCBlKSA9PiB7XG4gICAgdmlldy5pbnB1dFN0YXRlLmxhc3RUb3VjaFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIHZpZXcuaW5wdXRTdGF0ZS5zZXRTZWxlY3Rpb25PcmlnaW4oXCJzZWxlY3QucG9pbnRlclwiKTtcbn07XG5vYnNlcnZlcnMudG91Y2htb3ZlID0gdmlldyA9PiB7XG4gICAgdmlldy5pbnB1dFN0YXRlLnNldFNlbGVjdGlvbk9yaWdpbihcInNlbGVjdC5wb2ludGVyXCIpO1xufTtcbmhhbmRsZXJzLm1vdXNlZG93biA9ICh2aWV3LCBldmVudCkgPT4ge1xuICAgIHZpZXcub2JzZXJ2ZXIuZmx1c2goKTtcbiAgICBpZiAodmlldy5pbnB1dFN0YXRlLmxhc3RUb3VjaFRpbWUgPiBEYXRlLm5vdygpIC0gMjAwMClcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBJZ25vcmUgdG91Y2ggaW50ZXJhY3Rpb25cbiAgICBsZXQgc3R5bGUgPSBudWxsO1xuICAgIGZvciAobGV0IG1ha2VTdHlsZSBvZiB2aWV3LnN0YXRlLmZhY2V0KG1vdXNlU2VsZWN0aW9uU3R5bGUpKSB7XG4gICAgICAgIHN0eWxlID0gbWFrZVN0eWxlKHZpZXcsIGV2ZW50KTtcbiAgICAgICAgaWYgKHN0eWxlKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmICghc3R5bGUgJiYgZXZlbnQuYnV0dG9uID09IDApXG4gICAgICAgIHN0eWxlID0gYmFzaWNNb3VzZVNlbGVjdGlvbih2aWV3LCBldmVudCk7XG4gICAgaWYgKHN0eWxlKSB7XG4gICAgICAgIGxldCBtdXN0Rm9jdXMgPSAhdmlldy5oYXNGb2N1cztcbiAgICAgICAgdmlldy5pbnB1dFN0YXRlLnN0YXJ0TW91c2VTZWxlY3Rpb24obmV3IE1vdXNlU2VsZWN0aW9uKHZpZXcsIGV2ZW50LCBzdHlsZSwgbXVzdEZvY3VzKSk7XG4gICAgICAgIGlmIChtdXN0Rm9jdXMpXG4gICAgICAgICAgICB2aWV3Lm9ic2VydmVyLmlnbm9yZSgoKSA9PiBmb2N1c1ByZXZlbnRTY3JvbGwodmlldy5jb250ZW50RE9NKSk7XG4gICAgICAgIGxldCBtb3VzZVNlbCA9IHZpZXcuaW5wdXRTdGF0ZS5tb3VzZVNlbGVjdGlvbjtcbiAgICAgICAgaWYgKG1vdXNlU2VsKSB7XG4gICAgICAgICAgICBtb3VzZVNlbC5zdGFydChldmVudCk7XG4gICAgICAgICAgICByZXR1cm4gbW91c2VTZWwuZHJhZ2dpbmcgPT09IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5mdW5jdGlvbiByYW5nZUZvckNsaWNrKHZpZXcsIHBvcywgYmlhcywgdHlwZSkge1xuICAgIGlmICh0eXBlID09IDEpIHsgLy8gU2luZ2xlIGNsaWNrXG4gICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHBvcywgYmlhcyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT0gMikgeyAvLyBEb3VibGUgY2xpY2tcbiAgICAgICAgcmV0dXJuIGdyb3VwQXQodmlldy5zdGF0ZSwgcG9zLCBiaWFzKTtcbiAgICB9XG4gICAgZWxzZSB7IC8vIFRyaXBsZSBjbGlja1xuICAgICAgICBsZXQgdmlzdWFsID0gTGluZVZpZXcuZmluZCh2aWV3LmRvY1ZpZXcsIHBvcyksIGxpbmUgPSB2aWV3LnN0YXRlLmRvYy5saW5lQXQodmlzdWFsID8gdmlzdWFsLnBvc0F0RW5kIDogcG9zKTtcbiAgICAgICAgbGV0IGZyb20gPSB2aXN1YWwgPyB2aXN1YWwucG9zQXRTdGFydCA6IGxpbmUuZnJvbSwgdG8gPSB2aXN1YWwgPyB2aXN1YWwucG9zQXRFbmQgOiBsaW5lLnRvO1xuICAgICAgICBpZiAodG8gPCB2aWV3LnN0YXRlLmRvYy5sZW5ndGggJiYgdG8gPT0gbGluZS50bylcbiAgICAgICAgICAgIHRvKys7XG4gICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UoZnJvbSwgdG8pO1xuICAgIH1cbn1cbmxldCBpbnNpZGVZID0gKHksIHJlY3QpID0+IHkgPj0gcmVjdC50b3AgJiYgeSA8PSByZWN0LmJvdHRvbTtcbmxldCBpbnNpZGUgPSAoeCwgeSwgcmVjdCkgPT4gaW5zaWRlWSh5LCByZWN0KSAmJiB4ID49IHJlY3QubGVmdCAmJiB4IDw9IHJlY3QucmlnaHQ7XG4vLyBUcnkgdG8gZGV0ZXJtaW5lLCBmb3IgdGhlIGdpdmVuIGNvb3JkaW5hdGVzLCBhc3NvY2lhdGVkIHdpdGggdGhlXG4vLyBnaXZlbiBwb3NpdGlvbiwgd2hldGhlciB0aGV5IGFyZSByZWxhdGVkIHRvIHRoZSBlbGVtZW50IGJlZm9yZSBvclxuLy8gdGhlIGVsZW1lbnQgYWZ0ZXIgdGhlIHBvc2l0aW9uLlxuZnVuY3Rpb24gZmluZFBvc2l0aW9uU2lkZSh2aWV3LCBwb3MsIHgsIHkpIHtcbiAgICBsZXQgbGluZSA9IExpbmVWaWV3LmZpbmQodmlldy5kb2NWaWV3LCBwb3MpO1xuICAgIGlmICghbGluZSlcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgbGV0IG9mZiA9IHBvcyAtIGxpbmUucG9zQXRTdGFydDtcbiAgICAvLyBMaW5lIGJvdW5kYXJpZXMgcG9pbnQgaW50byB0aGUgbGluZVxuICAgIGlmIChvZmYgPT0gMClcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgaWYgKG9mZiA9PSBsaW5lLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIC8vIFBvc2l0aW9ucyBvbiB0b3Agb2YgYW4gZWxlbWVudCBwb2ludCBhdCB0aGF0IGVsZW1lbnRcbiAgICBsZXQgYmVmb3JlID0gbGluZS5jb29yZHNBdChvZmYsIC0xKTtcbiAgICBpZiAoYmVmb3JlICYmIGluc2lkZSh4LCB5LCBiZWZvcmUpKVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgbGV0IGFmdGVyID0gbGluZS5jb29yZHNBdChvZmYsIDEpO1xuICAgIGlmIChhZnRlciAmJiBpbnNpZGUoeCwgeSwgYWZ0ZXIpKVxuICAgICAgICByZXR1cm4gMTtcbiAgICAvLyBUaGlzIGlzIHByb2JhYmx5IGEgbGluZSB3cmFwIHBvaW50LiBQaWNrIGJlZm9yZSBpZiB0aGUgcG9pbnQgaXNcbiAgICAvLyBiZXNpZGUgaXQuXG4gICAgcmV0dXJuIGJlZm9yZSAmJiBpbnNpZGVZKHksIGJlZm9yZSkgPyAtMSA6IDE7XG59XG5mdW5jdGlvbiBxdWVyeVBvcyh2aWV3LCBldmVudCkge1xuICAgIGxldCBwb3MgPSB2aWV3LnBvc0F0Q29vcmRzKHsgeDogZXZlbnQuY2xpZW50WCwgeTogZXZlbnQuY2xpZW50WSB9LCBmYWxzZSk7XG4gICAgcmV0dXJuIHsgcG9zLCBiaWFzOiBmaW5kUG9zaXRpb25TaWRlKHZpZXcsIHBvcywgZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSkgfTtcbn1cbmNvbnN0IEJhZE1vdXNlRGV0YWlsID0gYnJvd3Nlci5pZSAmJiBicm93c2VyLmllX3ZlcnNpb24gPD0gMTE7XG5sZXQgbGFzdE1vdXNlRG93biA9IG51bGwsIGxhc3RNb3VzZURvd25Db3VudCA9IDAsIGxhc3RNb3VzZURvd25UaW1lID0gMDtcbmZ1bmN0aW9uIGdldENsaWNrVHlwZShldmVudCkge1xuICAgIGlmICghQmFkTW91c2VEZXRhaWwpXG4gICAgICAgIHJldHVybiBldmVudC5kZXRhaWw7XG4gICAgbGV0IGxhc3QgPSBsYXN0TW91c2VEb3duLCBsYXN0VGltZSA9IGxhc3RNb3VzZURvd25UaW1lO1xuICAgIGxhc3RNb3VzZURvd24gPSBldmVudDtcbiAgICBsYXN0TW91c2VEb3duVGltZSA9IERhdGUubm93KCk7XG4gICAgcmV0dXJuIGxhc3RNb3VzZURvd25Db3VudCA9ICFsYXN0IHx8IChsYXN0VGltZSA+IERhdGUubm93KCkgLSA0MDAgJiYgTWF0aC5hYnMobGFzdC5jbGllbnRYIC0gZXZlbnQuY2xpZW50WCkgPCAyICYmXG4gICAgICAgIE1hdGguYWJzKGxhc3QuY2xpZW50WSAtIGV2ZW50LmNsaWVudFkpIDwgMikgPyAobGFzdE1vdXNlRG93bkNvdW50ICsgMSkgJSAzIDogMTtcbn1cbmZ1bmN0aW9uIGJhc2ljTW91c2VTZWxlY3Rpb24odmlldywgZXZlbnQpIHtcbiAgICBsZXQgc3RhcnQgPSBxdWVyeVBvcyh2aWV3LCBldmVudCksIHR5cGUgPSBnZXRDbGlja1R5cGUoZXZlbnQpO1xuICAgIGxldCBzdGFydFNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICAgIHJldHVybiB7XG4gICAgICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgICAgIGlmICh1cGRhdGUuZG9jQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0LnBvcyA9IHVwZGF0ZS5jaGFuZ2VzLm1hcFBvcyhzdGFydC5wb3MpO1xuICAgICAgICAgICAgICAgIHN0YXJ0U2VsID0gc3RhcnRTZWwubWFwKHVwZGF0ZS5jaGFuZ2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZ2V0KGV2ZW50LCBleHRlbmQsIG11bHRpcGxlKSB7XG4gICAgICAgICAgICBsZXQgY3VyID0gcXVlcnlQb3ModmlldywgZXZlbnQpLCByZW1vdmVkO1xuICAgICAgICAgICAgbGV0IHJhbmdlID0gcmFuZ2VGb3JDbGljayh2aWV3LCBjdXIucG9zLCBjdXIuYmlhcywgdHlwZSk7XG4gICAgICAgICAgICBpZiAoc3RhcnQucG9zICE9IGN1ci5wb3MgJiYgIWV4dGVuZCkge1xuICAgICAgICAgICAgICAgIGxldCBzdGFydFJhbmdlID0gcmFuZ2VGb3JDbGljayh2aWV3LCBzdGFydC5wb3MsIHN0YXJ0LmJpYXMsIHR5cGUpO1xuICAgICAgICAgICAgICAgIGxldCBmcm9tID0gTWF0aC5taW4oc3RhcnRSYW5nZS5mcm9tLCByYW5nZS5mcm9tKSwgdG8gPSBNYXRoLm1heChzdGFydFJhbmdlLnRvLCByYW5nZS50byk7XG4gICAgICAgICAgICAgICAgcmFuZ2UgPSBmcm9tIDwgcmFuZ2UuZnJvbSA/IEVkaXRvclNlbGVjdGlvbi5yYW5nZShmcm9tLCB0bykgOiBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UodG8sIGZyb20pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV4dGVuZClcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnRTZWwucmVwbGFjZVJhbmdlKHN0YXJ0U2VsLm1haW4uZXh0ZW5kKHJhbmdlLmZyb20sIHJhbmdlLnRvKSk7XG4gICAgICAgICAgICBlbHNlIGlmIChtdWx0aXBsZSAmJiB0eXBlID09IDEgJiYgc3RhcnRTZWwucmFuZ2VzLmxlbmd0aCA+IDEgJiYgKHJlbW92ZWQgPSByZW1vdmVSYW5nZUFyb3VuZChzdGFydFNlbCwgY3VyLnBvcykpKVxuICAgICAgICAgICAgICAgIHJldHVybiByZW1vdmVkO1xuICAgICAgICAgICAgZWxzZSBpZiAobXVsdGlwbGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXJ0U2VsLmFkZFJhbmdlKHJhbmdlKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShbcmFuZ2VdKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiByZW1vdmVSYW5nZUFyb3VuZChzZWwsIHBvcykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VsLnJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgeyBmcm9tLCB0byB9ID0gc2VsLnJhbmdlc1tpXTtcbiAgICAgICAgaWYgKGZyb20gPD0gcG9zICYmIHRvID49IHBvcylcbiAgICAgICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKHNlbC5yYW5nZXMuc2xpY2UoMCwgaSkuY29uY2F0KHNlbC5yYW5nZXMuc2xpY2UoaSArIDEpKSwgc2VsLm1haW5JbmRleCA9PSBpID8gMCA6IHNlbC5tYWluSW5kZXggLSAoc2VsLm1haW5JbmRleCA+IGkgPyAxIDogMCkpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmhhbmRsZXJzLmRyYWdzdGFydCA9ICh2aWV3LCBldmVudCkgPT4ge1xuICAgIGxldCB7IHNlbGVjdGlvbjogeyBtYWluOiByYW5nZSB9IH0gPSB2aWV3LnN0YXRlO1xuICAgIGlmIChldmVudC50YXJnZXQuZHJhZ2dhYmxlKSB7XG4gICAgICAgIGxldCBjVmlldyA9IHZpZXcuZG9jVmlldy5uZWFyZXN0KGV2ZW50LnRhcmdldCk7XG4gICAgICAgIGlmIChjVmlldyAmJiBjVmlldy5pc1dpZGdldCkge1xuICAgICAgICAgICAgbGV0IGZyb20gPSBjVmlldy5wb3NBdFN0YXJ0LCB0byA9IGZyb20gKyBjVmlldy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoZnJvbSA+PSByYW5nZS50byB8fCB0byA8PSByYW5nZS5mcm9tKVxuICAgICAgICAgICAgICAgIHJhbmdlID0gRWRpdG9yU2VsZWN0aW9uLnJhbmdlKGZyb20sIHRvKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgeyBpbnB1dFN0YXRlIH0gPSB2aWV3O1xuICAgIGlmIChpbnB1dFN0YXRlLm1vdXNlU2VsZWN0aW9uKVxuICAgICAgICBpbnB1dFN0YXRlLm1vdXNlU2VsZWN0aW9uLmRyYWdnaW5nID0gdHJ1ZTtcbiAgICBpbnB1dFN0YXRlLmRyYWdnZWRDb250ZW50ID0gcmFuZ2U7XG4gICAgaWYgKGV2ZW50LmRhdGFUcmFuc2Zlcikge1xuICAgICAgICBldmVudC5kYXRhVHJhbnNmZXIuc2V0RGF0YShcIlRleHRcIiwgdmlldy5zdGF0ZS5zbGljZURvYyhyYW5nZS5mcm9tLCByYW5nZS50bykpO1xuICAgICAgICBldmVudC5kYXRhVHJhbnNmZXIuZWZmZWN0QWxsb3dlZCA9IFwiY29weU1vdmVcIjtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbmhhbmRsZXJzLmRyYWdlbmQgPSB2aWV3ID0+IHtcbiAgICB2aWV3LmlucHV0U3RhdGUuZHJhZ2dlZENvbnRlbnQgPSBudWxsO1xuICAgIHJldHVybiBmYWxzZTtcbn07XG5mdW5jdGlvbiBkcm9wVGV4dCh2aWV3LCBldmVudCwgdGV4dCwgZGlyZWN0KSB7XG4gICAgaWYgKCF0ZXh0KVxuICAgICAgICByZXR1cm47XG4gICAgbGV0IGRyb3BQb3MgPSB2aWV3LnBvc0F0Q29vcmRzKHsgeDogZXZlbnQuY2xpZW50WCwgeTogZXZlbnQuY2xpZW50WSB9LCBmYWxzZSk7XG4gICAgbGV0IHsgZHJhZ2dlZENvbnRlbnQgfSA9IHZpZXcuaW5wdXRTdGF0ZTtcbiAgICBsZXQgZGVsID0gZGlyZWN0ICYmIGRyYWdnZWRDb250ZW50ICYmIGRyYWdNb3Zlc1NlbGVjdGlvbih2aWV3LCBldmVudClcbiAgICAgICAgPyB7IGZyb206IGRyYWdnZWRDb250ZW50LmZyb20sIHRvOiBkcmFnZ2VkQ29udGVudC50byB9IDogbnVsbDtcbiAgICBsZXQgaW5zID0geyBmcm9tOiBkcm9wUG9zLCBpbnNlcnQ6IHRleHQgfTtcbiAgICBsZXQgY2hhbmdlcyA9IHZpZXcuc3RhdGUuY2hhbmdlcyhkZWwgPyBbZGVsLCBpbnNdIDogaW5zKTtcbiAgICB2aWV3LmZvY3VzKCk7XG4gICAgdmlldy5kaXNwYXRjaCh7XG4gICAgICAgIGNoYW5nZXMsXG4gICAgICAgIHNlbGVjdGlvbjogeyBhbmNob3I6IGNoYW5nZXMubWFwUG9zKGRyb3BQb3MsIC0xKSwgaGVhZDogY2hhbmdlcy5tYXBQb3MoZHJvcFBvcywgMSkgfSxcbiAgICAgICAgdXNlckV2ZW50OiBkZWwgPyBcIm1vdmUuZHJvcFwiIDogXCJpbnB1dC5kcm9wXCJcbiAgICB9KTtcbiAgICB2aWV3LmlucHV0U3RhdGUuZHJhZ2dlZENvbnRlbnQgPSBudWxsO1xufVxuaGFuZGxlcnMuZHJvcCA9ICh2aWV3LCBldmVudCkgPT4ge1xuICAgIGlmICghZXZlbnQuZGF0YVRyYW5zZmVyKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHZpZXcuc3RhdGUucmVhZE9ubHkpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGxldCBmaWxlcyA9IGV2ZW50LmRhdGFUcmFuc2Zlci5maWxlcztcbiAgICBpZiAoZmlsZXMgJiYgZmlsZXMubGVuZ3RoKSB7IC8vIEZvciBhIGZpbGUgZHJvcCwgcmVhZCB0aGUgZmlsZSdzIHRleHQuXG4gICAgICAgIGxldCB0ZXh0ID0gQXJyYXkoZmlsZXMubGVuZ3RoKSwgcmVhZCA9IDA7XG4gICAgICAgIGxldCBmaW5pc2hGaWxlID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCsrcmVhZCA9PSBmaWxlcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgZHJvcFRleHQodmlldywgZXZlbnQsIHRleHQuZmlsdGVyKHMgPT4gcyAhPSBudWxsKS5qb2luKHZpZXcuc3RhdGUubGluZUJyZWFrKSwgZmFsc2UpO1xuICAgICAgICB9O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXI7XG4gICAgICAgICAgICByZWFkZXIub25lcnJvciA9IGZpbmlzaEZpbGU7XG4gICAgICAgICAgICByZWFkZXIub25sb2FkID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghL1tcXHgwMC1cXHgwOFxceDBlLVxceDFmXXsyfS8udGVzdChyZWFkZXIucmVzdWx0KSlcbiAgICAgICAgICAgICAgICAgICAgdGV4dFtpXSA9IHJlYWRlci5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgZmluaXNoRmlsZSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlYWRlci5yZWFkQXNUZXh0KGZpbGVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCB0ZXh0ID0gZXZlbnQuZGF0YVRyYW5zZmVyLmdldERhdGEoXCJUZXh0XCIpO1xuICAgICAgICBpZiAodGV4dCkge1xuICAgICAgICAgICAgZHJvcFRleHQodmlldywgZXZlbnQsIHRleHQsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbmhhbmRsZXJzLnBhc3RlID0gKHZpZXcsIGV2ZW50KSA9PiB7XG4gICAgaWYgKHZpZXcuc3RhdGUucmVhZE9ubHkpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIHZpZXcub2JzZXJ2ZXIuZmx1c2goKTtcbiAgICBsZXQgZGF0YSA9IGJyb2tlbkNsaXBib2FyZEFQSSA/IG51bGwgOiBldmVudC5jbGlwYm9hcmREYXRhO1xuICAgIGlmIChkYXRhKSB7XG4gICAgICAgIGRvUGFzdGUodmlldywgZGF0YS5nZXREYXRhKFwidGV4dC9wbGFpblwiKSB8fCBkYXRhLmdldERhdGEoXCJ0ZXh0L3VyaS10ZXh0XCIpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjYXB0dXJlUGFzdGUodmlldyk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59O1xuZnVuY3Rpb24gY2FwdHVyZUNvcHkodmlldywgdGV4dCkge1xuICAgIC8vIFRoZSBleHRyYSB3cmFwcGVyIGlzIHNvbWVob3cgbmVjZXNzYXJ5IG9uIElFL0VkZ2UgdG8gcHJldmVudCB0aGVcbiAgICAvLyBjb250ZW50IGZyb20gYmVpbmcgbWFuZ2xlZCB3aGVuIGl0IGlzIHB1dCBvbnRvIHRoZSBjbGlwYm9hcmRcbiAgICBsZXQgcGFyZW50ID0gdmlldy5kb20ucGFyZW50Tm9kZTtcbiAgICBpZiAoIXBhcmVudClcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCB0YXJnZXQgPSBwYXJlbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRleHRhcmVhXCIpKTtcbiAgICB0YXJnZXQuc3R5bGUuY3NzVGV4dCA9IFwicG9zaXRpb246IGZpeGVkOyBsZWZ0OiAtMTAwMDBweDsgdG9wOiAxMHB4XCI7XG4gICAgdGFyZ2V0LnZhbHVlID0gdGV4dDtcbiAgICB0YXJnZXQuZm9jdXMoKTtcbiAgICB0YXJnZXQuc2VsZWN0aW9uRW5kID0gdGV4dC5sZW5ndGg7XG4gICAgdGFyZ2V0LnNlbGVjdGlvblN0YXJ0ID0gMDtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGFyZ2V0LnJlbW92ZSgpO1xuICAgICAgICB2aWV3LmZvY3VzKCk7XG4gICAgfSwgNTApO1xufVxuZnVuY3Rpb24gY29waWVkUmFuZ2Uoc3RhdGUpIHtcbiAgICBsZXQgY29udGVudCA9IFtdLCByYW5nZXMgPSBbXSwgbGluZXdpc2UgPSBmYWxzZTtcbiAgICBmb3IgKGxldCByYW5nZSBvZiBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzKVxuICAgICAgICBpZiAoIXJhbmdlLmVtcHR5KSB7XG4gICAgICAgICAgICBjb250ZW50LnB1c2goc3RhdGUuc2xpY2VEb2MocmFuZ2UuZnJvbSwgcmFuZ2UudG8pKTtcbiAgICAgICAgICAgIHJhbmdlcy5wdXNoKHJhbmdlKTtcbiAgICAgICAgfVxuICAgIGlmICghY29udGVudC5sZW5ndGgpIHtcbiAgICAgICAgLy8gTm90aGluZyBzZWxlY3RlZCwgZG8gYSBsaW5lLXdpc2UgY29weVxuICAgICAgICBsZXQgdXB0byA9IC0xO1xuICAgICAgICBmb3IgKGxldCB7IGZyb20gfSBvZiBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzKSB7XG4gICAgICAgICAgICBsZXQgbGluZSA9IHN0YXRlLmRvYy5saW5lQXQoZnJvbSk7XG4gICAgICAgICAgICBpZiAobGluZS5udW1iZXIgPiB1cHRvKSB7XG4gICAgICAgICAgICAgICAgY29udGVudC5wdXNoKGxpbmUudGV4dCk7XG4gICAgICAgICAgICAgICAgcmFuZ2VzLnB1c2goeyBmcm9tOiBsaW5lLmZyb20sIHRvOiBNYXRoLm1pbihzdGF0ZS5kb2MubGVuZ3RoLCBsaW5lLnRvICsgMSkgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1cHRvID0gbGluZS5udW1iZXI7XG4gICAgICAgIH1cbiAgICAgICAgbGluZXdpc2UgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4geyB0ZXh0OiBjb250ZW50LmpvaW4oc3RhdGUubGluZUJyZWFrKSwgcmFuZ2VzLCBsaW5ld2lzZSB9O1xufVxubGV0IGxhc3RMaW5ld2lzZUNvcHkgPSBudWxsO1xuaGFuZGxlcnMuY29weSA9IGhhbmRsZXJzLmN1dCA9ICh2aWV3LCBldmVudCkgPT4ge1xuICAgIGxldCB7IHRleHQsIHJhbmdlcywgbGluZXdpc2UgfSA9IGNvcGllZFJhbmdlKHZpZXcuc3RhdGUpO1xuICAgIGlmICghdGV4dCAmJiAhbGluZXdpc2UpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsYXN0TGluZXdpc2VDb3B5ID0gbGluZXdpc2UgPyB0ZXh0IDogbnVsbDtcbiAgICBpZiAoZXZlbnQudHlwZSA9PSBcImN1dFwiICYmICF2aWV3LnN0YXRlLnJlYWRPbmx5KVxuICAgICAgICB2aWV3LmRpc3BhdGNoKHtcbiAgICAgICAgICAgIGNoYW5nZXM6IHJhbmdlcyxcbiAgICAgICAgICAgIHNjcm9sbEludG9WaWV3OiB0cnVlLFxuICAgICAgICAgICAgdXNlckV2ZW50OiBcImRlbGV0ZS5jdXRcIlxuICAgICAgICB9KTtcbiAgICBsZXQgZGF0YSA9IGJyb2tlbkNsaXBib2FyZEFQSSA/IG51bGwgOiBldmVudC5jbGlwYm9hcmREYXRhO1xuICAgIGlmIChkYXRhKSB7XG4gICAgICAgIGRhdGEuY2xlYXJEYXRhKCk7XG4gICAgICAgIGRhdGEuc2V0RGF0YShcInRleHQvcGxhaW5cIiwgdGV4dCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY2FwdHVyZUNvcHkodmlldywgdGV4dCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59O1xuY29uc3QgaXNGb2N1c0NoYW5nZSA9IC8qQF9fUFVSRV9fKi9Bbm5vdGF0aW9uLmRlZmluZSgpO1xuZnVuY3Rpb24gZm9jdXNDaGFuZ2VUcmFuc2FjdGlvbihzdGF0ZSwgZm9jdXMpIHtcbiAgICBsZXQgZWZmZWN0cyA9IFtdO1xuICAgIGZvciAobGV0IGdldEVmZmVjdCBvZiBzdGF0ZS5mYWNldChmb2N1c0NoYW5nZUVmZmVjdCkpIHtcbiAgICAgICAgbGV0IGVmZmVjdCA9IGdldEVmZmVjdChzdGF0ZSwgZm9jdXMpO1xuICAgICAgICBpZiAoZWZmZWN0KVxuICAgICAgICAgICAgZWZmZWN0cy5wdXNoKGVmZmVjdCk7XG4gICAgfVxuICAgIHJldHVybiBlZmZlY3RzID8gc3RhdGUudXBkYXRlKHsgZWZmZWN0cywgYW5ub3RhdGlvbnM6IGlzRm9jdXNDaGFuZ2Uub2YodHJ1ZSkgfSkgOiBudWxsO1xufVxuZnVuY3Rpb24gdXBkYXRlRm9yRm9jdXNDaGFuZ2Uodmlldykge1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBsZXQgZm9jdXMgPSB2aWV3Lmhhc0ZvY3VzO1xuICAgICAgICBpZiAoZm9jdXMgIT0gdmlldy5pbnB1dFN0YXRlLm5vdGlmaWVkRm9jdXNlZCkge1xuICAgICAgICAgICAgbGV0IHRyID0gZm9jdXNDaGFuZ2VUcmFuc2FjdGlvbih2aWV3LnN0YXRlLCBmb2N1cyk7XG4gICAgICAgICAgICBpZiAodHIpXG4gICAgICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh0cik7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdmlldy51cGRhdGUoW10pO1xuICAgICAgICB9XG4gICAgfSwgMTApO1xufVxub2JzZXJ2ZXJzLmZvY3VzID0gdmlldyA9PiB7XG4gICAgdmlldy5pbnB1dFN0YXRlLmxhc3RGb2N1c1RpbWUgPSBEYXRlLm5vdygpO1xuICAgIC8vIFdoZW4gZm9jdXNpbmcgcmVzZXQgdGhlIHNjcm9sbCBwb3NpdGlvbiwgbW92ZSBpdCBiYWNrIHRvIHdoZXJlIGl0IHdhc1xuICAgIGlmICghdmlldy5zY3JvbGxET00uc2Nyb2xsVG9wICYmICh2aWV3LmlucHV0U3RhdGUubGFzdFNjcm9sbFRvcCB8fCB2aWV3LmlucHV0U3RhdGUubGFzdFNjcm9sbExlZnQpKSB7XG4gICAgICAgIHZpZXcuc2Nyb2xsRE9NLnNjcm9sbFRvcCA9IHZpZXcuaW5wdXRTdGF0ZS5sYXN0U2Nyb2xsVG9wO1xuICAgICAgICB2aWV3LnNjcm9sbERPTS5zY3JvbGxMZWZ0ID0gdmlldy5pbnB1dFN0YXRlLmxhc3RTY3JvbGxMZWZ0O1xuICAgIH1cbiAgICB1cGRhdGVGb3JGb2N1c0NoYW5nZSh2aWV3KTtcbn07XG5vYnNlcnZlcnMuYmx1ciA9IHZpZXcgPT4ge1xuICAgIHZpZXcub2JzZXJ2ZXIuY2xlYXJTZWxlY3Rpb25SYW5nZSgpO1xuICAgIHVwZGF0ZUZvckZvY3VzQ2hhbmdlKHZpZXcpO1xufTtcbm9ic2VydmVycy5jb21wb3NpdGlvbnN0YXJ0ID0gb2JzZXJ2ZXJzLmNvbXBvc2l0aW9udXBkYXRlID0gdmlldyA9PiB7XG4gICAgaWYgKHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpdGlvbkZpcnN0Q2hhbmdlID09IG51bGwpXG4gICAgICAgIHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpdGlvbkZpcnN0Q2hhbmdlID0gdHJ1ZTtcbiAgICBpZiAodmlldy5pbnB1dFN0YXRlLmNvbXBvc2luZyA8IDApIHtcbiAgICAgICAgLy8gRklYTUUgcG9zc2libHkgc2V0IGEgdGltZW91dCB0byBjbGVhciBpdCBhZ2FpbiBvbiBBbmRyb2lkXG4gICAgICAgIHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpbmcgPSAwO1xuICAgIH1cbn07XG5vYnNlcnZlcnMuY29tcG9zaXRpb25lbmQgPSB2aWV3ID0+IHtcbiAgICB2aWV3LmlucHV0U3RhdGUuY29tcG9zaW5nID0gLTE7XG4gICAgdmlldy5pbnB1dFN0YXRlLmNvbXBvc2l0aW9uRW5kZWRBdCA9IERhdGUubm93KCk7XG4gICAgdmlldy5pbnB1dFN0YXRlLmNvbXBvc2l0aW9uUGVuZGluZ0tleSA9IHRydWU7XG4gICAgdmlldy5pbnB1dFN0YXRlLmNvbXBvc2l0aW9uUGVuZGluZ0NoYW5nZSA9IHZpZXcub2JzZXJ2ZXIucGVuZGluZ1JlY29yZHMoKS5sZW5ndGggPiAwO1xuICAgIHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpdGlvbkZpcnN0Q2hhbmdlID0gbnVsbDtcbiAgICBpZiAoYnJvd3Nlci5jaHJvbWUgJiYgYnJvd3Nlci5hbmRyb2lkKSB7XG4gICAgICAgIC8vIERlbGF5IGZsdXNoaW5nIGZvciBhIGJpdCBvbiBBbmRyb2lkIGJlY2F1c2UgaXQnbGwgb2Z0ZW4gZmlyZSBhXG4gICAgICAgIC8vIGJ1bmNoIG9mIGNvbnRyYWRpY3RvcnkgY2hhbmdlcyBpbiBhIHJvdyBhdCBlbmQgb2YgY29tcG9zaXRvblxuICAgICAgICB2aWV3Lm9ic2VydmVyLmZsdXNoU29vbigpO1xuICAgIH1cbiAgICBlbHNlIGlmICh2aWV3LmlucHV0U3RhdGUuY29tcG9zaXRpb25QZW5kaW5nQ2hhbmdlKSB7XG4gICAgICAgIC8vIElmIHdlIGZvdW5kIHBlbmRpbmcgcmVjb3Jkcywgc2NoZWR1bGUgYSBmbHVzaC5cbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB2aWV3Lm9ic2VydmVyLmZsdXNoKCkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBtYWtlIHN1cmUgdGhhdCwgaWYgbm8gY2hhbmdlcyBjb21lIGluIHNvb24sIHRoZVxuICAgICAgICAvLyBjb21wb3NpdGlvbiB2aWV3IGlzIGNsZWFyZWQuXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpbmcgPCAwICYmIHZpZXcuZG9jVmlldy5oYXNDb21wb3NpdGlvbilcbiAgICAgICAgICAgICAgICB2aWV3LnVwZGF0ZShbXSk7XG4gICAgICAgIH0sIDUwKTtcbiAgICB9XG59O1xub2JzZXJ2ZXJzLmNvbnRleHRtZW51ID0gdmlldyA9PiB7XG4gICAgdmlldy5pbnB1dFN0YXRlLmxhc3RDb250ZXh0TWVudSA9IERhdGUubm93KCk7XG59O1xuaGFuZGxlcnMuYmVmb3JlaW5wdXQgPSAodmlldywgZXZlbnQpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgLy8gQmVjYXVzZSBDaHJvbWUgQW5kcm9pZCBkb2Vzbid0IGZpcmUgdXNlZnVsIGtleSBldmVudHMsIHVzZVxuICAgIC8vIGJlZm9yZWlucHV0IHRvIGRldGVjdCBiYWNrc3BhY2UgKGFuZCBwb3NzaWJseSBlbnRlciBhbmQgZGVsZXRlLFxuICAgIC8vIGJ1dCB0aG9zZSB1c3VhbGx5IGRvbid0IGV2ZW4gc2VlbSB0byBmaXJlIGJlZm9yZWlucHV0IGV2ZW50cyBhdFxuICAgIC8vIHRoZSBtb21lbnQpIGFuZCBmYWtlIGEga2V5IGV2ZW50IGZvciBpdC5cbiAgICAvL1xuICAgIC8vIChwcmV2ZW50RGVmYXVsdCBvbiBiZWZvcmVpbnB1dCwgdGhvdWdoIHN1cHBvcnRlZCBpbiB0aGUgc3BlYyxcbiAgICAvLyBzZWVtcyB0byBkbyBub3RoaW5nIGF0IGFsbCBvbiBDaHJvbWUpLlxuICAgIGxldCBwZW5kaW5nO1xuICAgIGlmIChicm93c2VyLmNocm9tZSAmJiBicm93c2VyLmFuZHJvaWQgJiYgKHBlbmRpbmcgPSBQZW5kaW5nS2V5cy5maW5kKGtleSA9PiBrZXkuaW5wdXRUeXBlID09IGV2ZW50LmlucHV0VHlwZSkpKSB7XG4gICAgICAgIHZpZXcub2JzZXJ2ZXIuZGVsYXlBbmRyb2lkS2V5KHBlbmRpbmcua2V5LCBwZW5kaW5nLmtleUNvZGUpO1xuICAgICAgICBpZiAocGVuZGluZy5rZXkgPT0gXCJCYWNrc3BhY2VcIiB8fCBwZW5kaW5nLmtleSA9PSBcIkRlbGV0ZVwiKSB7XG4gICAgICAgICAgICBsZXQgc3RhcnRWaWV3SGVpZ2h0ID0gKChfYSA9IHdpbmRvdy52aXN1YWxWaWV3cG9ydCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhlaWdodCkgfHwgMDtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAvLyBCYWNrc3BhY2luZyBuZWFyIHVuZWRpdGFibGUgbm9kZXMgb24gQ2hyb21lIEFuZHJvaWQgc29tZXRpbWVzXG4gICAgICAgICAgICAgICAgLy8gY2xvc2VzIHRoZSB2aXJ0dWFsIGtleWJvYXJkLiBUaGlzIHRyaWVzIHRvIGNydWRlbHkgZGV0ZWN0XG4gICAgICAgICAgICAgICAgLy8gdGhhdCBhbmQgcmVmb2N1cyB0byBnZXQgaXQgYmFjay5cbiAgICAgICAgICAgICAgICBpZiAoKCgoX2EgPSB3aW5kb3cudmlzdWFsVmlld3BvcnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5oZWlnaHQpIHx8IDApID4gc3RhcnRWaWV3SGVpZ2h0ICsgMTAgJiYgdmlldy5oYXNGb2N1cykge1xuICAgICAgICAgICAgICAgICAgICB2aWV3LmNvbnRlbnRET00uYmx1cigpO1xuICAgICAgICAgICAgICAgICAgICB2aWV3LmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgMTAwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuY29uc3QgYXBwbGllZEZpcmVmb3hIYWNrID0gLypAX19QVVJFX18qL25ldyBTZXQ7XG4vLyBJbiBGaXJlZm94LCB3aGVuIGN1dC9jb3B5IGhhbmRsZXJzIGFyZSBhZGRlZCB0byB0aGUgZG9jdW1lbnQsIHRoYXRcbi8vIHNvbWVob3cgYXZvaWRzIGEgYnVnIHdoZXJlIHRob3NlIGV2ZW50cyBhcmVuJ3QgZmlyZWQgd2hlbiB0aGVcbi8vIHNlbGVjdGlvbiBpcyBlbXB0eS4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jb2RlbWlycm9yL2Rldi9pc3N1ZXMvMTA4MlxuLy8gYW5kIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTk5NTk2MVxuZnVuY3Rpb24gZmlyZWZveENvcHlDdXRIYWNrKGRvYykge1xuICAgIGlmICghYXBwbGllZEZpcmVmb3hIYWNrLmhhcyhkb2MpKSB7XG4gICAgICAgIGFwcGxpZWRGaXJlZm94SGFjay5hZGQoZG9jKTtcbiAgICAgICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoXCJjb3B5XCIsICgpID0+IHsgfSk7XG4gICAgICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKFwiY3V0XCIsICgpID0+IHsgfSk7XG4gICAgfVxufVxuXG5jb25zdCB3cmFwcGluZ1doaXRlU3BhY2UgPSBbXCJwcmUtd3JhcFwiLCBcIm5vcm1hbFwiLCBcInByZS1saW5lXCIsIFwiYnJlYWstc3BhY2VzXCJdO1xuY2xhc3MgSGVpZ2h0T3JhY2xlIHtcbiAgICBjb25zdHJ1Y3RvcihsaW5lV3JhcHBpbmcpIHtcbiAgICAgICAgdGhpcy5saW5lV3JhcHBpbmcgPSBsaW5lV3JhcHBpbmc7XG4gICAgICAgIHRoaXMuZG9jID0gVGV4dC5lbXB0eTtcbiAgICAgICAgdGhpcy5oZWlnaHRTYW1wbGVzID0ge307XG4gICAgICAgIHRoaXMubGluZUhlaWdodCA9IDE0OyAvLyBUaGUgaGVpZ2h0IG9mIGFuIGVudGlyZSBsaW5lIChsaW5lLWhlaWdodClcbiAgICAgICAgdGhpcy5jaGFyV2lkdGggPSA3O1xuICAgICAgICB0aGlzLnRleHRIZWlnaHQgPSAxNDsgLy8gVGhlIGhlaWdodCBvZiB0aGUgYWN0dWFsIGZvbnQgKGZvbnQtc2l6ZSlcbiAgICAgICAgdGhpcy5saW5lTGVuZ3RoID0gMzA7XG4gICAgICAgIC8vIFVzZWQgdG8gdHJhY2ssIGR1cmluZyB1cGRhdGVIZWlnaHQsIGlmIGFueSBhY3R1YWwgaGVpZ2h0cyBjaGFuZ2VkXG4gICAgICAgIHRoaXMuaGVpZ2h0Q2hhbmdlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBoZWlnaHRGb3JHYXAoZnJvbSwgdG8pIHtcbiAgICAgICAgbGV0IGxpbmVzID0gdGhpcy5kb2MubGluZUF0KHRvKS5udW1iZXIgLSB0aGlzLmRvYy5saW5lQXQoZnJvbSkubnVtYmVyICsgMTtcbiAgICAgICAgaWYgKHRoaXMubGluZVdyYXBwaW5nKVxuICAgICAgICAgICAgbGluZXMgKz0gTWF0aC5tYXgoMCwgTWF0aC5jZWlsKCgodG8gLSBmcm9tKSAtIChsaW5lcyAqIHRoaXMubGluZUxlbmd0aCAqIDAuNSkpIC8gdGhpcy5saW5lTGVuZ3RoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmxpbmVIZWlnaHQgKiBsaW5lcztcbiAgICB9XG4gICAgaGVpZ2h0Rm9yTGluZShsZW5ndGgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmxpbmVXcmFwcGluZylcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxpbmVIZWlnaHQ7XG4gICAgICAgIGxldCBsaW5lcyA9IDEgKyBNYXRoLm1heCgwLCBNYXRoLmNlaWwoKGxlbmd0aCAtIHRoaXMubGluZUxlbmd0aCkgLyAodGhpcy5saW5lTGVuZ3RoIC0gNSkpKTtcbiAgICAgICAgcmV0dXJuIGxpbmVzICogdGhpcy5saW5lSGVpZ2h0O1xuICAgIH1cbiAgICBzZXREb2MoZG9jKSB7IHRoaXMuZG9jID0gZG9jOyByZXR1cm4gdGhpczsgfVxuICAgIG11c3RSZWZyZXNoRm9yV3JhcHBpbmcod2hpdGVTcGFjZSkge1xuICAgICAgICByZXR1cm4gKHdyYXBwaW5nV2hpdGVTcGFjZS5pbmRleE9mKHdoaXRlU3BhY2UpID4gLTEpICE9IHRoaXMubGluZVdyYXBwaW5nO1xuICAgIH1cbiAgICBtdXN0UmVmcmVzaEZvckhlaWdodHMobGluZUhlaWdodHMpIHtcbiAgICAgICAgbGV0IG5ld0hlaWdodCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVIZWlnaHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgaCA9IGxpbmVIZWlnaHRzW2ldO1xuICAgICAgICAgICAgaWYgKGggPCAwKSB7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIXRoaXMuaGVpZ2h0U2FtcGxlc1tNYXRoLmZsb29yKGggKiAxMCldKSB7IC8vIFJvdW5kIHRvIC4xIHBpeGVsc1xuICAgICAgICAgICAgICAgIG5ld0hlaWdodCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5oZWlnaHRTYW1wbGVzW01hdGguZmxvb3IoaCAqIDEwKV0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdIZWlnaHQ7XG4gICAgfVxuICAgIHJlZnJlc2god2hpdGVTcGFjZSwgbGluZUhlaWdodCwgY2hhcldpZHRoLCB0ZXh0SGVpZ2h0LCBsaW5lTGVuZ3RoLCBrbm93bkhlaWdodHMpIHtcbiAgICAgICAgbGV0IGxpbmVXcmFwcGluZyA9IHdyYXBwaW5nV2hpdGVTcGFjZS5pbmRleE9mKHdoaXRlU3BhY2UpID4gLTE7XG4gICAgICAgIGxldCBjaGFuZ2VkID0gTWF0aC5yb3VuZChsaW5lSGVpZ2h0KSAhPSBNYXRoLnJvdW5kKHRoaXMubGluZUhlaWdodCkgfHwgdGhpcy5saW5lV3JhcHBpbmcgIT0gbGluZVdyYXBwaW5nO1xuICAgICAgICB0aGlzLmxpbmVXcmFwcGluZyA9IGxpbmVXcmFwcGluZztcbiAgICAgICAgdGhpcy5saW5lSGVpZ2h0ID0gbGluZUhlaWdodDtcbiAgICAgICAgdGhpcy5jaGFyV2lkdGggPSBjaGFyV2lkdGg7XG4gICAgICAgIHRoaXMudGV4dEhlaWdodCA9IHRleHRIZWlnaHQ7XG4gICAgICAgIHRoaXMubGluZUxlbmd0aCA9IGxpbmVMZW5ndGg7XG4gICAgICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgICAgICB0aGlzLmhlaWdodFNhbXBsZXMgPSB7fTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga25vd25IZWlnaHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGggPSBrbm93bkhlaWdodHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGggPCAwKVxuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhlaWdodFNhbXBsZXNbTWF0aC5mbG9vcihoICogMTApXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoYW5nZWQ7XG4gICAgfVxufVxuLy8gVGhpcyBvYmplY3QgaXMgdXNlZCBieSBgdXBkYXRlSGVpZ2h0YCB0byBtYWtlIERPTSBtZWFzdXJlbWVudHNcbi8vIGFycml2ZSBhdCB0aGUgcmlnaHQgbmlkZXMuIFRoZSBgaGVpZ2h0c2AgYXJyYXkgaXMgYSBzZXF1ZW5jZSBvZlxuLy8gYmxvY2sgaGVpZ2h0cywgc3RhcnRpbmcgZnJvbSBwb3NpdGlvbiBgZnJvbWAuXG5jbGFzcyBNZWFzdXJlZEhlaWdodHMge1xuICAgIGNvbnN0cnVjdG9yKGZyb20sIGhlaWdodHMpIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy5oZWlnaHRzID0gaGVpZ2h0cztcbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgfVxuICAgIGdldCBtb3JlKCkgeyByZXR1cm4gdGhpcy5pbmRleCA8IHRoaXMuaGVpZ2h0cy5sZW5ndGg7IH1cbn1cbi8qKlxuUmVjb3JkIHVzZWQgdG8gcmVwcmVzZW50IGluZm9ybWF0aW9uIGFib3V0IGEgYmxvY2stbGV2ZWwgZWxlbWVudFxuaW4gdGhlIGVkaXRvciB2aWV3LlxuKi9cbmNsYXNzIEJsb2NrSW5mbyB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgc3RhcnQgb2YgdGhlIGVsZW1lbnQgaW4gdGhlIGRvY3VtZW50LlxuICAgICovXG4gICAgZnJvbSwgXG4gICAgLyoqXG4gICAgVGhlIGxlbmd0aCBvZiB0aGUgZWxlbWVudC5cbiAgICAqL1xuICAgIGxlbmd0aCwgXG4gICAgLyoqXG4gICAgVGhlIHRvcCBwb3NpdGlvbiBvZiB0aGUgZWxlbWVudCAocmVsYXRpdmUgdG8gdGhlIHRvcCBvZiB0aGVcbiAgICBkb2N1bWVudCkuXG4gICAgKi9cbiAgICB0b3AsIFxuICAgIC8qKlxuICAgIEl0cyBoZWlnaHQuXG4gICAgKi9cbiAgICBoZWlnaHQsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbCBXZWlyZCBwYWNrZWQgZmllbGQgdGhhdCBob2xkcyBhbiBhcnJheSBvZiBjaGlsZHJlblxuICAgIGZvciBjb21wb3NpdGUgYmxvY2tzLCBhIGRlY29yYXRpb24gZm9yIGJsb2NrIHdpZGdldHMsIGFuZCBhXG4gICAgbnVtYmVyIGluZGljYXRpbmcgdGhlIGFtb3VudCBvZiB3aWRnZXQtY3JlYXRlIGxpbmUgYnJlYWtzIGZvclxuICAgIHRleHQgYmxvY2tzLlxuICAgICovXG4gICAgX2NvbnRlbnQpIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRoaXMudG9wID0gdG9wO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgdGhpcy5fY29udGVudCA9IF9jb250ZW50O1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgdHlwZSBvZiBlbGVtZW50IHRoaXMgaXMuIFdoZW4gcXVlcnlpbmcgbGluZXMsIHRoaXMgbWF5IGJlXG4gICAgYW4gYXJyYXkgb2YgYWxsIHRoZSBibG9ja3MgdGhhdCBtYWtlIHVwIHRoZSBsaW5lLlxuICAgICovXG4gICAgZ2V0IHR5cGUoKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdGhpcy5fY29udGVudCA9PSBcIm51bWJlclwiID8gQmxvY2tUeXBlLlRleHQgOlxuICAgICAgICAgICAgQXJyYXkuaXNBcnJheSh0aGlzLl9jb250ZW50KSA/IHRoaXMuX2NvbnRlbnQgOiB0aGlzLl9jb250ZW50LnR5cGU7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBlbmQgb2YgdGhlIGVsZW1lbnQgYXMgYSBkb2N1bWVudCBwb3NpdGlvbi5cbiAgICAqL1xuICAgIGdldCB0bygpIHsgcmV0dXJuIHRoaXMuZnJvbSArIHRoaXMubGVuZ3RoOyB9XG4gICAgLyoqXG4gICAgVGhlIGJvdHRvbSBwb3NpdGlvbiBvZiB0aGUgZWxlbWVudC5cbiAgICAqL1xuICAgIGdldCBib3R0b20oKSB7IHJldHVybiB0aGlzLnRvcCArIHRoaXMuaGVpZ2h0OyB9XG4gICAgLyoqXG4gICAgSWYgdGhpcyBpcyBhIHdpZGdldCBibG9jaywgdGhpcyB3aWxsIHJldHVybiB0aGUgd2lkZ2V0XG4gICAgYXNzb2NpYXRlZCB3aXRoIGl0LlxuICAgICovXG4gICAgZ2V0IHdpZGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRlbnQgaW5zdGFuY2VvZiBQb2ludERlY29yYXRpb24gPyB0aGlzLl9jb250ZW50LndpZGdldCA6IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIElmIHRoaXMgaXMgYSB0ZXh0YmxvY2ssIHRoaXMgaG9sZHMgdGhlIG51bWJlciBvZiBsaW5lIGJyZWFrc1xuICAgIHRoYXQgYXBwZWFyIGluIHdpZGdldHMgaW5zaWRlIHRoZSBibG9jay5cbiAgICAqL1xuICAgIGdldCB3aWRnZXRMaW5lQnJlYWtzKCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHRoaXMuX2NvbnRlbnQgPT0gXCJudW1iZXJcIiA/IHRoaXMuX2NvbnRlbnQgOiAwO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGpvaW4ob3RoZXIpIHtcbiAgICAgICAgbGV0IGNvbnRlbnQgPSAoQXJyYXkuaXNBcnJheSh0aGlzLl9jb250ZW50KSA/IHRoaXMuX2NvbnRlbnQgOiBbdGhpc10pXG4gICAgICAgICAgICAuY29uY2F0KEFycmF5LmlzQXJyYXkob3RoZXIuX2NvbnRlbnQpID8gb3RoZXIuX2NvbnRlbnQgOiBbb3RoZXJdKTtcbiAgICAgICAgcmV0dXJuIG5ldyBCbG9ja0luZm8odGhpcy5mcm9tLCB0aGlzLmxlbmd0aCArIG90aGVyLmxlbmd0aCwgdGhpcy50b3AsIHRoaXMuaGVpZ2h0ICsgb3RoZXIuaGVpZ2h0LCBjb250ZW50KTtcbiAgICB9XG59XG52YXIgUXVlcnlUeXBlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoUXVlcnlUeXBlKSB7XG4gICAgUXVlcnlUeXBlW1F1ZXJ5VHlwZVtcIkJ5UG9zXCJdID0gMF0gPSBcIkJ5UG9zXCI7XG4gICAgUXVlcnlUeXBlW1F1ZXJ5VHlwZVtcIkJ5SGVpZ2h0XCJdID0gMV0gPSBcIkJ5SGVpZ2h0XCI7XG4gICAgUXVlcnlUeXBlW1F1ZXJ5VHlwZVtcIkJ5UG9zTm9IZWlnaHRcIl0gPSAyXSA9IFwiQnlQb3NOb0hlaWdodFwiO1xucmV0dXJuIFF1ZXJ5VHlwZX0pKFF1ZXJ5VHlwZSB8fCAoUXVlcnlUeXBlID0ge30pKTtcbmNvbnN0IEVwc2lsb24gPSAxZS0zO1xuY2xhc3MgSGVpZ2h0TWFwIHtcbiAgICBjb25zdHJ1Y3RvcihsZW5ndGgsIC8vIFRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyBjb3ZlcmVkXG4gICAgaGVpZ2h0LCAvLyBIZWlnaHQgb2YgdGhpcyBwYXJ0IG9mIHRoZSBkb2N1bWVudFxuICAgIGZsYWdzID0gMiAvKiBGbGFnLk91dGRhdGVkICovKSB7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgdGhpcy5mbGFncyA9IGZsYWdzO1xuICAgIH1cbiAgICBnZXQgb3V0ZGF0ZWQoKSB7IHJldHVybiAodGhpcy5mbGFncyAmIDIgLyogRmxhZy5PdXRkYXRlZCAqLykgPiAwOyB9XG4gICAgc2V0IG91dGRhdGVkKHZhbHVlKSB7IHRoaXMuZmxhZ3MgPSAodmFsdWUgPyAyIC8qIEZsYWcuT3V0ZGF0ZWQgKi8gOiAwKSB8ICh0aGlzLmZsYWdzICYgfjIgLyogRmxhZy5PdXRkYXRlZCAqLyk7IH1cbiAgICBzZXRIZWlnaHQob3JhY2xlLCBoZWlnaHQpIHtcbiAgICAgICAgaWYgKHRoaXMuaGVpZ2h0ICE9IGhlaWdodCkge1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHRoaXMuaGVpZ2h0IC0gaGVpZ2h0KSA+IEVwc2lsb24pXG4gICAgICAgICAgICAgICAgb3JhY2xlLmhlaWdodENoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQmFzZSBjYXNlIGlzIHRvIHJlcGxhY2UgYSBsZWFmIG5vZGUsIHdoaWNoIHNpbXBseSBidWlsZHMgYSB0cmVlXG4gICAgLy8gZnJvbSB0aGUgbmV3IG5vZGVzIGFuZCByZXR1cm5zIHRoYXQgKEhlaWdodE1hcEJyYW5jaCBhbmRcbiAgICAvLyBIZWlnaHRNYXBHYXAgb3ZlcnJpZGUgdGhpcyB0byBhY3R1YWxseSB1c2UgZnJvbS90bylcbiAgICByZXBsYWNlKF9mcm9tLCBfdG8sIG5vZGVzKSB7XG4gICAgICAgIHJldHVybiBIZWlnaHRNYXAub2Yobm9kZXMpO1xuICAgIH1cbiAgICAvLyBBZ2FpbiwgdGhlc2UgYXJlIGJhc2UgY2FzZXMsIGFuZCBhcmUgb3ZlcnJpZGRlbiBmb3IgYnJhbmNoIGFuZCBnYXAgbm9kZXMuXG4gICAgZGVjb21wb3NlTGVmdChfdG8sIHJlc3VsdCkgeyByZXN1bHQucHVzaCh0aGlzKTsgfVxuICAgIGRlY29tcG9zZVJpZ2h0KF9mcm9tLCByZXN1bHQpIHsgcmVzdWx0LnB1c2godGhpcyk7IH1cbiAgICBhcHBseUNoYW5nZXMoZGVjb3JhdGlvbnMsIG9sZERvYywgb3JhY2xlLCBjaGFuZ2VzKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXMsIGRvYyA9IG9yYWNsZS5kb2M7XG4gICAgICAgIGZvciAobGV0IGkgPSBjaGFuZ2VzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgeyBmcm9tQSwgdG9BLCBmcm9tQiwgdG9CIH0gPSBjaGFuZ2VzW2ldO1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gbWUubGluZUF0KGZyb21BLCBRdWVyeVR5cGUuQnlQb3NOb0hlaWdodCwgb3JhY2xlLnNldERvYyhvbGREb2MpLCAwLCAwKTtcbiAgICAgICAgICAgIGxldCBlbmQgPSBzdGFydC50byA+PSB0b0EgPyBzdGFydCA6IG1lLmxpbmVBdCh0b0EsIFF1ZXJ5VHlwZS5CeVBvc05vSGVpZ2h0LCBvcmFjbGUsIDAsIDApO1xuICAgICAgICAgICAgdG9CICs9IGVuZC50byAtIHRvQTtcbiAgICAgICAgICAgIHRvQSA9IGVuZC50bztcbiAgICAgICAgICAgIHdoaWxlIChpID4gMCAmJiBzdGFydC5mcm9tIDw9IGNoYW5nZXNbaSAtIDFdLnRvQSkge1xuICAgICAgICAgICAgICAgIGZyb21BID0gY2hhbmdlc1tpIC0gMV0uZnJvbUE7XG4gICAgICAgICAgICAgICAgZnJvbUIgPSBjaGFuZ2VzW2kgLSAxXS5mcm9tQjtcbiAgICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICAgICAgaWYgKGZyb21BIDwgc3RhcnQuZnJvbSlcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBtZS5saW5lQXQoZnJvbUEsIFF1ZXJ5VHlwZS5CeVBvc05vSGVpZ2h0LCBvcmFjbGUsIDAsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnJvbUIgKz0gc3RhcnQuZnJvbSAtIGZyb21BO1xuICAgICAgICAgICAgZnJvbUEgPSBzdGFydC5mcm9tO1xuICAgICAgICAgICAgbGV0IG5vZGVzID0gTm9kZUJ1aWxkZXIuYnVpbGQob3JhY2xlLnNldERvYyhkb2MpLCBkZWNvcmF0aW9ucywgZnJvbUIsIHRvQik7XG4gICAgICAgICAgICBtZSA9IG1lLnJlcGxhY2UoZnJvbUEsIHRvQSwgbm9kZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZS51cGRhdGVIZWlnaHQob3JhY2xlLCAwKTtcbiAgICB9XG4gICAgc3RhdGljIGVtcHR5KCkgeyByZXR1cm4gbmV3IEhlaWdodE1hcFRleHQoMCwgMCk7IH1cbiAgICAvLyBub2RlcyB1c2VzIG51bGwgdmFsdWVzIHRvIGluZGljYXRlIHRoZSBwb3NpdGlvbiBvZiBsaW5lIGJyZWFrcy5cbiAgICAvLyBUaGVyZSBhcmUgbmV2ZXIgbGluZSBicmVha3MgYXQgdGhlIHN0YXJ0IG9yIGVuZCBvZiB0aGUgYXJyYXksIG9yXG4gICAgLy8gdHdvIGxpbmUgYnJlYWtzIG5leHQgdG8gZWFjaCBvdGhlciwgYW5kIHRoZSBhcnJheSBpc24ndCBhbGxvd2VkXG4gICAgLy8gdG8gYmUgZW1wdHkgKHNhbWUgcmVzdHJpY3Rpb25zIGFzIHJldHVybiB2YWx1ZSBmcm9tIHRoZSBidWlsZGVyKS5cbiAgICBzdGF0aWMgb2Yobm9kZXMpIHtcbiAgICAgICAgaWYgKG5vZGVzLmxlbmd0aCA9PSAxKVxuICAgICAgICAgICAgcmV0dXJuIG5vZGVzWzBdO1xuICAgICAgICBsZXQgaSA9IDAsIGogPSBub2Rlcy5sZW5ndGgsIGJlZm9yZSA9IDAsIGFmdGVyID0gMDtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaWYgKGkgPT0gaikge1xuICAgICAgICAgICAgICAgIGlmIChiZWZvcmUgPiBhZnRlciAqIDIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNwbGl0ID0gbm9kZXNbaSAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3BsaXQuYnJlYWspXG4gICAgICAgICAgICAgICAgICAgICAgICBub2Rlcy5zcGxpY2UoLS1pLCAxLCBzcGxpdC5sZWZ0LCBudWxsLCBzcGxpdC5yaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzLnNwbGljZSgtLWksIDEsIHNwbGl0LmxlZnQsIHNwbGl0LnJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgaiArPSAxICsgc3BsaXQuYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGJlZm9yZSAtPSBzcGxpdC5zaXplO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChhZnRlciA+IGJlZm9yZSAqIDIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNwbGl0ID0gbm9kZXNbal07XG4gICAgICAgICAgICAgICAgICAgIGlmIChzcGxpdC5icmVhaylcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzLnNwbGljZShqLCAxLCBzcGxpdC5sZWZ0LCBudWxsLCBzcGxpdC5yaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzLnNwbGljZShqLCAxLCBzcGxpdC5sZWZ0LCBzcGxpdC5yaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIGogKz0gMiArIHNwbGl0LmJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBhZnRlciAtPSBzcGxpdC5zaXplO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYmVmb3JlIDwgYWZ0ZXIpIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IG5vZGVzW2krK107XG4gICAgICAgICAgICAgICAgaWYgKG5leHQpXG4gICAgICAgICAgICAgICAgICAgIGJlZm9yZSArPSBuZXh0LnNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IG5vZGVzWy0tal07XG4gICAgICAgICAgICAgICAgaWYgKG5leHQpXG4gICAgICAgICAgICAgICAgICAgIGFmdGVyICs9IG5leHQuc2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgYnJrID0gMDtcbiAgICAgICAgaWYgKG5vZGVzW2kgLSAxXSA9PSBudWxsKSB7XG4gICAgICAgICAgICBicmsgPSAxO1xuICAgICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGVzW2ldID09IG51bGwpIHtcbiAgICAgICAgICAgIGJyayA9IDE7XG4gICAgICAgICAgICBqKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBIZWlnaHRNYXBCcmFuY2goSGVpZ2h0TWFwLm9mKG5vZGVzLnNsaWNlKDAsIGkpKSwgYnJrLCBIZWlnaHRNYXAub2Yobm9kZXMuc2xpY2UoaikpKTtcbiAgICB9XG59XG5IZWlnaHRNYXAucHJvdG90eXBlLnNpemUgPSAxO1xuY2xhc3MgSGVpZ2h0TWFwQmxvY2sgZXh0ZW5kcyBIZWlnaHRNYXAge1xuICAgIGNvbnN0cnVjdG9yKGxlbmd0aCwgaGVpZ2h0LCBkZWNvKSB7XG4gICAgICAgIHN1cGVyKGxlbmd0aCwgaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5kZWNvID0gZGVjbztcbiAgICB9XG4gICAgYmxvY2tBdChfaGVpZ2h0LCBfb3JhY2xlLCB0b3AsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gbmV3IEJsb2NrSW5mbyhvZmZzZXQsIHRoaXMubGVuZ3RoLCB0b3AsIHRoaXMuaGVpZ2h0LCB0aGlzLmRlY28gfHwgMCk7XG4gICAgfVxuICAgIGxpbmVBdChfdmFsdWUsIF90eXBlLCBvcmFjbGUsIHRvcCwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJsb2NrQXQoMCwgb3JhY2xlLCB0b3AsIG9mZnNldCk7XG4gICAgfVxuICAgIGZvckVhY2hMaW5lKGZyb20sIHRvLCBvcmFjbGUsIHRvcCwgb2Zmc2V0LCBmKSB7XG4gICAgICAgIGlmIChmcm9tIDw9IG9mZnNldCArIHRoaXMubGVuZ3RoICYmIHRvID49IG9mZnNldClcbiAgICAgICAgICAgIGYodGhpcy5ibG9ja0F0KDAsIG9yYWNsZSwgdG9wLCBvZmZzZXQpKTtcbiAgICB9XG4gICAgdXBkYXRlSGVpZ2h0KG9yYWNsZSwgb2Zmc2V0ID0gMCwgX2ZvcmNlID0gZmFsc2UsIG1lYXN1cmVkKSB7XG4gICAgICAgIGlmIChtZWFzdXJlZCAmJiBtZWFzdXJlZC5mcm9tIDw9IG9mZnNldCAmJiBtZWFzdXJlZC5tb3JlKVxuICAgICAgICAgICAgdGhpcy5zZXRIZWlnaHQob3JhY2xlLCBtZWFzdXJlZC5oZWlnaHRzW21lYXN1cmVkLmluZGV4KytdKTtcbiAgICAgICAgdGhpcy5vdXRkYXRlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7IHJldHVybiBgYmxvY2soJHt0aGlzLmxlbmd0aH0pYDsgfVxufVxuY2xhc3MgSGVpZ2h0TWFwVGV4dCBleHRlbmRzIEhlaWdodE1hcEJsb2NrIHtcbiAgICBjb25zdHJ1Y3RvcihsZW5ndGgsIGhlaWdodCkge1xuICAgICAgICBzdXBlcihsZW5ndGgsIGhlaWdodCwgbnVsbCk7XG4gICAgICAgIHRoaXMuY29sbGFwc2VkID0gMDsgLy8gQW1vdW50IG9mIGNvbGxhcHNlZCBjb250ZW50IGluIHRoZSBsaW5lXG4gICAgICAgIHRoaXMud2lkZ2V0SGVpZ2h0ID0gMDsgLy8gTWF4aW11bSBpbmxpbmUgd2lkZ2V0IGhlaWdodFxuICAgICAgICB0aGlzLmJyZWFrcyA9IDA7IC8vIE51bWJlciBvZiB3aWRnZXQtaW50cm9kdWNlZCBsaW5lIGJyZWFrcyBvbiB0aGUgbGluZVxuICAgIH1cbiAgICBibG9ja0F0KF9oZWlnaHQsIF9vcmFjbGUsIHRvcCwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiBuZXcgQmxvY2tJbmZvKG9mZnNldCwgdGhpcy5sZW5ndGgsIHRvcCwgdGhpcy5oZWlnaHQsIHRoaXMuYnJlYWtzKTtcbiAgICB9XG4gICAgcmVwbGFjZShfZnJvbSwgX3RvLCBub2Rlcykge1xuICAgICAgICBsZXQgbm9kZSA9IG5vZGVzWzBdO1xuICAgICAgICBpZiAobm9kZXMubGVuZ3RoID09IDEgJiYgKG5vZGUgaW5zdGFuY2VvZiBIZWlnaHRNYXBUZXh0IHx8IG5vZGUgaW5zdGFuY2VvZiBIZWlnaHRNYXBHYXAgJiYgKG5vZGUuZmxhZ3MgJiA0IC8qIEZsYWcuU2luZ2xlTGluZSAqLykpICYmXG4gICAgICAgICAgICBNYXRoLmFicyh0aGlzLmxlbmd0aCAtIG5vZGUubGVuZ3RoKSA8IDEwKSB7XG4gICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEhlaWdodE1hcEdhcClcbiAgICAgICAgICAgICAgICBub2RlID0gbmV3IEhlaWdodE1hcFRleHQobm9kZS5sZW5ndGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBub2RlLmhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICAgICAgICAgICAgaWYgKCF0aGlzLm91dGRhdGVkKVxuICAgICAgICAgICAgICAgIG5vZGUub3V0ZGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIEhlaWdodE1hcC5vZihub2Rlcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlSGVpZ2h0KG9yYWNsZSwgb2Zmc2V0ID0gMCwgZm9yY2UgPSBmYWxzZSwgbWVhc3VyZWQpIHtcbiAgICAgICAgaWYgKG1lYXN1cmVkICYmIG1lYXN1cmVkLmZyb20gPD0gb2Zmc2V0ICYmIG1lYXN1cmVkLm1vcmUpXG4gICAgICAgICAgICB0aGlzLnNldEhlaWdodChvcmFjbGUsIG1lYXN1cmVkLmhlaWdodHNbbWVhc3VyZWQuaW5kZXgrK10pO1xuICAgICAgICBlbHNlIGlmIChmb3JjZSB8fCB0aGlzLm91dGRhdGVkKVxuICAgICAgICAgICAgdGhpcy5zZXRIZWlnaHQob3JhY2xlLCBNYXRoLm1heCh0aGlzLndpZGdldEhlaWdodCwgb3JhY2xlLmhlaWdodEZvckxpbmUodGhpcy5sZW5ndGggLSB0aGlzLmNvbGxhcHNlZCkpICtcbiAgICAgICAgICAgICAgICB0aGlzLmJyZWFrcyAqIG9yYWNsZS5saW5lSGVpZ2h0KTtcbiAgICAgICAgdGhpcy5vdXRkYXRlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBgbGluZSgke3RoaXMubGVuZ3RofSR7dGhpcy5jb2xsYXBzZWQgPyAtdGhpcy5jb2xsYXBzZWQgOiBcIlwifSR7dGhpcy53aWRnZXRIZWlnaHQgPyBcIjpcIiArIHRoaXMud2lkZ2V0SGVpZ2h0IDogXCJcIn0pYDtcbiAgICB9XG59XG5jbGFzcyBIZWlnaHRNYXBHYXAgZXh0ZW5kcyBIZWlnaHRNYXAge1xuICAgIGNvbnN0cnVjdG9yKGxlbmd0aCkgeyBzdXBlcihsZW5ndGgsIDApOyB9XG4gICAgaGVpZ2h0TWV0cmljcyhvcmFjbGUsIG9mZnNldCkge1xuICAgICAgICBsZXQgZmlyc3RMaW5lID0gb3JhY2xlLmRvYy5saW5lQXQob2Zmc2V0KS5udW1iZXIsIGxhc3RMaW5lID0gb3JhY2xlLmRvYy5saW5lQXQob2Zmc2V0ICsgdGhpcy5sZW5ndGgpLm51bWJlcjtcbiAgICAgICAgbGV0IGxpbmVzID0gbGFzdExpbmUgLSBmaXJzdExpbmUgKyAxO1xuICAgICAgICBsZXQgcGVyTGluZSwgcGVyQ2hhciA9IDA7XG4gICAgICAgIGlmIChvcmFjbGUubGluZVdyYXBwaW5nKSB7XG4gICAgICAgICAgICBsZXQgdG90YWxQZXJMaW5lID0gTWF0aC5taW4odGhpcy5oZWlnaHQsIG9yYWNsZS5saW5lSGVpZ2h0ICogbGluZXMpO1xuICAgICAgICAgICAgcGVyTGluZSA9IHRvdGFsUGVyTGluZSAvIGxpbmVzO1xuICAgICAgICAgICAgaWYgKHRoaXMubGVuZ3RoID4gbGluZXMgKyAxKVxuICAgICAgICAgICAgICAgIHBlckNoYXIgPSAodGhpcy5oZWlnaHQgLSB0b3RhbFBlckxpbmUpIC8gKHRoaXMubGVuZ3RoIC0gbGluZXMgLSAxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBlckxpbmUgPSB0aGlzLmhlaWdodCAvIGxpbmVzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGZpcnN0TGluZSwgbGFzdExpbmUsIHBlckxpbmUsIHBlckNoYXIgfTtcbiAgICB9XG4gICAgYmxvY2tBdChoZWlnaHQsIG9yYWNsZSwgdG9wLCBvZmZzZXQpIHtcbiAgICAgICAgbGV0IHsgZmlyc3RMaW5lLCBsYXN0TGluZSwgcGVyTGluZSwgcGVyQ2hhciB9ID0gdGhpcy5oZWlnaHRNZXRyaWNzKG9yYWNsZSwgb2Zmc2V0KTtcbiAgICAgICAgaWYgKG9yYWNsZS5saW5lV3JhcHBpbmcpIHtcbiAgICAgICAgICAgIGxldCBndWVzcyA9IG9mZnNldCArIE1hdGgucm91bmQoTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgKGhlaWdodCAtIHRvcCkgLyB0aGlzLmhlaWdodCkpICogdGhpcy5sZW5ndGgpO1xuICAgICAgICAgICAgbGV0IGxpbmUgPSBvcmFjbGUuZG9jLmxpbmVBdChndWVzcyksIGxpbmVIZWlnaHQgPSBwZXJMaW5lICsgbGluZS5sZW5ndGggKiBwZXJDaGFyO1xuICAgICAgICAgICAgbGV0IGxpbmVUb3AgPSBNYXRoLm1heCh0b3AsIGhlaWdodCAtIGxpbmVIZWlnaHQgLyAyKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQmxvY2tJbmZvKGxpbmUuZnJvbSwgbGluZS5sZW5ndGgsIGxpbmVUb3AsIGxpbmVIZWlnaHQsIDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGxpbmUgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihsYXN0TGluZSAtIGZpcnN0TGluZSwgTWF0aC5mbG9vcigoaGVpZ2h0IC0gdG9wKSAvIHBlckxpbmUpKSk7XG4gICAgICAgICAgICBsZXQgeyBmcm9tLCBsZW5ndGggfSA9IG9yYWNsZS5kb2MubGluZShmaXJzdExpbmUgKyBsaW5lKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQmxvY2tJbmZvKGZyb20sIGxlbmd0aCwgdG9wICsgcGVyTGluZSAqIGxpbmUsIHBlckxpbmUsIDApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxpbmVBdCh2YWx1ZSwgdHlwZSwgb3JhY2xlLCB0b3AsIG9mZnNldCkge1xuICAgICAgICBpZiAodHlwZSA9PSBRdWVyeVR5cGUuQnlIZWlnaHQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ibG9ja0F0KHZhbHVlLCBvcmFjbGUsIHRvcCwgb2Zmc2V0KTtcbiAgICAgICAgaWYgKHR5cGUgPT0gUXVlcnlUeXBlLkJ5UG9zTm9IZWlnaHQpIHtcbiAgICAgICAgICAgIGxldCB7IGZyb20sIHRvIH0gPSBvcmFjbGUuZG9jLmxpbmVBdCh2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJsb2NrSW5mbyhmcm9tLCB0byAtIGZyb20sIDAsIDAsIDApO1xuICAgICAgICB9XG4gICAgICAgIGxldCB7IGZpcnN0TGluZSwgcGVyTGluZSwgcGVyQ2hhciB9ID0gdGhpcy5oZWlnaHRNZXRyaWNzKG9yYWNsZSwgb2Zmc2V0KTtcbiAgICAgICAgbGV0IGxpbmUgPSBvcmFjbGUuZG9jLmxpbmVBdCh2YWx1ZSksIGxpbmVIZWlnaHQgPSBwZXJMaW5lICsgbGluZS5sZW5ndGggKiBwZXJDaGFyO1xuICAgICAgICBsZXQgbGluZXNBYm92ZSA9IGxpbmUubnVtYmVyIC0gZmlyc3RMaW5lO1xuICAgICAgICBsZXQgbGluZVRvcCA9IHRvcCArIHBlckxpbmUgKiBsaW5lc0Fib3ZlICsgcGVyQ2hhciAqIChsaW5lLmZyb20gLSBvZmZzZXQgLSBsaW5lc0Fib3ZlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBCbG9ja0luZm8obGluZS5mcm9tLCBsaW5lLmxlbmd0aCwgTWF0aC5tYXgodG9wLCBNYXRoLm1pbihsaW5lVG9wLCB0b3AgKyB0aGlzLmhlaWdodCAtIGxpbmVIZWlnaHQpKSwgbGluZUhlaWdodCwgMCk7XG4gICAgfVxuICAgIGZvckVhY2hMaW5lKGZyb20sIHRvLCBvcmFjbGUsIHRvcCwgb2Zmc2V0LCBmKSB7XG4gICAgICAgIGZyb20gPSBNYXRoLm1heChmcm9tLCBvZmZzZXQpO1xuICAgICAgICB0byA9IE1hdGgubWluKHRvLCBvZmZzZXQgKyB0aGlzLmxlbmd0aCk7XG4gICAgICAgIGxldCB7IGZpcnN0TGluZSwgcGVyTGluZSwgcGVyQ2hhciB9ID0gdGhpcy5oZWlnaHRNZXRyaWNzKG9yYWNsZSwgb2Zmc2V0KTtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gZnJvbSwgbGluZVRvcCA9IHRvcDsgcG9zIDw9IHRvOykge1xuICAgICAgICAgICAgbGV0IGxpbmUgPSBvcmFjbGUuZG9jLmxpbmVBdChwb3MpO1xuICAgICAgICAgICAgaWYgKHBvcyA9PSBmcm9tKSB7XG4gICAgICAgICAgICAgICAgbGV0IGxpbmVzQWJvdmUgPSBsaW5lLm51bWJlciAtIGZpcnN0TGluZTtcbiAgICAgICAgICAgICAgICBsaW5lVG9wICs9IHBlckxpbmUgKiBsaW5lc0Fib3ZlICsgcGVyQ2hhciAqIChmcm9tIC0gb2Zmc2V0IC0gbGluZXNBYm92ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbGluZUhlaWdodCA9IHBlckxpbmUgKyBwZXJDaGFyICogbGluZS5sZW5ndGg7XG4gICAgICAgICAgICBmKG5ldyBCbG9ja0luZm8obGluZS5mcm9tLCBsaW5lLmxlbmd0aCwgbGluZVRvcCwgbGluZUhlaWdodCwgMCkpO1xuICAgICAgICAgICAgbGluZVRvcCArPSBsaW5lSGVpZ2h0O1xuICAgICAgICAgICAgcG9zID0gbGluZS50byArIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVwbGFjZShmcm9tLCB0bywgbm9kZXMpIHtcbiAgICAgICAgbGV0IGFmdGVyID0gdGhpcy5sZW5ndGggLSB0bztcbiAgICAgICAgaWYgKGFmdGVyID4gMCkge1xuICAgICAgICAgICAgbGV0IGxhc3QgPSBub2Rlc1tub2Rlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGlmIChsYXN0IGluc3RhbmNlb2YgSGVpZ2h0TWFwR2FwKVxuICAgICAgICAgICAgICAgIG5vZGVzW25vZGVzLmxlbmd0aCAtIDFdID0gbmV3IEhlaWdodE1hcEdhcChsYXN0Lmxlbmd0aCArIGFmdGVyKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKG51bGwsIG5ldyBIZWlnaHRNYXBHYXAoYWZ0ZXIgLSAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZyb20gPiAwKSB7XG4gICAgICAgICAgICBsZXQgZmlyc3QgPSBub2Rlc1swXTtcbiAgICAgICAgICAgIGlmIChmaXJzdCBpbnN0YW5jZW9mIEhlaWdodE1hcEdhcClcbiAgICAgICAgICAgICAgICBub2Rlc1swXSA9IG5ldyBIZWlnaHRNYXBHYXAoZnJvbSArIGZpcnN0Lmxlbmd0aCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgbm9kZXMudW5zaGlmdChuZXcgSGVpZ2h0TWFwR2FwKGZyb20gLSAxKSwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEhlaWdodE1hcC5vZihub2Rlcyk7XG4gICAgfVxuICAgIGRlY29tcG9zZUxlZnQodG8sIHJlc3VsdCkge1xuICAgICAgICByZXN1bHQucHVzaChuZXcgSGVpZ2h0TWFwR2FwKHRvIC0gMSksIG51bGwpO1xuICAgIH1cbiAgICBkZWNvbXBvc2VSaWdodChmcm9tLCByZXN1bHQpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gobnVsbCwgbmV3IEhlaWdodE1hcEdhcCh0aGlzLmxlbmd0aCAtIGZyb20gLSAxKSk7XG4gICAgfVxuICAgIHVwZGF0ZUhlaWdodChvcmFjbGUsIG9mZnNldCA9IDAsIGZvcmNlID0gZmFsc2UsIG1lYXN1cmVkKSB7XG4gICAgICAgIGxldCBlbmQgPSBvZmZzZXQgKyB0aGlzLmxlbmd0aDtcbiAgICAgICAgaWYgKG1lYXN1cmVkICYmIG1lYXN1cmVkLmZyb20gPD0gb2Zmc2V0ICsgdGhpcy5sZW5ndGggJiYgbWVhc3VyZWQubW9yZSkge1xuICAgICAgICAgICAgLy8gRmlsbCBpbiBwYXJ0IG9mIHRoaXMgZ2FwIHdpdGggbWVhc3VyZWQgbGluZXMuIFdlIGtub3cgdGhlcmVcbiAgICAgICAgICAgIC8vIGNhbid0IGJlIHdpZGdldHMgb3IgY29sbGFwc2VkIHJhbmdlcyBpbiB0aG9zZSBsaW5lcywgYmVjYXVzZVxuICAgICAgICAgICAgLy8gdGhleSB3b3VsZCBhbHJlYWR5IGhhdmUgYmVlbiBhZGRlZCB0byB0aGUgaGVpZ2h0bWFwIChnYXBzXG4gICAgICAgICAgICAvLyBvbmx5IGNvbnRhaW4gcGxhaW4gdGV4dCkuXG4gICAgICAgICAgICBsZXQgbm9kZXMgPSBbXSwgcG9zID0gTWF0aC5tYXgob2Zmc2V0LCBtZWFzdXJlZC5mcm9tKSwgc2luZ2xlSGVpZ2h0ID0gLTE7XG4gICAgICAgICAgICBpZiAobWVhc3VyZWQuZnJvbSA+IG9mZnNldClcbiAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKG5ldyBIZWlnaHRNYXBHYXAobWVhc3VyZWQuZnJvbSAtIG9mZnNldCAtIDEpLnVwZGF0ZUhlaWdodChvcmFjbGUsIG9mZnNldCkpO1xuICAgICAgICAgICAgd2hpbGUgKHBvcyA8PSBlbmQgJiYgbWVhc3VyZWQubW9yZSkge1xuICAgICAgICAgICAgICAgIGxldCBsZW4gPSBvcmFjbGUuZG9jLmxpbmVBdChwb3MpLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAobm9kZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKG51bGwpO1xuICAgICAgICAgICAgICAgIGxldCBoZWlnaHQgPSBtZWFzdXJlZC5oZWlnaHRzW21lYXN1cmVkLmluZGV4KytdO1xuICAgICAgICAgICAgICAgIGlmIChzaW5nbGVIZWlnaHQgPT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIHNpbmdsZUhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChNYXRoLmFicyhoZWlnaHQgLSBzaW5nbGVIZWlnaHQpID49IEVwc2lsb24pXG4gICAgICAgICAgICAgICAgICAgIHNpbmdsZUhlaWdodCA9IC0yO1xuICAgICAgICAgICAgICAgIGxldCBsaW5lID0gbmV3IEhlaWdodE1hcFRleHQobGVuLCBoZWlnaHQpO1xuICAgICAgICAgICAgICAgIGxpbmUub3V0ZGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKGxpbmUpO1xuICAgICAgICAgICAgICAgIHBvcyArPSBsZW4gKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBvcyA8PSBlbmQpXG4gICAgICAgICAgICAgICAgbm9kZXMucHVzaChudWxsLCBuZXcgSGVpZ2h0TWFwR2FwKGVuZCAtIHBvcykudXBkYXRlSGVpZ2h0KG9yYWNsZSwgcG9zKSk7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gSGVpZ2h0TWFwLm9mKG5vZGVzKTtcbiAgICAgICAgICAgIGlmIChzaW5nbGVIZWlnaHQgPCAwIHx8IE1hdGguYWJzKHJlc3VsdC5oZWlnaHQgLSB0aGlzLmhlaWdodCkgPj0gRXBzaWxvbiB8fFxuICAgICAgICAgICAgICAgIE1hdGguYWJzKHNpbmdsZUhlaWdodCAtIHRoaXMuaGVpZ2h0TWV0cmljcyhvcmFjbGUsIG9mZnNldCkucGVyTGluZSkgPj0gRXBzaWxvbilcbiAgICAgICAgICAgICAgICBvcmFjbGUuaGVpZ2h0Q2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZvcmNlIHx8IHRoaXMub3V0ZGF0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0SGVpZ2h0KG9yYWNsZSwgb3JhY2xlLmhlaWdodEZvckdhcChvZmZzZXQsIG9mZnNldCArIHRoaXMubGVuZ3RoKSk7XG4gICAgICAgICAgICB0aGlzLm91dGRhdGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkgeyByZXR1cm4gYGdhcCgke3RoaXMubGVuZ3RofSlgOyB9XG59XG5jbGFzcyBIZWlnaHRNYXBCcmFuY2ggZXh0ZW5kcyBIZWlnaHRNYXAge1xuICAgIGNvbnN0cnVjdG9yKGxlZnQsIGJyaywgcmlnaHQpIHtcbiAgICAgICAgc3VwZXIobGVmdC5sZW5ndGggKyBicmsgKyByaWdodC5sZW5ndGgsIGxlZnQuaGVpZ2h0ICsgcmlnaHQuaGVpZ2h0LCBicmsgfCAobGVmdC5vdXRkYXRlZCB8fCByaWdodC5vdXRkYXRlZCA/IDIgLyogRmxhZy5PdXRkYXRlZCAqLyA6IDApKTtcbiAgICAgICAgdGhpcy5sZWZ0ID0gbGVmdDtcbiAgICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xuICAgICAgICB0aGlzLnNpemUgPSBsZWZ0LnNpemUgKyByaWdodC5zaXplO1xuICAgIH1cbiAgICBnZXQgYnJlYWsoKSB7IHJldHVybiB0aGlzLmZsYWdzICYgMSAvKiBGbGFnLkJyZWFrICovOyB9XG4gICAgYmxvY2tBdChoZWlnaHQsIG9yYWNsZSwgdG9wLCBvZmZzZXQpIHtcbiAgICAgICAgbGV0IG1pZCA9IHRvcCArIHRoaXMubGVmdC5oZWlnaHQ7XG4gICAgICAgIHJldHVybiBoZWlnaHQgPCBtaWQgPyB0aGlzLmxlZnQuYmxvY2tBdChoZWlnaHQsIG9yYWNsZSwgdG9wLCBvZmZzZXQpXG4gICAgICAgICAgICA6IHRoaXMucmlnaHQuYmxvY2tBdChoZWlnaHQsIG9yYWNsZSwgbWlkLCBvZmZzZXQgKyB0aGlzLmxlZnQubGVuZ3RoICsgdGhpcy5icmVhayk7XG4gICAgfVxuICAgIGxpbmVBdCh2YWx1ZSwgdHlwZSwgb3JhY2xlLCB0b3AsIG9mZnNldCkge1xuICAgICAgICBsZXQgcmlnaHRUb3AgPSB0b3AgKyB0aGlzLmxlZnQuaGVpZ2h0LCByaWdodE9mZnNldCA9IG9mZnNldCArIHRoaXMubGVmdC5sZW5ndGggKyB0aGlzLmJyZWFrO1xuICAgICAgICBsZXQgbGVmdCA9IHR5cGUgPT0gUXVlcnlUeXBlLkJ5SGVpZ2h0ID8gdmFsdWUgPCByaWdodFRvcCA6IHZhbHVlIDwgcmlnaHRPZmZzZXQ7XG4gICAgICAgIGxldCBiYXNlID0gbGVmdCA/IHRoaXMubGVmdC5saW5lQXQodmFsdWUsIHR5cGUsIG9yYWNsZSwgdG9wLCBvZmZzZXQpXG4gICAgICAgICAgICA6IHRoaXMucmlnaHQubGluZUF0KHZhbHVlLCB0eXBlLCBvcmFjbGUsIHJpZ2h0VG9wLCByaWdodE9mZnNldCk7XG4gICAgICAgIGlmICh0aGlzLmJyZWFrIHx8IChsZWZ0ID8gYmFzZS50byA8IHJpZ2h0T2Zmc2V0IDogYmFzZS5mcm9tID4gcmlnaHRPZmZzZXQpKVxuICAgICAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgICAgIGxldCBzdWJRdWVyeSA9IHR5cGUgPT0gUXVlcnlUeXBlLkJ5UG9zTm9IZWlnaHQgPyBRdWVyeVR5cGUuQnlQb3NOb0hlaWdodCA6IFF1ZXJ5VHlwZS5CeVBvcztcbiAgICAgICAgaWYgKGxlZnQpXG4gICAgICAgICAgICByZXR1cm4gYmFzZS5qb2luKHRoaXMucmlnaHQubGluZUF0KHJpZ2h0T2Zmc2V0LCBzdWJRdWVyeSwgb3JhY2xlLCByaWdodFRvcCwgcmlnaHRPZmZzZXQpKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVmdC5saW5lQXQocmlnaHRPZmZzZXQsIHN1YlF1ZXJ5LCBvcmFjbGUsIHRvcCwgb2Zmc2V0KS5qb2luKGJhc2UpO1xuICAgIH1cbiAgICBmb3JFYWNoTGluZShmcm9tLCB0bywgb3JhY2xlLCB0b3AsIG9mZnNldCwgZikge1xuICAgICAgICBsZXQgcmlnaHRUb3AgPSB0b3AgKyB0aGlzLmxlZnQuaGVpZ2h0LCByaWdodE9mZnNldCA9IG9mZnNldCArIHRoaXMubGVmdC5sZW5ndGggKyB0aGlzLmJyZWFrO1xuICAgICAgICBpZiAodGhpcy5icmVhaykge1xuICAgICAgICAgICAgaWYgKGZyb20gPCByaWdodE9mZnNldClcbiAgICAgICAgICAgICAgICB0aGlzLmxlZnQuZm9yRWFjaExpbmUoZnJvbSwgdG8sIG9yYWNsZSwgdG9wLCBvZmZzZXQsIGYpO1xuICAgICAgICAgICAgaWYgKHRvID49IHJpZ2h0T2Zmc2V0KVxuICAgICAgICAgICAgICAgIHRoaXMucmlnaHQuZm9yRWFjaExpbmUoZnJvbSwgdG8sIG9yYWNsZSwgcmlnaHRUb3AsIHJpZ2h0T2Zmc2V0LCBmKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBtaWQgPSB0aGlzLmxpbmVBdChyaWdodE9mZnNldCwgUXVlcnlUeXBlLkJ5UG9zLCBvcmFjbGUsIHRvcCwgb2Zmc2V0KTtcbiAgICAgICAgICAgIGlmIChmcm9tIDwgbWlkLmZyb20pXG4gICAgICAgICAgICAgICAgdGhpcy5sZWZ0LmZvckVhY2hMaW5lKGZyb20sIG1pZC5mcm9tIC0gMSwgb3JhY2xlLCB0b3AsIG9mZnNldCwgZik7XG4gICAgICAgICAgICBpZiAobWlkLnRvID49IGZyb20gJiYgbWlkLmZyb20gPD0gdG8pXG4gICAgICAgICAgICAgICAgZihtaWQpO1xuICAgICAgICAgICAgaWYgKHRvID4gbWlkLnRvKVxuICAgICAgICAgICAgICAgIHRoaXMucmlnaHQuZm9yRWFjaExpbmUobWlkLnRvICsgMSwgdG8sIG9yYWNsZSwgcmlnaHRUb3AsIHJpZ2h0T2Zmc2V0LCBmKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXBsYWNlKGZyb20sIHRvLCBub2Rlcykge1xuICAgICAgICBsZXQgcmlnaHRTdGFydCA9IHRoaXMubGVmdC5sZW5ndGggKyB0aGlzLmJyZWFrO1xuICAgICAgICBpZiAodG8gPCByaWdodFN0YXJ0KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmFsYW5jZWQodGhpcy5sZWZ0LnJlcGxhY2UoZnJvbSwgdG8sIG5vZGVzKSwgdGhpcy5yaWdodCk7XG4gICAgICAgIGlmIChmcm9tID4gdGhpcy5sZWZ0Lmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJhbGFuY2VkKHRoaXMubGVmdCwgdGhpcy5yaWdodC5yZXBsYWNlKGZyb20gLSByaWdodFN0YXJ0LCB0byAtIHJpZ2h0U3RhcnQsIG5vZGVzKSk7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgaWYgKGZyb20gPiAwKVxuICAgICAgICAgICAgdGhpcy5kZWNvbXBvc2VMZWZ0KGZyb20sIHJlc3VsdCk7XG4gICAgICAgIGxldCBsZWZ0ID0gcmVzdWx0Lmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgbm9kZSBvZiBub2RlcylcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5vZGUpO1xuICAgICAgICBpZiAoZnJvbSA+IDApXG4gICAgICAgICAgICBtZXJnZUdhcHMocmVzdWx0LCBsZWZ0IC0gMSk7XG4gICAgICAgIGlmICh0byA8IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgcmlnaHQgPSByZXN1bHQubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5kZWNvbXBvc2VSaWdodCh0bywgcmVzdWx0KTtcbiAgICAgICAgICAgIG1lcmdlR2FwcyhyZXN1bHQsIHJpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSGVpZ2h0TWFwLm9mKHJlc3VsdCk7XG4gICAgfVxuICAgIGRlY29tcG9zZUxlZnQodG8sIHJlc3VsdCkge1xuICAgICAgICBsZXQgbGVmdCA9IHRoaXMubGVmdC5sZW5ndGg7XG4gICAgICAgIGlmICh0byA8PSBsZWZ0KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVmdC5kZWNvbXBvc2VMZWZ0KHRvLCByZXN1bHQpO1xuICAgICAgICByZXN1bHQucHVzaCh0aGlzLmxlZnQpO1xuICAgICAgICBpZiAodGhpcy5icmVhaykge1xuICAgICAgICAgICAgbGVmdCsrO1xuICAgICAgICAgICAgaWYgKHRvID49IGxlZnQpXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRvID4gbGVmdClcbiAgICAgICAgICAgIHRoaXMucmlnaHQuZGVjb21wb3NlTGVmdCh0byAtIGxlZnQsIHJlc3VsdCk7XG4gICAgfVxuICAgIGRlY29tcG9zZVJpZ2h0KGZyb20sIHJlc3VsdCkge1xuICAgICAgICBsZXQgbGVmdCA9IHRoaXMubGVmdC5sZW5ndGgsIHJpZ2h0ID0gbGVmdCArIHRoaXMuYnJlYWs7XG4gICAgICAgIGlmIChmcm9tID49IHJpZ2h0KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmlnaHQuZGVjb21wb3NlUmlnaHQoZnJvbSAtIHJpZ2h0LCByZXN1bHQpO1xuICAgICAgICBpZiAoZnJvbSA8IGxlZnQpXG4gICAgICAgICAgICB0aGlzLmxlZnQuZGVjb21wb3NlUmlnaHQoZnJvbSwgcmVzdWx0KTtcbiAgICAgICAgaWYgKHRoaXMuYnJlYWsgJiYgZnJvbSA8IHJpZ2h0KVxuICAgICAgICAgICAgcmVzdWx0LnB1c2gobnVsbCk7XG4gICAgICAgIHJlc3VsdC5wdXNoKHRoaXMucmlnaHQpO1xuICAgIH1cbiAgICBiYWxhbmNlZChsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAobGVmdC5zaXplID4gMiAqIHJpZ2h0LnNpemUgfHwgcmlnaHQuc2l6ZSA+IDIgKiBsZWZ0LnNpemUpXG4gICAgICAgICAgICByZXR1cm4gSGVpZ2h0TWFwLm9mKHRoaXMuYnJlYWsgPyBbbGVmdCwgbnVsbCwgcmlnaHRdIDogW2xlZnQsIHJpZ2h0XSk7XG4gICAgICAgIHRoaXMubGVmdCA9IGxlZnQ7XG4gICAgICAgIHRoaXMucmlnaHQgPSByaWdodDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBsZWZ0LmhlaWdodCArIHJpZ2h0LmhlaWdodDtcbiAgICAgICAgdGhpcy5vdXRkYXRlZCA9IGxlZnQub3V0ZGF0ZWQgfHwgcmlnaHQub3V0ZGF0ZWQ7XG4gICAgICAgIHRoaXMuc2l6ZSA9IGxlZnQuc2l6ZSArIHJpZ2h0LnNpemU7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVmdC5sZW5ndGggKyB0aGlzLmJyZWFrICsgcmlnaHQubGVuZ3RoO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdXBkYXRlSGVpZ2h0KG9yYWNsZSwgb2Zmc2V0ID0gMCwgZm9yY2UgPSBmYWxzZSwgbWVhc3VyZWQpIHtcbiAgICAgICAgbGV0IHsgbGVmdCwgcmlnaHQgfSA9IHRoaXMsIHJpZ2h0U3RhcnQgPSBvZmZzZXQgKyBsZWZ0Lmxlbmd0aCArIHRoaXMuYnJlYWssIHJlYmFsYW5jZSA9IG51bGw7XG4gICAgICAgIGlmIChtZWFzdXJlZCAmJiBtZWFzdXJlZC5mcm9tIDw9IG9mZnNldCArIGxlZnQubGVuZ3RoICYmIG1lYXN1cmVkLm1vcmUpXG4gICAgICAgICAgICByZWJhbGFuY2UgPSBsZWZ0ID0gbGVmdC51cGRhdGVIZWlnaHQob3JhY2xlLCBvZmZzZXQsIGZvcmNlLCBtZWFzdXJlZCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxlZnQudXBkYXRlSGVpZ2h0KG9yYWNsZSwgb2Zmc2V0LCBmb3JjZSk7XG4gICAgICAgIGlmIChtZWFzdXJlZCAmJiBtZWFzdXJlZC5mcm9tIDw9IHJpZ2h0U3RhcnQgKyByaWdodC5sZW5ndGggJiYgbWVhc3VyZWQubW9yZSlcbiAgICAgICAgICAgIHJlYmFsYW5jZSA9IHJpZ2h0ID0gcmlnaHQudXBkYXRlSGVpZ2h0KG9yYWNsZSwgcmlnaHRTdGFydCwgZm9yY2UsIG1lYXN1cmVkKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmlnaHQudXBkYXRlSGVpZ2h0KG9yYWNsZSwgcmlnaHRTdGFydCwgZm9yY2UpO1xuICAgICAgICBpZiAocmViYWxhbmNlKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmFsYW5jZWQobGVmdCwgcmlnaHQpO1xuICAgICAgICB0aGlzLmhlaWdodCA9IHRoaXMubGVmdC5oZWlnaHQgKyB0aGlzLnJpZ2h0LmhlaWdodDtcbiAgICAgICAgdGhpcy5vdXRkYXRlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7IHJldHVybiB0aGlzLmxlZnQgKyAodGhpcy5icmVhayA/IFwiIFwiIDogXCItXCIpICsgdGhpcy5yaWdodDsgfVxufVxuZnVuY3Rpb24gbWVyZ2VHYXBzKG5vZGVzLCBhcm91bmQpIHtcbiAgICBsZXQgYmVmb3JlLCBhZnRlcjtcbiAgICBpZiAobm9kZXNbYXJvdW5kXSA9PSBudWxsICYmXG4gICAgICAgIChiZWZvcmUgPSBub2Rlc1thcm91bmQgLSAxXSkgaW5zdGFuY2VvZiBIZWlnaHRNYXBHYXAgJiZcbiAgICAgICAgKGFmdGVyID0gbm9kZXNbYXJvdW5kICsgMV0pIGluc3RhbmNlb2YgSGVpZ2h0TWFwR2FwKVxuICAgICAgICBub2Rlcy5zcGxpY2UoYXJvdW5kIC0gMSwgMywgbmV3IEhlaWdodE1hcEdhcChiZWZvcmUubGVuZ3RoICsgMSArIGFmdGVyLmxlbmd0aCkpO1xufVxuY29uc3QgcmVsZXZhbnRXaWRnZXRIZWlnaHQgPSA1O1xuY2xhc3MgTm9kZUJ1aWxkZXIge1xuICAgIGNvbnN0cnVjdG9yKHBvcywgb3JhY2xlKSB7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICB0aGlzLm9yYWNsZSA9IG9yYWNsZTtcbiAgICAgICAgdGhpcy5ub2RlcyA9IFtdO1xuICAgICAgICB0aGlzLmxpbmVTdGFydCA9IC0xO1xuICAgICAgICB0aGlzLmxpbmVFbmQgPSAtMTtcbiAgICAgICAgdGhpcy5jb3ZlcmluZyA9IG51bGw7XG4gICAgICAgIHRoaXMud3JpdHRlblRvID0gcG9zO1xuICAgIH1cbiAgICBnZXQgaXNDb3ZlcmVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb3ZlcmluZyAmJiB0aGlzLm5vZGVzW3RoaXMubm9kZXMubGVuZ3RoIC0gMV0gPT0gdGhpcy5jb3ZlcmluZztcbiAgICB9XG4gICAgc3BhbihfZnJvbSwgdG8pIHtcbiAgICAgICAgaWYgKHRoaXMubGluZVN0YXJ0ID4gLTEpIHtcbiAgICAgICAgICAgIGxldCBlbmQgPSBNYXRoLm1pbih0bywgdGhpcy5saW5lRW5kKSwgbGFzdCA9IHRoaXMubm9kZXNbdGhpcy5ub2Rlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGlmIChsYXN0IGluc3RhbmNlb2YgSGVpZ2h0TWFwVGV4dClcbiAgICAgICAgICAgICAgICBsYXN0Lmxlbmd0aCArPSBlbmQgLSB0aGlzLnBvcztcbiAgICAgICAgICAgIGVsc2UgaWYgKGVuZCA+IHRoaXMucG9zIHx8ICF0aGlzLmlzQ292ZXJlZClcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVzLnB1c2gobmV3IEhlaWdodE1hcFRleHQoZW5kIC0gdGhpcy5wb3MsIC0xKSk7XG4gICAgICAgICAgICB0aGlzLndyaXR0ZW5UbyA9IGVuZDtcbiAgICAgICAgICAgIGlmICh0byA+IGVuZCkge1xuICAgICAgICAgICAgICAgIHRoaXMubm9kZXMucHVzaChudWxsKTtcbiAgICAgICAgICAgICAgICB0aGlzLndyaXR0ZW5UbysrO1xuICAgICAgICAgICAgICAgIHRoaXMubGluZVN0YXJ0ID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wb3MgPSB0bztcbiAgICB9XG4gICAgcG9pbnQoZnJvbSwgdG8sIGRlY28pIHtcbiAgICAgICAgaWYgKGZyb20gPCB0byB8fCBkZWNvLmhlaWdodFJlbGV2YW50KSB7XG4gICAgICAgICAgICBsZXQgaGVpZ2h0ID0gZGVjby53aWRnZXQgPyBkZWNvLndpZGdldC5lc3RpbWF0ZWRIZWlnaHQgOiAwO1xuICAgICAgICAgICAgbGV0IGJyZWFrcyA9IGRlY28ud2lkZ2V0ID8gZGVjby53aWRnZXQubGluZUJyZWFrcyA6IDA7XG4gICAgICAgICAgICBpZiAoaGVpZ2h0IDwgMClcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSB0aGlzLm9yYWNsZS5saW5lSGVpZ2h0O1xuICAgICAgICAgICAgbGV0IGxlbiA9IHRvIC0gZnJvbTtcbiAgICAgICAgICAgIGlmIChkZWNvLmJsb2NrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRCbG9jayhuZXcgSGVpZ2h0TWFwQmxvY2sobGVuLCBoZWlnaHQsIGRlY28pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGxlbiB8fCBicmVha3MgfHwgaGVpZ2h0ID49IHJlbGV2YW50V2lkZ2V0SGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRMaW5lRGVjbyhoZWlnaHQsIGJyZWFrcywgbGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0byA+IGZyb20pIHtcbiAgICAgICAgICAgIHRoaXMuc3Bhbihmcm9tLCB0byk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubGluZUVuZCA+IC0xICYmIHRoaXMubGluZUVuZCA8IHRoaXMucG9zKVxuICAgICAgICAgICAgdGhpcy5saW5lRW5kID0gdGhpcy5vcmFjbGUuZG9jLmxpbmVBdCh0aGlzLnBvcykudG87XG4gICAgfVxuICAgIGVudGVyTGluZSgpIHtcbiAgICAgICAgaWYgKHRoaXMubGluZVN0YXJ0ID4gLTEpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCB7IGZyb20sIHRvIH0gPSB0aGlzLm9yYWNsZS5kb2MubGluZUF0KHRoaXMucG9zKTtcbiAgICAgICAgdGhpcy5saW5lU3RhcnQgPSBmcm9tO1xuICAgICAgICB0aGlzLmxpbmVFbmQgPSB0bztcbiAgICAgICAgaWYgKHRoaXMud3JpdHRlblRvIDwgZnJvbSkge1xuICAgICAgICAgICAgaWYgKHRoaXMud3JpdHRlblRvIDwgZnJvbSAtIDEgfHwgdGhpcy5ub2Rlc1t0aGlzLm5vZGVzLmxlbmd0aCAtIDFdID09IG51bGwpXG4gICAgICAgICAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKHRoaXMuYmxhbmtDb250ZW50KHRoaXMud3JpdHRlblRvLCBmcm9tIC0gMSkpO1xuICAgICAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBvcyA+IGZyb20pXG4gICAgICAgICAgICB0aGlzLm5vZGVzLnB1c2gobmV3IEhlaWdodE1hcFRleHQodGhpcy5wb3MgLSBmcm9tLCAtMSkpO1xuICAgICAgICB0aGlzLndyaXR0ZW5UbyA9IHRoaXMucG9zO1xuICAgIH1cbiAgICBibGFua0NvbnRlbnQoZnJvbSwgdG8pIHtcbiAgICAgICAgbGV0IGdhcCA9IG5ldyBIZWlnaHRNYXBHYXAodG8gLSBmcm9tKTtcbiAgICAgICAgaWYgKHRoaXMub3JhY2xlLmRvYy5saW5lQXQoZnJvbSkudG8gPT0gdG8pXG4gICAgICAgICAgICBnYXAuZmxhZ3MgfD0gNCAvKiBGbGFnLlNpbmdsZUxpbmUgKi87XG4gICAgICAgIHJldHVybiBnYXA7XG4gICAgfVxuICAgIGVuc3VyZUxpbmUoKSB7XG4gICAgICAgIHRoaXMuZW50ZXJMaW5lKCk7XG4gICAgICAgIGxldCBsYXN0ID0gdGhpcy5ub2Rlcy5sZW5ndGggPyB0aGlzLm5vZGVzW3RoaXMubm9kZXMubGVuZ3RoIC0gMV0gOiBudWxsO1xuICAgICAgICBpZiAobGFzdCBpbnN0YW5jZW9mIEhlaWdodE1hcFRleHQpXG4gICAgICAgICAgICByZXR1cm4gbGFzdDtcbiAgICAgICAgbGV0IGxpbmUgPSBuZXcgSGVpZ2h0TWFwVGV4dCgwLCAtMSk7XG4gICAgICAgIHRoaXMubm9kZXMucHVzaChsaW5lKTtcbiAgICAgICAgcmV0dXJuIGxpbmU7XG4gICAgfVxuICAgIGFkZEJsb2NrKGJsb2NrKSB7XG4gICAgICAgIHRoaXMuZW50ZXJMaW5lKCk7XG4gICAgICAgIGxldCBkZWNvID0gYmxvY2suZGVjbztcbiAgICAgICAgaWYgKGRlY28gJiYgZGVjby5zdGFydFNpZGUgPiAwICYmICF0aGlzLmlzQ292ZXJlZClcbiAgICAgICAgICAgIHRoaXMuZW5zdXJlTGluZSgpO1xuICAgICAgICB0aGlzLm5vZGVzLnB1c2goYmxvY2spO1xuICAgICAgICB0aGlzLndyaXR0ZW5UbyA9IHRoaXMucG9zID0gdGhpcy5wb3MgKyBibG9jay5sZW5ndGg7XG4gICAgICAgIGlmIChkZWNvICYmIGRlY28uZW5kU2lkZSA+IDApXG4gICAgICAgICAgICB0aGlzLmNvdmVyaW5nID0gYmxvY2s7XG4gICAgfVxuICAgIGFkZExpbmVEZWNvKGhlaWdodCwgYnJlYWtzLCBsZW5ndGgpIHtcbiAgICAgICAgbGV0IGxpbmUgPSB0aGlzLmVuc3VyZUxpbmUoKTtcbiAgICAgICAgbGluZS5sZW5ndGggKz0gbGVuZ3RoO1xuICAgICAgICBsaW5lLmNvbGxhcHNlZCArPSBsZW5ndGg7XG4gICAgICAgIGxpbmUud2lkZ2V0SGVpZ2h0ID0gTWF0aC5tYXgobGluZS53aWRnZXRIZWlnaHQsIGhlaWdodCk7XG4gICAgICAgIGxpbmUuYnJlYWtzICs9IGJyZWFrcztcbiAgICAgICAgdGhpcy53cml0dGVuVG8gPSB0aGlzLnBvcyA9IHRoaXMucG9zICsgbGVuZ3RoO1xuICAgIH1cbiAgICBmaW5pc2goZnJvbSkge1xuICAgICAgICBsZXQgbGFzdCA9IHRoaXMubm9kZXMubGVuZ3RoID09IDAgPyBudWxsIDogdGhpcy5ub2Rlc1t0aGlzLm5vZGVzLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAodGhpcy5saW5lU3RhcnQgPiAtMSAmJiAhKGxhc3QgaW5zdGFuY2VvZiBIZWlnaHRNYXBUZXh0KSAmJiAhdGhpcy5pc0NvdmVyZWQpXG4gICAgICAgICAgICB0aGlzLm5vZGVzLnB1c2gobmV3IEhlaWdodE1hcFRleHQoMCwgLTEpKTtcbiAgICAgICAgZWxzZSBpZiAodGhpcy53cml0dGVuVG8gPCB0aGlzLnBvcyB8fCBsYXN0ID09IG51bGwpXG4gICAgICAgICAgICB0aGlzLm5vZGVzLnB1c2godGhpcy5ibGFua0NvbnRlbnQodGhpcy53cml0dGVuVG8sIHRoaXMucG9zKSk7XG4gICAgICAgIGxldCBwb3MgPSBmcm9tO1xuICAgICAgICBmb3IgKGxldCBub2RlIG9mIHRoaXMubm9kZXMpIHtcbiAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgSGVpZ2h0TWFwVGV4dClcbiAgICAgICAgICAgICAgICBub2RlLnVwZGF0ZUhlaWdodCh0aGlzLm9yYWNsZSwgcG9zKTtcbiAgICAgICAgICAgIHBvcyArPSBub2RlID8gbm9kZS5sZW5ndGggOiAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVzO1xuICAgIH1cbiAgICAvLyBBbHdheXMgY2FsbGVkIHdpdGggYSByZWdpb24gdGhhdCBvbiBib3RoIHNpZGVzIGVpdGhlciBzdHJldGNoZXNcbiAgICAvLyB0byBhIGxpbmUgYnJlYWsgb3IgdGhlIGVuZCBvZiB0aGUgZG9jdW1lbnQuXG4gICAgLy8gVGhlIHJldHVybmVkIGFycmF5IHVzZXMgbnVsbCB0byBpbmRpY2F0ZSBsaW5lIGJyZWFrcywgYnV0IG5ldmVyXG4gICAgLy8gc3RhcnRzIG9yIGVuZHMgaW4gYSBsaW5lIGJyZWFrLCBvciBoYXMgbXVsdGlwbGUgbGluZSBicmVha3MgbmV4dFxuICAgIC8vIHRvIGVhY2ggb3RoZXIuXG4gICAgc3RhdGljIGJ1aWxkKG9yYWNsZSwgZGVjb3JhdGlvbnMsIGZyb20sIHRvKSB7XG4gICAgICAgIGxldCBidWlsZGVyID0gbmV3IE5vZGVCdWlsZGVyKGZyb20sIG9yYWNsZSk7XG4gICAgICAgIFJhbmdlU2V0LnNwYW5zKGRlY29yYXRpb25zLCBmcm9tLCB0bywgYnVpbGRlciwgMCk7XG4gICAgICAgIHJldHVybiBidWlsZGVyLmZpbmlzaChmcm9tKTtcbiAgICB9XG59XG5mdW5jdGlvbiBoZWlnaHRSZWxldmFudERlY29DaGFuZ2VzKGEsIGIsIGRpZmYpIHtcbiAgICBsZXQgY29tcCA9IG5ldyBEZWNvcmF0aW9uQ29tcGFyYXRvcjtcbiAgICBSYW5nZVNldC5jb21wYXJlKGEsIGIsIGRpZmYsIGNvbXAsIDApO1xuICAgIHJldHVybiBjb21wLmNoYW5nZXM7XG59XG5jbGFzcyBEZWNvcmF0aW9uQ29tcGFyYXRvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlcyA9IFtdO1xuICAgIH1cbiAgICBjb21wYXJlUmFuZ2UoKSB7IH1cbiAgICBjb21wYXJlUG9pbnQoZnJvbSwgdG8sIGEsIGIpIHtcbiAgICAgICAgaWYgKGZyb20gPCB0byB8fCBhICYmIGEuaGVpZ2h0UmVsZXZhbnQgfHwgYiAmJiBiLmhlaWdodFJlbGV2YW50KVxuICAgICAgICAgICAgYWRkUmFuZ2UoZnJvbSwgdG8sIHRoaXMuY2hhbmdlcywgNSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiB2aXNpYmxlUGl4ZWxSYW5nZShkb20sIHBhZGRpbmdUb3ApIHtcbiAgICBsZXQgcmVjdCA9IGRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBsZXQgZG9jID0gZG9tLm93bmVyRG9jdW1lbnQsIHdpbiA9IGRvYy5kZWZhdWx0VmlldyB8fCB3aW5kb3c7XG4gICAgbGV0IGxlZnQgPSBNYXRoLm1heCgwLCByZWN0LmxlZnQpLCByaWdodCA9IE1hdGgubWluKHdpbi5pbm5lcldpZHRoLCByZWN0LnJpZ2h0KTtcbiAgICBsZXQgdG9wID0gTWF0aC5tYXgoMCwgcmVjdC50b3ApLCBib3R0b20gPSBNYXRoLm1pbih3aW4uaW5uZXJIZWlnaHQsIHJlY3QuYm90dG9tKTtcbiAgICBmb3IgKGxldCBwYXJlbnQgPSBkb20ucGFyZW50Tm9kZTsgcGFyZW50ICYmIHBhcmVudCAhPSBkb2MuYm9keTspIHtcbiAgICAgICAgaWYgKHBhcmVudC5ub2RlVHlwZSA9PSAxKSB7XG4gICAgICAgICAgICBsZXQgZWx0ID0gcGFyZW50O1xuICAgICAgICAgICAgbGV0IHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWx0KTtcbiAgICAgICAgICAgIGlmICgoZWx0LnNjcm9sbEhlaWdodCA+IGVsdC5jbGllbnRIZWlnaHQgfHwgZWx0LnNjcm9sbFdpZHRoID4gZWx0LmNsaWVudFdpZHRoKSAmJlxuICAgICAgICAgICAgICAgIHN0eWxlLm92ZXJmbG93ICE9IFwidmlzaWJsZVwiKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBhcmVudFJlY3QgPSBlbHQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgbGVmdCA9IE1hdGgubWF4KGxlZnQsIHBhcmVudFJlY3QubGVmdCk7XG4gICAgICAgICAgICAgICAgcmlnaHQgPSBNYXRoLm1pbihyaWdodCwgcGFyZW50UmVjdC5yaWdodCk7XG4gICAgICAgICAgICAgICAgdG9wID0gTWF0aC5tYXgodG9wLCBwYXJlbnRSZWN0LnRvcCk7XG4gICAgICAgICAgICAgICAgYm90dG9tID0gcGFyZW50ID09IGRvbS5wYXJlbnROb2RlID8gcGFyZW50UmVjdC5ib3R0b20gOiBNYXRoLm1pbihib3R0b20sIHBhcmVudFJlY3QuYm90dG9tKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcmVudCA9IHN0eWxlLnBvc2l0aW9uID09IFwiYWJzb2x1dGVcIiB8fCBzdHlsZS5wb3NpdGlvbiA9PSBcImZpeGVkXCIgPyBlbHQub2Zmc2V0UGFyZW50IDogZWx0LnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGFyZW50Lm5vZGVUeXBlID09IDExKSB7IC8vIFNoYWRvdyByb290XG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQuaG9zdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IGxlZnQ6IGxlZnQgLSByZWN0LmxlZnQsIHJpZ2h0OiBNYXRoLm1heChsZWZ0LCByaWdodCkgLSByZWN0LmxlZnQsXG4gICAgICAgIHRvcDogdG9wIC0gKHJlY3QudG9wICsgcGFkZGluZ1RvcCksIGJvdHRvbTogTWF0aC5tYXgodG9wLCBib3R0b20pIC0gKHJlY3QudG9wICsgcGFkZGluZ1RvcCkgfTtcbn1cbmZ1bmN0aW9uIGZ1bGxQaXhlbFJhbmdlKGRvbSwgcGFkZGluZ1RvcCkge1xuICAgIGxldCByZWN0ID0gZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiB7IGxlZnQ6IDAsIHJpZ2h0OiByZWN0LnJpZ2h0IC0gcmVjdC5sZWZ0LFxuICAgICAgICB0b3A6IHBhZGRpbmdUb3AsIGJvdHRvbTogcmVjdC5ib3R0b20gLSAocmVjdC50b3AgKyBwYWRkaW5nVG9wKSB9O1xufVxuLy8gTGluZSBnYXBzIGFyZSBwbGFjZWhvbGRlciB3aWRnZXRzIHVzZWQgdG8gaGlkZSBwaWVjZXMgb2Ygb3Zlcmxvbmdcbi8vIGxpbmVzIHdpdGhpbiB0aGUgdmlld3BvcnQsIGFzIGEga2x1ZGdlIHRvIGtlZXAgdGhlIGVkaXRvclxuLy8gcmVzcG9uc2l2ZSB3aGVuIGEgcmlkaWN1bG91c2x5IGxvbmcgbGluZSBpcyBsb2FkZWQgaW50byBpdC5cbmNsYXNzIExpbmVHYXAge1xuICAgIGNvbnN0cnVjdG9yKGZyb20sIHRvLCBzaXplKSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy5zaXplID0gc2l6ZTtcbiAgICB9XG4gICAgc3RhdGljIHNhbWUoYSwgYikge1xuICAgICAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGdBID0gYVtpXSwgZ0IgPSBiW2ldO1xuICAgICAgICAgICAgaWYgKGdBLmZyb20gIT0gZ0IuZnJvbSB8fCBnQS50byAhPSBnQi50byB8fCBnQS5zaXplICE9IGdCLnNpemUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBkcmF3KHZpZXdTdGF0ZSwgd3JhcHBpbmcpIHtcbiAgICAgICAgcmV0dXJuIERlY29yYXRpb24ucmVwbGFjZSh7XG4gICAgICAgICAgICB3aWRnZXQ6IG5ldyBMaW5lR2FwV2lkZ2V0KHRoaXMuc2l6ZSAqICh3cmFwcGluZyA/IHZpZXdTdGF0ZS5zY2FsZVkgOiB2aWV3U3RhdGUuc2NhbGVYKSwgd3JhcHBpbmcpXG4gICAgICAgIH0pLnJhbmdlKHRoaXMuZnJvbSwgdGhpcy50byk7XG4gICAgfVxufVxuY2xhc3MgTGluZUdhcFdpZGdldCBleHRlbmRzIFdpZGdldFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKHNpemUsIHZlcnRpY2FsKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgICAgIHRoaXMudmVydGljYWwgPSB2ZXJ0aWNhbDtcbiAgICB9XG4gICAgZXEob3RoZXIpIHsgcmV0dXJuIG90aGVyLnNpemUgPT0gdGhpcy5zaXplICYmIG90aGVyLnZlcnRpY2FsID09IHRoaXMudmVydGljYWw7IH1cbiAgICB0b0RPTSgpIHtcbiAgICAgICAgbGV0IGVsdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGlmICh0aGlzLnZlcnRpY2FsKSB7XG4gICAgICAgICAgICBlbHQuc3R5bGUuaGVpZ2h0ID0gdGhpcy5zaXplICsgXCJweFwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZWx0LnN0eWxlLndpZHRoID0gdGhpcy5zaXplICsgXCJweFwiO1xuICAgICAgICAgICAgZWx0LnN0eWxlLmhlaWdodCA9IFwiMnB4XCI7XG4gICAgICAgICAgICBlbHQuc3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsdDtcbiAgICB9XG4gICAgZ2V0IGVzdGltYXRlZEhlaWdodCgpIHsgcmV0dXJuIHRoaXMudmVydGljYWwgPyB0aGlzLnNpemUgOiAtMTsgfVxufVxuY2xhc3MgVmlld1N0YXRlIHtcbiAgICBjb25zdHJ1Y3RvcihzdGF0ZSkge1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIC8vIFRoZXNlIGFyZSBjb250ZW50RE9NLWxvY2FsIGNvb3JkaW5hdGVzXG4gICAgICAgIHRoaXMucGl4ZWxWaWV3cG9ydCA9IHsgbGVmdDogMCwgcmlnaHQ6IHdpbmRvdy5pbm5lcldpZHRoLCB0b3A6IDAsIGJvdHRvbTogMCB9O1xuICAgICAgICB0aGlzLmluVmlldyA9IHRydWU7XG4gICAgICAgIHRoaXMucGFkZGluZ1RvcCA9IDA7IC8vIFBhZGRpbmcgYWJvdmUgdGhlIGRvY3VtZW50LCBzY2FsZWRcbiAgICAgICAgdGhpcy5wYWRkaW5nQm90dG9tID0gMDsgLy8gUGFkZGluZyBiZWxvdyB0aGUgZG9jdW1lbnQsIHNjYWxlZFxuICAgICAgICB0aGlzLmNvbnRlbnRET01XaWR0aCA9IDA7IC8vIGNvbnRlbnRET00uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGhcbiAgICAgICAgdGhpcy5jb250ZW50RE9NSGVpZ2h0ID0gMDsgLy8gY29udGVudERPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHRcbiAgICAgICAgdGhpcy5lZGl0b3JIZWlnaHQgPSAwOyAvLyBzY3JvbGxET00uY2xpZW50SGVpZ2h0LCB1bnNjYWxlZFxuICAgICAgICB0aGlzLmVkaXRvcldpZHRoID0gMDsgLy8gc2Nyb2xsRE9NLmNsaWVudFdpZHRoLCB1bnNjYWxlZFxuICAgICAgICB0aGlzLnNjcm9sbFRvcCA9IDA7IC8vIExhc3Qgc2VlbiBzY3JvbGxET00uc2Nyb2xsVG9wLCBzY2FsZWRcbiAgICAgICAgdGhpcy5zY3JvbGxlZFRvQm90dG9tID0gdHJ1ZTtcbiAgICAgICAgLy8gVGhlIENTUy10cmFuc2Zvcm1hdGlvbiBzY2FsZSBvZiB0aGUgZWRpdG9yICh0cmFuc2Zvcm1lZCBzaXplIC9cbiAgICAgICAgLy8gY29uY3JldGUgc2l6ZSlcbiAgICAgICAgdGhpcy5zY2FsZVggPSAxO1xuICAgICAgICB0aGlzLnNjYWxlWSA9IDE7XG4gICAgICAgIC8vIFRoZSB2ZXJ0aWNhbCBwb3NpdGlvbiAoZG9jdW1lbnQtcmVsYXRpdmUpIHRvIHdoaWNoIHRvIGFuY2hvciB0aGVcbiAgICAgICAgLy8gc2Nyb2xsIHBvc2l0aW9uLiAtMSBtZWFucyBhbmNob3IgdG8gdGhlIGVuZCBvZiB0aGUgZG9jdW1lbnQuXG4gICAgICAgIHRoaXMuc2Nyb2xsQW5jaG9yUG9zID0gMDtcbiAgICAgICAgLy8gVGhlIGhlaWdodCBhdCB0aGUgYW5jaG9yIHBvc2l0aW9uLiBTZXQgYnkgdGhlIERPTSB1cGRhdGUgcGhhc2UuXG4gICAgICAgIC8vIC0xIG1lYW5zIG5vIGhlaWdodCBhdmFpbGFibGUuXG4gICAgICAgIHRoaXMuc2Nyb2xsQW5jaG9ySGVpZ2h0ID0gLTE7XG4gICAgICAgIC8vIFNlZSBWUC5NYXhET01IZWlnaHRcbiAgICAgICAgdGhpcy5zY2FsZXIgPSBJZFNjYWxlcjtcbiAgICAgICAgdGhpcy5zY3JvbGxUYXJnZXQgPSBudWxsO1xuICAgICAgICAvLyBCcmllZmx5IHNldCB0byB0cnVlIHdoZW4gcHJpbnRpbmcsIHRvIGRpc2FibGUgdmlld3BvcnQgbGltaXRpbmdcbiAgICAgICAgdGhpcy5wcmludGluZyA9IGZhbHNlO1xuICAgICAgICAvLyBGbGFnIHNldCB3aGVuIGVkaXRvciBjb250ZW50IHdhcyByZWRyYXduLCBzbyB0aGF0IHRoZSBuZXh0XG4gICAgICAgIC8vIG1lYXN1cmUgc3RhZ2Uga25vd3MgaXQgbXVzdCByZWFkIERPTSBsYXlvdXRcbiAgICAgICAgdGhpcy5tdXN0TWVhc3VyZUNvbnRlbnQgPSB0cnVlO1xuICAgICAgICB0aGlzLmRlZmF1bHRUZXh0RGlyZWN0aW9uID0gRGlyZWN0aW9uLkxUUjtcbiAgICAgICAgdGhpcy52aXNpYmxlUmFuZ2VzID0gW107XG4gICAgICAgIC8vIEN1cnNvciAnYXNzb2MnIGlzIG9ubHkgc2lnbmlmaWNhbnQgd2hlbiB0aGUgY3Vyc29yIGlzIG9uIGEgbGluZVxuICAgICAgICAvLyB3cmFwIHBvaW50LCB3aGVyZSBpdCBtdXN0IHN0aWNrIHRvIHRoZSBjaGFyYWN0ZXIgdGhhdCBpdCBpc1xuICAgICAgICAvLyBhc3NvY2lhdGVkIHdpdGguIFNpbmNlIGJyb3dzZXJzIGRvbid0IHByb3ZpZGUgYSByZWFzb25hYmxlXG4gICAgICAgIC8vIGludGVyZmFjZSB0byBzZXQgb3IgcXVlcnkgdGhpcywgd2hlbiBhIHNlbGVjdGlvbiBpcyBzZXQgdGhhdFxuICAgICAgICAvLyBtaWdodCBjYXVzZSB0aGlzIHRvIGJlIHNpZ25pZmljYW50LCB0aGlzIGZsYWcgaXMgc2V0LiBUaGUgbmV4dFxuICAgICAgICAvLyBtZWFzdXJlIHBoYXNlIHdpbGwgY2hlY2sgd2hldGhlciB0aGUgY3Vyc29yIGlzIG9uIGEgbGluZS13cmFwcGluZ1xuICAgICAgICAvLyBib3VuZGFyeSBhbmQsIGlmIHNvLCByZXNldCBpdCB0byBtYWtlIHN1cmUgaXQgaXMgcG9zaXRpb25lZCBpblxuICAgICAgICAvLyB0aGUgcmlnaHQgcGxhY2UuXG4gICAgICAgIHRoaXMubXVzdEVuZm9yY2VDdXJzb3JBc3NvYyA9IGZhbHNlO1xuICAgICAgICBsZXQgZ3Vlc3NXcmFwcGluZyA9IHN0YXRlLmZhY2V0KGNvbnRlbnRBdHRyaWJ1dGVzKS5zb21lKHYgPT4gdHlwZW9mIHYgIT0gXCJmdW5jdGlvblwiICYmIHYuY2xhc3MgPT0gXCJjbS1saW5lV3JhcHBpbmdcIik7XG4gICAgICAgIHRoaXMuaGVpZ2h0T3JhY2xlID0gbmV3IEhlaWdodE9yYWNsZShndWVzc1dyYXBwaW5nKTtcbiAgICAgICAgdGhpcy5zdGF0ZURlY28gPSBzdGF0ZS5mYWNldChkZWNvcmF0aW9ucykuZmlsdGVyKGQgPT4gdHlwZW9mIGQgIT0gXCJmdW5jdGlvblwiKTtcbiAgICAgICAgdGhpcy5oZWlnaHRNYXAgPSBIZWlnaHRNYXAuZW1wdHkoKS5hcHBseUNoYW5nZXModGhpcy5zdGF0ZURlY28sIFRleHQuZW1wdHksIHRoaXMuaGVpZ2h0T3JhY2xlLnNldERvYyhzdGF0ZS5kb2MpLCBbbmV3IENoYW5nZWRSYW5nZSgwLCAwLCAwLCBzdGF0ZS5kb2MubGVuZ3RoKV0pO1xuICAgICAgICB0aGlzLnZpZXdwb3J0ID0gdGhpcy5nZXRWaWV3cG9ydCgwLCBudWxsKTtcbiAgICAgICAgdGhpcy51cGRhdGVWaWV3cG9ydExpbmVzKCk7XG4gICAgICAgIHRoaXMudXBkYXRlRm9yVmlld3BvcnQoKTtcbiAgICAgICAgdGhpcy5saW5lR2FwcyA9IHRoaXMuZW5zdXJlTGluZUdhcHMoW10pO1xuICAgICAgICB0aGlzLmxpbmVHYXBEZWNvID0gRGVjb3JhdGlvbi5zZXQodGhpcy5saW5lR2Fwcy5tYXAoZ2FwID0+IGdhcC5kcmF3KHRoaXMsIGZhbHNlKSkpO1xuICAgICAgICB0aGlzLmNvbXB1dGVWaXNpYmxlUmFuZ2VzKCk7XG4gICAgfVxuICAgIHVwZGF0ZUZvclZpZXdwb3J0KCkge1xuICAgICAgICBsZXQgdmlld3BvcnRzID0gW3RoaXMudmlld3BvcnRdLCB7IG1haW4gfSA9IHRoaXMuc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSAxOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBwb3MgPSBpID8gbWFpbi5oZWFkIDogbWFpbi5hbmNob3I7XG4gICAgICAgICAgICBpZiAoIXZpZXdwb3J0cy5zb21lKCh7IGZyb20sIHRvIH0pID0+IHBvcyA+PSBmcm9tICYmIHBvcyA8PSB0bykpIHtcbiAgICAgICAgICAgICAgICBsZXQgeyBmcm9tLCB0byB9ID0gdGhpcy5saW5lQmxvY2tBdChwb3MpO1xuICAgICAgICAgICAgICAgIHZpZXdwb3J0cy5wdXNoKG5ldyBWaWV3cG9ydChmcm9tLCB0bykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMudmlld3BvcnRzID0gdmlld3BvcnRzLnNvcnQoKGEsIGIpID0+IGEuZnJvbSAtIGIuZnJvbSk7XG4gICAgICAgIHRoaXMuc2NhbGVyID0gdGhpcy5oZWlnaHRNYXAuaGVpZ2h0IDw9IDcwMDAwMDAgLyogVlAuTWF4RE9NSGVpZ2h0ICovID8gSWRTY2FsZXIgOlxuICAgICAgICAgICAgbmV3IEJpZ1NjYWxlcih0aGlzLmhlaWdodE9yYWNsZSwgdGhpcy5oZWlnaHRNYXAsIHRoaXMudmlld3BvcnRzKTtcbiAgICB9XG4gICAgdXBkYXRlVmlld3BvcnRMaW5lcygpIHtcbiAgICAgICAgdGhpcy52aWV3cG9ydExpbmVzID0gW107XG4gICAgICAgIHRoaXMuaGVpZ2h0TWFwLmZvckVhY2hMaW5lKHRoaXMudmlld3BvcnQuZnJvbSwgdGhpcy52aWV3cG9ydC50bywgdGhpcy5oZWlnaHRPcmFjbGUuc2V0RG9jKHRoaXMuc3RhdGUuZG9jKSwgMCwgMCwgYmxvY2sgPT4ge1xuICAgICAgICAgICAgdGhpcy52aWV3cG9ydExpbmVzLnB1c2godGhpcy5zY2FsZXIuc2NhbGUgPT0gMSA/IGJsb2NrIDogc2NhbGVCbG9jayhibG9jaywgdGhpcy5zY2FsZXIpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUsIHNjcm9sbFRhcmdldCA9IG51bGwpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHVwZGF0ZS5zdGF0ZTtcbiAgICAgICAgbGV0IHByZXZEZWNvID0gdGhpcy5zdGF0ZURlY287XG4gICAgICAgIHRoaXMuc3RhdGVEZWNvID0gdGhpcy5zdGF0ZS5mYWNldChkZWNvcmF0aW9ucykuZmlsdGVyKGQgPT4gdHlwZW9mIGQgIT0gXCJmdW5jdGlvblwiKTtcbiAgICAgICAgbGV0IGNvbnRlbnRDaGFuZ2VzID0gdXBkYXRlLmNoYW5nZWRSYW5nZXM7XG4gICAgICAgIGxldCBoZWlnaHRDaGFuZ2VzID0gQ2hhbmdlZFJhbmdlLmV4dGVuZFdpdGhSYW5nZXMoY29udGVudENoYW5nZXMsIGhlaWdodFJlbGV2YW50RGVjb0NoYW5nZXMocHJldkRlY28sIHRoaXMuc3RhdGVEZWNvLCB1cGRhdGUgPyB1cGRhdGUuY2hhbmdlcyA6IENoYW5nZVNldC5lbXB0eSh0aGlzLnN0YXRlLmRvYy5sZW5ndGgpKSk7XG4gICAgICAgIGxldCBwcmV2SGVpZ2h0ID0gdGhpcy5oZWlnaHRNYXAuaGVpZ2h0O1xuICAgICAgICBsZXQgc2Nyb2xsQW5jaG9yID0gdGhpcy5zY3JvbGxlZFRvQm90dG9tID8gbnVsbCA6IHRoaXMuc2Nyb2xsQW5jaG9yQXQodGhpcy5zY3JvbGxUb3ApO1xuICAgICAgICB0aGlzLmhlaWdodE1hcCA9IHRoaXMuaGVpZ2h0TWFwLmFwcGx5Q2hhbmdlcyh0aGlzLnN0YXRlRGVjbywgdXBkYXRlLnN0YXJ0U3RhdGUuZG9jLCB0aGlzLmhlaWdodE9yYWNsZS5zZXREb2ModGhpcy5zdGF0ZS5kb2MpLCBoZWlnaHRDaGFuZ2VzKTtcbiAgICAgICAgaWYgKHRoaXMuaGVpZ2h0TWFwLmhlaWdodCAhPSBwcmV2SGVpZ2h0KVxuICAgICAgICAgICAgdXBkYXRlLmZsYWdzIHw9IDIgLyogVXBkYXRlRmxhZy5IZWlnaHQgKi87XG4gICAgICAgIGlmIChzY3JvbGxBbmNob3IpIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsQW5jaG9yUG9zID0gdXBkYXRlLmNoYW5nZXMubWFwUG9zKHNjcm9sbEFuY2hvci5mcm9tLCAtMSk7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbEFuY2hvckhlaWdodCA9IHNjcm9sbEFuY2hvci50b3A7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbEFuY2hvclBvcyA9IC0xO1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxBbmNob3JIZWlnaHQgPSB0aGlzLmhlaWdodE1hcC5oZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHZpZXdwb3J0ID0gaGVpZ2h0Q2hhbmdlcy5sZW5ndGggPyB0aGlzLm1hcFZpZXdwb3J0KHRoaXMudmlld3BvcnQsIHVwZGF0ZS5jaGFuZ2VzKSA6IHRoaXMudmlld3BvcnQ7XG4gICAgICAgIGlmIChzY3JvbGxUYXJnZXQgJiYgKHNjcm9sbFRhcmdldC5yYW5nZS5oZWFkIDwgdmlld3BvcnQuZnJvbSB8fCBzY3JvbGxUYXJnZXQucmFuZ2UuaGVhZCA+IHZpZXdwb3J0LnRvKSB8fFxuICAgICAgICAgICAgIXRoaXMudmlld3BvcnRJc0FwcHJvcHJpYXRlKHZpZXdwb3J0KSlcbiAgICAgICAgICAgIHZpZXdwb3J0ID0gdGhpcy5nZXRWaWV3cG9ydCgwLCBzY3JvbGxUYXJnZXQpO1xuICAgICAgICBsZXQgdXBkYXRlTGluZXMgPSAhdXBkYXRlLmNoYW5nZXMuZW1wdHkgfHwgKHVwZGF0ZS5mbGFncyAmIDIgLyogVXBkYXRlRmxhZy5IZWlnaHQgKi8pIHx8XG4gICAgICAgICAgICB2aWV3cG9ydC5mcm9tICE9IHRoaXMudmlld3BvcnQuZnJvbSB8fCB2aWV3cG9ydC50byAhPSB0aGlzLnZpZXdwb3J0LnRvO1xuICAgICAgICB0aGlzLnZpZXdwb3J0ID0gdmlld3BvcnQ7XG4gICAgICAgIHRoaXMudXBkYXRlRm9yVmlld3BvcnQoKTtcbiAgICAgICAgaWYgKHVwZGF0ZUxpbmVzKVxuICAgICAgICAgICAgdGhpcy51cGRhdGVWaWV3cG9ydExpbmVzKCk7XG4gICAgICAgIGlmICh0aGlzLmxpbmVHYXBzLmxlbmd0aCB8fCB0aGlzLnZpZXdwb3J0LnRvIC0gdGhpcy52aWV3cG9ydC5mcm9tID4gKDIwMDAgLyogTEcuTWFyZ2luICovIDw8IDEpKVxuICAgICAgICAgICAgdGhpcy51cGRhdGVMaW5lR2Fwcyh0aGlzLmVuc3VyZUxpbmVHYXBzKHRoaXMubWFwTGluZUdhcHModGhpcy5saW5lR2FwcywgdXBkYXRlLmNoYW5nZXMpKSk7XG4gICAgICAgIHVwZGF0ZS5mbGFncyB8PSB0aGlzLmNvbXB1dGVWaXNpYmxlUmFuZ2VzKCk7XG4gICAgICAgIGlmIChzY3JvbGxUYXJnZXQpXG4gICAgICAgICAgICB0aGlzLnNjcm9sbFRhcmdldCA9IHNjcm9sbFRhcmdldDtcbiAgICAgICAgaWYgKCF0aGlzLm11c3RFbmZvcmNlQ3Vyc29yQXNzb2MgJiYgdXBkYXRlLnNlbGVjdGlvblNldCAmJiB1cGRhdGUudmlldy5saW5lV3JhcHBpbmcgJiZcbiAgICAgICAgICAgIHVwZGF0ZS5zdGF0ZS5zZWxlY3Rpb24ubWFpbi5lbXB0eSAmJiB1cGRhdGUuc3RhdGUuc2VsZWN0aW9uLm1haW4uYXNzb2MgJiZcbiAgICAgICAgICAgICF1cGRhdGUuc3RhdGUuZmFjZXQobmF0aXZlU2VsZWN0aW9uSGlkZGVuKSlcbiAgICAgICAgICAgIHRoaXMubXVzdEVuZm9yY2VDdXJzb3JBc3NvYyA9IHRydWU7XG4gICAgfVxuICAgIG1lYXN1cmUodmlldykge1xuICAgICAgICBsZXQgZG9tID0gdmlldy5jb250ZW50RE9NLCBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRvbSk7XG4gICAgICAgIGxldCBvcmFjbGUgPSB0aGlzLmhlaWdodE9yYWNsZTtcbiAgICAgICAgbGV0IHdoaXRlU3BhY2UgPSBzdHlsZS53aGl0ZVNwYWNlO1xuICAgICAgICB0aGlzLmRlZmF1bHRUZXh0RGlyZWN0aW9uID0gc3R5bGUuZGlyZWN0aW9uID09IFwicnRsXCIgPyBEaXJlY3Rpb24uUlRMIDogRGlyZWN0aW9uLkxUUjtcbiAgICAgICAgbGV0IHJlZnJlc2ggPSB0aGlzLmhlaWdodE9yYWNsZS5tdXN0UmVmcmVzaEZvcldyYXBwaW5nKHdoaXRlU3BhY2UpO1xuICAgICAgICBsZXQgZG9tUmVjdCA9IGRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgbGV0IG1lYXN1cmVDb250ZW50ID0gcmVmcmVzaCB8fCB0aGlzLm11c3RNZWFzdXJlQ29udGVudCB8fCB0aGlzLmNvbnRlbnRET01IZWlnaHQgIT0gZG9tUmVjdC5oZWlnaHQ7XG4gICAgICAgIHRoaXMuY29udGVudERPTUhlaWdodCA9IGRvbVJlY3QuaGVpZ2h0O1xuICAgICAgICB0aGlzLm11c3RNZWFzdXJlQ29udGVudCA9IGZhbHNlO1xuICAgICAgICBsZXQgcmVzdWx0ID0gMCwgYmlhcyA9IDA7XG4gICAgICAgIGlmIChkb21SZWN0LndpZHRoICYmIGRvbVJlY3QuaGVpZ2h0KSB7XG4gICAgICAgICAgICBsZXQgeyBzY2FsZVgsIHNjYWxlWSB9ID0gZ2V0U2NhbGUoZG9tLCBkb21SZWN0KTtcbiAgICAgICAgICAgIGlmICh0aGlzLnNjYWxlWCAhPSBzY2FsZVggfHwgdGhpcy5zY2FsZVkgIT0gc2NhbGVZKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2FsZVggPSBzY2FsZVg7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2FsZVkgPSBzY2FsZVk7XG4gICAgICAgICAgICAgICAgcmVzdWx0IHw9IDggLyogVXBkYXRlRmxhZy5HZW9tZXRyeSAqLztcbiAgICAgICAgICAgICAgICByZWZyZXNoID0gbWVhc3VyZUNvbnRlbnQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFZlcnRpY2FsIHBhZGRpbmdcbiAgICAgICAgbGV0IHBhZGRpbmdUb3AgPSAocGFyc2VJbnQoc3R5bGUucGFkZGluZ1RvcCkgfHwgMCkgKiB0aGlzLnNjYWxlWTtcbiAgICAgICAgbGV0IHBhZGRpbmdCb3R0b20gPSAocGFyc2VJbnQoc3R5bGUucGFkZGluZ0JvdHRvbSkgfHwgMCkgKiB0aGlzLnNjYWxlWTtcbiAgICAgICAgaWYgKHRoaXMucGFkZGluZ1RvcCAhPSBwYWRkaW5nVG9wIHx8IHRoaXMucGFkZGluZ0JvdHRvbSAhPSBwYWRkaW5nQm90dG9tKSB7XG4gICAgICAgICAgICB0aGlzLnBhZGRpbmdUb3AgPSBwYWRkaW5nVG9wO1xuICAgICAgICAgICAgdGhpcy5wYWRkaW5nQm90dG9tID0gcGFkZGluZ0JvdHRvbTtcbiAgICAgICAgICAgIHJlc3VsdCB8PSA4IC8qIFVwZGF0ZUZsYWcuR2VvbWV0cnkgKi8gfCAyIC8qIFVwZGF0ZUZsYWcuSGVpZ2h0ICovO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmVkaXRvcldpZHRoICE9IHZpZXcuc2Nyb2xsRE9NLmNsaWVudFdpZHRoKSB7XG4gICAgICAgICAgICBpZiAob3JhY2xlLmxpbmVXcmFwcGluZylcbiAgICAgICAgICAgICAgICBtZWFzdXJlQ29udGVudCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmVkaXRvcldpZHRoID0gdmlldy5zY3JvbGxET00uY2xpZW50V2lkdGg7XG4gICAgICAgICAgICByZXN1bHQgfD0gOCAvKiBVcGRhdGVGbGFnLkdlb21ldHJ5ICovO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzY3JvbGxUb3AgPSB2aWV3LnNjcm9sbERPTS5zY3JvbGxUb3AgKiB0aGlzLnNjYWxlWTtcbiAgICAgICAgaWYgKHRoaXMuc2Nyb2xsVG9wICE9IHNjcm9sbFRvcCkge1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxBbmNob3JIZWlnaHQgPSAtMTtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG9wID0gc2Nyb2xsVG9wO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2Nyb2xsZWRUb0JvdHRvbSA9IGlzU2Nyb2xsZWRUb0JvdHRvbSh2aWV3LnNjcm9sbERPTSk7XG4gICAgICAgIC8vIFBpeGVsIHZpZXdwb3J0XG4gICAgICAgIGxldCBwaXhlbFZpZXdwb3J0ID0gKHRoaXMucHJpbnRpbmcgPyBmdWxsUGl4ZWxSYW5nZSA6IHZpc2libGVQaXhlbFJhbmdlKShkb20sIHRoaXMucGFkZGluZ1RvcCk7XG4gICAgICAgIGxldCBkVG9wID0gcGl4ZWxWaWV3cG9ydC50b3AgLSB0aGlzLnBpeGVsVmlld3BvcnQudG9wLCBkQm90dG9tID0gcGl4ZWxWaWV3cG9ydC5ib3R0b20gLSB0aGlzLnBpeGVsVmlld3BvcnQuYm90dG9tO1xuICAgICAgICB0aGlzLnBpeGVsVmlld3BvcnQgPSBwaXhlbFZpZXdwb3J0O1xuICAgICAgICBsZXQgaW5WaWV3ID0gdGhpcy5waXhlbFZpZXdwb3J0LmJvdHRvbSA+IHRoaXMucGl4ZWxWaWV3cG9ydC50b3AgJiYgdGhpcy5waXhlbFZpZXdwb3J0LnJpZ2h0ID4gdGhpcy5waXhlbFZpZXdwb3J0LmxlZnQ7XG4gICAgICAgIGlmIChpblZpZXcgIT0gdGhpcy5pblZpZXcpIHtcbiAgICAgICAgICAgIHRoaXMuaW5WaWV3ID0gaW5WaWV3O1xuICAgICAgICAgICAgaWYgKGluVmlldylcbiAgICAgICAgICAgICAgICBtZWFzdXJlQ29udGVudCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmluVmlldyAmJiAhdGhpcy5zY3JvbGxUYXJnZXQpXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgbGV0IGNvbnRlbnRXaWR0aCA9IGRvbVJlY3Qud2lkdGg7XG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnRET01XaWR0aCAhPSBjb250ZW50V2lkdGggfHwgdGhpcy5lZGl0b3JIZWlnaHQgIT0gdmlldy5zY3JvbGxET00uY2xpZW50SGVpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRET01XaWR0aCA9IGRvbVJlY3Qud2lkdGg7XG4gICAgICAgICAgICB0aGlzLmVkaXRvckhlaWdodCA9IHZpZXcuc2Nyb2xsRE9NLmNsaWVudEhlaWdodDtcbiAgICAgICAgICAgIHJlc3VsdCB8PSA4IC8qIFVwZGF0ZUZsYWcuR2VvbWV0cnkgKi87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lYXN1cmVDb250ZW50KSB7XG4gICAgICAgICAgICBsZXQgbGluZUhlaWdodHMgPSB2aWV3LmRvY1ZpZXcubWVhc3VyZVZpc2libGVMaW5lSGVpZ2h0cyh0aGlzLnZpZXdwb3J0KTtcbiAgICAgICAgICAgIGlmIChvcmFjbGUubXVzdFJlZnJlc2hGb3JIZWlnaHRzKGxpbmVIZWlnaHRzKSlcbiAgICAgICAgICAgICAgICByZWZyZXNoID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChyZWZyZXNoIHx8IG9yYWNsZS5saW5lV3JhcHBpbmcgJiYgTWF0aC5hYnMoY29udGVudFdpZHRoIC0gdGhpcy5jb250ZW50RE9NV2lkdGgpID4gb3JhY2xlLmNoYXJXaWR0aCkge1xuICAgICAgICAgICAgICAgIGxldCB7IGxpbmVIZWlnaHQsIGNoYXJXaWR0aCwgdGV4dEhlaWdodCB9ID0gdmlldy5kb2NWaWV3Lm1lYXN1cmVUZXh0U2l6ZSgpO1xuICAgICAgICAgICAgICAgIHJlZnJlc2ggPSBsaW5lSGVpZ2h0ID4gMCAmJiBvcmFjbGUucmVmcmVzaCh3aGl0ZVNwYWNlLCBsaW5lSGVpZ2h0LCBjaGFyV2lkdGgsIHRleHRIZWlnaHQsIGNvbnRlbnRXaWR0aCAvIGNoYXJXaWR0aCwgbGluZUhlaWdodHMpO1xuICAgICAgICAgICAgICAgIGlmIChyZWZyZXNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZpZXcuZG9jVmlldy5taW5XaWR0aCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCB8PSA4IC8qIFVwZGF0ZUZsYWcuR2VvbWV0cnkgKi87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRUb3AgPiAwICYmIGRCb3R0b20gPiAwKVxuICAgICAgICAgICAgICAgIGJpYXMgPSBNYXRoLm1heChkVG9wLCBkQm90dG9tKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGRUb3AgPCAwICYmIGRCb3R0b20gPCAwKVxuICAgICAgICAgICAgICAgIGJpYXMgPSBNYXRoLm1pbihkVG9wLCBkQm90dG9tKTtcbiAgICAgICAgICAgIG9yYWNsZS5oZWlnaHRDaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKGxldCB2cCBvZiB0aGlzLnZpZXdwb3J0cykge1xuICAgICAgICAgICAgICAgIGxldCBoZWlnaHRzID0gdnAuZnJvbSA9PSB0aGlzLnZpZXdwb3J0LmZyb20gPyBsaW5lSGVpZ2h0cyA6IHZpZXcuZG9jVmlldy5tZWFzdXJlVmlzaWJsZUxpbmVIZWlnaHRzKHZwKTtcbiAgICAgICAgICAgICAgICB0aGlzLmhlaWdodE1hcCA9IChyZWZyZXNoID8gSGVpZ2h0TWFwLmVtcHR5KCkuYXBwbHlDaGFuZ2VzKHRoaXMuc3RhdGVEZWNvLCBUZXh0LmVtcHR5LCB0aGlzLmhlaWdodE9yYWNsZSwgW25ldyBDaGFuZ2VkUmFuZ2UoMCwgMCwgMCwgdmlldy5zdGF0ZS5kb2MubGVuZ3RoKV0pIDogdGhpcy5oZWlnaHRNYXApLnVwZGF0ZUhlaWdodChvcmFjbGUsIDAsIHJlZnJlc2gsIG5ldyBNZWFzdXJlZEhlaWdodHModnAuZnJvbSwgaGVpZ2h0cykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9yYWNsZS5oZWlnaHRDaGFuZ2VkKVxuICAgICAgICAgICAgICAgIHJlc3VsdCB8PSAyIC8qIFVwZGF0ZUZsYWcuSGVpZ2h0ICovO1xuICAgICAgICB9XG4gICAgICAgIGxldCB2aWV3cG9ydENoYW5nZSA9ICF0aGlzLnZpZXdwb3J0SXNBcHByb3ByaWF0ZSh0aGlzLnZpZXdwb3J0LCBiaWFzKSB8fFxuICAgICAgICAgICAgdGhpcy5zY3JvbGxUYXJnZXQgJiYgKHRoaXMuc2Nyb2xsVGFyZ2V0LnJhbmdlLmhlYWQgPCB0aGlzLnZpZXdwb3J0LmZyb20gfHxcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbFRhcmdldC5yYW5nZS5oZWFkID4gdGhpcy52aWV3cG9ydC50byk7XG4gICAgICAgIGlmICh2aWV3cG9ydENoYW5nZSlcbiAgICAgICAgICAgIHRoaXMudmlld3BvcnQgPSB0aGlzLmdldFZpZXdwb3J0KGJpYXMsIHRoaXMuc2Nyb2xsVGFyZ2V0KTtcbiAgICAgICAgdGhpcy51cGRhdGVGb3JWaWV3cG9ydCgpO1xuICAgICAgICBpZiAoKHJlc3VsdCAmIDIgLyogVXBkYXRlRmxhZy5IZWlnaHQgKi8pIHx8IHZpZXdwb3J0Q2hhbmdlKVxuICAgICAgICAgICAgdGhpcy51cGRhdGVWaWV3cG9ydExpbmVzKCk7XG4gICAgICAgIGlmICh0aGlzLmxpbmVHYXBzLmxlbmd0aCB8fCB0aGlzLnZpZXdwb3J0LnRvIC0gdGhpcy52aWV3cG9ydC5mcm9tID4gKDIwMDAgLyogTEcuTWFyZ2luICovIDw8IDEpKVxuICAgICAgICAgICAgdGhpcy51cGRhdGVMaW5lR2Fwcyh0aGlzLmVuc3VyZUxpbmVHYXBzKHJlZnJlc2ggPyBbXSA6IHRoaXMubGluZUdhcHMsIHZpZXcpKTtcbiAgICAgICAgcmVzdWx0IHw9IHRoaXMuY29tcHV0ZVZpc2libGVSYW5nZXMoKTtcbiAgICAgICAgaWYgKHRoaXMubXVzdEVuZm9yY2VDdXJzb3JBc3NvYykge1xuICAgICAgICAgICAgdGhpcy5tdXN0RW5mb3JjZUN1cnNvckFzc29jID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIGRvbmUgaW4gdGhlIHJlYWQgc3RhZ2UsIGJlY2F1c2UgbW92aW5nIHRoZSBzZWxlY3Rpb25cbiAgICAgICAgICAgIC8vIHRvIGEgbGluZSBlbmQgaXMgZ29pbmcgdG8gdHJpZ2dlciBhIGxheW91dCBhbnl3YXksIHNvIGl0XG4gICAgICAgICAgICAvLyBjYW4ndCBiZSBhIHB1cmUgd3JpdGUuIEl0IHNob3VsZCBiZSByYXJlIHRoYXQgaXQgZG9lcyBhbnlcbiAgICAgICAgICAgIC8vIHdyaXRpbmcuXG4gICAgICAgICAgICB2aWV3LmRvY1ZpZXcuZW5mb3JjZUN1cnNvckFzc29jKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZ2V0IHZpc2libGVUb3AoKSB7IHJldHVybiB0aGlzLnNjYWxlci5mcm9tRE9NKHRoaXMucGl4ZWxWaWV3cG9ydC50b3ApOyB9XG4gICAgZ2V0IHZpc2libGVCb3R0b20oKSB7IHJldHVybiB0aGlzLnNjYWxlci5mcm9tRE9NKHRoaXMucGl4ZWxWaWV3cG9ydC5ib3R0b20pOyB9XG4gICAgZ2V0Vmlld3BvcnQoYmlhcywgc2Nyb2xsVGFyZ2V0KSB7XG4gICAgICAgIC8vIFRoaXMgd2lsbCBkaXZpZGUgVlAuTWFyZ2luIGJldHdlZW4gdGhlIHRvcCBhbmQgdGhlXG4gICAgICAgIC8vIGJvdHRvbSwgZGVwZW5kaW5nIG9uIHRoZSBiaWFzICh0aGUgY2hhbmdlIGluIHZpZXdwb3J0IHBvc2l0aW9uXG4gICAgICAgIC8vIHNpbmNlIHRoZSBsYXN0IHVwZGF0ZSkuIEl0J2xsIGhvbGQgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG4gICAgICAgIGxldCBtYXJnaW5Ub3AgPSAwLjUgLSBNYXRoLm1heCgtMC41LCBNYXRoLm1pbigwLjUsIGJpYXMgLyAxMDAwIC8qIFZQLk1hcmdpbiAqLyAvIDIpKTtcbiAgICAgICAgbGV0IG1hcCA9IHRoaXMuaGVpZ2h0TWFwLCBvcmFjbGUgPSB0aGlzLmhlaWdodE9yYWNsZTtcbiAgICAgICAgbGV0IHsgdmlzaWJsZVRvcCwgdmlzaWJsZUJvdHRvbSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHZpZXdwb3J0ID0gbmV3IFZpZXdwb3J0KG1hcC5saW5lQXQodmlzaWJsZVRvcCAtIG1hcmdpblRvcCAqIDEwMDAgLyogVlAuTWFyZ2luICovLCBRdWVyeVR5cGUuQnlIZWlnaHQsIG9yYWNsZSwgMCwgMCkuZnJvbSwgbWFwLmxpbmVBdCh2aXNpYmxlQm90dG9tICsgKDEgLSBtYXJnaW5Ub3ApICogMTAwMCAvKiBWUC5NYXJnaW4gKi8sIFF1ZXJ5VHlwZS5CeUhlaWdodCwgb3JhY2xlLCAwLCAwKS50byk7XG4gICAgICAgIC8vIElmIHNjcm9sbFRhcmdldCBpcyBnaXZlbiwgbWFrZSBzdXJlIHRoZSB2aWV3cG9ydCBpbmNsdWRlcyB0aGF0IHBvc2l0aW9uXG4gICAgICAgIGlmIChzY3JvbGxUYXJnZXQpIHtcbiAgICAgICAgICAgIGxldCB7IGhlYWQgfSA9IHNjcm9sbFRhcmdldC5yYW5nZTtcbiAgICAgICAgICAgIGlmIChoZWFkIDwgdmlld3BvcnQuZnJvbSB8fCBoZWFkID4gdmlld3BvcnQudG8pIHtcbiAgICAgICAgICAgICAgICBsZXQgdmlld0hlaWdodCA9IE1hdGgubWluKHRoaXMuZWRpdG9ySGVpZ2h0LCB0aGlzLnBpeGVsVmlld3BvcnQuYm90dG9tIC0gdGhpcy5waXhlbFZpZXdwb3J0LnRvcCk7XG4gICAgICAgICAgICAgICAgbGV0IGJsb2NrID0gbWFwLmxpbmVBdChoZWFkLCBRdWVyeVR5cGUuQnlQb3MsIG9yYWNsZSwgMCwgMCksIHRvcFBvcztcbiAgICAgICAgICAgICAgICBpZiAoc2Nyb2xsVGFyZ2V0LnkgPT0gXCJjZW50ZXJcIilcbiAgICAgICAgICAgICAgICAgICAgdG9wUG9zID0gKGJsb2NrLnRvcCArIGJsb2NrLmJvdHRvbSkgLyAyIC0gdmlld0hlaWdodCAvIDI7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2Nyb2xsVGFyZ2V0LnkgPT0gXCJzdGFydFwiIHx8IHNjcm9sbFRhcmdldC55ID09IFwibmVhcmVzdFwiICYmIGhlYWQgPCB2aWV3cG9ydC5mcm9tKVxuICAgICAgICAgICAgICAgICAgICB0b3BQb3MgPSBibG9jay50b3A7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0b3BQb3MgPSBibG9jay5ib3R0b20gLSB2aWV3SGVpZ2h0O1xuICAgICAgICAgICAgICAgIHZpZXdwb3J0ID0gbmV3IFZpZXdwb3J0KG1hcC5saW5lQXQodG9wUG9zIC0gMTAwMCAvKiBWUC5NYXJnaW4gKi8gLyAyLCBRdWVyeVR5cGUuQnlIZWlnaHQsIG9yYWNsZSwgMCwgMCkuZnJvbSwgbWFwLmxpbmVBdCh0b3BQb3MgKyB2aWV3SGVpZ2h0ICsgMTAwMCAvKiBWUC5NYXJnaW4gKi8gLyAyLCBRdWVyeVR5cGUuQnlIZWlnaHQsIG9yYWNsZSwgMCwgMCkudG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2aWV3cG9ydDtcbiAgICB9XG4gICAgbWFwVmlld3BvcnQodmlld3BvcnQsIGNoYW5nZXMpIHtcbiAgICAgICAgbGV0IGZyb20gPSBjaGFuZ2VzLm1hcFBvcyh2aWV3cG9ydC5mcm9tLCAtMSksIHRvID0gY2hhbmdlcy5tYXBQb3Modmlld3BvcnQudG8sIDEpO1xuICAgICAgICByZXR1cm4gbmV3IFZpZXdwb3J0KHRoaXMuaGVpZ2h0TWFwLmxpbmVBdChmcm9tLCBRdWVyeVR5cGUuQnlQb3MsIHRoaXMuaGVpZ2h0T3JhY2xlLCAwLCAwKS5mcm9tLCB0aGlzLmhlaWdodE1hcC5saW5lQXQodG8sIFF1ZXJ5VHlwZS5CeVBvcywgdGhpcy5oZWlnaHRPcmFjbGUsIDAsIDApLnRvKTtcbiAgICB9XG4gICAgLy8gQ2hlY2tzIGlmIGEgZ2l2ZW4gdmlld3BvcnQgY292ZXJzIHRoZSB2aXNpYmxlIHBhcnQgb2YgdGhlXG4gICAgLy8gZG9jdW1lbnQgYW5kIG5vdCB0b28gbXVjaCBiZXlvbmQgdGhhdC5cbiAgICB2aWV3cG9ydElzQXBwcm9wcmlhdGUoeyBmcm9tLCB0byB9LCBiaWFzID0gMCkge1xuICAgICAgICBpZiAoIXRoaXMuaW5WaWV3KVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGxldCB7IHRvcCB9ID0gdGhpcy5oZWlnaHRNYXAubGluZUF0KGZyb20sIFF1ZXJ5VHlwZS5CeVBvcywgdGhpcy5oZWlnaHRPcmFjbGUsIDAsIDApO1xuICAgICAgICBsZXQgeyBib3R0b20gfSA9IHRoaXMuaGVpZ2h0TWFwLmxpbmVBdCh0bywgUXVlcnlUeXBlLkJ5UG9zLCB0aGlzLmhlaWdodE9yYWNsZSwgMCwgMCk7XG4gICAgICAgIGxldCB7IHZpc2libGVUb3AsIHZpc2libGVCb3R0b20gfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiAoZnJvbSA9PSAwIHx8IHRvcCA8PSB2aXNpYmxlVG9wIC0gTWF0aC5tYXgoMTAgLyogVlAuTWluQ292ZXJNYXJnaW4gKi8sIE1hdGgubWluKC1iaWFzLCAyNTAgLyogVlAuTWF4Q292ZXJNYXJnaW4gKi8pKSkgJiZcbiAgICAgICAgICAgICh0byA9PSB0aGlzLnN0YXRlLmRvYy5sZW5ndGggfHxcbiAgICAgICAgICAgICAgICBib3R0b20gPj0gdmlzaWJsZUJvdHRvbSArIE1hdGgubWF4KDEwIC8qIFZQLk1pbkNvdmVyTWFyZ2luICovLCBNYXRoLm1pbihiaWFzLCAyNTAgLyogVlAuTWF4Q292ZXJNYXJnaW4gKi8pKSkgJiZcbiAgICAgICAgICAgICh0b3AgPiB2aXNpYmxlVG9wIC0gMiAqIDEwMDAgLyogVlAuTWFyZ2luICovICYmIGJvdHRvbSA8IHZpc2libGVCb3R0b20gKyAyICogMTAwMCAvKiBWUC5NYXJnaW4gKi8pO1xuICAgIH1cbiAgICBtYXBMaW5lR2FwcyhnYXBzLCBjaGFuZ2VzKSB7XG4gICAgICAgIGlmICghZ2Fwcy5sZW5ndGggfHwgY2hhbmdlcy5lbXB0eSlcbiAgICAgICAgICAgIHJldHVybiBnYXBzO1xuICAgICAgICBsZXQgbWFwcGVkID0gW107XG4gICAgICAgIGZvciAobGV0IGdhcCBvZiBnYXBzKVxuICAgICAgICAgICAgaWYgKCFjaGFuZ2VzLnRvdWNoZXNSYW5nZShnYXAuZnJvbSwgZ2FwLnRvKSlcbiAgICAgICAgICAgICAgICBtYXBwZWQucHVzaChuZXcgTGluZUdhcChjaGFuZ2VzLm1hcFBvcyhnYXAuZnJvbSksIGNoYW5nZXMubWFwUG9zKGdhcC50byksIGdhcC5zaXplKSk7XG4gICAgICAgIHJldHVybiBtYXBwZWQ7XG4gICAgfVxuICAgIC8vIENvbXB1dGVzIHBvc2l0aW9ucyBpbiB0aGUgdmlld3BvcnQgd2hlcmUgdGhlIHN0YXJ0IG9yIGVuZCBvZiBhXG4gICAgLy8gbGluZSBzaG91bGQgYmUgaGlkZGVuLCB0cnlpbmcgdG8gcmV1c2UgZXhpc3RpbmcgbGluZSBnYXBzIHdoZW5cbiAgICAvLyBhcHByb3ByaWF0ZSB0byBhdm9pZCB1bm5lY2Nlc2FyeSByZWRyYXdzLlxuICAgIC8vIFVzZXMgY3J1ZGUgY2hhcmFjdGVyLWNvdW50aW5nIGZvciB0aGUgcG9zaXRpb25pbmcgYW5kIHNpemluZyxcbiAgICAvLyBzaW5jZSBhY3R1YWwgRE9NIGNvb3JkaW5hdGVzIGFyZW4ndCBhbHdheXMgYXZhaWxhYmxlIGFuZFxuICAgIC8vIHByZWRpY3RhYmxlLiBSZWxpZXMgb24gZ2VuZXJvdXMgbWFyZ2lucyAoc2VlIExHLk1hcmdpbikgdG8gaGlkZVxuICAgIC8vIHRoZSBhcnRpZmFjdHMgdGhpcyBtaWdodCBwcm9kdWNlIGZyb20gdGhlIHVzZXIuXG4gICAgZW5zdXJlTGluZUdhcHMoY3VycmVudCwgbWF5TWVhc3VyZSkge1xuICAgICAgICBsZXQgd3JhcHBpbmcgPSB0aGlzLmhlaWdodE9yYWNsZS5saW5lV3JhcHBpbmc7XG4gICAgICAgIGxldCBtYXJnaW4gPSB3cmFwcGluZyA/IDEwMDAwIC8qIExHLk1hcmdpbldyYXAgKi8gOiAyMDAwIC8qIExHLk1hcmdpbiAqLywgaGFsZk1hcmdpbiA9IG1hcmdpbiA+PiAxLCBkb3VibGVNYXJnaW4gPSBtYXJnaW4gPDwgMTtcbiAgICAgICAgLy8gVGhlIG5vbi13cmFwcGluZyBsb2dpYyB3b24ndCB3b3JrIGF0IGFsbCBpbiBwcmVkb21pbmFudGx5IHJpZ2h0LXRvLWxlZnQgdGV4dC5cbiAgICAgICAgaWYgKHRoaXMuZGVmYXVsdFRleHREaXJlY3Rpb24gIT0gRGlyZWN0aW9uLkxUUiAmJiAhd3JhcHBpbmcpXG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIGxldCBnYXBzID0gW107XG4gICAgICAgIGxldCBhZGRHYXAgPSAoZnJvbSwgdG8sIGxpbmUsIHN0cnVjdHVyZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHRvIC0gZnJvbSA8IGhhbGZNYXJnaW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IHNlbCA9IHRoaXMuc3RhdGUuc2VsZWN0aW9uLm1haW4sIGF2b2lkID0gW3NlbC5mcm9tXTtcbiAgICAgICAgICAgIGlmICghc2VsLmVtcHR5KVxuICAgICAgICAgICAgICAgIGF2b2lkLnB1c2goc2VsLnRvKTtcbiAgICAgICAgICAgIGZvciAobGV0IHBvcyBvZiBhdm9pZCkge1xuICAgICAgICAgICAgICAgIGlmIChwb3MgPiBmcm9tICYmIHBvcyA8IHRvKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZEdhcChmcm9tLCBwb3MgLSAxMCAvKiBMRy5TZWxlY3Rpb25NYXJnaW4gKi8sIGxpbmUsIHN0cnVjdHVyZSk7XG4gICAgICAgICAgICAgICAgICAgIGFkZEdhcChwb3MgKyAxMCAvKiBMRy5TZWxlY3Rpb25NYXJnaW4gKi8sIHRvLCBsaW5lLCBzdHJ1Y3R1cmUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGdhcCA9IGZpbmQoY3VycmVudCwgZ2FwID0+IGdhcC5mcm9tID49IGxpbmUuZnJvbSAmJiBnYXAudG8gPD0gbGluZS50byAmJlxuICAgICAgICAgICAgICAgIE1hdGguYWJzKGdhcC5mcm9tIC0gZnJvbSkgPCBoYWxmTWFyZ2luICYmIE1hdGguYWJzKGdhcC50byAtIHRvKSA8IGhhbGZNYXJnaW4gJiZcbiAgICAgICAgICAgICAgICAhYXZvaWQuc29tZShwb3MgPT4gZ2FwLmZyb20gPCBwb3MgJiYgZ2FwLnRvID4gcG9zKSk7XG4gICAgICAgICAgICBpZiAoIWdhcCkge1xuICAgICAgICAgICAgICAgIC8vIFdoZW4gc2Nyb2xsaW5nIGRvd24sIHNuYXAgZ2FwIGVuZHMgdG8gbGluZSBzdGFydHMgdG8gYXZvaWQgc2hpZnRzIGluIHdyYXBwaW5nXG4gICAgICAgICAgICAgICAgaWYgKHRvIDwgbGluZS50byAmJiBtYXlNZWFzdXJlICYmIHdyYXBwaW5nICYmXG4gICAgICAgICAgICAgICAgICAgIG1heU1lYXN1cmUudmlzaWJsZVJhbmdlcy5zb21lKHIgPT4gci5mcm9tIDw9IHRvICYmIHIudG8gPj0gdG8pKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBsaW5lU3RhcnQgPSBtYXlNZWFzdXJlLm1vdmVUb0xpbmVCb3VuZGFyeShFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHRvKSwgZmFsc2UsIHRydWUpLmhlYWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaW5lU3RhcnQgPiBmcm9tKVxuICAgICAgICAgICAgICAgICAgICAgICAgdG8gPSBsaW5lU3RhcnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGdhcCA9IG5ldyBMaW5lR2FwKGZyb20sIHRvLCB0aGlzLmdhcFNpemUobGluZSwgZnJvbSwgdG8sIHN0cnVjdHVyZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2Fwcy5wdXNoKGdhcCk7XG4gICAgICAgIH07XG4gICAgICAgIGZvciAobGV0IGxpbmUgb2YgdGhpcy52aWV3cG9ydExpbmVzKSB7XG4gICAgICAgICAgICBpZiAobGluZS5sZW5ndGggPCBkb3VibGVNYXJnaW4pXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBsZXQgc3RydWN0dXJlID0gbGluZVN0cnVjdHVyZShsaW5lLmZyb20sIGxpbmUudG8sIHRoaXMuc3RhdGVEZWNvKTtcbiAgICAgICAgICAgIGlmIChzdHJ1Y3R1cmUudG90YWwgPCBkb3VibGVNYXJnaW4pXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gdGhpcy5zY3JvbGxUYXJnZXQgPyB0aGlzLnNjcm9sbFRhcmdldC5yYW5nZS5oZWFkIDogbnVsbDtcbiAgICAgICAgICAgIGxldCB2aWV3RnJvbSwgdmlld1RvO1xuICAgICAgICAgICAgaWYgKHdyYXBwaW5nKSB7XG4gICAgICAgICAgICAgICAgbGV0IG1hcmdpbkhlaWdodCA9IChtYXJnaW4gLyB0aGlzLmhlaWdodE9yYWNsZS5saW5lTGVuZ3RoKSAqIHRoaXMuaGVpZ2h0T3JhY2xlLmxpbmVIZWlnaHQ7XG4gICAgICAgICAgICAgICAgbGV0IHRvcCwgYm90O1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0RnJhYyA9IGZpbmRGcmFjdGlvbihzdHJ1Y3R1cmUsIHRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzcGFjZUZyYWMgPSAoKHRoaXMudmlzaWJsZUJvdHRvbSAtIHRoaXMudmlzaWJsZVRvcCkgLyAyICsgbWFyZ2luSGVpZ2h0KSAvIGxpbmUuaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICB0b3AgPSB0YXJnZXRGcmFjIC0gc3BhY2VGcmFjO1xuICAgICAgICAgICAgICAgICAgICBib3QgPSB0YXJnZXRGcmFjICsgc3BhY2VGcmFjO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdG9wID0gKHRoaXMudmlzaWJsZVRvcCAtIGxpbmUudG9wIC0gbWFyZ2luSGVpZ2h0KSAvIGxpbmUuaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBib3QgPSAodGhpcy52aXNpYmxlQm90dG9tIC0gbGluZS50b3AgKyBtYXJnaW5IZWlnaHQpIC8gbGluZS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZpZXdGcm9tID0gZmluZFBvc2l0aW9uKHN0cnVjdHVyZSwgdG9wKTtcbiAgICAgICAgICAgICAgICB2aWV3VG8gPSBmaW5kUG9zaXRpb24oc3RydWN0dXJlLCBib3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IHRvdGFsV2lkdGggPSBzdHJ1Y3R1cmUudG90YWwgKiB0aGlzLmhlaWdodE9yYWNsZS5jaGFyV2lkdGg7XG4gICAgICAgICAgICAgICAgbGV0IG1hcmdpbldpZHRoID0gbWFyZ2luICogdGhpcy5oZWlnaHRPcmFjbGUuY2hhcldpZHRoO1xuICAgICAgICAgICAgICAgIGxldCBsZWZ0LCByaWdodDtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRhcmdldEZyYWMgPSBmaW5kRnJhY3Rpb24oc3RydWN0dXJlLCB0YXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgc3BhY2VGcmFjID0gKCh0aGlzLnBpeGVsVmlld3BvcnQucmlnaHQgLSB0aGlzLnBpeGVsVmlld3BvcnQubGVmdCkgLyAyICsgbWFyZ2luV2lkdGgpIC8gdG90YWxXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IHRhcmdldEZyYWMgLSBzcGFjZUZyYWM7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gdGFyZ2V0RnJhYyArIHNwYWNlRnJhYztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSAodGhpcy5waXhlbFZpZXdwb3J0LmxlZnQgLSBtYXJnaW5XaWR0aCkgLyB0b3RhbFdpZHRoO1xuICAgICAgICAgICAgICAgICAgICByaWdodCA9ICh0aGlzLnBpeGVsVmlld3BvcnQucmlnaHQgKyBtYXJnaW5XaWR0aCkgLyB0b3RhbFdpZHRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2aWV3RnJvbSA9IGZpbmRQb3NpdGlvbihzdHJ1Y3R1cmUsIGxlZnQpO1xuICAgICAgICAgICAgICAgIHZpZXdUbyA9IGZpbmRQb3NpdGlvbihzdHJ1Y3R1cmUsIHJpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2aWV3RnJvbSA+IGxpbmUuZnJvbSlcbiAgICAgICAgICAgICAgICBhZGRHYXAobGluZS5mcm9tLCB2aWV3RnJvbSwgbGluZSwgc3RydWN0dXJlKTtcbiAgICAgICAgICAgIGlmICh2aWV3VG8gPCBsaW5lLnRvKVxuICAgICAgICAgICAgICAgIGFkZEdhcCh2aWV3VG8sIGxpbmUudG8sIGxpbmUsIHN0cnVjdHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdhcHM7XG4gICAgfVxuICAgIGdhcFNpemUobGluZSwgZnJvbSwgdG8sIHN0cnVjdHVyZSkge1xuICAgICAgICBsZXQgZnJhY3Rpb24gPSBmaW5kRnJhY3Rpb24oc3RydWN0dXJlLCB0bykgLSBmaW5kRnJhY3Rpb24oc3RydWN0dXJlLCBmcm9tKTtcbiAgICAgICAgaWYgKHRoaXMuaGVpZ2h0T3JhY2xlLmxpbmVXcmFwcGluZykge1xuICAgICAgICAgICAgcmV0dXJuIGxpbmUuaGVpZ2h0ICogZnJhY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gc3RydWN0dXJlLnRvdGFsICogdGhpcy5oZWlnaHRPcmFjbGUuY2hhcldpZHRoICogZnJhY3Rpb247XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlTGluZUdhcHMoZ2Fwcykge1xuICAgICAgICBpZiAoIUxpbmVHYXAuc2FtZShnYXBzLCB0aGlzLmxpbmVHYXBzKSkge1xuICAgICAgICAgICAgdGhpcy5saW5lR2FwcyA9IGdhcHM7XG4gICAgICAgICAgICB0aGlzLmxpbmVHYXBEZWNvID0gRGVjb3JhdGlvbi5zZXQoZ2Fwcy5tYXAoZ2FwID0+IGdhcC5kcmF3KHRoaXMsIHRoaXMuaGVpZ2h0T3JhY2xlLmxpbmVXcmFwcGluZykpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb21wdXRlVmlzaWJsZVJhbmdlcygpIHtcbiAgICAgICAgbGV0IGRlY28gPSB0aGlzLnN0YXRlRGVjbztcbiAgICAgICAgaWYgKHRoaXMubGluZUdhcHMubGVuZ3RoKVxuICAgICAgICAgICAgZGVjbyA9IGRlY28uY29uY2F0KHRoaXMubGluZUdhcERlY28pO1xuICAgICAgICBsZXQgcmFuZ2VzID0gW107XG4gICAgICAgIFJhbmdlU2V0LnNwYW5zKGRlY28sIHRoaXMudmlld3BvcnQuZnJvbSwgdGhpcy52aWV3cG9ydC50bywge1xuICAgICAgICAgICAgc3Bhbihmcm9tLCB0bykgeyByYW5nZXMucHVzaCh7IGZyb20sIHRvIH0pOyB9LFxuICAgICAgICAgICAgcG9pbnQoKSB7IH1cbiAgICAgICAgfSwgMjApO1xuICAgICAgICBsZXQgY2hhbmdlZCA9IHJhbmdlcy5sZW5ndGggIT0gdGhpcy52aXNpYmxlUmFuZ2VzLmxlbmd0aCB8fFxuICAgICAgICAgICAgdGhpcy52aXNpYmxlUmFuZ2VzLnNvbWUoKHIsIGkpID0+IHIuZnJvbSAhPSByYW5nZXNbaV0uZnJvbSB8fCByLnRvICE9IHJhbmdlc1tpXS50byk7XG4gICAgICAgIHRoaXMudmlzaWJsZVJhbmdlcyA9IHJhbmdlcztcbiAgICAgICAgcmV0dXJuIGNoYW5nZWQgPyA0IC8qIFVwZGF0ZUZsYWcuVmlld3BvcnQgKi8gOiAwO1xuICAgIH1cbiAgICBsaW5lQmxvY2tBdChwb3MpIHtcbiAgICAgICAgcmV0dXJuIChwb3MgPj0gdGhpcy52aWV3cG9ydC5mcm9tICYmIHBvcyA8PSB0aGlzLnZpZXdwb3J0LnRvICYmIHRoaXMudmlld3BvcnRMaW5lcy5maW5kKGIgPT4gYi5mcm9tIDw9IHBvcyAmJiBiLnRvID49IHBvcykpIHx8XG4gICAgICAgICAgICBzY2FsZUJsb2NrKHRoaXMuaGVpZ2h0TWFwLmxpbmVBdChwb3MsIFF1ZXJ5VHlwZS5CeVBvcywgdGhpcy5oZWlnaHRPcmFjbGUsIDAsIDApLCB0aGlzLnNjYWxlcik7XG4gICAgfVxuICAgIGxpbmVCbG9ja0F0SGVpZ2h0KGhlaWdodCkge1xuICAgICAgICByZXR1cm4gc2NhbGVCbG9jayh0aGlzLmhlaWdodE1hcC5saW5lQXQodGhpcy5zY2FsZXIuZnJvbURPTShoZWlnaHQpLCBRdWVyeVR5cGUuQnlIZWlnaHQsIHRoaXMuaGVpZ2h0T3JhY2xlLCAwLCAwKSwgdGhpcy5zY2FsZXIpO1xuICAgIH1cbiAgICBzY3JvbGxBbmNob3JBdChzY3JvbGxUb3ApIHtcbiAgICAgICAgbGV0IGJsb2NrID0gdGhpcy5saW5lQmxvY2tBdEhlaWdodChzY3JvbGxUb3AgKyA4KTtcbiAgICAgICAgcmV0dXJuIGJsb2NrLmZyb20gPj0gdGhpcy52aWV3cG9ydC5mcm9tIHx8IHRoaXMudmlld3BvcnRMaW5lc1swXS50b3AgLSBzY3JvbGxUb3AgPiAyMDAgPyBibG9jayA6IHRoaXMudmlld3BvcnRMaW5lc1swXTtcbiAgICB9XG4gICAgZWxlbWVudEF0SGVpZ2h0KGhlaWdodCkge1xuICAgICAgICByZXR1cm4gc2NhbGVCbG9jayh0aGlzLmhlaWdodE1hcC5ibG9ja0F0KHRoaXMuc2NhbGVyLmZyb21ET00oaGVpZ2h0KSwgdGhpcy5oZWlnaHRPcmFjbGUsIDAsIDApLCB0aGlzLnNjYWxlcik7XG4gICAgfVxuICAgIGdldCBkb2NIZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjYWxlci50b0RPTSh0aGlzLmhlaWdodE1hcC5oZWlnaHQpO1xuICAgIH1cbiAgICBnZXQgY29udGVudEhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jSGVpZ2h0ICsgdGhpcy5wYWRkaW5nVG9wICsgdGhpcy5wYWRkaW5nQm90dG9tO1xuICAgIH1cbn1cbmNsYXNzIFZpZXdwb3J0IHtcbiAgICBjb25zdHJ1Y3Rvcihmcm9tLCB0bykge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgfVxufVxuZnVuY3Rpb24gbGluZVN0cnVjdHVyZShmcm9tLCB0bywgc3RhdGVEZWNvKSB7XG4gICAgbGV0IHJhbmdlcyA9IFtdLCBwb3MgPSBmcm9tLCB0b3RhbCA9IDA7XG4gICAgUmFuZ2VTZXQuc3BhbnMoc3RhdGVEZWNvLCBmcm9tLCB0bywge1xuICAgICAgICBzcGFuKCkgeyB9LFxuICAgICAgICBwb2ludChmcm9tLCB0bykge1xuICAgICAgICAgICAgaWYgKGZyb20gPiBwb3MpIHtcbiAgICAgICAgICAgICAgICByYW5nZXMucHVzaCh7IGZyb206IHBvcywgdG86IGZyb20gfSk7XG4gICAgICAgICAgICAgICAgdG90YWwgKz0gZnJvbSAtIHBvcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcyA9IHRvO1xuICAgICAgICB9XG4gICAgfSwgMjApOyAvLyBXZSdyZSBvbmx5IGludGVyZXN0ZWQgaW4gY29sbGFwc2VkIHJhbmdlcyBvZiBhIHNpZ25pZmljYW50IHNpemVcbiAgICBpZiAocG9zIDwgdG8pIHtcbiAgICAgICAgcmFuZ2VzLnB1c2goeyBmcm9tOiBwb3MsIHRvIH0pO1xuICAgICAgICB0b3RhbCArPSB0byAtIHBvcztcbiAgICB9XG4gICAgcmV0dXJuIHsgdG90YWwsIHJhbmdlcyB9O1xufVxuZnVuY3Rpb24gZmluZFBvc2l0aW9uKHsgdG90YWwsIHJhbmdlcyB9LCByYXRpbykge1xuICAgIGlmIChyYXRpbyA8PSAwKVxuICAgICAgICByZXR1cm4gcmFuZ2VzWzBdLmZyb207XG4gICAgaWYgKHJhdGlvID49IDEpXG4gICAgICAgIHJldHVybiByYW5nZXNbcmFuZ2VzLmxlbmd0aCAtIDFdLnRvO1xuICAgIGxldCBkaXN0ID0gTWF0aC5mbG9vcih0b3RhbCAqIHJhdGlvKTtcbiAgICBmb3IgKGxldCBpID0gMDs7IGkrKykge1xuICAgICAgICBsZXQgeyBmcm9tLCB0byB9ID0gcmFuZ2VzW2ldLCBzaXplID0gdG8gLSBmcm9tO1xuICAgICAgICBpZiAoZGlzdCA8PSBzaXplKVxuICAgICAgICAgICAgcmV0dXJuIGZyb20gKyBkaXN0O1xuICAgICAgICBkaXN0IC09IHNpemU7XG4gICAgfVxufVxuZnVuY3Rpb24gZmluZEZyYWN0aW9uKHN0cnVjdHVyZSwgcG9zKSB7XG4gICAgbGV0IGNvdW50ZWQgPSAwO1xuICAgIGZvciAobGV0IHsgZnJvbSwgdG8gfSBvZiBzdHJ1Y3R1cmUucmFuZ2VzKSB7XG4gICAgICAgIGlmIChwb3MgPD0gdG8pIHtcbiAgICAgICAgICAgIGNvdW50ZWQgKz0gcG9zIC0gZnJvbTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvdW50ZWQgKz0gdG8gLSBmcm9tO1xuICAgIH1cbiAgICByZXR1cm4gY291bnRlZCAvIHN0cnVjdHVyZS50b3RhbDtcbn1cbmZ1bmN0aW9uIGZpbmQoYXJyYXksIGYpIHtcbiAgICBmb3IgKGxldCB2YWwgb2YgYXJyYXkpXG4gICAgICAgIGlmIChmKHZhbCkpXG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG4vLyBEb24ndCBzY2FsZSB3aGVuIHRoZSBkb2N1bWVudCBoZWlnaHQgaXMgd2l0aGluIHRoZSByYW5nZSBvZiB3aGF0XG4vLyB0aGUgRE9NIGNhbiBoYW5kbGUuXG5jb25zdCBJZFNjYWxlciA9IHtcbiAgICB0b0RPTShuKSB7IHJldHVybiBuOyB9LFxuICAgIGZyb21ET00obikgeyByZXR1cm4gbjsgfSxcbiAgICBzY2FsZTogMVxufTtcbi8vIFdoZW4gdGhlIGhlaWdodCBpcyB0b28gYmlnICg+IFZQLk1heERPTUhlaWdodCksIHNjYWxlIGRvd24gdGhlXG4vLyByZWdpb25zIG91dHNpZGUgdGhlIHZpZXdwb3J0cyBzbyB0aGF0IHRoZSB0b3RhbCBoZWlnaHQgaXNcbi8vIFZQLk1heERPTUhlaWdodC5cbmNsYXNzIEJpZ1NjYWxlciB7XG4gICAgY29uc3RydWN0b3Iob3JhY2xlLCBoZWlnaHRNYXAsIHZpZXdwb3J0cykge1xuICAgICAgICBsZXQgdnBIZWlnaHQgPSAwLCBiYXNlID0gMCwgZG9tQmFzZSA9IDA7XG4gICAgICAgIHRoaXMudmlld3BvcnRzID0gdmlld3BvcnRzLm1hcCgoeyBmcm9tLCB0byB9KSA9PiB7XG4gICAgICAgICAgICBsZXQgdG9wID0gaGVpZ2h0TWFwLmxpbmVBdChmcm9tLCBRdWVyeVR5cGUuQnlQb3MsIG9yYWNsZSwgMCwgMCkudG9wO1xuICAgICAgICAgICAgbGV0IGJvdHRvbSA9IGhlaWdodE1hcC5saW5lQXQodG8sIFF1ZXJ5VHlwZS5CeVBvcywgb3JhY2xlLCAwLCAwKS5ib3R0b207XG4gICAgICAgICAgICB2cEhlaWdodCArPSBib3R0b20gLSB0b3A7XG4gICAgICAgICAgICByZXR1cm4geyBmcm9tLCB0bywgdG9wLCBib3R0b20sIGRvbVRvcDogMCwgZG9tQm90dG9tOiAwIH07XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNjYWxlID0gKDcwMDAwMDAgLyogVlAuTWF4RE9NSGVpZ2h0ICovIC0gdnBIZWlnaHQpIC8gKGhlaWdodE1hcC5oZWlnaHQgLSB2cEhlaWdodCk7XG4gICAgICAgIGZvciAobGV0IG9iaiBvZiB0aGlzLnZpZXdwb3J0cykge1xuICAgICAgICAgICAgb2JqLmRvbVRvcCA9IGRvbUJhc2UgKyAob2JqLnRvcCAtIGJhc2UpICogdGhpcy5zY2FsZTtcbiAgICAgICAgICAgIGRvbUJhc2UgPSBvYmouZG9tQm90dG9tID0gb2JqLmRvbVRvcCArIChvYmouYm90dG9tIC0gb2JqLnRvcCk7XG4gICAgICAgICAgICBiYXNlID0gb2JqLmJvdHRvbTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b0RPTShuKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBiYXNlID0gMCwgZG9tQmFzZSA9IDA7OyBpKyspIHtcbiAgICAgICAgICAgIGxldCB2cCA9IGkgPCB0aGlzLnZpZXdwb3J0cy5sZW5ndGggPyB0aGlzLnZpZXdwb3J0c1tpXSA6IG51bGw7XG4gICAgICAgICAgICBpZiAoIXZwIHx8IG4gPCB2cC50b3ApXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvbUJhc2UgKyAobiAtIGJhc2UpICogdGhpcy5zY2FsZTtcbiAgICAgICAgICAgIGlmIChuIDw9IHZwLmJvdHRvbSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdnAuZG9tVG9wICsgKG4gLSB2cC50b3ApO1xuICAgICAgICAgICAgYmFzZSA9IHZwLmJvdHRvbTtcbiAgICAgICAgICAgIGRvbUJhc2UgPSB2cC5kb21Cb3R0b207XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnJvbURPTShuKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBiYXNlID0gMCwgZG9tQmFzZSA9IDA7OyBpKyspIHtcbiAgICAgICAgICAgIGxldCB2cCA9IGkgPCB0aGlzLnZpZXdwb3J0cy5sZW5ndGggPyB0aGlzLnZpZXdwb3J0c1tpXSA6IG51bGw7XG4gICAgICAgICAgICBpZiAoIXZwIHx8IG4gPCB2cC5kb21Ub3ApXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJhc2UgKyAobiAtIGRvbUJhc2UpIC8gdGhpcy5zY2FsZTtcbiAgICAgICAgICAgIGlmIChuIDw9IHZwLmRvbUJvdHRvbSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdnAudG9wICsgKG4gLSB2cC5kb21Ub3ApO1xuICAgICAgICAgICAgYmFzZSA9IHZwLmJvdHRvbTtcbiAgICAgICAgICAgIGRvbUJhc2UgPSB2cC5kb21Cb3R0b207XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBzY2FsZUJsb2NrKGJsb2NrLCBzY2FsZXIpIHtcbiAgICBpZiAoc2NhbGVyLnNjYWxlID09IDEpXG4gICAgICAgIHJldHVybiBibG9jaztcbiAgICBsZXQgYlRvcCA9IHNjYWxlci50b0RPTShibG9jay50b3ApLCBiQm90dG9tID0gc2NhbGVyLnRvRE9NKGJsb2NrLmJvdHRvbSk7XG4gICAgcmV0dXJuIG5ldyBCbG9ja0luZm8oYmxvY2suZnJvbSwgYmxvY2subGVuZ3RoLCBiVG9wLCBiQm90dG9tIC0gYlRvcCwgQXJyYXkuaXNBcnJheShibG9jay5fY29udGVudCkgPyBibG9jay5fY29udGVudC5tYXAoYiA9PiBzY2FsZUJsb2NrKGIsIHNjYWxlcikpIDogYmxvY2suX2NvbnRlbnQpO1xufVxuXG5jb25zdCB0aGVtZSA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoeyBjb21iaW5lOiBzdHJzID0+IHN0cnMuam9pbihcIiBcIikgfSk7XG5jb25zdCBkYXJrVGhlbWUgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHsgY29tYmluZTogdmFsdWVzID0+IHZhbHVlcy5pbmRleE9mKHRydWUpID4gLTEgfSk7XG5jb25zdCBiYXNlVGhlbWVJRCA9IC8qQF9fUFVSRV9fKi9TdHlsZU1vZHVsZS5uZXdOYW1lKCksIGJhc2VMaWdodElEID0gLypAX19QVVJFX18qL1N0eWxlTW9kdWxlLm5ld05hbWUoKSwgYmFzZURhcmtJRCA9IC8qQF9fUFVSRV9fKi9TdHlsZU1vZHVsZS5uZXdOYW1lKCk7XG5jb25zdCBsaWdodERhcmtJRHMgPSB7IFwiJmxpZ2h0XCI6IFwiLlwiICsgYmFzZUxpZ2h0SUQsIFwiJmRhcmtcIjogXCIuXCIgKyBiYXNlRGFya0lEIH07XG5mdW5jdGlvbiBidWlsZFRoZW1lKG1haW4sIHNwZWMsIHNjb3Blcykge1xuICAgIHJldHVybiBuZXcgU3R5bGVNb2R1bGUoc3BlYywge1xuICAgICAgICBmaW5pc2goc2VsKSB7XG4gICAgICAgICAgICByZXR1cm4gLyYvLnRlc3Qoc2VsKSA/IHNlbC5yZXBsYWNlKC8mXFx3Ki8sIG0gPT4ge1xuICAgICAgICAgICAgICAgIGlmIChtID09IFwiJlwiKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFpbjtcbiAgICAgICAgICAgICAgICBpZiAoIXNjb3BlcyB8fCAhc2NvcGVzW21dKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgVW5zdXBwb3J0ZWQgc2VsZWN0b3I6ICR7bX1gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2NvcGVzW21dO1xuICAgICAgICAgICAgfSkgOiBtYWluICsgXCIgXCIgKyBzZWw7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmNvbnN0IGJhc2VUaGVtZSQxID0gLypAX19QVVJFX18qL2J1aWxkVGhlbWUoXCIuXCIgKyBiYXNlVGhlbWVJRCwge1xuICAgIFwiJlwiOiB7XG4gICAgICAgIHBvc2l0aW9uOiBcInJlbGF0aXZlICFpbXBvcnRhbnRcIixcbiAgICAgICAgYm94U2l6aW5nOiBcImJvcmRlci1ib3hcIixcbiAgICAgICAgXCImLmNtLWZvY3VzZWRcIjoge1xuICAgICAgICAgICAgLy8gUHJvdmlkZSBhIHNpbXBsZSBkZWZhdWx0IG91dGxpbmUgdG8gbWFrZSBzdXJlIGEgZm9jdXNlZFxuICAgICAgICAgICAgLy8gZWRpdG9yIGlzIHZpc3VhbGx5IGRpc3RpbmN0LiBDYW4ndCBsZWF2ZSB0aGUgZGVmYXVsdCBiZWhhdmlvclxuICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGF0IHdpbGwgYXBwbHkgdG8gdGhlIGNvbnRlbnQgZWxlbWVudCwgd2hpY2ggaXNcbiAgICAgICAgICAgIC8vIGluc2lkZSB0aGUgc2Nyb2xsYWJsZSBjb250YWluZXIgYW5kIGRvZXNuJ3QgaW5jbHVkZSB0aGVcbiAgICAgICAgICAgIC8vIGd1dHRlcnMuIFdlIGFsc28gY2FuJ3QgdXNlIGFuICdhdXRvJyBvdXRsaW5lLCBzaW5jZSB0aG9zZVxuICAgICAgICAgICAgLy8gYXJlLCBmb3Igc29tZSByZWFzb24sIGRyYXduIGJlaGluZCB0aGUgZWxlbWVudCBjb250ZW50LCB3aGljaFxuICAgICAgICAgICAgLy8gd2lsbCBjYXVzZSB0aGluZ3MgbGlrZSB0aGUgYWN0aXZlIGxpbmUgYmFja2dyb3VuZCB0byBjb3ZlclxuICAgICAgICAgICAgLy8gdGhlIG91dGxpbmUgKCMyOTcpLlxuICAgICAgICAgICAgb3V0bGluZTogXCIxcHggZG90dGVkICMyMTIxMjFcIlxuICAgICAgICB9LFxuICAgICAgICBkaXNwbGF5OiBcImZsZXggIWltcG9ydGFudFwiLFxuICAgICAgICBmbGV4RGlyZWN0aW9uOiBcImNvbHVtblwiXG4gICAgfSxcbiAgICBcIi5jbS1zY3JvbGxlclwiOiB7XG4gICAgICAgIGRpc3BsYXk6IFwiZmxleCAhaW1wb3J0YW50XCIsXG4gICAgICAgIGFsaWduSXRlbXM6IFwiZmxleC1zdGFydCAhaW1wb3J0YW50XCIsXG4gICAgICAgIGZvbnRGYW1pbHk6IFwibW9ub3NwYWNlXCIsXG4gICAgICAgIGxpbmVIZWlnaHQ6IDEuNCxcbiAgICAgICAgaGVpZ2h0OiBcIjEwMCVcIixcbiAgICAgICAgb3ZlcmZsb3dYOiBcImF1dG9cIixcbiAgICAgICAgcG9zaXRpb246IFwicmVsYXRpdmVcIixcbiAgICAgICAgekluZGV4OiAwXG4gICAgfSxcbiAgICBcIi5jbS1jb250ZW50XCI6IHtcbiAgICAgICAgbWFyZ2luOiAwLFxuICAgICAgICBmbGV4R3JvdzogMixcbiAgICAgICAgZmxleFNocmluazogMCxcbiAgICAgICAgZGlzcGxheTogXCJibG9ja1wiLFxuICAgICAgICB3aGl0ZVNwYWNlOiBcInByZVwiLFxuICAgICAgICB3b3JkV3JhcDogXCJub3JtYWxcIiwgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NvZGVtaXJyb3IvZGV2L2lzc3Vlcy80NTZcbiAgICAgICAgYm94U2l6aW5nOiBcImJvcmRlci1ib3hcIixcbiAgICAgICAgbWluSGVpZ2h0OiBcIjEwMCVcIixcbiAgICAgICAgcGFkZGluZzogXCI0cHggMFwiLFxuICAgICAgICBvdXRsaW5lOiBcIm5vbmVcIixcbiAgICAgICAgXCImW2NvbnRlbnRlZGl0YWJsZT10cnVlXVwiOiB7XG4gICAgICAgICAgICBXZWJraXRVc2VyTW9kaWZ5OiBcInJlYWQtd3JpdGUtcGxhaW50ZXh0LW9ubHlcIixcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXCIuY20tbGluZVdyYXBwaW5nXCI6IHtcbiAgICAgICAgd2hpdGVTcGFjZV9mYWxsYmFjazogXCJwcmUtd3JhcFwiLCAvLyBGb3IgSUVcbiAgICAgICAgd2hpdGVTcGFjZTogXCJicmVhay1zcGFjZXNcIixcbiAgICAgICAgd29yZEJyZWFrOiBcImJyZWFrLXdvcmRcIiwgLy8gRm9yIFNhZmFyaSwgd2hpY2ggZG9lc24ndCBzdXBwb3J0IG92ZXJmbG93LXdyYXA6IGFueXdoZXJlXG4gICAgICAgIG92ZXJmbG93V3JhcDogXCJhbnl3aGVyZVwiLFxuICAgICAgICBmbGV4U2hyaW5rOiAxXG4gICAgfSxcbiAgICBcIiZsaWdodCAuY20tY29udGVudFwiOiB7IGNhcmV0Q29sb3I6IFwiYmxhY2tcIiB9LFxuICAgIFwiJmRhcmsgLmNtLWNvbnRlbnRcIjogeyBjYXJldENvbG9yOiBcIndoaXRlXCIgfSxcbiAgICBcIi5jbS1saW5lXCI6IHtcbiAgICAgICAgZGlzcGxheTogXCJibG9ja1wiLFxuICAgICAgICBwYWRkaW5nOiBcIjAgMnB4IDAgNnB4XCJcbiAgICB9LFxuICAgIFwiLmNtLWxheWVyXCI6IHtcbiAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgdG9wOiAwLFxuICAgICAgICBjb250YWluOiBcInNpemUgc3R5bGVcIixcbiAgICAgICAgXCImID4gKlwiOiB7XG4gICAgICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFwiJmxpZ2h0IC5jbS1zZWxlY3Rpb25CYWNrZ3JvdW5kXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZDogXCIjZDlkOWQ5XCJcbiAgICB9LFxuICAgIFwiJmRhcmsgLmNtLXNlbGVjdGlvbkJhY2tncm91bmRcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kOiBcIiMyMjJcIlxuICAgIH0sXG4gICAgXCImbGlnaHQuY20tZm9jdXNlZCA+IC5jbS1zY3JvbGxlciA+IC5jbS1zZWxlY3Rpb25MYXllciAuY20tc2VsZWN0aW9uQmFja2dyb3VuZFwiOiB7XG4gICAgICAgIGJhY2tncm91bmQ6IFwiI2Q3ZDRmMFwiXG4gICAgfSxcbiAgICBcIiZkYXJrLmNtLWZvY3VzZWQgPiAuY20tc2Nyb2xsZXIgPiAuY20tc2VsZWN0aW9uTGF5ZXIgLmNtLXNlbGVjdGlvbkJhY2tncm91bmRcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kOiBcIiMyMzNcIlxuICAgIH0sXG4gICAgXCIuY20tY3Vyc29yTGF5ZXJcIjoge1xuICAgICAgICBwb2ludGVyRXZlbnRzOiBcIm5vbmVcIlxuICAgIH0sXG4gICAgXCImLmNtLWZvY3VzZWQgPiAuY20tc2Nyb2xsZXIgPiAuY20tY3Vyc29yTGF5ZXJcIjoge1xuICAgICAgICBhbmltYXRpb246IFwic3RlcHMoMSkgY20tYmxpbmsgMS4ycyBpbmZpbml0ZVwiXG4gICAgfSxcbiAgICAvLyBUd28gYW5pbWF0aW9ucyBkZWZpbmVkIHNvIHRoYXQgd2UgY2FuIHN3aXRjaCBiZXR3ZWVuIHRoZW0gdG9cbiAgICAvLyByZXN0YXJ0IHRoZSBhbmltYXRpb24gd2l0aG91dCBmb3JjaW5nIGFub3RoZXIgc3R5bGVcbiAgICAvLyByZWNvbXB1dGF0aW9uLlxuICAgIFwiQGtleWZyYW1lcyBjbS1ibGlua1wiOiB7IFwiMCVcIjoge30sIFwiNTAlXCI6IHsgb3BhY2l0eTogMCB9LCBcIjEwMCVcIjoge30gfSxcbiAgICBcIkBrZXlmcmFtZXMgY20tYmxpbmsyXCI6IHsgXCIwJVwiOiB7fSwgXCI1MCVcIjogeyBvcGFjaXR5OiAwIH0sIFwiMTAwJVwiOiB7fSB9LFxuICAgIFwiLmNtLWN1cnNvciwgLmNtLWRyb3BDdXJzb3JcIjoge1xuICAgICAgICBib3JkZXJMZWZ0OiBcIjEuMnB4IHNvbGlkIGJsYWNrXCIsXG4gICAgICAgIG1hcmdpbkxlZnQ6IFwiLTAuNnB4XCIsXG4gICAgICAgIHBvaW50ZXJFdmVudHM6IFwibm9uZVwiLFxuICAgIH0sXG4gICAgXCIuY20tY3Vyc29yXCI6IHtcbiAgICAgICAgZGlzcGxheTogXCJub25lXCJcbiAgICB9LFxuICAgIFwiJmRhcmsgLmNtLWN1cnNvclwiOiB7XG4gICAgICAgIGJvcmRlckxlZnRDb2xvcjogXCIjNDQ0XCJcbiAgICB9LFxuICAgIFwiLmNtLWRyb3BDdXJzb3JcIjoge1xuICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiXG4gICAgfSxcbiAgICBcIiYuY20tZm9jdXNlZCA+IC5jbS1zY3JvbGxlciA+IC5jbS1jdXJzb3JMYXllciAuY20tY3Vyc29yXCI6IHtcbiAgICAgICAgZGlzcGxheTogXCJibG9ja1wiXG4gICAgfSxcbiAgICBcIi5jbS1hbm5vdW5jZWRcIjoge1xuICAgICAgICBwb3NpdGlvbjogXCJmaXhlZFwiLFxuICAgICAgICB0b3A6IFwiLTEwMDAwcHhcIlxuICAgIH0sXG4gICAgXCJAbWVkaWEgcHJpbnRcIjoge1xuICAgICAgICBcIi5jbS1hbm5vdW5jZWRcIjogeyBkaXNwbGF5OiBcIm5vbmVcIiB9XG4gICAgfSxcbiAgICBcIiZsaWdodCAuY20tYWN0aXZlTGluZVwiOiB7IGJhY2tncm91bmRDb2xvcjogXCIjY2NlZWZmNDRcIiB9LFxuICAgIFwiJmRhcmsgLmNtLWFjdGl2ZUxpbmVcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwiIzk5ZWVmZjMzXCIgfSxcbiAgICBcIiZsaWdodCAuY20tc3BlY2lhbENoYXJcIjogeyBjb2xvcjogXCJyZWRcIiB9LFxuICAgIFwiJmRhcmsgLmNtLXNwZWNpYWxDaGFyXCI6IHsgY29sb3I6IFwiI2Y3OFwiIH0sXG4gICAgXCIuY20tZ3V0dGVyc1wiOiB7XG4gICAgICAgIGZsZXhTaHJpbms6IDAsXG4gICAgICAgIGRpc3BsYXk6IFwiZmxleFwiLFxuICAgICAgICBoZWlnaHQ6IFwiMTAwJVwiLFxuICAgICAgICBib3hTaXppbmc6IFwiYm9yZGVyLWJveFwiLFxuICAgICAgICBpbnNldElubGluZVN0YXJ0OiAwLFxuICAgICAgICB6SW5kZXg6IDIwMFxuICAgIH0sXG4gICAgXCImbGlnaHQgLmNtLWd1dHRlcnNcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiI2Y1ZjVmNVwiLFxuICAgICAgICBjb2xvcjogXCIjNmM2YzZjXCIsXG4gICAgICAgIGJvcmRlclJpZ2h0OiBcIjFweCBzb2xpZCAjZGRkXCJcbiAgICB9LFxuICAgIFwiJmRhcmsgLmNtLWd1dHRlcnNcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiIzMzMzMzOFwiLFxuICAgICAgICBjb2xvcjogXCIjY2NjXCJcbiAgICB9LFxuICAgIFwiLmNtLWd1dHRlclwiOiB7XG4gICAgICAgIGRpc3BsYXk6IFwiZmxleCAhaW1wb3J0YW50XCIsIC8vIE5lY2Vzc2FyeSAtLSBwcmV2ZW50cyBtYXJnaW4gY29sbGFwc2luZ1xuICAgICAgICBmbGV4RGlyZWN0aW9uOiBcImNvbHVtblwiLFxuICAgICAgICBmbGV4U2hyaW5rOiAwLFxuICAgICAgICBib3hTaXppbmc6IFwiYm9yZGVyLWJveFwiLFxuICAgICAgICBtaW5IZWlnaHQ6IFwiMTAwJVwiLFxuICAgICAgICBvdmVyZmxvdzogXCJoaWRkZW5cIlxuICAgIH0sXG4gICAgXCIuY20tZ3V0dGVyRWxlbWVudFwiOiB7XG4gICAgICAgIGJveFNpemluZzogXCJib3JkZXItYm94XCJcbiAgICB9LFxuICAgIFwiLmNtLWxpbmVOdW1iZXJzIC5jbS1ndXR0ZXJFbGVtZW50XCI6IHtcbiAgICAgICAgcGFkZGluZzogXCIwIDNweCAwIDVweFwiLFxuICAgICAgICBtaW5XaWR0aDogXCIyMHB4XCIsXG4gICAgICAgIHRleHRBbGlnbjogXCJyaWdodFwiLFxuICAgICAgICB3aGl0ZVNwYWNlOiBcIm5vd3JhcFwiXG4gICAgfSxcbiAgICBcIiZsaWdodCAuY20tYWN0aXZlTGluZUd1dHRlclwiOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjZTJmMmZmXCJcbiAgICB9LFxuICAgIFwiJmRhcmsgLmNtLWFjdGl2ZUxpbmVHdXR0ZXJcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiIzIyMjIyN1wiXG4gICAgfSxcbiAgICBcIi5jbS1wYW5lbHNcIjoge1xuICAgICAgICBib3hTaXppbmc6IFwiYm9yZGVyLWJveFwiLFxuICAgICAgICBwb3NpdGlvbjogXCJzdGlja3lcIixcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgcmlnaHQ6IDBcbiAgICB9LFxuICAgIFwiJmxpZ2h0IC5jbS1wYW5lbHNcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiI2Y1ZjVmNVwiLFxuICAgICAgICBjb2xvcjogXCJibGFja1wiXG4gICAgfSxcbiAgICBcIiZsaWdodCAuY20tcGFuZWxzLXRvcFwiOiB7XG4gICAgICAgIGJvcmRlckJvdHRvbTogXCIxcHggc29saWQgI2RkZFwiXG4gICAgfSxcbiAgICBcIiZsaWdodCAuY20tcGFuZWxzLWJvdHRvbVwiOiB7XG4gICAgICAgIGJvcmRlclRvcDogXCIxcHggc29saWQgI2RkZFwiXG4gICAgfSxcbiAgICBcIiZkYXJrIC5jbS1wYW5lbHNcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiIzMzMzMzOFwiLFxuICAgICAgICBjb2xvcjogXCJ3aGl0ZVwiXG4gICAgfSxcbiAgICBcIi5jbS10YWJcIjoge1xuICAgICAgICBkaXNwbGF5OiBcImlubGluZS1ibG9ja1wiLFxuICAgICAgICBvdmVyZmxvdzogXCJoaWRkZW5cIixcbiAgICAgICAgdmVydGljYWxBbGlnbjogXCJib3R0b21cIlxuICAgIH0sXG4gICAgXCIuY20td2lkZ2V0QnVmZmVyXCI6IHtcbiAgICAgICAgdmVydGljYWxBbGlnbjogXCJ0ZXh0LXRvcFwiLFxuICAgICAgICBoZWlnaHQ6IFwiMWVtXCIsXG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBkaXNwbGF5OiBcImlubGluZVwiXG4gICAgfSxcbiAgICBcIi5jbS1wbGFjZWhvbGRlclwiOiB7XG4gICAgICAgIGNvbG9yOiBcIiM4ODhcIixcbiAgICAgICAgZGlzcGxheTogXCJpbmxpbmUtYmxvY2tcIixcbiAgICAgICAgdmVydGljYWxBbGlnbjogXCJ0b3BcIixcbiAgICB9LFxuICAgIFwiLmNtLWhpZ2hsaWdodFNwYWNlOmJlZm9yZVwiOiB7XG4gICAgICAgIGNvbnRlbnQ6IFwiYXR0cihkYXRhLWRpc3BsYXkpXCIsXG4gICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICAgIHBvaW50ZXJFdmVudHM6IFwibm9uZVwiLFxuICAgICAgICBjb2xvcjogXCIjODg4XCJcbiAgICB9LFxuICAgIFwiLmNtLWhpZ2hsaWdodFRhYlwiOiB7XG4gICAgICAgIGJhY2tncm91bmRJbWFnZTogYHVybCgnZGF0YTppbWFnZS9zdmcreG1sLDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMjAwXCIgaGVpZ2h0PVwiMjBcIj48cGF0aCBzdHJva2U9XCIlMjM4ODhcIiBzdHJva2Utd2lkdGg9XCIxXCIgZmlsbD1cIm5vbmVcIiBkPVwiTTEgMTBIMTk2TDE5MCA1TTE5MCAxNUwxOTYgMTBNMTk3IDRMMTk3IDE2XCIvPjwvc3ZnPicpYCxcbiAgICAgICAgYmFja2dyb3VuZFNpemU6IFwiYXV0byAxMDAlXCIsXG4gICAgICAgIGJhY2tncm91bmRQb3NpdGlvbjogXCJyaWdodCA5MCVcIixcbiAgICAgICAgYmFja2dyb3VuZFJlcGVhdDogXCJuby1yZXBlYXRcIlxuICAgIH0sXG4gICAgXCIuY20tdHJhaWxpbmdTcGFjZVwiOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjZmYzMzIyNTVcIlxuICAgIH0sXG4gICAgXCIuY20tYnV0dG9uXCI6IHtcbiAgICAgICAgdmVydGljYWxBbGlnbjogXCJtaWRkbGVcIixcbiAgICAgICAgY29sb3I6IFwiaW5oZXJpdFwiLFxuICAgICAgICBmb250U2l6ZTogXCI3MCVcIixcbiAgICAgICAgcGFkZGluZzogXCIuMmVtIDFlbVwiLFxuICAgICAgICBib3JkZXJSYWRpdXM6IFwiMXB4XCJcbiAgICB9LFxuICAgIFwiJmxpZ2h0IC5jbS1idXR0b25cIjoge1xuICAgICAgICBiYWNrZ3JvdW5kSW1hZ2U6IFwibGluZWFyLWdyYWRpZW50KCNlZmYxZjUsICNkOWQ5ZGYpXCIsXG4gICAgICAgIGJvcmRlcjogXCIxcHggc29saWQgIzg4OFwiLFxuICAgICAgICBcIiY6YWN0aXZlXCI6IHtcbiAgICAgICAgICAgIGJhY2tncm91bmRJbWFnZTogXCJsaW5lYXItZ3JhZGllbnQoI2I0YjRiNCwgI2QwZDNkNilcIlxuICAgICAgICB9XG4gICAgfSxcbiAgICBcIiZkYXJrIC5jbS1idXR0b25cIjoge1xuICAgICAgICBiYWNrZ3JvdW5kSW1hZ2U6IFwibGluZWFyLWdyYWRpZW50KCMzOTM5MzksICMxMTEpXCIsXG4gICAgICAgIGJvcmRlcjogXCIxcHggc29saWQgIzg4OFwiLFxuICAgICAgICBcIiY6YWN0aXZlXCI6IHtcbiAgICAgICAgICAgIGJhY2tncm91bmRJbWFnZTogXCJsaW5lYXItZ3JhZGllbnQoIzExMSwgIzMzMylcIlxuICAgICAgICB9XG4gICAgfSxcbiAgICBcIi5jbS10ZXh0ZmllbGRcIjoge1xuICAgICAgICB2ZXJ0aWNhbEFsaWduOiBcIm1pZGRsZVwiLFxuICAgICAgICBjb2xvcjogXCJpbmhlcml0XCIsXG4gICAgICAgIGZvbnRTaXplOiBcIjcwJVwiLFxuICAgICAgICBib3JkZXI6IFwiMXB4IHNvbGlkIHNpbHZlclwiLFxuICAgICAgICBwYWRkaW5nOiBcIi4yZW0gLjVlbVwiXG4gICAgfSxcbiAgICBcIiZsaWdodCAuY20tdGV4dGZpZWxkXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIndoaXRlXCJcbiAgICB9LFxuICAgIFwiJmRhcmsgLmNtLXRleHRmaWVsZFwiOiB7XG4gICAgICAgIGJvcmRlcjogXCIxcHggc29saWQgIzU1NVwiLFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiaW5oZXJpdFwiXG4gICAgfVxufSwgbGlnaHREYXJrSURzKTtcblxuY29uc3QgTGluZUJyZWFrUGxhY2Vob2xkZXIgPSBcIlxcdWZmZmZcIjtcbmNsYXNzIERPTVJlYWRlciB7XG4gICAgY29uc3RydWN0b3IocG9pbnRzLCBzdGF0ZSkge1xuICAgICAgICB0aGlzLnBvaW50cyA9IHBvaW50cztcbiAgICAgICAgdGhpcy50ZXh0ID0gXCJcIjtcbiAgICAgICAgdGhpcy5saW5lU2VwYXJhdG9yID0gc3RhdGUuZmFjZXQoRWRpdG9yU3RhdGUubGluZVNlcGFyYXRvcik7XG4gICAgfVxuICAgIGFwcGVuZCh0ZXh0KSB7XG4gICAgICAgIHRoaXMudGV4dCArPSB0ZXh0O1xuICAgIH1cbiAgICBsaW5lQnJlYWsoKSB7XG4gICAgICAgIHRoaXMudGV4dCArPSBMaW5lQnJlYWtQbGFjZWhvbGRlcjtcbiAgICB9XG4gICAgcmVhZFJhbmdlKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgaWYgKCFzdGFydClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBsZXQgcGFyZW50ID0gc3RhcnQucGFyZW50Tm9kZTtcbiAgICAgICAgZm9yIChsZXQgY3VyID0gc3RhcnQ7Oykge1xuICAgICAgICAgICAgdGhpcy5maW5kUG9pbnRCZWZvcmUocGFyZW50LCBjdXIpO1xuICAgICAgICAgICAgbGV0IG9sZExlbiA9IHRoaXMudGV4dC5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLnJlYWROb2RlKGN1cik7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IGN1ci5uZXh0U2libGluZztcbiAgICAgICAgICAgIGlmIChuZXh0ID09IGVuZClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGxldCB2aWV3ID0gQ29udGVudFZpZXcuZ2V0KGN1ciksIG5leHRWaWV3ID0gQ29udGVudFZpZXcuZ2V0KG5leHQpO1xuICAgICAgICAgICAgaWYgKHZpZXcgJiYgbmV4dFZpZXcgPyB2aWV3LmJyZWFrQWZ0ZXIgOlxuICAgICAgICAgICAgICAgICh2aWV3ID8gdmlldy5icmVha0FmdGVyIDogaXNCbG9ja0VsZW1lbnQoY3VyKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgKGlzQmxvY2tFbGVtZW50KG5leHQpICYmIChjdXIubm9kZU5hbWUgIT0gXCJCUlwiIHx8IGN1ci5jbUlnbm9yZSkgJiYgdGhpcy50ZXh0Lmxlbmd0aCA+IG9sZExlbikpXG4gICAgICAgICAgICAgICAgdGhpcy5saW5lQnJlYWsoKTtcbiAgICAgICAgICAgIGN1ciA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5maW5kUG9pbnRCZWZvcmUocGFyZW50LCBlbmQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmVhZFRleHROb2RlKG5vZGUpIHtcbiAgICAgICAgbGV0IHRleHQgPSBub2RlLm5vZGVWYWx1ZTtcbiAgICAgICAgZm9yIChsZXQgcG9pbnQgb2YgdGhpcy5wb2ludHMpXG4gICAgICAgICAgICBpZiAocG9pbnQubm9kZSA9PSBub2RlKVxuICAgICAgICAgICAgICAgIHBvaW50LnBvcyA9IHRoaXMudGV4dC5sZW5ndGggKyBNYXRoLm1pbihwb2ludC5vZmZzZXQsIHRleHQubGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgb2ZmID0gMCwgcmUgPSB0aGlzLmxpbmVTZXBhcmF0b3IgPyBudWxsIDogL1xcclxcbj98XFxuL2c7Oykge1xuICAgICAgICAgICAgbGV0IG5leHRCcmVhayA9IC0xLCBicmVha1NpemUgPSAxLCBtO1xuICAgICAgICAgICAgaWYgKHRoaXMubGluZVNlcGFyYXRvcikge1xuICAgICAgICAgICAgICAgIG5leHRCcmVhayA9IHRleHQuaW5kZXhPZih0aGlzLmxpbmVTZXBhcmF0b3IsIG9mZik7XG4gICAgICAgICAgICAgICAgYnJlYWtTaXplID0gdGhpcy5saW5lU2VwYXJhdG9yLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG0gPSByZS5leGVjKHRleHQpKSB7XG4gICAgICAgICAgICAgICAgbmV4dEJyZWFrID0gbS5pbmRleDtcbiAgICAgICAgICAgICAgICBicmVha1NpemUgPSBtWzBdLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYXBwZW5kKHRleHQuc2xpY2Uob2ZmLCBuZXh0QnJlYWsgPCAwID8gdGV4dC5sZW5ndGggOiBuZXh0QnJlYWspKTtcbiAgICAgICAgICAgIGlmIChuZXh0QnJlYWsgPCAwKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgdGhpcy5saW5lQnJlYWsoKTtcbiAgICAgICAgICAgIGlmIChicmVha1NpemUgPiAxKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IHBvaW50IG9mIHRoaXMucG9pbnRzKVxuICAgICAgICAgICAgICAgICAgICBpZiAocG9pbnQubm9kZSA9PSBub2RlICYmIHBvaW50LnBvcyA+IHRoaXMudGV4dC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludC5wb3MgLT0gYnJlYWtTaXplIC0gMTtcbiAgICAgICAgICAgIG9mZiA9IG5leHRCcmVhayArIGJyZWFrU2l6ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZWFkTm9kZShub2RlKSB7XG4gICAgICAgIGlmIChub2RlLmNtSWdub3JlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgdmlldyA9IENvbnRlbnRWaWV3LmdldChub2RlKTtcbiAgICAgICAgbGV0IGZyb21WaWV3ID0gdmlldyAmJiB2aWV3Lm92ZXJyaWRlRE9NVGV4dDtcbiAgICAgICAgaWYgKGZyb21WaWV3ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZmluZFBvaW50SW5zaWRlKG5vZGUsIGZyb21WaWV3Lmxlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gZnJvbVZpZXcuaXRlcigpOyAhaS5uZXh0KCkuZG9uZTspIHtcbiAgICAgICAgICAgICAgICBpZiAoaS5saW5lQnJlYWspXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGluZUJyZWFrKCk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcGVuZChpLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlLm5vZGVUeXBlID09IDMpIHtcbiAgICAgICAgICAgIHRoaXMucmVhZFRleHROb2RlKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUubm9kZU5hbWUgPT0gXCJCUlwiKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5uZXh0U2libGluZylcbiAgICAgICAgICAgICAgICB0aGlzLmxpbmVCcmVhaygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICAgICAgdGhpcy5yZWFkUmFuZ2Uobm9kZS5maXJzdENoaWxkLCBudWxsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmaW5kUG9pbnRCZWZvcmUobm9kZSwgbmV4dCkge1xuICAgICAgICBmb3IgKGxldCBwb2ludCBvZiB0aGlzLnBvaW50cylcbiAgICAgICAgICAgIGlmIChwb2ludC5ub2RlID09IG5vZGUgJiYgbm9kZS5jaGlsZE5vZGVzW3BvaW50Lm9mZnNldF0gPT0gbmV4dClcbiAgICAgICAgICAgICAgICBwb2ludC5wb3MgPSB0aGlzLnRleHQubGVuZ3RoO1xuICAgIH1cbiAgICBmaW5kUG9pbnRJbnNpZGUobm9kZSwgbGVuZ3RoKSB7XG4gICAgICAgIGZvciAobGV0IHBvaW50IG9mIHRoaXMucG9pbnRzKVxuICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMyA/IHBvaW50Lm5vZGUgPT0gbm9kZSA6IG5vZGUuY29udGFpbnMocG9pbnQubm9kZSkpXG4gICAgICAgICAgICAgICAgcG9pbnQucG9zID0gdGhpcy50ZXh0Lmxlbmd0aCArIChpc0F0RW5kKG5vZGUsIHBvaW50Lm5vZGUsIHBvaW50Lm9mZnNldCkgPyBsZW5ndGggOiAwKTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc0F0RW5kKHBhcmVudCwgbm9kZSwgb2Zmc2V0KSB7XG4gICAgZm9yICg7Oykge1xuICAgICAgICBpZiAoIW5vZGUgfHwgb2Zmc2V0IDwgbWF4T2Zmc2V0KG5vZGUpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAobm9kZSA9PSBwYXJlbnQpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgb2Zmc2V0ID0gZG9tSW5kZXgobm9kZSkgKyAxO1xuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzQmxvY2tFbGVtZW50KG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PSAxICYmIC9eKERJVnxQfExJfFVMfE9MfEJMT0NLUVVPVEV8RER8RFR8SFxcZHxTRUNUSU9OfFBSRSkkLy50ZXN0KG5vZGUubm9kZU5hbWUpO1xufVxuY2xhc3MgRE9NUG9pbnQge1xuICAgIGNvbnN0cnVjdG9yKG5vZGUsIG9mZnNldCkge1xuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgdGhpcy5wb3MgPSAtMTtcbiAgICB9XG59XG5cbmNsYXNzIERPTUNoYW5nZSB7XG4gICAgY29uc3RydWN0b3Iodmlldywgc3RhcnQsIGVuZCwgdHlwZU92ZXIpIHtcbiAgICAgICAgdGhpcy50eXBlT3ZlciA9IHR5cGVPdmVyO1xuICAgICAgICB0aGlzLmJvdW5kcyA9IG51bGw7XG4gICAgICAgIHRoaXMudGV4dCA9IFwiXCI7XG4gICAgICAgIGxldCB7IGltcHJlY2lzZUhlYWQ6IGlIZWFkLCBpbXByZWNpc2VBbmNob3I6IGlBbmNob3IgfSA9IHZpZXcuZG9jVmlldztcbiAgICAgICAgaWYgKHZpZXcuc3RhdGUucmVhZE9ubHkgJiYgc3RhcnQgPiAtMSkge1xuICAgICAgICAgICAgLy8gSWdub3JlIGNoYW5nZXMgd2hlbiB0aGUgZWRpdG9yIGlzIHJlYWQtb25seVxuICAgICAgICAgICAgdGhpcy5uZXdTZWwgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXJ0ID4gLTEgJiYgKHRoaXMuYm91bmRzID0gdmlldy5kb2NWaWV3LmRvbUJvdW5kc0Fyb3VuZChzdGFydCwgZW5kLCAwKSkpIHtcbiAgICAgICAgICAgIGxldCBzZWxQb2ludHMgPSBpSGVhZCB8fCBpQW5jaG9yID8gW10gOiBzZWxlY3Rpb25Qb2ludHModmlldyk7XG4gICAgICAgICAgICBsZXQgcmVhZGVyID0gbmV3IERPTVJlYWRlcihzZWxQb2ludHMsIHZpZXcuc3RhdGUpO1xuICAgICAgICAgICAgcmVhZGVyLnJlYWRSYW5nZSh0aGlzLmJvdW5kcy5zdGFydERPTSwgdGhpcy5ib3VuZHMuZW5kRE9NKTtcbiAgICAgICAgICAgIHRoaXMudGV4dCA9IHJlYWRlci50ZXh0O1xuICAgICAgICAgICAgdGhpcy5uZXdTZWwgPSBzZWxlY3Rpb25Gcm9tUG9pbnRzKHNlbFBvaW50cywgdGhpcy5ib3VuZHMuZnJvbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgZG9tU2VsID0gdmlldy5vYnNlcnZlci5zZWxlY3Rpb25SYW5nZTtcbiAgICAgICAgICAgIGxldCBoZWFkID0gaUhlYWQgJiYgaUhlYWQubm9kZSA9PSBkb21TZWwuZm9jdXNOb2RlICYmIGlIZWFkLm9mZnNldCA9PSBkb21TZWwuZm9jdXNPZmZzZXQgfHxcbiAgICAgICAgICAgICAgICAhY29udGFpbnModmlldy5jb250ZW50RE9NLCBkb21TZWwuZm9jdXNOb2RlKVxuICAgICAgICAgICAgICAgID8gdmlldy5zdGF0ZS5zZWxlY3Rpb24ubWFpbi5oZWFkXG4gICAgICAgICAgICAgICAgOiB2aWV3LmRvY1ZpZXcucG9zRnJvbURPTShkb21TZWwuZm9jdXNOb2RlLCBkb21TZWwuZm9jdXNPZmZzZXQpO1xuICAgICAgICAgICAgbGV0IGFuY2hvciA9IGlBbmNob3IgJiYgaUFuY2hvci5ub2RlID09IGRvbVNlbC5hbmNob3JOb2RlICYmIGlBbmNob3Iub2Zmc2V0ID09IGRvbVNlbC5hbmNob3JPZmZzZXQgfHxcbiAgICAgICAgICAgICAgICAhY29udGFpbnModmlldy5jb250ZW50RE9NLCBkb21TZWwuYW5jaG9yTm9kZSlcbiAgICAgICAgICAgICAgICA/IHZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW4uYW5jaG9yXG4gICAgICAgICAgICAgICAgOiB2aWV3LmRvY1ZpZXcucG9zRnJvbURPTShkb21TZWwuYW5jaG9yTm9kZSwgZG9tU2VsLmFuY2hvck9mZnNldCk7XG4gICAgICAgICAgICB0aGlzLm5ld1NlbCA9IEVkaXRvclNlbGVjdGlvbi5zaW5nbGUoYW5jaG9yLCBoZWFkKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGFwcGx5RE9NQ2hhbmdlKHZpZXcsIGRvbUNoYW5nZSkge1xuICAgIGxldCBjaGFuZ2U7XG4gICAgbGV0IHsgbmV3U2VsIH0gPSBkb21DaGFuZ2UsIHNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW47XG4gICAgbGV0IGxhc3RLZXkgPSB2aWV3LmlucHV0U3RhdGUubGFzdEtleVRpbWUgPiBEYXRlLm5vdygpIC0gMTAwID8gdmlldy5pbnB1dFN0YXRlLmxhc3RLZXlDb2RlIDogLTE7XG4gICAgaWYgKGRvbUNoYW5nZS5ib3VuZHMpIHtcbiAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IGRvbUNoYW5nZS5ib3VuZHM7XG4gICAgICAgIGxldCBwcmVmZXJyZWRQb3MgPSBzZWwuZnJvbSwgcHJlZmVycmVkU2lkZSA9IG51bGw7XG4gICAgICAgIC8vIFByZWZlciBhbmNob3JpbmcgdG8gZW5kIHdoZW4gQmFja3NwYWNlIGlzIHByZXNzZWQgKG9yLCBvblxuICAgICAgICAvLyBBbmRyb2lkLCB3aGVuIHNvbWV0aGluZyB3YXMgZGVsZXRlZClcbiAgICAgICAgaWYgKGxhc3RLZXkgPT09IDggfHwgYnJvd3Nlci5hbmRyb2lkICYmIGRvbUNoYW5nZS50ZXh0Lmxlbmd0aCA8IHRvIC0gZnJvbSkge1xuICAgICAgICAgICAgcHJlZmVycmVkUG9zID0gc2VsLnRvO1xuICAgICAgICAgICAgcHJlZmVycmVkU2lkZSA9IFwiZW5kXCI7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRpZmYgPSBmaW5kRGlmZih2aWV3LnN0YXRlLmRvYy5zbGljZVN0cmluZyhmcm9tLCB0bywgTGluZUJyZWFrUGxhY2Vob2xkZXIpLCBkb21DaGFuZ2UudGV4dCwgcHJlZmVycmVkUG9zIC0gZnJvbSwgcHJlZmVycmVkU2lkZSk7XG4gICAgICAgIGlmIChkaWZmKSB7XG4gICAgICAgICAgICAvLyBDaHJvbWUgaW5zZXJ0cyB0d28gbmV3bGluZXMgd2hlbiBwcmVzc2luZyBzaGlmdC1lbnRlciBhdCB0aGVcbiAgICAgICAgICAgIC8vIGVuZCBvZiBhIGxpbmUuIERvbUNoYW5nZSBkcm9wcyBvbmUgb2YgdGhvc2UuXG4gICAgICAgICAgICBpZiAoYnJvd3Nlci5jaHJvbWUgJiYgbGFzdEtleSA9PSAxMyAmJlxuICAgICAgICAgICAgICAgIGRpZmYudG9CID09IGRpZmYuZnJvbSArIDIgJiYgZG9tQ2hhbmdlLnRleHQuc2xpY2UoZGlmZi5mcm9tLCBkaWZmLnRvQikgPT0gTGluZUJyZWFrUGxhY2Vob2xkZXIgKyBMaW5lQnJlYWtQbGFjZWhvbGRlcilcbiAgICAgICAgICAgICAgICBkaWZmLnRvQi0tO1xuICAgICAgICAgICAgY2hhbmdlID0geyBmcm9tOiBmcm9tICsgZGlmZi5mcm9tLCB0bzogZnJvbSArIGRpZmYudG9BLFxuICAgICAgICAgICAgICAgIGluc2VydDogVGV4dC5vZihkb21DaGFuZ2UudGV4dC5zbGljZShkaWZmLmZyb20sIGRpZmYudG9CKS5zcGxpdChMaW5lQnJlYWtQbGFjZWhvbGRlcikpIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAobmV3U2VsICYmICghdmlldy5oYXNGb2N1cyAmJiB2aWV3LnN0YXRlLmZhY2V0KGVkaXRhYmxlKSB8fCBuZXdTZWwubWFpbi5lcShzZWwpKSkge1xuICAgICAgICBuZXdTZWwgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoIWNoYW5nZSAmJiAhbmV3U2VsKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCFjaGFuZ2UgJiYgZG9tQ2hhbmdlLnR5cGVPdmVyICYmICFzZWwuZW1wdHkgJiYgbmV3U2VsICYmIG5ld1NlbC5tYWluLmVtcHR5KSB7XG4gICAgICAgIC8vIEhldXJpc3RpYyB0byBub3RpY2UgdHlwaW5nIG92ZXIgYSBzZWxlY3RlZCBjaGFyYWN0ZXJcbiAgICAgICAgY2hhbmdlID0geyBmcm9tOiBzZWwuZnJvbSwgdG86IHNlbC50bywgaW5zZXJ0OiB2aWV3LnN0YXRlLmRvYy5zbGljZShzZWwuZnJvbSwgc2VsLnRvKSB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChjaGFuZ2UgJiYgY2hhbmdlLmZyb20gPj0gc2VsLmZyb20gJiYgY2hhbmdlLnRvIDw9IHNlbC50byAmJlxuICAgICAgICAoY2hhbmdlLmZyb20gIT0gc2VsLmZyb20gfHwgY2hhbmdlLnRvICE9IHNlbC50bykgJiZcbiAgICAgICAgKHNlbC50byAtIHNlbC5mcm9tKSAtIChjaGFuZ2UudG8gLSBjaGFuZ2UuZnJvbSkgPD0gNCkge1xuICAgICAgICAvLyBJZiB0aGUgY2hhbmdlIGlzIGluc2lkZSB0aGUgc2VsZWN0aW9uIGFuZCBjb3ZlcnMgbW9zdCBvZiBpdCxcbiAgICAgICAgLy8gYXNzdW1lIGl0IGlzIGEgc2VsZWN0aW9uIHJlcGxhY2UgKHdpdGggaWRlbnRpY2FsIGNoYXJhY3RlcnMgYXRcbiAgICAgICAgLy8gdGhlIHN0YXJ0L2VuZCBub3QgaW5jbHVkZWQgaW4gdGhlIGRpZmYpXG4gICAgICAgIGNoYW5nZSA9IHtcbiAgICAgICAgICAgIGZyb206IHNlbC5mcm9tLCB0bzogc2VsLnRvLFxuICAgICAgICAgICAgaW5zZXJ0OiB2aWV3LnN0YXRlLmRvYy5zbGljZShzZWwuZnJvbSwgY2hhbmdlLmZyb20pLmFwcGVuZChjaGFuZ2UuaW5zZXJ0KS5hcHBlbmQodmlldy5zdGF0ZS5kb2Muc2xpY2UoY2hhbmdlLnRvLCBzZWwudG8pKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmICgoYnJvd3Nlci5tYWMgfHwgYnJvd3Nlci5hbmRyb2lkKSAmJiBjaGFuZ2UgJiYgY2hhbmdlLmZyb20gPT0gY2hhbmdlLnRvICYmIGNoYW5nZS5mcm9tID09IHNlbC5oZWFkIC0gMSAmJlxuICAgICAgICAvXlxcLiA/JC8udGVzdChjaGFuZ2UuaW5zZXJ0LnRvU3RyaW5nKCkpICYmIHZpZXcuY29udGVudERPTS5nZXRBdHRyaWJ1dGUoXCJhdXRvY29ycmVjdFwiKSA9PSBcIm9mZlwiKSB7XG4gICAgICAgIC8vIERldGVjdCBpbnNlcnQtcGVyaW9kLW9uLWRvdWJsZS1zcGFjZSBNYWMgYW5kIEFuZHJvaWQgYmVoYXZpb3IsXG4gICAgICAgIC8vIGFuZCB0cmFuc2Zvcm0gaXQgaW50byBhIHJlZ3VsYXIgc3BhY2UgaW5zZXJ0LlxuICAgICAgICBpZiAobmV3U2VsICYmIGNoYW5nZS5pbnNlcnQubGVuZ3RoID09IDIpXG4gICAgICAgICAgICBuZXdTZWwgPSBFZGl0b3JTZWxlY3Rpb24uc2luZ2xlKG5ld1NlbC5tYWluLmFuY2hvciAtIDEsIG5ld1NlbC5tYWluLmhlYWQgLSAxKTtcbiAgICAgICAgY2hhbmdlID0geyBmcm9tOiBzZWwuZnJvbSwgdG86IHNlbC50bywgaW5zZXJ0OiBUZXh0Lm9mKFtcIiBcIl0pIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGJyb3dzZXIuY2hyb21lICYmIGNoYW5nZSAmJiBjaGFuZ2UuZnJvbSA9PSBjaGFuZ2UudG8gJiYgY2hhbmdlLmZyb20gPT0gc2VsLmhlYWQgJiZcbiAgICAgICAgY2hhbmdlLmluc2VydC50b1N0cmluZygpID09IFwiXFxuIFwiICYmIHZpZXcubGluZVdyYXBwaW5nKSB7XG4gICAgICAgIC8vIEluIENocm9tZSwgaWYgeW91IGluc2VydCBhIHNwYWNlIGF0IHRoZSBzdGFydCBvZiBhIHdyYXBwZWRcbiAgICAgICAgLy8gbGluZSwgaXQgd2lsbCBhY3R1YWxseSBpbnNlcnQgYSBuZXdsaW5lIGFuZCBhIHNwYWNlLCBjYXVzaW5nIGFcbiAgICAgICAgLy8gYm9ndXMgbmV3IGxpbmUgdG8gYmUgY3JlYXRlZCBpbiBDb2RlTWlycm9yICgjOTY4KVxuICAgICAgICBpZiAobmV3U2VsKVxuICAgICAgICAgICAgbmV3U2VsID0gRWRpdG9yU2VsZWN0aW9uLnNpbmdsZShuZXdTZWwubWFpbi5hbmNob3IgLSAxLCBuZXdTZWwubWFpbi5oZWFkIC0gMSk7XG4gICAgICAgIGNoYW5nZSA9IHsgZnJvbTogc2VsLmZyb20sIHRvOiBzZWwudG8sIGluc2VydDogVGV4dC5vZihbXCIgXCJdKSB9O1xuICAgIH1cbiAgICBpZiAoY2hhbmdlKSB7XG4gICAgICAgIGlmIChicm93c2VyLmlvcyAmJiB2aWV3LmlucHV0U3RhdGUuZmx1c2hJT1NLZXkoKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAvLyBBbmRyb2lkIGJyb3dzZXJzIGRvbid0IGZpcmUgcmVhc29uYWJsZSBrZXkgZXZlbnRzIGZvciBlbnRlcixcbiAgICAgICAgLy8gYmFja3NwYWNlLCBvciBkZWxldGUuIFNvIHRoaXMgZGV0ZWN0cyBjaGFuZ2VzIHRoYXQgbG9vayBsaWtlXG4gICAgICAgIC8vIHRoZXkncmUgY2F1c2VkIGJ5IHRob3NlIGtleXMsIGFuZCByZWludGVycHJldHMgdGhlbSBhcyBrZXlcbiAgICAgICAgLy8gZXZlbnRzLiAoU29tZSBvZiB0aGVzZSBrZXlzIGFyZSBhbHNvIGhhbmRsZWQgYnkgYmVmb3JlaW5wdXRcbiAgICAgICAgLy8gZXZlbnRzIGFuZCB0aGUgcGVuZGluZ0FuZHJvaWRLZXkgbWVjaGFuaXNtLCBidXQgdGhhdCdzIG5vdFxuICAgICAgICAvLyByZWxpYWJsZSBpbiBhbGwgc2l0dWF0aW9ucy4pXG4gICAgICAgIGlmIChicm93c2VyLmFuZHJvaWQgJiZcbiAgICAgICAgICAgICgoY2hhbmdlLmZyb20gPT0gc2VsLmZyb20gJiYgY2hhbmdlLnRvID09IHNlbC50byAmJlxuICAgICAgICAgICAgICAgIGNoYW5nZS5pbnNlcnQubGVuZ3RoID09IDEgJiYgY2hhbmdlLmluc2VydC5saW5lcyA9PSAyICYmXG4gICAgICAgICAgICAgICAgZGlzcGF0Y2hLZXkodmlldy5jb250ZW50RE9NLCBcIkVudGVyXCIsIDEzKSkgfHxcbiAgICAgICAgICAgICAgICAoKGNoYW5nZS5mcm9tID09IHNlbC5mcm9tIC0gMSAmJiBjaGFuZ2UudG8gPT0gc2VsLnRvICYmIGNoYW5nZS5pbnNlcnQubGVuZ3RoID09IDAgfHxcbiAgICAgICAgICAgICAgICAgICAgbGFzdEtleSA9PSA4ICYmIGNoYW5nZS5pbnNlcnQubGVuZ3RoIDwgY2hhbmdlLnRvIC0gY2hhbmdlLmZyb20gJiYgY2hhbmdlLnRvID4gc2VsLmhlYWQpICYmXG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoS2V5KHZpZXcuY29udGVudERPTSwgXCJCYWNrc3BhY2VcIiwgOCkpIHx8XG4gICAgICAgICAgICAgICAgKGNoYW5nZS5mcm9tID09IHNlbC5mcm9tICYmIGNoYW5nZS50byA9PSBzZWwudG8gKyAxICYmIGNoYW5nZS5pbnNlcnQubGVuZ3RoID09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2hLZXkodmlldy5jb250ZW50RE9NLCBcIkRlbGV0ZVwiLCA0NikpKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBsZXQgdGV4dCA9IGNoYW5nZS5pbnNlcnQudG9TdHJpbmcoKTtcbiAgICAgICAgaWYgKHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpbmcgPj0gMClcbiAgICAgICAgICAgIHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpbmcrKztcbiAgICAgICAgbGV0IGRlZmF1bHRUcjtcbiAgICAgICAgbGV0IGRlZmF1bHRJbnNlcnQgPSAoKSA9PiBkZWZhdWx0VHIgfHwgKGRlZmF1bHRUciA9IGFwcGx5RGVmYXVsdEluc2VydCh2aWV3LCBjaGFuZ2UsIG5ld1NlbCkpO1xuICAgICAgICBpZiAoIXZpZXcuc3RhdGUuZmFjZXQoaW5wdXRIYW5kbGVyKS5zb21lKGggPT4gaCh2aWV3LCBjaGFuZ2UuZnJvbSwgY2hhbmdlLnRvLCB0ZXh0LCBkZWZhdWx0SW5zZXJ0KSkpXG4gICAgICAgICAgICB2aWV3LmRpc3BhdGNoKGRlZmF1bHRJbnNlcnQoKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbHNlIGlmIChuZXdTZWwgJiYgIW5ld1NlbC5tYWluLmVxKHNlbCkpIHtcbiAgICAgICAgbGV0IHNjcm9sbEludG9WaWV3ID0gZmFsc2UsIHVzZXJFdmVudCA9IFwic2VsZWN0XCI7XG4gICAgICAgIGlmICh2aWV3LmlucHV0U3RhdGUubGFzdFNlbGVjdGlvblRpbWUgPiBEYXRlLm5vdygpIC0gNTApIHtcbiAgICAgICAgICAgIGlmICh2aWV3LmlucHV0U3RhdGUubGFzdFNlbGVjdGlvbk9yaWdpbiA9PSBcInNlbGVjdFwiKVxuICAgICAgICAgICAgICAgIHNjcm9sbEludG9WaWV3ID0gdHJ1ZTtcbiAgICAgICAgICAgIHVzZXJFdmVudCA9IHZpZXcuaW5wdXRTdGF0ZS5sYXN0U2VsZWN0aW9uT3JpZ2luO1xuICAgICAgICB9XG4gICAgICAgIHZpZXcuZGlzcGF0Y2goeyBzZWxlY3Rpb246IG5ld1NlbCwgc2Nyb2xsSW50b1ZpZXcsIHVzZXJFdmVudCB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gYXBwbHlEZWZhdWx0SW5zZXJ0KHZpZXcsIGNoYW5nZSwgbmV3U2VsKSB7XG4gICAgbGV0IHRyLCBzdGFydFN0YXRlID0gdmlldy5zdGF0ZSwgc2VsID0gc3RhcnRTdGF0ZS5zZWxlY3Rpb24ubWFpbjtcbiAgICBpZiAoY2hhbmdlLmZyb20gPj0gc2VsLmZyb20gJiYgY2hhbmdlLnRvIDw9IHNlbC50byAmJiBjaGFuZ2UudG8gLSBjaGFuZ2UuZnJvbSA+PSAoc2VsLnRvIC0gc2VsLmZyb20pIC8gMyAmJlxuICAgICAgICAoIW5ld1NlbCB8fCBuZXdTZWwubWFpbi5lbXB0eSAmJiBuZXdTZWwubWFpbi5mcm9tID09IGNoYW5nZS5mcm9tICsgY2hhbmdlLmluc2VydC5sZW5ndGgpICYmXG4gICAgICAgIHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpbmcgPCAwKSB7XG4gICAgICAgIGxldCBiZWZvcmUgPSBzZWwuZnJvbSA8IGNoYW5nZS5mcm9tID8gc3RhcnRTdGF0ZS5zbGljZURvYyhzZWwuZnJvbSwgY2hhbmdlLmZyb20pIDogXCJcIjtcbiAgICAgICAgbGV0IGFmdGVyID0gc2VsLnRvID4gY2hhbmdlLnRvID8gc3RhcnRTdGF0ZS5zbGljZURvYyhjaGFuZ2UudG8sIHNlbC50bykgOiBcIlwiO1xuICAgICAgICB0ciA9IHN0YXJ0U3RhdGUucmVwbGFjZVNlbGVjdGlvbih2aWV3LnN0YXRlLnRvVGV4dChiZWZvcmUgKyBjaGFuZ2UuaW5zZXJ0LnNsaWNlU3RyaW5nKDAsIHVuZGVmaW5lZCwgdmlldy5zdGF0ZS5saW5lQnJlYWspICsgYWZ0ZXIpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCBjaGFuZ2VzID0gc3RhcnRTdGF0ZS5jaGFuZ2VzKGNoYW5nZSk7XG4gICAgICAgIGxldCBtYWluU2VsID0gbmV3U2VsICYmIG5ld1NlbC5tYWluLnRvIDw9IGNoYW5nZXMubmV3TGVuZ3RoID8gbmV3U2VsLm1haW4gOiB1bmRlZmluZWQ7XG4gICAgICAgIC8vIFRyeSB0byBhcHBseSBhIGNvbXBvc2l0aW9uIGNoYW5nZSB0byBhbGwgY3Vyc29yc1xuICAgICAgICBpZiAoc3RhcnRTdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzLmxlbmd0aCA+IDEgJiYgdmlldy5pbnB1dFN0YXRlLmNvbXBvc2luZyA+PSAwICYmXG4gICAgICAgICAgICBjaGFuZ2UudG8gPD0gc2VsLnRvICYmIGNoYW5nZS50byA+PSBzZWwudG8gLSAxMCkge1xuICAgICAgICAgICAgbGV0IHJlcGxhY2VkID0gdmlldy5zdGF0ZS5zbGljZURvYyhjaGFuZ2UuZnJvbSwgY2hhbmdlLnRvKTtcbiAgICAgICAgICAgIGxldCBjb21wb3NpdGlvblJhbmdlLCBjb21wb3NpdGlvbiA9IG5ld1NlbCAmJiBmaW5kQ29tcG9zaXRpb25Ob2RlKHZpZXcsIG5ld1NlbC5tYWluLmhlYWQpO1xuICAgICAgICAgICAgaWYgKGNvbXBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgbGV0IGRMZW4gPSBjaGFuZ2UuaW5zZXJ0Lmxlbmd0aCAtIChjaGFuZ2UudG8gLSBjaGFuZ2UuZnJvbSk7XG4gICAgICAgICAgICAgICAgY29tcG9zaXRpb25SYW5nZSA9IHsgZnJvbTogY29tcG9zaXRpb24uZnJvbSwgdG86IGNvbXBvc2l0aW9uLnRvIC0gZExlbiB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29tcG9zaXRpb25SYW5nZSA9IHZpZXcuc3RhdGUuZG9jLmxpbmVBdChzZWwuaGVhZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgb2Zmc2V0ID0gc2VsLnRvIC0gY2hhbmdlLnRvLCBzaXplID0gc2VsLnRvIC0gc2VsLmZyb207XG4gICAgICAgICAgICB0ciA9IHN0YXJ0U3RhdGUuY2hhbmdlQnlSYW5nZShyYW5nZSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlLmZyb20gPT0gc2VsLmZyb20gJiYgcmFuZ2UudG8gPT0gc2VsLnRvKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBjaGFuZ2VzLCByYW5nZTogbWFpblNlbCB8fCByYW5nZS5tYXAoY2hhbmdlcykgfTtcbiAgICAgICAgICAgICAgICBsZXQgdG8gPSByYW5nZS50byAtIG9mZnNldCwgZnJvbSA9IHRvIC0gcmVwbGFjZWQubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChyYW5nZS50byAtIHJhbmdlLmZyb20gIT0gc2l6ZSB8fCB2aWV3LnN0YXRlLnNsaWNlRG9jKGZyb20sIHRvKSAhPSByZXBsYWNlZCB8fFxuICAgICAgICAgICAgICAgICAgICAvLyBVbmZvcnR1bmF0ZWx5LCB0aGVyZSdzIG5vIHdheSB0byBtYWtlIG11bHRpcGxlXG4gICAgICAgICAgICAgICAgICAgIC8vIGNoYW5nZXMgaW4gdGhlIHNhbWUgbm9kZSB3b3JrIHdpdGhvdXQgYWJvcnRpbmdcbiAgICAgICAgICAgICAgICAgICAgLy8gY29tcG9zaXRpb24sIHNvIGN1cnNvcnMgaW4gdGhlIGNvbXBvc2l0aW9uIHJhbmdlIGFyZVxuICAgICAgICAgICAgICAgICAgICAvLyBpZ25vcmVkLlxuICAgICAgICAgICAgICAgICAgICByYW5nZS50byA+PSBjb21wb3NpdGlvblJhbmdlLmZyb20gJiYgcmFuZ2UuZnJvbSA8PSBjb21wb3NpdGlvblJhbmdlLnRvKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyByYW5nZSB9O1xuICAgICAgICAgICAgICAgIGxldCByYW5nZUNoYW5nZXMgPSBzdGFydFN0YXRlLmNoYW5nZXMoeyBmcm9tLCB0bywgaW5zZXJ0OiBjaGFuZ2UuaW5zZXJ0IH0pLCBzZWxPZmYgPSByYW5nZS50byAtIHNlbC50bztcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VzOiByYW5nZUNoYW5nZXMsXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlOiAhbWFpblNlbCA/IHJhbmdlLm1hcChyYW5nZUNoYW5nZXMpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIEVkaXRvclNlbGVjdGlvbi5yYW5nZShNYXRoLm1heCgwLCBtYWluU2VsLmFuY2hvciArIHNlbE9mZiksIE1hdGgubWF4KDAsIG1haW5TZWwuaGVhZCArIHNlbE9mZikpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdHIgPSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlcyxcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb246IG1haW5TZWwgJiYgc3RhcnRTdGF0ZS5zZWxlY3Rpb24ucmVwbGFjZVJhbmdlKG1haW5TZWwpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCB1c2VyRXZlbnQgPSBcImlucHV0LnR5cGVcIjtcbiAgICBpZiAodmlldy5jb21wb3NpbmcgfHxcbiAgICAgICAgdmlldy5pbnB1dFN0YXRlLmNvbXBvc2l0aW9uUGVuZGluZ0NoYW5nZSAmJiB2aWV3LmlucHV0U3RhdGUuY29tcG9zaXRpb25FbmRlZEF0ID4gRGF0ZS5ub3coKSAtIDUwKSB7XG4gICAgICAgIHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpdGlvblBlbmRpbmdDaGFuZ2UgPSBmYWxzZTtcbiAgICAgICAgdXNlckV2ZW50ICs9IFwiLmNvbXBvc2VcIjtcbiAgICAgICAgaWYgKHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpdGlvbkZpcnN0Q2hhbmdlKSB7XG4gICAgICAgICAgICB1c2VyRXZlbnQgKz0gXCIuc3RhcnRcIjtcbiAgICAgICAgICAgIHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpdGlvbkZpcnN0Q2hhbmdlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0YXJ0U3RhdGUudXBkYXRlKHRyLCB7IHVzZXJFdmVudCwgc2Nyb2xsSW50b1ZpZXc6IHRydWUgfSk7XG59XG5mdW5jdGlvbiBmaW5kRGlmZihhLCBiLCBwcmVmZXJyZWRQb3MsIHByZWZlcnJlZFNpZGUpIHtcbiAgICBsZXQgbWluTGVuID0gTWF0aC5taW4oYS5sZW5ndGgsIGIubGVuZ3RoKTtcbiAgICBsZXQgZnJvbSA9IDA7XG4gICAgd2hpbGUgKGZyb20gPCBtaW5MZW4gJiYgYS5jaGFyQ29kZUF0KGZyb20pID09IGIuY2hhckNvZGVBdChmcm9tKSlcbiAgICAgICAgZnJvbSsrO1xuICAgIGlmIChmcm9tID09IG1pbkxlbiAmJiBhLmxlbmd0aCA9PSBiLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IHRvQSA9IGEubGVuZ3RoLCB0b0IgPSBiLmxlbmd0aDtcbiAgICB3aGlsZSAodG9BID4gMCAmJiB0b0IgPiAwICYmIGEuY2hhckNvZGVBdCh0b0EgLSAxKSA9PSBiLmNoYXJDb2RlQXQodG9CIC0gMSkpIHtcbiAgICAgICAgdG9BLS07XG4gICAgICAgIHRvQi0tO1xuICAgIH1cbiAgICBpZiAocHJlZmVycmVkU2lkZSA9PSBcImVuZFwiKSB7XG4gICAgICAgIGxldCBhZGp1c3QgPSBNYXRoLm1heCgwLCBmcm9tIC0gTWF0aC5taW4odG9BLCB0b0IpKTtcbiAgICAgICAgcHJlZmVycmVkUG9zIC09IHRvQSArIGFkanVzdCAtIGZyb207XG4gICAgfVxuICAgIGlmICh0b0EgPCBmcm9tICYmIGEubGVuZ3RoIDwgYi5sZW5ndGgpIHtcbiAgICAgICAgbGV0IG1vdmUgPSBwcmVmZXJyZWRQb3MgPD0gZnJvbSAmJiBwcmVmZXJyZWRQb3MgPj0gdG9BID8gZnJvbSAtIHByZWZlcnJlZFBvcyA6IDA7XG4gICAgICAgIGZyb20gLT0gbW92ZTtcbiAgICAgICAgdG9CID0gZnJvbSArICh0b0IgLSB0b0EpO1xuICAgICAgICB0b0EgPSBmcm9tO1xuICAgIH1cbiAgICBlbHNlIGlmICh0b0IgPCBmcm9tKSB7XG4gICAgICAgIGxldCBtb3ZlID0gcHJlZmVycmVkUG9zIDw9IGZyb20gJiYgcHJlZmVycmVkUG9zID49IHRvQiA/IGZyb20gLSBwcmVmZXJyZWRQb3MgOiAwO1xuICAgICAgICBmcm9tIC09IG1vdmU7XG4gICAgICAgIHRvQSA9IGZyb20gKyAodG9BIC0gdG9CKTtcbiAgICAgICAgdG9CID0gZnJvbTtcbiAgICB9XG4gICAgcmV0dXJuIHsgZnJvbSwgdG9BLCB0b0IgfTtcbn1cbmZ1bmN0aW9uIHNlbGVjdGlvblBvaW50cyh2aWV3KSB7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGlmICh2aWV3LnJvb3QuYWN0aXZlRWxlbWVudCAhPSB2aWV3LmNvbnRlbnRET00pXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgbGV0IHsgYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0LCBmb2N1c05vZGUsIGZvY3VzT2Zmc2V0IH0gPSB2aWV3Lm9ic2VydmVyLnNlbGVjdGlvblJhbmdlO1xuICAgIGlmIChhbmNob3JOb2RlKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKG5ldyBET01Qb2ludChhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQpKTtcbiAgICAgICAgaWYgKGZvY3VzTm9kZSAhPSBhbmNob3JOb2RlIHx8IGZvY3VzT2Zmc2V0ICE9IGFuY2hvck9mZnNldClcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyBET01Qb2ludChmb2N1c05vZGUsIGZvY3VzT2Zmc2V0KSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBzZWxlY3Rpb25Gcm9tUG9pbnRzKHBvaW50cywgYmFzZSkge1xuICAgIGlmIChwb2ludHMubGVuZ3RoID09IDApXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBhbmNob3IgPSBwb2ludHNbMF0ucG9zLCBoZWFkID0gcG9pbnRzLmxlbmd0aCA9PSAyID8gcG9pbnRzWzFdLnBvcyA6IGFuY2hvcjtcbiAgICByZXR1cm4gYW5jaG9yID4gLTEgJiYgaGVhZCA+IC0xID8gRWRpdG9yU2VsZWN0aW9uLnNpbmdsZShhbmNob3IgKyBiYXNlLCBoZWFkICsgYmFzZSkgOiBudWxsO1xufVxuXG5jb25zdCBvYnNlcnZlT3B0aW9ucyA9IHtcbiAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgY2hhcmFjdGVyRGF0YTogdHJ1ZSxcbiAgICBzdWJ0cmVlOiB0cnVlLFxuICAgIGF0dHJpYnV0ZXM6IHRydWUsXG4gICAgY2hhcmFjdGVyRGF0YU9sZFZhbHVlOiB0cnVlXG59O1xuLy8gSUUxMSBoYXMgdmVyeSBicm9rZW4gbXV0YXRpb24gb2JzZXJ2ZXJzLCBzbyB3ZSBhbHNvIGxpc3RlbiB0b1xuLy8gRE9NQ2hhcmFjdGVyRGF0YU1vZGlmaWVkIHRoZXJlXG5jb25zdCB1c2VDaGFyRGF0YSA9IGJyb3dzZXIuaWUgJiYgYnJvd3Nlci5pZV92ZXJzaW9uIDw9IDExO1xuY2xhc3MgRE9NT2JzZXJ2ZXIge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgLy8gVGhlIGtub3duIHNlbGVjdGlvbi4gS2VwdCBpbiBvdXIgb3duIG9iamVjdCwgYXMgb3Bwb3NlZCB0byBqdXN0XG4gICAgICAgIC8vIGRpcmVjdGx5IGFjY2Vzc2luZyB0aGUgc2VsZWN0aW9uIGJlY2F1c2U6XG4gICAgICAgIC8vICAtIFNhZmFyaSBkb2Vzbid0IHJlcG9ydCB0aGUgcmlnaHQgc2VsZWN0aW9uIGluIHNoYWRvdyBET01cbiAgICAgICAgLy8gIC0gUmVhZGluZyBmcm9tIHRoZSBzZWxlY3Rpb24gZm9yY2VzIGEgRE9NIGxheW91dFxuICAgICAgICAvLyAgLSBUaGlzIHdheSwgd2UgY2FuIGlnbm9yZSBzZWxlY3Rpb25jaGFuZ2UgZXZlbnRzIGlmIHdlIGhhdmVcbiAgICAgICAgLy8gICAgYWxyZWFkeSBzZWVuIHRoZSAnbmV3JyBzZWxlY3Rpb25cbiAgICAgICAgdGhpcy5zZWxlY3Rpb25SYW5nZSA9IG5ldyBET01TZWxlY3Rpb25TdGF0ZTtcbiAgICAgICAgLy8gU2V0IHdoZW4gYSBzZWxlY3Rpb24gY2hhbmdlIGlzIGRldGVjdGVkLCBjbGVhcmVkIG9uIGZsdXNoXG4gICAgICAgIHRoaXMuc2VsZWN0aW9uQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRlbGF5ZWRGbHVzaCA9IC0xO1xuICAgICAgICB0aGlzLnJlc2l6ZVRpbWVvdXQgPSAtMTtcbiAgICAgICAgdGhpcy5xdWV1ZSA9IFtdO1xuICAgICAgICB0aGlzLmRlbGF5ZWRBbmRyb2lkS2V5ID0gbnVsbDtcbiAgICAgICAgdGhpcy5mbHVzaGluZ0FuZHJvaWRLZXkgPSAtMTtcbiAgICAgICAgdGhpcy5sYXN0Q2hhbmdlID0gMDtcbiAgICAgICAgdGhpcy5zY3JvbGxUYXJnZXRzID0gW107XG4gICAgICAgIHRoaXMuaW50ZXJzZWN0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZXNpemVTY3JvbGwgPSBudWxsO1xuICAgICAgICB0aGlzLmludGVyc2VjdGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmdhcEludGVyc2VjdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMuZ2FwcyA9IFtdO1xuICAgICAgICAvLyBUaW1lb3V0IGZvciBzY2hlZHVsaW5nIGNoZWNrIG9mIHRoZSBwYXJlbnRzIHRoYXQgbmVlZCBzY3JvbGwgaGFuZGxlcnNcbiAgICAgICAgdGhpcy5wYXJlbnRDaGVjayA9IC0xO1xuICAgICAgICB0aGlzLmRvbSA9IHZpZXcuY29udGVudERPTTtcbiAgICAgICAgdGhpcy5vYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKG11dGF0aW9ucyA9PiB7XG4gICAgICAgICAgICBmb3IgKGxldCBtdXQgb2YgbXV0YXRpb25zKVxuICAgICAgICAgICAgICAgIHRoaXMucXVldWUucHVzaChtdXQpO1xuICAgICAgICAgICAgLy8gSUUxMSB3aWxsIHNvbWV0aW1lcyAob24gdHlwaW5nIG92ZXIgYSBzZWxlY3Rpb24gb3JcbiAgICAgICAgICAgIC8vIGJhY2tzcGFjaW5nIG91dCBhIHNpbmdsZSBjaGFyYWN0ZXIgdGV4dCBub2RlKSBjYWxsIHRoZVxuICAgICAgICAgICAgLy8gb2JzZXJ2ZXIgY2FsbGJhY2sgYmVmb3JlIGFjdHVhbGx5IHVwZGF0aW5nIHRoZSBET00uXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gVW5yZWxhdGVkbHksIGlPUyBTYWZhcmkgd2lsbCwgd2hlbiBlbmRpbmcgYSBjb21wb3NpdGlvbixcbiAgICAgICAgICAgIC8vIHNvbWV0aW1lcyBmaXJzdCBjbGVhciBpdCwgZGVsaXZlciB0aGUgbXV0YXRpb25zLCBhbmQgdGhlblxuICAgICAgICAgICAgLy8gcmVpbnNlcnQgdGhlIGZpbmlzaGVkIHRleHQuIENvZGVNaXJyb3IncyBoYW5kbGluZyBvZiB0aGVcbiAgICAgICAgICAgIC8vIGRlbGV0aW9uIHdpbGwgcHJldmVudCB0aGUgcmVpbnNlcnRpb24gZnJvbSBoYXBwZW5pbmcsXG4gICAgICAgICAgICAvLyBicmVha2luZyBjb21wb3NpdGlvbi5cbiAgICAgICAgICAgIGlmICgoYnJvd3Nlci5pZSAmJiBicm93c2VyLmllX3ZlcnNpb24gPD0gMTEgfHwgYnJvd3Nlci5pb3MgJiYgdmlldy5jb21wb3NpbmcpICYmXG4gICAgICAgICAgICAgICAgbXV0YXRpb25zLnNvbWUobSA9PiBtLnR5cGUgPT0gXCJjaGlsZExpc3RcIiAmJiBtLnJlbW92ZWROb2Rlcy5sZW5ndGggfHxcbiAgICAgICAgICAgICAgICAgICAgbS50eXBlID09IFwiY2hhcmFjdGVyRGF0YVwiICYmIG0ub2xkVmFsdWUubGVuZ3RoID4gbS50YXJnZXQubm9kZVZhbHVlLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgdGhpcy5mbHVzaFNvb24oKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLmZsdXNoKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodXNlQ2hhckRhdGEpXG4gICAgICAgICAgICB0aGlzLm9uQ2hhckRhdGEgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLnB1c2goeyB0YXJnZXQ6IGV2ZW50LnRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJjaGFyYWN0ZXJEYXRhXCIsXG4gICAgICAgICAgICAgICAgICAgIG9sZFZhbHVlOiBldmVudC5wcmV2VmFsdWUgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5mbHVzaFNvb24oKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIHRoaXMub25TZWxlY3Rpb25DaGFuZ2UgPSB0aGlzLm9uU2VsZWN0aW9uQ2hhbmdlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25SZXNpemUgPSB0aGlzLm9uUmVzaXplLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25QcmludCA9IHRoaXMub25QcmludC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uU2Nyb2xsID0gdGhpcy5vblNjcm9sbC5iaW5kKHRoaXMpO1xuICAgICAgICBpZiAodHlwZW9mIFJlc2l6ZU9ic2VydmVyID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhpcy5yZXNpemVTY3JvbGwgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICBpZiAoKChfYSA9IHRoaXMudmlldy5kb2NWaWV3KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGFzdFVwZGF0ZSkgPCBEYXRlLm5vdygpIC0gNzUpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25SZXNpemUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5yZXNpemVTY3JvbGwub2JzZXJ2ZSh2aWV3LnNjcm9sbERPTSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZGRXaW5kb3dMaXN0ZW5lcnModGhpcy53aW4gPSB2aWV3Lndpbik7XG4gICAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICAgICAgaWYgKHR5cGVvZiBJbnRlcnNlY3Rpb25PYnNlcnZlciA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJzZWN0aW9uID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKGVudHJpZXMgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudENoZWNrIDwgMClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRDaGVjayA9IHNldFRpbWVvdXQodGhpcy5saXN0ZW5Gb3JTY3JvbGwuYmluZCh0aGlzKSwgMTAwMCk7XG4gICAgICAgICAgICAgICAgaWYgKGVudHJpZXMubGVuZ3RoID4gMCAmJiAoZW50cmllc1tlbnRyaWVzLmxlbmd0aCAtIDFdLmludGVyc2VjdGlvblJhdGlvID4gMCkgIT0gdGhpcy5pbnRlcnNlY3RpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnRlcnNlY3RpbmcgPSAhdGhpcy5pbnRlcnNlY3Rpbmc7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmludGVyc2VjdGluZyAhPSB0aGlzLnZpZXcuaW5WaWV3KVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vblNjcm9sbENoYW5nZWQoZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJFdmVudFwiKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgeyB0aHJlc2hvbGQ6IFswLCAuMDAxXSB9KTtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJzZWN0aW9uLm9ic2VydmUodGhpcy5kb20pO1xuICAgICAgICAgICAgdGhpcy5nYXBJbnRlcnNlY3Rpb24gPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoZW50cmllcyA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVudHJpZXMubGVuZ3RoID4gMCAmJiBlbnRyaWVzW2VudHJpZXMubGVuZ3RoIC0gMV0uaW50ZXJzZWN0aW9uUmF0aW8gPiAwKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uU2Nyb2xsQ2hhbmdlZChkb2N1bWVudC5jcmVhdGVFdmVudChcIkV2ZW50XCIpKTtcbiAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxpc3RlbkZvclNjcm9sbCgpO1xuICAgICAgICB0aGlzLnJlYWRTZWxlY3Rpb25SYW5nZSgpO1xuICAgIH1cbiAgICBvblNjcm9sbENoYW5nZWQoZSkge1xuICAgICAgICB0aGlzLnZpZXcuaW5wdXRTdGF0ZS5ydW5IYW5kbGVycyhcInNjcm9sbFwiLCBlKTtcbiAgICAgICAgaWYgKHRoaXMuaW50ZXJzZWN0aW5nKVxuICAgICAgICAgICAgdGhpcy52aWV3Lm1lYXN1cmUoKTtcbiAgICB9XG4gICAgb25TY3JvbGwoZSkge1xuICAgICAgICBpZiAodGhpcy5pbnRlcnNlY3RpbmcpXG4gICAgICAgICAgICB0aGlzLmZsdXNoKGZhbHNlKTtcbiAgICAgICAgdGhpcy5vblNjcm9sbENoYW5nZWQoZSk7XG4gICAgfVxuICAgIG9uUmVzaXplKCkge1xuICAgICAgICBpZiAodGhpcy5yZXNpemVUaW1lb3V0IDwgMClcbiAgICAgICAgICAgIHRoaXMucmVzaXplVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzaXplVGltZW91dCA9IC0xO1xuICAgICAgICAgICAgICAgIHRoaXMudmlldy5yZXF1ZXN0TWVhc3VyZSgpO1xuICAgICAgICAgICAgfSwgNTApO1xuICAgIH1cbiAgICBvblByaW50KCkge1xuICAgICAgICB0aGlzLnZpZXcudmlld1N0YXRlLnByaW50aW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy52aWV3Lm1lYXN1cmUoKTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnZpZXcudmlld1N0YXRlLnByaW50aW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnZpZXcucmVxdWVzdE1lYXN1cmUoKTtcbiAgICAgICAgfSwgNTAwKTtcbiAgICB9XG4gICAgdXBkYXRlR2FwcyhnYXBzKSB7XG4gICAgICAgIGlmICh0aGlzLmdhcEludGVyc2VjdGlvbiAmJiAoZ2Fwcy5sZW5ndGggIT0gdGhpcy5nYXBzLmxlbmd0aCB8fCB0aGlzLmdhcHMuc29tZSgoZywgaSkgPT4gZyAhPSBnYXBzW2ldKSkpIHtcbiAgICAgICAgICAgIHRoaXMuZ2FwSW50ZXJzZWN0aW9uLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGdhcCBvZiBnYXBzKVxuICAgICAgICAgICAgICAgIHRoaXMuZ2FwSW50ZXJzZWN0aW9uLm9ic2VydmUoZ2FwKTtcbiAgICAgICAgICAgIHRoaXMuZ2FwcyA9IGdhcHM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25TZWxlY3Rpb25DaGFuZ2UoZXZlbnQpIHtcbiAgICAgICAgbGV0IHdhc0NoYW5nZWQgPSB0aGlzLnNlbGVjdGlvbkNoYW5nZWQ7XG4gICAgICAgIGlmICghdGhpcy5yZWFkU2VsZWN0aW9uUmFuZ2UoKSB8fCB0aGlzLmRlbGF5ZWRBbmRyb2lkS2V5KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgeyB2aWV3IH0gPSB0aGlzLCBzZWwgPSB0aGlzLnNlbGVjdGlvblJhbmdlO1xuICAgICAgICBpZiAodmlldy5zdGF0ZS5mYWNldChlZGl0YWJsZSkgPyB2aWV3LnJvb3QuYWN0aXZlRWxlbWVudCAhPSB0aGlzLmRvbSA6ICFoYXNTZWxlY3Rpb24odmlldy5kb20sIHNlbCkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBjb250ZXh0ID0gc2VsLmFuY2hvck5vZGUgJiYgdmlldy5kb2NWaWV3Lm5lYXJlc3Qoc2VsLmFuY2hvck5vZGUpO1xuICAgICAgICBpZiAoY29udGV4dCAmJiBjb250ZXh0Lmlnbm9yZUV2ZW50KGV2ZW50KSkge1xuICAgICAgICAgICAgaWYgKCF3YXNDaGFuZ2VkKVxuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIERlbGV0aW9ucyBvbiBJRTExIGZpcmUgdGhlaXIgZXZlbnRzIGluIHRoZSB3cm9uZyBvcmRlciwgZ2l2aW5nXG4gICAgICAgIC8vIHVzIGEgc2VsZWN0aW9uIGNoYW5nZSBldmVudCBiZWZvcmUgdGhlIERPTSBjaGFuZ2VzIGFyZVxuICAgICAgICAvLyByZXBvcnRlZC5cbiAgICAgICAgLy8gQ2hyb21lIEFuZHJvaWQgaGFzIGEgc2ltaWxhciBpc3N1ZSB3aGVuIGJhY2tzcGFjaW5nIG91dCBhXG4gICAgICAgIC8vIHNlbGVjdGlvbiAoIzY0NSkuXG4gICAgICAgIGlmICgoYnJvd3Nlci5pZSAmJiBicm93c2VyLmllX3ZlcnNpb24gPD0gMTEgfHwgYnJvd3Nlci5hbmRyb2lkICYmIGJyb3dzZXIuY2hyb21lKSAmJiAhdmlldy5zdGF0ZS5zZWxlY3Rpb24ubWFpbi5lbXB0eSAmJlxuICAgICAgICAgICAgLy8gKFNlbGVjdGlvbi5pc0NvbGxhcHNlZCBpc24ndCByZWxpYWJsZSBvbiBJRSlcbiAgICAgICAgICAgIHNlbC5mb2N1c05vZGUgJiYgaXNFcXVpdmFsZW50UG9zaXRpb24oc2VsLmZvY3VzTm9kZSwgc2VsLmZvY3VzT2Zmc2V0LCBzZWwuYW5jaG9yTm9kZSwgc2VsLmFuY2hvck9mZnNldCkpXG4gICAgICAgICAgICB0aGlzLmZsdXNoU29vbigpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLmZsdXNoKGZhbHNlKTtcbiAgICB9XG4gICAgcmVhZFNlbGVjdGlvblJhbmdlKCkge1xuICAgICAgICBsZXQgeyB2aWV3IH0gPSB0aGlzO1xuICAgICAgICAvLyBUaGUgU2VsZWN0aW9uIG9iamVjdCBpcyBicm9rZW4gaW4gc2hhZG93IHJvb3RzIGluIFNhZmFyaS4gU2VlXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jb2RlbWlycm9yL2Rldi9pc3N1ZXMvNDE0XG4gICAgICAgIGxldCByYW5nZSA9IGJyb3dzZXIuc2FmYXJpICYmIHZpZXcucm9vdC5ub2RlVHlwZSA9PSAxMSAmJlxuICAgICAgICAgICAgZGVlcEFjdGl2ZUVsZW1lbnQodGhpcy5kb20ub3duZXJEb2N1bWVudCkgPT0gdGhpcy5kb20gJiZcbiAgICAgICAgICAgIHNhZmFyaVNlbGVjdGlvblJhbmdlSGFjayh0aGlzLnZpZXcpIHx8IGdldFNlbGVjdGlvbih2aWV3LnJvb3QpO1xuICAgICAgICBpZiAoIXJhbmdlIHx8IHRoaXMuc2VsZWN0aW9uUmFuZ2UuZXEocmFuZ2UpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgbG9jYWwgPSBoYXNTZWxlY3Rpb24odGhpcy5kb20sIHJhbmdlKTtcbiAgICAgICAgLy8gRGV0ZWN0IHRoZSBzaXR1YXRpb24gd2hlcmUgdGhlIGJyb3dzZXIgaGFzLCBvbiBmb2N1cywgbW92ZWQgdGhlXG4gICAgICAgIC8vIHNlbGVjdGlvbiB0byB0aGUgc3RhcnQgb2YgdGhlIGNvbnRlbnQgZWxlbWVudC4gUmVzZXQgaXQgdG8gdGhlXG4gICAgICAgIC8vIHBvc2l0aW9uIGZyb20gdGhlIGVkaXRvciBzdGF0ZS5cbiAgICAgICAgaWYgKGxvY2FsICYmICF0aGlzLnNlbGVjdGlvbkNoYW5nZWQgJiZcbiAgICAgICAgICAgIHZpZXcuaW5wdXRTdGF0ZS5sYXN0Rm9jdXNUaW1lID4gRGF0ZS5ub3coKSAtIDIwMCAmJlxuICAgICAgICAgICAgdmlldy5pbnB1dFN0YXRlLmxhc3RUb3VjaFRpbWUgPCBEYXRlLm5vdygpIC0gMzAwICYmXG4gICAgICAgICAgICBhdEVsZW1lbnRTdGFydCh0aGlzLmRvbSwgcmFuZ2UpKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXcuaW5wdXRTdGF0ZS5sYXN0Rm9jdXNUaW1lID0gMDtcbiAgICAgICAgICAgIHZpZXcuZG9jVmlldy51cGRhdGVTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlbGVjdGlvblJhbmdlLnNldFJhbmdlKHJhbmdlKTtcbiAgICAgICAgaWYgKGxvY2FsKVxuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25DaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHNldFNlbGVjdGlvblJhbmdlKGFuY2hvciwgaGVhZCkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvblJhbmdlLnNldChhbmNob3Iubm9kZSwgYW5jaG9yLm9mZnNldCwgaGVhZC5ub2RlLCBoZWFkLm9mZnNldCk7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uQ2hhbmdlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBjbGVhclNlbGVjdGlvblJhbmdlKCkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvblJhbmdlLnNldChudWxsLCAwLCBudWxsLCAwKTtcbiAgICB9XG4gICAgbGlzdGVuRm9yU2Nyb2xsKCkge1xuICAgICAgICB0aGlzLnBhcmVudENoZWNrID0gLTE7XG4gICAgICAgIGxldCBpID0gMCwgY2hhbmdlZCA9IG51bGw7XG4gICAgICAgIGZvciAobGV0IGRvbSA9IHRoaXMuZG9tOyBkb207KSB7XG4gICAgICAgICAgICBpZiAoZG9tLm5vZGVUeXBlID09IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNoYW5nZWQgJiYgaSA8IHRoaXMuc2Nyb2xsVGFyZ2V0cy5sZW5ndGggJiYgdGhpcy5zY3JvbGxUYXJnZXRzW2ldID09IGRvbSlcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFjaGFuZ2VkKVxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkID0gdGhpcy5zY3JvbGxUYXJnZXRzLnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgICAgIGlmIChjaGFuZ2VkKVxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkLnB1c2goZG9tKTtcbiAgICAgICAgICAgICAgICBkb20gPSBkb20uYXNzaWduZWRTbG90IHx8IGRvbS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZG9tLm5vZGVUeXBlID09IDExKSB7IC8vIFNoYWRvdyByb290XG4gICAgICAgICAgICAgICAgZG9tID0gZG9tLmhvc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA8IHRoaXMuc2Nyb2xsVGFyZ2V0cy5sZW5ndGggJiYgIWNoYW5nZWQpXG4gICAgICAgICAgICBjaGFuZ2VkID0gdGhpcy5zY3JvbGxUYXJnZXRzLnNsaWNlKDAsIGkpO1xuICAgICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICAgICAgZm9yIChsZXQgZG9tIG9mIHRoaXMuc2Nyb2xsVGFyZ2V0cylcbiAgICAgICAgICAgICAgICBkb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCB0aGlzLm9uU2Nyb2xsKTtcbiAgICAgICAgICAgIGZvciAobGV0IGRvbSBvZiB0aGlzLnNjcm9sbFRhcmdldHMgPSBjaGFuZ2VkKVxuICAgICAgICAgICAgICAgIGRvbS5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHRoaXMub25TY3JvbGwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlnbm9yZShmKSB7XG4gICAgICAgIGlmICghdGhpcy5hY3RpdmUpXG4gICAgICAgICAgICByZXR1cm4gZigpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgICAgICByZXR1cm4gZigpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy5zdGFydCgpO1xuICAgICAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXJ0KCkge1xuICAgICAgICBpZiAodGhpcy5hY3RpdmUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLmRvbSwgb2JzZXJ2ZU9wdGlvbnMpO1xuICAgICAgICBpZiAodXNlQ2hhckRhdGEpXG4gICAgICAgICAgICB0aGlzLmRvbS5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ2hhcmFjdGVyRGF0YU1vZGlmaWVkXCIsIHRoaXMub25DaGFyRGF0YSk7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgICB9XG4gICAgc3RvcCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgIGlmICh1c2VDaGFyRGF0YSlcbiAgICAgICAgICAgIHRoaXMuZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJET01DaGFyYWN0ZXJEYXRhTW9kaWZpZWRcIiwgdGhpcy5vbkNoYXJEYXRhKTtcbiAgICB9XG4gICAgLy8gVGhyb3cgYXdheSBhbnkgcGVuZGluZyBjaGFuZ2VzXG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHRoaXMucHJvY2Vzc1JlY29yZHMoKTtcbiAgICAgICAgdGhpcy5xdWV1ZS5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkNoYW5nZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgLy8gQ2hyb21lIEFuZHJvaWQsIGVzcGVjaWFsbHkgaW4gY29tYmluYXRpb24gd2l0aCBHQm9hcmQsIG5vdCBvbmx5XG4gICAgLy8gZG9lc24ndCByZWxpYWJseSBmaXJlIHJlZ3VsYXIga2V5IGV2ZW50cywgYnV0IGFsc28gb2Z0ZW5cbiAgICAvLyBzdXJyb3VuZHMgdGhlIGVmZmVjdCBvZiBlbnRlciBvciBiYWNrc3BhY2Ugd2l0aCBhIGJ1bmNoIG9mXG4gICAgLy8gY29tcG9zaXRpb24gZXZlbnRzIHRoYXQsIHdoZW4gaW50ZXJydXB0ZWQsIGNhdXNlIHRleHQgZHVwbGljYXRpb25cbiAgICAvLyBvciBvdGhlciBraW5kcyBvZiBjb3JydXB0aW9uLiBUaGlzIGhhY2sgbWFrZXMgdGhlIGVkaXRvciBiYWNrIG9mZlxuICAgIC8vIGZyb20gaGFuZGxpbmcgRE9NIGNoYW5nZXMgZm9yIGEgbW9tZW50IHdoZW4gc3VjaCBhIGtleSBpc1xuICAgIC8vIGRldGVjdGVkICh2aWEgYmVmb3JlaW5wdXQgb3Iga2V5ZG93biksIGFuZCB0aGVuIHRyaWVzIHRvIGZsdXNoXG4gICAgLy8gdGhlbSBvciwgaWYgdGhhdCBoYXMgbm8gZWZmZWN0LCBkaXNwYXRjaGVzIHRoZSBnaXZlbiBrZXkuXG4gICAgZGVsYXlBbmRyb2lkS2V5KGtleSwga2V5Q29kZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICghdGhpcy5kZWxheWVkQW5kcm9pZEtleSkge1xuICAgICAgICAgICAgbGV0IGZsdXNoID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBrZXkgPSB0aGlzLmRlbGF5ZWRBbmRyb2lkS2V5O1xuICAgICAgICAgICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGVhckRlbGF5ZWRBbmRyb2lkS2V5KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlldy5pbnB1dFN0YXRlLmxhc3RLZXlDb2RlID0ga2V5LmtleUNvZGU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlldy5pbnB1dFN0YXRlLmxhc3RLZXlUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZsdXNoZWQgPSB0aGlzLmZsdXNoKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZmx1c2hlZCAmJiBrZXkuZm9yY2UpXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaEtleSh0aGlzLmRvbSwga2V5LmtleSwga2V5LmtleUNvZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLmZsdXNoaW5nQW5kcm9pZEtleSA9IHRoaXMudmlldy53aW4ucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZsdXNoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTaW5jZSBiYWNrc3BhY2UgYmVmb3JlaW5wdXQgaXMgc29tZXRpbWVzIHNpZ25hbGxlZCBzcHVyaW91c2x5LFxuICAgICAgICAvLyBFbnRlciBhbHdheXMgdGFrZXMgcHJlY2VkZW5jZS5cbiAgICAgICAgaWYgKCF0aGlzLmRlbGF5ZWRBbmRyb2lkS2V5IHx8IGtleSA9PSBcIkVudGVyXCIpXG4gICAgICAgICAgICB0aGlzLmRlbGF5ZWRBbmRyb2lkS2V5ID0ge1xuICAgICAgICAgICAgICAgIGtleSwga2V5Q29kZSxcbiAgICAgICAgICAgICAgICAvLyBPbmx5IHJ1biB0aGUga2V5IGhhbmRsZXIgd2hlbiBubyBjaGFuZ2VzIGFyZSBkZXRlY3RlZCBpZlxuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXNuJ3QgY29taW5nIHJpZ2h0IGFmdGVyIGFub3RoZXIgY2hhbmdlLCBpbiB3aGljaCBjYXNlXG4gICAgICAgICAgICAgICAgLy8gaXQgaXMgcHJvYmFibHkgcGFydCBvZiBhIHdlaXJkIGNoYWluIG9mIHVwZGF0ZXMsIGFuZCBzaG91bGRcbiAgICAgICAgICAgICAgICAvLyBiZSBpZ25vcmVkIGlmIGl0IHJldHVybnMgdGhlIERPTSB0byBpdHMgcHJldmlvdXMgc3RhdGUuXG4gICAgICAgICAgICAgICAgZm9yY2U6IHRoaXMubGFzdENoYW5nZSA8IERhdGUubm93KCkgLSA1MCB8fCAhISgoX2EgPSB0aGlzLmRlbGF5ZWRBbmRyb2lkS2V5KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZm9yY2UpXG4gICAgICAgICAgICB9O1xuICAgIH1cbiAgICBjbGVhckRlbGF5ZWRBbmRyb2lkS2V5KCkge1xuICAgICAgICB0aGlzLndpbi5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmZsdXNoaW5nQW5kcm9pZEtleSk7XG4gICAgICAgIHRoaXMuZGVsYXllZEFuZHJvaWRLZXkgPSBudWxsO1xuICAgICAgICB0aGlzLmZsdXNoaW5nQW5kcm9pZEtleSA9IC0xO1xuICAgIH1cbiAgICBmbHVzaFNvb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmRlbGF5ZWRGbHVzaCA8IDApXG4gICAgICAgICAgICB0aGlzLmRlbGF5ZWRGbHVzaCA9IHRoaXMudmlldy53aW4ucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHsgdGhpcy5kZWxheWVkRmx1c2ggPSAtMTsgdGhpcy5mbHVzaCgpOyB9KTtcbiAgICB9XG4gICAgZm9yY2VGbHVzaCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVsYXllZEZsdXNoID49IDApIHtcbiAgICAgICAgICAgIHRoaXMudmlldy53aW4uY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5kZWxheWVkRmx1c2gpO1xuICAgICAgICAgICAgdGhpcy5kZWxheWVkRmx1c2ggPSAtMTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZsdXNoKCk7XG4gICAgfVxuICAgIHBlbmRpbmdSZWNvcmRzKCkge1xuICAgICAgICBmb3IgKGxldCBtdXQgb2YgdGhpcy5vYnNlcnZlci50YWtlUmVjb3JkcygpKVxuICAgICAgICAgICAgdGhpcy5xdWV1ZS5wdXNoKG11dCk7XG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXVlO1xuICAgIH1cbiAgICBwcm9jZXNzUmVjb3JkcygpIHtcbiAgICAgICAgbGV0IHJlY29yZHMgPSB0aGlzLnBlbmRpbmdSZWNvcmRzKCk7XG4gICAgICAgIGlmIChyZWNvcmRzLmxlbmd0aClcbiAgICAgICAgICAgIHRoaXMucXVldWUgPSBbXTtcbiAgICAgICAgbGV0IGZyb20gPSAtMSwgdG8gPSAtMSwgdHlwZU92ZXIgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgcmVjb3JkIG9mIHJlY29yZHMpIHtcbiAgICAgICAgICAgIGxldCByYW5nZSA9IHRoaXMucmVhZE11dGF0aW9uKHJlY29yZCk7XG4gICAgICAgICAgICBpZiAoIXJhbmdlKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKHJhbmdlLnR5cGVPdmVyKVxuICAgICAgICAgICAgICAgIHR5cGVPdmVyID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChmcm9tID09IC0xKSB7XG4gICAgICAgICAgICAgICAgKHsgZnJvbSwgdG8gfSA9IHJhbmdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZyb20gPSBNYXRoLm1pbihyYW5nZS5mcm9tLCBmcm9tKTtcbiAgICAgICAgICAgICAgICB0byA9IE1hdGgubWF4KHJhbmdlLnRvLCB0byk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZnJvbSwgdG8sIHR5cGVPdmVyIH07XG4gICAgfVxuICAgIHJlYWRDaGFuZ2UoKSB7XG4gICAgICAgIGxldCB7IGZyb20sIHRvLCB0eXBlT3ZlciB9ID0gdGhpcy5wcm9jZXNzUmVjb3JkcygpO1xuICAgICAgICBsZXQgbmV3U2VsID0gdGhpcy5zZWxlY3Rpb25DaGFuZ2VkICYmIGhhc1NlbGVjdGlvbih0aGlzLmRvbSwgdGhpcy5zZWxlY3Rpb25SYW5nZSk7XG4gICAgICAgIGlmIChmcm9tIDwgMCAmJiAhbmV3U2VsKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmIChmcm9tID4gLTEpXG4gICAgICAgICAgICB0aGlzLmxhc3RDaGFuZ2UgPSBEYXRlLm5vdygpO1xuICAgICAgICB0aGlzLnZpZXcuaW5wdXRTdGF0ZS5sYXN0Rm9jdXNUaW1lID0gMDtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25DaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgIGxldCBjaGFuZ2UgPSBuZXcgRE9NQ2hhbmdlKHRoaXMudmlldywgZnJvbSwgdG8sIHR5cGVPdmVyKTtcbiAgICAgICAgdGhpcy52aWV3LmRvY1ZpZXcuZG9tQ2hhbmdlZCA9IHsgbmV3U2VsOiBjaGFuZ2UubmV3U2VsID8gY2hhbmdlLm5ld1NlbC5tYWluIDogbnVsbCB9O1xuICAgICAgICByZXR1cm4gY2hhbmdlO1xuICAgIH1cbiAgICAvLyBBcHBseSBwZW5kaW5nIGNoYW5nZXMsIGlmIGFueVxuICAgIGZsdXNoKHJlYWRTZWxlY3Rpb24gPSB0cnVlKSB7XG4gICAgICAgIC8vIENvbXBsZXRlbHkgaG9sZCBvZmYgZmx1c2hpbmcgd2hlbiBwZW5kaW5nIGtleXMgYXJlIHNldOKAlHRoZSBjb2RlXG4gICAgICAgIC8vIG1hbmFnaW5nIHRob3NlIHdpbGwgbWFrZSBzdXJlIHByb2Nlc3NSZWNvcmRzIGlzIGNhbGxlZCBhbmQgdGhlXG4gICAgICAgIC8vIHZpZXcgaXMgcmVzeW5jaHJvbml6ZWQgYWZ0ZXJcbiAgICAgICAgaWYgKHRoaXMuZGVsYXllZEZsdXNoID49IDAgfHwgdGhpcy5kZWxheWVkQW5kcm9pZEtleSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHJlYWRTZWxlY3Rpb24pXG4gICAgICAgICAgICB0aGlzLnJlYWRTZWxlY3Rpb25SYW5nZSgpO1xuICAgICAgICBsZXQgZG9tQ2hhbmdlID0gdGhpcy5yZWFkQ2hhbmdlKCk7XG4gICAgICAgIGlmICghZG9tQ2hhbmdlKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXcucmVxdWVzdE1lYXN1cmUoKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RhcnRTdGF0ZSA9IHRoaXMudmlldy5zdGF0ZTtcbiAgICAgICAgbGV0IGhhbmRsZWQgPSBhcHBseURPTUNoYW5nZSh0aGlzLnZpZXcsIGRvbUNoYW5nZSk7XG4gICAgICAgIC8vIFRoZSB2aWV3IHdhc24ndCB1cGRhdGVkXG4gICAgICAgIGlmICh0aGlzLnZpZXcuc3RhdGUgPT0gc3RhcnRTdGF0ZSlcbiAgICAgICAgICAgIHRoaXMudmlldy51cGRhdGUoW10pO1xuICAgICAgICByZXR1cm4gaGFuZGxlZDtcbiAgICB9XG4gICAgcmVhZE11dGF0aW9uKHJlYykge1xuICAgICAgICBsZXQgY1ZpZXcgPSB0aGlzLnZpZXcuZG9jVmlldy5uZWFyZXN0KHJlYy50YXJnZXQpO1xuICAgICAgICBpZiAoIWNWaWV3IHx8IGNWaWV3Lmlnbm9yZU11dGF0aW9uKHJlYykpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgY1ZpZXcubWFya0RpcnR5KHJlYy50eXBlID09IFwiYXR0cmlidXRlc1wiKTtcbiAgICAgICAgaWYgKHJlYy50eXBlID09IFwiYXR0cmlidXRlc1wiKVxuICAgICAgICAgICAgY1ZpZXcuZmxhZ3MgfD0gNCAvKiBWaWV3RmxhZy5BdHRyc0RpcnR5ICovO1xuICAgICAgICBpZiAocmVjLnR5cGUgPT0gXCJjaGlsZExpc3RcIikge1xuICAgICAgICAgICAgbGV0IGNoaWxkQmVmb3JlID0gZmluZENoaWxkKGNWaWV3LCByZWMucHJldmlvdXNTaWJsaW5nIHx8IHJlYy50YXJnZXQucHJldmlvdXNTaWJsaW5nLCAtMSk7XG4gICAgICAgICAgICBsZXQgY2hpbGRBZnRlciA9IGZpbmRDaGlsZChjVmlldywgcmVjLm5leHRTaWJsaW5nIHx8IHJlYy50YXJnZXQubmV4dFNpYmxpbmcsIDEpO1xuICAgICAgICAgICAgcmV0dXJuIHsgZnJvbTogY2hpbGRCZWZvcmUgPyBjVmlldy5wb3NBZnRlcihjaGlsZEJlZm9yZSkgOiBjVmlldy5wb3NBdFN0YXJ0LFxuICAgICAgICAgICAgICAgIHRvOiBjaGlsZEFmdGVyID8gY1ZpZXcucG9zQmVmb3JlKGNoaWxkQWZ0ZXIpIDogY1ZpZXcucG9zQXRFbmQsIHR5cGVPdmVyOiBmYWxzZSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlYy50eXBlID09IFwiY2hhcmFjdGVyRGF0YVwiKSB7XG4gICAgICAgICAgICByZXR1cm4geyBmcm9tOiBjVmlldy5wb3NBdFN0YXJ0LCB0bzogY1ZpZXcucG9zQXRFbmQsIHR5cGVPdmVyOiByZWMudGFyZ2V0Lm5vZGVWYWx1ZSA9PSByZWMub2xkVmFsdWUgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldFdpbmRvdyh3aW4pIHtcbiAgICAgICAgaWYgKHdpbiAhPSB0aGlzLndpbikge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVXaW5kb3dMaXN0ZW5lcnModGhpcy53aW4pO1xuICAgICAgICAgICAgdGhpcy53aW4gPSB3aW47XG4gICAgICAgICAgICB0aGlzLmFkZFdpbmRvd0xpc3RlbmVycyh0aGlzLndpbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkV2luZG93TGlzdGVuZXJzKHdpbikge1xuICAgICAgICB3aW4uYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLm9uUmVzaXplKTtcbiAgICAgICAgd2luLmFkZEV2ZW50TGlzdGVuZXIoXCJiZWZvcmVwcmludFwiLCB0aGlzLm9uUHJpbnQpO1xuICAgICAgICB3aW4uYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCB0aGlzLm9uU2Nyb2xsKTtcbiAgICAgICAgd2luLmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJzZWxlY3Rpb25jaGFuZ2VcIiwgdGhpcy5vblNlbGVjdGlvbkNoYW5nZSk7XG4gICAgfVxuICAgIHJlbW92ZVdpbmRvd0xpc3RlbmVycyh3aW4pIHtcbiAgICAgICAgd2luLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgdGhpcy5vblNjcm9sbCk7XG4gICAgICAgIHdpbi5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMub25SZXNpemUpO1xuICAgICAgICB3aW4ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImJlZm9yZXByaW50XCIsIHRoaXMub25QcmludCk7XG4gICAgICAgIHdpbi5kb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwic2VsZWN0aW9uY2hhbmdlXCIsIHRoaXMub25TZWxlY3Rpb25DaGFuZ2UpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgIChfYSA9IHRoaXMuaW50ZXJzZWN0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGlzY29ubmVjdCgpO1xuICAgICAgICAoX2IgPSB0aGlzLmdhcEludGVyc2VjdGlvbikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgKF9jID0gdGhpcy5yZXNpemVTY3JvbGwpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5kaXNjb25uZWN0KCk7XG4gICAgICAgIGZvciAobGV0IGRvbSBvZiB0aGlzLnNjcm9sbFRhcmdldHMpXG4gICAgICAgICAgICBkb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCB0aGlzLm9uU2Nyb2xsKTtcbiAgICAgICAgdGhpcy5yZW1vdmVXaW5kb3dMaXN0ZW5lcnModGhpcy53aW4pO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5wYXJlbnRDaGVjayk7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnJlc2l6ZVRpbWVvdXQpO1xuICAgICAgICB0aGlzLndpbi5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmRlbGF5ZWRGbHVzaCk7XG4gICAgICAgIHRoaXMud2luLmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuZmx1c2hpbmdBbmRyb2lkS2V5KTtcbiAgICB9XG59XG5mdW5jdGlvbiBmaW5kQ2hpbGQoY1ZpZXcsIGRvbSwgZGlyKSB7XG4gICAgd2hpbGUgKGRvbSkge1xuICAgICAgICBsZXQgY3VyVmlldyA9IENvbnRlbnRWaWV3LmdldChkb20pO1xuICAgICAgICBpZiAoY3VyVmlldyAmJiBjdXJWaWV3LnBhcmVudCA9PSBjVmlldylcbiAgICAgICAgICAgIHJldHVybiBjdXJWaWV3O1xuICAgICAgICBsZXQgcGFyZW50ID0gZG9tLnBhcmVudE5vZGU7XG4gICAgICAgIGRvbSA9IHBhcmVudCAhPSBjVmlldy5kb20gPyBwYXJlbnQgOiBkaXIgPiAwID8gZG9tLm5leHRTaWJsaW5nIDogZG9tLnByZXZpb3VzU2libGluZztcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG4vLyBVc2VkIHRvIHdvcmsgYXJvdW5kIGEgU2FmYXJpIFNlbGVjdGlvbi9zaGFkb3cgRE9NIGJ1ZyAoIzQxNClcbmZ1bmN0aW9uIHNhZmFyaVNlbGVjdGlvblJhbmdlSGFjayh2aWV3KSB7XG4gICAgbGV0IGZvdW5kID0gbnVsbDtcbiAgICAvLyBCZWNhdXNlIFNhZmFyaSAoYXQgbGVhc3QgaW4gMjAxOC0yMDIxKSBkb2Vzbid0IHByb3ZpZGUgcmVndWxhclxuICAgIC8vIGFjY2VzcyB0byB0aGUgc2VsZWN0aW9uIGluc2lkZSBhIHNoYWRvd3Jvb3QsIHdlIGhhdmUgdG8gcGVyZm9ybSBhXG4gICAgLy8gcmlkaWN1bG91cyBoYWNrIHRvIGdldCBhdCBpdOKAlHVzaW5nIGBleGVjQ29tbWFuZGAgdG8gdHJpZ2dlciBhXG4gICAgLy8gYGJlZm9yZUlucHV0YCBldmVudCBzbyB0aGF0IHdlIGNhbiByZWFkIHRoZSB0YXJnZXQgcmFuZ2UgZnJvbSB0aGVcbiAgICAvLyBldmVudC5cbiAgICBmdW5jdGlvbiByZWFkKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICBmb3VuZCA9IGV2ZW50LmdldFRhcmdldFJhbmdlcygpWzBdO1xuICAgIH1cbiAgICB2aWV3LmNvbnRlbnRET00uYWRkRXZlbnRMaXN0ZW5lcihcImJlZm9yZWlucHV0XCIsIHJlYWQsIHRydWUpO1xuICAgIHZpZXcuZG9tLm93bmVyRG9jdW1lbnQuZXhlY0NvbW1hbmQoXCJpbmRlbnRcIik7XG4gICAgdmlldy5jb250ZW50RE9NLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJiZWZvcmVpbnB1dFwiLCByZWFkLCB0cnVlKTtcbiAgICBpZiAoIWZvdW5kKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgYW5jaG9yTm9kZSA9IGZvdW5kLnN0YXJ0Q29udGFpbmVyLCBhbmNob3JPZmZzZXQgPSBmb3VuZC5zdGFydE9mZnNldDtcbiAgICBsZXQgZm9jdXNOb2RlID0gZm91bmQuZW5kQ29udGFpbmVyLCBmb2N1c09mZnNldCA9IGZvdW5kLmVuZE9mZnNldDtcbiAgICBsZXQgY3VyQW5jaG9yID0gdmlldy5kb2NWaWV3LmRvbUF0UG9zKHZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW4uYW5jaG9yKTtcbiAgICAvLyBTaW5jZSBzdWNoIGEgcmFuZ2UgZG9lc24ndCBkaXN0aW5ndWlzaCBiZXR3ZWVuIGFuY2hvciBhbmQgaGVhZCxcbiAgICAvLyB1c2UgYSBoZXVyaXN0aWMgdGhhdCBmbGlwcyBpdCBhcm91bmQgaWYgaXRzIGVuZCBtYXRjaGVzIHRoZVxuICAgIC8vIGN1cnJlbnQgYW5jaG9yLlxuICAgIGlmIChpc0VxdWl2YWxlbnRQb3NpdGlvbihjdXJBbmNob3Iubm9kZSwgY3VyQW5jaG9yLm9mZnNldCwgZm9jdXNOb2RlLCBmb2N1c09mZnNldCkpXG4gICAgICAgIFthbmNob3JOb2RlLCBhbmNob3JPZmZzZXQsIGZvY3VzTm9kZSwgZm9jdXNPZmZzZXRdID0gW2ZvY3VzTm9kZSwgZm9jdXNPZmZzZXQsIGFuY2hvck5vZGUsIGFuY2hvck9mZnNldF07XG4gICAgcmV0dXJuIHsgYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0LCBmb2N1c05vZGUsIGZvY3VzT2Zmc2V0IH07XG59XG5cbi8vIFRoZSBlZGl0b3IncyB1cGRhdGUgc3RhdGUgbWFjaGluZSBsb29rcyBzb21ldGhpbmcgbGlrZSB0aGlzOlxuLy9cbi8vICAgICBJZGxlIOKGkiBVcGRhdGluZyDih4YgSWRsZSAodW5jaGVja2VkKSDihpIgTWVhc3VyaW5nIOKGkiBJZGxlXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4oaRICAgICAg4oaTXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVXBkYXRpbmcgKG1lYXN1cmUpXG4vL1xuLy8gVGhlIGRpZmZlcmVuY2UgYmV0d2VlbiAnSWRsZScgYW5kICdJZGxlICh1bmNoZWNrZWQpJyBsaWVzIGluXG4vLyB3aGV0aGVyIGEgbGF5b3V0IGNoZWNrIGhhcyBiZWVuIHNjaGVkdWxlZC4gQSByZWd1bGFyIHVwZGF0ZSB0aHJvdWdoXG4vLyB0aGUgYHVwZGF0ZWAgbWV0aG9kIHVwZGF0ZXMgdGhlIERPTSBpbiBhIHdyaXRlLW9ubHkgZmFzaGlvbiwgYW5kXG4vLyByZWxpZXMgb24gYSBjaGVjayAoc2NoZWR1bGVkIHdpdGggYHJlcXVlc3RBbmltYXRpb25GcmFtZWApIHRvIG1ha2Vcbi8vIHN1cmUgZXZlcnl0aGluZyBpcyB3aGVyZSBpdCBzaG91bGQgYmUgYW5kIHRoZSB2aWV3cG9ydCBjb3ZlcnMgdGhlXG4vLyB2aXNpYmxlIGNvZGUuIFRoYXQgY2hlY2sgY29udGludWVzIHRvIG1lYXN1cmUgYW5kIHRoZW4gb3B0aW9uYWxseVxuLy8gdXBkYXRlIHVudGlsIGl0IHJlYWNoZXMgYSBjb2hlcmVudCBzdGF0ZS5cbi8qKlxuQW4gZWRpdG9yIHZpZXcgcmVwcmVzZW50cyB0aGUgZWRpdG9yJ3MgdXNlciBpbnRlcmZhY2UuIEl0IGhvbGRzXG50aGUgZWRpdGFibGUgRE9NIHN1cmZhY2UsIGFuZCBwb3NzaWJseSBvdGhlciBlbGVtZW50cyBzdWNoIGFzIHRoZVxubGluZSBudW1iZXIgZ3V0dGVyLiBJdCBoYW5kbGVzIGV2ZW50cyBhbmQgZGlzcGF0Y2hlcyBzdGF0ZVxudHJhbnNhY3Rpb25zIGZvciBlZGl0aW5nIGFjdGlvbnMuXG4qL1xuY2xhc3MgRWRpdG9yVmlldyB7XG4gICAgLyoqXG4gICAgVGhlIGN1cnJlbnQgZWRpdG9yIHN0YXRlLlxuICAgICovXG4gICAgZ2V0IHN0YXRlKCkgeyByZXR1cm4gdGhpcy52aWV3U3RhdGUuc3RhdGU7IH1cbiAgICAvKipcbiAgICBUbyBiZSBhYmxlIHRvIGRpc3BsYXkgbGFyZ2UgZG9jdW1lbnRzIHdpdGhvdXQgY29uc3VtaW5nIHRvbyBtdWNoXG4gICAgbWVtb3J5IG9yIG92ZXJsb2FkaW5nIHRoZSBicm93c2VyLCBDb2RlTWlycm9yIG9ubHkgZHJhd3MgdGhlXG4gICAgY29kZSB0aGF0IGlzIHZpc2libGUgKHBsdXMgYSBtYXJnaW4gYXJvdW5kIGl0KSB0byB0aGUgRE9NLiBUaGlzXG4gICAgcHJvcGVydHkgdGVsbHMgeW91IHRoZSBleHRlbnQgb2YgdGhlIGN1cnJlbnQgZHJhd24gdmlld3BvcnQsIGluXG4gICAgZG9jdW1lbnQgcG9zaXRpb25zLlxuICAgICovXG4gICAgZ2V0IHZpZXdwb3J0KCkgeyByZXR1cm4gdGhpcy52aWV3U3RhdGUudmlld3BvcnQ7IH1cbiAgICAvKipcbiAgICBXaGVuIHRoZXJlIGFyZSwgZm9yIGV4YW1wbGUsIGxhcmdlIGNvbGxhcHNlZCByYW5nZXMgaW4gdGhlXG4gICAgdmlld3BvcnQsIGl0cyBzaXplIGNhbiBiZSBhIGxvdCBiaWdnZXIgdGhhbiB0aGUgYWN0dWFsIHZpc2libGVcbiAgICBjb250ZW50LiBUaHVzLCBpZiB5b3UgYXJlIGRvaW5nIHNvbWV0aGluZyBsaWtlIHN0eWxpbmcgdGhlXG4gICAgY29udGVudCBpbiB0aGUgdmlld3BvcnQsIGl0IGlzIHByZWZlcmFibGUgdG8gb25seSBkbyBzbyBmb3JcbiAgICB0aGVzZSByYW5nZXMsIHdoaWNoIGFyZSB0aGUgc3Vic2V0IG9mIHRoZSB2aWV3cG9ydCB0aGF0IGlzXG4gICAgYWN0dWFsbHkgZHJhd24uXG4gICAgKi9cbiAgICBnZXQgdmlzaWJsZVJhbmdlcygpIHsgcmV0dXJuIHRoaXMudmlld1N0YXRlLnZpc2libGVSYW5nZXM7IH1cbiAgICAvKipcbiAgICBSZXR1cm5zIGZhbHNlIHdoZW4gdGhlIGVkaXRvciBpcyBlbnRpcmVseSBzY3JvbGxlZCBvdXQgb2Ygdmlld1xuICAgIG9yIG90aGVyd2lzZSBoaWRkZW4uXG4gICAgKi9cbiAgICBnZXQgaW5WaWV3KCkgeyByZXR1cm4gdGhpcy52aWV3U3RhdGUuaW5WaWV3OyB9XG4gICAgLyoqXG4gICAgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHVzZXIgaXMgY3VycmVudGx5IGNvbXBvc2luZyB0ZXh0IHZpYVxuICAgIFtJTUVdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lucHV0X21ldGhvZCksIGFuZCBhdCBsZWFzdFxuICAgIG9uZSBjaGFuZ2UgaGFzIGJlZW4gbWFkZSBpbiB0aGUgY3VycmVudCBjb21wb3NpdGlvbi5cbiAgICAqL1xuICAgIGdldCBjb21wb3NpbmcoKSB7IHJldHVybiB0aGlzLmlucHV0U3RhdGUuY29tcG9zaW5nID4gMDsgfVxuICAgIC8qKlxuICAgIEluZGljYXRlcyB3aGV0aGVyIHRoZSB1c2VyIGlzIGN1cnJlbnRseSBpbiBjb21wb3Npbmcgc3RhdGUuIE5vdGVcbiAgICB0aGF0IG9uIHNvbWUgcGxhdGZvcm1zLCBsaWtlIEFuZHJvaWQsIHRoaXMgd2lsbCBiZSB0aGUgY2FzZSBhXG4gICAgbG90LCBzaW5jZSBqdXN0IHB1dHRpbmcgdGhlIGN1cnNvciBvbiBhIHdvcmQgc3RhcnRzIGFcbiAgICBjb21wb3NpdGlvbiB0aGVyZS5cbiAgICAqL1xuICAgIGdldCBjb21wb3NpdGlvblN0YXJ0ZWQoKSB7IHJldHVybiB0aGlzLmlucHV0U3RhdGUuY29tcG9zaW5nID49IDA7IH1cbiAgICAvKipcbiAgICBUaGUgZG9jdW1lbnQgb3Igc2hhZG93IHJvb3QgdGhhdCB0aGUgdmlldyBsaXZlcyBpbi5cbiAgICAqL1xuICAgIGdldCByb290KCkgeyByZXR1cm4gdGhpcy5fcm9vdDsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZ2V0IHdpbigpIHsgcmV0dXJuIHRoaXMuZG9tLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgfHwgd2luZG93OyB9XG4gICAgLyoqXG4gICAgQ29uc3RydWN0IGEgbmV3IHZpZXcuIFlvdSdsbCB3YW50IHRvIGVpdGhlciBwcm92aWRlIGEgYHBhcmVudGBcbiAgICBvcHRpb24sIG9yIHB1dCBgdmlldy5kb21gIGludG8geW91ciBkb2N1bWVudCBhZnRlciBjcmVhdGluZyBhXG4gICAgdmlldywgc28gdGhhdCB0aGUgdXNlciBjYW4gc2VlIHRoZSBlZGl0b3IuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcgPSB7fSkge1xuICAgICAgICB0aGlzLnBsdWdpbnMgPSBbXTtcbiAgICAgICAgdGhpcy5wbHVnaW5NYXAgPSBuZXcgTWFwO1xuICAgICAgICB0aGlzLmVkaXRvckF0dHJzID0ge307XG4gICAgICAgIHRoaXMuY29udGVudEF0dHJzID0ge307XG4gICAgICAgIHRoaXMuYmlkaUNhY2hlID0gW107XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSA9IDIgLyogVXBkYXRlU3RhdGUuVXBkYXRpbmcgKi87XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tZWFzdXJlU2NoZWR1bGVkID0gLTE7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tZWFzdXJlUmVxdWVzdHMgPSBbXTtcbiAgICAgICAgdGhpcy5jb250ZW50RE9NID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy5zY3JvbGxET00gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLnNjcm9sbERPTS50YWJJbmRleCA9IC0xO1xuICAgICAgICB0aGlzLnNjcm9sbERPTS5jbGFzc05hbWUgPSBcImNtLXNjcm9sbGVyXCI7XG4gICAgICAgIHRoaXMuc2Nyb2xsRE9NLmFwcGVuZENoaWxkKHRoaXMuY29udGVudERPTSk7XG4gICAgICAgIHRoaXMuYW5ub3VuY2VET00gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLmFubm91bmNlRE9NLmNsYXNzTmFtZSA9IFwiY20tYW5ub3VuY2VkXCI7XG4gICAgICAgIHRoaXMuYW5ub3VuY2VET00uc2V0QXR0cmlidXRlKFwiYXJpYS1saXZlXCIsIFwicG9saXRlXCIpO1xuICAgICAgICB0aGlzLmRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMuZG9tLmFwcGVuZENoaWxkKHRoaXMuYW5ub3VuY2VET00pO1xuICAgICAgICB0aGlzLmRvbS5hcHBlbmRDaGlsZCh0aGlzLnNjcm9sbERPTSk7XG4gICAgICAgIGxldCB7IGRpc3BhdGNoIH0gPSBjb25maWc7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hUcmFuc2FjdGlvbnMgPSBjb25maWcuZGlzcGF0Y2hUcmFuc2FjdGlvbnMgfHxcbiAgICAgICAgICAgIChkaXNwYXRjaCAmJiAoKHRycykgPT4gdHJzLmZvckVhY2godHIgPT4gZGlzcGF0Y2godHIsIHRoaXMpKSkpIHx8XG4gICAgICAgICAgICAoKHRycykgPT4gdGhpcy51cGRhdGUodHJzKSk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2ggPSB0aGlzLmRpc3BhdGNoLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuX3Jvb3QgPSAoY29uZmlnLnJvb3QgfHwgZ2V0Um9vdChjb25maWcucGFyZW50KSB8fCBkb2N1bWVudCk7XG4gICAgICAgIHRoaXMudmlld1N0YXRlID0gbmV3IFZpZXdTdGF0ZShjb25maWcuc3RhdGUgfHwgRWRpdG9yU3RhdGUuY3JlYXRlKGNvbmZpZykpO1xuICAgICAgICBpZiAoY29uZmlnLnNjcm9sbFRvICYmIGNvbmZpZy5zY3JvbGxUby5pcyhzY3JvbGxJbnRvVmlldykpXG4gICAgICAgICAgICB0aGlzLnZpZXdTdGF0ZS5zY3JvbGxUYXJnZXQgPSBjb25maWcuc2Nyb2xsVG8udmFsdWUuY2xpcCh0aGlzLnZpZXdTdGF0ZS5zdGF0ZSk7XG4gICAgICAgIHRoaXMucGx1Z2lucyA9IHRoaXMuc3RhdGUuZmFjZXQodmlld1BsdWdpbikubWFwKHNwZWMgPT4gbmV3IFBsdWdpbkluc3RhbmNlKHNwZWMpKTtcbiAgICAgICAgZm9yIChsZXQgcGx1Z2luIG9mIHRoaXMucGx1Z2lucylcbiAgICAgICAgICAgIHBsdWdpbi51cGRhdGUodGhpcyk7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIgPSBuZXcgRE9NT2JzZXJ2ZXIodGhpcyk7XG4gICAgICAgIHRoaXMuaW5wdXRTdGF0ZSA9IG5ldyBJbnB1dFN0YXRlKHRoaXMpO1xuICAgICAgICB0aGlzLmlucHV0U3RhdGUuZW5zdXJlSGFuZGxlcnModGhpcy5wbHVnaW5zKTtcbiAgICAgICAgdGhpcy5kb2NWaWV3ID0gbmV3IERvY1ZpZXcodGhpcyk7XG4gICAgICAgIHRoaXMubW91bnRTdHlsZXMoKTtcbiAgICAgICAgdGhpcy51cGRhdGVBdHRycygpO1xuICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlID0gMCAvKiBVcGRhdGVTdGF0ZS5JZGxlICovO1xuICAgICAgICB0aGlzLnJlcXVlc3RNZWFzdXJlKCk7XG4gICAgICAgIGlmIChjb25maWcucGFyZW50KVxuICAgICAgICAgICAgY29uZmlnLnBhcmVudC5hcHBlbmRDaGlsZCh0aGlzLmRvbSk7XG4gICAgfVxuICAgIGRpc3BhdGNoKC4uLmlucHV0KSB7XG4gICAgICAgIGxldCB0cnMgPSBpbnB1dC5sZW5ndGggPT0gMSAmJiBpbnB1dFswXSBpbnN0YW5jZW9mIFRyYW5zYWN0aW9uID8gaW5wdXRcbiAgICAgICAgICAgIDogaW5wdXQubGVuZ3RoID09IDEgJiYgQXJyYXkuaXNBcnJheShpbnB1dFswXSkgPyBpbnB1dFswXVxuICAgICAgICAgICAgICAgIDogW3RoaXMuc3RhdGUudXBkYXRlKC4uLmlucHV0KV07XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hUcmFuc2FjdGlvbnModHJzLCB0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVXBkYXRlIHRoZSB2aWV3IGZvciB0aGUgZ2l2ZW4gYXJyYXkgb2YgdHJhbnNhY3Rpb25zLiBUaGlzIHdpbGxcbiAgICB1cGRhdGUgdGhlIHZpc2libGUgZG9jdW1lbnQgYW5kIHNlbGVjdGlvbiB0byBtYXRjaCB0aGUgc3RhdGVcbiAgICBwcm9kdWNlZCBieSB0aGUgdHJhbnNhY3Rpb25zLCBhbmQgbm90aWZ5IHZpZXcgcGx1Z2lucyBvZiB0aGVcbiAgICBjaGFuZ2UuIFlvdSBzaG91bGQgdXN1YWxseSBjYWxsXG4gICAgW2BkaXNwYXRjaGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LmRpc3BhdGNoKSBpbnN0ZWFkLCB3aGljaCB1c2VzIHRoaXNcbiAgICBhcyBhIHByaW1pdGl2ZS5cbiAgICAqL1xuICAgIHVwZGF0ZSh0cmFuc2FjdGlvbnMpIHtcbiAgICAgICAgaWYgKHRoaXMudXBkYXRlU3RhdGUgIT0gMCAvKiBVcGRhdGVTdGF0ZS5JZGxlICovKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FsbHMgdG8gRWRpdG9yVmlldy51cGRhdGUgYXJlIG5vdCBhbGxvd2VkIHdoaWxlIGFuIHVwZGF0ZSBpcyBpbiBwcm9ncmVzc1wiKTtcbiAgICAgICAgbGV0IHJlZHJhd24gPSBmYWxzZSwgYXR0cnNDaGFuZ2VkID0gZmFsc2UsIHVwZGF0ZTtcbiAgICAgICAgbGV0IHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgZm9yIChsZXQgdHIgb2YgdHJhbnNhY3Rpb25zKSB7XG4gICAgICAgICAgICBpZiAodHIuc3RhcnRTdGF0ZSAhPSBzdGF0ZSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRyeWluZyB0byB1cGRhdGUgc3RhdGUgd2l0aCBhIHRyYW5zYWN0aW9uIHRoYXQgZG9lc24ndCBzdGFydCBmcm9tIHRoZSBwcmV2aW91cyBzdGF0ZS5cIik7XG4gICAgICAgICAgICBzdGF0ZSA9IHRyLnN0YXRlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgdGhpcy52aWV3U3RhdGUuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZm9jdXMgPSB0aGlzLmhhc0ZvY3VzLCBmb2N1c0ZsYWcgPSAwLCBkaXNwYXRjaEZvY3VzID0gbnVsbDtcbiAgICAgICAgaWYgKHRyYW5zYWN0aW9ucy5zb21lKHRyID0+IHRyLmFubm90YXRpb24oaXNGb2N1c0NoYW5nZSkpKSB7XG4gICAgICAgICAgICB0aGlzLmlucHV0U3RhdGUubm90aWZpZWRGb2N1c2VkID0gZm9jdXM7XG4gICAgICAgICAgICAvLyBJZiBhIGZvY3VzLWNoYW5nZSB0cmFuc2FjdGlvbiBpcyBiZWluZyBkaXNwYXRjaGVkLCBzZXQgdGhpcyB1cGRhdGUgZmxhZy5cbiAgICAgICAgICAgIGZvY3VzRmxhZyA9IDEgLyogVXBkYXRlRmxhZy5Gb2N1cyAqLztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmb2N1cyAhPSB0aGlzLmlucHV0U3RhdGUubm90aWZpZWRGb2N1c2VkKSB7XG4gICAgICAgICAgICB0aGlzLmlucHV0U3RhdGUubm90aWZpZWRGb2N1c2VkID0gZm9jdXM7XG4gICAgICAgICAgICAvLyBTY2hlZHVsZSBhIHNlcGFyYXRlIGZvY3VzIHRyYW5zYWN0aW9uIGlmIG5lY2Vzc2FyeSwgb3RoZXJ3aXNlXG4gICAgICAgICAgICAvLyBhZGQgYSBmbGFnIHRvIHRoaXMgdXBkYXRlXG4gICAgICAgICAgICBkaXNwYXRjaEZvY3VzID0gZm9jdXNDaGFuZ2VUcmFuc2FjdGlvbihzdGF0ZSwgZm9jdXMpO1xuICAgICAgICAgICAgaWYgKCFkaXNwYXRjaEZvY3VzKVxuICAgICAgICAgICAgICAgIGZvY3VzRmxhZyA9IDEgLyogVXBkYXRlRmxhZy5Gb2N1cyAqLztcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGVyZSB3YXMgYSBwZW5kaW5nIERPTSBjaGFuZ2UsIGVhZ2VybHkgcmVhZCBpdCBhbmQgdHJ5IHRvXG4gICAgICAgIC8vIGFwcGx5IGl0IGFmdGVyIHRoZSBnaXZlbiB0cmFuc2FjdGlvbnMuXG4gICAgICAgIGxldCBwZW5kaW5nS2V5ID0gdGhpcy5vYnNlcnZlci5kZWxheWVkQW5kcm9pZEtleSwgZG9tQ2hhbmdlID0gbnVsbDtcbiAgICAgICAgaWYgKHBlbmRpbmdLZXkpIHtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXIuY2xlYXJEZWxheWVkQW5kcm9pZEtleSgpO1xuICAgICAgICAgICAgZG9tQ2hhbmdlID0gdGhpcy5vYnNlcnZlci5yZWFkQ2hhbmdlKCk7XG4gICAgICAgICAgICAvLyBPbmx5IHRyeSB0byBhcHBseSBET00gY2hhbmdlcyBpZiB0aGUgdHJhbnNhY3Rpb25zIGRpZG4ndFxuICAgICAgICAgICAgLy8gY2hhbmdlIHRoZSBkb2Mgb3Igc2VsZWN0aW9uLlxuICAgICAgICAgICAgaWYgKGRvbUNoYW5nZSAmJiAhdGhpcy5zdGF0ZS5kb2MuZXEoc3RhdGUuZG9jKSB8fCAhdGhpcy5zdGF0ZS5zZWxlY3Rpb24uZXEoc3RhdGUuc2VsZWN0aW9uKSlcbiAgICAgICAgICAgICAgICBkb21DaGFuZ2UgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vYnNlcnZlci5jbGVhcigpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdoZW4gdGhlIHBocmFzZXMgY2hhbmdlLCByZWRyYXcgdGhlIGVkaXRvclxuICAgICAgICBpZiAoc3RhdGUuZmFjZXQoRWRpdG9yU3RhdGUucGhyYXNlcykgIT0gdGhpcy5zdGF0ZS5mYWNldChFZGl0b3JTdGF0ZS5waHJhc2VzKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldFN0YXRlKHN0YXRlKTtcbiAgICAgICAgdXBkYXRlID0gVmlld1VwZGF0ZS5jcmVhdGUodGhpcywgc3RhdGUsIHRyYW5zYWN0aW9ucyk7XG4gICAgICAgIHVwZGF0ZS5mbGFncyB8PSBmb2N1c0ZsYWc7XG4gICAgICAgIGxldCBzY3JvbGxUYXJnZXQgPSB0aGlzLnZpZXdTdGF0ZS5zY3JvbGxUYXJnZXQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlID0gMiAvKiBVcGRhdGVTdGF0ZS5VcGRhdGluZyAqLztcbiAgICAgICAgICAgIGZvciAobGV0IHRyIG9mIHRyYW5zYWN0aW9ucykge1xuICAgICAgICAgICAgICAgIGlmIChzY3JvbGxUYXJnZXQpXG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbFRhcmdldCA9IHNjcm9sbFRhcmdldC5tYXAodHIuY2hhbmdlcyk7XG4gICAgICAgICAgICAgICAgaWYgKHRyLnNjcm9sbEludG9WaWV3KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB7IG1haW4gfSA9IHRyLnN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsVGFyZ2V0ID0gbmV3IFNjcm9sbFRhcmdldChtYWluLmVtcHR5ID8gbWFpbiA6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IobWFpbi5oZWFkLCBtYWluLmhlYWQgPiBtYWluLmFuY2hvciA/IC0xIDogMSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBlIG9mIHRyLmVmZmVjdHMpXG4gICAgICAgICAgICAgICAgICAgIGlmIChlLmlzKHNjcm9sbEludG9WaWV3KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbFRhcmdldCA9IGUudmFsdWUuY2xpcCh0aGlzLnN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudmlld1N0YXRlLnVwZGF0ZSh1cGRhdGUsIHNjcm9sbFRhcmdldCk7XG4gICAgICAgICAgICB0aGlzLmJpZGlDYWNoZSA9IENhY2hlZE9yZGVyLnVwZGF0ZSh0aGlzLmJpZGlDYWNoZSwgdXBkYXRlLmNoYW5nZXMpO1xuICAgICAgICAgICAgaWYgKCF1cGRhdGUuZW1wdHkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVBsdWdpbnModXBkYXRlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlucHV0U3RhdGUudXBkYXRlKHVwZGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWRyYXduID0gdGhpcy5kb2NWaWV3LnVwZGF0ZSh1cGRhdGUpO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUuZmFjZXQoc3R5bGVNb2R1bGUpICE9IHRoaXMuc3R5bGVNb2R1bGVzKVxuICAgICAgICAgICAgICAgIHRoaXMubW91bnRTdHlsZXMoKTtcbiAgICAgICAgICAgIGF0dHJzQ2hhbmdlZCA9IHRoaXMudXBkYXRlQXR0cnMoKTtcbiAgICAgICAgICAgIHRoaXMuc2hvd0Fubm91bmNlbWVudHModHJhbnNhY3Rpb25zKTtcbiAgICAgICAgICAgIHRoaXMuZG9jVmlldy51cGRhdGVTZWxlY3Rpb24ocmVkcmF3biwgdHJhbnNhY3Rpb25zLnNvbWUodHIgPT4gdHIuaXNVc2VyRXZlbnQoXCJzZWxlY3QucG9pbnRlclwiKSkpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSA9IDAgLyogVXBkYXRlU3RhdGUuSWRsZSAqLztcbiAgICAgICAgfVxuICAgICAgICBpZiAodXBkYXRlLnN0YXJ0U3RhdGUuZmFjZXQodGhlbWUpICE9IHVwZGF0ZS5zdGF0ZS5mYWNldCh0aGVtZSkpXG4gICAgICAgICAgICB0aGlzLnZpZXdTdGF0ZS5tdXN0TWVhc3VyZUNvbnRlbnQgPSB0cnVlO1xuICAgICAgICBpZiAocmVkcmF3biB8fCBhdHRyc0NoYW5nZWQgfHwgc2Nyb2xsVGFyZ2V0IHx8IHRoaXMudmlld1N0YXRlLm11c3RFbmZvcmNlQ3Vyc29yQXNzb2MgfHwgdGhpcy52aWV3U3RhdGUubXVzdE1lYXN1cmVDb250ZW50KVxuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0TWVhc3VyZSgpO1xuICAgICAgICBpZiAoIXVwZGF0ZS5lbXB0eSlcbiAgICAgICAgICAgIGZvciAobGV0IGxpc3RlbmVyIG9mIHRoaXMuc3RhdGUuZmFjZXQodXBkYXRlTGlzdGVuZXIpKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXIodXBkYXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nRXhjZXB0aW9uKHRoaXMuc3RhdGUsIGUsIFwidXBkYXRlIGxpc3RlbmVyXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgaWYgKGRpc3BhdGNoRm9jdXMgfHwgZG9tQ2hhbmdlKVxuICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGRpc3BhdGNoRm9jdXMgJiYgdGhpcy5zdGF0ZSA9PSBkaXNwYXRjaEZvY3VzLnN0YXJ0U3RhdGUpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goZGlzcGF0Y2hGb2N1cyk7XG4gICAgICAgICAgICAgICAgaWYgKGRvbUNoYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWFwcGx5RE9NQ2hhbmdlKHRoaXMsIGRvbUNoYW5nZSkgJiYgcGVuZGluZ0tleS5mb3JjZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoS2V5KHRoaXMuY29udGVudERPTSwgcGVuZGluZ0tleS5rZXksIHBlbmRpbmdLZXkua2V5Q29kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlc2V0IHRoZSB2aWV3IHRvIHRoZSBnaXZlbiBzdGF0ZS4gKFRoaXMgd2lsbCBjYXVzZSB0aGUgZW50aXJlXG4gICAgZG9jdW1lbnQgdG8gYmUgcmVkcmF3biBhbmQgYWxsIHZpZXcgcGx1Z2lucyB0byBiZSByZWluaXRpYWxpemVkLFxuICAgIHNvIHlvdSBzaG91bGQgcHJvYmFibHkgb25seSB1c2UgaXQgd2hlbiB0aGUgbmV3IHN0YXRlIGlzbid0XG4gICAgZGVyaXZlZCBmcm9tIHRoZSBvbGQgc3RhdGUuIE90aGVyd2lzZSwgdXNlXG4gICAgW2BkaXNwYXRjaGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LmRpc3BhdGNoKSBpbnN0ZWFkLilcbiAgICAqL1xuICAgIHNldFN0YXRlKG5ld1N0YXRlKSB7XG4gICAgICAgIGlmICh0aGlzLnVwZGF0ZVN0YXRlICE9IDAgLyogVXBkYXRlU3RhdGUuSWRsZSAqLylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbGxzIHRvIEVkaXRvclZpZXcuc2V0U3RhdGUgYXJlIG5vdCBhbGxvd2VkIHdoaWxlIGFuIHVwZGF0ZSBpcyBpbiBwcm9ncmVzc1wiKTtcbiAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXdTdGF0ZS5zdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlU3RhdGUgPSAyIC8qIFVwZGF0ZVN0YXRlLlVwZGF0aW5nICovO1xuICAgICAgICBsZXQgaGFkRm9jdXMgPSB0aGlzLmhhc0ZvY3VzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yIChsZXQgcGx1Z2luIG9mIHRoaXMucGx1Z2lucylcbiAgICAgICAgICAgICAgICBwbHVnaW4uZGVzdHJveSh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMudmlld1N0YXRlID0gbmV3IFZpZXdTdGF0ZShuZXdTdGF0ZSk7XG4gICAgICAgICAgICB0aGlzLnBsdWdpbnMgPSBuZXdTdGF0ZS5mYWNldCh2aWV3UGx1Z2luKS5tYXAoc3BlYyA9PiBuZXcgUGx1Z2luSW5zdGFuY2Uoc3BlYykpO1xuICAgICAgICAgICAgdGhpcy5wbHVnaW5NYXAuY2xlYXIoKTtcbiAgICAgICAgICAgIGZvciAobGV0IHBsdWdpbiBvZiB0aGlzLnBsdWdpbnMpXG4gICAgICAgICAgICAgICAgcGx1Z2luLnVwZGF0ZSh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuZG9jVmlldy5kZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLmRvY1ZpZXcgPSBuZXcgRG9jVmlldyh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRTdGF0ZS5lbnN1cmVIYW5kbGVycyh0aGlzLnBsdWdpbnMpO1xuICAgICAgICAgICAgdGhpcy5tb3VudFN0eWxlcygpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVBdHRycygpO1xuICAgICAgICAgICAgdGhpcy5iaWRpQ2FjaGUgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUgPSAwIC8qIFVwZGF0ZVN0YXRlLklkbGUgKi87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhZEZvY3VzKVxuICAgICAgICAgICAgdGhpcy5mb2N1cygpO1xuICAgICAgICB0aGlzLnJlcXVlc3RNZWFzdXJlKCk7XG4gICAgfVxuICAgIHVwZGF0ZVBsdWdpbnModXBkYXRlKSB7XG4gICAgICAgIGxldCBwcmV2U3BlY3MgPSB1cGRhdGUuc3RhcnRTdGF0ZS5mYWNldCh2aWV3UGx1Z2luKSwgc3BlY3MgPSB1cGRhdGUuc3RhdGUuZmFjZXQodmlld1BsdWdpbik7XG4gICAgICAgIGlmIChwcmV2U3BlY3MgIT0gc3BlY3MpIHtcbiAgICAgICAgICAgIGxldCBuZXdQbHVnaW5zID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBzcGVjIG9mIHNwZWNzKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZvdW5kID0gcHJldlNwZWNzLmluZGV4T2Yoc3BlYyk7XG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBuZXdQbHVnaW5zLnB1c2gobmV3IFBsdWdpbkluc3RhbmNlKHNwZWMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwbHVnaW4gPSB0aGlzLnBsdWdpbnNbZm91bmRdO1xuICAgICAgICAgICAgICAgICAgICBwbHVnaW4ubXVzdFVwZGF0ZSA9IHVwZGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgbmV3UGx1Z2lucy5wdXNoKHBsdWdpbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgcGx1Z2luIG9mIHRoaXMucGx1Z2lucylcbiAgICAgICAgICAgICAgICBpZiAocGx1Z2luLm11c3RVcGRhdGUgIT0gdXBkYXRlKVxuICAgICAgICAgICAgICAgICAgICBwbHVnaW4uZGVzdHJveSh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMucGx1Z2lucyA9IG5ld1BsdWdpbnM7XG4gICAgICAgICAgICB0aGlzLnBsdWdpbk1hcC5jbGVhcigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChsZXQgcCBvZiB0aGlzLnBsdWdpbnMpXG4gICAgICAgICAgICAgICAgcC5tdXN0VXBkYXRlID0gdXBkYXRlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5wbHVnaW5zLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgdGhpcy5wbHVnaW5zW2ldLnVwZGF0ZSh0aGlzKTtcbiAgICAgICAgaWYgKHByZXZTcGVjcyAhPSBzcGVjcylcbiAgICAgICAgICAgIHRoaXMuaW5wdXRTdGF0ZS5lbnN1cmVIYW5kbGVycyh0aGlzLnBsdWdpbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIG1lYXN1cmUoZmx1c2ggPSB0cnVlKSB7XG4gICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHRoaXMubWVhc3VyZVNjaGVkdWxlZCA+IC0xKVxuICAgICAgICAgICAgdGhpcy53aW4uY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5tZWFzdXJlU2NoZWR1bGVkKTtcbiAgICAgICAgaWYgKHRoaXMub2JzZXJ2ZXIuZGVsYXllZEFuZHJvaWRLZXkpIHtcbiAgICAgICAgICAgIHRoaXMubWVhc3VyZVNjaGVkdWxlZCA9IC0xO1xuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0TWVhc3VyZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWVhc3VyZVNjaGVkdWxlZCA9IDA7IC8vIFByZXZlbnQgcmVxdWVzdE1lYXN1cmUgY2FsbHMgZnJvbSBzY2hlZHVsaW5nIGFub3RoZXIgYW5pbWF0aW9uIGZyYW1lXG4gICAgICAgIGlmIChmbHVzaClcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXIuZm9yY2VGbHVzaCgpO1xuICAgICAgICBsZXQgdXBkYXRlZCA9IG51bGw7XG4gICAgICAgIGxldCBzRE9NID0gdGhpcy5zY3JvbGxET00sIHNjcm9sbFRvcCA9IHNET00uc2Nyb2xsVG9wICogdGhpcy5zY2FsZVk7XG4gICAgICAgIGxldCB7IHNjcm9sbEFuY2hvclBvcywgc2Nyb2xsQW5jaG9ySGVpZ2h0IH0gPSB0aGlzLnZpZXdTdGF0ZTtcbiAgICAgICAgaWYgKE1hdGguYWJzKHNjcm9sbFRvcCAtIHRoaXMudmlld1N0YXRlLnNjcm9sbFRvcCkgPiAxKVxuICAgICAgICAgICAgc2Nyb2xsQW5jaG9ySGVpZ2h0ID0gLTE7XG4gICAgICAgIHRoaXMudmlld1N0YXRlLnNjcm9sbEFuY2hvckhlaWdodCA9IC0xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7OyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoc2Nyb2xsQW5jaG9ySGVpZ2h0IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNTY3JvbGxlZFRvQm90dG9tKHNET00pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxBbmNob3JQb3MgPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbEFuY2hvckhlaWdodCA9IHRoaXMudmlld1N0YXRlLmhlaWdodE1hcC5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgYmxvY2sgPSB0aGlzLnZpZXdTdGF0ZS5zY3JvbGxBbmNob3JBdChzY3JvbGxUb3ApO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsQW5jaG9yUG9zID0gYmxvY2suZnJvbTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbEFuY2hvckhlaWdodCA9IGJsb2NrLnRvcDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlID0gMSAvKiBVcGRhdGVTdGF0ZS5NZWFzdXJpbmcgKi87XG4gICAgICAgICAgICAgICAgbGV0IGNoYW5nZWQgPSB0aGlzLnZpZXdTdGF0ZS5tZWFzdXJlKHRoaXMpO1xuICAgICAgICAgICAgICAgIGlmICghY2hhbmdlZCAmJiAhdGhpcy5tZWFzdXJlUmVxdWVzdHMubGVuZ3RoICYmIHRoaXMudmlld1N0YXRlLnNjcm9sbFRhcmdldCA9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAoaSA+IDUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKHRoaXMubWVhc3VyZVJlcXVlc3RzLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBcIk1lYXN1cmUgbG9vcCByZXN0YXJ0ZWQgbW9yZSB0aGFuIDUgdGltZXNcIlxuICAgICAgICAgICAgICAgICAgICAgICAgOiBcIlZpZXdwb3J0IGZhaWxlZCB0byBzdGFiaWxpemVcIik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgbWVhc3VyaW5nID0gW107XG4gICAgICAgICAgICAgICAgLy8gT25seSBydW4gbWVhc3VyZSByZXF1ZXN0cyBpbiB0aGlzIGN5Y2xlIHdoZW4gdGhlIHZpZXdwb3J0IGRpZG4ndCBjaGFuZ2VcbiAgICAgICAgICAgICAgICBpZiAoIShjaGFuZ2VkICYgNCAvKiBVcGRhdGVGbGFnLlZpZXdwb3J0ICovKSlcbiAgICAgICAgICAgICAgICAgICAgW3RoaXMubWVhc3VyZVJlcXVlc3RzLCBtZWFzdXJpbmddID0gW21lYXN1cmluZywgdGhpcy5tZWFzdXJlUmVxdWVzdHNdO1xuICAgICAgICAgICAgICAgIGxldCBtZWFzdXJlZCA9IG1lYXN1cmluZy5tYXAobSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbS5yZWFkKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dFeGNlcHRpb24odGhpcy5zdGF0ZSwgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gQmFkTWVhc3VyZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGxldCB1cGRhdGUgPSBWaWV3VXBkYXRlLmNyZWF0ZSh0aGlzLCB0aGlzLnN0YXRlLCBbXSksIHJlZHJhd24gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB1cGRhdGUuZmxhZ3MgfD0gY2hhbmdlZDtcbiAgICAgICAgICAgICAgICBpZiAoIXVwZGF0ZWQpXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZWQgPSB1cGRhdGU7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVkLmZsYWdzIHw9IGNoYW5nZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSA9IDIgLyogVXBkYXRlU3RhdGUuVXBkYXRpbmcgKi87XG4gICAgICAgICAgICAgICAgaWYgKCF1cGRhdGUuZW1wdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVQbHVnaW5zKHVwZGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRTdGF0ZS51cGRhdGUodXBkYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVBdHRycygpO1xuICAgICAgICAgICAgICAgICAgICByZWRyYXduID0gdGhpcy5kb2NWaWV3LnVwZGF0ZSh1cGRhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1lYXN1cmluZy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lYXN1cmVkW2ldICE9IEJhZE1lYXN1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG0gPSBtZWFzdXJpbmdbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG0ud3JpdGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0ud3JpdGUobWVhc3VyZWRbaV0sIHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dFeGNlcHRpb24odGhpcy5zdGF0ZSwgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVkcmF3bilcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb2NWaWV3LnVwZGF0ZVNlbGVjdGlvbih0cnVlKTtcbiAgICAgICAgICAgICAgICBpZiAoIXVwZGF0ZS52aWV3cG9ydENoYW5nZWQgJiYgdGhpcy5tZWFzdXJlUmVxdWVzdHMubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudmlld1N0YXRlLmVkaXRvckhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudmlld1N0YXRlLnNjcm9sbFRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZG9jVmlldy5zY3JvbGxJbnRvVmlldyh0aGlzLnZpZXdTdGF0ZS5zY3JvbGxUYXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmlld1N0YXRlLnNjcm9sbFRhcmdldCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsQW5jaG9ySGVpZ2h0ID0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmV3QW5jaG9ySGVpZ2h0ID0gc2Nyb2xsQW5jaG9yUG9zIDwgMCA/IHRoaXMudmlld1N0YXRlLmhlaWdodE1hcC5oZWlnaHQgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXdTdGF0ZS5saW5lQmxvY2tBdChzY3JvbGxBbmNob3JQb3MpLnRvcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZGlmZiA9IG5ld0FuY2hvckhlaWdodCAtIHNjcm9sbEFuY2hvckhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlmZiA+IDEgfHwgZGlmZiA8IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbFRvcCA9IHNjcm9sbFRvcCArIGRpZmY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNET00uc2Nyb2xsVG9wID0gc2Nyb2xsVG9wIC8gdGhpcy5zY2FsZVk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbEFuY2hvckhlaWdodCA9IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSA9IDAgLyogVXBkYXRlU3RhdGUuSWRsZSAqLztcbiAgICAgICAgICAgIHRoaXMubWVhc3VyZVNjaGVkdWxlZCA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cGRhdGVkICYmICF1cGRhdGVkLmVtcHR5KVxuICAgICAgICAgICAgZm9yIChsZXQgbGlzdGVuZXIgb2YgdGhpcy5zdGF0ZS5mYWNldCh1cGRhdGVMaXN0ZW5lcikpXG4gICAgICAgICAgICAgICAgbGlzdGVuZXIodXBkYXRlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgQ1NTIGNsYXNzZXMgZm9yIHRoZSBjdXJyZW50bHkgYWN0aXZlIGVkaXRvciB0aGVtZXMuXG4gICAgKi9cbiAgICBnZXQgdGhlbWVDbGFzc2VzKCkge1xuICAgICAgICByZXR1cm4gYmFzZVRoZW1lSUQgKyBcIiBcIiArXG4gICAgICAgICAgICAodGhpcy5zdGF0ZS5mYWNldChkYXJrVGhlbWUpID8gYmFzZURhcmtJRCA6IGJhc2VMaWdodElEKSArIFwiIFwiICtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuZmFjZXQodGhlbWUpO1xuICAgIH1cbiAgICB1cGRhdGVBdHRycygpIHtcbiAgICAgICAgbGV0IGVkaXRvckF0dHJzID0gYXR0cnNGcm9tRmFjZXQodGhpcywgZWRpdG9yQXR0cmlidXRlcywge1xuICAgICAgICAgICAgY2xhc3M6IFwiY20tZWRpdG9yXCIgKyAodGhpcy5oYXNGb2N1cyA/IFwiIGNtLWZvY3VzZWQgXCIgOiBcIiBcIikgKyB0aGlzLnRoZW1lQ2xhc3Nlc1xuICAgICAgICB9KTtcbiAgICAgICAgbGV0IGNvbnRlbnRBdHRycyA9IHtcbiAgICAgICAgICAgIHNwZWxsY2hlY2s6IFwiZmFsc2VcIixcbiAgICAgICAgICAgIGF1dG9jb3JyZWN0OiBcIm9mZlwiLFxuICAgICAgICAgICAgYXV0b2NhcGl0YWxpemU6IFwib2ZmXCIsXG4gICAgICAgICAgICB0cmFuc2xhdGU6IFwibm9cIixcbiAgICAgICAgICAgIGNvbnRlbnRlZGl0YWJsZTogIXRoaXMuc3RhdGUuZmFjZXQoZWRpdGFibGUpID8gXCJmYWxzZVwiIDogXCJ0cnVlXCIsXG4gICAgICAgICAgICBjbGFzczogXCJjbS1jb250ZW50XCIsXG4gICAgICAgICAgICBzdHlsZTogYCR7YnJvd3Nlci50YWJTaXplfTogJHt0aGlzLnN0YXRlLnRhYlNpemV9YCxcbiAgICAgICAgICAgIHJvbGU6IFwidGV4dGJveFwiLFxuICAgICAgICAgICAgXCJhcmlhLW11bHRpbGluZVwiOiBcInRydWVcIlxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5yZWFkT25seSlcbiAgICAgICAgICAgIGNvbnRlbnRBdHRyc1tcImFyaWEtcmVhZG9ubHlcIl0gPSBcInRydWVcIjtcbiAgICAgICAgYXR0cnNGcm9tRmFjZXQodGhpcywgY29udGVudEF0dHJpYnV0ZXMsIGNvbnRlbnRBdHRycyk7XG4gICAgICAgIGxldCBjaGFuZ2VkID0gdGhpcy5vYnNlcnZlci5pZ25vcmUoKCkgPT4ge1xuICAgICAgICAgICAgbGV0IGNoYW5nZWRDb250ZW50ID0gdXBkYXRlQXR0cnModGhpcy5jb250ZW50RE9NLCB0aGlzLmNvbnRlbnRBdHRycywgY29udGVudEF0dHJzKTtcbiAgICAgICAgICAgIGxldCBjaGFuZ2VkRWRpdG9yID0gdXBkYXRlQXR0cnModGhpcy5kb20sIHRoaXMuZWRpdG9yQXR0cnMsIGVkaXRvckF0dHJzKTtcbiAgICAgICAgICAgIHJldHVybiBjaGFuZ2VkQ29udGVudCB8fCBjaGFuZ2VkRWRpdG9yO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5lZGl0b3JBdHRycyA9IGVkaXRvckF0dHJzO1xuICAgICAgICB0aGlzLmNvbnRlbnRBdHRycyA9IGNvbnRlbnRBdHRycztcbiAgICAgICAgcmV0dXJuIGNoYW5nZWQ7XG4gICAgfVxuICAgIHNob3dBbm5vdW5jZW1lbnRzKHRycykge1xuICAgICAgICBsZXQgZmlyc3QgPSB0cnVlO1xuICAgICAgICBmb3IgKGxldCB0ciBvZiB0cnMpXG4gICAgICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgdHIuZWZmZWN0cylcbiAgICAgICAgICAgICAgICBpZiAoZWZmZWN0LmlzKEVkaXRvclZpZXcuYW5ub3VuY2UpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaXJzdClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYW5ub3VuY2VET00udGV4dENvbnRlbnQgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZGl2ID0gdGhpcy5hbm5vdW5jZURPTS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKTtcbiAgICAgICAgICAgICAgICAgICAgZGl2LnRleHRDb250ZW50ID0gZWZmZWN0LnZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICB9XG4gICAgbW91bnRTdHlsZXMoKSB7XG4gICAgICAgIHRoaXMuc3R5bGVNb2R1bGVzID0gdGhpcy5zdGF0ZS5mYWNldChzdHlsZU1vZHVsZSk7XG4gICAgICAgIGxldCBub25jZSA9IHRoaXMuc3RhdGUuZmFjZXQoRWRpdG9yVmlldy5jc3BOb25jZSk7XG4gICAgICAgIFN0eWxlTW9kdWxlLm1vdW50KHRoaXMucm9vdCwgdGhpcy5zdHlsZU1vZHVsZXMuY29uY2F0KGJhc2VUaGVtZSQxKS5yZXZlcnNlKCksIG5vbmNlID8geyBub25jZSB9IDogdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgcmVhZE1lYXN1cmVkKCkge1xuICAgICAgICBpZiAodGhpcy51cGRhdGVTdGF0ZSA9PSAyIC8qIFVwZGF0ZVN0YXRlLlVwZGF0aW5nICovKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVhZGluZyB0aGUgZWRpdG9yIGxheW91dCBpc24ndCBhbGxvd2VkIGR1cmluZyBhbiB1cGRhdGVcIik7XG4gICAgICAgIGlmICh0aGlzLnVwZGF0ZVN0YXRlID09IDAgLyogVXBkYXRlU3RhdGUuSWRsZSAqLyAmJiB0aGlzLm1lYXN1cmVTY2hlZHVsZWQgPiAtMSlcbiAgICAgICAgICAgIHRoaXMubWVhc3VyZShmYWxzZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFNjaGVkdWxlIGEgbGF5b3V0IG1lYXN1cmVtZW50LCBvcHRpb25hbGx5IHByb3ZpZGluZyBjYWxsYmFja3MgdG9cbiAgICBkbyBjdXN0b20gRE9NIG1lYXN1cmluZyBmb2xsb3dlZCBieSBhIERPTSB3cml0ZSBwaGFzZS4gVXNpbmdcbiAgICB0aGlzIGlzIHByZWZlcmFibGUgcmVhZGluZyBET00gbGF5b3V0IGRpcmVjdGx5IGZyb20sIGZvclxuICAgIGV4YW1wbGUsIGFuIGV2ZW50IGhhbmRsZXIsIGJlY2F1c2UgaXQnbGwgbWFrZSBzdXJlIG1lYXN1cmluZyBhbmRcbiAgICBkcmF3aW5nIGRvbmUgYnkgb3RoZXIgY29tcG9uZW50cyBpcyBzeW5jaHJvbml6ZWQsIGF2b2lkaW5nXG4gICAgdW5uZWNlc3NhcnkgRE9NIGxheW91dCBjb21wdXRhdGlvbnMuXG4gICAgKi9cbiAgICByZXF1ZXN0TWVhc3VyZShyZXF1ZXN0KSB7XG4gICAgICAgIGlmICh0aGlzLm1lYXN1cmVTY2hlZHVsZWQgPCAwKVxuICAgICAgICAgICAgdGhpcy5tZWFzdXJlU2NoZWR1bGVkID0gdGhpcy53aW4ucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHRoaXMubWVhc3VyZSgpKTtcbiAgICAgICAgaWYgKHJlcXVlc3QpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm1lYXN1cmVSZXF1ZXN0cy5pbmRleE9mKHJlcXVlc3QpID4gLTEpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKHJlcXVlc3Qua2V5ICE9IG51bGwpXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1lYXN1cmVSZXF1ZXN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tZWFzdXJlUmVxdWVzdHNbaV0ua2V5ID09PSByZXF1ZXN0LmtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tZWFzdXJlUmVxdWVzdHNbaV0gPSByZXF1ZXN0O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tZWFzdXJlUmVxdWVzdHMucHVzaChyZXF1ZXN0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIHZhbHVlIG9mIGEgc3BlY2lmaWMgcGx1Z2luLCBpZiBwcmVzZW50LiBOb3RlIHRoYXRcbiAgICBwbHVnaW5zIHRoYXQgY3Jhc2ggY2FuIGJlIGRyb3BwZWQgZnJvbSBhIHZpZXcsIHNvIGV2ZW4gd2hlbiB5b3VcbiAgICBrbm93IHlvdSByZWdpc3RlcmVkIGEgZ2l2ZW4gcGx1Z2luLCBpdCBpcyByZWNvbW1lbmRlZCB0byBjaGVja1xuICAgIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhpcyBtZXRob2QuXG4gICAgKi9cbiAgICBwbHVnaW4ocGx1Z2luKSB7XG4gICAgICAgIGxldCBrbm93biA9IHRoaXMucGx1Z2luTWFwLmdldChwbHVnaW4pO1xuICAgICAgICBpZiAoa25vd24gPT09IHVuZGVmaW5lZCB8fCBrbm93biAmJiBrbm93bi5zcGVjICE9IHBsdWdpbilcbiAgICAgICAgICAgIHRoaXMucGx1Z2luTWFwLnNldChwbHVnaW4sIGtub3duID0gdGhpcy5wbHVnaW5zLmZpbmQocCA9PiBwLnNwZWMgPT0gcGx1Z2luKSB8fCBudWxsKTtcbiAgICAgICAgcmV0dXJuIGtub3duICYmIGtub3duLnVwZGF0ZSh0aGlzKS52YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIHRvcCBwb3NpdGlvbiBvZiB0aGUgZG9jdW1lbnQsIGluIHNjcmVlbiBjb29yZGluYXRlcy4gVGhpc1xuICAgIG1heSBiZSBuZWdhdGl2ZSB3aGVuIHRoZSBlZGl0b3IgaXMgc2Nyb2xsZWQgZG93bi4gUG9pbnRzXG4gICAgZGlyZWN0bHkgdG8gdGhlIHRvcCBvZiB0aGUgZmlyc3QgbGluZSwgbm90IGFib3ZlIHRoZSBwYWRkaW5nLlxuICAgICovXG4gICAgZ2V0IGRvY3VtZW50VG9wKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50RE9NLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCArIHRoaXMudmlld1N0YXRlLnBhZGRpbmdUb3A7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlcG9ydHMgdGhlIHBhZGRpbmcgYWJvdmUgYW5kIGJlbG93IHRoZSBkb2N1bWVudC5cbiAgICAqL1xuICAgIGdldCBkb2N1bWVudFBhZGRpbmcoKSB7XG4gICAgICAgIHJldHVybiB7IHRvcDogdGhpcy52aWV3U3RhdGUucGFkZGluZ1RvcCwgYm90dG9tOiB0aGlzLnZpZXdTdGF0ZS5wYWRkaW5nQm90dG9tIH07XG4gICAgfVxuICAgIC8qKlxuICAgIElmIHRoZSBlZGl0b3IgaXMgdHJhbnNmb3JtZWQgd2l0aCBDU1MsIHRoaXMgcHJvdmlkZXMgdGhlIHNjYWxlXG4gICAgYWxvbmcgdGhlIFggYXhpcy4gT3RoZXJ3aXNlLCBpdCB3aWxsIGp1c3QgYmUgMS4gTm90ZSB0aGF0XG4gICAgdHJhbnNmb3JtcyBvdGhlciB0aGFuIHRyYW5zbGF0aW9uIGFuZCBzY2FsaW5nIGFyZSBub3Qgc3VwcG9ydGVkLlxuICAgICovXG4gICAgZ2V0IHNjYWxlWCgpIHsgcmV0dXJuIHRoaXMudmlld1N0YXRlLnNjYWxlWDsgfVxuICAgIC8qKlxuICAgIFByb3ZpZGUgdGhlIENTUyB0cmFuc2Zvcm1lZCBzY2FsZSBhbG9uZyB0aGUgWSBheGlzLlxuICAgICovXG4gICAgZ2V0IHNjYWxlWSgpIHsgcmV0dXJuIHRoaXMudmlld1N0YXRlLnNjYWxlWTsgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIHRleHQgbGluZSBvciBibG9jayB3aWRnZXQgYXQgdGhlIGdpdmVuIHZlcnRpY2FsXG4gICAgcG9zaXRpb24gKHdoaWNoIGlzIGludGVycHJldGVkIGFzIHJlbGF0aXZlIHRvIHRoZSBbdG9wIG9mIHRoZVxuICAgIGRvY3VtZW50XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5kb2N1bWVudFRvcCkpLlxuICAgICovXG4gICAgZWxlbWVudEF0SGVpZ2h0KGhlaWdodCkge1xuICAgICAgICB0aGlzLnJlYWRNZWFzdXJlZCgpO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3U3RhdGUuZWxlbWVudEF0SGVpZ2h0KGhlaWdodCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIGxpbmUgYmxvY2sgKHNlZVxuICAgIFtgbGluZUJsb2NrQXRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5saW5lQmxvY2tBdCkgYXQgdGhlIGdpdmVuXG4gICAgaGVpZ2h0LCBhZ2FpbiBpbnRlcnByZXRlZCByZWxhdGl2ZSB0byB0aGUgW3RvcCBvZiB0aGVcbiAgICBkb2N1bWVudF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcuZG9jdW1lbnRUb3ApLlxuICAgICovXG4gICAgbGluZUJsb2NrQXRIZWlnaHQoaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMucmVhZE1lYXN1cmVkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdTdGF0ZS5saW5lQmxvY2tBdEhlaWdodChoZWlnaHQpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGV4dGVudCBhbmQgdmVydGljYWwgcG9zaXRpb24gb2YgYWxsIFtsaW5lXG4gICAgYmxvY2tzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5saW5lQmxvY2tBdCkgaW4gdGhlIHZpZXdwb3J0LiBQb3NpdGlvbnNcbiAgICBhcmUgcmVsYXRpdmUgdG8gdGhlIFt0b3Agb2YgdGhlXG4gICAgZG9jdW1lbnRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LmRvY3VtZW50VG9wKTtcbiAgICAqL1xuICAgIGdldCB2aWV3cG9ydExpbmVCbG9ja3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdTdGF0ZS52aWV3cG9ydExpbmVzO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBsaW5lIGJsb2NrIGFyb3VuZCB0aGUgZ2l2ZW4gZG9jdW1lbnQgcG9zaXRpb24uIEEgbGluZVxuICAgIGJsb2NrIGlzIGEgcmFuZ2UgZGVsaW1pdGVkIG9uIGJvdGggc2lkZXMgYnkgZWl0aGVyIGFcbiAgICBub24tW2hpZGRlbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkRlY29yYXRpb25ecmVwbGFjZSkgbGluZSBicmVha3MsIG9yIHRoZVxuICAgIHN0YXJ0L2VuZCBvZiB0aGUgZG9jdW1lbnQuIEl0IHdpbGwgdXN1YWxseSBqdXN0IGhvbGQgYSBsaW5lIG9mXG4gICAgdGV4dCwgYnV0IG1heSBiZSBicm9rZW4gaW50byBtdWx0aXBsZSB0ZXh0YmxvY2tzIGJ5IGJsb2NrXG4gICAgd2lkZ2V0cy5cbiAgICAqL1xuICAgIGxpbmVCbG9ja0F0KHBvcykge1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3U3RhdGUubGluZUJsb2NrQXQocG9zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIGVkaXRvcidzIHRvdGFsIGNvbnRlbnQgaGVpZ2h0LlxuICAgICovXG4gICAgZ2V0IGNvbnRlbnRIZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdTdGF0ZS5jb250ZW50SGVpZ2h0O1xuICAgIH1cbiAgICAvKipcbiAgICBNb3ZlIGEgY3Vyc29yIHBvc2l0aW9uIGJ5IFtncmFwaGVtZVxuICAgIGNsdXN0ZXJdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuZmluZENsdXN0ZXJCcmVhaykuIGBmb3J3YXJkYCBkZXRlcm1pbmVzIHdoZXRoZXJcbiAgICB0aGUgbW90aW9uIGlzIGF3YXkgZnJvbSB0aGUgbGluZSBzdGFydCwgb3IgdG93YXJkcyBpdC4gSW5cbiAgICBiaWRpcmVjdGlvbmFsIHRleHQsIHRoZSBsaW5lIGlzIHRyYXZlcnNlZCBpbiB2aXN1YWwgb3JkZXIsIHVzaW5nXG4gICAgdGhlIGVkaXRvcidzIFt0ZXh0IGRpcmVjdGlvbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcudGV4dERpcmVjdGlvbikuXG4gICAgV2hlbiB0aGUgc3RhcnQgcG9zaXRpb24gd2FzIHRoZSBsYXN0IG9uZSBvbiB0aGUgbGluZSwgdGhlXG4gICAgcmV0dXJuZWQgcG9zaXRpb24gd2lsbCBiZSBhY3Jvc3MgdGhlIGxpbmUgYnJlYWsuIElmIHRoZXJlIGlzIG5vXG4gICAgZnVydGhlciBsaW5lLCB0aGUgb3JpZ2luYWwgcG9zaXRpb24gaXMgcmV0dXJuZWQuXG4gICAgXG4gICAgQnkgZGVmYXVsdCwgdGhpcyBtZXRob2QgbW92ZXMgb3ZlciBhIHNpbmdsZSBjbHVzdGVyLiBUaGVcbiAgICBvcHRpb25hbCBgYnlgIGFyZ3VtZW50IGNhbiBiZSB1c2VkIHRvIG1vdmUgYWNyb3NzIG1vcmUuIEl0IHdpbGxcbiAgICBiZSBjYWxsZWQgd2l0aCB0aGUgZmlyc3QgY2x1c3RlciBhcyBhcmd1bWVudCwgYW5kIHNob3VsZCByZXR1cm5cbiAgICBhIHByZWRpY2F0ZSB0aGF0IGRldGVybWluZXMsIGZvciBlYWNoIHN1YnNlcXVlbnQgY2x1c3RlcixcbiAgICB3aGV0aGVyIGl0IHNob3VsZCBhbHNvIGJlIG1vdmVkIG92ZXIuXG4gICAgKi9cbiAgICBtb3ZlQnlDaGFyKHN0YXJ0LCBmb3J3YXJkLCBieSkge1xuICAgICAgICByZXR1cm4gc2tpcEF0b21zKHRoaXMsIHN0YXJ0LCBtb3ZlQnlDaGFyKHRoaXMsIHN0YXJ0LCBmb3J3YXJkLCBieSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBNb3ZlIGEgY3Vyc29yIHBvc2l0aW9uIGFjcm9zcyB0aGUgbmV4dCBncm91cCBvZiBlaXRoZXJcbiAgICBbbGV0dGVyc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5jaGFyQ2F0ZWdvcml6ZXIpIG9yIG5vbi1sZXR0ZXJcbiAgICBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXJzLlxuICAgICovXG4gICAgbW92ZUJ5R3JvdXAoc3RhcnQsIGZvcndhcmQpIHtcbiAgICAgICAgcmV0dXJuIHNraXBBdG9tcyh0aGlzLCBzdGFydCwgbW92ZUJ5Q2hhcih0aGlzLCBzdGFydCwgZm9yd2FyZCwgaW5pdGlhbCA9PiBieUdyb3VwKHRoaXMsIHN0YXJ0LmhlYWQsIGluaXRpYWwpKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIE1vdmUgdG8gdGhlIG5leHQgbGluZSBib3VuZGFyeSBpbiB0aGUgZ2l2ZW4gZGlyZWN0aW9uLiBJZlxuICAgIGBpbmNsdWRlV3JhcGAgaXMgdHJ1ZSwgbGluZSB3cmFwcGluZyBpcyBvbiwgYW5kIHRoZXJlIGlzIGFcbiAgICBmdXJ0aGVyIHdyYXAgcG9pbnQgb24gdGhlIGN1cnJlbnQgbGluZSwgdGhlIHdyYXAgcG9pbnQgd2lsbCBiZVxuICAgIHJldHVybmVkLiBPdGhlcndpc2UgdGhpcyBmdW5jdGlvbiB3aWxsIHJldHVybiB0aGUgc3RhcnQgb3IgZW5kXG4gICAgb2YgdGhlIGxpbmUuXG4gICAgKi9cbiAgICBtb3ZlVG9MaW5lQm91bmRhcnkoc3RhcnQsIGZvcndhcmQsIGluY2x1ZGVXcmFwID0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gbW92ZVRvTGluZUJvdW5kYXJ5KHRoaXMsIHN0YXJ0LCBmb3J3YXJkLCBpbmNsdWRlV3JhcCk7XG4gICAgfVxuICAgIC8qKlxuICAgIE1vdmUgYSBjdXJzb3IgcG9zaXRpb24gdmVydGljYWxseS4gV2hlbiBgZGlzdGFuY2VgIGlzbid0IGdpdmVuLFxuICAgIGl0IGRlZmF1bHRzIHRvIG1vdmluZyB0byB0aGUgbmV4dCBsaW5lIChpbmNsdWRpbmcgd3JhcHBlZFxuICAgIGxpbmVzKS4gT3RoZXJ3aXNlLCBgZGlzdGFuY2VgIHNob3VsZCBwcm92aWRlIGEgcG9zaXRpdmUgZGlzdGFuY2VcbiAgICBpbiBwaXhlbHMuXG4gICAgXG4gICAgV2hlbiBgc3RhcnRgIGhhcyBhXG4gICAgW2Bnb2FsQ29sdW1uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5TZWxlY3Rpb25SYW5nZS5nb2FsQ29sdW1uKSwgdGhlIHZlcnRpY2FsXG4gICAgbW90aW9uIHdpbGwgdXNlIHRoYXQgYXMgYSB0YXJnZXQgaG9yaXpvbnRhbCBwb3NpdGlvbi4gT3RoZXJ3aXNlLFxuICAgIHRoZSBjdXJzb3IncyBvd24gaG9yaXpvbnRhbCBwb3NpdGlvbiBpcyB1c2VkLiBUaGUgcmV0dXJuZWRcbiAgICBjdXJzb3Igd2lsbCBoYXZlIGl0cyBnb2FsIGNvbHVtbiBzZXQgdG8gd2hpY2hldmVyIGNvbHVtbiB3YXNcbiAgICB1c2VkLlxuICAgICovXG4gICAgbW92ZVZlcnRpY2FsbHkoc3RhcnQsIGZvcndhcmQsIGRpc3RhbmNlKSB7XG4gICAgICAgIHJldHVybiBza2lwQXRvbXModGhpcywgc3RhcnQsIG1vdmVWZXJ0aWNhbGx5KHRoaXMsIHN0YXJ0LCBmb3J3YXJkLCBkaXN0YW5jZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBET00gcGFyZW50IG5vZGUgYW5kIG9mZnNldCAoY2hpbGQgb2Zmc2V0IGlmIGBub2RlYCBpc1xuICAgIGFuIGVsZW1lbnQsIGNoYXJhY3RlciBvZmZzZXQgd2hlbiBpdCBpcyBhIHRleHQgbm9kZSkgYXQgdGhlXG4gICAgZ2l2ZW4gZG9jdW1lbnQgcG9zaXRpb24uXG4gICAgXG4gICAgTm90ZSB0aGF0IGZvciBwb3NpdGlvbnMgdGhhdCBhcmVuJ3QgY3VycmVudGx5IGluXG4gICAgYHZpc2libGVSYW5nZXNgLCB0aGUgcmVzdWx0aW5nIERPTSBwb3NpdGlvbiBpc24ndCBuZWNlc3NhcmlseVxuICAgIG1lYW5pbmdmdWwgKGl0IG1heSBqdXN0IHBvaW50IGJlZm9yZSBvciBhZnRlciBhIHBsYWNlaG9sZGVyXG4gICAgZWxlbWVudCkuXG4gICAgKi9cbiAgICBkb21BdFBvcyhwb3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jVmlldy5kb21BdFBvcyhwb3MpO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBkb2N1bWVudCBwb3NpdGlvbiBhdCB0aGUgZ2l2ZW4gRE9NIG5vZGUuIENhbiBiZSB1c2VmdWxcbiAgICBmb3IgYXNzb2NpYXRpbmcgcG9zaXRpb25zIHdpdGggRE9NIGV2ZW50cy4gV2lsbCByYWlzZSBhbiBlcnJvclxuICAgIHdoZW4gYG5vZGVgIGlzbid0IHBhcnQgb2YgdGhlIGVkaXRvciBjb250ZW50LlxuICAgICovXG4gICAgcG9zQXRET00obm9kZSwgb2Zmc2V0ID0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kb2NWaWV3LnBvc0Zyb21ET00obm9kZSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgcG9zQXRDb29yZHMoY29vcmRzLCBwcmVjaXNlID0gdHJ1ZSkge1xuICAgICAgICB0aGlzLnJlYWRNZWFzdXJlZCgpO1xuICAgICAgICByZXR1cm4gcG9zQXRDb29yZHModGhpcywgY29vcmRzLCBwcmVjaXNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBzY3JlZW4gY29vcmRpbmF0ZXMgYXQgdGhlIGdpdmVuIGRvY3VtZW50IHBvc2l0aW9uLlxuICAgIGBzaWRlYCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGNvb3JkaW5hdGVzIGFyZSBiYXNlZCBvbiB0aGVcbiAgICBlbGVtZW50IGJlZm9yZSAoLTEpIG9yIGFmdGVyICgxKSB0aGUgcG9zaXRpb24gKGlmIG5vIGVsZW1lbnQgaXNcbiAgICBhdmFpbGFibGUgb24gdGhlIGdpdmVuIHNpZGUsIHRoZSBtZXRob2Qgd2lsbCB0cmFuc3BhcmVudGx5IHVzZVxuICAgIGFub3RoZXIgc3RyYXRlZ3kgdG8gZ2V0IHJlYXNvbmFibGUgY29vcmRpbmF0ZXMpLlxuICAgICovXG4gICAgY29vcmRzQXRQb3MocG9zLCBzaWRlID0gMSkge1xuICAgICAgICB0aGlzLnJlYWRNZWFzdXJlZCgpO1xuICAgICAgICBsZXQgcmVjdCA9IHRoaXMuZG9jVmlldy5jb29yZHNBdChwb3MsIHNpZGUpO1xuICAgICAgICBpZiAoIXJlY3QgfHwgcmVjdC5sZWZ0ID09IHJlY3QucmlnaHQpXG4gICAgICAgICAgICByZXR1cm4gcmVjdDtcbiAgICAgICAgbGV0IGxpbmUgPSB0aGlzLnN0YXRlLmRvYy5saW5lQXQocG9zKSwgb3JkZXIgPSB0aGlzLmJpZGlTcGFucyhsaW5lKTtcbiAgICAgICAgbGV0IHNwYW4gPSBvcmRlcltCaWRpU3Bhbi5maW5kKG9yZGVyLCBwb3MgLSBsaW5lLmZyb20sIC0xLCBzaWRlKV07XG4gICAgICAgIHJldHVybiBmbGF0dGVuUmVjdChyZWN0LCAoc3Bhbi5kaXIgPT0gRGlyZWN0aW9uLkxUUikgPT0gKHNpZGUgPiAwKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybiB0aGUgcmVjdGFuZ2xlIGFyb3VuZCBhIGdpdmVuIGNoYXJhY3Rlci4gSWYgYHBvc2AgZG9lcyBub3RcbiAgICBwb2ludCBpbiBmcm9udCBvZiBhIGNoYXJhY3RlciB0aGF0IGlzIGluIHRoZSB2aWV3cG9ydCBhbmRcbiAgICByZW5kZXJlZCAoaS5lLiBub3QgcmVwbGFjZWQsIG5vdCBhIGxpbmUgYnJlYWspLCB0aGlzIHdpbGwgcmV0dXJuXG4gICAgbnVsbC4gRm9yIHNwYWNlIGNoYXJhY3RlcnMgdGhhdCBhcmUgYSBsaW5lIHdyYXAgcG9pbnQsIHRoaXMgd2lsbFxuICAgIHJldHVybiB0aGUgcG9zaXRpb24gYmVmb3JlIHRoZSBsaW5lIGJyZWFrLlxuICAgICovXG4gICAgY29vcmRzRm9yQ2hhcihwb3MpIHtcbiAgICAgICAgdGhpcy5yZWFkTWVhc3VyZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jVmlldy5jb29yZHNGb3JDaGFyKHBvcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBkZWZhdWx0IHdpZHRoIG9mIGEgY2hhcmFjdGVyIGluIHRoZSBlZGl0b3IuIE1heSBub3RcbiAgICBhY2N1cmF0ZWx5IHJlZmxlY3QgdGhlIHdpZHRoIG9mIGFsbCBjaGFyYWN0ZXJzIChnaXZlbiB2YXJpYWJsZVxuICAgIHdpZHRoIGZvbnRzIG9yIHN0eWxpbmcgb2YgaW52aWRpZHVhbCByYW5nZXMpLlxuICAgICovXG4gICAgZ2V0IGRlZmF1bHRDaGFyYWN0ZXJXaWR0aCgpIHsgcmV0dXJuIHRoaXMudmlld1N0YXRlLmhlaWdodE9yYWNsZS5jaGFyV2lkdGg7IH1cbiAgICAvKipcbiAgICBUaGUgZGVmYXVsdCBoZWlnaHQgb2YgYSBsaW5lIGluIHRoZSBlZGl0b3IuIE1heSBub3QgYmUgYWNjdXJhdGVcbiAgICBmb3IgYWxsIGxpbmVzLlxuICAgICovXG4gICAgZ2V0IGRlZmF1bHRMaW5lSGVpZ2h0KCkgeyByZXR1cm4gdGhpcy52aWV3U3RhdGUuaGVpZ2h0T3JhY2xlLmxpbmVIZWlnaHQ7IH1cbiAgICAvKipcbiAgICBUaGUgdGV4dCBkaXJlY3Rpb25cbiAgICAoW2BkaXJlY3Rpb25gXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvZGlyZWN0aW9uKVxuICAgIENTUyBwcm9wZXJ0eSkgb2YgdGhlIGVkaXRvcidzIGNvbnRlbnQgZWxlbWVudC5cbiAgICAqL1xuICAgIGdldCB0ZXh0RGlyZWN0aW9uKCkgeyByZXR1cm4gdGhpcy52aWV3U3RhdGUuZGVmYXVsdFRleHREaXJlY3Rpb247IH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSB0ZXh0IGRpcmVjdGlvbiBvZiB0aGUgYmxvY2sgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLCBhc1xuICAgIGFzc2lnbmVkIGJ5IENTUy4gSWZcbiAgICBbYHBlckxpbmVUZXh0RGlyZWN0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXdecGVyTGluZVRleHREaXJlY3Rpb24pXG4gICAgaXNuJ3QgZW5hYmxlZCwgb3IgdGhlIGdpdmVuIHBvc2l0aW9uIGlzIG91dHNpZGUgb2YgdGhlIHZpZXdwb3J0LFxuICAgIHRoaXMgd2lsbCBhbHdheXMgcmV0dXJuIHRoZSBzYW1lIGFzXG4gICAgW2B0ZXh0RGlyZWN0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcudGV4dERpcmVjdGlvbikuIE5vdGUgdGhhdFxuICAgIHRoaXMgbWF5IHRyaWdnZXIgYSBET00gbGF5b3V0LlxuICAgICovXG4gICAgdGV4dERpcmVjdGlvbkF0KHBvcykge1xuICAgICAgICBsZXQgcGVyTGluZSA9IHRoaXMuc3RhdGUuZmFjZXQocGVyTGluZVRleHREaXJlY3Rpb24pO1xuICAgICAgICBpZiAoIXBlckxpbmUgfHwgcG9zIDwgdGhpcy52aWV3cG9ydC5mcm9tIHx8IHBvcyA+IHRoaXMudmlld3BvcnQudG8pXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50ZXh0RGlyZWN0aW9uO1xuICAgICAgICB0aGlzLnJlYWRNZWFzdXJlZCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5kb2NWaWV3LnRleHREaXJlY3Rpb25BdChwb3MpO1xuICAgIH1cbiAgICAvKipcbiAgICBXaGV0aGVyIHRoaXMgZWRpdG9yIFt3cmFwcyBsaW5lc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcubGluZVdyYXBwaW5nKVxuICAgIChhcyBkZXRlcm1pbmVkIGJ5IHRoZVxuICAgIFtgd2hpdGUtc3BhY2VgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1Mvd2hpdGUtc3BhY2UpXG4gICAgQ1NTIHByb3BlcnR5IG9mIGl0cyBjb250ZW50IGVsZW1lbnQpLlxuICAgICovXG4gICAgZ2V0IGxpbmVXcmFwcGluZygpIHsgcmV0dXJuIHRoaXMudmlld1N0YXRlLmhlaWdodE9yYWNsZS5saW5lV3JhcHBpbmc7IH1cbiAgICAvKipcbiAgICBSZXR1cm5zIHRoZSBiaWRpcmVjdGlvbmFsIHRleHQgc3RydWN0dXJlIG9mIHRoZSBnaXZlbiBsaW5lXG4gICAgKHdoaWNoIHNob3VsZCBiZSBpbiB0aGUgY3VycmVudCBkb2N1bWVudCkgYXMgYW4gYXJyYXkgb2Ygc3BhblxuICAgIG9iamVjdHMuIFRoZSBvcmRlciBvZiB0aGVzZSBzcGFucyBtYXRjaGVzIHRoZSBbdGV4dFxuICAgIGRpcmVjdGlvbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcudGV4dERpcmVjdGlvbinigJRpZiB0aGF0IGlzXG4gICAgbGVmdC10by1yaWdodCwgdGhlIGxlZnRtb3N0IHNwYW5zIGNvbWUgZmlyc3QsIG90aGVyd2lzZSB0aGVcbiAgICByaWdodG1vc3Qgc3BhbnMgY29tZSBmaXJzdC5cbiAgICAqL1xuICAgIGJpZGlTcGFucyhsaW5lKSB7XG4gICAgICAgIGlmIChsaW5lLmxlbmd0aCA+IE1heEJpZGlMaW5lKVxuICAgICAgICAgICAgcmV0dXJuIHRyaXZpYWxPcmRlcihsaW5lLmxlbmd0aCk7XG4gICAgICAgIGxldCBkaXIgPSB0aGlzLnRleHREaXJlY3Rpb25BdChsaW5lLmZyb20pLCBpc29sYXRlcztcbiAgICAgICAgZm9yIChsZXQgZW50cnkgb2YgdGhpcy5iaWRpQ2FjaGUpIHtcbiAgICAgICAgICAgIGlmIChlbnRyeS5mcm9tID09IGxpbmUuZnJvbSAmJiBlbnRyeS5kaXIgPT0gZGlyICYmXG4gICAgICAgICAgICAgICAgKGVudHJ5LmZyZXNoIHx8IGlzb2xhdGVzRXEoZW50cnkuaXNvbGF0ZXMsIGlzb2xhdGVzID0gZ2V0SXNvbGF0ZWRSYW5nZXModGhpcywgbGluZS5mcm9tLCBsaW5lLnRvKSkpKVxuICAgICAgICAgICAgICAgIHJldHVybiBlbnRyeS5vcmRlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzb2xhdGVzKVxuICAgICAgICAgICAgaXNvbGF0ZXMgPSBnZXRJc29sYXRlZFJhbmdlcyh0aGlzLCBsaW5lLmZyb20sIGxpbmUudG8pO1xuICAgICAgICBsZXQgb3JkZXIgPSBjb21wdXRlT3JkZXIobGluZS50ZXh0LCBkaXIsIGlzb2xhdGVzKTtcbiAgICAgICAgdGhpcy5iaWRpQ2FjaGUucHVzaChuZXcgQ2FjaGVkT3JkZXIobGluZS5mcm9tLCBsaW5lLnRvLCBkaXIsIGlzb2xhdGVzLCB0cnVlLCBvcmRlcikpO1xuICAgICAgICByZXR1cm4gb3JkZXI7XG4gICAgfVxuICAgIC8qKlxuICAgIENoZWNrIHdoZXRoZXIgdGhlIGVkaXRvciBoYXMgZm9jdXMuXG4gICAgKi9cbiAgICBnZXQgaGFzRm9jdXMoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgLy8gU2FmYXJpIHJldHVybiBmYWxzZSBmb3IgaGFzRm9jdXMgd2hlbiB0aGUgY29udGV4dCBtZW51IGlzIG9wZW5cbiAgICAgICAgLy8gb3IgY2xvc2luZywgd2hpY2ggbGVhZHMgdXMgdG8gaWdub3JlIHNlbGVjdGlvbiBjaGFuZ2VzIGZyb20gdGhlXG4gICAgICAgIC8vIGNvbnRleHQgbWVudSBiZWNhdXNlIGl0IGxvb2tzIGxpa2UgdGhlIGVkaXRvciBpc24ndCBmb2N1c2VkLlxuICAgICAgICAvLyBUaGlzIGtsdWRnZXMgYXJvdW5kIHRoYXQuXG4gICAgICAgIHJldHVybiAodGhpcy5kb20ub3duZXJEb2N1bWVudC5oYXNGb2N1cygpIHx8IGJyb3dzZXIuc2FmYXJpICYmICgoX2EgPSB0aGlzLmlucHV0U3RhdGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sYXN0Q29udGV4dE1lbnUpID4gRGF0ZS5ub3coKSAtIDNlNCkgJiZcbiAgICAgICAgICAgIHRoaXMucm9vdC5hY3RpdmVFbGVtZW50ID09IHRoaXMuY29udGVudERPTTtcbiAgICB9XG4gICAgLyoqXG4gICAgUHV0IGZvY3VzIG9uIHRoZSBlZGl0b3IuXG4gICAgKi9cbiAgICBmb2N1cygpIHtcbiAgICAgICAgdGhpcy5vYnNlcnZlci5pZ25vcmUoKCkgPT4ge1xuICAgICAgICAgICAgZm9jdXNQcmV2ZW50U2Nyb2xsKHRoaXMuY29udGVudERPTSk7XG4gICAgICAgICAgICB0aGlzLmRvY1ZpZXcudXBkYXRlU2VsZWN0aW9uKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICBVcGRhdGUgdGhlIFtyb290XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvIyN2aWV3LkVkaXRvclZpZXdDb25maWcucm9vdCkgaW4gd2hpY2ggdGhlIGVkaXRvciBsaXZlcy4gVGhpcyBpcyBvbmx5XG4gICAgbmVjZXNzYXJ5IHdoZW4gbW92aW5nIHRoZSBlZGl0b3IncyBleGlzdGluZyBET00gdG8gYSBuZXcgd2luZG93IG9yIHNoYWRvdyByb290LlxuICAgICovXG4gICAgc2V0Um9vdChyb290KSB7XG4gICAgICAgIGlmICh0aGlzLl9yb290ICE9IHJvb3QpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3QgPSByb290O1xuICAgICAgICAgICAgdGhpcy5vYnNlcnZlci5zZXRXaW5kb3coKHJvb3Qubm9kZVR5cGUgPT0gOSA/IHJvb3QgOiByb290Lm93bmVyRG9jdW1lbnQpLmRlZmF1bHRWaWV3IHx8IHdpbmRvdyk7XG4gICAgICAgICAgICB0aGlzLm1vdW50U3R5bGVzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgQ2xlYW4gdXAgdGhpcyBlZGl0b3IgdmlldywgcmVtb3ZpbmcgaXRzIGVsZW1lbnQgZnJvbSB0aGVcbiAgICBkb2N1bWVudCwgdW5yZWdpc3RlcmluZyBldmVudCBoYW5kbGVycywgYW5kIG5vdGlmeWluZ1xuICAgIHBsdWdpbnMuIFRoZSB2aWV3IGluc3RhbmNlIGNhbiBubyBsb25nZXIgYmUgdXNlZCBhZnRlclxuICAgIGNhbGxpbmcgdGhpcy5cbiAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGZvciAobGV0IHBsdWdpbiBvZiB0aGlzLnBsdWdpbnMpXG4gICAgICAgICAgICBwbHVnaW4uZGVzdHJveSh0aGlzKTtcbiAgICAgICAgdGhpcy5wbHVnaW5zID0gW107XG4gICAgICAgIHRoaXMuaW5wdXRTdGF0ZS5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuZG9jVmlldy5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuZG9tLnJlbW92ZSgpO1xuICAgICAgICB0aGlzLm9ic2VydmVyLmRlc3Ryb3koKTtcbiAgICAgICAgaWYgKHRoaXMubWVhc3VyZVNjaGVkdWxlZCA+IC0xKVxuICAgICAgICAgICAgdGhpcy53aW4uY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5tZWFzdXJlU2NoZWR1bGVkKTtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIGFuIGVmZmVjdCB0aGF0IGNhbiBiZVxuICAgIFthZGRlZF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMuZWZmZWN0cykgdG8gYSB0cmFuc2FjdGlvbiB0b1xuICAgIGNhdXNlIGl0IHRvIHNjcm9sbCB0aGUgZ2l2ZW4gcG9zaXRpb24gb3IgcmFuZ2UgaW50byB2aWV3LlxuICAgICovXG4gICAgc3RhdGljIHNjcm9sbEludG9WaWV3KHBvcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiBzY3JvbGxJbnRvVmlldy5vZihuZXcgU2Nyb2xsVGFyZ2V0KHR5cGVvZiBwb3MgPT0gXCJudW1iZXJcIiA/IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocG9zKSA6IHBvcywgb3B0aW9ucy55LCBvcHRpb25zLngsIG9wdGlvbnMueU1hcmdpbiwgb3B0aW9ucy54TWFyZ2luKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybiBhbiBlZmZlY3QgdGhhdCByZXNldHMgdGhlIGVkaXRvciB0byBpdHMgY3VycmVudCAoYXQgdGhlXG4gICAgdGltZSB0aGlzIG1ldGhvZCB3YXMgY2FsbGVkKSBzY3JvbGwgcG9zaXRpb24uIE5vdGUgdGhhdCB0aGlzXG4gICAgb25seSBhZmZlY3RzIHRoZSBlZGl0b3IncyBvd24gc2Nyb2xsYWJsZSBlbGVtZW50LCBub3QgcGFyZW50cy5cbiAgICBTZWUgYWxzb1xuICAgIFtgRWRpdG9yVmlld0NvbmZpZy5zY3JvbGxUb2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3Q29uZmlnLnNjcm9sbFRvKS5cbiAgICBcbiAgICBUaGUgZWZmZWN0IHNob3VsZCBiZSB1c2VkIHdpdGggYSBkb2N1bWVudCBpZGVudGljYWwgdG8gdGhlIG9uZVxuICAgIGl0IHdhcyBjcmVhdGVkIGZvci4gRmFpbGluZyB0byBkbyBzbyBpcyBub3QgYW4gZXJyb3IsIGJ1dCBtYXlcbiAgICBub3Qgc2Nyb2xsIHRvIHRoZSBleHBlY3RlZCBwb3NpdGlvbi4gWW91IGNhblxuICAgIFttYXBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuU3RhdGVFZmZlY3QubWFwKSB0aGUgZWZmZWN0IHRvIGFjY291bnQgZm9yIGNoYW5nZXMuXG4gICAgKi9cbiAgICBzY3JvbGxTbmFwc2hvdCgpIHtcbiAgICAgICAgbGV0IHsgc2Nyb2xsVG9wLCBzY3JvbGxMZWZ0IH0gPSB0aGlzLnNjcm9sbERPTTtcbiAgICAgICAgbGV0IHJlZiA9IHRoaXMudmlld1N0YXRlLnNjcm9sbEFuY2hvckF0KHNjcm9sbFRvcCk7XG4gICAgICAgIHJldHVybiBzY3JvbGxJbnRvVmlldy5vZihuZXcgU2Nyb2xsVGFyZ2V0KEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocmVmLmZyb20pLCBcInN0YXJ0XCIsIFwic3RhcnRcIiwgcmVmLnRvcCAtIHNjcm9sbFRvcCwgc2Nyb2xsTGVmdCwgdHJ1ZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIGFuIGV4dGVuc2lvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIGFkZCBET00gZXZlbnQgaGFuZGxlcnMuXG4gICAgVGhlIHZhbHVlIHNob3VsZCBiZSBhbiBvYmplY3QgbWFwcGluZyBldmVudCBuYW1lcyB0byBoYW5kbGVyXG4gICAgZnVuY3Rpb25zLiBGb3IgYW55IGdpdmVuIGV2ZW50LCBzdWNoIGZ1bmN0aW9ucyBhcmUgb3JkZXJlZCBieVxuICAgIGV4dGVuc2lvbiBwcmVjZWRlbmNlLCBhbmQgdGhlIGZpcnN0IGhhbmRsZXIgdG8gcmV0dXJuIHRydWUgd2lsbFxuICAgIGJlIGFzc3VtZWQgdG8gaGF2ZSBoYW5kbGVkIHRoYXQgZXZlbnQsIGFuZCBubyBvdGhlciBoYW5kbGVycyBvclxuICAgIGJ1aWx0LWluIGJlaGF2aW9yIHdpbGwgYmUgYWN0aXZhdGVkIGZvciBpdC4gVGhlc2UgYXJlIHJlZ2lzdGVyZWRcbiAgICBvbiB0aGUgW2NvbnRlbnQgZWxlbWVudF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcuY29udGVudERPTSksIGV4Y2VwdFxuICAgIGZvciBgc2Nyb2xsYCBoYW5kbGVycywgd2hpY2ggd2lsbCBiZSBjYWxsZWQgYW55IHRpbWUgdGhlXG4gICAgZWRpdG9yJ3MgW3Njcm9sbCBlbGVtZW50XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5zY3JvbGxET00pIG9yIG9uZSBvZlxuICAgIGl0cyBwYXJlbnQgbm9kZXMgaXMgc2Nyb2xsZWQuXG4gICAgKi9cbiAgICBzdGF0aWMgZG9tRXZlbnRIYW5kbGVycyhoYW5kbGVycykge1xuICAgICAgICByZXR1cm4gVmlld1BsdWdpbi5kZWZpbmUoKCkgPT4gKHt9KSwgeyBldmVudEhhbmRsZXJzOiBoYW5kbGVycyB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGFuIGV4dGVuc2lvbiB0aGF0IHJlZ2lzdGVycyBET00gZXZlbnQgb2JzZXJ2ZXJzLiBDb250cmFyeVxuICAgIHRvIGV2ZW50IFtoYW5kbGVyc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXdeZG9tRXZlbnRIYW5kbGVycyksXG4gICAgb2JzZXJ2ZXJzIGNhbid0IGJlIHByZXZlbnRlZCBmcm9tIHJ1bm5pbmcgYnkgYSBoaWdoZXItcHJlY2VkZW5jZVxuICAgIGhhbmRsZXIgcmV0dXJuaW5nIHRydWUuIFRoZXkgYWxzbyBkb24ndCBwcmV2ZW50IG90aGVyIGhhbmRsZXJzXG4gICAgYW5kIG9ic2VydmVycyBmcm9tIHJ1bm5pbmcgd2hlbiB0aGV5IHJldHVybiB0cnVlLCBhbmQgc2hvdWxkIG5vdFxuICAgIGNhbGwgYHByZXZlbnREZWZhdWx0YC5cbiAgICAqL1xuICAgIHN0YXRpYyBkb21FdmVudE9ic2VydmVycyhvYnNlcnZlcnMpIHtcbiAgICAgICAgcmV0dXJuIFZpZXdQbHVnaW4uZGVmaW5lKCgpID0+ICh7fSksIHsgZXZlbnRPYnNlcnZlcnM6IG9ic2VydmVycyB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgdGhlbWUgZXh0ZW5zaW9uLiBUaGUgZmlyc3QgYXJndW1lbnQgY2FuIGJlIGFcbiAgICBbYHN0eWxlLW1vZGBdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJpam5oL3N0eWxlLW1vZCNkb2N1bWVudGF0aW9uKVxuICAgIHN0eWxlIHNwZWMgcHJvdmlkaW5nIHRoZSBzdHlsZXMgZm9yIHRoZSB0aGVtZS4gVGhlc2Ugd2lsbCBiZVxuICAgIHByZWZpeGVkIHdpdGggYSBnZW5lcmF0ZWQgY2xhc3MgZm9yIHRoZSBzdHlsZS5cbiAgICBcbiAgICBCZWNhdXNlIHRoZSBzZWxlY3RvcnMgd2lsbCBiZSBwcmVmaXhlZCB3aXRoIGEgc2NvcGUgY2xhc3MsIHJ1bGVcbiAgICB0aGF0IGRpcmVjdGx5IG1hdGNoIHRoZSBlZGl0b3IncyBbd3JhcHBlclxuICAgIGVsZW1lbnRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LmRvbSnigJR0byB3aGljaCB0aGUgc2NvcGUgY2xhc3Mgd2lsbCBiZVxuICAgIGFkZGVk4oCUbmVlZCB0byBiZSBleHBsaWNpdGx5IGRpZmZlcmVudGlhdGVkIGJ5IGFkZGluZyBhbiBgJmAgdG9cbiAgICB0aGUgc2VsZWN0b3IgZm9yIHRoYXQgZWxlbWVudOKAlGZvciBleGFtcGxlXG4gICAgYCYuY20tZm9jdXNlZGAuXG4gICAgXG4gICAgV2hlbiBgZGFya2AgaXMgc2V0IHRvIHRydWUsIHRoZSB0aGVtZSB3aWxsIGJlIG1hcmtlZCBhcyBkYXJrLFxuICAgIHdoaWNoIHdpbGwgY2F1c2UgdGhlIGAmZGFya2AgcnVsZXMgZnJvbSBbYmFzZVxuICAgIHRoZW1lc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXdeYmFzZVRoZW1lKSB0byBiZSB1c2VkIChhcyBvcHBvc2VkIHRvXG4gICAgYCZsaWdodGAgd2hlbiBhIGxpZ2h0IHRoZW1lIGlzIGFjdGl2ZSkuXG4gICAgKi9cbiAgICBzdGF0aWMgdGhlbWUoc3BlYywgb3B0aW9ucykge1xuICAgICAgICBsZXQgcHJlZml4ID0gU3R5bGVNb2R1bGUubmV3TmFtZSgpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW3RoZW1lLm9mKHByZWZpeCksIHN0eWxlTW9kdWxlLm9mKGJ1aWxkVGhlbWUoYC4ke3ByZWZpeH1gLCBzcGVjKSldO1xuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmRhcmspXG4gICAgICAgICAgICByZXN1bHQucHVzaChkYXJrVGhlbWUub2YodHJ1ZSkpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYW4gZXh0ZW5zaW9uIHRoYXQgYWRkcyBzdHlsZXMgdG8gdGhlIGJhc2UgdGhlbWUuIExpa2VcbiAgICB3aXRoIFtgdGhlbWVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlld150aGVtZSksIHVzZSBgJmAgdG8gaW5kaWNhdGUgdGhlXG4gICAgcGxhY2Ugb2YgdGhlIGVkaXRvciB3cmFwcGVyIGVsZW1lbnQgd2hlbiBkaXJlY3RseSB0YXJnZXRpbmdcbiAgICB0aGF0LiBZb3UgY2FuIGFsc28gdXNlIGAmZGFya2Agb3IgYCZsaWdodGAgaW5zdGVhZCB0byBvbmx5XG4gICAgdGFyZ2V0IGVkaXRvcnMgd2l0aCBhIGRhcmsgb3IgbGlnaHQgdGhlbWUuXG4gICAgKi9cbiAgICBzdGF0aWMgYmFzZVRoZW1lKHNwZWMpIHtcbiAgICAgICAgcmV0dXJuIFByZWMubG93ZXN0KHN0eWxlTW9kdWxlLm9mKGJ1aWxkVGhlbWUoXCIuXCIgKyBiYXNlVGhlbWVJRCwgc3BlYywgbGlnaHREYXJrSURzKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXRyaWV2ZSBhbiBlZGl0b3IgdmlldyBpbnN0YW5jZSBmcm9tIHRoZSB2aWV3J3MgRE9NXG4gICAgcmVwcmVzZW50YXRpb24uXG4gICAgKi9cbiAgICBzdGF0aWMgZmluZEZyb21ET00oZG9tKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgbGV0IGNvbnRlbnQgPSBkb20ucXVlcnlTZWxlY3RvcihcIi5jbS1jb250ZW50XCIpO1xuICAgICAgICBsZXQgY1ZpZXcgPSBjb250ZW50ICYmIENvbnRlbnRWaWV3LmdldChjb250ZW50KSB8fCBDb250ZW50Vmlldy5nZXQoZG9tKTtcbiAgICAgICAgcmV0dXJuICgoX2EgPSBjVmlldyA9PT0gbnVsbCB8fCBjVmlldyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY1ZpZXcucm9vdFZpZXcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS52aWV3KSB8fCBudWxsO1xuICAgIH1cbn1cbi8qKlxuRmFjZXQgdG8gYWRkIGEgW3N0eWxlXG5tb2R1bGVdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJpam5oL3N0eWxlLW1vZCNkb2N1bWVudGF0aW9uKSB0b1xuYW4gZWRpdG9yIHZpZXcuIFRoZSB2aWV3IHdpbGwgZW5zdXJlIHRoYXQgdGhlIG1vZHVsZSBpc1xubW91bnRlZCBpbiBpdHMgW2RvY3VtZW50XG5yb290XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5jb25zdHJ1Y3Rvcl5jb25maWcucm9vdCkuXG4qL1xuRWRpdG9yVmlldy5zdHlsZU1vZHVsZSA9IHN0eWxlTW9kdWxlO1xuLyoqXG5BbiBpbnB1dCBoYW5kbGVyIGNhbiBvdmVycmlkZSB0aGUgd2F5IGNoYW5nZXMgdG8gdGhlIGVkaXRhYmxlXG5ET00gY29udGVudCBhcmUgaGFuZGxlZC4gSGFuZGxlcnMgYXJlIHBhc3NlZCB0aGUgZG9jdW1lbnRcbnBvc2l0aW9ucyBiZXR3ZWVuIHdoaWNoIHRoZSBjaGFuZ2Ugd2FzIGZvdW5kLCBhbmQgdGhlIG5ld1xuY29udGVudC4gV2hlbiBvbmUgcmV0dXJucyB0cnVlLCBubyBmdXJ0aGVyIGlucHV0IGhhbmRsZXJzIGFyZVxuY2FsbGVkIGFuZCB0aGUgZGVmYXVsdCBiZWhhdmlvciBpcyBwcmV2ZW50ZWQuXG5cblRoZSBgaW5zZXJ0YCBhcmd1bWVudCBjYW4gYmUgdXNlZCB0byBnZXQgdGhlIGRlZmF1bHQgdHJhbnNhY3Rpb25cbnRoYXQgd291bGQgYmUgYXBwbGllZCBmb3IgdGhpcyBpbnB1dC4gVGhpcyBjYW4gYmUgdXNlZnVsIHdoZW5cbmRpc3BhdGNoaW5nIHRoZSBjdXN0b20gYmVoYXZpb3IgYXMgYSBzZXBhcmF0ZSB0cmFuc2FjdGlvbi5cbiovXG5FZGl0b3JWaWV3LmlucHV0SGFuZGxlciA9IGlucHV0SGFuZGxlcjtcbi8qKlxuVGhpcyBmYWNldCBjYW4gYmUgdXNlZCB0byBwcm92aWRlIGZ1bmN0aW9ucyB0aGF0IGNyZWF0ZSBlZmZlY3RzXG50byBiZSBkaXNwYXRjaGVkIHdoZW4gdGhlIGVkaXRvcidzIGZvY3VzIHN0YXRlIGNoYW5nZXMuXG4qL1xuRWRpdG9yVmlldy5mb2N1c0NoYW5nZUVmZmVjdCA9IGZvY3VzQ2hhbmdlRWZmZWN0O1xuLyoqXG5CeSBkZWZhdWx0LCB0aGUgZWRpdG9yIGFzc3VtZXMgYWxsIGl0cyBjb250ZW50IGhhcyB0aGUgc2FtZVxuW3RleHQgZGlyZWN0aW9uXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRGlyZWN0aW9uKS4gQ29uZmlndXJlIHRoaXMgd2l0aCBhIGB0cnVlYFxudmFsdWUgdG8gbWFrZSBpdCByZWFkIHRoZSB0ZXh0IGRpcmVjdGlvbiBvZiBldmVyeSAocmVuZGVyZWQpXG5saW5lIHNlcGFyYXRlbHkuXG4qL1xuRWRpdG9yVmlldy5wZXJMaW5lVGV4dERpcmVjdGlvbiA9IHBlckxpbmVUZXh0RGlyZWN0aW9uO1xuLyoqXG5BbGxvd3MgeW91IHRvIHByb3ZpZGUgYSBmdW5jdGlvbiB0aGF0IHNob3VsZCBiZSBjYWxsZWQgd2hlbiB0aGVcbmxpYnJhcnkgY2F0Y2hlcyBhbiBleGNlcHRpb24gZnJvbSBhbiBleHRlbnNpb24gKG1vc3RseSBmcm9tIHZpZXdcbnBsdWdpbnMsIGJ1dCBtYXkgYmUgdXNlZCBieSBvdGhlciBleHRlbnNpb25zIHRvIHJvdXRlIGV4Y2VwdGlvbnNcbmZyb20gdXNlci1jb2RlLXByb3ZpZGVkIGNhbGxiYWNrcykuIFRoaXMgaXMgbW9zdGx5IHVzZWZ1bCBmb3JcbmRlYnVnZ2luZyBhbmQgbG9nZ2luZy4gU2VlIFtgbG9nRXhjZXB0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LmxvZ0V4Y2VwdGlvbikuXG4qL1xuRWRpdG9yVmlldy5leGNlcHRpb25TaW5rID0gZXhjZXB0aW9uU2luaztcbi8qKlxuQSBmYWNldCB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlZ2lzdGVyIGEgZnVuY3Rpb24gdG8gYmUgY2FsbGVkXG5ldmVyeSB0aW1lIHRoZSB2aWV3IHVwZGF0ZXMuXG4qL1xuRWRpdG9yVmlldy51cGRhdGVMaXN0ZW5lciA9IHVwZGF0ZUxpc3RlbmVyO1xuLyoqXG5GYWNldCB0aGF0IGNvbnRyb2xzIHdoZXRoZXIgdGhlIGVkaXRvciBjb250ZW50IERPTSBpcyBlZGl0YWJsZS5cbldoZW4gaXRzIGhpZ2hlc3QtcHJlY2VkZW5jZSB2YWx1ZSBpcyBgZmFsc2VgLCB0aGUgZWxlbWVudCB3aWxsXG5ub3QgaGF2ZSBpdHMgYGNvbnRlbnRlZGl0YWJsZWAgYXR0cmlidXRlIHNldC4gKE5vdGUgdGhhdCB0aGlzXG5kb2Vzbid0IGFmZmVjdCBBUEkgY2FsbHMgdGhhdCBjaGFuZ2UgdGhlIGVkaXRvciBjb250ZW50LCBldmVuXG53aGVuIHRob3NlIGFyZSBib3VuZCB0byBrZXlzIG9yIGJ1dHRvbnMuIFNlZSB0aGVcbltgcmVhZE9ubHlgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLnJlYWRPbmx5KSBmYWNldCBmb3IgdGhhdC4pXG4qL1xuRWRpdG9yVmlldy5lZGl0YWJsZSA9IGVkaXRhYmxlO1xuLyoqXG5BbGxvd3MgeW91IHRvIGluZmx1ZW5jZSB0aGUgd2F5IG1vdXNlIHNlbGVjdGlvbiBoYXBwZW5zLiBUaGVcbmZ1bmN0aW9ucyBpbiB0aGlzIGZhY2V0IHdpbGwgYmUgY2FsbGVkIGZvciBhIGBtb3VzZWRvd25gIGV2ZW50XG5vbiB0aGUgZWRpdG9yLCBhbmQgY2FuIHJldHVybiBhbiBvYmplY3QgdGhhdCBvdmVycmlkZXMgdGhlIHdheSBhXG5zZWxlY3Rpb24gaXMgY29tcHV0ZWQgZnJvbSB0aGF0IG1vdXNlIGNsaWNrIG9yIGRyYWcuXG4qL1xuRWRpdG9yVmlldy5tb3VzZVNlbGVjdGlvblN0eWxlID0gbW91c2VTZWxlY3Rpb25TdHlsZTtcbi8qKlxuRmFjZXQgdXNlZCB0byBjb25maWd1cmUgd2hldGhlciBhIGdpdmVuIHNlbGVjdGlvbiBkcmFnIGV2ZW50XG5zaG91bGQgbW92ZSBvciBjb3B5IHRoZSBzZWxlY3Rpb24uIFRoZSBnaXZlbiBwcmVkaWNhdGUgd2lsbCBiZVxuY2FsbGVkIHdpdGggdGhlIGBtb3VzZWRvd25gIGV2ZW50LCBhbmQgY2FuIHJldHVybiBgdHJ1ZWAgd2hlblxudGhlIGRyYWcgc2hvdWxkIG1vdmUgdGhlIGNvbnRlbnQuXG4qL1xuRWRpdG9yVmlldy5kcmFnTW92ZXNTZWxlY3Rpb24gPSBkcmFnTW92ZXNTZWxlY3Rpb24kMTtcbi8qKlxuRmFjZXQgdXNlZCB0byBjb25maWd1cmUgd2hldGhlciBhIGdpdmVuIHNlbGVjdGluZyBjbGljayBhZGRzIGFcbm5ldyByYW5nZSB0byB0aGUgZXhpc3Rpbmcgc2VsZWN0aW9uIG9yIHJlcGxhY2VzIGl0IGVudGlyZWx5LiBUaGVcbmRlZmF1bHQgYmVoYXZpb3IgaXMgdG8gY2hlY2sgYGV2ZW50Lm1ldGFLZXlgIG9uIG1hY09TLCBhbmRcbmBldmVudC5jdHJsS2V5YCBlbHNld2hlcmUuXG4qL1xuRWRpdG9yVmlldy5jbGlja0FkZHNTZWxlY3Rpb25SYW5nZSA9IGNsaWNrQWRkc1NlbGVjdGlvblJhbmdlO1xuLyoqXG5BIGZhY2V0IHRoYXQgZGV0ZXJtaW5lcyB3aGljaCBbZGVjb3JhdGlvbnNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5EZWNvcmF0aW9uKVxuYXJlIHNob3duIGluIHRoZSB2aWV3LiBEZWNvcmF0aW9ucyBjYW4gYmUgcHJvdmlkZWQgaW4gdHdvXG53YXlz4oCUZGlyZWN0bHksIG9yIHZpYSBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYW4gZWRpdG9yIHZpZXcuXG5cbk9ubHkgZGVjb3JhdGlvbiBzZXRzIHByb3ZpZGVkIGRpcmVjdGx5IGFyZSBhbGxvd2VkIHRvIGluZmx1ZW5jZVxudGhlIGVkaXRvcidzIHZlcnRpY2FsIGxheW91dCBzdHJ1Y3R1cmUuIFRoZSBvbmVzIHByb3ZpZGVkIGFzXG5mdW5jdGlvbnMgYXJlIGNhbGxlZCBfYWZ0ZXJfIHRoZSBuZXcgdmlld3BvcnQgaGFzIGJlZW4gY29tcHV0ZWQsXG5hbmQgdGh1cyAqKm11c3Qgbm90KiogaW50cm9kdWNlIGJsb2NrIHdpZGdldHMgb3IgcmVwbGFjaW5nXG5kZWNvcmF0aW9ucyB0aGF0IGNvdmVyIGxpbmUgYnJlYWtzLlxuXG5JZiB5b3Ugd2FudCBkZWNvcmF0ZWQgcmFuZ2VzIHRvIGJlaGF2ZSBsaWtlIGF0b21pYyB1bml0cyBmb3JcbmN1cnNvciBtb3Rpb24gYW5kIGRlbGV0aW9uIHB1cnBvc2VzLCBhbHNvIHByb3ZpZGUgdGhlIHJhbmdlIHNldFxuY29udGFpbmluZyB0aGUgZGVjb3JhdGlvbnMgdG9cbltgRWRpdG9yVmlldy5hdG9taWNSYW5nZXNgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlld15hdG9taWNSYW5nZXMpLlxuKi9cbkVkaXRvclZpZXcuZGVjb3JhdGlvbnMgPSBkZWNvcmF0aW9ucztcbi8qKlxuVXNlZCB0byBwcm92aWRlIHJhbmdlcyB0aGF0IHNob3VsZCBiZSB0cmVhdGVkIGFzIGF0b21zIGFzIGZhciBhc1xuY3Vyc29yIG1vdGlvbiBpcyBjb25jZXJuZWQuIFRoaXMgY2F1c2VzIG1ldGhvZHMgbGlrZVxuW2Btb3ZlQnlDaGFyYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcubW92ZUJ5Q2hhcikgYW5kXG5bYG1vdmVWZXJ0aWNhbGx5YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcubW92ZVZlcnRpY2FsbHkpIChhbmQgdGhlXG5jb21tYW5kcyBidWlsdCBvbiB0b3Agb2YgdGhlbSkgdG8gc2tpcCBhY3Jvc3Mgc3VjaCByZWdpb25zIHdoZW5cbmEgc2VsZWN0aW9uIGVuZHBvaW50IHdvdWxkIGVudGVyIHRoZW0uIFRoaXMgZG9lcyBfbm90XyBwcmV2ZW50XG5kaXJlY3QgcHJvZ3JhbW1hdGljIFtzZWxlY3Rpb25cbnVwZGF0ZXNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjLnNlbGVjdGlvbikgZnJvbSBtb3ZpbmcgaW50byBzdWNoXG5yZWdpb25zLlxuKi9cbkVkaXRvclZpZXcuYXRvbWljUmFuZ2VzID0gYXRvbWljUmFuZ2VzO1xuLyoqXG5XaGVuIHJhbmdlIGRlY29yYXRpb25zIGFkZCBhIGB1bmljb2RlLWJpZGk6IGlzb2xhdGVgIHN0eWxlLCB0aGV5XG5zaG91bGQgYWxzbyBpbmNsdWRlIGFcbltgYmlkaUlzb2xhdGVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuTWFya0RlY29yYXRpb25TcGVjLmJpZGlJc29sYXRlKSBwcm9wZXJ0eVxuaW4gdGhlaXIgZGVjb3JhdGlvbiBzcGVjLCBhbmQgYmUgZXhwb3NlZCB0aHJvdWdoIHRoaXMgZmFjZXQsIHNvXG50aGF0IHRoZSBlZGl0b3IgY2FuIGNvbXB1dGUgdGhlIHByb3BlciB0ZXh0IG9yZGVyLiAoT3RoZXIgdmFsdWVzXG5mb3IgYHVuaWNvZGUtYmlkaWAsIGV4Y2VwdCBvZiBjb3Vyc2UgYG5vcm1hbGAsIGFyZSBub3RcbnN1cHBvcnRlZC4pXG4qL1xuRWRpdG9yVmlldy5iaWRpSXNvbGF0ZWRSYW5nZXMgPSBiaWRpSXNvbGF0ZWRSYW5nZXM7XG4vKipcbkZhY2V0IHRoYXQgYWxsb3dzIGV4dGVuc2lvbnMgdG8gcHJvdmlkZSBhZGRpdGlvbmFsIHNjcm9sbFxubWFyZ2lucyAoc3BhY2UgYXJvdW5kIHRoZSBzaWRlcyBvZiB0aGUgc2Nyb2xsaW5nIGVsZW1lbnQgdGhhdFxuc2hvdWxkIGJlIGNvbnNpZGVyZWQgaW52aXNpYmxlKS4gVGhpcyBjYW4gYmUgdXNlZnVsIHdoZW4gdGhlXG5wbHVnaW4gaW50cm9kdWNlcyBlbGVtZW50cyB0aGF0IGNvdmVyIHBhcnQgb2YgdGhhdCBlbGVtZW50IChmb3JcbmV4YW1wbGUgYSBob3Jpem9udGFsbHkgZml4ZWQgZ3V0dGVyKS5cbiovXG5FZGl0b3JWaWV3LnNjcm9sbE1hcmdpbnMgPSBzY3JvbGxNYXJnaW5zO1xuLyoqXG5UaGlzIGZhY2V0IHJlY29yZHMgd2hldGhlciBhIGRhcmsgdGhlbWUgaXMgYWN0aXZlLiBUaGUgZXh0ZW5zaW9uXG5yZXR1cm5lZCBieSBbYHRoZW1lYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXdedGhlbWUpIGF1dG9tYXRpY2FsbHlcbmluY2x1ZGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgd2hlbiB0aGUgYGRhcmtgIG9wdGlvbiBpcyBzZXQgdG9cbnRydWUuXG4qL1xuRWRpdG9yVmlldy5kYXJrVGhlbWUgPSBkYXJrVGhlbWU7XG4vKipcblByb3ZpZGVzIGEgQ29udGVudCBTZWN1cml0eSBQb2xpY3kgbm9uY2UgdG8gdXNlIHdoZW4gY3JlYXRpbmdcbnRoZSBzdHlsZSBzaGVldHMgZm9yIHRoZSBlZGl0b3IuIEhvbGRzIHRoZSBlbXB0eSBzdHJpbmcgd2hlbiBub1xubm9uY2UgaGFzIGJlZW4gcHJvdmlkZWQuXG4qL1xuRWRpdG9yVmlldy5jc3BOb25jZSA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoeyBjb21iaW5lOiB2YWx1ZXMgPT4gdmFsdWVzLmxlbmd0aCA/IHZhbHVlc1swXSA6IFwiXCIgfSk7XG4vKipcbkZhY2V0IHRoYXQgcHJvdmlkZXMgYWRkaXRpb25hbCBET00gYXR0cmlidXRlcyBmb3IgdGhlIGVkaXRvcidzXG5lZGl0YWJsZSBET00gZWxlbWVudC5cbiovXG5FZGl0b3JWaWV3LmNvbnRlbnRBdHRyaWJ1dGVzID0gY29udGVudEF0dHJpYnV0ZXM7XG4vKipcbkZhY2V0IHRoYXQgcHJvdmlkZXMgRE9NIGF0dHJpYnV0ZXMgZm9yIHRoZSBlZGl0b3IncyBvdXRlclxuZWxlbWVudC5cbiovXG5FZGl0b3JWaWV3LmVkaXRvckF0dHJpYnV0ZXMgPSBlZGl0b3JBdHRyaWJ1dGVzO1xuLyoqXG5BbiBleHRlbnNpb24gdGhhdCBlbmFibGVzIGxpbmUgd3JhcHBpbmcgaW4gdGhlIGVkaXRvciAoYnlcbnNldHRpbmcgQ1NTIGB3aGl0ZS1zcGFjZWAgdG8gYHByZS13cmFwYCBpbiB0aGUgY29udGVudCkuXG4qL1xuRWRpdG9yVmlldy5saW5lV3JhcHBpbmcgPSAvKkBfX1BVUkVfXyovRWRpdG9yVmlldy5jb250ZW50QXR0cmlidXRlcy5vZih7IFwiY2xhc3NcIjogXCJjbS1saW5lV3JhcHBpbmdcIiB9KTtcbi8qKlxuU3RhdGUgZWZmZWN0IHVzZWQgdG8gaW5jbHVkZSBzY3JlZW4gcmVhZGVyIGFubm91bmNlbWVudHMgaW4gYVxudHJhbnNhY3Rpb24uIFRoZXNlIHdpbGwgYmUgYWRkZWQgdG8gdGhlIERPTSBpbiBhIHZpc3VhbGx5IGhpZGRlblxuZWxlbWVudCB3aXRoIGBhcmlhLWxpdmU9XCJwb2xpdGVcImAgc2V0LCBhbmQgc2hvdWxkIGJlIHVzZWQgdG9cbmRlc2NyaWJlIGVmZmVjdHMgdGhhdCBhcmUgdmlzdWFsbHkgb2J2aW91cyBidXQgbWF5IG5vdCBiZVxubm90aWNlZCBieSBzY3JlZW4gcmVhZGVyIHVzZXJzIChzdWNoIGFzIG1vdmluZyB0byB0aGUgbmV4dFxuc2VhcmNoIG1hdGNoKS5cbiovXG5FZGl0b3JWaWV3LmFubm91bmNlID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSgpO1xuLy8gTWF4aW11bSBsaW5lIGxlbmd0aCBmb3Igd2hpY2ggd2UgY29tcHV0ZSBhY2N1cmF0ZSBiaWRpIGluZm9cbmNvbnN0IE1heEJpZGlMaW5lID0gNDA5NjtcbmNvbnN0IEJhZE1lYXN1cmUgPSB7fTtcbmNsYXNzIENhY2hlZE9yZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihmcm9tLCB0bywgZGlyLCBpc29sYXRlcywgZnJlc2gsIG9yZGVyKSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy5kaXIgPSBkaXI7XG4gICAgICAgIHRoaXMuaXNvbGF0ZXMgPSBpc29sYXRlcztcbiAgICAgICAgdGhpcy5mcmVzaCA9IGZyZXNoO1xuICAgICAgICB0aGlzLm9yZGVyID0gb3JkZXI7XG4gICAgfVxuICAgIHN0YXRpYyB1cGRhdGUoY2FjaGUsIGNoYW5nZXMpIHtcbiAgICAgICAgaWYgKGNoYW5nZXMuZW1wdHkgJiYgIWNhY2hlLnNvbWUoYyA9PiBjLmZyZXNoKSlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdLCBsYXN0RGlyID0gY2FjaGUubGVuZ3RoID8gY2FjaGVbY2FjaGUubGVuZ3RoIC0gMV0uZGlyIDogRGlyZWN0aW9uLkxUUjtcbiAgICAgICAgZm9yIChsZXQgaSA9IE1hdGgubWF4KDAsIGNhY2hlLmxlbmd0aCAtIDEwKTsgaSA8IGNhY2hlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgZW50cnkgPSBjYWNoZVtpXTtcbiAgICAgICAgICAgIGlmIChlbnRyeS5kaXIgPT0gbGFzdERpciAmJiAhY2hhbmdlcy50b3VjaGVzUmFuZ2UoZW50cnkuZnJvbSwgZW50cnkudG8pKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyBDYWNoZWRPcmRlcihjaGFuZ2VzLm1hcFBvcyhlbnRyeS5mcm9tLCAxKSwgY2hhbmdlcy5tYXBQb3MoZW50cnkudG8sIC0xKSwgZW50cnkuZGlyLCBlbnRyeS5pc29sYXRlcywgZmFsc2UsIGVudHJ5Lm9yZGVyKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5mdW5jdGlvbiBhdHRyc0Zyb21GYWNldCh2aWV3LCBmYWNldCwgYmFzZSkge1xuICAgIGZvciAobGV0IHNvdXJjZXMgPSB2aWV3LnN0YXRlLmZhY2V0KGZhY2V0KSwgaSA9IHNvdXJjZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgbGV0IHNvdXJjZSA9IHNvdXJjZXNbaV0sIHZhbHVlID0gdHlwZW9mIHNvdXJjZSA9PSBcImZ1bmN0aW9uXCIgPyBzb3VyY2UodmlldykgOiBzb3VyY2U7XG4gICAgICAgIGlmICh2YWx1ZSlcbiAgICAgICAgICAgIGNvbWJpbmVBdHRycyh2YWx1ZSwgYmFzZSk7XG4gICAgfVxuICAgIHJldHVybiBiYXNlO1xufVxuXG5jb25zdCBjdXJyZW50UGxhdGZvcm0gPSBicm93c2VyLm1hYyA/IFwibWFjXCIgOiBicm93c2VyLndpbmRvd3MgPyBcIndpblwiIDogYnJvd3Nlci5saW51eCA/IFwibGludXhcIiA6IFwia2V5XCI7XG5mdW5jdGlvbiBub3JtYWxpemVLZXlOYW1lKG5hbWUsIHBsYXRmb3JtKSB7XG4gICAgY29uc3QgcGFydHMgPSBuYW1lLnNwbGl0KC8tKD8hJCkvKTtcbiAgICBsZXQgcmVzdWx0ID0gcGFydHNbcGFydHMubGVuZ3RoIC0gMV07XG4gICAgaWYgKHJlc3VsdCA9PSBcIlNwYWNlXCIpXG4gICAgICAgIHJlc3VsdCA9IFwiIFwiO1xuICAgIGxldCBhbHQsIGN0cmwsIHNoaWZ0LCBtZXRhO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgICAgIGNvbnN0IG1vZCA9IHBhcnRzW2ldO1xuICAgICAgICBpZiAoL14oY21kfG1ldGF8bSkkL2kudGVzdChtb2QpKVxuICAgICAgICAgICAgbWV0YSA9IHRydWU7XG4gICAgICAgIGVsc2UgaWYgKC9eYShsdCk/JC9pLnRlc3QobW9kKSlcbiAgICAgICAgICAgIGFsdCA9IHRydWU7XG4gICAgICAgIGVsc2UgaWYgKC9eKGN8Y3RybHxjb250cm9sKSQvaS50ZXN0KG1vZCkpXG4gICAgICAgICAgICBjdHJsID0gdHJ1ZTtcbiAgICAgICAgZWxzZSBpZiAoL15zKGhpZnQpPyQvaS50ZXN0KG1vZCkpXG4gICAgICAgICAgICBzaGlmdCA9IHRydWU7XG4gICAgICAgIGVsc2UgaWYgKC9ebW9kJC9pLnRlc3QobW9kKSkge1xuICAgICAgICAgICAgaWYgKHBsYXRmb3JtID09IFwibWFjXCIpXG4gICAgICAgICAgICAgICAgbWV0YSA9IHRydWU7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgY3RybCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5yZWNvZ25pemVkIG1vZGlmaWVyIG5hbWU6IFwiICsgbW9kKTtcbiAgICB9XG4gICAgaWYgKGFsdClcbiAgICAgICAgcmVzdWx0ID0gXCJBbHQtXCIgKyByZXN1bHQ7XG4gICAgaWYgKGN0cmwpXG4gICAgICAgIHJlc3VsdCA9IFwiQ3RybC1cIiArIHJlc3VsdDtcbiAgICBpZiAobWV0YSlcbiAgICAgICAgcmVzdWx0ID0gXCJNZXRhLVwiICsgcmVzdWx0O1xuICAgIGlmIChzaGlmdClcbiAgICAgICAgcmVzdWx0ID0gXCJTaGlmdC1cIiArIHJlc3VsdDtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gbW9kaWZpZXJzKG5hbWUsIGV2ZW50LCBzaGlmdCkge1xuICAgIGlmIChldmVudC5hbHRLZXkpXG4gICAgICAgIG5hbWUgPSBcIkFsdC1cIiArIG5hbWU7XG4gICAgaWYgKGV2ZW50LmN0cmxLZXkpXG4gICAgICAgIG5hbWUgPSBcIkN0cmwtXCIgKyBuYW1lO1xuICAgIGlmIChldmVudC5tZXRhS2V5KVxuICAgICAgICBuYW1lID0gXCJNZXRhLVwiICsgbmFtZTtcbiAgICBpZiAoc2hpZnQgIT09IGZhbHNlICYmIGV2ZW50LnNoaWZ0S2V5KVxuICAgICAgICBuYW1lID0gXCJTaGlmdC1cIiArIG5hbWU7XG4gICAgcmV0dXJuIG5hbWU7XG59XG5jb25zdCBoYW5kbGVLZXlFdmVudHMgPSAvKkBfX1BVUkVfXyovUHJlYy5kZWZhdWx0KC8qQF9fUFVSRV9fKi9FZGl0b3JWaWV3LmRvbUV2ZW50SGFuZGxlcnMoe1xuICAgIGtleWRvd24oZXZlbnQsIHZpZXcpIHtcbiAgICAgICAgcmV0dXJuIHJ1bkhhbmRsZXJzKGdldEtleW1hcCh2aWV3LnN0YXRlKSwgZXZlbnQsIHZpZXcsIFwiZWRpdG9yXCIpO1xuICAgIH1cbn0pKTtcbi8qKlxuRmFjZXQgdXNlZCBmb3IgcmVnaXN0ZXJpbmcga2V5bWFwcy5cblxuWW91IGNhbiBhZGQgbXVsdGlwbGUga2V5bWFwcyB0byBhbiBlZGl0b3IuIFRoZWlyIHByaW9yaXRpZXNcbmRldGVybWluZSB0aGVpciBwcmVjZWRlbmNlICh0aGUgb25lcyBzcGVjaWZpZWQgZWFybHkgb3Igd2l0aCBoaWdoXG5wcmlvcml0eSBnZXQgY2hlY2tlZCBmaXJzdCkuIFdoZW4gYSBoYW5kbGVyIGhhcyByZXR1cm5lZCBgdHJ1ZWBcbmZvciBhIGdpdmVuIGtleSwgbm8gZnVydGhlciBoYW5kbGVycyBhcmUgY2FsbGVkLlxuKi9cbmNvbnN0IGtleW1hcCA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoeyBlbmFibGVzOiBoYW5kbGVLZXlFdmVudHMgfSk7XG5jb25zdCBLZXltYXBzID0gLypAX19QVVJFX18qL25ldyBXZWFrTWFwKCk7XG4vLyBUaGlzIGlzIGhpZGRlbiBiZWhpbmQgYW4gaW5kaXJlY3Rpb24sIHJhdGhlciB0aGFuIGRpcmVjdGx5IGNvbXB1dGVkXG4vLyBieSB0aGUgZmFjZXQsIHRvIGtlZXAgaW50ZXJuYWwgdHlwZXMgb3V0IG9mIHRoZSBmYWNldCdzIHR5cGUuXG5mdW5jdGlvbiBnZXRLZXltYXAoc3RhdGUpIHtcbiAgICBsZXQgYmluZGluZ3MgPSBzdGF0ZS5mYWNldChrZXltYXApO1xuICAgIGxldCBtYXAgPSBLZXltYXBzLmdldChiaW5kaW5ncyk7XG4gICAgaWYgKCFtYXApXG4gICAgICAgIEtleW1hcHMuc2V0KGJpbmRpbmdzLCBtYXAgPSBidWlsZEtleW1hcChiaW5kaW5ncy5yZWR1Y2UoKGEsIGIpID0+IGEuY29uY2F0KGIpLCBbXSkpKTtcbiAgICByZXR1cm4gbWFwO1xufVxuLyoqXG5SdW4gdGhlIGtleSBoYW5kbGVycyByZWdpc3RlcmVkIGZvciBhIGdpdmVuIHNjb3BlLiBUaGUgZXZlbnRcbm9iamVjdCBzaG91bGQgYmUgYSBgXCJrZXlkb3duXCJgIGV2ZW50LiBSZXR1cm5zIHRydWUgaWYgYW55IG9mIHRoZVxuaGFuZGxlcnMgaGFuZGxlZCBpdC5cbiovXG5mdW5jdGlvbiBydW5TY29wZUhhbmRsZXJzKHZpZXcsIGV2ZW50LCBzY29wZSkge1xuICAgIHJldHVybiBydW5IYW5kbGVycyhnZXRLZXltYXAodmlldy5zdGF0ZSksIGV2ZW50LCB2aWV3LCBzY29wZSk7XG59XG5sZXQgc3RvcmVkUHJlZml4ID0gbnVsbDtcbmNvbnN0IFByZWZpeFRpbWVvdXQgPSA0MDAwO1xuZnVuY3Rpb24gYnVpbGRLZXltYXAoYmluZGluZ3MsIHBsYXRmb3JtID0gY3VycmVudFBsYXRmb3JtKSB7XG4gICAgbGV0IGJvdW5kID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBsZXQgaXNQcmVmaXggPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGxldCBjaGVja1ByZWZpeCA9IChuYW1lLCBpcykgPT4ge1xuICAgICAgICBsZXQgY3VycmVudCA9IGlzUHJlZml4W25hbWVdO1xuICAgICAgICBpZiAoY3VycmVudCA9PSBudWxsKVxuICAgICAgICAgICAgaXNQcmVmaXhbbmFtZV0gPSBpcztcbiAgICAgICAgZWxzZSBpZiAoY3VycmVudCAhPSBpcylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIktleSBiaW5kaW5nIFwiICsgbmFtZSArIFwiIGlzIHVzZWQgYm90aCBhcyBhIHJlZ3VsYXIgYmluZGluZyBhbmQgYXMgYSBtdWx0aS1zdHJva2UgcHJlZml4XCIpO1xuICAgIH07XG4gICAgbGV0IGFkZCA9IChzY29wZSwga2V5LCBjb21tYW5kLCBwcmV2ZW50RGVmYXVsdCwgc3RvcFByb3BhZ2F0aW9uKSA9PiB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGxldCBzY29wZU9iaiA9IGJvdW5kW3Njb3BlXSB8fCAoYm91bmRbc2NvcGVdID0gT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gICAgICAgIGxldCBwYXJ0cyA9IGtleS5zcGxpdCgvICg/ISQpLykubWFwKGsgPT4gbm9ybWFsaXplS2V5TmFtZShrLCBwbGF0Zm9ybSkpO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcHJlZml4ID0gcGFydHMuc2xpY2UoMCwgaSkuam9pbihcIiBcIik7XG4gICAgICAgICAgICBjaGVja1ByZWZpeChwcmVmaXgsIHRydWUpO1xuICAgICAgICAgICAgaWYgKCFzY29wZU9ialtwcmVmaXhdKVxuICAgICAgICAgICAgICAgIHNjb3BlT2JqW3ByZWZpeF0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZlbnREZWZhdWx0OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBzdG9wUHJvcGFnYXRpb246IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBydW46IFsodmlldykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBvdXJPYmogPSBzdG9yZWRQcmVmaXggPSB7IHZpZXcsIHByZWZpeCwgc2NvcGUgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHsgaWYgKHN0b3JlZFByZWZpeCA9PSBvdXJPYmopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlZFByZWZpeCA9IG51bGw7IH0sIFByZWZpeFRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGxldCBmdWxsID0gcGFydHMuam9pbihcIiBcIik7XG4gICAgICAgIGNoZWNrUHJlZml4KGZ1bGwsIGZhbHNlKTtcbiAgICAgICAgbGV0IGJpbmRpbmcgPSBzY29wZU9ialtmdWxsXSB8fCAoc2NvcGVPYmpbZnVsbF0gPSB7XG4gICAgICAgICAgICBwcmV2ZW50RGVmYXVsdDogZmFsc2UsXG4gICAgICAgICAgICBzdG9wUHJvcGFnYXRpb246IGZhbHNlLFxuICAgICAgICAgICAgcnVuOiAoKF9iID0gKF9hID0gc2NvcGVPYmouX2FueSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJ1bikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNsaWNlKCkpIHx8IFtdXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoY29tbWFuZClcbiAgICAgICAgICAgIGJpbmRpbmcucnVuLnB1c2goY29tbWFuZCk7XG4gICAgICAgIGlmIChwcmV2ZW50RGVmYXVsdClcbiAgICAgICAgICAgIGJpbmRpbmcucHJldmVudERlZmF1bHQgPSB0cnVlO1xuICAgICAgICBpZiAoc3RvcFByb3BhZ2F0aW9uKVxuICAgICAgICAgICAgYmluZGluZy5zdG9wUHJvcGFnYXRpb24gPSB0cnVlO1xuICAgIH07XG4gICAgZm9yIChsZXQgYiBvZiBiaW5kaW5ncykge1xuICAgICAgICBsZXQgc2NvcGVzID0gYi5zY29wZSA/IGIuc2NvcGUuc3BsaXQoXCIgXCIpIDogW1wiZWRpdG9yXCJdO1xuICAgICAgICBpZiAoYi5hbnkpXG4gICAgICAgICAgICBmb3IgKGxldCBzY29wZSBvZiBzY29wZXMpIHtcbiAgICAgICAgICAgICAgICBsZXQgc2NvcGVPYmogPSBib3VuZFtzY29wZV0gfHwgKGJvdW5kW3Njb3BlXSA9IE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICAgICAgICAgICAgICAgIGlmICghc2NvcGVPYmouX2FueSlcbiAgICAgICAgICAgICAgICAgICAgc2NvcGVPYmouX2FueSA9IHsgcHJldmVudERlZmF1bHQ6IGZhbHNlLCBzdG9wUHJvcGFnYXRpb246IGZhbHNlLCBydW46IFtdIH07XG4gICAgICAgICAgICAgICAgZm9yIChsZXQga2V5IGluIHNjb3BlT2JqKVxuICAgICAgICAgICAgICAgICAgICBzY29wZU9ialtrZXldLnJ1bi5wdXNoKGIuYW55KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgbGV0IG5hbWUgPSBiW3BsYXRmb3JtXSB8fCBiLmtleTtcbiAgICAgICAgaWYgKCFuYW1lKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGZvciAobGV0IHNjb3BlIG9mIHNjb3Blcykge1xuICAgICAgICAgICAgYWRkKHNjb3BlLCBuYW1lLCBiLnJ1biwgYi5wcmV2ZW50RGVmYXVsdCwgYi5zdG9wUHJvcGFnYXRpb24pO1xuICAgICAgICAgICAgaWYgKGIuc2hpZnQpXG4gICAgICAgICAgICAgICAgYWRkKHNjb3BlLCBcIlNoaWZ0LVwiICsgbmFtZSwgYi5zaGlmdCwgYi5wcmV2ZW50RGVmYXVsdCwgYi5zdG9wUHJvcGFnYXRpb24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBib3VuZDtcbn1cbmZ1bmN0aW9uIHJ1bkhhbmRsZXJzKG1hcCwgZXZlbnQsIHZpZXcsIHNjb3BlKSB7XG4gICAgbGV0IG5hbWUgPSBrZXlOYW1lKGV2ZW50KTtcbiAgICBsZXQgY2hhckNvZGUgPSBjb2RlUG9pbnRBdChuYW1lLCAwKSwgaXNDaGFyID0gY29kZVBvaW50U2l6ZShjaGFyQ29kZSkgPT0gbmFtZS5sZW5ndGggJiYgbmFtZSAhPSBcIiBcIjtcbiAgICBsZXQgcHJlZml4ID0gXCJcIiwgaGFuZGxlZCA9IGZhbHNlLCBwcmV2ZW50ZWQgPSBmYWxzZSwgc3RvcFByb3BhZ2F0aW9uID0gZmFsc2U7XG4gICAgaWYgKHN0b3JlZFByZWZpeCAmJiBzdG9yZWRQcmVmaXgudmlldyA9PSB2aWV3ICYmIHN0b3JlZFByZWZpeC5zY29wZSA9PSBzY29wZSkge1xuICAgICAgICBwcmVmaXggPSBzdG9yZWRQcmVmaXgucHJlZml4ICsgXCIgXCI7XG4gICAgICAgIGlmIChtb2RpZmllckNvZGVzLmluZGV4T2YoZXZlbnQua2V5Q29kZSkgPCAwKSB7XG4gICAgICAgICAgICBwcmV2ZW50ZWQgPSB0cnVlO1xuICAgICAgICAgICAgc3RvcmVkUHJlZml4ID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgcmFuID0gbmV3IFNldDtcbiAgICBsZXQgcnVuRm9yID0gKGJpbmRpbmcpID0+IHtcbiAgICAgICAgaWYgKGJpbmRpbmcpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGNtZCBvZiBiaW5kaW5nLnJ1bilcbiAgICAgICAgICAgICAgICBpZiAoIXJhbi5oYXMoY21kKSkge1xuICAgICAgICAgICAgICAgICAgICByYW4uYWRkKGNtZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjbWQodmlldywgZXZlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmluZGluZy5zdG9wUHJvcGFnYXRpb24pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcFByb3BhZ2F0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJpbmRpbmcucHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICBpZiAoYmluZGluZy5zdG9wUHJvcGFnYXRpb24pXG4gICAgICAgICAgICAgICAgICAgIHN0b3BQcm9wYWdhdGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgcHJldmVudGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBsZXQgc2NvcGVPYmogPSBtYXBbc2NvcGVdLCBiYXNlTmFtZSwgc2hpZnROYW1lO1xuICAgIGlmIChzY29wZU9iaikge1xuICAgICAgICBpZiAocnVuRm9yKHNjb3BlT2JqW3ByZWZpeCArIG1vZGlmaWVycyhuYW1lLCBldmVudCwgIWlzQ2hhcildKSkge1xuICAgICAgICAgICAgaGFuZGxlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNDaGFyICYmIChldmVudC5hbHRLZXkgfHwgZXZlbnQubWV0YUtleSB8fCBldmVudC5jdHJsS2V5KSAmJlxuICAgICAgICAgICAgLy8gQ3RybC1BbHQgbWF5IGJlIHVzZWQgZm9yIEFsdEdyIG9uIFdpbmRvd3NcbiAgICAgICAgICAgICEoYnJvd3Nlci53aW5kb3dzICYmIGV2ZW50LmN0cmxLZXkgJiYgZXZlbnQuYWx0S2V5KSAmJlxuICAgICAgICAgICAgKGJhc2VOYW1lID0gYmFzZVtldmVudC5rZXlDb2RlXSkgJiYgYmFzZU5hbWUgIT0gbmFtZSkge1xuICAgICAgICAgICAgaWYgKHJ1bkZvcihzY29wZU9ialtwcmVmaXggKyBtb2RpZmllcnMoYmFzZU5hbWUsIGV2ZW50LCB0cnVlKV0pKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChldmVudC5zaGlmdEtleSAmJiAoc2hpZnROYW1lID0gc2hpZnRbZXZlbnQua2V5Q29kZV0pICE9IG5hbWUgJiYgc2hpZnROYW1lICE9IGJhc2VOYW1lICYmXG4gICAgICAgICAgICAgICAgcnVuRm9yKHNjb3BlT2JqW3ByZWZpeCArIG1vZGlmaWVycyhzaGlmdE5hbWUsIGV2ZW50LCBmYWxzZSldKSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzQ2hhciAmJiBldmVudC5zaGlmdEtleSAmJlxuICAgICAgICAgICAgcnVuRm9yKHNjb3BlT2JqW3ByZWZpeCArIG1vZGlmaWVycyhuYW1lLCBldmVudCwgdHJ1ZSldKSkge1xuICAgICAgICAgICAgaGFuZGxlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFoYW5kbGVkICYmIHJ1bkZvcihzY29wZU9iai5fYW55KSlcbiAgICAgICAgICAgIGhhbmRsZWQgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAocHJldmVudGVkKVxuICAgICAgICBoYW5kbGVkID0gdHJ1ZTtcbiAgICBpZiAoaGFuZGxlZCAmJiBzdG9wUHJvcGFnYXRpb24pXG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIHJldHVybiBoYW5kbGVkO1xufVxuXG4vKipcbkltcGxlbWVudGF0aW9uIG9mIFtgTGF5ZXJNYXJrZXJgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuTGF5ZXJNYXJrZXIpIHRoYXQgY3JlYXRlc1xuYSByZWN0YW5nbGUgYXQgYSBnaXZlbiBzZXQgb2YgY29vcmRpbmF0ZXMuXG4qL1xuY2xhc3MgUmVjdGFuZ2xlTWFya2VyIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBtYXJrZXIgd2l0aCB0aGUgZ2l2ZW4gY2xhc3MgYW5kIGRpbWVuc2lvbnMuIElmIGB3aWR0aGBcbiAgICBpcyBudWxsLCB0aGUgRE9NIGVsZW1lbnQgd2lsbCBnZXQgbm8gd2lkdGggc3R5bGUuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihjbGFzc05hbWUsIFxuICAgIC8qKlxuICAgIFRoZSBsZWZ0IHBvc2l0aW9uIG9mIHRoZSBtYXJrZXIgKGluIHBpeGVscywgZG9jdW1lbnQtcmVsYXRpdmUpLlxuICAgICovXG4gICAgbGVmdCwgXG4gICAgLyoqXG4gICAgVGhlIHRvcCBwb3NpdGlvbiBvZiB0aGUgbWFya2VyLlxuICAgICovXG4gICAgdG9wLCBcbiAgICAvKipcbiAgICBUaGUgd2lkdGggb2YgdGhlIG1hcmtlciwgb3IgbnVsbCBpZiBpdCBzaG91bGRuJ3QgZ2V0IGEgd2lkdGggYXNzaWduZWQuXG4gICAgKi9cbiAgICB3aWR0aCwgXG4gICAgLyoqXG4gICAgVGhlIGhlaWdodCBvZiB0aGUgbWFya2VyLlxuICAgICovXG4gICAgaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xuICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xuICAgICAgICB0aGlzLnRvcCA9IHRvcDtcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICB9XG4gICAgZHJhdygpIHtcbiAgICAgICAgbGV0IGVsdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGVsdC5jbGFzc05hbWUgPSB0aGlzLmNsYXNzTmFtZTtcbiAgICAgICAgdGhpcy5hZGp1c3QoZWx0KTtcbiAgICAgICAgcmV0dXJuIGVsdDtcbiAgICB9XG4gICAgdXBkYXRlKGVsdCwgcHJldikge1xuICAgICAgICBpZiAocHJldi5jbGFzc05hbWUgIT0gdGhpcy5jbGFzc05hbWUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMuYWRqdXN0KGVsdCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBhZGp1c3QoZWx0KSB7XG4gICAgICAgIGVsdC5zdHlsZS5sZWZ0ID0gdGhpcy5sZWZ0ICsgXCJweFwiO1xuICAgICAgICBlbHQuc3R5bGUudG9wID0gdGhpcy50b3AgKyBcInB4XCI7XG4gICAgICAgIGlmICh0aGlzLndpZHRoICE9IG51bGwpXG4gICAgICAgICAgICBlbHQuc3R5bGUud2lkdGggPSB0aGlzLndpZHRoICsgXCJweFwiO1xuICAgICAgICBlbHQuc3R5bGUuaGVpZ2h0ID0gdGhpcy5oZWlnaHQgKyBcInB4XCI7XG4gICAgfVxuICAgIGVxKHApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVmdCA9PSBwLmxlZnQgJiYgdGhpcy50b3AgPT0gcC50b3AgJiYgdGhpcy53aWR0aCA9PSBwLndpZHRoICYmIHRoaXMuaGVpZ2h0ID09IHAuaGVpZ2h0ICYmXG4gICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9PSBwLmNsYXNzTmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgc2V0IG9mIHJlY3RhbmdsZXMgZm9yIHRoZSBnaXZlbiBzZWxlY3Rpb24gcmFuZ2UsXG4gICAgYXNzaWduaW5nIHRoZW0gdGhlY2xhc3NgY2xhc3NOYW1lYC4gV2lsbCBjcmVhdGUgYSBzaW5nbGVcbiAgICByZWN0YW5nbGUgZm9yIGVtcHR5IHJhbmdlcywgYW5kIGEgc2V0IG9mIHNlbGVjdGlvbi1zdHlsZVxuICAgIHJlY3RhbmdsZXMgY292ZXJpbmcgdGhlIHJhbmdlJ3MgY29udGVudCAoaW4gYSBiaWRpLWF3YXJlXG4gICAgd2F5KSBmb3Igbm9uLWVtcHR5IG9uZXMuXG4gICAgKi9cbiAgICBzdGF0aWMgZm9yUmFuZ2UodmlldywgY2xhc3NOYW1lLCByYW5nZSkge1xuICAgICAgICBpZiAocmFuZ2UuZW1wdHkpIHtcbiAgICAgICAgICAgIGxldCBwb3MgPSB2aWV3LmNvb3Jkc0F0UG9zKHJhbmdlLmhlYWQsIHJhbmdlLmFzc29jIHx8IDEpO1xuICAgICAgICAgICAgaWYgKCFwb3MpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgbGV0IGJhc2UgPSBnZXRCYXNlKHZpZXcpO1xuICAgICAgICAgICAgcmV0dXJuIFtuZXcgUmVjdGFuZ2xlTWFya2VyKGNsYXNzTmFtZSwgcG9zLmxlZnQgLSBiYXNlLmxlZnQsIHBvcy50b3AgLSBiYXNlLnRvcCwgbnVsbCwgcG9zLmJvdHRvbSAtIHBvcy50b3ApXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiByZWN0YW5nbGVzRm9yUmFuZ2UodmlldywgY2xhc3NOYW1lLCByYW5nZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBnZXRCYXNlKHZpZXcpIHtcbiAgICBsZXQgcmVjdCA9IHZpZXcuc2Nyb2xsRE9NLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGxldCBsZWZ0ID0gdmlldy50ZXh0RGlyZWN0aW9uID09IERpcmVjdGlvbi5MVFIgPyByZWN0LmxlZnQgOiByZWN0LnJpZ2h0IC0gdmlldy5zY3JvbGxET00uY2xpZW50V2lkdGggKiB2aWV3LnNjYWxlWDtcbiAgICByZXR1cm4geyBsZWZ0OiBsZWZ0IC0gdmlldy5zY3JvbGxET00uc2Nyb2xsTGVmdCAqIHZpZXcuc2NhbGVYLCB0b3A6IHJlY3QudG9wIC0gdmlldy5zY3JvbGxET00uc2Nyb2xsVG9wICogdmlldy5zY2FsZVkgfTtcbn1cbmZ1bmN0aW9uIHdyYXBwZWRMaW5lKHZpZXcsIHBvcywgaW5zaWRlKSB7XG4gICAgbGV0IHJhbmdlID0gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihwb3MpO1xuICAgIHJldHVybiB7IGZyb206IE1hdGgubWF4KGluc2lkZS5mcm9tLCB2aWV3Lm1vdmVUb0xpbmVCb3VuZGFyeShyYW5nZSwgZmFsc2UsIHRydWUpLmZyb20pLFxuICAgICAgICB0bzogTWF0aC5taW4oaW5zaWRlLnRvLCB2aWV3Lm1vdmVUb0xpbmVCb3VuZGFyeShyYW5nZSwgdHJ1ZSwgdHJ1ZSkuZnJvbSksXG4gICAgICAgIHR5cGU6IEJsb2NrVHlwZS5UZXh0IH07XG59XG5mdW5jdGlvbiByZWN0YW5nbGVzRm9yUmFuZ2UodmlldywgY2xhc3NOYW1lLCByYW5nZSkge1xuICAgIGlmIChyYW5nZS50byA8PSB2aWV3LnZpZXdwb3J0LmZyb20gfHwgcmFuZ2UuZnJvbSA+PSB2aWV3LnZpZXdwb3J0LnRvKVxuICAgICAgICByZXR1cm4gW107XG4gICAgbGV0IGZyb20gPSBNYXRoLm1heChyYW5nZS5mcm9tLCB2aWV3LnZpZXdwb3J0LmZyb20pLCB0byA9IE1hdGgubWluKHJhbmdlLnRvLCB2aWV3LnZpZXdwb3J0LnRvKTtcbiAgICBsZXQgbHRyID0gdmlldy50ZXh0RGlyZWN0aW9uID09IERpcmVjdGlvbi5MVFI7XG4gICAgbGV0IGNvbnRlbnQgPSB2aWV3LmNvbnRlbnRET00sIGNvbnRlbnRSZWN0ID0gY29udGVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgYmFzZSA9IGdldEJhc2Uodmlldyk7XG4gICAgbGV0IGxpbmVFbHQgPSBjb250ZW50LnF1ZXJ5U2VsZWN0b3IoXCIuY20tbGluZVwiKSwgbGluZVN0eWxlID0gbGluZUVsdCAmJiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShsaW5lRWx0KTtcbiAgICBsZXQgbGVmdFNpZGUgPSBjb250ZW50UmVjdC5sZWZ0ICtcbiAgICAgICAgKGxpbmVTdHlsZSA/IHBhcnNlSW50KGxpbmVTdHlsZS5wYWRkaW5nTGVmdCkgKyBNYXRoLm1pbigwLCBwYXJzZUludChsaW5lU3R5bGUudGV4dEluZGVudCkpIDogMCk7XG4gICAgbGV0IHJpZ2h0U2lkZSA9IGNvbnRlbnRSZWN0LnJpZ2h0IC0gKGxpbmVTdHlsZSA/IHBhcnNlSW50KGxpbmVTdHlsZS5wYWRkaW5nUmlnaHQpIDogMCk7XG4gICAgbGV0IHN0YXJ0QmxvY2sgPSBibG9ja0F0KHZpZXcsIGZyb20pLCBlbmRCbG9jayA9IGJsb2NrQXQodmlldywgdG8pO1xuICAgIGxldCB2aXN1YWxTdGFydCA9IHN0YXJ0QmxvY2sudHlwZSA9PSBCbG9ja1R5cGUuVGV4dCA/IHN0YXJ0QmxvY2sgOiBudWxsO1xuICAgIGxldCB2aXN1YWxFbmQgPSBlbmRCbG9jay50eXBlID09IEJsb2NrVHlwZS5UZXh0ID8gZW5kQmxvY2sgOiBudWxsO1xuICAgIGlmICh2aXN1YWxTdGFydCAmJiAodmlldy5saW5lV3JhcHBpbmcgfHwgc3RhcnRCbG9jay53aWRnZXRMaW5lQnJlYWtzKSlcbiAgICAgICAgdmlzdWFsU3RhcnQgPSB3cmFwcGVkTGluZSh2aWV3LCBmcm9tLCB2aXN1YWxTdGFydCk7XG4gICAgaWYgKHZpc3VhbEVuZCAmJiAodmlldy5saW5lV3JhcHBpbmcgfHwgZW5kQmxvY2sud2lkZ2V0TGluZUJyZWFrcykpXG4gICAgICAgIHZpc3VhbEVuZCA9IHdyYXBwZWRMaW5lKHZpZXcsIHRvLCB2aXN1YWxFbmQpO1xuICAgIGlmICh2aXN1YWxTdGFydCAmJiB2aXN1YWxFbmQgJiYgdmlzdWFsU3RhcnQuZnJvbSA9PSB2aXN1YWxFbmQuZnJvbSkge1xuICAgICAgICByZXR1cm4gcGllY2VzKGRyYXdGb3JMaW5lKHJhbmdlLmZyb20sIHJhbmdlLnRvLCB2aXN1YWxTdGFydCkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGV0IHRvcCA9IHZpc3VhbFN0YXJ0ID8gZHJhd0ZvckxpbmUocmFuZ2UuZnJvbSwgbnVsbCwgdmlzdWFsU3RhcnQpIDogZHJhd0ZvcldpZGdldChzdGFydEJsb2NrLCBmYWxzZSk7XG4gICAgICAgIGxldCBib3R0b20gPSB2aXN1YWxFbmQgPyBkcmF3Rm9yTGluZShudWxsLCByYW5nZS50bywgdmlzdWFsRW5kKSA6IGRyYXdGb3JXaWRnZXQoZW5kQmxvY2ssIHRydWUpO1xuICAgICAgICBsZXQgYmV0d2VlbiA9IFtdO1xuICAgICAgICBpZiAoKHZpc3VhbFN0YXJ0IHx8IHN0YXJ0QmxvY2spLnRvIDwgKHZpc3VhbEVuZCB8fCBlbmRCbG9jaykuZnJvbSAtICh2aXN1YWxTdGFydCAmJiB2aXN1YWxFbmQgPyAxIDogMCkgfHxcbiAgICAgICAgICAgIHN0YXJ0QmxvY2sud2lkZ2V0TGluZUJyZWFrcyA+IDEgJiYgdG9wLmJvdHRvbSArIHZpZXcuZGVmYXVsdExpbmVIZWlnaHQgLyAyIDwgYm90dG9tLnRvcClcbiAgICAgICAgICAgIGJldHdlZW4ucHVzaChwaWVjZShsZWZ0U2lkZSwgdG9wLmJvdHRvbSwgcmlnaHRTaWRlLCBib3R0b20udG9wKSk7XG4gICAgICAgIGVsc2UgaWYgKHRvcC5ib3R0b20gPCBib3R0b20udG9wICYmIHZpZXcuZWxlbWVudEF0SGVpZ2h0KCh0b3AuYm90dG9tICsgYm90dG9tLnRvcCkgLyAyKS50eXBlID09IEJsb2NrVHlwZS5UZXh0KVxuICAgICAgICAgICAgdG9wLmJvdHRvbSA9IGJvdHRvbS50b3AgPSAodG9wLmJvdHRvbSArIGJvdHRvbS50b3ApIC8gMjtcbiAgICAgICAgcmV0dXJuIHBpZWNlcyh0b3ApLmNvbmNhdChiZXR3ZWVuKS5jb25jYXQocGllY2VzKGJvdHRvbSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwaWVjZShsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b20pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWN0YW5nbGVNYXJrZXIoY2xhc3NOYW1lLCBsZWZ0IC0gYmFzZS5sZWZ0LCB0b3AgLSBiYXNlLnRvcCAtIDAuMDEgLyogQy5FcHNpbG9uICovLCByaWdodCAtIGxlZnQsIGJvdHRvbSAtIHRvcCArIDAuMDEgLyogQy5FcHNpbG9uICovKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGllY2VzKHsgdG9wLCBib3R0b20sIGhvcml6b250YWwgfSkge1xuICAgICAgICBsZXQgcGllY2VzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaG9yaXpvbnRhbC5sZW5ndGg7IGkgKz0gMilcbiAgICAgICAgICAgIHBpZWNlcy5wdXNoKHBpZWNlKGhvcml6b250YWxbaV0sIHRvcCwgaG9yaXpvbnRhbFtpICsgMV0sIGJvdHRvbSkpO1xuICAgICAgICByZXR1cm4gcGllY2VzO1xuICAgIH1cbiAgICAvLyBHZXRzIHBhc3NlZCBmcm9tL3RvIGluIGxpbmUtbG9jYWwgcG9zaXRpb25zXG4gICAgZnVuY3Rpb24gZHJhd0ZvckxpbmUoZnJvbSwgdG8sIGxpbmUpIHtcbiAgICAgICAgbGV0IHRvcCA9IDFlOSwgYm90dG9tID0gLTFlOSwgaG9yaXpvbnRhbCA9IFtdO1xuICAgICAgICBmdW5jdGlvbiBhZGRTcGFuKGZyb20sIGZyb21PcGVuLCB0bywgdG9PcGVuLCBkaXIpIHtcbiAgICAgICAgICAgIC8vIFBhc3NpbmcgMi8tMiBpcyBhIGtsdWRnZSB0byBmb3JjZSB0aGUgdmlldyB0byByZXR1cm5cbiAgICAgICAgICAgIC8vIGNvb3JkaW5hdGVzIG9uIHRoZSBwcm9wZXIgc2lkZSBvZiBibG9jayB3aWRnZXRzLCBzaW5jZVxuICAgICAgICAgICAgLy8gbm9ybWFsaXppbmcgdGhlIHNpZGUgdGhlcmUsIHRob3VnaCBhcHByb3ByaWF0ZSBmb3IgbW9zdFxuICAgICAgICAgICAgLy8gY29vcmRzQXRQb3MgcXVlcmllcywgd291bGQgYnJlYWsgc2VsZWN0aW9uIGRyYXdpbmcuXG4gICAgICAgICAgICBsZXQgZnJvbUNvb3JkcyA9IHZpZXcuY29vcmRzQXRQb3MoZnJvbSwgKGZyb20gPT0gbGluZS50byA/IC0yIDogMikpO1xuICAgICAgICAgICAgbGV0IHRvQ29vcmRzID0gdmlldy5jb29yZHNBdFBvcyh0bywgKHRvID09IGxpbmUuZnJvbSA/IDIgOiAtMikpO1xuICAgICAgICAgICAgaWYgKCFmcm9tQ29vcmRzIHx8ICF0b0Nvb3JkcylcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0b3AgPSBNYXRoLm1pbihmcm9tQ29vcmRzLnRvcCwgdG9Db29yZHMudG9wLCB0b3ApO1xuICAgICAgICAgICAgYm90dG9tID0gTWF0aC5tYXgoZnJvbUNvb3Jkcy5ib3R0b20sIHRvQ29vcmRzLmJvdHRvbSwgYm90dG9tKTtcbiAgICAgICAgICAgIGlmIChkaXIgPT0gRGlyZWN0aW9uLkxUUilcbiAgICAgICAgICAgICAgICBob3Jpem9udGFsLnB1c2gobHRyICYmIGZyb21PcGVuID8gbGVmdFNpZGUgOiBmcm9tQ29vcmRzLmxlZnQsIGx0ciAmJiB0b09wZW4gPyByaWdodFNpZGUgOiB0b0Nvb3Jkcy5yaWdodCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgaG9yaXpvbnRhbC5wdXNoKCFsdHIgJiYgdG9PcGVuID8gbGVmdFNpZGUgOiB0b0Nvb3Jkcy5sZWZ0LCAhbHRyICYmIGZyb21PcGVuID8gcmlnaHRTaWRlIDogZnJvbUNvb3Jkcy5yaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0YXJ0ID0gZnJvbSAhPT0gbnVsbCAmJiBmcm9tICE9PSB2b2lkIDAgPyBmcm9tIDogbGluZS5mcm9tLCBlbmQgPSB0byAhPT0gbnVsbCAmJiB0byAhPT0gdm9pZCAwID8gdG8gOiBsaW5lLnRvO1xuICAgICAgICAvLyBTcGxpdCB0aGUgcmFuZ2UgYnkgdmlzaWJsZSByYW5nZSBhbmQgZG9jdW1lbnQgbGluZVxuICAgICAgICBmb3IgKGxldCByIG9mIHZpZXcudmlzaWJsZVJhbmdlcylcbiAgICAgICAgICAgIGlmIChyLnRvID4gc3RhcnQgJiYgci5mcm9tIDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcG9zID0gTWF0aC5tYXgoci5mcm9tLCBzdGFydCksIGVuZFBvcyA9IE1hdGgubWluKHIudG8sIGVuZCk7Oykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZG9jTGluZSA9IHZpZXcuc3RhdGUuZG9jLmxpbmVBdChwb3MpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBzcGFuIG9mIHZpZXcuYmlkaVNwYW5zKGRvY0xpbmUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3BhbkZyb20gPSBzcGFuLmZyb20gKyBkb2NMaW5lLmZyb20sIHNwYW5UbyA9IHNwYW4udG8gKyBkb2NMaW5lLmZyb207XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3BhbkZyb20gPj0gZW5kUG9zKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNwYW5UbyA+IHBvcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRTcGFuKE1hdGgubWF4KHNwYW5Gcm9tLCBwb3MpLCBmcm9tID09IG51bGwgJiYgc3BhbkZyb20gPD0gc3RhcnQsIE1hdGgubWluKHNwYW5UbywgZW5kUG9zKSwgdG8gPT0gbnVsbCAmJiBzcGFuVG8gPj0gZW5kLCBzcGFuLmRpcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcG9zID0gZG9jTGluZS50byArIDE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3MgPj0gZW5kUG9zKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICBpZiAoaG9yaXpvbnRhbC5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIGFkZFNwYW4oc3RhcnQsIGZyb20gPT0gbnVsbCwgZW5kLCB0byA9PSBudWxsLCB2aWV3LnRleHREaXJlY3Rpb24pO1xuICAgICAgICByZXR1cm4geyB0b3AsIGJvdHRvbSwgaG9yaXpvbnRhbCB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBkcmF3Rm9yV2lkZ2V0KGJsb2NrLCB0b3ApIHtcbiAgICAgICAgbGV0IHkgPSBjb250ZW50UmVjdC50b3AgKyAodG9wID8gYmxvY2sudG9wIDogYmxvY2suYm90dG9tKTtcbiAgICAgICAgcmV0dXJuIHsgdG9wOiB5LCBib3R0b206IHksIGhvcml6b250YWw6IFtdIH07XG4gICAgfVxufVxuZnVuY3Rpb24gc2FtZU1hcmtlcihhLCBiKSB7XG4gICAgcmV0dXJuIGEuY29uc3RydWN0b3IgPT0gYi5jb25zdHJ1Y3RvciAmJiBhLmVxKGIpO1xufVxuY2xhc3MgTGF5ZXJWaWV3IHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3LCBsYXllcikge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLmxheWVyID0gbGF5ZXI7XG4gICAgICAgIHRoaXMuZHJhd24gPSBbXTtcbiAgICAgICAgdGhpcy5zY2FsZVggPSAxO1xuICAgICAgICB0aGlzLnNjYWxlWSA9IDE7XG4gICAgICAgIHRoaXMubWVhc3VyZVJlcSA9IHsgcmVhZDogdGhpcy5tZWFzdXJlLmJpbmQodGhpcyksIHdyaXRlOiB0aGlzLmRyYXcuYmluZCh0aGlzKSB9O1xuICAgICAgICB0aGlzLmRvbSA9IHZpZXcuc2Nyb2xsRE9NLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpO1xuICAgICAgICB0aGlzLmRvbS5jbGFzc0xpc3QuYWRkKFwiY20tbGF5ZXJcIik7XG4gICAgICAgIGlmIChsYXllci5hYm92ZSlcbiAgICAgICAgICAgIHRoaXMuZG9tLmNsYXNzTGlzdC5hZGQoXCJjbS1sYXllci1hYm92ZVwiKTtcbiAgICAgICAgaWYgKGxheWVyLmNsYXNzKVxuICAgICAgICAgICAgdGhpcy5kb20uY2xhc3NMaXN0LmFkZChsYXllci5jbGFzcyk7XG4gICAgICAgIHRoaXMuc2NhbGUoKTtcbiAgICAgICAgdGhpcy5kb20uc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgXCJ0cnVlXCIpO1xuICAgICAgICB0aGlzLnNldE9yZGVyKHZpZXcuc3RhdGUpO1xuICAgICAgICB2aWV3LnJlcXVlc3RNZWFzdXJlKHRoaXMubWVhc3VyZVJlcSk7XG4gICAgICAgIGlmIChsYXllci5tb3VudClcbiAgICAgICAgICAgIGxheWVyLm1vdW50KHRoaXMuZG9tLCB2aWV3KTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBpZiAodXBkYXRlLnN0YXJ0U3RhdGUuZmFjZXQobGF5ZXJPcmRlcikgIT0gdXBkYXRlLnN0YXRlLmZhY2V0KGxheWVyT3JkZXIpKVxuICAgICAgICAgICAgdGhpcy5zZXRPcmRlcih1cGRhdGUuc3RhdGUpO1xuICAgICAgICBpZiAodGhpcy5sYXllci51cGRhdGUodXBkYXRlLCB0aGlzLmRvbSkgfHwgdXBkYXRlLmdlb21ldHJ5Q2hhbmdlZCkge1xuICAgICAgICAgICAgdGhpcy5zY2FsZSgpO1xuICAgICAgICAgICAgdXBkYXRlLnZpZXcucmVxdWVzdE1lYXN1cmUodGhpcy5tZWFzdXJlUmVxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRPcmRlcihzdGF0ZSkge1xuICAgICAgICBsZXQgcG9zID0gMCwgb3JkZXIgPSBzdGF0ZS5mYWNldChsYXllck9yZGVyKTtcbiAgICAgICAgd2hpbGUgKHBvcyA8IG9yZGVyLmxlbmd0aCAmJiBvcmRlcltwb3NdICE9IHRoaXMubGF5ZXIpXG4gICAgICAgICAgICBwb3MrKztcbiAgICAgICAgdGhpcy5kb20uc3R5bGUuekluZGV4ID0gU3RyaW5nKCh0aGlzLmxheWVyLmFib3ZlID8gMTUwIDogLTEpIC0gcG9zKTtcbiAgICB9XG4gICAgbWVhc3VyZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGF5ZXIubWFya2Vycyh0aGlzLnZpZXcpO1xuICAgIH1cbiAgICBzY2FsZSgpIHtcbiAgICAgICAgbGV0IHsgc2NhbGVYLCBzY2FsZVkgfSA9IHRoaXMudmlldztcbiAgICAgICAgaWYgKHNjYWxlWCAhPSB0aGlzLnNjYWxlWCB8fCBzY2FsZVkgIT0gdGhpcy5zY2FsZVkpIHtcbiAgICAgICAgICAgIHRoaXMuc2NhbGVYID0gc2NhbGVYO1xuICAgICAgICAgICAgdGhpcy5zY2FsZVkgPSBzY2FsZVk7XG4gICAgICAgICAgICB0aGlzLmRvbS5zdHlsZS50cmFuc2Zvcm0gPSBgc2NhbGUoJHsxIC8gc2NhbGVYfSwgJHsxIC8gc2NhbGVZfSlgO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRyYXcobWFya2Vycykge1xuICAgICAgICBpZiAobWFya2Vycy5sZW5ndGggIT0gdGhpcy5kcmF3bi5sZW5ndGggfHwgbWFya2Vycy5zb21lKChwLCBpKSA9PiAhc2FtZU1hcmtlcihwLCB0aGlzLmRyYXduW2ldKSkpIHtcbiAgICAgICAgICAgIGxldCBvbGQgPSB0aGlzLmRvbS5maXJzdENoaWxkLCBvbGRJID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IG1hcmtlciBvZiBtYXJrZXJzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hcmtlci51cGRhdGUgJiYgb2xkICYmIG1hcmtlci5jb25zdHJ1Y3RvciAmJiB0aGlzLmRyYXduW29sZEldLmNvbnN0cnVjdG9yICYmXG4gICAgICAgICAgICAgICAgICAgIG1hcmtlci51cGRhdGUob2xkLCB0aGlzLmRyYXduW29sZEldKSkge1xuICAgICAgICAgICAgICAgICAgICBvbGQgPSBvbGQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgIG9sZEkrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9tLmluc2VydEJlZm9yZShtYXJrZXIuZHJhdygpLCBvbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChvbGQpIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IG9sZC5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICBvbGQucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgb2xkID0gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZHJhd24gPSBtYXJrZXJzO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLmxheWVyLmRlc3Ryb3kpXG4gICAgICAgICAgICB0aGlzLmxheWVyLmRlc3Ryb3kodGhpcy5kb20sIHRoaXMudmlldyk7XG4gICAgICAgIHRoaXMuZG9tLnJlbW92ZSgpO1xuICAgIH1cbn1cbmNvbnN0IGxheWVyT3JkZXIgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG4vKipcbkRlZmluZSBhIGxheWVyLlxuKi9cbmZ1bmN0aW9uIGxheWVyKGNvbmZpZykge1xuICAgIHJldHVybiBbXG4gICAgICAgIFZpZXdQbHVnaW4uZGVmaW5lKHYgPT4gbmV3IExheWVyVmlldyh2LCBjb25maWcpKSxcbiAgICAgICAgbGF5ZXJPcmRlci5vZihjb25maWcpXG4gICAgXTtcbn1cblxuY29uc3QgQ2FuSGlkZVByaW1hcnkgPSAhYnJvd3Nlci5pb3M7IC8vIEZJWE1FIHRlc3QgSUVcbmNvbnN0IHNlbGVjdGlvbkNvbmZpZyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmUoY29uZmlncykge1xuICAgICAgICByZXR1cm4gY29tYmluZUNvbmZpZyhjb25maWdzLCB7XG4gICAgICAgICAgICBjdXJzb3JCbGlua1JhdGU6IDEyMDAsXG4gICAgICAgICAgICBkcmF3UmFuZ2VDdXJzb3I6IHRydWVcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgY3Vyc29yQmxpbmtSYXRlOiAoYSwgYikgPT4gTWF0aC5taW4oYSwgYiksXG4gICAgICAgICAgICBkcmF3UmFuZ2VDdXJzb3I6IChhLCBiKSA9PiBhIHx8IGJcbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG4vKipcblJldHVybnMgYW4gZXh0ZW5zaW9uIHRoYXQgaGlkZXMgdGhlIGJyb3dzZXIncyBuYXRpdmUgc2VsZWN0aW9uIGFuZFxuY3Vyc29yLCByZXBsYWNpbmcgdGhlIHNlbGVjdGlvbiB3aXRoIGEgYmFja2dyb3VuZCBiZWhpbmQgdGhlIHRleHRcbih3aXRoIHRoZSBgY20tc2VsZWN0aW9uQmFja2dyb3VuZGAgY2xhc3MpLCBhbmQgdGhlXG5jdXJzb3JzIHdpdGggZWxlbWVudHMgb3ZlcmxhaWQgb3ZlciB0aGUgY29kZSAodXNpbmdcbmBjbS1jdXJzb3ItcHJpbWFyeWAgYW5kIGBjbS1jdXJzb3Itc2Vjb25kYXJ5YCkuXG5cblRoaXMgYWxsb3dzIHRoZSBlZGl0b3IgdG8gZGlzcGxheSBzZWNvbmRhcnkgc2VsZWN0aW9uIHJhbmdlcywgYW5kXG50ZW5kcyB0byBwcm9kdWNlIGEgdHlwZSBvZiBzZWxlY3Rpb24gbW9yZSBpbiBsaW5lIHdpdGggdGhhdCB1c2Vyc1xuZXhwZWN0IGluIGEgdGV4dCBlZGl0b3IgKHRoZSBuYXRpdmUgc2VsZWN0aW9uIHN0eWxpbmcgd2lsbCBvZnRlblxubGVhdmUgZ2FwcyBiZXR3ZWVuIGxpbmVzIGFuZCB3b24ndCBmaWxsIHRoZSBob3Jpem9udGFsIHNwYWNlIGFmdGVyXG5hIGxpbmUgd2hlbiB0aGUgc2VsZWN0aW9uIGNvbnRpbnVlcyBwYXN0IGl0KS5cblxuSXQgZG9lcyBoYXZlIGEgcGVyZm9ybWFuY2UgY29zdCwgaW4gdGhhdCBpdCByZXF1aXJlcyBhbiBleHRyYSBET01cbmxheW91dCBjeWNsZSBmb3IgbWFueSB1cGRhdGVzICh0aGUgc2VsZWN0aW9uIGlzIGRyYXduIGJhc2VkIG9uIERPTVxubGF5b3V0IGluZm9ybWF0aW9uIHRoYXQncyBvbmx5IGF2YWlsYWJsZSBhZnRlciBsYXlpbmcgb3V0IHRoZVxuY29udGVudCkuXG4qL1xuZnVuY3Rpb24gZHJhd1NlbGVjdGlvbihjb25maWcgPSB7fSkge1xuICAgIHJldHVybiBbXG4gICAgICAgIHNlbGVjdGlvbkNvbmZpZy5vZihjb25maWcpLFxuICAgICAgICBjdXJzb3JMYXllcixcbiAgICAgICAgc2VsZWN0aW9uTGF5ZXIsXG4gICAgICAgIGhpZGVOYXRpdmVTZWxlY3Rpb24sXG4gICAgICAgIG5hdGl2ZVNlbGVjdGlvbkhpZGRlbi5vZih0cnVlKVxuICAgIF07XG59XG4vKipcblJldHJpZXZlIHRoZSBbYGRyYXdTZWxlY3Rpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuZHJhd1NlbGVjdGlvbikgY29uZmlndXJhdGlvblxuZm9yIHRoaXMgc3RhdGUuIChOb3RlIHRoYXQgdGhpcyB3aWxsIHJldHVybiBhIHNldCBvZiBkZWZhdWx0cyBldmVuXG5pZiBgZHJhd1NlbGVjdGlvbmAgaXNuJ3QgZW5hYmxlZC4pXG4qL1xuZnVuY3Rpb24gZ2V0RHJhd1NlbGVjdGlvbkNvbmZpZyhzdGF0ZSkge1xuICAgIHJldHVybiBzdGF0ZS5mYWNldChzZWxlY3Rpb25Db25maWcpO1xufVxuZnVuY3Rpb24gY29uZmlnQ2hhbmdlZCh1cGRhdGUpIHtcbiAgICByZXR1cm4gdXBkYXRlLnN0YXJ0U3RhdGUuZmFjZXQoc2VsZWN0aW9uQ29uZmlnKSAhPSB1cGRhdGUuc3RhdGUuZmFjZXQoc2VsZWN0aW9uQ29uZmlnKTtcbn1cbmNvbnN0IGN1cnNvckxheWVyID0gLypAX19QVVJFX18qL2xheWVyKHtcbiAgICBhYm92ZTogdHJ1ZSxcbiAgICBtYXJrZXJzKHZpZXcpIHtcbiAgICAgICAgbGV0IHsgc3RhdGUgfSA9IHZpZXcsIGNvbmYgPSBzdGF0ZS5mYWNldChzZWxlY3Rpb25Db25maWcpO1xuICAgICAgICBsZXQgY3Vyc29ycyA9IFtdO1xuICAgICAgICBmb3IgKGxldCByIG9mIHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMpIHtcbiAgICAgICAgICAgIGxldCBwcmltID0gciA9PSBzdGF0ZS5zZWxlY3Rpb24ubWFpbjtcbiAgICAgICAgICAgIGlmIChyLmVtcHR5ID8gIXByaW0gfHwgQ2FuSGlkZVByaW1hcnkgOiBjb25mLmRyYXdSYW5nZUN1cnNvcikge1xuICAgICAgICAgICAgICAgIGxldCBjbGFzc05hbWUgPSBwcmltID8gXCJjbS1jdXJzb3IgY20tY3Vyc29yLXByaW1hcnlcIiA6IFwiY20tY3Vyc29yIGNtLWN1cnNvci1zZWNvbmRhcnlcIjtcbiAgICAgICAgICAgICAgICBsZXQgY3Vyc29yID0gci5lbXB0eSA/IHIgOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHIuaGVhZCwgci5oZWFkID4gci5hbmNob3IgPyAtMSA6IDEpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHBpZWNlIG9mIFJlY3RhbmdsZU1hcmtlci5mb3JSYW5nZSh2aWV3LCBjbGFzc05hbWUsIGN1cnNvcikpXG4gICAgICAgICAgICAgICAgICAgIGN1cnNvcnMucHVzaChwaWVjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1cnNvcnM7XG4gICAgfSxcbiAgICB1cGRhdGUodXBkYXRlLCBkb20pIHtcbiAgICAgICAgaWYgKHVwZGF0ZS50cmFuc2FjdGlvbnMuc29tZSh0ciA9PiB0ci5zZWxlY3Rpb24pKVxuICAgICAgICAgICAgZG9tLnN0eWxlLmFuaW1hdGlvbk5hbWUgPSBkb20uc3R5bGUuYW5pbWF0aW9uTmFtZSA9PSBcImNtLWJsaW5rXCIgPyBcImNtLWJsaW5rMlwiIDogXCJjbS1ibGlua1wiO1xuICAgICAgICBsZXQgY29uZkNoYW5nZSA9IGNvbmZpZ0NoYW5nZWQodXBkYXRlKTtcbiAgICAgICAgaWYgKGNvbmZDaGFuZ2UpXG4gICAgICAgICAgICBzZXRCbGlua1JhdGUodXBkYXRlLnN0YXRlLCBkb20pO1xuICAgICAgICByZXR1cm4gdXBkYXRlLmRvY0NoYW5nZWQgfHwgdXBkYXRlLnNlbGVjdGlvblNldCB8fCBjb25mQ2hhbmdlO1xuICAgIH0sXG4gICAgbW91bnQoZG9tLCB2aWV3KSB7XG4gICAgICAgIHNldEJsaW5rUmF0ZSh2aWV3LnN0YXRlLCBkb20pO1xuICAgIH0sXG4gICAgY2xhc3M6IFwiY20tY3Vyc29yTGF5ZXJcIlxufSk7XG5mdW5jdGlvbiBzZXRCbGlua1JhdGUoc3RhdGUsIGRvbSkge1xuICAgIGRvbS5zdHlsZS5hbmltYXRpb25EdXJhdGlvbiA9IHN0YXRlLmZhY2V0KHNlbGVjdGlvbkNvbmZpZykuY3Vyc29yQmxpbmtSYXRlICsgXCJtc1wiO1xufVxuY29uc3Qgc2VsZWN0aW9uTGF5ZXIgPSAvKkBfX1BVUkVfXyovbGF5ZXIoe1xuICAgIGFib3ZlOiBmYWxzZSxcbiAgICBtYXJrZXJzKHZpZXcpIHtcbiAgICAgICAgcmV0dXJuIHZpZXcuc3RhdGUuc2VsZWN0aW9uLnJhbmdlcy5tYXAociA9PiByLmVtcHR5ID8gW10gOiBSZWN0YW5nbGVNYXJrZXIuZm9yUmFuZ2UodmlldywgXCJjbS1zZWxlY3Rpb25CYWNrZ3JvdW5kXCIsIHIpKVxuICAgICAgICAgICAgLnJlZHVjZSgoYSwgYikgPT4gYS5jb25jYXQoYikpO1xuICAgIH0sXG4gICAgdXBkYXRlKHVwZGF0ZSwgZG9tKSB7XG4gICAgICAgIHJldHVybiB1cGRhdGUuZG9jQ2hhbmdlZCB8fCB1cGRhdGUuc2VsZWN0aW9uU2V0IHx8IHVwZGF0ZS52aWV3cG9ydENoYW5nZWQgfHwgY29uZmlnQ2hhbmdlZCh1cGRhdGUpO1xuICAgIH0sXG4gICAgY2xhc3M6IFwiY20tc2VsZWN0aW9uTGF5ZXJcIlxufSk7XG5jb25zdCB0aGVtZVNwZWMgPSB7XG4gICAgXCIuY20tbGluZVwiOiB7XG4gICAgICAgIFwiJiA6OnNlbGVjdGlvblwiOiB7IGJhY2tncm91bmRDb2xvcjogXCJ0cmFuc3BhcmVudCAhaW1wb3J0YW50XCIgfSxcbiAgICAgICAgXCImOjpzZWxlY3Rpb25cIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwidHJhbnNwYXJlbnQgIWltcG9ydGFudFwiIH1cbiAgICB9XG59O1xuaWYgKENhbkhpZGVQcmltYXJ5KSB7XG4gICAgdGhlbWVTcGVjW1wiLmNtLWxpbmVcIl0uY2FyZXRDb2xvciA9IFwidHJhbnNwYXJlbnQgIWltcG9ydGFudFwiO1xuICAgIHRoZW1lU3BlY1tcIi5jbS1jb250ZW50XCJdID0geyBjYXJldENvbG9yOiBcInRyYW5zcGFyZW50ICFpbXBvcnRhbnRcIiB9O1xufVxuY29uc3QgaGlkZU5hdGl2ZVNlbGVjdGlvbiA9IC8qQF9fUFVSRV9fKi9QcmVjLmhpZ2hlc3QoLypAX19QVVJFX18qL0VkaXRvclZpZXcudGhlbWUodGhlbWVTcGVjKSk7XG5cbmNvbnN0IHNldERyb3BDdXJzb3JQb3MgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKHtcbiAgICBtYXAocG9zLCBtYXBwaW5nKSB7IHJldHVybiBwb3MgPT0gbnVsbCA/IG51bGwgOiBtYXBwaW5nLm1hcFBvcyhwb3MpOyB9XG59KTtcbmNvbnN0IGRyb3BDdXJzb3JQb3MgPSAvKkBfX1BVUkVfXyovU3RhdGVGaWVsZC5kZWZpbmUoe1xuICAgIGNyZWF0ZSgpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgdXBkYXRlKHBvcywgdHIpIHtcbiAgICAgICAgaWYgKHBvcyAhPSBudWxsKVxuICAgICAgICAgICAgcG9zID0gdHIuY2hhbmdlcy5tYXBQb3MocG9zKTtcbiAgICAgICAgcmV0dXJuIHRyLmVmZmVjdHMucmVkdWNlKChwb3MsIGUpID0+IGUuaXMoc2V0RHJvcEN1cnNvclBvcykgPyBlLnZhbHVlIDogcG9zLCBwb3MpO1xuICAgIH1cbn0pO1xuY29uc3QgZHJhd0Ryb3BDdXJzb3IgPSAvKkBfX1BVUkVfXyovVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5jdXJzb3IgPSBudWxsO1xuICAgICAgICB0aGlzLm1lYXN1cmVSZXEgPSB7IHJlYWQ6IHRoaXMucmVhZFBvcy5iaW5kKHRoaXMpLCB3cml0ZTogdGhpcy5kcmF3Q3Vyc29yLmJpbmQodGhpcykgfTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGxldCBjdXJzb3JQb3MgPSB1cGRhdGUuc3RhdGUuZmllbGQoZHJvcEN1cnNvclBvcyk7XG4gICAgICAgIGlmIChjdXJzb3JQb3MgPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY3Vyc29yICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLmN1cnNvcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5jdXJzb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnNvciA9IHRoaXMudmlldy5zY3JvbGxET00uYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJzb3IuY2xhc3NOYW1lID0gXCJjbS1kcm9wQ3Vyc29yXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodXBkYXRlLnN0YXJ0U3RhdGUuZmllbGQoZHJvcEN1cnNvclBvcykgIT0gY3Vyc29yUG9zIHx8IHVwZGF0ZS5kb2NDaGFuZ2VkIHx8IHVwZGF0ZS5nZW9tZXRyeUNoYW5nZWQpXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3LnJlcXVlc3RNZWFzdXJlKHRoaXMubWVhc3VyZVJlcSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVhZFBvcygpIHtcbiAgICAgICAgbGV0IHsgdmlldyB9ID0gdGhpcztcbiAgICAgICAgbGV0IHBvcyA9IHZpZXcuc3RhdGUuZmllbGQoZHJvcEN1cnNvclBvcyk7XG4gICAgICAgIGxldCByZWN0ID0gcG9zICE9IG51bGwgJiYgdmlldy5jb29yZHNBdFBvcyhwb3MpO1xuICAgICAgICBpZiAoIXJlY3QpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IG91dGVyID0gdmlldy5zY3JvbGxET00uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZWZ0OiByZWN0LmxlZnQgLSBvdXRlci5sZWZ0ICsgdmlldy5zY3JvbGxET00uc2Nyb2xsTGVmdCAqIHZpZXcuc2NhbGVYLFxuICAgICAgICAgICAgdG9wOiByZWN0LnRvcCAtIG91dGVyLnRvcCArIHZpZXcuc2Nyb2xsRE9NLnNjcm9sbFRvcCAqIHZpZXcuc2NhbGVZLFxuICAgICAgICAgICAgaGVpZ2h0OiByZWN0LmJvdHRvbSAtIHJlY3QudG9wXG4gICAgICAgIH07XG4gICAgfVxuICAgIGRyYXdDdXJzb3IocG9zKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnNvcikge1xuICAgICAgICAgICAgbGV0IHsgc2NhbGVYLCBzY2FsZVkgfSA9IHRoaXMudmlldztcbiAgICAgICAgICAgIGlmIChwb3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnNvci5zdHlsZS5sZWZ0ID0gcG9zLmxlZnQgLyBzY2FsZVggKyBcInB4XCI7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJzb3Iuc3R5bGUudG9wID0gcG9zLnRvcCAvIHNjYWxlWSArIFwicHhcIjtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnNvci5zdHlsZS5oZWlnaHQgPSBwb3MuaGVpZ2h0IC8gc2NhbGVZICsgXCJweFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJzb3Iuc3R5bGUubGVmdCA9IFwiLTEwMDAwMHB4XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMuY3Vyc29yKVxuICAgICAgICAgICAgdGhpcy5jdXJzb3IucmVtb3ZlKCk7XG4gICAgfVxuICAgIHNldERyb3BQb3MocG9zKSB7XG4gICAgICAgIGlmICh0aGlzLnZpZXcuc3RhdGUuZmllbGQoZHJvcEN1cnNvclBvcykgIT0gcG9zKVxuICAgICAgICAgICAgdGhpcy52aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogc2V0RHJvcEN1cnNvclBvcy5vZihwb3MpIH0pO1xuICAgIH1cbn0sIHtcbiAgICBldmVudE9ic2VydmVyczoge1xuICAgICAgICBkcmFnb3ZlcihldmVudCkge1xuICAgICAgICAgICAgdGhpcy5zZXREcm9wUG9zKHRoaXMudmlldy5wb3NBdENvb3Jkcyh7IHg6IGV2ZW50LmNsaWVudFgsIHk6IGV2ZW50LmNsaWVudFkgfSkpO1xuICAgICAgICB9LFxuICAgICAgICBkcmFnbGVhdmUoZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChldmVudC50YXJnZXQgPT0gdGhpcy52aWV3LmNvbnRlbnRET00gfHwgIXRoaXMudmlldy5jb250ZW50RE9NLmNvbnRhaW5zKGV2ZW50LnJlbGF0ZWRUYXJnZXQpKVxuICAgICAgICAgICAgICAgIHRoaXMuc2V0RHJvcFBvcyhudWxsKTtcbiAgICAgICAgfSxcbiAgICAgICAgZHJhZ2VuZCgpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RHJvcFBvcyhudWxsKTtcbiAgICAgICAgfSxcbiAgICAgICAgZHJvcCgpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RHJvcFBvcyhudWxsKTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuLyoqXG5EcmF3cyBhIGN1cnNvciBhdCB0aGUgY3VycmVudCBkcm9wIHBvc2l0aW9uIHdoZW4gc29tZXRoaW5nIGlzXG5kcmFnZ2VkIG92ZXIgdGhlIGVkaXRvci5cbiovXG5mdW5jdGlvbiBkcm9wQ3Vyc29yKCkge1xuICAgIHJldHVybiBbZHJvcEN1cnNvclBvcywgZHJhd0Ryb3BDdXJzb3JdO1xufVxuXG5mdW5jdGlvbiBpdGVyTWF0Y2hlcyhkb2MsIHJlLCBmcm9tLCB0bywgZikge1xuICAgIHJlLmxhc3RJbmRleCA9IDA7XG4gICAgZm9yIChsZXQgY3Vyc29yID0gZG9jLml0ZXJSYW5nZShmcm9tLCB0byksIHBvcyA9IGZyb20sIG07ICFjdXJzb3IubmV4dCgpLmRvbmU7IHBvcyArPSBjdXJzb3IudmFsdWUubGVuZ3RoKSB7XG4gICAgICAgIGlmICghY3Vyc29yLmxpbmVCcmVhaylcbiAgICAgICAgICAgIHdoaWxlIChtID0gcmUuZXhlYyhjdXJzb3IudmFsdWUpKVxuICAgICAgICAgICAgICAgIGYocG9zICsgbS5pbmRleCwgbSk7XG4gICAgfVxufVxuZnVuY3Rpb24gbWF0Y2hSYW5nZXModmlldywgbWF4TGVuZ3RoKSB7XG4gICAgbGV0IHZpc2libGUgPSB2aWV3LnZpc2libGVSYW5nZXM7XG4gICAgaWYgKHZpc2libGUubGVuZ3RoID09IDEgJiYgdmlzaWJsZVswXS5mcm9tID09IHZpZXcudmlld3BvcnQuZnJvbSAmJlxuICAgICAgICB2aXNpYmxlWzBdLnRvID09IHZpZXcudmlld3BvcnQudG8pXG4gICAgICAgIHJldHVybiB2aXNpYmxlO1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCB7IGZyb20sIHRvIH0gb2YgdmlzaWJsZSkge1xuICAgICAgICBmcm9tID0gTWF0aC5tYXgodmlldy5zdGF0ZS5kb2MubGluZUF0KGZyb20pLmZyb20sIGZyb20gLSBtYXhMZW5ndGgpO1xuICAgICAgICB0byA9IE1hdGgubWluKHZpZXcuc3RhdGUuZG9jLmxpbmVBdCh0bykudG8sIHRvICsgbWF4TGVuZ3RoKTtcbiAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggJiYgcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXS50byA+PSBmcm9tKVxuICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXS50byA9IHRvO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXN1bHQucHVzaCh7IGZyb20sIHRvIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG5IZWxwZXIgY2xhc3MgdXNlZCB0byBtYWtlIGl0IGVhc2llciB0byBtYWludGFpbiBkZWNvcmF0aW9ucyBvblxudmlzaWJsZSBjb2RlIHRoYXQgbWF0Y2hlcyBhIGdpdmVuIHJlZ3VsYXIgZXhwcmVzc2lvbi4gVG8gYmUgdXNlZFxuaW4gYSBbdmlldyBwbHVnaW5dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5WaWV3UGx1Z2luKS4gSW5zdGFuY2VzIG9mIHRoaXMgb2JqZWN0XG5yZXByZXNlbnQgYSBtYXRjaGluZyBjb25maWd1cmF0aW9uLlxuKi9cbmNsYXNzIE1hdGNoRGVjb3JhdG9yIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBkZWNvcmF0b3IuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgY29uc3QgeyByZWdleHAsIGRlY29yYXRpb24sIGRlY29yYXRlLCBib3VuZGFyeSwgbWF4TGVuZ3RoID0gMTAwMCB9ID0gY29uZmlnO1xuICAgICAgICBpZiAoIXJlZ2V4cC5nbG9iYWwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRoZSByZWd1bGFyIGV4cHJlc3Npb24gZ2l2ZW4gdG8gTWF0Y2hEZWNvcmF0b3Igc2hvdWxkIGhhdmUgaXRzICdnJyBmbGFnIHNldFwiKTtcbiAgICAgICAgdGhpcy5yZWdleHAgPSByZWdleHA7XG4gICAgICAgIGlmIChkZWNvcmF0ZSkge1xuICAgICAgICAgICAgdGhpcy5hZGRNYXRjaCA9IChtYXRjaCwgdmlldywgZnJvbSwgYWRkKSA9PiBkZWNvcmF0ZShhZGQsIGZyb20sIGZyb20gKyBtYXRjaFswXS5sZW5ndGgsIG1hdGNoLCB2aWV3KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgZGVjb3JhdGlvbiA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkTWF0Y2ggPSAobWF0Y2gsIHZpZXcsIGZyb20sIGFkZCkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBkZWNvID0gZGVjb3JhdGlvbihtYXRjaCwgdmlldywgZnJvbSk7XG4gICAgICAgICAgICAgICAgaWYgKGRlY28pXG4gICAgICAgICAgICAgICAgICAgIGFkZChmcm9tLCBmcm9tICsgbWF0Y2hbMF0ubGVuZ3RoLCBkZWNvKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGVjb3JhdGlvbikge1xuICAgICAgICAgICAgdGhpcy5hZGRNYXRjaCA9IChtYXRjaCwgX3ZpZXcsIGZyb20sIGFkZCkgPT4gYWRkKGZyb20sIGZyb20gKyBtYXRjaFswXS5sZW5ndGgsIGRlY29yYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJFaXRoZXIgJ2RlY29yYXRlJyBvciAnZGVjb3JhdGlvbicgc2hvdWxkIGJlIHByb3ZpZGVkIHRvIE1hdGNoRGVjb3JhdG9yXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYm91bmRhcnkgPSBib3VuZGFyeTtcbiAgICAgICAgdGhpcy5tYXhMZW5ndGggPSBtYXhMZW5ndGg7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbXB1dGUgdGhlIGZ1bGwgc2V0IG9mIGRlY29yYXRpb25zIGZvciBtYXRjaGVzIGluIHRoZSBnaXZlblxuICAgIHZpZXcncyB2aWV3cG9ydC4gWW91J2xsIHdhbnQgdG8gY2FsbCB0aGlzIHdoZW4gaW5pdGlhbGl6aW5nIHlvdXJcbiAgICBwbHVnaW4uXG4gICAgKi9cbiAgICBjcmVhdGVEZWNvKHZpZXcpIHtcbiAgICAgICAgbGV0IGJ1aWxkID0gbmV3IFJhbmdlU2V0QnVpbGRlcigpLCBhZGQgPSBidWlsZC5hZGQuYmluZChidWlsZCk7XG4gICAgICAgIGZvciAobGV0IHsgZnJvbSwgdG8gfSBvZiBtYXRjaFJhbmdlcyh2aWV3LCB0aGlzLm1heExlbmd0aCkpXG4gICAgICAgICAgICBpdGVyTWF0Y2hlcyh2aWV3LnN0YXRlLmRvYywgdGhpcy5yZWdleHAsIGZyb20sIHRvLCAoZnJvbSwgbSkgPT4gdGhpcy5hZGRNYXRjaChtLCB2aWV3LCBmcm9tLCBhZGQpKTtcbiAgICAgICAgcmV0dXJuIGJ1aWxkLmZpbmlzaCgpO1xuICAgIH1cbiAgICAvKipcbiAgICBVcGRhdGUgYSBzZXQgb2YgZGVjb3JhdGlvbnMgZm9yIGEgdmlldyB1cGRhdGUuIGBkZWNvYCBfbXVzdF8gYmVcbiAgICB0aGUgc2V0IG9mIGRlY29yYXRpb25zIHByb2R1Y2VkIGJ5IF90aGlzXyBgTWF0Y2hEZWNvcmF0b3JgIGZvclxuICAgIHRoZSB2aWV3IHN0YXRlIGJlZm9yZSB0aGUgdXBkYXRlLlxuICAgICovXG4gICAgdXBkYXRlRGVjbyh1cGRhdGUsIGRlY28pIHtcbiAgICAgICAgbGV0IGNoYW5nZUZyb20gPSAxZTksIGNoYW5nZVRvID0gLTE7XG4gICAgICAgIGlmICh1cGRhdGUuZG9jQ2hhbmdlZClcbiAgICAgICAgICAgIHVwZGF0ZS5jaGFuZ2VzLml0ZXJDaGFuZ2VzKChfZiwgX3QsIGZyb20sIHRvKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRvID4gdXBkYXRlLnZpZXcudmlld3BvcnQuZnJvbSAmJiBmcm9tIDwgdXBkYXRlLnZpZXcudmlld3BvcnQudG8pIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlRnJvbSA9IE1hdGgubWluKGZyb20sIGNoYW5nZUZyb20pO1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VUbyA9IE1hdGgubWF4KHRvLCBjaGFuZ2VUbyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGlmICh1cGRhdGUudmlld3BvcnRDaGFuZ2VkIHx8IGNoYW5nZVRvIC0gY2hhbmdlRnJvbSA+IDEwMDApXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVEZWNvKHVwZGF0ZS52aWV3KTtcbiAgICAgICAgaWYgKGNoYW5nZVRvID4gLTEpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVSYW5nZSh1cGRhdGUudmlldywgZGVjby5tYXAodXBkYXRlLmNoYW5nZXMpLCBjaGFuZ2VGcm9tLCBjaGFuZ2VUbyk7XG4gICAgICAgIHJldHVybiBkZWNvO1xuICAgIH1cbiAgICB1cGRhdGVSYW5nZSh2aWV3LCBkZWNvLCB1cGRhdGVGcm9tLCB1cGRhdGVUbykge1xuICAgICAgICBmb3IgKGxldCByIG9mIHZpZXcudmlzaWJsZVJhbmdlcykge1xuICAgICAgICAgICAgbGV0IGZyb20gPSBNYXRoLm1heChyLmZyb20sIHVwZGF0ZUZyb20pLCB0byA9IE1hdGgubWluKHIudG8sIHVwZGF0ZVRvKTtcbiAgICAgICAgICAgIGlmICh0byA+IGZyb20pIHtcbiAgICAgICAgICAgICAgICBsZXQgZnJvbUxpbmUgPSB2aWV3LnN0YXRlLmRvYy5saW5lQXQoZnJvbSksIHRvTGluZSA9IGZyb21MaW5lLnRvIDwgdG8gPyB2aWV3LnN0YXRlLmRvYy5saW5lQXQodG8pIDogZnJvbUxpbmU7XG4gICAgICAgICAgICAgICAgbGV0IHN0YXJ0ID0gTWF0aC5tYXgoci5mcm9tLCBmcm9tTGluZS5mcm9tKSwgZW5kID0gTWF0aC5taW4oci50bywgdG9MaW5lLnRvKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ib3VuZGFyeSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgZnJvbSA+IGZyb21MaW5lLmZyb207IGZyb20tLSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmJvdW5kYXJ5LnRlc3QoZnJvbUxpbmUudGV4dFtmcm9tIC0gMSAtIGZyb21MaW5lLmZyb21dKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gZnJvbTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IHRvIDwgdG9MaW5lLnRvOyB0bysrKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYm91bmRhcnkudGVzdCh0b0xpbmUudGV4dFt0byAtIHRvTGluZS5mcm9tXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSB0bztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHJhbmdlcyA9IFtdLCBtO1xuICAgICAgICAgICAgICAgIGxldCBhZGQgPSAoZnJvbSwgdG8sIGRlY28pID0+IHJhbmdlcy5wdXNoKGRlY28ucmFuZ2UoZnJvbSwgdG8pKTtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbUxpbmUgPT0gdG9MaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVnZXhwLmxhc3RJbmRleCA9IHN0YXJ0IC0gZnJvbUxpbmUuZnJvbTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChtID0gdGhpcy5yZWdleHAuZXhlYyhmcm9tTGluZS50ZXh0KSkgJiYgbS5pbmRleCA8IGVuZCAtIGZyb21MaW5lLmZyb20pXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZE1hdGNoKG0sIHZpZXcsIG0uaW5kZXggKyBmcm9tTGluZS5mcm9tLCBhZGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlck1hdGNoZXModmlldy5zdGF0ZS5kb2MsIHRoaXMucmVnZXhwLCBzdGFydCwgZW5kLCAoZnJvbSwgbSkgPT4gdGhpcy5hZGRNYXRjaChtLCB2aWV3LCBmcm9tLCBhZGQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVjbyA9IGRlY28udXBkYXRlKHsgZmlsdGVyRnJvbTogc3RhcnQsIGZpbHRlclRvOiBlbmQsIGZpbHRlcjogKGZyb20sIHRvKSA9PiBmcm9tIDwgc3RhcnQgfHwgdG8gPiBlbmQsIGFkZDogcmFuZ2VzIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWNvO1xuICAgIH1cbn1cblxuY29uc3QgVW5pY29kZVJlZ2V4cFN1cHBvcnQgPSAveC8udW5pY29kZSAhPSBudWxsID8gXCJndVwiIDogXCJnXCI7XG5jb25zdCBTcGVjaWFscyA9IC8qQF9fUFVSRV9fKi9uZXcgUmVnRXhwKFwiW1xcdTAwMDAtXFx1MDAwOFxcdTAwMGEtXFx1MDAxZlxcdTAwN2YtXFx1MDA5ZlxcdTAwYWRcXHUwNjFjXFx1MjAwYlxcdTIwMGVcXHUyMDBmXFx1MjAyOFxcdTIwMjlcXHUyMDJkXFx1MjAyZVxcdTIwNjZcXHUyMDY3XFx1MjA2OVxcdWZlZmZcXHVmZmY5LVxcdWZmZmNdXCIsIFVuaWNvZGVSZWdleHBTdXBwb3J0KTtcbmNvbnN0IE5hbWVzID0ge1xuICAgIDA6IFwibnVsbFwiLFxuICAgIDc6IFwiYmVsbFwiLFxuICAgIDg6IFwiYmFja3NwYWNlXCIsXG4gICAgMTA6IFwibmV3bGluZVwiLFxuICAgIDExOiBcInZlcnRpY2FsIHRhYlwiLFxuICAgIDEzOiBcImNhcnJpYWdlIHJldHVyblwiLFxuICAgIDI3OiBcImVzY2FwZVwiLFxuICAgIDgyMDM6IFwiemVybyB3aWR0aCBzcGFjZVwiLFxuICAgIDgyMDQ6IFwiemVybyB3aWR0aCBub24tam9pbmVyXCIsXG4gICAgODIwNTogXCJ6ZXJvIHdpZHRoIGpvaW5lclwiLFxuICAgIDgyMDY6IFwibGVmdC10by1yaWdodCBtYXJrXCIsXG4gICAgODIwNzogXCJyaWdodC10by1sZWZ0IG1hcmtcIixcbiAgICA4MjMyOiBcImxpbmUgc2VwYXJhdG9yXCIsXG4gICAgODIzNzogXCJsZWZ0LXRvLXJpZ2h0IG92ZXJyaWRlXCIsXG4gICAgODIzODogXCJyaWdodC10by1sZWZ0IG92ZXJyaWRlXCIsXG4gICAgODI5NDogXCJsZWZ0LXRvLXJpZ2h0IGlzb2xhdGVcIixcbiAgICA4Mjk1OiBcInJpZ2h0LXRvLWxlZnQgaXNvbGF0ZVwiLFxuICAgIDgyOTc6IFwicG9wIGRpcmVjdGlvbmFsIGlzb2xhdGVcIixcbiAgICA4MjMzOiBcInBhcmFncmFwaCBzZXBhcmF0b3JcIixcbiAgICA2NTI3OTogXCJ6ZXJvIHdpZHRoIG5vLWJyZWFrIHNwYWNlXCIsXG4gICAgNjU1MzI6IFwib2JqZWN0IHJlcGxhY2VtZW50XCJcbn07XG5sZXQgX3N1cHBvcnRzVGFiU2l6ZSA9IG51bGw7XG5mdW5jdGlvbiBzdXBwb3J0c1RhYlNpemUoKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmIChfc3VwcG9ydHNUYWJTaXplID09IG51bGwgJiYgdHlwZW9mIGRvY3VtZW50ICE9IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnQuYm9keSkge1xuICAgICAgICBsZXQgc3R5bGVzID0gZG9jdW1lbnQuYm9keS5zdHlsZTtcbiAgICAgICAgX3N1cHBvcnRzVGFiU2l6ZSA9ICgoX2EgPSBzdHlsZXMudGFiU2l6ZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogc3R5bGVzLk1velRhYlNpemUpICE9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBfc3VwcG9ydHNUYWJTaXplIHx8IGZhbHNlO1xufVxuY29uc3Qgc3BlY2lhbENoYXJDb25maWcgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lKGNvbmZpZ3MpIHtcbiAgICAgICAgbGV0IGNvbmZpZyA9IGNvbWJpbmVDb25maWcoY29uZmlncywge1xuICAgICAgICAgICAgcmVuZGVyOiBudWxsLFxuICAgICAgICAgICAgc3BlY2lhbENoYXJzOiBTcGVjaWFscyxcbiAgICAgICAgICAgIGFkZFNwZWNpYWxDaGFyczogbnVsbFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGNvbmZpZy5yZXBsYWNlVGFicyA9ICFzdXBwb3J0c1RhYlNpemUoKSlcbiAgICAgICAgICAgIGNvbmZpZy5zcGVjaWFsQ2hhcnMgPSBuZXcgUmVnRXhwKFwiXFx0fFwiICsgY29uZmlnLnNwZWNpYWxDaGFycy5zb3VyY2UsIFVuaWNvZGVSZWdleHBTdXBwb3J0KTtcbiAgICAgICAgaWYgKGNvbmZpZy5hZGRTcGVjaWFsQ2hhcnMpXG4gICAgICAgICAgICBjb25maWcuc3BlY2lhbENoYXJzID0gbmV3IFJlZ0V4cChjb25maWcuc3BlY2lhbENoYXJzLnNvdXJjZSArIFwifFwiICsgY29uZmlnLmFkZFNwZWNpYWxDaGFycy5zb3VyY2UsIFVuaWNvZGVSZWdleHBTdXBwb3J0KTtcbiAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9XG59KTtcbi8qKlxuUmV0dXJucyBhbiBleHRlbnNpb24gdGhhdCBpbnN0YWxscyBoaWdobGlnaHRpbmcgb2Ygc3BlY2lhbFxuY2hhcmFjdGVycy5cbiovXG5mdW5jdGlvbiBoaWdobGlnaHRTcGVjaWFsQ2hhcnMoXG4vKipcbkNvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiovXG5jb25maWcgPSB7fSkge1xuICAgIHJldHVybiBbc3BlY2lhbENoYXJDb25maWcub2YoY29uZmlnKSwgc3BlY2lhbENoYXJQbHVnaW4oKV07XG59XG5sZXQgX3BsdWdpbiA9IG51bGw7XG5mdW5jdGlvbiBzcGVjaWFsQ2hhclBsdWdpbigpIHtcbiAgICByZXR1cm4gX3BsdWdpbiB8fCAoX3BsdWdpbiA9IFZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIHtcbiAgICAgICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSBEZWNvcmF0aW9uLm5vbmU7XG4gICAgICAgICAgICB0aGlzLmRlY29yYXRpb25DYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICB0aGlzLmRlY29yYXRvciA9IHRoaXMubWFrZURlY29yYXRvcih2aWV3LnN0YXRlLmZhY2V0KHNwZWNpYWxDaGFyQ29uZmlnKSk7XG4gICAgICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gdGhpcy5kZWNvcmF0b3IuY3JlYXRlRGVjbyh2aWV3KTtcbiAgICAgICAgfVxuICAgICAgICBtYWtlRGVjb3JhdG9yKGNvbmYpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTWF0Y2hEZWNvcmF0b3Ioe1xuICAgICAgICAgICAgICAgIHJlZ2V4cDogY29uZi5zcGVjaWFsQ2hhcnMsXG4gICAgICAgICAgICAgICAgZGVjb3JhdGlvbjogKG0sIHZpZXcsIHBvcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgeyBkb2MgfSA9IHZpZXcuc3RhdGU7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjb2RlID0gY29kZVBvaW50QXQobVswXSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2RlID09IDkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBsaW5lID0gZG9jLmxpbmVBdChwb3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHNpemUgPSB2aWV3LnN0YXRlLnRhYlNpemUsIGNvbCA9IGNvdW50Q29sdW1uKGxpbmUudGV4dCwgc2l6ZSwgcG9zIC0gbGluZS5mcm9tKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uLnJlcGxhY2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZGdldDogbmV3IFRhYldpZGdldCgoc2l6ZSAtIChjb2wgJSBzaXplKSkgKiB0aGlzLnZpZXcuZGVmYXVsdENoYXJhY3RlcldpZHRoIC8gdGhpcy52aWV3LnNjYWxlWClcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29yYXRpb25DYWNoZVtjb2RlXSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMuZGVjb3JhdGlvbkNhY2hlW2NvZGVdID0gRGVjb3JhdGlvbi5yZXBsYWNlKHsgd2lkZ2V0OiBuZXcgU3BlY2lhbENoYXJXaWRnZXQoY29uZiwgY29kZSkgfSkpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYm91bmRhcnk6IGNvbmYucmVwbGFjZVRhYnMgPyB1bmRlZmluZWQgOiAvW15dL1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICAgICAgbGV0IGNvbmYgPSB1cGRhdGUuc3RhdGUuZmFjZXQoc3BlY2lhbENoYXJDb25maWcpO1xuICAgICAgICAgICAgaWYgKHVwZGF0ZS5zdGFydFN0YXRlLmZhY2V0KHNwZWNpYWxDaGFyQ29uZmlnKSAhPSBjb25mKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWNvcmF0b3IgPSB0aGlzLm1ha2VEZWNvcmF0b3IoY29uZik7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuZGVjb3JhdG9yLmNyZWF0ZURlY28odXBkYXRlLnZpZXcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuZGVjb3JhdG9yLnVwZGF0ZURlY28odXBkYXRlLCB0aGlzLmRlY29yYXRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAgZGVjb3JhdGlvbnM6IHYgPT4gdi5kZWNvcmF0aW9uc1xuICAgIH0pKTtcbn1cbmNvbnN0IERlZmF1bHRQbGFjZWhvbGRlciA9IFwiXFx1MjAyMlwiO1xuLy8gQXNzaWducyBwbGFjZWhvbGRlciBjaGFyYWN0ZXJzIGZyb20gdGhlIENvbnRyb2wgUGljdHVyZXMgYmxvY2sgdG9cbi8vIEFTQ0lJIGNvbnRyb2wgY2hhcmFjdGVyc1xuZnVuY3Rpb24gcGxhY2Vob2xkZXIkMShjb2RlKSB7XG4gICAgaWYgKGNvZGUgPj0gMzIpXG4gICAgICAgIHJldHVybiBEZWZhdWx0UGxhY2Vob2xkZXI7XG4gICAgaWYgKGNvZGUgPT0gMTApXG4gICAgICAgIHJldHVybiBcIlxcdTI0MjRcIjtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSg5MjE2ICsgY29kZSk7XG59XG5jbGFzcyBTcGVjaWFsQ2hhcldpZGdldCBleHRlbmRzIFdpZGdldFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGNvZGUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICB9XG4gICAgZXEob3RoZXIpIHsgcmV0dXJuIG90aGVyLmNvZGUgPT0gdGhpcy5jb2RlOyB9XG4gICAgdG9ET00odmlldykge1xuICAgICAgICBsZXQgcGggPSBwbGFjZWhvbGRlciQxKHRoaXMuY29kZSk7XG4gICAgICAgIGxldCBkZXNjID0gdmlldy5zdGF0ZS5waHJhc2UoXCJDb250cm9sIGNoYXJhY3RlclwiKSArIFwiIFwiICsgKE5hbWVzW3RoaXMuY29kZV0gfHwgXCIweFwiICsgdGhpcy5jb2RlLnRvU3RyaW5nKDE2KSk7XG4gICAgICAgIGxldCBjdXN0b20gPSB0aGlzLm9wdGlvbnMucmVuZGVyICYmIHRoaXMub3B0aW9ucy5yZW5kZXIodGhpcy5jb2RlLCBkZXNjLCBwaCk7XG4gICAgICAgIGlmIChjdXN0b20pXG4gICAgICAgICAgICByZXR1cm4gY3VzdG9tO1xuICAgICAgICBsZXQgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICBzcGFuLnRleHRDb250ZW50ID0gcGg7XG4gICAgICAgIHNwYW4udGl0bGUgPSBkZXNjO1xuICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgZGVzYyk7XG4gICAgICAgIHNwYW4uY2xhc3NOYW1lID0gXCJjbS1zcGVjaWFsQ2hhclwiO1xuICAgICAgICByZXR1cm4gc3BhbjtcbiAgICB9XG4gICAgaWdub3JlRXZlbnQoKSB7IHJldHVybiBmYWxzZTsgfVxufVxuY2xhc3MgVGFiV2lkZ2V0IGV4dGVuZHMgV2lkZ2V0VHlwZSB7XG4gICAgY29uc3RydWN0b3Iod2lkdGgpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIH1cbiAgICBlcShvdGhlcikgeyByZXR1cm4gb3RoZXIud2lkdGggPT0gdGhpcy53aWR0aDsgfVxuICAgIHRvRE9NKCkge1xuICAgICAgICBsZXQgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICBzcGFuLnRleHRDb250ZW50ID0gXCJcXHRcIjtcbiAgICAgICAgc3Bhbi5jbGFzc05hbWUgPSBcImNtLXRhYlwiO1xuICAgICAgICBzcGFuLnN0eWxlLndpZHRoID0gdGhpcy53aWR0aCArIFwicHhcIjtcbiAgICAgICAgcmV0dXJuIHNwYW47XG4gICAgfVxuICAgIGlnbm9yZUV2ZW50KCkgeyByZXR1cm4gZmFsc2U7IH1cbn1cblxuY29uc3QgcGx1Z2luID0gLypAX19QVVJFX18qL1ZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSAxMDAwO1xuICAgICAgICB0aGlzLmF0dHJzID0geyBzdHlsZTogXCJwYWRkaW5nLWJvdHRvbTogMTAwMHB4XCIgfTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBsZXQgeyB2aWV3IH0gPSB1cGRhdGU7XG4gICAgICAgIGxldCBoZWlnaHQgPSB2aWV3LnZpZXdTdGF0ZS5lZGl0b3JIZWlnaHQgKiB2aWV3LnNjYWxlWSAtXG4gICAgICAgICAgICB2aWV3LmRlZmF1bHRMaW5lSGVpZ2h0IC0gdmlldy5kb2N1bWVudFBhZGRpbmcudG9wIC0gMC41O1xuICAgICAgICBpZiAoaGVpZ2h0ID49IDAgJiYgaGVpZ2h0ICE9IHRoaXMuaGVpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgICAgIHRoaXMuYXR0cnMgPSB7IHN0eWxlOiBgcGFkZGluZy1ib3R0b206ICR7aGVpZ2h0fXB4YCB9O1xuICAgICAgICB9XG4gICAgfVxufSk7XG4vKipcblJldHVybnMgYW4gZXh0ZW5zaW9uIHRoYXQgbWFrZXMgc3VyZSB0aGUgY29udGVudCBoYXMgYSBib3R0b21cbm1hcmdpbiBlcXVpdmFsZW50IHRvIHRoZSBoZWlnaHQgb2YgdGhlIGVkaXRvciwgbWludXMgb25lIGxpbmVcbmhlaWdodCwgc28gdGhhdCBldmVyeSBsaW5lIGluIHRoZSBkb2N1bWVudCBjYW4gYmUgc2Nyb2xsZWQgdG8gdGhlXG50b3Agb2YgdGhlIGVkaXRvci5cblxuVGhpcyBpcyBvbmx5IG1lYW5pbmdmdWwgd2hlbiB0aGUgZWRpdG9yIGlzIHNjcm9sbGFibGUsIGFuZCBzaG91bGRcbm5vdCBiZSBlbmFibGVkIGluIGVkaXRvcnMgdGhhdCB0YWtlIHRoZSBzaXplIG9mIHRoZWlyIGNvbnRlbnQuXG4qL1xuZnVuY3Rpb24gc2Nyb2xsUGFzdEVuZCgpIHtcbiAgICByZXR1cm4gW3BsdWdpbiwgY29udGVudEF0dHJpYnV0ZXMub2YodmlldyA9PiB7IHZhciBfYTsgcmV0dXJuICgoX2EgPSB2aWV3LnBsdWdpbihwbHVnaW4pKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYXR0cnMpIHx8IG51bGw7IH0pXTtcbn1cblxuLyoqXG5NYXJrIGxpbmVzIHRoYXQgaGF2ZSBhIGN1cnNvciBvbiB0aGVtIHdpdGggdGhlIGBcImNtLWFjdGl2ZUxpbmVcImBcbkRPTSBjbGFzcy5cbiovXG5mdW5jdGlvbiBoaWdobGlnaHRBY3RpdmVMaW5lKCkge1xuICAgIHJldHVybiBhY3RpdmVMaW5lSGlnaGxpZ2h0ZXI7XG59XG5jb25zdCBsaW5lRGVjbyA9IC8qQF9fUFVSRV9fKi9EZWNvcmF0aW9uLmxpbmUoeyBjbGFzczogXCJjbS1hY3RpdmVMaW5lXCIgfSk7XG5jb25zdCBhY3RpdmVMaW5lSGlnaGxpZ2h0ZXIgPSAvKkBfX1BVUkVfXyovVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuZ2V0RGVjbyh2aWV3KTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBpZiAodXBkYXRlLmRvY0NoYW5nZWQgfHwgdXBkYXRlLnNlbGVjdGlvblNldClcbiAgICAgICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSB0aGlzLmdldERlY28odXBkYXRlLnZpZXcpO1xuICAgIH1cbiAgICBnZXREZWNvKHZpZXcpIHtcbiAgICAgICAgbGV0IGxhc3RMaW5lU3RhcnQgPSAtMSwgZGVjbyA9IFtdO1xuICAgICAgICBmb3IgKGxldCByIG9mIHZpZXcuc3RhdGUuc2VsZWN0aW9uLnJhbmdlcykge1xuICAgICAgICAgICAgbGV0IGxpbmUgPSB2aWV3LmxpbmVCbG9ja0F0KHIuaGVhZCk7XG4gICAgICAgICAgICBpZiAobGluZS5mcm9tID4gbGFzdExpbmVTdGFydCkge1xuICAgICAgICAgICAgICAgIGRlY28ucHVzaChsaW5lRGVjby5yYW5nZShsaW5lLmZyb20pKTtcbiAgICAgICAgICAgICAgICBsYXN0TGluZVN0YXJ0ID0gbGluZS5mcm9tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBEZWNvcmF0aW9uLnNldChkZWNvKTtcbiAgICB9XG59LCB7XG4gICAgZGVjb3JhdGlvbnM6IHYgPT4gdi5kZWNvcmF0aW9uc1xufSk7XG5cbmNsYXNzIFBsYWNlaG9sZGVyIGV4dGVuZHMgV2lkZ2V0VHlwZSB7XG4gICAgY29uc3RydWN0b3IoY29udGVudCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuICAgIH1cbiAgICB0b0RPTSgpIHtcbiAgICAgICAgbGV0IHdyYXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgd3JhcC5jbGFzc05hbWUgPSBcImNtLXBsYWNlaG9sZGVyXCI7XG4gICAgICAgIHdyYXAuc3R5bGUucG9pbnRlckV2ZW50cyA9IFwibm9uZVwiO1xuICAgICAgICB3cmFwLmFwcGVuZENoaWxkKHR5cGVvZiB0aGlzLmNvbnRlbnQgPT0gXCJzdHJpbmdcIiA/IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRoaXMuY29udGVudCkgOiB0aGlzLmNvbnRlbnQpO1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuY29udGVudCA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgd3JhcC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIFwicGxhY2Vob2xkZXIgXCIgKyB0aGlzLmNvbnRlbnQpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB3cmFwLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIFwidHJ1ZVwiKTtcbiAgICAgICAgcmV0dXJuIHdyYXA7XG4gICAgfVxuICAgIGNvb3Jkc0F0KGRvbSkge1xuICAgICAgICBsZXQgcmVjdHMgPSBkb20uZmlyc3RDaGlsZCA/IGNsaWVudFJlY3RzRm9yKGRvbS5maXJzdENoaWxkKSA6IFtdO1xuICAgICAgICBpZiAoIXJlY3RzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb20ucGFyZW50Tm9kZSk7XG4gICAgICAgIGxldCByZWN0ID0gZmxhdHRlblJlY3QocmVjdHNbMF0sIHN0eWxlLmRpcmVjdGlvbiAhPSBcInJ0bFwiKTtcbiAgICAgICAgbGV0IGxpbmVIZWlnaHQgPSBwYXJzZUludChzdHlsZS5saW5lSGVpZ2h0KTtcbiAgICAgICAgaWYgKHJlY3QuYm90dG9tIC0gcmVjdC50b3AgPiBsaW5lSGVpZ2h0ICogMS41KVxuICAgICAgICAgICAgcmV0dXJuIHsgbGVmdDogcmVjdC5sZWZ0LCByaWdodDogcmVjdC5yaWdodCwgdG9wOiByZWN0LnRvcCwgYm90dG9tOiByZWN0LnRvcCArIGxpbmVIZWlnaHQgfTtcbiAgICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgfVxuICAgIGlnbm9yZUV2ZW50KCkgeyByZXR1cm4gZmFsc2U7IH1cbn1cbi8qKlxuRXh0ZW5zaW9uIHRoYXQgZW5hYmxlcyBhIHBsYWNlaG9sZGVy4oCUYSBwaWVjZSBvZiBleGFtcGxlIGNvbnRlbnRcbnRvIHNob3cgd2hlbiB0aGUgZWRpdG9yIGlzIGVtcHR5LlxuKi9cbmZ1bmN0aW9uIHBsYWNlaG9sZGVyKGNvbnRlbnQpIHtcbiAgICByZXR1cm4gVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3Mge1xuICAgICAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICAgICAgdGhpcy5wbGFjZWhvbGRlciA9IGNvbnRlbnRcbiAgICAgICAgICAgICAgICA/IERlY29yYXRpb24uc2V0KFtEZWNvcmF0aW9uLndpZGdldCh7IHdpZGdldDogbmV3IFBsYWNlaG9sZGVyKGNvbnRlbnQpLCBzaWRlOiAxIH0pLnJhbmdlKDApXSlcbiAgICAgICAgICAgICAgICA6IERlY29yYXRpb24ubm9uZTtcbiAgICAgICAgfVxuICAgICAgICBnZXQgZGVjb3JhdGlvbnMoKSB7IHJldHVybiB0aGlzLnZpZXcuc3RhdGUuZG9jLmxlbmd0aCA/IERlY29yYXRpb24ubm9uZSA6IHRoaXMucGxhY2Vob2xkZXI7IH1cbiAgICB9LCB7IGRlY29yYXRpb25zOiB2ID0+IHYuZGVjb3JhdGlvbnMgfSk7XG59XG5cbi8vIERvbid0IGNvbXB1dGUgcHJlY2lzZSBjb2x1bW4gcG9zaXRpb25zIGZvciBsaW5lIG9mZnNldHMgYWJvdmUgdGhpc1xuLy8gKHNpbmNlIGl0IGNvdWxkIGdldCBleHBlbnNpdmUpLiBBc3N1bWUgb2Zmc2V0PT1jb2x1bW4gZm9yIHRoZW0uXG5jb25zdCBNYXhPZmYgPSAyMDAwO1xuZnVuY3Rpb24gcmVjdGFuZ2xlRm9yKHN0YXRlLCBhLCBiKSB7XG4gICAgbGV0IHN0YXJ0TGluZSA9IE1hdGgubWluKGEubGluZSwgYi5saW5lKSwgZW5kTGluZSA9IE1hdGgubWF4KGEubGluZSwgYi5saW5lKTtcbiAgICBsZXQgcmFuZ2VzID0gW107XG4gICAgaWYgKGEub2ZmID4gTWF4T2ZmIHx8IGIub2ZmID4gTWF4T2ZmIHx8IGEuY29sIDwgMCB8fCBiLmNvbCA8IDApIHtcbiAgICAgICAgbGV0IHN0YXJ0T2ZmID0gTWF0aC5taW4oYS5vZmYsIGIub2ZmKSwgZW5kT2ZmID0gTWF0aC5tYXgoYS5vZmYsIGIub2ZmKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0TGluZTsgaSA8PSBlbmRMaW5lOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBsaW5lID0gc3RhdGUuZG9jLmxpbmUoaSk7XG4gICAgICAgICAgICBpZiAobGluZS5sZW5ndGggPD0gZW5kT2ZmKVxuICAgICAgICAgICAgICAgIHJhbmdlcy5wdXNoKEVkaXRvclNlbGVjdGlvbi5yYW5nZShsaW5lLmZyb20gKyBzdGFydE9mZiwgbGluZS50byArIGVuZE9mZikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgc3RhcnRDb2wgPSBNYXRoLm1pbihhLmNvbCwgYi5jb2wpLCBlbmRDb2wgPSBNYXRoLm1heChhLmNvbCwgYi5jb2wpO1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnRMaW5lOyBpIDw9IGVuZExpbmU7IGkrKykge1xuICAgICAgICAgICAgbGV0IGxpbmUgPSBzdGF0ZS5kb2MubGluZShpKTtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IGZpbmRDb2x1bW4obGluZS50ZXh0LCBzdGFydENvbCwgc3RhdGUudGFiU2l6ZSwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgICAgICAgICAgcmFuZ2VzLnB1c2goRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihsaW5lLnRvKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgZW5kID0gZmluZENvbHVtbihsaW5lLnRleHQsIGVuZENvbCwgc3RhdGUudGFiU2l6ZSk7XG4gICAgICAgICAgICAgICAgcmFuZ2VzLnB1c2goRWRpdG9yU2VsZWN0aW9uLnJhbmdlKGxpbmUuZnJvbSArIHN0YXJ0LCBsaW5lLmZyb20gKyBlbmQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmFuZ2VzO1xufVxuZnVuY3Rpb24gYWJzb2x1dGVDb2x1bW4odmlldywgeCkge1xuICAgIGxldCByZWYgPSB2aWV3LmNvb3Jkc0F0UG9zKHZpZXcudmlld3BvcnQuZnJvbSk7XG4gICAgcmV0dXJuIHJlZiA/IE1hdGgucm91bmQoTWF0aC5hYnMoKHJlZi5sZWZ0IC0geCkgLyB2aWV3LmRlZmF1bHRDaGFyYWN0ZXJXaWR0aCkpIDogLTE7XG59XG5mdW5jdGlvbiBnZXRQb3ModmlldywgZXZlbnQpIHtcbiAgICBsZXQgb2Zmc2V0ID0gdmlldy5wb3NBdENvb3Jkcyh7IHg6IGV2ZW50LmNsaWVudFgsIHk6IGV2ZW50LmNsaWVudFkgfSwgZmFsc2UpO1xuICAgIGxldCBsaW5lID0gdmlldy5zdGF0ZS5kb2MubGluZUF0KG9mZnNldCksIG9mZiA9IG9mZnNldCAtIGxpbmUuZnJvbTtcbiAgICBsZXQgY29sID0gb2ZmID4gTWF4T2ZmID8gLTFcbiAgICAgICAgOiBvZmYgPT0gbGluZS5sZW5ndGggPyBhYnNvbHV0ZUNvbHVtbih2aWV3LCBldmVudC5jbGllbnRYKVxuICAgICAgICAgICAgOiBjb3VudENvbHVtbihsaW5lLnRleHQsIHZpZXcuc3RhdGUudGFiU2l6ZSwgb2Zmc2V0IC0gbGluZS5mcm9tKTtcbiAgICByZXR1cm4geyBsaW5lOiBsaW5lLm51bWJlciwgY29sLCBvZmYgfTtcbn1cbmZ1bmN0aW9uIHJlY3RhbmdsZVNlbGVjdGlvblN0eWxlKHZpZXcsIGV2ZW50KSB7XG4gICAgbGV0IHN0YXJ0ID0gZ2V0UG9zKHZpZXcsIGV2ZW50KSwgc3RhcnRTZWwgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcbiAgICBpZiAoIXN0YXJ0KVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4ge1xuICAgICAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgICAgICBpZiAodXBkYXRlLmRvY0NoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV3U3RhcnQgPSB1cGRhdGUuY2hhbmdlcy5tYXBQb3ModXBkYXRlLnN0YXJ0U3RhdGUuZG9jLmxpbmUoc3RhcnQubGluZSkuZnJvbSk7XG4gICAgICAgICAgICAgICAgbGV0IG5ld0xpbmUgPSB1cGRhdGUuc3RhdGUuZG9jLmxpbmVBdChuZXdTdGFydCk7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSB7IGxpbmU6IG5ld0xpbmUubnVtYmVyLCBjb2w6IHN0YXJ0LmNvbCwgb2ZmOiBNYXRoLm1pbihzdGFydC5vZmYsIG5ld0xpbmUubGVuZ3RoKSB9O1xuICAgICAgICAgICAgICAgIHN0YXJ0U2VsID0gc3RhcnRTZWwubWFwKHVwZGF0ZS5jaGFuZ2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZ2V0KGV2ZW50LCBfZXh0ZW5kLCBtdWx0aXBsZSkge1xuICAgICAgICAgICAgbGV0IGN1ciA9IGdldFBvcyh2aWV3LCBldmVudCk7XG4gICAgICAgICAgICBpZiAoIWN1cilcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnRTZWw7XG4gICAgICAgICAgICBsZXQgcmFuZ2VzID0gcmVjdGFuZ2xlRm9yKHZpZXcuc3RhdGUsIHN0YXJ0LCBjdXIpO1xuICAgICAgICAgICAgaWYgKCFyYW5nZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybiBzdGFydFNlbDtcbiAgICAgICAgICAgIGlmIChtdWx0aXBsZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShyYW5nZXMuY29uY2F0KHN0YXJ0U2VsLnJhbmdlcykpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKHJhbmdlcyk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuLyoqXG5DcmVhdGUgYW4gZXh0ZW5zaW9uIHRoYXQgZW5hYmxlcyByZWN0YW5ndWxhciBzZWxlY3Rpb25zLiBCeVxuZGVmYXVsdCwgaXQgd2lsbCByZWFjdCB0byBsZWZ0IG1vdXNlIGRyYWcgd2l0aCB0aGUgQWx0IGtleSBoZWxkXG5kb3duLiBXaGVuIHN1Y2ggYSBzZWxlY3Rpb24gb2NjdXJzLCB0aGUgdGV4dCB3aXRoaW4gdGhlIHJlY3RhbmdsZVxudGhhdCB3YXMgZHJhZ2dlZCBvdmVyIHdpbGwgYmUgc2VsZWN0ZWQsIGFzIG9uZSBzZWxlY3Rpb25cbltyYW5nZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5TZWxlY3Rpb25SYW5nZSkgcGVyIGxpbmUuXG4qL1xuZnVuY3Rpb24gcmVjdGFuZ3VsYXJTZWxlY3Rpb24ob3B0aW9ucykge1xuICAgIGxldCBmaWx0ZXIgPSAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmV2ZW50RmlsdGVyKSB8fCAoZSA9PiBlLmFsdEtleSAmJiBlLmJ1dHRvbiA9PSAwKTtcbiAgICByZXR1cm4gRWRpdG9yVmlldy5tb3VzZVNlbGVjdGlvblN0eWxlLm9mKCh2aWV3LCBldmVudCkgPT4gZmlsdGVyKGV2ZW50KSA/IHJlY3RhbmdsZVNlbGVjdGlvblN0eWxlKHZpZXcsIGV2ZW50KSA6IG51bGwpO1xufVxuY29uc3Qga2V5cyA9IHtcbiAgICBBbHQ6IFsxOCwgZSA9PiAhIWUuYWx0S2V5XSxcbiAgICBDb250cm9sOiBbMTcsIGUgPT4gISFlLmN0cmxLZXldLFxuICAgIFNoaWZ0OiBbMTYsIGUgPT4gISFlLnNoaWZ0S2V5XSxcbiAgICBNZXRhOiBbOTEsIGUgPT4gISFlLm1ldGFLZXldXG59O1xuY29uc3Qgc2hvd0Nyb3NzaGFpciA9IHsgc3R5bGU6IFwiY3Vyc29yOiBjcm9zc2hhaXJcIiB9O1xuLyoqXG5SZXR1cm5zIGFuIGV4dGVuc2lvbiB0aGF0IHR1cm5zIHRoZSBwb2ludGVyIGN1cnNvciBpbnRvIGFcbmNyb3NzaGFpciB3aGVuIGEgZ2l2ZW4gbW9kaWZpZXIga2V5LCBkZWZhdWx0aW5nIHRvIEFsdCwgaXMgaGVsZFxuZG93bi4gQ2FuIHNlcnZlIGFzIGEgdmlzdWFsIGhpbnQgdGhhdCByZWN0YW5ndWxhciBzZWxlY3Rpb24gaXNcbmdvaW5nIHRvIGhhcHBlbiB3aGVuIHBhaXJlZCB3aXRoXG5bYHJlY3Rhbmd1bGFyU2VsZWN0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LnJlY3Rhbmd1bGFyU2VsZWN0aW9uKS5cbiovXG5mdW5jdGlvbiBjcm9zc2hhaXJDdXJzb3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgbGV0IFtjb2RlLCBnZXR0ZXJdID0ga2V5c1tvcHRpb25zLmtleSB8fCBcIkFsdFwiXTtcbiAgICBsZXQgcGx1Z2luID0gVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3Mge1xuICAgICAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICAgICAgdGhpcy5pc0Rvd24gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBzZXQoaXNEb3duKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0Rvd24gIT0gaXNEb3duKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc0Rvd24gPSBpc0Rvd247XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3LnVwZGF0ZShbXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGV2ZW50T2JzZXJ2ZXJzOiB7XG4gICAgICAgICAgICBrZXlkb3duKGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldChlLmtleUNvZGUgPT0gY29kZSB8fCBnZXR0ZXIoZSkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGtleXVwKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZS5rZXlDb2RlID09IGNvZGUgfHwgIWdldHRlcihlKSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXQoZmFsc2UpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1vdXNlbW92ZShlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXQoZ2V0dGVyKGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBbXG4gICAgICAgIHBsdWdpbixcbiAgICAgICAgRWRpdG9yVmlldy5jb250ZW50QXR0cmlidXRlcy5vZih2aWV3ID0+IHsgdmFyIF9hOyByZXR1cm4gKChfYSA9IHZpZXcucGx1Z2luKHBsdWdpbikpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pc0Rvd24pID8gc2hvd0Nyb3NzaGFpciA6IG51bGw7IH0pXG4gICAgXTtcbn1cblxuY29uc3QgT3V0c2lkZSA9IFwiLTEwMDAwcHhcIjtcbmNsYXNzIFRvb2x0aXBWaWV3TWFuYWdlciB7XG4gICAgY29uc3RydWN0b3IodmlldywgZmFjZXQsIGNyZWF0ZVRvb2x0aXBWaWV3KSB7XG4gICAgICAgIHRoaXMuZmFjZXQgPSBmYWNldDtcbiAgICAgICAgdGhpcy5jcmVhdGVUb29sdGlwVmlldyA9IGNyZWF0ZVRvb2x0aXBWaWV3O1xuICAgICAgICB0aGlzLmlucHV0ID0gdmlldy5zdGF0ZS5mYWNldChmYWNldCk7XG4gICAgICAgIHRoaXMudG9vbHRpcHMgPSB0aGlzLmlucHV0LmZpbHRlcih0ID0+IHQpO1xuICAgICAgICB0aGlzLnRvb2x0aXBWaWV3cyA9IHRoaXMudG9vbHRpcHMubWFwKGNyZWF0ZVRvb2x0aXBWaWV3KTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSwgYWJvdmUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgaW5wdXQgPSB1cGRhdGUuc3RhdGUuZmFjZXQodGhpcy5mYWNldCk7XG4gICAgICAgIGxldCB0b29sdGlwcyA9IGlucHV0LmZpbHRlcih4ID0+IHgpO1xuICAgICAgICBpZiAoaW5wdXQgPT09IHRoaXMuaW5wdXQpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHQgb2YgdGhpcy50b29sdGlwVmlld3MpXG4gICAgICAgICAgICAgICAgaWYgKHQudXBkYXRlKVxuICAgICAgICAgICAgICAgICAgICB0LnVwZGF0ZSh1cGRhdGUpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0b29sdGlwVmlld3MgPSBbXSwgbmV3QWJvdmUgPSBhYm92ZSA/IFtdIDogbnVsbDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b29sdGlwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHRpcCA9IHRvb2x0aXBzW2ldLCBrbm93biA9IC0xO1xuICAgICAgICAgICAgaWYgKCF0aXApXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudG9vbHRpcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgb3RoZXIgPSB0aGlzLnRvb2x0aXBzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChvdGhlciAmJiBvdGhlci5jcmVhdGUgPT0gdGlwLmNyZWF0ZSlcbiAgICAgICAgICAgICAgICAgICAga25vd24gPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGtub3duIDwgMCkge1xuICAgICAgICAgICAgICAgIHRvb2x0aXBWaWV3c1tpXSA9IHRoaXMuY3JlYXRlVG9vbHRpcFZpZXcodGlwKTtcbiAgICAgICAgICAgICAgICBpZiAobmV3QWJvdmUpXG4gICAgICAgICAgICAgICAgICAgIG5ld0Fib3ZlW2ldID0gISF0aXAuYWJvdmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgdG9vbHRpcFZpZXcgPSB0b29sdGlwVmlld3NbaV0gPSB0aGlzLnRvb2x0aXBWaWV3c1trbm93bl07XG4gICAgICAgICAgICAgICAgaWYgKG5ld0Fib3ZlKVxuICAgICAgICAgICAgICAgICAgICBuZXdBYm92ZVtpXSA9IGFib3ZlW2tub3duXTtcbiAgICAgICAgICAgICAgICBpZiAodG9vbHRpcFZpZXcudXBkYXRlKVxuICAgICAgICAgICAgICAgICAgICB0b29sdGlwVmlldy51cGRhdGUodXBkYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCB0IG9mIHRoaXMudG9vbHRpcFZpZXdzKVxuICAgICAgICAgICAgaWYgKHRvb2x0aXBWaWV3cy5pbmRleE9mKHQpIDwgMCkge1xuICAgICAgICAgICAgICAgIHQuZG9tLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIChfYSA9IHQuZGVzdHJveSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIGlmIChhYm92ZSkge1xuICAgICAgICAgICAgbmV3QWJvdmUuZm9yRWFjaCgodmFsLCBpKSA9PiBhYm92ZVtpXSA9IHZhbCk7XG4gICAgICAgICAgICBhYm92ZS5sZW5ndGggPSBuZXdBYm92ZS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgICAgICB0aGlzLnRvb2x0aXBzID0gdG9vbHRpcHM7XG4gICAgICAgIHRoaXMudG9vbHRpcFZpZXdzID0gdG9vbHRpcFZpZXdzO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG4vKipcbkNyZWF0ZXMgYW4gZXh0ZW5zaW9uIHRoYXQgY29uZmlndXJlcyB0b29sdGlwIGJlaGF2aW9yLlxuKi9cbmZ1bmN0aW9uIHRvb2x0aXBzKGNvbmZpZyA9IHt9KSB7XG4gICAgcmV0dXJuIHRvb2x0aXBDb25maWcub2YoY29uZmlnKTtcbn1cbmZ1bmN0aW9uIHdpbmRvd1NwYWNlKHZpZXcpIHtcbiAgICBsZXQgeyB3aW4gfSA9IHZpZXc7XG4gICAgcmV0dXJuIHsgdG9wOiAwLCBsZWZ0OiAwLCBib3R0b206IHdpbi5pbm5lckhlaWdodCwgcmlnaHQ6IHdpbi5pbm5lcldpZHRoIH07XG59XG5jb25zdCB0b29sdGlwQ29uZmlnID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZTogdmFsdWVzID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIHJldHVybiAoe1xuICAgICAgICAgICAgcG9zaXRpb246IGJyb3dzZXIuaW9zID8gXCJhYnNvbHV0ZVwiIDogKChfYSA9IHZhbHVlcy5maW5kKGNvbmYgPT4gY29uZi5wb3NpdGlvbikpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wb3NpdGlvbikgfHwgXCJmaXhlZFwiLFxuICAgICAgICAgICAgcGFyZW50OiAoKF9iID0gdmFsdWVzLmZpbmQoY29uZiA9PiBjb25mLnBhcmVudCkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5wYXJlbnQpIHx8IG51bGwsXG4gICAgICAgICAgICB0b29sdGlwU3BhY2U6ICgoX2MgPSB2YWx1ZXMuZmluZChjb25mID0+IGNvbmYudG9vbHRpcFNwYWNlKSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnRvb2x0aXBTcGFjZSkgfHwgd2luZG93U3BhY2UsXG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuY29uc3Qga25vd25IZWlnaHQgPSAvKkBfX1BVUkVfXyovbmV3IFdlYWtNYXAoKTtcbmNvbnN0IHRvb2x0aXBQbHVnaW4gPSAvKkBfX1BVUkVfXyovVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5hYm92ZSA9IFtdO1xuICAgICAgICB0aGlzLmluVmlldyA9IHRydWU7XG4gICAgICAgIHRoaXMubWFkZUFic29sdXRlID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGFzdFRyYW5zYWN0aW9uID0gMDtcbiAgICAgICAgdGhpcy5tZWFzdXJlVGltZW91dCA9IC0xO1xuICAgICAgICBsZXQgY29uZmlnID0gdmlldy5zdGF0ZS5mYWNldCh0b29sdGlwQ29uZmlnKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IGNvbmZpZy5wb3NpdGlvbjtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBjb25maWcucGFyZW50O1xuICAgICAgICB0aGlzLmNsYXNzZXMgPSB2aWV3LnRoZW1lQ2xhc3NlcztcbiAgICAgICAgdGhpcy5jcmVhdGVDb250YWluZXIoKTtcbiAgICAgICAgdGhpcy5tZWFzdXJlUmVxID0geyByZWFkOiB0aGlzLnJlYWRNZWFzdXJlLmJpbmQodGhpcyksIHdyaXRlOiB0aGlzLndyaXRlTWVhc3VyZS5iaW5kKHRoaXMpLCBrZXk6IHRoaXMgfTtcbiAgICAgICAgdGhpcy5tYW5hZ2VyID0gbmV3IFRvb2x0aXBWaWV3TWFuYWdlcih2aWV3LCBzaG93VG9vbHRpcCwgdCA9PiB0aGlzLmNyZWF0ZVRvb2x0aXAodCkpO1xuICAgICAgICB0aGlzLmludGVyc2VjdGlvbk9ic2VydmVyID0gdHlwZW9mIEludGVyc2VjdGlvbk9ic2VydmVyID09IFwiZnVuY3Rpb25cIiA/IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihlbnRyaWVzID0+IHtcbiAgICAgICAgICAgIGlmIChEYXRlLm5vdygpID4gdGhpcy5sYXN0VHJhbnNhY3Rpb24gLSA1MCAmJlxuICAgICAgICAgICAgICAgIGVudHJpZXMubGVuZ3RoID4gMCAmJiBlbnRyaWVzW2VudHJpZXMubGVuZ3RoIC0gMV0uaW50ZXJzZWN0aW9uUmF0aW8gPCAxKVxuICAgICAgICAgICAgICAgIHRoaXMubWVhc3VyZVNvb24oKTtcbiAgICAgICAgfSwgeyB0aHJlc2hvbGQ6IFsxXSB9KSA6IG51bGw7XG4gICAgICAgIHRoaXMub2JzZXJ2ZUludGVyc2VjdGlvbigpO1xuICAgICAgICB2aWV3Lndpbi5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMubWVhc3VyZVNvb24gPSB0aGlzLm1lYXN1cmVTb29uLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLm1heWJlTWVhc3VyZSgpO1xuICAgIH1cbiAgICBjcmVhdGVDb250YWluZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXIuc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5jbGFzc05hbWUgPSB0aGlzLnZpZXcudGhlbWVDbGFzc2VzO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQuYXBwZW5kQ2hpbGQodGhpcy5jb250YWluZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXIgPSB0aGlzLnZpZXcuZG9tO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9ic2VydmVJbnRlcnNlY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmludGVyc2VjdGlvbk9ic2VydmVyKSB7XG4gICAgICAgICAgICB0aGlzLmludGVyc2VjdGlvbk9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIGZvciAobGV0IHRvb2x0aXAgb2YgdGhpcy5tYW5hZ2VyLnRvb2x0aXBWaWV3cylcbiAgICAgICAgICAgICAgICB0aGlzLmludGVyc2VjdGlvbk9ic2VydmVyLm9ic2VydmUodG9vbHRpcC5kb20pO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1lYXN1cmVTb29uKCkge1xuICAgICAgICBpZiAodGhpcy5tZWFzdXJlVGltZW91dCA8IDApXG4gICAgICAgICAgICB0aGlzLm1lYXN1cmVUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5tZWFzdXJlVGltZW91dCA9IC0xO1xuICAgICAgICAgICAgICAgIHRoaXMubWF5YmVNZWFzdXJlKCk7XG4gICAgICAgICAgICB9LCA1MCk7XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgaWYgKHVwZGF0ZS50cmFuc2FjdGlvbnMubGVuZ3RoKVxuICAgICAgICAgICAgdGhpcy5sYXN0VHJhbnNhY3Rpb24gPSBEYXRlLm5vdygpO1xuICAgICAgICBsZXQgdXBkYXRlZCA9IHRoaXMubWFuYWdlci51cGRhdGUodXBkYXRlLCB0aGlzLmFib3ZlKTtcbiAgICAgICAgaWYgKHVwZGF0ZWQpXG4gICAgICAgICAgICB0aGlzLm9ic2VydmVJbnRlcnNlY3Rpb24oKTtcbiAgICAgICAgbGV0IHNob3VsZE1lYXN1cmUgPSB1cGRhdGVkIHx8IHVwZGF0ZS5nZW9tZXRyeUNoYW5nZWQ7XG4gICAgICAgIGxldCBuZXdDb25maWcgPSB1cGRhdGUuc3RhdGUuZmFjZXQodG9vbHRpcENvbmZpZyk7XG4gICAgICAgIGlmIChuZXdDb25maWcucG9zaXRpb24gIT0gdGhpcy5wb3NpdGlvbiAmJiAhdGhpcy5tYWRlQWJzb2x1dGUpIHtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24gPSBuZXdDb25maWcucG9zaXRpb247XG4gICAgICAgICAgICBmb3IgKGxldCB0IG9mIHRoaXMubWFuYWdlci50b29sdGlwVmlld3MpXG4gICAgICAgICAgICAgICAgdC5kb20uc3R5bGUucG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uO1xuICAgICAgICAgICAgc2hvdWxkTWVhc3VyZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld0NvbmZpZy5wYXJlbnQgIT0gdGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudClcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5yZW1vdmUoKTtcbiAgICAgICAgICAgIHRoaXMucGFyZW50ID0gbmV3Q29uZmlnLnBhcmVudDtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlQ29udGFpbmVyKCk7XG4gICAgICAgICAgICBmb3IgKGxldCB0IG9mIHRoaXMubWFuYWdlci50b29sdGlwVmlld3MpXG4gICAgICAgICAgICAgICAgdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQodC5kb20pO1xuICAgICAgICAgICAgc2hvdWxkTWVhc3VyZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5wYXJlbnQgJiYgdGhpcy52aWV3LnRoZW1lQ2xhc3NlcyAhPSB0aGlzLmNsYXNzZXMpIHtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NlcyA9IHRoaXMuY29udGFpbmVyLmNsYXNzTmFtZSA9IHRoaXMudmlldy50aGVtZUNsYXNzZXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3VsZE1lYXN1cmUpXG4gICAgICAgICAgICB0aGlzLm1heWJlTWVhc3VyZSgpO1xuICAgIH1cbiAgICBjcmVhdGVUb29sdGlwKHRvb2x0aXApIHtcbiAgICAgICAgbGV0IHRvb2x0aXBWaWV3ID0gdG9vbHRpcC5jcmVhdGUodGhpcy52aWV3KTtcbiAgICAgICAgdG9vbHRpcFZpZXcuZG9tLmNsYXNzTGlzdC5hZGQoXCJjbS10b29sdGlwXCIpO1xuICAgICAgICBpZiAodG9vbHRpcC5hcnJvdyAmJiAhdG9vbHRpcFZpZXcuZG9tLnF1ZXJ5U2VsZWN0b3IoXCIuY20tdG9vbHRpcCA+IC5jbS10b29sdGlwLWFycm93XCIpKSB7XG4gICAgICAgICAgICBsZXQgYXJyb3cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgYXJyb3cuY2xhc3NOYW1lID0gXCJjbS10b29sdGlwLWFycm93XCI7XG4gICAgICAgICAgICB0b29sdGlwVmlldy5kb20uYXBwZW5kQ2hpbGQoYXJyb3cpO1xuICAgICAgICB9XG4gICAgICAgIHRvb2x0aXBWaWV3LmRvbS5zdHlsZS5wb3NpdGlvbiA9IHRoaXMucG9zaXRpb247XG4gICAgICAgIHRvb2x0aXBWaWV3LmRvbS5zdHlsZS50b3AgPSBPdXRzaWRlO1xuICAgICAgICB0b29sdGlwVmlldy5kb20uc3R5bGUubGVmdCA9IFwiMHB4XCI7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKHRvb2x0aXBWaWV3LmRvbSk7XG4gICAgICAgIGlmICh0b29sdGlwVmlldy5tb3VudClcbiAgICAgICAgICAgIHRvb2x0aXBWaWV3Lm1vdW50KHRoaXMudmlldyk7XG4gICAgICAgIHJldHVybiB0b29sdGlwVmlldztcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdGhpcy52aWV3Lndpbi5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMubWVhc3VyZVNvb24pO1xuICAgICAgICBmb3IgKGxldCB0b29sdGlwVmlldyBvZiB0aGlzLm1hbmFnZXIudG9vbHRpcFZpZXdzKSB7XG4gICAgICAgICAgICB0b29sdGlwVmlldy5kb20ucmVtb3ZlKCk7XG4gICAgICAgICAgICAoX2EgPSB0b29sdGlwVmlldy5kZXN0cm95KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0b29sdGlwVmlldyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGFyZW50KVxuICAgICAgICAgICAgdGhpcy5jb250YWluZXIucmVtb3ZlKCk7XG4gICAgICAgIChfYiA9IHRoaXMuaW50ZXJzZWN0aW9uT2JzZXJ2ZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5kaXNjb25uZWN0KCk7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLm1lYXN1cmVUaW1lb3V0KTtcbiAgICB9XG4gICAgcmVhZE1lYXN1cmUoKSB7XG4gICAgICAgIGxldCBlZGl0b3IgPSB0aGlzLnZpZXcuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBsZXQgc2NhbGVYID0gMSwgc2NhbGVZID0gMSwgbWFrZUFic29sdXRlID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLnBvc2l0aW9uID09IFwiZml4ZWRcIiAmJiB0aGlzLm1hbmFnZXIudG9vbHRpcFZpZXdzLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IHsgZG9tIH0gPSB0aGlzLm1hbmFnZXIudG9vbHRpcFZpZXdzWzBdO1xuICAgICAgICAgICAgaWYgKGJyb3dzZXIuZ2Vja28pIHtcbiAgICAgICAgICAgICAgICAvLyBGaXJlZm94IHNldHMgdGhlIGVsZW1lbnQncyBgb2Zmc2V0UGFyZW50YCB0byB0aGVcbiAgICAgICAgICAgICAgICAvLyB0cmFuc2Zvcm1lZCBlbGVtZW50IHdoZW4gYSB0cmFuc2Zvcm0gaW50ZXJmZXJlcyB3aXRoIGZpeGVkXG4gICAgICAgICAgICAgICAgLy8gcG9zaXRpb25pbmcuXG4gICAgICAgICAgICAgICAgbWFrZUFic29sdXRlID0gZG9tLm9mZnNldFBhcmVudCAhPSB0aGlzLmNvbnRhaW5lci5vd25lckRvY3VtZW50LmJvZHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBPbiBvdGhlciBicm93c2Vycywgd2UgaGF2ZSB0byBhd2t3YXJkbHkgdHJ5IGFuZCB1c2Ugb3RoZXJcbiAgICAgICAgICAgICAgICAvLyBpbmZvcm1hdGlvbiB0byBkZXRlY3QgYSB0cmFuc2Zvcm0uXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudmlldy5zY2FsZVggIT0gMSB8fCB0aGlzLnZpZXcuc2NhbGVZICE9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFrZUFic29sdXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZG9tLnN0eWxlLnRvcCA9PSBPdXRzaWRlICYmIGRvbS5zdHlsZS5sZWZ0ID09IFwiMHB4XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlY3QgPSBkb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIG1ha2VBYnNvbHV0ZSA9IE1hdGguYWJzKHJlY3QudG9wICsgMTAwMDApID4gMSB8fCBNYXRoLmFicyhyZWN0LmxlZnQpID4gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ha2VBYnNvbHV0ZSB8fCB0aGlzLnBvc2l0aW9uID09IFwiYWJzb2x1dGVcIikge1xuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlY3QgPSB0aGlzLnBhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICBpZiAocmVjdC53aWR0aCAmJiByZWN0LmhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICBzY2FsZVggPSByZWN0LndpZHRoIC8gdGhpcy5wYXJlbnQub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIHNjYWxlWSA9IHJlY3QuaGVpZ2h0IC8gdGhpcy5wYXJlbnQub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICh7IHNjYWxlWCwgc2NhbGVZIH0gPSB0aGlzLnZpZXcudmlld1N0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgICAgcGFyZW50OiB0aGlzLnBhcmVudCA/IHRoaXMuY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIDogZWRpdG9yLFxuICAgICAgICAgICAgcG9zOiB0aGlzLm1hbmFnZXIudG9vbHRpcHMubWFwKCh0LCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHR2ID0gdGhpcy5tYW5hZ2VyLnRvb2x0aXBWaWV3c1tpXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHYuZ2V0Q29vcmRzID8gdHYuZ2V0Q29vcmRzKHQucG9zKSA6IHRoaXMudmlldy5jb29yZHNBdFBvcyh0LnBvcyk7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHNpemU6IHRoaXMubWFuYWdlci50b29sdGlwVmlld3MubWFwKCh7IGRvbSB9KSA9PiBkb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpLFxuICAgICAgICAgICAgc3BhY2U6IHRoaXMudmlldy5zdGF0ZS5mYWNldCh0b29sdGlwQ29uZmlnKS50b29sdGlwU3BhY2UodGhpcy52aWV3KSxcbiAgICAgICAgICAgIHNjYWxlWCwgc2NhbGVZLCBtYWtlQWJzb2x1dGVcbiAgICAgICAgfTtcbiAgICB9XG4gICAgd3JpdGVNZWFzdXJlKG1lYXN1cmVkKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKG1lYXN1cmVkLm1ha2VBYnNvbHV0ZSkge1xuICAgICAgICAgICAgdGhpcy5tYWRlQWJzb2x1dGUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICAgICAgICAgIGZvciAobGV0IHQgb2YgdGhpcy5tYW5hZ2VyLnRvb2x0aXBWaWV3cylcbiAgICAgICAgICAgICAgICB0LmRvbS5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgeyBlZGl0b3IsIHNwYWNlLCBzY2FsZVgsIHNjYWxlWSB9ID0gbWVhc3VyZWQ7XG4gICAgICAgIGxldCBvdGhlcnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1hbmFnZXIudG9vbHRpcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB0b29sdGlwID0gdGhpcy5tYW5hZ2VyLnRvb2x0aXBzW2ldLCB0VmlldyA9IHRoaXMubWFuYWdlci50b29sdGlwVmlld3NbaV0sIHsgZG9tIH0gPSB0VmlldztcbiAgICAgICAgICAgIGxldCBwb3MgPSBtZWFzdXJlZC5wb3NbaV0sIHNpemUgPSBtZWFzdXJlZC5zaXplW2ldO1xuICAgICAgICAgICAgLy8gSGlkZSB0b29sdGlwcyB0aGF0IGFyZSBvdXRzaWRlIG9mIHRoZSBlZGl0b3IuXG4gICAgICAgICAgICBpZiAoIXBvcyB8fCBwb3MuYm90dG9tIDw9IE1hdGgubWF4KGVkaXRvci50b3AsIHNwYWNlLnRvcCkgfHxcbiAgICAgICAgICAgICAgICBwb3MudG9wID49IE1hdGgubWluKGVkaXRvci5ib3R0b20sIHNwYWNlLmJvdHRvbSkgfHxcbiAgICAgICAgICAgICAgICBwb3MucmlnaHQgPCBNYXRoLm1heChlZGl0b3IubGVmdCwgc3BhY2UubGVmdCkgLSAuMSB8fFxuICAgICAgICAgICAgICAgIHBvcy5sZWZ0ID4gTWF0aC5taW4oZWRpdG9yLnJpZ2h0LCBzcGFjZS5yaWdodCkgKyAuMSkge1xuICAgICAgICAgICAgICAgIGRvbS5zdHlsZS50b3AgPSBPdXRzaWRlO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGFycm93ID0gdG9vbHRpcC5hcnJvdyA/IHRWaWV3LmRvbS5xdWVyeVNlbGVjdG9yKFwiLmNtLXRvb2x0aXAtYXJyb3dcIikgOiBudWxsO1xuICAgICAgICAgICAgbGV0IGFycm93SGVpZ2h0ID0gYXJyb3cgPyA3IC8qIEFycm93LlNpemUgKi8gOiAwO1xuICAgICAgICAgICAgbGV0IHdpZHRoID0gc2l6ZS5yaWdodCAtIHNpemUubGVmdCwgaGVpZ2h0ID0gKF9hID0ga25vd25IZWlnaHQuZ2V0KHRWaWV3KSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogc2l6ZS5ib3R0b20gLSBzaXplLnRvcDtcbiAgICAgICAgICAgIGxldCBvZmZzZXQgPSB0Vmlldy5vZmZzZXQgfHwgbm9PZmZzZXQsIGx0ciA9IHRoaXMudmlldy50ZXh0RGlyZWN0aW9uID09IERpcmVjdGlvbi5MVFI7XG4gICAgICAgICAgICBsZXQgbGVmdCA9IHNpemUud2lkdGggPiBzcGFjZS5yaWdodCAtIHNwYWNlLmxlZnQgPyAobHRyID8gc3BhY2UubGVmdCA6IHNwYWNlLnJpZ2h0IC0gc2l6ZS53aWR0aClcbiAgICAgICAgICAgICAgICA6IGx0ciA/IE1hdGgubWluKHBvcy5sZWZ0IC0gKGFycm93ID8gMTQgLyogQXJyb3cuT2Zmc2V0ICovIDogMCkgKyBvZmZzZXQueCwgc3BhY2UucmlnaHQgLSB3aWR0aClcbiAgICAgICAgICAgICAgICAgICAgOiBNYXRoLm1heChzcGFjZS5sZWZ0LCBwb3MubGVmdCAtIHdpZHRoICsgKGFycm93ID8gMTQgLyogQXJyb3cuT2Zmc2V0ICovIDogMCkgLSBvZmZzZXQueCk7XG4gICAgICAgICAgICBsZXQgYWJvdmUgPSB0aGlzLmFib3ZlW2ldO1xuICAgICAgICAgICAgaWYgKCF0b29sdGlwLnN0cmljdFNpZGUgJiYgKGFib3ZlXG4gICAgICAgICAgICAgICAgPyBwb3MudG9wIC0gKHNpemUuYm90dG9tIC0gc2l6ZS50b3ApIC0gb2Zmc2V0LnkgPCBzcGFjZS50b3BcbiAgICAgICAgICAgICAgICA6IHBvcy5ib3R0b20gKyAoc2l6ZS5ib3R0b20gLSBzaXplLnRvcCkgKyBvZmZzZXQueSA+IHNwYWNlLmJvdHRvbSkgJiZcbiAgICAgICAgICAgICAgICBhYm92ZSA9PSAoc3BhY2UuYm90dG9tIC0gcG9zLmJvdHRvbSA+IHBvcy50b3AgLSBzcGFjZS50b3ApKVxuICAgICAgICAgICAgICAgIGFib3ZlID0gdGhpcy5hYm92ZVtpXSA9ICFhYm92ZTtcbiAgICAgICAgICAgIGxldCBzcGFjZVZlcnQgPSAoYWJvdmUgPyBwb3MudG9wIC0gc3BhY2UudG9wIDogc3BhY2UuYm90dG9tIC0gcG9zLmJvdHRvbSkgLSBhcnJvd0hlaWdodDtcbiAgICAgICAgICAgIGlmIChzcGFjZVZlcnQgPCBoZWlnaHQgJiYgdFZpZXcucmVzaXplICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGlmIChzcGFjZVZlcnQgPCB0aGlzLnZpZXcuZGVmYXVsdExpbmVIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tLnN0eWxlLnRvcCA9IE91dHNpZGU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBrbm93bkhlaWdodC5zZXQodFZpZXcsIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgZG9tLnN0eWxlLmhlaWdodCA9IChoZWlnaHQgPSBzcGFjZVZlcnQpIC8gc2NhbGVZICsgXCJweFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZG9tLnN0eWxlLmhlaWdodCkge1xuICAgICAgICAgICAgICAgIGRvbS5zdHlsZS5oZWlnaHQgPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHRvcCA9IGFib3ZlID8gcG9zLnRvcCAtIGhlaWdodCAtIGFycm93SGVpZ2h0IC0gb2Zmc2V0LnkgOiBwb3MuYm90dG9tICsgYXJyb3dIZWlnaHQgKyBvZmZzZXQueTtcbiAgICAgICAgICAgIGxldCByaWdodCA9IGxlZnQgKyB3aWR0aDtcbiAgICAgICAgICAgIGlmICh0Vmlldy5vdmVybGFwICE9PSB0cnVlKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IHIgb2Ygb3RoZXJzKVxuICAgICAgICAgICAgICAgICAgICBpZiAoci5sZWZ0IDwgcmlnaHQgJiYgci5yaWdodCA+IGxlZnQgJiYgci50b3AgPCB0b3AgKyBoZWlnaHQgJiYgci5ib3R0b20gPiB0b3ApXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3AgPSBhYm92ZSA/IHIudG9wIC0gaGVpZ2h0IC0gMiAtIGFycm93SGVpZ2h0IDogci5ib3R0b20gKyBhcnJvd0hlaWdodCArIDI7XG4gICAgICAgICAgICBpZiAodGhpcy5wb3NpdGlvbiA9PSBcImFic29sdXRlXCIpIHtcbiAgICAgICAgICAgICAgICBkb20uc3R5bGUudG9wID0gKHRvcCAtIG1lYXN1cmVkLnBhcmVudC50b3ApIC8gc2NhbGVZICsgXCJweFwiO1xuICAgICAgICAgICAgICAgIGRvbS5zdHlsZS5sZWZ0ID0gKGxlZnQgLSBtZWFzdXJlZC5wYXJlbnQubGVmdCkgLyBzY2FsZVggKyBcInB4XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkb20uc3R5bGUudG9wID0gdG9wIC8gc2NhbGVZICsgXCJweFwiO1xuICAgICAgICAgICAgICAgIGRvbS5zdHlsZS5sZWZ0ID0gbGVmdCAvIHNjYWxlWCArIFwicHhcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhcnJvdykge1xuICAgICAgICAgICAgICAgIGxldCBhcnJvd0xlZnQgPSBwb3MubGVmdCArIChsdHIgPyBvZmZzZXQueCA6IC1vZmZzZXQueCkgLSAobGVmdCArIDE0IC8qIEFycm93Lk9mZnNldCAqLyAtIDcgLyogQXJyb3cuU2l6ZSAqLyk7XG4gICAgICAgICAgICAgICAgYXJyb3cuc3R5bGUubGVmdCA9IGFycm93TGVmdCAvIHNjYWxlWCArIFwicHhcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0Vmlldy5vdmVybGFwICE9PSB0cnVlKVxuICAgICAgICAgICAgICAgIG90aGVycy5wdXNoKHsgbGVmdCwgdG9wLCByaWdodCwgYm90dG9tOiB0b3AgKyBoZWlnaHQgfSk7XG4gICAgICAgICAgICBkb20uY2xhc3NMaXN0LnRvZ2dsZShcImNtLXRvb2x0aXAtYWJvdmVcIiwgYWJvdmUpO1xuICAgICAgICAgICAgZG9tLmNsYXNzTGlzdC50b2dnbGUoXCJjbS10b29sdGlwLWJlbG93XCIsICFhYm92ZSk7XG4gICAgICAgICAgICBpZiAodFZpZXcucG9zaXRpb25lZClcbiAgICAgICAgICAgICAgICB0Vmlldy5wb3NpdGlvbmVkKG1lYXN1cmVkLnNwYWNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtYXliZU1lYXN1cmUoKSB7XG4gICAgICAgIGlmICh0aGlzLm1hbmFnZXIudG9vbHRpcHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy52aWV3LmluVmlldylcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXcucmVxdWVzdE1lYXN1cmUodGhpcy5tZWFzdXJlUmVxKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmluVmlldyAhPSB0aGlzLnZpZXcuaW5WaWV3KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pblZpZXcgPSB0aGlzLnZpZXcuaW5WaWV3O1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pblZpZXcpXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHR2IG9mIHRoaXMubWFuYWdlci50b29sdGlwVmlld3MpXG4gICAgICAgICAgICAgICAgICAgICAgICB0di5kb20uc3R5bGUudG9wID0gT3V0c2lkZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn0sIHtcbiAgICBldmVudE9ic2VydmVyczoge1xuICAgICAgICBzY3JvbGwoKSB7IHRoaXMubWF5YmVNZWFzdXJlKCk7IH1cbiAgICB9XG59KTtcbmNvbnN0IGJhc2VUaGVtZSA9IC8qQF9fUFVSRV9fKi9FZGl0b3JWaWV3LmJhc2VUaGVtZSh7XG4gICAgXCIuY20tdG9vbHRpcFwiOiB7XG4gICAgICAgIHpJbmRleDogMTAwLFxuICAgICAgICBib3hTaXppbmc6IFwiYm9yZGVyLWJveFwiXG4gICAgfSxcbiAgICBcIiZsaWdodCAuY20tdG9vbHRpcFwiOiB7XG4gICAgICAgIGJvcmRlcjogXCIxcHggc29saWQgI2JiYlwiLFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiI2Y1ZjVmNVwiXG4gICAgfSxcbiAgICBcIiZsaWdodCAuY20tdG9vbHRpcC1zZWN0aW9uOm5vdCg6Zmlyc3QtY2hpbGQpXCI6IHtcbiAgICAgICAgYm9yZGVyVG9wOiBcIjFweCBzb2xpZCAjYmJiXCIsXG4gICAgfSxcbiAgICBcIiZkYXJrIC5jbS10b29sdGlwXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiMzMzMzMzhcIixcbiAgICAgICAgY29sb3I6IFwid2hpdGVcIlxuICAgIH0sXG4gICAgXCIuY20tdG9vbHRpcC1hcnJvd1wiOiB7XG4gICAgICAgIGhlaWdodDogYCR7NyAvKiBBcnJvdy5TaXplICovfXB4YCxcbiAgICAgICAgd2lkdGg6IGAkezcgLyogQXJyb3cuU2l6ZSAqLyAqIDJ9cHhgLFxuICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgICB6SW5kZXg6IC0xLFxuICAgICAgICBvdmVyZmxvdzogXCJoaWRkZW5cIixcbiAgICAgICAgXCImOmJlZm9yZSwgJjphZnRlclwiOiB7XG4gICAgICAgICAgICBjb250ZW50OiBcIicnXCIsXG4gICAgICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgICAgICBib3JkZXJMZWZ0OiBgJHs3IC8qIEFycm93LlNpemUgKi99cHggc29saWQgdHJhbnNwYXJlbnRgLFxuICAgICAgICAgICAgYm9yZGVyUmlnaHQ6IGAkezcgLyogQXJyb3cuU2l6ZSAqL31weCBzb2xpZCB0cmFuc3BhcmVudGAsXG4gICAgICAgIH0sXG4gICAgICAgIFwiLmNtLXRvb2x0aXAtYWJvdmUgJlwiOiB7XG4gICAgICAgICAgICBib3R0b206IGAtJHs3IC8qIEFycm93LlNpemUgKi99cHhgLFxuICAgICAgICAgICAgXCImOmJlZm9yZVwiOiB7XG4gICAgICAgICAgICAgICAgYm9yZGVyVG9wOiBgJHs3IC8qIEFycm93LlNpemUgKi99cHggc29saWQgI2JiYmAsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCImOmFmdGVyXCI6IHtcbiAgICAgICAgICAgICAgICBib3JkZXJUb3A6IGAkezcgLyogQXJyb3cuU2l6ZSAqL31weCBzb2xpZCAjZjVmNWY1YCxcbiAgICAgICAgICAgICAgICBib3R0b206IFwiMXB4XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCIuY20tdG9vbHRpcC1iZWxvdyAmXCI6IHtcbiAgICAgICAgICAgIHRvcDogYC0kezcgLyogQXJyb3cuU2l6ZSAqL31weGAsXG4gICAgICAgICAgICBcIiY6YmVmb3JlXCI6IHtcbiAgICAgICAgICAgICAgICBib3JkZXJCb3R0b206IGAkezcgLyogQXJyb3cuU2l6ZSAqL31weCBzb2xpZCAjYmJiYCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcIiY6YWZ0ZXJcIjoge1xuICAgICAgICAgICAgICAgIGJvcmRlckJvdHRvbTogYCR7NyAvKiBBcnJvdy5TaXplICovfXB4IHNvbGlkICNmNWY1ZjVgLFxuICAgICAgICAgICAgICAgIHRvcDogXCIxcHhcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH0sXG4gICAgXCImZGFyayAuY20tdG9vbHRpcCAuY20tdG9vbHRpcC1hcnJvd1wiOiB7XG4gICAgICAgIFwiJjpiZWZvcmVcIjoge1xuICAgICAgICAgICAgYm9yZGVyVG9wQ29sb3I6IFwiIzMzMzMzOFwiLFxuICAgICAgICAgICAgYm9yZGVyQm90dG9tQ29sb3I6IFwiIzMzMzMzOFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiJjphZnRlclwiOiB7XG4gICAgICAgICAgICBib3JkZXJUb3BDb2xvcjogXCJ0cmFuc3BhcmVudFwiLFxuICAgICAgICAgICAgYm9yZGVyQm90dG9tQ29sb3I6IFwidHJhbnNwYXJlbnRcIlxuICAgICAgICB9XG4gICAgfVxufSk7XG5jb25zdCBub09mZnNldCA9IHsgeDogMCwgeTogMCB9O1xuLyoqXG5GYWNldCB0byB3aGljaCBhbiBleHRlbnNpb24gY2FuIGFkZCBhIHZhbHVlIHRvIHNob3cgYSB0b29sdGlwLlxuKi9cbmNvbnN0IHNob3dUb29sdGlwID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgZW5hYmxlczogW3Rvb2x0aXBQbHVnaW4sIGJhc2VUaGVtZV1cbn0pO1xuY29uc3Qgc2hvd0hvdmVyVG9vbHRpcCA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNsYXNzIEhvdmVyVG9vbHRpcEhvc3Qge1xuICAgIC8vIE5lZWRzIHRvIGJlIHN0YXRpYyBzbyB0aGF0IGhvc3QgdG9vbHRpcCBpbnN0YW5jZXMgYWx3YXlzIG1hdGNoXG4gICAgc3RhdGljIGNyZWF0ZSh2aWV3KSB7XG4gICAgICAgIHJldHVybiBuZXcgSG92ZXJUb29sdGlwSG9zdCh2aWV3KTtcbiAgICB9XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLm1vdW50ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLmRvbS5jbGFzc0xpc3QuYWRkKFwiY20tdG9vbHRpcC1ob3ZlclwiKTtcbiAgICAgICAgdGhpcy5tYW5hZ2VyID0gbmV3IFRvb2x0aXBWaWV3TWFuYWdlcih2aWV3LCBzaG93SG92ZXJUb29sdGlwLCB0ID0+IHRoaXMuY3JlYXRlSG9zdGVkVmlldyh0KSk7XG4gICAgfVxuICAgIGNyZWF0ZUhvc3RlZFZpZXcodG9vbHRpcCkge1xuICAgICAgICBsZXQgaG9zdGVkVmlldyA9IHRvb2x0aXAuY3JlYXRlKHRoaXMudmlldyk7XG4gICAgICAgIGhvc3RlZFZpZXcuZG9tLmNsYXNzTGlzdC5hZGQoXCJjbS10b29sdGlwLXNlY3Rpb25cIik7XG4gICAgICAgIHRoaXMuZG9tLmFwcGVuZENoaWxkKGhvc3RlZFZpZXcuZG9tKTtcbiAgICAgICAgaWYgKHRoaXMubW91bnRlZCAmJiBob3N0ZWRWaWV3Lm1vdW50KVxuICAgICAgICAgICAgaG9zdGVkVmlldy5tb3VudCh0aGlzLnZpZXcpO1xuICAgICAgICByZXR1cm4gaG9zdGVkVmlldztcbiAgICB9XG4gICAgbW91bnQodmlldykge1xuICAgICAgICBmb3IgKGxldCBob3N0ZWRWaWV3IG9mIHRoaXMubWFuYWdlci50b29sdGlwVmlld3MpIHtcbiAgICAgICAgICAgIGlmIChob3N0ZWRWaWV3Lm1vdW50KVxuICAgICAgICAgICAgICAgIGhvc3RlZFZpZXcubW91bnQodmlldyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb3VudGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcG9zaXRpb25lZChzcGFjZSkge1xuICAgICAgICBmb3IgKGxldCBob3N0ZWRWaWV3IG9mIHRoaXMubWFuYWdlci50b29sdGlwVmlld3MpIHtcbiAgICAgICAgICAgIGlmIChob3N0ZWRWaWV3LnBvc2l0aW9uZWQpXG4gICAgICAgICAgICAgICAgaG9zdGVkVmlldy5wb3NpdGlvbmVkKHNwYWNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIHRoaXMubWFuYWdlci51cGRhdGUodXBkYXRlKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBmb3IgKGxldCB0IG9mIHRoaXMubWFuYWdlci50b29sdGlwVmlld3MpXG4gICAgICAgICAgICAoX2EgPSB0LmRlc3Ryb3kpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHQpO1xuICAgIH1cbiAgICBwYXNzUHJvcChuYW1lKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yIChsZXQgdmlldyBvZiB0aGlzLm1hbmFnZXIudG9vbHRpcFZpZXdzKSB7XG4gICAgICAgICAgICBsZXQgZ2l2ZW4gPSB2aWV3W25hbWVdO1xuICAgICAgICAgICAgaWYgKGdpdmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBnaXZlbjtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSAhPT0gZ2l2ZW4pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBnZXQgb2Zmc2V0KCkgeyByZXR1cm4gdGhpcy5wYXNzUHJvcChcIm9mZnNldFwiKTsgfVxuICAgIGdldCBnZXRDb29yZHMoKSB7IHJldHVybiB0aGlzLnBhc3NQcm9wKFwiZ2V0Q29vcmRzXCIpOyB9XG4gICAgZ2V0IG92ZXJsYXAoKSB7IHJldHVybiB0aGlzLnBhc3NQcm9wKFwib3ZlcmxhcFwiKTsgfVxuICAgIGdldCByZXNpemUoKSB7IHJldHVybiB0aGlzLnBhc3NQcm9wKFwicmVzaXplXCIpOyB9XG59XG5jb25zdCBzaG93SG92ZXJUb29sdGlwSG9zdCA9IC8qQF9fUFVSRV9fKi9zaG93VG9vbHRpcC5jb21wdXRlKFtzaG93SG92ZXJUb29sdGlwXSwgc3RhdGUgPT4ge1xuICAgIGxldCB0b29sdGlwcyA9IHN0YXRlLmZhY2V0KHNob3dIb3ZlclRvb2x0aXApLmZpbHRlcih0ID0+IHQpO1xuICAgIGlmICh0b29sdGlwcy5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiB7XG4gICAgICAgIHBvczogTWF0aC5taW4oLi4udG9vbHRpcHMubWFwKHQgPT4gdC5wb3MpKSxcbiAgICAgICAgZW5kOiBNYXRoLm1heCguLi50b29sdGlwcy5tYXAodCA9PiB7IHZhciBfYTsgcmV0dXJuIChfYSA9IHQuZW5kKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0LnBvczsgfSkpLFxuICAgICAgICBjcmVhdGU6IEhvdmVyVG9vbHRpcEhvc3QuY3JlYXRlLFxuICAgICAgICBhYm92ZTogdG9vbHRpcHNbMF0uYWJvdmUsXG4gICAgICAgIGFycm93OiB0b29sdGlwcy5zb21lKHQgPT4gdC5hcnJvdyksXG4gICAgfTtcbn0pO1xuY2xhc3MgSG92ZXJQbHVnaW4ge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcsIHNvdXJjZSwgZmllbGQsIHNldEhvdmVyLCBob3ZlclRpbWUpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMuZmllbGQgPSBmaWVsZDtcbiAgICAgICAgdGhpcy5zZXRIb3ZlciA9IHNldEhvdmVyO1xuICAgICAgICB0aGlzLmhvdmVyVGltZSA9IGhvdmVyVGltZTtcbiAgICAgICAgdGhpcy5ob3ZlclRpbWVvdXQgPSAtMTtcbiAgICAgICAgdGhpcy5yZXN0YXJ0VGltZW91dCA9IC0xO1xuICAgICAgICB0aGlzLnBlbmRpbmcgPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3RNb3ZlID0geyB4OiAwLCB5OiAwLCB0YXJnZXQ6IHZpZXcuZG9tLCB0aW1lOiAwIH07XG4gICAgICAgIHRoaXMuY2hlY2tIb3ZlciA9IHRoaXMuY2hlY2tIb3Zlci5iaW5kKHRoaXMpO1xuICAgICAgICB2aWV3LmRvbS5hZGRFdmVudExpc3RlbmVyKFwibW91c2VsZWF2ZVwiLCB0aGlzLm1vdXNlbGVhdmUgPSB0aGlzLm1vdXNlbGVhdmUuYmluZCh0aGlzKSk7XG4gICAgICAgIHZpZXcuZG9tLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy5tb3VzZW1vdmUgPSB0aGlzLm1vdXNlbW92ZS5iaW5kKHRoaXMpKTtcbiAgICB9XG4gICAgdXBkYXRlKCkge1xuICAgICAgICBpZiAodGhpcy5wZW5kaW5nKSB7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmcgPSBudWxsO1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucmVzdGFydFRpbWVvdXQpO1xuICAgICAgICAgICAgdGhpcy5yZXN0YXJ0VGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5zdGFydEhvdmVyKCksIDIwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgYWN0aXZlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3LnN0YXRlLmZpZWxkKHRoaXMuZmllbGQpO1xuICAgIH1cbiAgICBjaGVja0hvdmVyKCkge1xuICAgICAgICB0aGlzLmhvdmVyVGltZW91dCA9IC0xO1xuICAgICAgICBpZiAodGhpcy5hY3RpdmUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBob3ZlcmVkID0gRGF0ZS5ub3coKSAtIHRoaXMubGFzdE1vdmUudGltZTtcbiAgICAgICAgaWYgKGhvdmVyZWQgPCB0aGlzLmhvdmVyVGltZSlcbiAgICAgICAgICAgIHRoaXMuaG92ZXJUaW1lb3V0ID0gc2V0VGltZW91dCh0aGlzLmNoZWNrSG92ZXIsIHRoaXMuaG92ZXJUaW1lIC0gaG92ZXJlZCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuc3RhcnRIb3ZlcigpO1xuICAgIH1cbiAgICBzdGFydEhvdmVyKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5yZXN0YXJ0VGltZW91dCk7XG4gICAgICAgIGxldCB7IHZpZXcsIGxhc3RNb3ZlIH0gPSB0aGlzO1xuICAgICAgICBsZXQgZGVzYyA9IHZpZXcuZG9jVmlldy5uZWFyZXN0KGxhc3RNb3ZlLnRhcmdldCk7XG4gICAgICAgIGlmICghZGVzYylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IHBvcywgc2lkZSA9IDE7XG4gICAgICAgIGlmIChkZXNjIGluc3RhbmNlb2YgV2lkZ2V0Vmlldykge1xuICAgICAgICAgICAgcG9zID0gZGVzYy5wb3NBdFN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcG9zID0gdmlldy5wb3NBdENvb3JkcyhsYXN0TW92ZSk7XG4gICAgICAgICAgICBpZiAocG9zID09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IHBvc0Nvb3JkcyA9IHZpZXcuY29vcmRzQXRQb3MocG9zKTtcbiAgICAgICAgICAgIGlmICghcG9zQ29vcmRzIHx8XG4gICAgICAgICAgICAgICAgbGFzdE1vdmUueSA8IHBvc0Nvb3Jkcy50b3AgfHwgbGFzdE1vdmUueSA+IHBvc0Nvb3Jkcy5ib3R0b20gfHxcbiAgICAgICAgICAgICAgICBsYXN0TW92ZS54IDwgcG9zQ29vcmRzLmxlZnQgLSB2aWV3LmRlZmF1bHRDaGFyYWN0ZXJXaWR0aCB8fFxuICAgICAgICAgICAgICAgIGxhc3RNb3ZlLnggPiBwb3NDb29yZHMucmlnaHQgKyB2aWV3LmRlZmF1bHRDaGFyYWN0ZXJXaWR0aClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsZXQgYmlkaSA9IHZpZXcuYmlkaVNwYW5zKHZpZXcuc3RhdGUuZG9jLmxpbmVBdChwb3MpKS5maW5kKHMgPT4gcy5mcm9tIDw9IHBvcyAmJiBzLnRvID49IHBvcyk7XG4gICAgICAgICAgICBsZXQgcnRsID0gYmlkaSAmJiBiaWRpLmRpciA9PSBEaXJlY3Rpb24uUlRMID8gLTEgOiAxO1xuICAgICAgICAgICAgc2lkZSA9IChsYXN0TW92ZS54IDwgcG9zQ29vcmRzLmxlZnQgPyAtcnRsIDogcnRsKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgb3BlbiA9IHRoaXMuc291cmNlKHZpZXcsIHBvcywgc2lkZSk7XG4gICAgICAgIGlmIChvcGVuID09PSBudWxsIHx8IG9wZW4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wZW4udGhlbikge1xuICAgICAgICAgICAgbGV0IHBlbmRpbmcgPSB0aGlzLnBlbmRpbmcgPSB7IHBvcyB9O1xuICAgICAgICAgICAgb3Blbi50aGVuKHJlc3VsdCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZyA9PSBwZW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpXG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogdGhpcy5zZXRIb3Zlci5vZihyZXN1bHQpIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGUgPT4gbG9nRXhjZXB0aW9uKHZpZXcuc3RhdGUsIGUsIFwiaG92ZXIgdG9vbHRpcFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3Blbikge1xuICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHRoaXMuc2V0SG92ZXIub2Yob3BlbikgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IHRvb2x0aXAoKSB7XG4gICAgICAgIGxldCBwbHVnaW4gPSB0aGlzLnZpZXcucGx1Z2luKHRvb2x0aXBQbHVnaW4pO1xuICAgICAgICBsZXQgaW5kZXggPSBwbHVnaW4gPyBwbHVnaW4ubWFuYWdlci50b29sdGlwcy5maW5kSW5kZXgodCA9PiB0LmNyZWF0ZSA9PSBIb3ZlclRvb2x0aXBIb3N0LmNyZWF0ZSkgOiAtMTtcbiAgICAgICAgcmV0dXJuIGluZGV4ID4gLTEgPyBwbHVnaW4ubWFuYWdlci50b29sdGlwVmlld3NbaW5kZXhdIDogbnVsbDtcbiAgICB9XG4gICAgbW91c2Vtb3ZlKGV2ZW50KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5sYXN0TW92ZSA9IHsgeDogZXZlbnQuY2xpZW50WCwgeTogZXZlbnQuY2xpZW50WSwgdGFyZ2V0OiBldmVudC50YXJnZXQsIHRpbWU6IERhdGUubm93KCkgfTtcbiAgICAgICAgaWYgKHRoaXMuaG92ZXJUaW1lb3V0IDwgMClcbiAgICAgICAgICAgIHRoaXMuaG92ZXJUaW1lb3V0ID0gc2V0VGltZW91dCh0aGlzLmNoZWNrSG92ZXIsIHRoaXMuaG92ZXJUaW1lKTtcbiAgICAgICAgbGV0IHsgYWN0aXZlLCB0b29sdGlwIH0gPSB0aGlzO1xuICAgICAgICBpZiAoYWN0aXZlICYmIHRvb2x0aXAgJiYgIWlzSW5Ub29sdGlwKHRvb2x0aXAuZG9tLCBldmVudCkgfHwgdGhpcy5wZW5kaW5nKSB7XG4gICAgICAgICAgICBsZXQgeyBwb3MgfSA9IGFjdGl2ZSB8fCB0aGlzLnBlbmRpbmcsIGVuZCA9IChfYSA9IGFjdGl2ZSA9PT0gbnVsbCB8fCBhY3RpdmUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFjdGl2ZS5lbmQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHBvcztcbiAgICAgICAgICAgIGlmICgocG9zID09IGVuZCA/IHRoaXMudmlldy5wb3NBdENvb3Jkcyh0aGlzLmxhc3RNb3ZlKSAhPSBwb3NcbiAgICAgICAgICAgICAgICA6ICFpc092ZXJSYW5nZSh0aGlzLnZpZXcsIHBvcywgZW5kLCBldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiB0aGlzLnNldEhvdmVyLm9mKG51bGwpIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbW91c2VsZWF2ZShldmVudCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5ob3ZlclRpbWVvdXQpO1xuICAgICAgICB0aGlzLmhvdmVyVGltZW91dCA9IC0xO1xuICAgICAgICBsZXQgeyBhY3RpdmUgfSA9IHRoaXM7XG4gICAgICAgIGlmIChhY3RpdmUpIHtcbiAgICAgICAgICAgIGxldCB7IHRvb2x0aXAgfSA9IHRoaXM7XG4gICAgICAgICAgICBsZXQgaW5Ub29sdGlwID0gdG9vbHRpcCAmJiB0b29sdGlwLmRvbS5jb250YWlucyhldmVudC5yZWxhdGVkVGFyZ2V0KTtcbiAgICAgICAgICAgIGlmICghaW5Ub29sdGlwKVxuICAgICAgICAgICAgICAgIHRoaXMudmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHRoaXMuc2V0SG92ZXIub2YobnVsbCkgfSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy53YXRjaFRvb2x0aXBMZWF2ZSh0b29sdGlwLmRvbSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgd2F0Y2hUb29sdGlwTGVhdmUodG9vbHRpcCkge1xuICAgICAgICBsZXQgd2F0Y2ggPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRvb2x0aXAucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbGVhdmVcIiwgd2F0Y2gpO1xuICAgICAgICAgICAgaWYgKHRoaXMuYWN0aXZlICYmICF0aGlzLnZpZXcuZG9tLmNvbnRhaW5zKGV2ZW50LnJlbGF0ZWRUYXJnZXQpKVxuICAgICAgICAgICAgICAgIHRoaXMudmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHRoaXMuc2V0SG92ZXIub2YobnVsbCkgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRvb2x0aXAuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbGVhdmVcIiwgd2F0Y2gpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5ob3ZlclRpbWVvdXQpO1xuICAgICAgICB0aGlzLnZpZXcuZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsIHRoaXMubW91c2VsZWF2ZSk7XG4gICAgICAgIHRoaXMudmlldy5kb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLm1vdXNlbW92ZSk7XG4gICAgfVxufVxuY29uc3QgdG9vbHRpcE1hcmdpbiA9IDQ7XG5mdW5jdGlvbiBpc0luVG9vbHRpcCh0b29sdGlwLCBldmVudCkge1xuICAgIGxldCByZWN0ID0gdG9vbHRpcC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4gZXZlbnQuY2xpZW50WCA+PSByZWN0LmxlZnQgLSB0b29sdGlwTWFyZ2luICYmIGV2ZW50LmNsaWVudFggPD0gcmVjdC5yaWdodCArIHRvb2x0aXBNYXJnaW4gJiZcbiAgICAgICAgZXZlbnQuY2xpZW50WSA+PSByZWN0LnRvcCAtIHRvb2x0aXBNYXJnaW4gJiYgZXZlbnQuY2xpZW50WSA8PSByZWN0LmJvdHRvbSArIHRvb2x0aXBNYXJnaW47XG59XG5mdW5jdGlvbiBpc092ZXJSYW5nZSh2aWV3LCBmcm9tLCB0bywgeCwgeSwgbWFyZ2luKSB7XG4gICAgbGV0IHJlY3QgPSB2aWV3LnNjcm9sbERPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBsZXQgZG9jQm90dG9tID0gdmlldy5kb2N1bWVudFRvcCArIHZpZXcuZG9jdW1lbnRQYWRkaW5nLnRvcCArIHZpZXcuY29udGVudEhlaWdodDtcbiAgICBpZiAocmVjdC5sZWZ0ID4geCB8fCByZWN0LnJpZ2h0IDwgeCB8fCByZWN0LnRvcCA+IHkgfHwgTWF0aC5taW4ocmVjdC5ib3R0b20sIGRvY0JvdHRvbSkgPCB5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHBvcyA9IHZpZXcucG9zQXRDb29yZHMoeyB4LCB5IH0sIGZhbHNlKTtcbiAgICByZXR1cm4gcG9zID49IGZyb20gJiYgcG9zIDw9IHRvO1xufVxuLyoqXG5TZXQgdXAgYSBob3ZlciB0b29sdGlwLCB3aGljaCBzaG93cyB1cCB3aGVuIHRoZSBwb2ludGVyIGhvdmVyc1xub3ZlciByYW5nZXMgb2YgdGV4dC4gVGhlIGNhbGxiYWNrIGlzIGNhbGxlZCB3aGVuIHRoZSBtb3VzZSBob3ZlcnNcbm92ZXIgdGhlIGRvY3VtZW50IHRleHQuIEl0IHNob3VsZCwgaWYgdGhlcmUgaXMgYSB0b29sdGlwXG5hc3NvY2lhdGVkIHdpdGggcG9zaXRpb24gYHBvc2AsIHJldHVybiB0aGUgdG9vbHRpcCBkZXNjcmlwdGlvblxuKGVpdGhlciBkaXJlY3RseSBvciBpbiBhIHByb21pc2UpLiBUaGUgYHNpZGVgIGFyZ3VtZW50IGluZGljYXRlc1xub24gd2hpY2ggc2lkZSBvZiB0aGUgcG9zaXRpb24gdGhlIHBvaW50ZXIgaXPigJRpdCB3aWxsIGJlIC0xIGlmIHRoZVxucG9pbnRlciBpcyBiZWZvcmUgdGhlIHBvc2l0aW9uLCAxIGlmIGFmdGVyIHRoZSBwb3NpdGlvbi5cblxuTm90ZSB0aGF0IGFsbCBob3ZlciB0b29sdGlwcyBhcmUgaG9zdGVkIHdpdGhpbiBhIHNpbmdsZSB0b29sdGlwXG5jb250YWluZXIgZWxlbWVudC4gVGhpcyBhbGxvd3MgbXVsdGlwbGUgdG9vbHRpcHMgb3ZlciB0aGUgc2FtZVxucmFuZ2UgdG8gYmUgXCJtZXJnZWRcIiB0b2dldGhlciB3aXRob3V0IG92ZXJsYXBwaW5nLlxuKi9cbmZ1bmN0aW9uIGhvdmVyVG9vbHRpcChzb3VyY2UsIG9wdGlvbnMgPSB7fSkge1xuICAgIGxldCBzZXRIb3ZlciA9IFN0YXRlRWZmZWN0LmRlZmluZSgpO1xuICAgIGxldCBob3ZlclN0YXRlID0gU3RhdGVGaWVsZC5kZWZpbmUoe1xuICAgICAgICBjcmVhdGUoKSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICB1cGRhdGUodmFsdWUsIHRyKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgJiYgKG9wdGlvbnMuaGlkZU9uQ2hhbmdlICYmICh0ci5kb2NDaGFuZ2VkIHx8IHRyLnNlbGVjdGlvbikgfHxcbiAgICAgICAgICAgICAgICBvcHRpb25zLmhpZGVPbiAmJiBvcHRpb25zLmhpZGVPbih0ciwgdmFsdWUpKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAmJiB0ci5kb2NDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5ld1BvcyA9IHRyLmNoYW5nZXMubWFwUG9zKHZhbHVlLnBvcywgLTEsIE1hcE1vZGUuVHJhY2tEZWwpO1xuICAgICAgICAgICAgICAgIGlmIChuZXdQb3MgPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgbGV0IGNvcHkgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICBjb3B5LnBvcyA9IG5ld1BvcztcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUuZW5kICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIGNvcHkuZW5kID0gdHIuY2hhbmdlcy5tYXBQb3ModmFsdWUuZW5kKTtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGNvcHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgdHIuZWZmZWN0cykge1xuICAgICAgICAgICAgICAgIGlmIChlZmZlY3QuaXMoc2V0SG92ZXIpKVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGVmZmVjdC52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoZWZmZWN0LmlzKGNsb3NlSG92ZXJUb29sdGlwRWZmZWN0KSlcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBwcm92aWRlOiBmID0+IHNob3dIb3ZlclRvb2x0aXAuZnJvbShmKVxuICAgIH0pO1xuICAgIHJldHVybiBbXG4gICAgICAgIGhvdmVyU3RhdGUsXG4gICAgICAgIFZpZXdQbHVnaW4uZGVmaW5lKHZpZXcgPT4gbmV3IEhvdmVyUGx1Z2luKHZpZXcsIHNvdXJjZSwgaG92ZXJTdGF0ZSwgc2V0SG92ZXIsIG9wdGlvbnMuaG92ZXJUaW1lIHx8IDMwMCAvKiBIb3Zlci5UaW1lICovKSksXG4gICAgICAgIHNob3dIb3ZlclRvb2x0aXBIb3N0XG4gICAgXTtcbn1cbi8qKlxuR2V0IHRoZSBhY3RpdmUgdG9vbHRpcCB2aWV3IGZvciBhIGdpdmVuIHRvb2x0aXAsIGlmIGF2YWlsYWJsZS5cbiovXG5mdW5jdGlvbiBnZXRUb29sdGlwKHZpZXcsIHRvb2x0aXApIHtcbiAgICBsZXQgcGx1Z2luID0gdmlldy5wbHVnaW4odG9vbHRpcFBsdWdpbik7XG4gICAgaWYgKCFwbHVnaW4pXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBmb3VuZCA9IHBsdWdpbi5tYW5hZ2VyLnRvb2x0aXBzLmluZGV4T2YodG9vbHRpcCk7XG4gICAgcmV0dXJuIGZvdW5kIDwgMCA/IG51bGwgOiBwbHVnaW4ubWFuYWdlci50b29sdGlwVmlld3NbZm91bmRdO1xufVxuLyoqXG5SZXR1cm5zIHRydWUgaWYgYW55IGhvdmVyIHRvb2x0aXBzIGFyZSBjdXJyZW50bHkgYWN0aXZlLlxuKi9cbmZ1bmN0aW9uIGhhc0hvdmVyVG9vbHRpcHMoc3RhdGUpIHtcbiAgICByZXR1cm4gc3RhdGUuZmFjZXQoc2hvd0hvdmVyVG9vbHRpcCkuc29tZSh4ID0+IHgpO1xufVxuY29uc3QgY2xvc2VIb3ZlclRvb2x0aXBFZmZlY3QgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG4vKipcblRyYW5zYWN0aW9uIGVmZmVjdCB0aGF0IGNsb3NlcyBhbGwgaG92ZXIgdG9vbHRpcHMuXG4qL1xuY29uc3QgY2xvc2VIb3ZlclRvb2x0aXBzID0gLypAX19QVVJFX18qL2Nsb3NlSG92ZXJUb29sdGlwRWZmZWN0Lm9mKG51bGwpO1xuLyoqXG5UZWxsIHRoZSB0b29sdGlwIGV4dGVuc2lvbiB0byByZWNvbXB1dGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBhY3RpdmVcbnRvb2x0aXBzLiBUaGlzIGNhbiBiZSB1c2VmdWwgd2hlbiBzb21ldGhpbmcgaGFwcGVucyAoc3VjaCBhcyBhXG5yZS1wb3NpdGlvbmluZyBvciBDU1MgY2hhbmdlIGFmZmVjdGluZyB0aGUgZWRpdG9yKSB0aGF0IGNvdWxkXG5pbnZhbGlkYXRlIHRoZSBleGlzdGluZyB0b29sdGlwIHBvc2l0aW9ucy5cbiovXG5mdW5jdGlvbiByZXBvc2l0aW9uVG9vbHRpcHModmlldykge1xuICAgIGxldCBwbHVnaW4gPSB2aWV3LnBsdWdpbih0b29sdGlwUGx1Z2luKTtcbiAgICBpZiAocGx1Z2luKVxuICAgICAgICBwbHVnaW4ubWF5YmVNZWFzdXJlKCk7XG59XG5cbmNvbnN0IHBhbmVsQ29uZmlnID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZShjb25maWdzKSB7XG4gICAgICAgIGxldCB0b3BDb250YWluZXIsIGJvdHRvbUNvbnRhaW5lcjtcbiAgICAgICAgZm9yIChsZXQgYyBvZiBjb25maWdzKSB7XG4gICAgICAgICAgICB0b3BDb250YWluZXIgPSB0b3BDb250YWluZXIgfHwgYy50b3BDb250YWluZXI7XG4gICAgICAgICAgICBib3R0b21Db250YWluZXIgPSBib3R0b21Db250YWluZXIgfHwgYy5ib3R0b21Db250YWluZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdG9wQ29udGFpbmVyLCBib3R0b21Db250YWluZXIgfTtcbiAgICB9XG59KTtcbi8qKlxuQ29uZmlndXJlcyB0aGUgcGFuZWwtbWFuYWdpbmcgZXh0ZW5zaW9uLlxuKi9cbmZ1bmN0aW9uIHBhbmVscyhjb25maWcpIHtcbiAgICByZXR1cm4gY29uZmlnID8gW3BhbmVsQ29uZmlnLm9mKGNvbmZpZyldIDogW107XG59XG4vKipcbkdldCB0aGUgYWN0aXZlIHBhbmVsIGNyZWF0ZWQgYnkgdGhlIGdpdmVuIGNvbnN0cnVjdG9yLCBpZiBhbnkuXG5UaGlzIGNhbiBiZSB1c2VmdWwgd2hlbiB5b3UgbmVlZCBhY2Nlc3MgdG8geW91ciBwYW5lbHMnIERPTVxuc3RydWN0dXJlLlxuKi9cbmZ1bmN0aW9uIGdldFBhbmVsKHZpZXcsIHBhbmVsKSB7XG4gICAgbGV0IHBsdWdpbiA9IHZpZXcucGx1Z2luKHBhbmVsUGx1Z2luKTtcbiAgICBsZXQgaW5kZXggPSBwbHVnaW4gPyBwbHVnaW4uc3BlY3MuaW5kZXhPZihwYW5lbCkgOiAtMTtcbiAgICByZXR1cm4gaW5kZXggPiAtMSA/IHBsdWdpbi5wYW5lbHNbaW5kZXhdIDogbnVsbDtcbn1cbmNvbnN0IHBhbmVsUGx1Z2luID0gLypAX19QVVJFX18qL1ZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHRoaXMuaW5wdXQgPSB2aWV3LnN0YXRlLmZhY2V0KHNob3dQYW5lbCk7XG4gICAgICAgIHRoaXMuc3BlY3MgPSB0aGlzLmlucHV0LmZpbHRlcihzID0+IHMpO1xuICAgICAgICB0aGlzLnBhbmVscyA9IHRoaXMuc3BlY3MubWFwKHNwZWMgPT4gc3BlYyh2aWV3KSk7XG4gICAgICAgIGxldCBjb25mID0gdmlldy5zdGF0ZS5mYWNldChwYW5lbENvbmZpZyk7XG4gICAgICAgIHRoaXMudG9wID0gbmV3IFBhbmVsR3JvdXAodmlldywgdHJ1ZSwgY29uZi50b3BDb250YWluZXIpO1xuICAgICAgICB0aGlzLmJvdHRvbSA9IG5ldyBQYW5lbEdyb3VwKHZpZXcsIGZhbHNlLCBjb25mLmJvdHRvbUNvbnRhaW5lcik7XG4gICAgICAgIHRoaXMudG9wLnN5bmModGhpcy5wYW5lbHMuZmlsdGVyKHAgPT4gcC50b3ApKTtcbiAgICAgICAgdGhpcy5ib3R0b20uc3luYyh0aGlzLnBhbmVscy5maWx0ZXIocCA9PiAhcC50b3ApKTtcbiAgICAgICAgZm9yIChsZXQgcCBvZiB0aGlzLnBhbmVscykge1xuICAgICAgICAgICAgcC5kb20uY2xhc3NMaXN0LmFkZChcImNtLXBhbmVsXCIpO1xuICAgICAgICAgICAgaWYgKHAubW91bnQpXG4gICAgICAgICAgICAgICAgcC5tb3VudCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgbGV0IGNvbmYgPSB1cGRhdGUuc3RhdGUuZmFjZXQocGFuZWxDb25maWcpO1xuICAgICAgICBpZiAodGhpcy50b3AuY29udGFpbmVyICE9IGNvbmYudG9wQ29udGFpbmVyKSB7XG4gICAgICAgICAgICB0aGlzLnRvcC5zeW5jKFtdKTtcbiAgICAgICAgICAgIHRoaXMudG9wID0gbmV3IFBhbmVsR3JvdXAodXBkYXRlLnZpZXcsIHRydWUsIGNvbmYudG9wQ29udGFpbmVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5ib3R0b20uY29udGFpbmVyICE9IGNvbmYuYm90dG9tQ29udGFpbmVyKSB7XG4gICAgICAgICAgICB0aGlzLmJvdHRvbS5zeW5jKFtdKTtcbiAgICAgICAgICAgIHRoaXMuYm90dG9tID0gbmV3IFBhbmVsR3JvdXAodXBkYXRlLnZpZXcsIGZhbHNlLCBjb25mLmJvdHRvbUNvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50b3Auc3luY0NsYXNzZXMoKTtcbiAgICAgICAgdGhpcy5ib3R0b20uc3luY0NsYXNzZXMoKTtcbiAgICAgICAgbGV0IGlucHV0ID0gdXBkYXRlLnN0YXRlLmZhY2V0KHNob3dQYW5lbCk7XG4gICAgICAgIGlmIChpbnB1dCAhPSB0aGlzLmlucHV0KSB7XG4gICAgICAgICAgICBsZXQgc3BlY3MgPSBpbnB1dC5maWx0ZXIoeCA9PiB4KTtcbiAgICAgICAgICAgIGxldCBwYW5lbHMgPSBbXSwgdG9wID0gW10sIGJvdHRvbSA9IFtdLCBtb3VudCA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgc3BlYyBvZiBzcGVjcykge1xuICAgICAgICAgICAgICAgIGxldCBrbm93biA9IHRoaXMuc3BlY3MuaW5kZXhPZihzcGVjKSwgcGFuZWw7XG4gICAgICAgICAgICAgICAgaWYgKGtub3duIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBwYW5lbCA9IHNwZWModXBkYXRlLnZpZXcpO1xuICAgICAgICAgICAgICAgICAgICBtb3VudC5wdXNoKHBhbmVsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBhbmVsID0gdGhpcy5wYW5lbHNba25vd25dO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFuZWwudXBkYXRlKVxuICAgICAgICAgICAgICAgICAgICAgICAgcGFuZWwudXBkYXRlKHVwZGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhbmVscy5wdXNoKHBhbmVsKTtcbiAgICAgICAgICAgICAgICAocGFuZWwudG9wID8gdG9wIDogYm90dG9tKS5wdXNoKHBhbmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3BlY3MgPSBzcGVjcztcbiAgICAgICAgICAgIHRoaXMucGFuZWxzID0gcGFuZWxzO1xuICAgICAgICAgICAgdGhpcy50b3Auc3luYyh0b3ApO1xuICAgICAgICAgICAgdGhpcy5ib3R0b20uc3luYyhib3R0b20pO1xuICAgICAgICAgICAgZm9yIChsZXQgcCBvZiBtb3VudCkge1xuICAgICAgICAgICAgICAgIHAuZG9tLmNsYXNzTGlzdC5hZGQoXCJjbS1wYW5lbFwiKTtcbiAgICAgICAgICAgICAgICBpZiAocC5tb3VudClcbiAgICAgICAgICAgICAgICAgICAgcC5tb3VudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChsZXQgcCBvZiB0aGlzLnBhbmVscylcbiAgICAgICAgICAgICAgICBpZiAocC51cGRhdGUpXG4gICAgICAgICAgICAgICAgICAgIHAudXBkYXRlKHVwZGF0ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy50b3Auc3luYyhbXSk7XG4gICAgICAgIHRoaXMuYm90dG9tLnN5bmMoW10pO1xuICAgIH1cbn0sIHtcbiAgICBwcm92aWRlOiBwbHVnaW4gPT4gRWRpdG9yVmlldy5zY3JvbGxNYXJnaW5zLm9mKHZpZXcgPT4ge1xuICAgICAgICBsZXQgdmFsdWUgPSB2aWV3LnBsdWdpbihwbHVnaW4pO1xuICAgICAgICByZXR1cm4gdmFsdWUgJiYgeyB0b3A6IHZhbHVlLnRvcC5zY3JvbGxNYXJnaW4oKSwgYm90dG9tOiB2YWx1ZS5ib3R0b20uc2Nyb2xsTWFyZ2luKCkgfTtcbiAgICB9KVxufSk7XG5jbGFzcyBQYW5lbEdyb3VwIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3LCB0b3AsIGNvbnRhaW5lcikge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLnRvcCA9IHRvcDtcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgICAgIHRoaXMuZG9tID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmNsYXNzZXMgPSBcIlwiO1xuICAgICAgICB0aGlzLnBhbmVscyA9IFtdO1xuICAgICAgICB0aGlzLnN5bmNDbGFzc2VzKCk7XG4gICAgfVxuICAgIHN5bmMocGFuZWxzKSB7XG4gICAgICAgIGZvciAobGV0IHAgb2YgdGhpcy5wYW5lbHMpXG4gICAgICAgICAgICBpZiAocC5kZXN0cm95ICYmIHBhbmVscy5pbmRleE9mKHApIDwgMClcbiAgICAgICAgICAgICAgICBwLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5wYW5lbHMgPSBwYW5lbHM7XG4gICAgICAgIHRoaXMuc3luY0RPTSgpO1xuICAgIH1cbiAgICBzeW5jRE9NKCkge1xuICAgICAgICBpZiAodGhpcy5wYW5lbHMubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRvbSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZG9tLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuZG9tID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5kb20pIHtcbiAgICAgICAgICAgIHRoaXMuZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgIHRoaXMuZG9tLmNsYXNzTmFtZSA9IHRoaXMudG9wID8gXCJjbS1wYW5lbHMgY20tcGFuZWxzLXRvcFwiIDogXCJjbS1wYW5lbHMgY20tcGFuZWxzLWJvdHRvbVwiO1xuICAgICAgICAgICAgdGhpcy5kb20uc3R5bGVbdGhpcy50b3AgPyBcInRvcFwiIDogXCJib3R0b21cIl0gPSBcIjBcIjtcbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSB0aGlzLmNvbnRhaW5lciB8fCB0aGlzLnZpZXcuZG9tO1xuICAgICAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZSh0aGlzLmRvbSwgdGhpcy50b3AgPyBwYXJlbnQuZmlyc3RDaGlsZCA6IG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjdXJET00gPSB0aGlzLmRvbS5maXJzdENoaWxkO1xuICAgICAgICBmb3IgKGxldCBwYW5lbCBvZiB0aGlzLnBhbmVscykge1xuICAgICAgICAgICAgaWYgKHBhbmVsLmRvbS5wYXJlbnROb2RlID09IHRoaXMuZG9tKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGN1ckRPTSAhPSBwYW5lbC5kb20pXG4gICAgICAgICAgICAgICAgICAgIGN1ckRPTSA9IHJtKGN1ckRPTSk7XG4gICAgICAgICAgICAgICAgY3VyRE9NID0gY3VyRE9NLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kb20uaW5zZXJ0QmVmb3JlKHBhbmVsLmRvbSwgY3VyRE9NKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoY3VyRE9NKVxuICAgICAgICAgICAgY3VyRE9NID0gcm0oY3VyRE9NKTtcbiAgICB9XG4gICAgc2Nyb2xsTWFyZ2luKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuZG9tIHx8IHRoaXMuY29udGFpbmVyID8gMFxuICAgICAgICAgICAgOiBNYXRoLm1heCgwLCB0aGlzLnRvcCA/XG4gICAgICAgICAgICAgICAgdGhpcy5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuYm90dG9tIC0gTWF0aC5tYXgoMCwgdGhpcy52aWV3LnNjcm9sbERPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3ApIDpcbiAgICAgICAgICAgICAgICBNYXRoLm1pbihpbm5lckhlaWdodCwgdGhpcy52aWV3LnNjcm9sbERPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5ib3R0b20pIC0gdGhpcy5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wKTtcbiAgICB9XG4gICAgc3luY0NsYXNzZXMoKSB7XG4gICAgICAgIGlmICghdGhpcy5jb250YWluZXIgfHwgdGhpcy5jbGFzc2VzID09IHRoaXMudmlldy50aGVtZUNsYXNzZXMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGZvciAobGV0IGNscyBvZiB0aGlzLmNsYXNzZXMuc3BsaXQoXCIgXCIpKVxuICAgICAgICAgICAgaWYgKGNscylcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKGNscyk7XG4gICAgICAgIGZvciAobGV0IGNscyBvZiAodGhpcy5jbGFzc2VzID0gdGhpcy52aWV3LnRoZW1lQ2xhc3Nlcykuc3BsaXQoXCIgXCIpKVxuICAgICAgICAgICAgaWYgKGNscylcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKGNscyk7XG4gICAgfVxufVxuZnVuY3Rpb24gcm0obm9kZSkge1xuICAgIGxldCBuZXh0ID0gbm9kZS5uZXh0U2libGluZztcbiAgICBub2RlLnJlbW92ZSgpO1xuICAgIHJldHVybiBuZXh0O1xufVxuLyoqXG5PcGVuaW5nIGEgcGFuZWwgaXMgZG9uZSBieSBwcm92aWRpbmcgYSBjb25zdHJ1Y3RvciBmdW5jdGlvbiBmb3JcbnRoZSBwYW5lbCB0aHJvdWdoIHRoaXMgZmFjZXQuIChUaGUgcGFuZWwgaXMgY2xvc2VkIGFnYWluIHdoZW4gaXRzXG5jb25zdHJ1Y3RvciBpcyBubyBsb25nZXIgcHJvdmlkZWQuKSBWYWx1ZXMgb2YgYG51bGxgIGFyZSBpZ25vcmVkLlxuKi9cbmNvbnN0IHNob3dQYW5lbCA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGVuYWJsZXM6IHBhbmVsUGx1Z2luXG59KTtcblxuLyoqXG5BIGd1dHRlciBtYXJrZXIgcmVwcmVzZW50cyBhIGJpdCBvZiBpbmZvcm1hdGlvbiBhdHRhY2hlZCB0byBhIGxpbmVcbmluIGEgc3BlY2lmaWMgZ3V0dGVyLiBZb3VyIG93biBjdXN0b20gbWFya2VycyBoYXZlIHRvIGV4dGVuZCB0aGlzXG5jbGFzcy5cbiovXG5jbGFzcyBHdXR0ZXJNYXJrZXIgZXh0ZW5kcyBSYW5nZVZhbHVlIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbXBhcmUob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMgPT0gb3RoZXIgfHwgdGhpcy5jb25zdHJ1Y3RvciA9PSBvdGhlci5jb25zdHJ1Y3RvciAmJiB0aGlzLmVxKG90aGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29tcGFyZSB0aGlzIG1hcmtlciB0byBhbm90aGVyIG1hcmtlciBvZiB0aGUgc2FtZSB0eXBlLlxuICAgICovXG4gICAgZXEob3RoZXIpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgLyoqXG4gICAgQ2FsbGVkIGlmIHRoZSBtYXJrZXIgaGFzIGEgYHRvRE9NYCBtZXRob2QgYW5kIGl0cyByZXByZXNlbnRhdGlvblxuICAgIHdhcyByZW1vdmVkIGZyb20gYSBndXR0ZXIuXG4gICAgKi9cbiAgICBkZXN0cm95KGRvbSkgeyB9XG59XG5HdXR0ZXJNYXJrZXIucHJvdG90eXBlLmVsZW1lbnRDbGFzcyA9IFwiXCI7XG5HdXR0ZXJNYXJrZXIucHJvdG90eXBlLnRvRE9NID0gdW5kZWZpbmVkO1xuR3V0dGVyTWFya2VyLnByb3RvdHlwZS5tYXBNb2RlID0gTWFwTW9kZS5UcmFja0JlZm9yZTtcbkd1dHRlck1hcmtlci5wcm90b3R5cGUuc3RhcnRTaWRlID0gR3V0dGVyTWFya2VyLnByb3RvdHlwZS5lbmRTaWRlID0gLTE7XG5HdXR0ZXJNYXJrZXIucHJvdG90eXBlLnBvaW50ID0gdHJ1ZTtcbi8qKlxuRmFjZXQgdXNlZCB0byBhZGQgYSBjbGFzcyB0byBhbGwgZ3V0dGVyIGVsZW1lbnRzIGZvciBhIGdpdmVuIGxpbmUuXG5NYXJrZXJzIGdpdmVuIHRvIHRoaXMgZmFjZXQgc2hvdWxkIF9vbmx5XyBkZWZpbmUgYW5cbltgZWxlbWVudGNsYXNzYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3Lkd1dHRlck1hcmtlci5lbGVtZW50Q2xhc3MpLCBub3QgYVxuW2B0b0RPTWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5HdXR0ZXJNYXJrZXIudG9ET00pIChvciB0aGUgbWFya2VyIHdpbGwgYXBwZWFyXG5pbiBhbGwgZ3V0dGVycyBmb3IgdGhlIGxpbmUpLlxuKi9cbmNvbnN0IGd1dHRlckxpbmVDbGFzcyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IGRlZmF1bHRzID0ge1xuICAgIGNsYXNzOiBcIlwiLFxuICAgIHJlbmRlckVtcHR5RWxlbWVudHM6IGZhbHNlLFxuICAgIGVsZW1lbnRTdHlsZTogXCJcIixcbiAgICBtYXJrZXJzOiAoKSA9PiBSYW5nZVNldC5lbXB0eSxcbiAgICBsaW5lTWFya2VyOiAoKSA9PiBudWxsLFxuICAgIHdpZGdldE1hcmtlcjogKCkgPT4gbnVsbCxcbiAgICBsaW5lTWFya2VyQ2hhbmdlOiBudWxsLFxuICAgIGluaXRpYWxTcGFjZXI6IG51bGwsXG4gICAgdXBkYXRlU3BhY2VyOiBudWxsLFxuICAgIGRvbUV2ZW50SGFuZGxlcnM6IHt9XG59O1xuY29uc3QgYWN0aXZlR3V0dGVycyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbi8qKlxuRGVmaW5lIGFuIGVkaXRvciBndXR0ZXIuIFRoZSBvcmRlciBpbiB3aGljaCB0aGUgZ3V0dGVycyBhcHBlYXIgaXNcbmRldGVybWluZWQgYnkgdGhlaXIgZXh0ZW5zaW9uIHByaW9yaXR5LlxuKi9cbmZ1bmN0aW9uIGd1dHRlcihjb25maWcpIHtcbiAgICByZXR1cm4gW2d1dHRlcnMoKSwgYWN0aXZlR3V0dGVycy5vZihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRzKSwgY29uZmlnKSldO1xufVxuY29uc3QgdW5maXhHdXR0ZXJzID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZTogdmFsdWVzID0+IHZhbHVlcy5zb21lKHggPT4geClcbn0pO1xuLyoqXG5UaGUgZ3V0dGVyLWRyYXdpbmcgcGx1Z2luIGlzIGF1dG9tYXRpY2FsbHkgZW5hYmxlZCB3aGVuIHlvdSBhZGQgYVxuZ3V0dGVyLCBidXQgeW91IGNhbiB1c2UgdGhpcyBmdW5jdGlvbiB0byBleHBsaWNpdGx5IGNvbmZpZ3VyZSBpdC5cblxuVW5sZXNzIGBmaXhlZGAgaXMgZXhwbGljaXRseSBzZXQgdG8gYGZhbHNlYCwgdGhlIGd1dHRlcnMgYXJlXG5maXhlZCwgbWVhbmluZyB0aGV5IGRvbid0IHNjcm9sbCBhbG9uZyB3aXRoIHRoZSBjb250ZW50XG5ob3Jpem9udGFsbHkgKGV4Y2VwdCBvbiBJbnRlcm5ldCBFeHBsb3Jlciwgd2hpY2ggZG9lc24ndCBzdXBwb3J0XG5DU1MgW2Bwb3NpdGlvbjpcbnN0aWNreWBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9wb3NpdGlvbiNzdGlja3kpKS5cbiovXG5mdW5jdGlvbiBndXR0ZXJzKGNvbmZpZykge1xuICAgIGxldCByZXN1bHQgPSBbXG4gICAgICAgIGd1dHRlclZpZXcsXG4gICAgXTtcbiAgICBpZiAoY29uZmlnICYmIGNvbmZpZy5maXhlZCA9PT0gZmFsc2UpXG4gICAgICAgIHJlc3VsdC5wdXNoKHVuZml4R3V0dGVycy5vZih0cnVlKSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IGd1dHRlclZpZXcgPSAvKkBfX1BVUkVfXyovVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5wcmV2Vmlld3BvcnQgPSB2aWV3LnZpZXdwb3J0O1xuICAgICAgICB0aGlzLmRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMuZG9tLmNsYXNzTmFtZSA9IFwiY20tZ3V0dGVyc1wiO1xuICAgICAgICB0aGlzLmRvbS5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCBcInRydWVcIik7XG4gICAgICAgIHRoaXMuZG9tLnN0eWxlLm1pbkhlaWdodCA9ICh0aGlzLnZpZXcuY29udGVudEhlaWdodCAvIHRoaXMudmlldy5zY2FsZVkpICsgXCJweFwiO1xuICAgICAgICB0aGlzLmd1dHRlcnMgPSB2aWV3LnN0YXRlLmZhY2V0KGFjdGl2ZUd1dHRlcnMpLm1hcChjb25mID0+IG5ldyBTaW5nbGVHdXR0ZXJWaWV3KHZpZXcsIGNvbmYpKTtcbiAgICAgICAgZm9yIChsZXQgZ3V0dGVyIG9mIHRoaXMuZ3V0dGVycylcbiAgICAgICAgICAgIHRoaXMuZG9tLmFwcGVuZENoaWxkKGd1dHRlci5kb20pO1xuICAgICAgICB0aGlzLmZpeGVkID0gIXZpZXcuc3RhdGUuZmFjZXQodW5maXhHdXR0ZXJzKTtcbiAgICAgICAgaWYgKHRoaXMuZml4ZWQpIHtcbiAgICAgICAgICAgIC8vIEZJWE1FIElFMTEgZmFsbGJhY2ssIHdoaWNoIGRvZXNuJ3Qgc3VwcG9ydCBwb3NpdGlvbjogc3RpY2t5LFxuICAgICAgICAgICAgLy8gYnkgdXNpbmcgcG9zaXRpb246IHJlbGF0aXZlICsgZXZlbnQgaGFuZGxlcnMgdGhhdCByZWFsaWduIHRoZVxuICAgICAgICAgICAgLy8gZ3V0dGVyIChvciBqdXN0IGZvcmNlIGZpeGVkPWZhbHNlIG9uIElFMTE/KVxuICAgICAgICAgICAgdGhpcy5kb20uc3R5bGUucG9zaXRpb24gPSBcInN0aWNreVwiO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3luY0d1dHRlcnMoZmFsc2UpO1xuICAgICAgICB2aWV3LnNjcm9sbERPTS5pbnNlcnRCZWZvcmUodGhpcy5kb20sIHZpZXcuY29udGVudERPTSk7XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgaWYgKHRoaXMudXBkYXRlR3V0dGVycyh1cGRhdGUpKSB7XG4gICAgICAgICAgICAvLyBEZXRhY2ggZHVyaW5nIHN5bmMgd2hlbiB0aGUgdmlld3BvcnQgY2hhbmdlZCBzaWduaWZpY2FudGx5XG4gICAgICAgICAgICAvLyAoc3VjaCBhcyBkdXJpbmcgc2Nyb2xsaW5nKSwgc2luY2UgZm9yIGxhcmdlIHVwZGF0ZXMgdGhhdCBpc1xuICAgICAgICAgICAgLy8gZmFzdGVyLlxuICAgICAgICAgICAgbGV0IHZwQSA9IHRoaXMucHJldlZpZXdwb3J0LCB2cEIgPSB1cGRhdGUudmlldy52aWV3cG9ydDtcbiAgICAgICAgICAgIGxldCB2cE92ZXJsYXAgPSBNYXRoLm1pbih2cEEudG8sIHZwQi50bykgLSBNYXRoLm1heCh2cEEuZnJvbSwgdnBCLmZyb20pO1xuICAgICAgICAgICAgdGhpcy5zeW5jR3V0dGVycyh2cE92ZXJsYXAgPCAodnBCLnRvIC0gdnBCLmZyb20pICogMC44KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXBkYXRlLmdlb21ldHJ5Q2hhbmdlZClcbiAgICAgICAgICAgIHRoaXMuZG9tLnN0eWxlLm1pbkhlaWdodCA9IHRoaXMudmlldy5jb250ZW50SGVpZ2h0ICsgXCJweFwiO1xuICAgICAgICBpZiAodGhpcy52aWV3LnN0YXRlLmZhY2V0KHVuZml4R3V0dGVycykgIT0gIXRoaXMuZml4ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZml4ZWQgPSAhdGhpcy5maXhlZDtcbiAgICAgICAgICAgIHRoaXMuZG9tLnN0eWxlLnBvc2l0aW9uID0gdGhpcy5maXhlZCA/IFwic3RpY2t5XCIgOiBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJldlZpZXdwb3J0ID0gdXBkYXRlLnZpZXcudmlld3BvcnQ7XG4gICAgfVxuICAgIHN5bmNHdXR0ZXJzKGRldGFjaCkge1xuICAgICAgICBsZXQgYWZ0ZXIgPSB0aGlzLmRvbS5uZXh0U2libGluZztcbiAgICAgICAgaWYgKGRldGFjaClcbiAgICAgICAgICAgIHRoaXMuZG9tLnJlbW92ZSgpO1xuICAgICAgICBsZXQgbGluZUNsYXNzZXMgPSBSYW5nZVNldC5pdGVyKHRoaXMudmlldy5zdGF0ZS5mYWNldChndXR0ZXJMaW5lQ2xhc3MpLCB0aGlzLnZpZXcudmlld3BvcnQuZnJvbSk7XG4gICAgICAgIGxldCBjbGFzc1NldCA9IFtdO1xuICAgICAgICBsZXQgY29udGV4dHMgPSB0aGlzLmd1dHRlcnMubWFwKGd1dHRlciA9PiBuZXcgVXBkYXRlQ29udGV4dChndXR0ZXIsIHRoaXMudmlldy52aWV3cG9ydCwgLXRoaXMudmlldy5kb2N1bWVudFBhZGRpbmcudG9wKSk7XG4gICAgICAgIGZvciAobGV0IGxpbmUgb2YgdGhpcy52aWV3LnZpZXdwb3J0TGluZUJsb2Nrcykge1xuICAgICAgICAgICAgaWYgKGNsYXNzU2V0Lmxlbmd0aClcbiAgICAgICAgICAgICAgICBjbGFzc1NldCA9IFtdO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobGluZS50eXBlKSkge1xuICAgICAgICAgICAgICAgIGxldCBmaXJzdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgYiBvZiBsaW5lLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGIudHlwZSA9PSBCbG9ja1R5cGUuVGV4dCAmJiBmaXJzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWR2YW5jZUN1cnNvcihsaW5lQ2xhc3NlcywgY2xhc3NTZXQsIGIuZnJvbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBjeCBvZiBjb250ZXh0cylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjeC5saW5lKHRoaXMudmlldywgYiwgY2xhc3NTZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChiLndpZGdldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgY3ggb2YgY29udGV4dHMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3gud2lkZ2V0KHRoaXMudmlldywgYik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChsaW5lLnR5cGUgPT0gQmxvY2tUeXBlLlRleHQpIHtcbiAgICAgICAgICAgICAgICBhZHZhbmNlQ3Vyc29yKGxpbmVDbGFzc2VzLCBjbGFzc1NldCwgbGluZS5mcm9tKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjeCBvZiBjb250ZXh0cylcbiAgICAgICAgICAgICAgICAgICAgY3gubGluZSh0aGlzLnZpZXcsIGxpbmUsIGNsYXNzU2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGxpbmUud2lkZ2V0KSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgY3ggb2YgY29udGV4dHMpXG4gICAgICAgICAgICAgICAgICAgIGN4LndpZGdldCh0aGlzLnZpZXcsIGxpbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGN4IG9mIGNvbnRleHRzKVxuICAgICAgICAgICAgY3guZmluaXNoKCk7XG4gICAgICAgIGlmIChkZXRhY2gpXG4gICAgICAgICAgICB0aGlzLnZpZXcuc2Nyb2xsRE9NLmluc2VydEJlZm9yZSh0aGlzLmRvbSwgYWZ0ZXIpO1xuICAgIH1cbiAgICB1cGRhdGVHdXR0ZXJzKHVwZGF0ZSkge1xuICAgICAgICBsZXQgcHJldiA9IHVwZGF0ZS5zdGFydFN0YXRlLmZhY2V0KGFjdGl2ZUd1dHRlcnMpLCBjdXIgPSB1cGRhdGUuc3RhdGUuZmFjZXQoYWN0aXZlR3V0dGVycyk7XG4gICAgICAgIGxldCBjaGFuZ2UgPSB1cGRhdGUuZG9jQ2hhbmdlZCB8fCB1cGRhdGUuaGVpZ2h0Q2hhbmdlZCB8fCB1cGRhdGUudmlld3BvcnRDaGFuZ2VkIHx8XG4gICAgICAgICAgICAhUmFuZ2VTZXQuZXEodXBkYXRlLnN0YXJ0U3RhdGUuZmFjZXQoZ3V0dGVyTGluZUNsYXNzKSwgdXBkYXRlLnN0YXRlLmZhY2V0KGd1dHRlckxpbmVDbGFzcyksIHVwZGF0ZS52aWV3LnZpZXdwb3J0LmZyb20sIHVwZGF0ZS52aWV3LnZpZXdwb3J0LnRvKTtcbiAgICAgICAgaWYgKHByZXYgPT0gY3VyKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBndXR0ZXIgb2YgdGhpcy5ndXR0ZXJzKVxuICAgICAgICAgICAgICAgIGlmIChndXR0ZXIudXBkYXRlKHVwZGF0ZSkpXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjaGFuZ2UgPSB0cnVlO1xuICAgICAgICAgICAgbGV0IGd1dHRlcnMgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGNvbmYgb2YgY3VyKSB7XG4gICAgICAgICAgICAgICAgbGV0IGtub3duID0gcHJldi5pbmRleE9mKGNvbmYpO1xuICAgICAgICAgICAgICAgIGlmIChrbm93biA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZ3V0dGVycy5wdXNoKG5ldyBTaW5nbGVHdXR0ZXJWaWV3KHRoaXMudmlldywgY29uZikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ndXR0ZXJzW2tub3duXS51cGRhdGUodXBkYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgZ3V0dGVycy5wdXNoKHRoaXMuZ3V0dGVyc1trbm93bl0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGcgb2YgdGhpcy5ndXR0ZXJzKSB7XG4gICAgICAgICAgICAgICAgZy5kb20ucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgaWYgKGd1dHRlcnMuaW5kZXhPZihnKSA8IDApXG4gICAgICAgICAgICAgICAgICAgIGcuZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgZyBvZiBndXR0ZXJzKVxuICAgICAgICAgICAgICAgIHRoaXMuZG9tLmFwcGVuZENoaWxkKGcuZG9tKTtcbiAgICAgICAgICAgIHRoaXMuZ3V0dGVycyA9IGd1dHRlcnM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoYW5nZTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgZm9yIChsZXQgdmlldyBvZiB0aGlzLmd1dHRlcnMpXG4gICAgICAgICAgICB2aWV3LmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5kb20ucmVtb3ZlKCk7XG4gICAgfVxufSwge1xuICAgIHByb3ZpZGU6IHBsdWdpbiA9PiBFZGl0b3JWaWV3LnNjcm9sbE1hcmdpbnMub2YodmlldyA9PiB7XG4gICAgICAgIGxldCB2YWx1ZSA9IHZpZXcucGx1Z2luKHBsdWdpbik7XG4gICAgICAgIGlmICghdmFsdWUgfHwgdmFsdWUuZ3V0dGVycy5sZW5ndGggPT0gMCB8fCAhdmFsdWUuZml4ZWQpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIHZpZXcudGV4dERpcmVjdGlvbiA9PSBEaXJlY3Rpb24uTFRSXG4gICAgICAgICAgICA/IHsgbGVmdDogdmFsdWUuZG9tLm9mZnNldFdpZHRoICogdmlldy5zY2FsZVggfVxuICAgICAgICAgICAgOiB7IHJpZ2h0OiB2YWx1ZS5kb20ub2Zmc2V0V2lkdGggKiB2aWV3LnNjYWxlWCB9O1xuICAgIH0pXG59KTtcbmZ1bmN0aW9uIGFzQXJyYXkodmFsKSB7IHJldHVybiAoQXJyYXkuaXNBcnJheSh2YWwpID8gdmFsIDogW3ZhbF0pOyB9XG5mdW5jdGlvbiBhZHZhbmNlQ3Vyc29yKGN1cnNvciwgY29sbGVjdCwgcG9zKSB7XG4gICAgd2hpbGUgKGN1cnNvci52YWx1ZSAmJiBjdXJzb3IuZnJvbSA8PSBwb3MpIHtcbiAgICAgICAgaWYgKGN1cnNvci5mcm9tID09IHBvcylcbiAgICAgICAgICAgIGNvbGxlY3QucHVzaChjdXJzb3IudmFsdWUpO1xuICAgICAgICBjdXJzb3IubmV4dCgpO1xuICAgIH1cbn1cbmNsYXNzIFVwZGF0ZUNvbnRleHQge1xuICAgIGNvbnN0cnVjdG9yKGd1dHRlciwgdmlld3BvcnQsIGhlaWdodCkge1xuICAgICAgICB0aGlzLmd1dHRlciA9IGd1dHRlcjtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHRoaXMuaSA9IDA7XG4gICAgICAgIHRoaXMuY3Vyc29yID0gUmFuZ2VTZXQuaXRlcihndXR0ZXIubWFya2Vycywgdmlld3BvcnQuZnJvbSk7XG4gICAgfVxuICAgIGFkZEVsZW1lbnQodmlldywgYmxvY2ssIG1hcmtlcnMpIHtcbiAgICAgICAgbGV0IHsgZ3V0dGVyIH0gPSB0aGlzLCBhYm92ZSA9IChibG9jay50b3AgLSB0aGlzLmhlaWdodCkgLyB2aWV3LnNjYWxlWSwgaGVpZ2h0ID0gYmxvY2suaGVpZ2h0IC8gdmlldy5zY2FsZVk7XG4gICAgICAgIGlmICh0aGlzLmkgPT0gZ3V0dGVyLmVsZW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IG5ld0VsdCA9IG5ldyBHdXR0ZXJFbGVtZW50KHZpZXcsIGhlaWdodCwgYWJvdmUsIG1hcmtlcnMpO1xuICAgICAgICAgICAgZ3V0dGVyLmVsZW1lbnRzLnB1c2gobmV3RWx0KTtcbiAgICAgICAgICAgIGd1dHRlci5kb20uYXBwZW5kQ2hpbGQobmV3RWx0LmRvbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBndXR0ZXIuZWxlbWVudHNbdGhpcy5pXS51cGRhdGUodmlldywgaGVpZ2h0LCBhYm92ZSwgbWFya2Vycyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oZWlnaHQgPSBibG9jay5ib3R0b207XG4gICAgICAgIHRoaXMuaSsrO1xuICAgIH1cbiAgICBsaW5lKHZpZXcsIGxpbmUsIGV4dHJhTWFya2Vycykge1xuICAgICAgICBsZXQgbG9jYWxNYXJrZXJzID0gW107XG4gICAgICAgIGFkdmFuY2VDdXJzb3IodGhpcy5jdXJzb3IsIGxvY2FsTWFya2VycywgbGluZS5mcm9tKTtcbiAgICAgICAgaWYgKGV4dHJhTWFya2Vycy5sZW5ndGgpXG4gICAgICAgICAgICBsb2NhbE1hcmtlcnMgPSBsb2NhbE1hcmtlcnMuY29uY2F0KGV4dHJhTWFya2Vycyk7XG4gICAgICAgIGxldCBmb3JMaW5lID0gdGhpcy5ndXR0ZXIuY29uZmlnLmxpbmVNYXJrZXIodmlldywgbGluZSwgbG9jYWxNYXJrZXJzKTtcbiAgICAgICAgaWYgKGZvckxpbmUpXG4gICAgICAgICAgICBsb2NhbE1hcmtlcnMudW5zaGlmdChmb3JMaW5lKTtcbiAgICAgICAgbGV0IGd1dHRlciA9IHRoaXMuZ3V0dGVyO1xuICAgICAgICBpZiAobG9jYWxNYXJrZXJzLmxlbmd0aCA9PSAwICYmICFndXR0ZXIuY29uZmlnLnJlbmRlckVtcHR5RWxlbWVudHMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuYWRkRWxlbWVudCh2aWV3LCBsaW5lLCBsb2NhbE1hcmtlcnMpO1xuICAgIH1cbiAgICB3aWRnZXQodmlldywgYmxvY2spIHtcbiAgICAgICAgbGV0IG1hcmtlciA9IHRoaXMuZ3V0dGVyLmNvbmZpZy53aWRnZXRNYXJrZXIodmlldywgYmxvY2sud2lkZ2V0LCBibG9jayk7XG4gICAgICAgIGlmIChtYXJrZXIpXG4gICAgICAgICAgICB0aGlzLmFkZEVsZW1lbnQodmlldywgYmxvY2ssIFttYXJrZXJdKTtcbiAgICB9XG4gICAgZmluaXNoKCkge1xuICAgICAgICBsZXQgZ3V0dGVyID0gdGhpcy5ndXR0ZXI7XG4gICAgICAgIHdoaWxlIChndXR0ZXIuZWxlbWVudHMubGVuZ3RoID4gdGhpcy5pKSB7XG4gICAgICAgICAgICBsZXQgbGFzdCA9IGd1dHRlci5lbGVtZW50cy5wb3AoKTtcbiAgICAgICAgICAgIGd1dHRlci5kb20ucmVtb3ZlQ2hpbGQobGFzdC5kb20pO1xuICAgICAgICAgICAgbGFzdC5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBTaW5nbGVHdXR0ZXJWaWV3IHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3LCBjb25maWcpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIHRoaXMuZWxlbWVudHMgPSBbXTtcbiAgICAgICAgdGhpcy5zcGFjZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMuZG9tLmNsYXNzTmFtZSA9IFwiY20tZ3V0dGVyXCIgKyAodGhpcy5jb25maWcuY2xhc3MgPyBcIiBcIiArIHRoaXMuY29uZmlnLmNsYXNzIDogXCJcIik7XG4gICAgICAgIGZvciAobGV0IHByb3AgaW4gY29uZmlnLmRvbUV2ZW50SGFuZGxlcnMpIHtcbiAgICAgICAgICAgIHRoaXMuZG9tLmFkZEV2ZW50TGlzdGVuZXIocHJvcCwgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHRhcmdldCA9IGV2ZW50LnRhcmdldCwgeTtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0ICE9IHRoaXMuZG9tICYmIHRoaXMuZG9tLmNvbnRhaW5zKHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHRhcmdldC5wYXJlbnROb2RlICE9IHRoaXMuZG9tKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0LnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgICAgIGxldCByZWN0ID0gdGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICB5ID0gKHJlY3QudG9wICsgcmVjdC5ib3R0b20pIC8gMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHkgPSBldmVudC5jbGllbnRZO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgbGluZSA9IHZpZXcubGluZUJsb2NrQXRIZWlnaHQoeSAtIHZpZXcuZG9jdW1lbnRUb3ApO1xuICAgICAgICAgICAgICAgIGlmIChjb25maWcuZG9tRXZlbnRIYW5kbGVyc1twcm9wXSh2aWV3LCBsaW5lLCBldmVudCkpXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1hcmtlcnMgPSBhc0FycmF5KGNvbmZpZy5tYXJrZXJzKHZpZXcpKTtcbiAgICAgICAgaWYgKGNvbmZpZy5pbml0aWFsU3BhY2VyKSB7XG4gICAgICAgICAgICB0aGlzLnNwYWNlciA9IG5ldyBHdXR0ZXJFbGVtZW50KHZpZXcsIDAsIDAsIFtjb25maWcuaW5pdGlhbFNwYWNlcih2aWV3KV0pO1xuICAgICAgICAgICAgdGhpcy5kb20uYXBwZW5kQ2hpbGQodGhpcy5zcGFjZXIuZG9tKTtcbiAgICAgICAgICAgIHRoaXMuc3BhY2VyLmRvbS5zdHlsZS5jc3NUZXh0ICs9IFwidmlzaWJpbGl0eTogaGlkZGVuOyBwb2ludGVyLWV2ZW50czogbm9uZVwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgbGV0IHByZXZNYXJrZXJzID0gdGhpcy5tYXJrZXJzO1xuICAgICAgICB0aGlzLm1hcmtlcnMgPSBhc0FycmF5KHRoaXMuY29uZmlnLm1hcmtlcnModXBkYXRlLnZpZXcpKTtcbiAgICAgICAgaWYgKHRoaXMuc3BhY2VyICYmIHRoaXMuY29uZmlnLnVwZGF0ZVNwYWNlcikge1xuICAgICAgICAgICAgbGV0IHVwZGF0ZWQgPSB0aGlzLmNvbmZpZy51cGRhdGVTcGFjZXIodGhpcy5zcGFjZXIubWFya2Vyc1swXSwgdXBkYXRlKTtcbiAgICAgICAgICAgIGlmICh1cGRhdGVkICE9IHRoaXMuc3BhY2VyLm1hcmtlcnNbMF0pXG4gICAgICAgICAgICAgICAgdGhpcy5zcGFjZXIudXBkYXRlKHVwZGF0ZS52aWV3LCAwLCAwLCBbdXBkYXRlZF0pO1xuICAgICAgICB9XG4gICAgICAgIGxldCB2cCA9IHVwZGF0ZS52aWV3LnZpZXdwb3J0O1xuICAgICAgICByZXR1cm4gIVJhbmdlU2V0LmVxKHRoaXMubWFya2VycywgcHJldk1hcmtlcnMsIHZwLmZyb20sIHZwLnRvKSB8fFxuICAgICAgICAgICAgKHRoaXMuY29uZmlnLmxpbmVNYXJrZXJDaGFuZ2UgPyB0aGlzLmNvbmZpZy5saW5lTWFya2VyQ2hhbmdlKHVwZGF0ZSkgOiBmYWxzZSk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGZvciAobGV0IGVsdCBvZiB0aGlzLmVsZW1lbnRzKVxuICAgICAgICAgICAgZWx0LmRlc3Ryb3koKTtcbiAgICB9XG59XG5jbGFzcyBHdXR0ZXJFbGVtZW50IHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3LCBoZWlnaHQsIGFib3ZlLCBtYXJrZXJzKSB7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gLTE7XG4gICAgICAgIHRoaXMuYWJvdmUgPSAwO1xuICAgICAgICB0aGlzLm1hcmtlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5kb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLmRvbS5jbGFzc05hbWUgPSBcImNtLWd1dHRlckVsZW1lbnRcIjtcbiAgICAgICAgdGhpcy51cGRhdGUodmlldywgaGVpZ2h0LCBhYm92ZSwgbWFya2Vycyk7XG4gICAgfVxuICAgIHVwZGF0ZSh2aWV3LCBoZWlnaHQsIGFib3ZlLCBtYXJrZXJzKSB7XG4gICAgICAgIGlmICh0aGlzLmhlaWdodCAhPSBoZWlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy5kb20uc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgXCJweFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmFib3ZlICE9IGFib3ZlKVxuICAgICAgICAgICAgdGhpcy5kb20uc3R5bGUubWFyZ2luVG9wID0gKHRoaXMuYWJvdmUgPSBhYm92ZSkgPyBhYm92ZSArIFwicHhcIiA6IFwiXCI7XG4gICAgICAgIGlmICghc2FtZU1hcmtlcnModGhpcy5tYXJrZXJzLCBtYXJrZXJzKSlcbiAgICAgICAgICAgIHRoaXMuc2V0TWFya2Vycyh2aWV3LCBtYXJrZXJzKTtcbiAgICB9XG4gICAgc2V0TWFya2Vycyh2aWV3LCBtYXJrZXJzKSB7XG4gICAgICAgIGxldCBjbHMgPSBcImNtLWd1dHRlckVsZW1lbnRcIiwgZG9tUG9zID0gdGhpcy5kb20uZmlyc3RDaGlsZDtcbiAgICAgICAgZm9yIChsZXQgaU5ldyA9IDAsIGlPbGQgPSAwOzspIHtcbiAgICAgICAgICAgIGxldCBza2lwVG8gPSBpT2xkLCBtYXJrZXIgPSBpTmV3IDwgbWFya2Vycy5sZW5ndGggPyBtYXJrZXJzW2lOZXcrK10gOiBudWxsLCBtYXRjaGVkID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAobWFya2VyKSB7XG4gICAgICAgICAgICAgICAgbGV0IGMgPSBtYXJrZXIuZWxlbWVudENsYXNzO1xuICAgICAgICAgICAgICAgIGlmIChjKVxuICAgICAgICAgICAgICAgICAgICBjbHMgKz0gXCIgXCIgKyBjO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBpT2xkOyBpIDwgdGhpcy5tYXJrZXJzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXJrZXJzW2ldLmNvbXBhcmUobWFya2VyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2tpcFRvID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNraXBUbyA9IHRoaXMubWFya2Vycy5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoaU9sZCA8IHNraXBUbykge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gdGhpcy5tYXJrZXJzW2lPbGQrK107XG4gICAgICAgICAgICAgICAgaWYgKG5leHQudG9ET00pIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dC5kZXN0cm95KGRvbVBvcyk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBhZnRlciA9IGRvbVBvcy5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICAgICAgZG9tUG9zLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICBkb21Qb3MgPSBhZnRlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW1hcmtlcilcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGlmIChtYXJrZXIudG9ET00pIHtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hlZClcbiAgICAgICAgICAgICAgICAgICAgZG9tUG9zID0gZG9tUG9zLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb20uaW5zZXJ0QmVmb3JlKG1hcmtlci50b0RPTSh2aWV3KSwgZG9tUG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRjaGVkKVxuICAgICAgICAgICAgICAgIGlPbGQrKztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRvbS5jbGFzc05hbWUgPSBjbHM7XG4gICAgICAgIHRoaXMubWFya2VycyA9IG1hcmtlcnM7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc2V0TWFya2VycyhudWxsLCBbXSk7IC8vIEZpcnN0IGFyZ3VtZW50IG5vdCB1c2VkIHVubGVzcyBjcmVhdGluZyBtYXJrZXJzXG4gICAgfVxufVxuZnVuY3Rpb24gc2FtZU1hcmtlcnMoYSwgYikge1xuICAgIGlmIChhLmxlbmd0aCAhPSBiLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKylcbiAgICAgICAgaWYgKCFhW2ldLmNvbXBhcmUoYltpXSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbkZhY2V0IHVzZWQgdG8gcHJvdmlkZSBtYXJrZXJzIHRvIHRoZSBsaW5lIG51bWJlciBndXR0ZXIuXG4qL1xuY29uc3QgbGluZU51bWJlck1hcmtlcnMgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCBsaW5lTnVtYmVyQ29uZmlnID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZSh2YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVDb25maWcodmFsdWVzLCB7IGZvcm1hdE51bWJlcjogU3RyaW5nLCBkb21FdmVudEhhbmRsZXJzOiB7fSB9LCB7XG4gICAgICAgICAgICBkb21FdmVudEhhbmRsZXJzKGEsIGIpIHtcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gT2JqZWN0LmFzc2lnbih7fSwgYSk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgZXZlbnQgaW4gYikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZXhpc3RzID0gcmVzdWx0W2V2ZW50XSwgYWRkID0gYltldmVudF07XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtldmVudF0gPSBleGlzdHMgPyAodmlldywgbGluZSwgZXZlbnQpID0+IGV4aXN0cyh2aWV3LCBsaW5lLCBldmVudCkgfHwgYWRkKHZpZXcsIGxpbmUsIGV2ZW50KSA6IGFkZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG5jbGFzcyBOdW1iZXJNYXJrZXIgZXh0ZW5kcyBHdXR0ZXJNYXJrZXIge1xuICAgIGNvbnN0cnVjdG9yKG51bWJlcikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm51bWJlciA9IG51bWJlcjtcbiAgICB9XG4gICAgZXEob3RoZXIpIHsgcmV0dXJuIHRoaXMubnVtYmVyID09IG90aGVyLm51bWJlcjsgfVxuICAgIHRvRE9NKCkgeyByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGhpcy5udW1iZXIpOyB9XG59XG5mdW5jdGlvbiBmb3JtYXROdW1iZXIodmlldywgbnVtYmVyKSB7XG4gICAgcmV0dXJuIHZpZXcuc3RhdGUuZmFjZXQobGluZU51bWJlckNvbmZpZykuZm9ybWF0TnVtYmVyKG51bWJlciwgdmlldy5zdGF0ZSk7XG59XG5jb25zdCBsaW5lTnVtYmVyR3V0dGVyID0gLypAX19QVVJFX18qL2FjdGl2ZUd1dHRlcnMuY29tcHV0ZShbbGluZU51bWJlckNvbmZpZ10sIHN0YXRlID0+ICh7XG4gICAgY2xhc3M6IFwiY20tbGluZU51bWJlcnNcIixcbiAgICByZW5kZXJFbXB0eUVsZW1lbnRzOiBmYWxzZSxcbiAgICBtYXJrZXJzKHZpZXcpIHsgcmV0dXJuIHZpZXcuc3RhdGUuZmFjZXQobGluZU51bWJlck1hcmtlcnMpOyB9LFxuICAgIGxpbmVNYXJrZXIodmlldywgbGluZSwgb3RoZXJzKSB7XG4gICAgICAgIGlmIChvdGhlcnMuc29tZShtID0+IG0udG9ET00pKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBuZXcgTnVtYmVyTWFya2VyKGZvcm1hdE51bWJlcih2aWV3LCB2aWV3LnN0YXRlLmRvYy5saW5lQXQobGluZS5mcm9tKS5udW1iZXIpKTtcbiAgICB9LFxuICAgIHdpZGdldE1hcmtlcjogKCkgPT4gbnVsbCxcbiAgICBsaW5lTWFya2VyQ2hhbmdlOiB1cGRhdGUgPT4gdXBkYXRlLnN0YXJ0U3RhdGUuZmFjZXQobGluZU51bWJlckNvbmZpZykgIT0gdXBkYXRlLnN0YXRlLmZhY2V0KGxpbmVOdW1iZXJDb25maWcpLFxuICAgIGluaXRpYWxTcGFjZXIodmlldykge1xuICAgICAgICByZXR1cm4gbmV3IE51bWJlck1hcmtlcihmb3JtYXROdW1iZXIodmlldywgbWF4TGluZU51bWJlcih2aWV3LnN0YXRlLmRvYy5saW5lcykpKTtcbiAgICB9LFxuICAgIHVwZGF0ZVNwYWNlcihzcGFjZXIsIHVwZGF0ZSkge1xuICAgICAgICBsZXQgbWF4ID0gZm9ybWF0TnVtYmVyKHVwZGF0ZS52aWV3LCBtYXhMaW5lTnVtYmVyKHVwZGF0ZS52aWV3LnN0YXRlLmRvYy5saW5lcykpO1xuICAgICAgICByZXR1cm4gbWF4ID09IHNwYWNlci5udW1iZXIgPyBzcGFjZXIgOiBuZXcgTnVtYmVyTWFya2VyKG1heCk7XG4gICAgfSxcbiAgICBkb21FdmVudEhhbmRsZXJzOiBzdGF0ZS5mYWNldChsaW5lTnVtYmVyQ29uZmlnKS5kb21FdmVudEhhbmRsZXJzXG59KSk7XG4vKipcbkNyZWF0ZSBhIGxpbmUgbnVtYmVyIGd1dHRlciBleHRlbnNpb24uXG4qL1xuZnVuY3Rpb24gbGluZU51bWJlcnMoY29uZmlnID0ge30pIHtcbiAgICByZXR1cm4gW1xuICAgICAgICBsaW5lTnVtYmVyQ29uZmlnLm9mKGNvbmZpZyksXG4gICAgICAgIGd1dHRlcnMoKSxcbiAgICAgICAgbGluZU51bWJlckd1dHRlclxuICAgIF07XG59XG5mdW5jdGlvbiBtYXhMaW5lTnVtYmVyKGxpbmVzKSB7XG4gICAgbGV0IGxhc3QgPSA5O1xuICAgIHdoaWxlIChsYXN0IDwgbGluZXMpXG4gICAgICAgIGxhc3QgPSBsYXN0ICogMTAgKyA5O1xuICAgIHJldHVybiBsYXN0O1xufVxuY29uc3QgYWN0aXZlTGluZUd1dHRlck1hcmtlciA9IC8qQF9fUFVSRV9fKi9uZXcgY2xhc3MgZXh0ZW5kcyBHdXR0ZXJNYXJrZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmVsZW1lbnRDbGFzcyA9IFwiY20tYWN0aXZlTGluZUd1dHRlclwiO1xuICAgIH1cbn07XG5jb25zdCBhY3RpdmVMaW5lR3V0dGVySGlnaGxpZ2h0ZXIgPSAvKkBfX1BVUkVfXyovZ3V0dGVyTGluZUNsYXNzLmNvbXB1dGUoW1wic2VsZWN0aW9uXCJdLCBzdGF0ZSA9PiB7XG4gICAgbGV0IG1hcmtzID0gW10sIGxhc3QgPSAtMTtcbiAgICBmb3IgKGxldCByYW5nZSBvZiBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzKSB7XG4gICAgICAgIGxldCBsaW5lUG9zID0gc3RhdGUuZG9jLmxpbmVBdChyYW5nZS5oZWFkKS5mcm9tO1xuICAgICAgICBpZiAobGluZVBvcyA+IGxhc3QpIHtcbiAgICAgICAgICAgIGxhc3QgPSBsaW5lUG9zO1xuICAgICAgICAgICAgbWFya3MucHVzaChhY3RpdmVMaW5lR3V0dGVyTWFya2VyLnJhbmdlKGxpbmVQb3MpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gUmFuZ2VTZXQub2YobWFya3MpO1xufSk7XG4vKipcblJldHVybnMgYW4gZXh0ZW5zaW9uIHRoYXQgYWRkcyBhIGBjbS1hY3RpdmVMaW5lR3V0dGVyYCBjbGFzcyB0b1xuYWxsIGd1dHRlciBlbGVtZW50cyBvbiB0aGUgW2FjdGl2ZVxubGluZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LmhpZ2hsaWdodEFjdGl2ZUxpbmUpLlxuKi9cbmZ1bmN0aW9uIGhpZ2hsaWdodEFjdGl2ZUxpbmVHdXR0ZXIoKSB7XG4gICAgcmV0dXJuIGFjdGl2ZUxpbmVHdXR0ZXJIaWdobGlnaHRlcjtcbn1cblxuY29uc3QgV2hpdGVzcGFjZURlY28gPSAvKkBfX1BVUkVfXyovbmV3IE1hcCgpO1xuZnVuY3Rpb24gZ2V0V2hpdGVzcGFjZURlY28oc3BhY2UpIHtcbiAgICBsZXQgZGVjbyA9IFdoaXRlc3BhY2VEZWNvLmdldChzcGFjZSk7XG4gICAgaWYgKCFkZWNvKVxuICAgICAgICBXaGl0ZXNwYWNlRGVjby5zZXQoc3BhY2UsIGRlY28gPSBEZWNvcmF0aW9uLm1hcmsoe1xuICAgICAgICAgICAgYXR0cmlidXRlczogc3BhY2UgPT09IFwiXFx0XCIgPyB7XG4gICAgICAgICAgICAgICAgY2xhc3M6IFwiY20taGlnaGxpZ2h0VGFiXCIsXG4gICAgICAgICAgICB9IDoge1xuICAgICAgICAgICAgICAgIGNsYXNzOiBcImNtLWhpZ2hsaWdodFNwYWNlXCIsXG4gICAgICAgICAgICAgICAgXCJkYXRhLWRpc3BsYXlcIjogc3BhY2UucmVwbGFjZSgvIC9nLCBcIsK3XCIpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICByZXR1cm4gZGVjbztcbn1cbmZ1bmN0aW9uIG1hdGNoZXIoZGVjb3JhdG9yKSB7XG4gICAgcmV0dXJuIFZpZXdQbHVnaW4uZGVmaW5lKHZpZXcgPT4gKHtcbiAgICAgICAgZGVjb3JhdGlvbnM6IGRlY29yYXRvci5jcmVhdGVEZWNvKHZpZXcpLFxuICAgICAgICB1cGRhdGUodSkge1xuICAgICAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IGRlY29yYXRvci51cGRhdGVEZWNvKHUsIHRoaXMuZGVjb3JhdGlvbnMpO1xuICAgICAgICB9LFxuICAgIH0pLCB7XG4gICAgICAgIGRlY29yYXRpb25zOiB2ID0+IHYuZGVjb3JhdGlvbnNcbiAgICB9KTtcbn1cbmNvbnN0IHdoaXRlc3BhY2VIaWdobGlnaHRlciA9IC8qQF9fUFVSRV9fKi9tYXRjaGVyKC8qQF9fUFVSRV9fKi9uZXcgTWF0Y2hEZWNvcmF0b3Ioe1xuICAgIHJlZ2V4cDogL1xcdHwgKy9nLFxuICAgIGRlY29yYXRpb246IG1hdGNoID0+IGdldFdoaXRlc3BhY2VEZWNvKG1hdGNoWzBdKSxcbiAgICBib3VuZGFyeTogL1xcUy8sXG59KSk7XG4vKipcblJldHVybnMgYW4gZXh0ZW5zaW9uIHRoYXQgaGlnaGxpZ2h0cyB3aGl0ZXNwYWNlLCBhZGRpbmcgYVxuYGNtLWhpZ2hsaWdodFNwYWNlYCBjbGFzcyB0byBzdHJldGNoZXMgb2Ygc3BhY2VzLCBhbmQgYVxuYGNtLWhpZ2hsaWdodFRhYmAgY2xhc3MgdG8gaW5kaXZpZHVhbCB0YWIgY2hhcmFjdGVycy4gQnkgZGVmYXVsdCxcbnRoZSBmb3JtZXIgYXJlIHNob3duIGFzIGZhaW50IGRvdHMsIGFuZCB0aGUgbGF0dGVyIGFzIGFycm93cy5cbiovXG5mdW5jdGlvbiBoaWdobGlnaHRXaGl0ZXNwYWNlKCkge1xuICAgIHJldHVybiB3aGl0ZXNwYWNlSGlnaGxpZ2h0ZXI7XG59XG5jb25zdCB0cmFpbGluZ0hpZ2hsaWdodGVyID0gLypAX19QVVJFX18qL21hdGNoZXIoLypAX19QVVJFX18qL25ldyBNYXRjaERlY29yYXRvcih7XG4gICAgcmVnZXhwOiAvXFxzKyQvZyxcbiAgICBkZWNvcmF0aW9uOiAvKkBfX1BVUkVfXyovRGVjb3JhdGlvbi5tYXJrKHsgY2xhc3M6IFwiY20tdHJhaWxpbmdTcGFjZVwiIH0pLFxuICAgIGJvdW5kYXJ5OiAvXFxTLyxcbn0pKTtcbi8qKlxuUmV0dXJucyBhbiBleHRlbnNpb24gdGhhdCBhZGRzIGEgYGNtLXRyYWlsaW5nU3BhY2VgIGNsYXNzIHRvIGFsbFxudHJhaWxpbmcgd2hpdGVzcGFjZS5cbiovXG5mdW5jdGlvbiBoaWdobGlnaHRUcmFpbGluZ1doaXRlc3BhY2UoKSB7XG4gICAgcmV0dXJuIHRyYWlsaW5nSGlnaGxpZ2h0ZXI7XG59XG5cbi8qKlxuQGludGVybmFsXG4qL1xuY29uc3QgX190ZXN0ID0geyBIZWlnaHRNYXAsIEhlaWdodE9yYWNsZSwgTWVhc3VyZWRIZWlnaHRzLCBRdWVyeVR5cGUsIENoYW5nZWRSYW5nZSwgY29tcHV0ZU9yZGVyLCBtb3ZlVmlzdWFsbHkgfTtcblxuZXhwb3J0IHsgQmlkaVNwYW4sIEJsb2NrSW5mbywgQmxvY2tUeXBlLCBEZWNvcmF0aW9uLCBEaXJlY3Rpb24sIEVkaXRvclZpZXcsIEd1dHRlck1hcmtlciwgTWF0Y2hEZWNvcmF0b3IsIFJlY3RhbmdsZU1hcmtlciwgVmlld1BsdWdpbiwgVmlld1VwZGF0ZSwgV2lkZ2V0VHlwZSwgX190ZXN0LCBjbG9zZUhvdmVyVG9vbHRpcHMsIGNyb3NzaGFpckN1cnNvciwgZHJhd1NlbGVjdGlvbiwgZHJvcEN1cnNvciwgZ2V0RHJhd1NlbGVjdGlvbkNvbmZpZywgZ2V0UGFuZWwsIGdldFRvb2x0aXAsIGd1dHRlciwgZ3V0dGVyTGluZUNsYXNzLCBndXR0ZXJzLCBoYXNIb3ZlclRvb2x0aXBzLCBoaWdobGlnaHRBY3RpdmVMaW5lLCBoaWdobGlnaHRBY3RpdmVMaW5lR3V0dGVyLCBoaWdobGlnaHRTcGVjaWFsQ2hhcnMsIGhpZ2hsaWdodFRyYWlsaW5nV2hpdGVzcGFjZSwgaGlnaGxpZ2h0V2hpdGVzcGFjZSwgaG92ZXJUb29sdGlwLCBrZXltYXAsIGxheWVyLCBsaW5lTnVtYmVyTWFya2VycywgbGluZU51bWJlcnMsIGxvZ0V4Y2VwdGlvbiwgcGFuZWxzLCBwbGFjZWhvbGRlciwgcmVjdGFuZ3VsYXJTZWxlY3Rpb24sIHJlcG9zaXRpb25Ub29sdGlwcywgcnVuU2NvcGVIYW5kbGVycywgc2Nyb2xsUGFzdEVuZCwgc2hvd1BhbmVsLCBzaG93VG9vbHRpcCwgdG9vbHRpcHMgfTtcbiJdLCJuYW1lcyI6WyJUZXh0IiwiUmFuZ2VTZXQiLCJNYXBNb2RlIiwiUmFuZ2VWYWx1ZSIsIkZhY2V0IiwiU3RhdGVFZmZlY3QiLCJDaGFuZ2VTZXQiLCJFZGl0b3JTZWxlY3Rpb24iLCJmaW5kQ2x1c3RlckJyZWFrIiwiZmluZENvbHVtbiIsIkNoYXJDYXRlZ29yeSIsIkFubm90YXRpb24iLCJFZGl0b3JTdGF0ZSIsIlRyYW5zYWN0aW9uIiwiUHJlYyIsImNvZGVQb2ludEF0IiwiY29kZVBvaW50U2l6ZSIsImNvbWJpbmVDb25maWciLCJTdGF0ZUZpZWxkIiwiUmFuZ2VTZXRCdWlsZGVyIiwiY291bnRDb2x1bW4iLCJTdHlsZU1vZHVsZSIsImtleU5hbWUiLCJiYXNlIiwic2hpZnQiLCJnZXRTZWxlY3Rpb24iLCJyb290IiwidGFyZ2V0Iiwibm9kZVR5cGUiLCJvd25lckRvY3VtZW50IiwiY29udGFpbnMiLCJkb20iLCJub2RlIiwicGFyZW50Tm9kZSIsImRlZXBBY3RpdmVFbGVtZW50IiwiZG9jIiwiZWx0IiwiYWN0aXZlRWxlbWVudCIsInNoYWRvd1Jvb3QiLCJoYXNTZWxlY3Rpb24iLCJzZWxlY3Rpb24iLCJhbmNob3JOb2RlIiwiXyIsImNsaWVudFJlY3RzRm9yIiwidGV4dFJhbmdlIiwibm9kZVZhbHVlIiwibGVuZ3RoIiwiZ2V0Q2xpZW50UmVjdHMiLCJpc0VxdWl2YWxlbnRQb3NpdGlvbiIsIm9mZiIsInRhcmdldE5vZGUiLCJ0YXJnZXRPZmYiLCJzY2FuRm9yIiwiZG9tSW5kZXgiLCJpbmRleCIsInByZXZpb3VzU2libGluZyIsImRpciIsIm1heE9mZnNldCIsIm5vZGVOYW1lIiwicGFyZW50IiwiY2hpbGROb2RlcyIsImNvbnRlbnRFZGl0YWJsZSIsImZsYXR0ZW5SZWN0IiwicmVjdCIsImxlZnQiLCJ4IiwicmlnaHQiLCJ0b3AiLCJib3R0b20iLCJ3aW5kb3dSZWN0Iiwid2luIiwiaW5uZXJXaWR0aCIsImlubmVySGVpZ2h0IiwiZ2V0U2NhbGUiLCJzY2FsZVgiLCJ3aWR0aCIsIm9mZnNldFdpZHRoIiwic2NhbGVZIiwiaGVpZ2h0Iiwib2Zmc2V0SGVpZ2h0IiwiaXNGaW5pdGUiLCJNYXRoIiwiYWJzIiwic2Nyb2xsUmVjdEludG9WaWV3Iiwic2lkZSIsInkiLCJ4TWFyZ2luIiwieU1hcmdpbiIsImx0ciIsImRlZmF1bHRWaWV3Iiwid2luZG93IiwiY3VyIiwic3RvcCIsImJvdW5kaW5nIiwiYm9keSIsInRlc3QiLCJnZXRDb21wdXRlZFN0eWxlIiwicG9zaXRpb24iLCJzY3JvbGxIZWlnaHQiLCJjbGllbnRIZWlnaHQiLCJzY3JvbGxXaWR0aCIsImNsaWVudFdpZHRoIiwiYXNzaWduZWRTbG90IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwibW92ZVgiLCJtb3ZlWSIsInJlY3RIZWlnaHQiLCJib3VuZGluZ0hlaWdodCIsInRhcmdldFRvcCIsInRhcmdldExlZnQiLCJzY3JvbGxCeSIsIm1vdmVkWCIsIm1vdmVkWSIsInN0YXJ0Iiwic2Nyb2xsVG9wIiwic2Nyb2xsTGVmdCIsImhvc3QiLCJzY3JvbGxhYmxlUGFyZW50IiwiRE9NU2VsZWN0aW9uU3RhdGUiLCJjb25zdHJ1Y3RvciIsImFuY2hvck9mZnNldCIsImZvY3VzTm9kZSIsImZvY3VzT2Zmc2V0IiwiZXEiLCJkb21TZWwiLCJzZXRSYW5nZSIsInJhbmdlIiwic2V0IiwibWluIiwicHJldmVudFNjcm9sbFN1cHBvcnRlZCIsImZvY3VzUHJldmVudFNjcm9sbCIsInNldEFjdGl2ZSIsImZvY3VzIiwic3RhY2siLCJwdXNoIiwicHJldmVudFNjcm9sbCIsInVuZGVmaW5lZCIsImkiLCJzY3JhdGNoUmFuZ2UiLCJmcm9tIiwidG8iLCJkb2N1bWVudCIsImNyZWF0ZVJhbmdlIiwic2V0RW5kIiwic2V0U3RhcnQiLCJkaXNwYXRjaEtleSIsIm5hbWUiLCJjb2RlIiwib3B0aW9ucyIsImtleSIsImtleUNvZGUiLCJ3aGljaCIsImNhbmNlbGFibGUiLCJkb3duIiwiS2V5Ym9hcmRFdmVudCIsInN5bnRoZXRpYyIsImRpc3BhdGNoRXZlbnQiLCJ1cCIsImRlZmF1bHRQcmV2ZW50ZWQiLCJnZXRSb290IiwiY2xlYXJBdHRyaWJ1dGVzIiwiYXR0cmlidXRlcyIsInJlbW92ZUF0dHJpYnV0ZU5vZGUiLCJhdEVsZW1lbnRTdGFydCIsIm9mZnNldCIsInByZXYiLCJpc1Njcm9sbGVkVG9Cb3R0b20iLCJtYXgiLCJET01Qb3MiLCJwcmVjaXNlIiwiYmVmb3JlIiwiYWZ0ZXIiLCJub0NoaWxkcmVuIiwiQ29udGVudFZpZXciLCJmbGFncyIsIm92ZXJyaWRlRE9NVGV4dCIsInBvc0F0U3RhcnQiLCJwb3NCZWZvcmUiLCJwb3NBdEVuZCIsInZpZXciLCJwb3MiLCJjaGlsZCIsImNoaWxkcmVuIiwiYnJlYWtBZnRlciIsIlJhbmdlRXJyb3IiLCJwb3NBZnRlciIsInN5bmMiLCJ0cmFjayIsIm5leHQiLCJuZXh0U2libGluZyIsImZpcnN0Q2hpbGQiLCJjb250ZW50VmlldyIsImdldCIsImNhblJldXNlRE9NIiwicmV1c2VET00iLCJ3cml0dGVuIiwicm0kMSIsImluc2VydEJlZm9yZSIsIl9kb20iLCJsb2NhbFBvc0Zyb21ET00iLCJiaWFzIiwibGFzdENoaWxkIiwiZG9tQm91bmRzQXJvdW5kIiwiZnJvbUkiLCJmcm9tU3RhcnQiLCJ0b0kiLCJ0b0VuZCIsInByZXZFbmQiLCJlbmQiLCJzdGFydERPTSIsImVuZERPTSIsIm1hcmtEaXJ0eSIsImFuZFBhcmVudCIsIm1hcmtQYXJlbnRzRGlydHkiLCJjaGlsZExpc3QiLCJzZXRQYXJlbnQiLCJzZXRET00iLCJjbVZpZXciLCJyb290VmlldyIsInYiLCJyZXBsYWNlQ2hpbGRyZW4iLCJpbmRleE9mIiwiZGVzdHJveSIsInNwbGljZSIsImlnbm9yZU11dGF0aW9uIiwiX3JlYyIsImlnbm9yZUV2ZW50IiwiX2V2ZW50IiwiY2hpbGRDdXJzb3IiLCJDaGlsZEN1cnNvciIsImNoaWxkUG9zIiwiZmluZFBvcyIsInRvU3RyaW5nIiwicmVwbGFjZSIsImpvaW4iLCJ0ZXh0IiwiaXNFZGl0YWJsZSIsImlzV2lkZ2V0IiwiaXNIaWRkZW4iLCJtZXJnZSIsInNvdXJjZSIsImhhc1N0YXJ0Iiwib3BlblN0YXJ0Iiwib3BlbkVuZCIsImJlY29tZSIsIm90aGVyIiwiZ2V0U2lkZSIsInByb3RvdHlwZSIsInJlbW92ZUNoaWxkIiwicmVwbGFjZVJhbmdlIiwiZnJvbU9mZiIsInRvT2ZmIiwiaW5zZXJ0IiwiYnJlYWtBdFN0YXJ0IiwibGFzdCIsImJyZWFrQXRFbmQiLCJzcGxpdCIsInBvcCIsIm1lcmdlQ2hpbGRyZW5JbnRvIiwiZExlbiIsIm5hdiIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsInZlbmRvciIsInBsYXRmb3JtIiwiZG9jdW1lbnRFbGVtZW50Iiwic3R5bGUiLCJpZV9lZGdlIiwiZXhlYyIsImllX3VwdG8xMCIsImllXzExdXAiLCJpZSIsImdlY2tvIiwiY2hyb21lIiwid2Via2l0Iiwic2FmYXJpIiwiaW9zIiwibWF4VG91Y2hQb2ludHMiLCJicm93c2VyIiwibWFjIiwid2luZG93cyIsImxpbnV4IiwiaWVfdmVyc2lvbiIsImRvY3VtZW50TW9kZSIsImdlY2tvX3ZlcnNpb24iLCJjaHJvbWVfdmVyc2lvbiIsImFuZHJvaWQiLCJ3ZWJraXRfdmVyc2lvbiIsInRhYlNpemUiLCJNYXhKb2luTGVuIiwiVGV4dFZpZXciLCJjcmVhdGVET00iLCJ0ZXh0RE9NIiwiY3JlYXRlVGV4dE5vZGUiLCJzbGljZSIsInJlc3VsdCIsImRvbUF0UG9zIiwiX2Zyb20iLCJfdG8iLCJjb29yZHNBdCIsInRleHRDb29yZHMiLCJNYXJrVmlldyIsIm1hcmsiLCJjaCIsInNldEF0dHJzIiwiY2xhc3MiLCJjbGFzc05hbWUiLCJhdHRycyIsInNldEF0dHJpYnV0ZSIsInRhZ05hbWUiLCJ0b1VwcGVyQ2FzZSIsImNyZWF0ZUVsZW1lbnQiLCJfaGFzU3RhcnQiLCJkZXRhY2hGcm9tIiwiaW5saW5lRE9NQXRQb3MiLCJjb29yZHNJbkNoaWxkcmVuIiwiZmxhdHRlbiIsInJlY3RzIiwiQXJyYXkiLCJmaW5kIiwiY2FsbCIsInIiLCJXaWRnZXRWaWV3IiwiY3JlYXRlIiwid2lkZ2V0IiwicHJldldpZGdldCIsInVwZGF0ZURPTSIsInRvRE9NIiwiY29tcGFyZSIsImV2ZW50IiwiZW1wdHkiLCJzdGF0ZSIsImN1c3RvbSIsImZyb21CYWNrIiwiV2lkZ2V0QnVmZmVyVmlldyIsImoiLCJqb2luSW5saW5lSW50byIsIm9wZW4iLCJiZWZvcmVQb3MiLCJhZnRlclBvcyIsInNjYW4iLCJmYWxsYmFja1JlY3QiLCJjb21iaW5lQXR0cnMiLCJub0F0dHJzIiwiT2JqZWN0IiwiYXR0cnNFcSIsImEiLCJiIiwiaWdub3JlIiwia2V5c0EiLCJrZXlzIiwia2V5c0IiLCJ1cGRhdGVBdHRycyIsImNoYW5nZWQiLCJjc3NUZXh0IiwicmVtb3ZlQXR0cmlidXRlIiwiZ2V0QXR0cnMiLCJhdHRyIiwidmFsdWUiLCJMaW5lVmlldyIsImFyZ3VtZW50cyIsInByZXZBdHRycyIsInRyYW5zZmVyRE9NIiwic2V0RGVjbyIsImF0IiwiYXBwZW5kIiwiYWRkTGluZURlY28iLCJkZWNvIiwic3BlYyIsImNscyIsIl9hIiwiY2xhc3NMaXN0IiwiYWRkIiwic29tZSIsImhhY2siLCJjbUlnbm9yZSIsImFwcGVuZENoaWxkIiwibWVhc3VyZVRleHRTaXplIiwidG90YWxXaWR0aCIsInRleHRIZWlnaHQiLCJsaW5lSGVpZ2h0IiwiY2hhcldpZHRoIiwiaGVpZ2h0T3JhY2xlIiwidmlld1N0YXRlIiwiZGlzdCIsIl9vdGhlciIsImNvdmVycyIsImRvY1ZpZXciLCJibG9jayIsIkJsb2NrV2lkZ2V0VmlldyIsIl90YWtlRGVjbyIsImxlbiIsInN0YXJ0U2lkZSIsImVuZFNpZGUiLCJXaWRnZXRUeXBlIiwiZXN0aW1hdGVkSGVpZ2h0IiwibGluZUJyZWFrcyIsIkJsb2NrVHlwZSIsIkRlY29yYXRpb24iLCJoZWlnaHRSZWxldmFudCIsIk1hcmtEZWNvcmF0aW9uIiwiaW5saW5lT3JkZXIiLCJQb2ludERlY29yYXRpb24iLCJpc0Jsb2NrR2FwIiwiZ2V0SW5jbHVzaXZlIiwibGluZSIsIkxpbmVEZWNvcmF0aW9uIiwib2YiLCJzb3J0IiwiaGFzSGVpZ2h0Iiwibm9uZSIsIl9iIiwicG9pbnQiLCJtYXBNb2RlIiwiVHJhY2tCZWZvcmUiLCJpc1JlcGxhY2UiLCJUcmFja0RlbCIsIlRyYWNrQWZ0ZXIiLCJ0eXBlIiwiV2lkZ2V0UmFuZ2UiLCJXaWRnZXRCZWZvcmUiLCJXaWRnZXRBZnRlciIsIndpZGdldHNFcSIsImluY2x1c2l2ZVN0YXJ0IiwiaW5jbHVzaXZlRW5kIiwiaW5jbHVzaXZlIiwiYWRkUmFuZ2UiLCJyYW5nZXMiLCJtYXJnaW4iLCJDb250ZW50QnVpbGRlciIsImRpc2FsbG93QmxvY2tFZmZlY3RzRm9yIiwiY29udGVudCIsImN1ckxpbmUiLCJwZW5kaW5nQnVmZmVyIiwiYnVmZmVyTWFya3MiLCJhdEN1cnNvclBvcyIsInRleHRPZmYiLCJjdXJzb3IiLCJpdGVyIiwic2tpcCIsInBvc0NvdmVyZWQiLCJsaW5lQXQiLCJnZXRMaW5lIiwiZmx1c2hCdWZmZXIiLCJhY3RpdmUiLCJ3cmFwTWFya3MiLCJhZGRCbG9ja1dpZGdldCIsImZpbmlzaCIsImJ1aWxkVGV4dCIsImxpbmVCcmVhayIsImRvbmUiLCJFcnJvciIsInRha2UiLCJzcGFuIiwiTnVsbFdpZGdldCIsImN1cnNvckJlZm9yZSIsImN1cnNvckFmdGVyIiwiYnVpbGQiLCJkZWNvcmF0aW9ucyIsImR5bmFtaWNEZWNvcmF0aW9uTWFwIiwiYnVpbGRlciIsInNwYW5zIiwidGFnIiwidG9Mb3dlckNhc2UiLCJjbGlja0FkZHNTZWxlY3Rpb25SYW5nZSIsImRlZmluZSIsImRyYWdNb3Zlc1NlbGVjdGlvbiQxIiwibW91c2VTZWxlY3Rpb25TdHlsZSIsImV4Y2VwdGlvblNpbmsiLCJ1cGRhdGVMaXN0ZW5lciIsImlucHV0SGFuZGxlciIsImZvY3VzQ2hhbmdlRWZmZWN0IiwicGVyTGluZVRleHREaXJlY3Rpb24iLCJjb21iaW5lIiwidmFsdWVzIiwibmF0aXZlU2VsZWN0aW9uSGlkZGVuIiwiU2Nyb2xsVGFyZ2V0IiwiaXNTbmFwc2hvdCIsIm1hcCIsImNoYW5nZXMiLCJjbGlwIiwic2Nyb2xsSW50b1ZpZXciLCJ0IiwibG9nRXhjZXB0aW9uIiwiZXhjZXB0aW9uIiwiY29udGV4dCIsImhhbmRsZXIiLCJmYWNldCIsIm9uZXJyb3IiLCJTdHJpbmciLCJjb25zb2xlIiwiZXJyb3IiLCJlZGl0YWJsZSIsIm5leHRQbHVnaW5JRCIsInZpZXdQbHVnaW4iLCJWaWV3UGx1Z2luIiwiaWQiLCJkb21FdmVudEhhbmRsZXJzIiwiZG9tRXZlbnRPYnNlcnZlcnMiLCJidWlsZEV4dGVuc2lvbnMiLCJleHRlbnNpb24iLCJldmVudEhhbmRsZXJzIiwiZXZlbnRPYnNlcnZlcnMiLCJwcm92aWRlIiwicGx1Z2luIiwiZXh0IiwicGx1Z2luSW5zdCIsImZyb21DbGFzcyIsIlBsdWdpbkluc3RhbmNlIiwibXVzdFVwZGF0ZSIsInVwZGF0ZSIsImUiLCJkZWFjdGl2YXRlIiwiZWRpdG9yQXR0cmlidXRlcyIsImNvbnRlbnRBdHRyaWJ1dGVzIiwiYXRvbWljUmFuZ2VzIiwiYmlkaUlzb2xhdGVkUmFuZ2VzIiwiZ2V0SXNvbGF0ZWRSYW5nZXMiLCJpc29sYXRlcyIsInNldHMiLCJGdW5jdGlvbiIsImxldmVsIiwiaXNvIiwiYmlkaUlzb2xhdGUiLCJkaXJlY3Rpb24iLCJpbm5lciIsInNjcm9sbE1hcmdpbnMiLCJnZXRTY3JvbGxNYXJnaW5zIiwibSIsInN0eWxlTW9kdWxlIiwiQ2hhbmdlZFJhbmdlIiwiZnJvbUEiLCJ0b0EiLCJmcm9tQiIsInRvQiIsImFkZFRvU2V0IiwibWUiLCJleHRlbmRXaXRoUmFuZ2VzIiwiZGlmZiIsImRJIiwickkiLCJwb3NBIiwicG9zQiIsIlZpZXdVcGRhdGUiLCJ0cmFuc2FjdGlvbnMiLCJzdGFydFN0YXRlIiwidHIiLCJjb21wb3NlIiwiY2hhbmdlZFJhbmdlcyIsIml0ZXJDaGFuZ2VkUmFuZ2VzIiwidmlld3BvcnRDaGFuZ2VkIiwiaGVpZ2h0Q2hhbmdlZCIsImdlb21ldHJ5Q2hhbmdlZCIsImRvY0NoYW5nZWQiLCJmb2N1c0NoYW5nZWQiLCJzZWxlY3Rpb25TZXQiLCJEaXJlY3Rpb24iLCJMVFIiLCJSVEwiLCJkZWMiLCJzdHIiLCJMb3dUeXBlcyIsIkFyYWJpY1R5cGVzIiwiQnJhY2tldHMiLCJCcmFja2V0U3RhY2siLCJwIiwibCIsImNoYXJDb2RlQXQiLCJjaGFyVHlwZSIsIkJpZGlSRSIsIkJpZGlTcGFuIiwib3JkZXIiLCJhc3NvYyIsIm1heWJlIiwiaXNvbGF0ZXNFcSIsImlBIiwiaUIiLCJ0eXBlcyIsImNvbXB1dGVDaGFyVHlwZXMiLCJyRnJvbSIsInJUbyIsIm91dGVyVHlwZSIsImlJIiwicHJldlR5cGUiLCJwcmV2U3Ryb25nIiwicHJvY2Vzc0JyYWNrZXRQYWlycyIsIm9wcG9zaXRlVHlwZSIsInNJIiwiYnIiLCJzSiIsImVtYmVkIiwicHJvY2Vzc05ldXRyYWxzIiwiYmVmb3JlTCIsImFmdGVyTCIsImpJIiwiZnJvbUoiLCJlbWl0U3BhbnMiLCJiYXNlTGV2ZWwiLCJvdXJUeXBlIiwiaUNoIiwic2FtZURpciIsImlzTnVtIiwicmVjdXJzZSIsImxvY2FsTGV2ZWwiLCJpU2NhbiIsInJ1biIsInVwdG8iLCJkaXJTd2FwIiwiY29tcHV0ZVNlY3Rpb25PcmRlciIsImNvbXB1dGVPcmRlciIsInRyaXZpYWxPcmRlciIsIm1vdmVkT3ZlciIsIm1vdmVWaXN1YWxseSIsImZvcndhcmQiLCJzdGFydEluZGV4IiwiaGVhZCIsInNwYW5JIiwiYmlkaUxldmVsIiwiaW5kZXhGb3J3YXJkIiwibmV4dEluZGV4IiwibmV4dFNwYW4iLCJEb2NWaWV3IiwiZG9tQ2hhbmdlZCIsImhhc0NvbXBvc2l0aW9uIiwibWFya2VkRm9yQ29tcG9zaXRpb24iLCJTZXQiLCJtaW5XaWR0aCIsIm1pbldpZHRoRnJvbSIsIm1pbldpZHRoVG8iLCJpbXByZWNpc2VBbmNob3IiLCJpbXByZWNpc2VIZWFkIiwiZm9yY2VTZWxlY3Rpb24iLCJsYXN0VXBkYXRlIiwiRGF0ZSIsIm5vdyIsImNvbnRlbnRET00iLCJ1cGRhdGVEZWNvIiwidXBkYXRlSW5uZXIiLCJldmVyeSIsIm1hcFBvcyIsInJlYWRDb21wb3NpdGlvbkF0IiwiaW5wdXRTdGF0ZSIsImNvbXBvc2luZyIsIm5ld1NlbCIsInRvdWNoZXNDb21wb3NpdGlvbiIsIm1haW4iLCJjb21wb3NpdGlvbiIsImZpbmRDb21wb3NpdGlvblJhbmdlIiwiY2xlYXIiLCJsaW5lcyIsInByZXZEZWNvIiwiZGVjb0RpZmYiLCJmaW5kQ2hhbmdlZERlY28iLCJvbGRMZW5ndGgiLCJtdXN0TWVhc3VyZUNvbnRlbnQiLCJ1cGRhdGVDaGlsZHJlbiIsIm9ic2VydmVyIiwiY29udGVudEhlaWdodCIsImZsZXhCYXNpcyIsInNlbGVjdGlvblJhbmdlIiwiZm9yRWFjaCIsImNWaWV3IiwiZ2FwcyIsInZpZXdwb3J0IiwiQmxvY2tHYXBXaWRnZXQiLCJ1cGRhdGVHYXBzIiwiY29tcExpbmUiLCJjb21wb3NpdGlvblZpZXciLCJjb25jYXQiLCJmaXhDb21wb3NpdGlvbkRPTSIsIm1hcmtzIiwiZml4IiwiYyIsInVwZGF0ZVNlbGVjdGlvbiIsIm11c3RSZWFkIiwiZnJvbVBvaW50ZXIiLCJyZWFkU2VsZWN0aW9uUmFuZ2UiLCJhY3RpdmVFbHQiLCJmb2N1c2VkIiwic2VsZWN0aW9uTm90Rm9jdXMiLCJmb3JjZSIsImFuY2hvciIsIm1vdmVUb0xpbmUiLCJiZXR3ZWVuVW5lZGl0YWJsZSIsImR1bW15IiwiaW5VbmVkaXRhYmxlIiwiYmx1ciIsInJhd1NlbCIsIm5leHRUbyIsIm5leHRUb1VuZWRpdGFibGUiLCJuZWFyYnlUZXh0Tm9kZSIsImNvbGxhcHNlIiwiY2FyZXRCaWRpTGV2ZWwiLCJleHRlbmQiLCJyZW1vdmVBbGxSYW5nZXMiLCJzZXRTZWxlY3Rpb25SYW5nZSIsImVuZm9yY2VDdXJzb3JBc3NvYyIsInNlbCIsIm1vZGlmeSIsImxpbmVTdGFydCIsIm5ld1JhbmdlIiwicG9zRnJvbURPTSIsIm5ld1BvcyIsIm5lYXJlc3QiLCJkb21WaWV3IiwiYmVzdCIsImJlc3RQb3MiLCJjb29yZHNGb3JDaGFyIiwiY2hpbGRPZmYiLCJtZWFzdXJlVmlzaWJsZUxpbmVIZWlnaHRzIiwiY29udGVudFdpZHRoIiwiaXNXaWRlciIsInNjcm9sbERPTSIsIndpZGVzdCIsInRleHREaXJlY3Rpb24iLCJjaGlsZFJlY3QiLCJ0ZXh0RGlyZWN0aW9uQXQiLCJtZWFzdXJlIiwidGV4dENvbnRlbnQiLCJyZW1vdmUiLCJjb21wdXRlQmxvY2tHYXBEZWNvIiwidnMiLCJ2aWV3cG9ydHMiLCJsaW5lQmxvY2tBdCIsImFsbERlY28iLCJkIiwiZHluYW1pYyIsImxpbmVHYXBEZWNvIiwicmVmIiwibWFyZ2lucyIsInRhcmdldFJlY3QiLCJmaW5kQ29tcG9zaXRpb25Ob2RlIiwiaGVhZFBvcyIsInRleHROb2RlIiwiZm91bmQiLCJzbGljZVN0cmluZyIsImludiIsImludmVydGVkRGVzYyIsInBhcmVudFZpZXciLCJzdGFydE5vZGUiLCJzdGFydE9mZnNldCIsIkRlY29yYXRpb25Db21wYXJhdG9yJDEiLCJEZWNvcmF0aW9uQ29tcGFyYXRvciIsImNvbXBhcmVSYW5nZSIsImNvbXBhcmVQb2ludCIsImNvbXAiLCJpbnNpZGUiLCJ0b3VjaGVkIiwiZ3JvdXBBdCIsImNhdGVnb3JpemUiLCJjaGFyQ2F0ZWdvcml6ZXIiLCJsaW5lUG9zIiwiY2F0IiwiZ2V0ZHgiLCJnZXRkeSIsInlPdmVybGFwIiwidXBUb3AiLCJ1cEJvdCIsImRvbVBvc0F0Q29vcmRzIiwiY2xvc2VzdCIsImNsb3Nlc3RSZWN0IiwiY2xvc2VzdFgiLCJjbG9zZXN0WSIsImNsb3Nlc3RPdmVybGFwIiwiYWJvdmUiLCJiZWxvdyIsImFib3ZlUmVjdCIsImJlbG93UmVjdCIsImR4IiwiZHkiLCJkb21Qb3NJblRleHQiLCJjbGlwWCIsImNsb3Nlc3RPZmZzZXQiLCJjbG9zZXN0RFkiLCJnZW5lcmFsU2lkZSIsInJlY3RCZWZvcmUiLCJwb3NBdENvb3JkcyIsImNvb3JkcyIsImRvY1RvcCIsInBhZGRpbmdUb3AiLCJkb2NIZWlnaHQiLCJ5T2Zmc2V0IiwiaGFsZkxpbmUiLCJib3VuY2VkIiwiZWxlbWVudEF0SGVpZ2h0IiwicG9zQXRDb29yZHNJbXByZWNpc2UiLCJlbGVtZW50RnJvbVBvaW50IiwiZWxlbWVudCIsImNhcmV0UG9zaXRpb25Gcm9tUG9pbnQiLCJvZmZzZXROb2RlIiwiY2FyZXRSYW5nZUZyb21Qb2ludCIsInN0YXJ0Q29udGFpbmVyIiwiaXNTdXNwaWNpb3VzU2FmYXJpQ2FyZXRSZXN1bHQiLCJpc1N1c3BpY2lvdXNDaHJvbWVDYXJldFJlc3VsdCIsImNvbnRlbnRSZWN0IiwiaW50byIsInJvdW5kIiwiZGVmYXVsdENoYXJhY3RlcldpZHRoIiwibGluZVdyYXBwaW5nIiwiZGVmYXVsdExpbmVIZWlnaHQiLCJmbG9vciIsImxpbmVMZW5ndGgiLCJzbGljZURvYyIsImJsb2NrQXQiLCJpc0FycmF5IiwibW92ZVRvTGluZUJvdW5kYXJ5IiwiaW5jbHVkZVdyYXAiLCJ3aWRnZXRMaW5lQnJlYWtzIiwiY29vcmRzQXRQb3MiLCJlZGl0b3JSZWN0IiwibW92ZUJ5Q2hhciIsImJ5IiwiYmlkaVNwYW5zIiwiY2hlY2siLCJjaGFyIiwibnVtYmVyIiwiYnlHcm91cCIsIm5leHRDYXQiLCJTcGFjZSIsIm1vdmVWZXJ0aWNhbGx5IiwiZGlzdGFuY2UiLCJzdGFydFBvcyIsImdvYWwiLCJnb2FsQ29sdW1uIiwic3RhcnRZIiwic3RhcnRDb29yZHMiLCJkb2N1bWVudFRvcCIsInJlc29sdmVkR29hbCIsImV4dHJhIiwiY3VyWSIsImNoYXJSZWN0Iiwic2tpcEF0b21pY1JhbmdlcyIsImF0b21zIiwibW92ZWQiLCJiZXR3ZWVuIiwic2tpcEF0b21zIiwib2xkUG9zIiwiZiIsIklucHV0U3RhdGUiLCJzZXRTZWxlY3Rpb25PcmlnaW4iLCJvcmlnaW4iLCJsYXN0U2VsZWN0aW9uT3JpZ2luIiwibGFzdFNlbGVjdGlvblRpbWUiLCJsYXN0S2V5Q29kZSIsImxhc3RLZXlUaW1lIiwibGFzdFRvdWNoVGltZSIsImxhc3RGb2N1c1RpbWUiLCJsYXN0U2Nyb2xsVG9wIiwibGFzdFNjcm9sbExlZnQiLCJwZW5kaW5nSU9TS2V5IiwibGFzdEVzY1ByZXNzIiwibGFzdENvbnRleHRNZW51Iiwic2Nyb2xsSGFuZGxlcnMiLCJoYW5kbGVycyIsImNvbXBvc2l0aW9uRmlyc3RDaGFuZ2UiLCJjb21wb3NpdGlvbkVuZGVkQXQiLCJjb21wb3NpdGlvblBlbmRpbmdLZXkiLCJjb21wb3NpdGlvblBlbmRpbmdDaGFuZ2UiLCJtb3VzZVNlbGVjdGlvbiIsImRyYWdnZWRDb250ZW50IiwiaGFuZGxlRXZlbnQiLCJiaW5kIiwibm90aWZpZWRGb2N1c2VkIiwiaGFzRm9jdXMiLCJhZGRFdmVudExpc3RlbmVyIiwiZmlyZWZveENvcHlDdXRIYWNrIiwiZXZlbnRCZWxvbmdzVG9FZGl0b3IiLCJpZ25vcmVEdXJpbmdDb21wb3NpdGlvbiIsImtleWRvd24iLCJydW5IYW5kbGVycyIsIm9ic2VydmVycyIsInByZXZlbnREZWZhdWx0IiwiZW5zdXJlSGFuZGxlcnMiLCJwbHVnaW5zIiwiY29tcHV0ZUhhbmRsZXJzIiwicGFzc2l2ZSIsImV4aXN0cyIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJtb2RpZmllckNvZGVzIiwiZGVsYXlBbmRyb2lkS2V5IiwicGVuZGluZyIsImFsdEtleSIsIm1ldGFLZXkiLCJQZW5kaW5nS2V5cyIsImN0cmxLZXkiLCJFbWFjc3lQZW5kaW5nS2V5cyIsInNoaWZ0S2V5Iiwic2V0VGltZW91dCIsImZsdXNoSU9TS2V5IiwiZm9yY2VGbHVzaCIsInN0YXJ0TW91c2VTZWxlY3Rpb24iLCJiaW5kSGFuZGxlciIsInJlY29yZCIsImlucHV0VHlwZSIsImRyYWdTY3JvbGxNYXJnaW4iLCJkcmFnU2Nyb2xsU3BlZWQiLCJjbGllbnRYIiwiY2xpZW50WSIsIk1vdXNlU2VsZWN0aW9uIiwic3RhcnRFdmVudCIsIm11c3RTZWxlY3QiLCJzY3JvbGxTcGVlZCIsInNjcm9sbGluZyIsImxhc3RFdmVudCIsInNjcm9sbFBhcmVudCIsIm1vdmUiLCJtdWx0aXBsZSIsImFsbG93TXVsdGlwbGVTZWxlY3Rpb25zIiwiYWRkc1NlbGVjdGlvblJhbmdlIiwiZHJhZ2dpbmciLCJpc0luUHJpbWFyeVNlbGVjdGlvbiIsImdldENsaWNrVHlwZSIsInNlbGVjdCIsImJ1dHRvbnMiLCJzeCIsInN5Iiwic2V0U2Nyb2xsU3BlZWQiLCJzZXRJbnRlcnZhbCIsInNjcm9sbCIsImNsZWFySW50ZXJ2YWwiLCJ1cGRhdGVkIiwibWFpbkluZGV4IiwiZGlzcGF0Y2giLCJ1c2VyRXZlbnQiLCJkcmFnTW92ZXNTZWxlY3Rpb24iLCJyYW5nZUNvdW50IiwiZ2V0UmFuZ2VBdCIsImJ1YmJsZXMiLCJicm9rZW5DbGlwYm9hcmRBUEkiLCJjYXB0dXJlUGFzdGUiLCJkb1Bhc3RlIiwiaW5wdXQiLCJ0b1RleHQiLCJieUxpbmUiLCJsaW5ld2lzZSIsImxhc3RMaW5ld2lzZUNvcHkiLCJsYXN0TGluZSIsImNoYW5nZUJ5UmFuZ2UiLCJyZXBsYWNlU2VsZWN0aW9uIiwidG91Y2hzdGFydCIsInRvdWNobW92ZSIsIm1vdXNlZG93biIsImZsdXNoIiwibWFrZVN0eWxlIiwiYnV0dG9uIiwiYmFzaWNNb3VzZVNlbGVjdGlvbiIsIm11c3RGb2N1cyIsIm1vdXNlU2VsIiwicmFuZ2VGb3JDbGljayIsInZpc3VhbCIsImluc2lkZVkiLCJmaW5kUG9zaXRpb25TaWRlIiwicXVlcnlQb3MiLCJCYWRNb3VzZURldGFpbCIsImxhc3RNb3VzZURvd24iLCJsYXN0TW91c2VEb3duQ291bnQiLCJsYXN0TW91c2VEb3duVGltZSIsImRldGFpbCIsImxhc3RUaW1lIiwic3RhcnRTZWwiLCJyZW1vdmVkIiwic3RhcnRSYW5nZSIsInJlbW92ZVJhbmdlQXJvdW5kIiwiZHJhZ3N0YXJ0IiwiZHJhZ2dhYmxlIiwiZGF0YVRyYW5zZmVyIiwic2V0RGF0YSIsImVmZmVjdEFsbG93ZWQiLCJkcmFnZW5kIiwiZHJvcFRleHQiLCJkaXJlY3QiLCJkcm9wUG9zIiwiZGVsIiwiaW5zIiwiZHJvcCIsInJlYWRPbmx5IiwiZmlsZXMiLCJyZWFkIiwiZmluaXNoRmlsZSIsImZpbHRlciIsInMiLCJyZWFkZXIiLCJGaWxlUmVhZGVyIiwib25sb2FkIiwicmVhZEFzVGV4dCIsImdldERhdGEiLCJwYXN0ZSIsImRhdGEiLCJjbGlwYm9hcmREYXRhIiwiY2FwdHVyZUNvcHkiLCJzZWxlY3Rpb25FbmQiLCJzZWxlY3Rpb25TdGFydCIsImNvcGllZFJhbmdlIiwiY29weSIsImN1dCIsImNsZWFyRGF0YSIsImlzRm9jdXNDaGFuZ2UiLCJmb2N1c0NoYW5nZVRyYW5zYWN0aW9uIiwiZWZmZWN0cyIsImdldEVmZmVjdCIsImVmZmVjdCIsImFubm90YXRpb25zIiwidXBkYXRlRm9yRm9jdXNDaGFuZ2UiLCJjbGVhclNlbGVjdGlvblJhbmdlIiwiY29tcG9zaXRpb25zdGFydCIsImNvbXBvc2l0aW9udXBkYXRlIiwiY29tcG9zaXRpb25lbmQiLCJwZW5kaW5nUmVjb3JkcyIsImZsdXNoU29vbiIsIlByb21pc2UiLCJyZXNvbHZlIiwidGhlbiIsImNvbnRleHRtZW51IiwiYmVmb3JlaW5wdXQiLCJzdGFydFZpZXdIZWlnaHQiLCJ2aXN1YWxWaWV3cG9ydCIsImFwcGxpZWRGaXJlZm94SGFjayIsImhhcyIsIndyYXBwaW5nV2hpdGVTcGFjZSIsIkhlaWdodE9yYWNsZSIsImhlaWdodFNhbXBsZXMiLCJoZWlnaHRGb3JHYXAiLCJjZWlsIiwiaGVpZ2h0Rm9yTGluZSIsInNldERvYyIsIm11c3RSZWZyZXNoRm9yV3JhcHBpbmciLCJ3aGl0ZVNwYWNlIiwibXVzdFJlZnJlc2hGb3JIZWlnaHRzIiwibGluZUhlaWdodHMiLCJuZXdIZWlnaHQiLCJoIiwicmVmcmVzaCIsImtub3duSGVpZ2h0cyIsIk1lYXN1cmVkSGVpZ2h0cyIsImhlaWdodHMiLCJtb3JlIiwiQmxvY2tJbmZvIiwiX2NvbnRlbnQiLCJRdWVyeVR5cGUiLCJFcHNpbG9uIiwiSGVpZ2h0TWFwIiwib3V0ZGF0ZWQiLCJzZXRIZWlnaHQiLCJvcmFjbGUiLCJub2RlcyIsImRlY29tcG9zZUxlZnQiLCJkZWNvbXBvc2VSaWdodCIsImFwcGx5Q2hhbmdlcyIsIm9sZERvYyIsIkJ5UG9zTm9IZWlnaHQiLCJOb2RlQnVpbGRlciIsInVwZGF0ZUhlaWdodCIsIkhlaWdodE1hcFRleHQiLCJicmVhayIsInNpemUiLCJicmsiLCJIZWlnaHRNYXBCcmFuY2giLCJIZWlnaHRNYXBCbG9jayIsIl9oZWlnaHQiLCJfb3JhY2xlIiwiX3ZhbHVlIiwiX3R5cGUiLCJmb3JFYWNoTGluZSIsIl9mb3JjZSIsIm1lYXN1cmVkIiwiY29sbGFwc2VkIiwid2lkZ2V0SGVpZ2h0IiwiYnJlYWtzIiwiSGVpZ2h0TWFwR2FwIiwiaGVpZ2h0TWV0cmljcyIsImZpcnN0TGluZSIsInBlckxpbmUiLCJwZXJDaGFyIiwidG90YWxQZXJMaW5lIiwiZ3Vlc3MiLCJsaW5lVG9wIiwiQnlIZWlnaHQiLCJsaW5lc0Fib3ZlIiwiZmlyc3QiLCJ1bnNoaWZ0Iiwic2luZ2xlSGVpZ2h0IiwibWlkIiwicmlnaHRUb3AiLCJyaWdodE9mZnNldCIsInN1YlF1ZXJ5IiwiQnlQb3MiLCJyaWdodFN0YXJ0IiwiYmFsYW5jZWQiLCJtZXJnZUdhcHMiLCJyZWJhbGFuY2UiLCJhcm91bmQiLCJyZWxldmFudFdpZGdldEhlaWdodCIsImxpbmVFbmQiLCJjb3ZlcmluZyIsIndyaXR0ZW5UbyIsImlzQ292ZXJlZCIsImFkZEJsb2NrIiwiZW50ZXJMaW5lIiwiYmxhbmtDb250ZW50IiwiZ2FwIiwiZW5zdXJlTGluZSIsImhlaWdodFJlbGV2YW50RGVjb0NoYW5nZXMiLCJ2aXNpYmxlUGl4ZWxSYW5nZSIsIm92ZXJmbG93IiwicGFyZW50UmVjdCIsIm9mZnNldFBhcmVudCIsImZ1bGxQaXhlbFJhbmdlIiwiTGluZUdhcCIsInNhbWUiLCJnQSIsImdCIiwiZHJhdyIsIndyYXBwaW5nIiwiTGluZUdhcFdpZGdldCIsInZlcnRpY2FsIiwiZGlzcGxheSIsIlZpZXdTdGF0ZSIsInBpeGVsVmlld3BvcnQiLCJpblZpZXciLCJwYWRkaW5nQm90dG9tIiwiY29udGVudERPTVdpZHRoIiwiY29udGVudERPTUhlaWdodCIsImVkaXRvckhlaWdodCIsImVkaXRvcldpZHRoIiwic2Nyb2xsZWRUb0JvdHRvbSIsInNjcm9sbEFuY2hvclBvcyIsInNjcm9sbEFuY2hvckhlaWdodCIsInNjYWxlciIsIklkU2NhbGVyIiwic2Nyb2xsVGFyZ2V0IiwicHJpbnRpbmciLCJkZWZhdWx0VGV4dERpcmVjdGlvbiIsInZpc2libGVSYW5nZXMiLCJtdXN0RW5mb3JjZUN1cnNvckFzc29jIiwiZ3Vlc3NXcmFwcGluZyIsInN0YXRlRGVjbyIsImhlaWdodE1hcCIsImdldFZpZXdwb3J0IiwidXBkYXRlVmlld3BvcnRMaW5lcyIsInVwZGF0ZUZvclZpZXdwb3J0IiwibGluZUdhcHMiLCJlbnN1cmVMaW5lR2FwcyIsImNvbXB1dGVWaXNpYmxlUmFuZ2VzIiwiVmlld3BvcnQiLCJCaWdTY2FsZXIiLCJ2aWV3cG9ydExpbmVzIiwic2NhbGUiLCJzY2FsZUJsb2NrIiwiY29udGVudENoYW5nZXMiLCJoZWlnaHRDaGFuZ2VzIiwicHJldkhlaWdodCIsInNjcm9sbEFuY2hvciIsInNjcm9sbEFuY2hvckF0IiwibWFwVmlld3BvcnQiLCJ2aWV3cG9ydElzQXBwcm9wcmlhdGUiLCJ1cGRhdGVMaW5lcyIsInVwZGF0ZUxpbmVHYXBzIiwibWFwTGluZUdhcHMiLCJkb21SZWN0IiwibWVhc3VyZUNvbnRlbnQiLCJwYXJzZUludCIsImRUb3AiLCJkQm90dG9tIiwidnAiLCJ2aWV3cG9ydENoYW5nZSIsInZpc2libGVUb3AiLCJmcm9tRE9NIiwidmlzaWJsZUJvdHRvbSIsIm1hcmdpblRvcCIsInZpZXdIZWlnaHQiLCJ0b3BQb3MiLCJtYXBwZWQiLCJ0b3VjaGVzUmFuZ2UiLCJjdXJyZW50IiwibWF5TWVhc3VyZSIsImhhbGZNYXJnaW4iLCJkb3VibGVNYXJnaW4iLCJhZGRHYXAiLCJzdHJ1Y3R1cmUiLCJhdm9pZCIsImdhcFNpemUiLCJsaW5lU3RydWN0dXJlIiwidG90YWwiLCJ2aWV3RnJvbSIsInZpZXdUbyIsIm1hcmdpbkhlaWdodCIsImJvdCIsInRhcmdldEZyYWMiLCJmaW5kRnJhY3Rpb24iLCJzcGFjZUZyYWMiLCJmaW5kUG9zaXRpb24iLCJtYXJnaW5XaWR0aCIsImZyYWN0aW9uIiwibGluZUJsb2NrQXRIZWlnaHQiLCJyYXRpbyIsImNvdW50ZWQiLCJhcnJheSIsInZhbCIsIm4iLCJ2cEhlaWdodCIsImRvbUJhc2UiLCJkb21Ub3AiLCJkb21Cb3R0b20iLCJvYmoiLCJiVG9wIiwiYkJvdHRvbSIsInRoZW1lIiwic3RycyIsImRhcmtUaGVtZSIsImJhc2VUaGVtZUlEIiwibmV3TmFtZSIsImJhc2VMaWdodElEIiwiYmFzZURhcmtJRCIsImxpZ2h0RGFya0lEcyIsImJ1aWxkVGhlbWUiLCJzY29wZXMiLCJiYXNlVGhlbWUkMSIsImJveFNpemluZyIsIm91dGxpbmUiLCJmbGV4RGlyZWN0aW9uIiwiYWxpZ25JdGVtcyIsImZvbnRGYW1pbHkiLCJvdmVyZmxvd1giLCJ6SW5kZXgiLCJmbGV4R3JvdyIsImZsZXhTaHJpbmsiLCJ3b3JkV3JhcCIsIm1pbkhlaWdodCIsInBhZGRpbmciLCJXZWJraXRVc2VyTW9kaWZ5Iiwid2hpdGVTcGFjZV9mYWxsYmFjayIsIndvcmRCcmVhayIsIm92ZXJmbG93V3JhcCIsImNhcmV0Q29sb3IiLCJjb250YWluIiwiYmFja2dyb3VuZCIsInBvaW50ZXJFdmVudHMiLCJhbmltYXRpb24iLCJvcGFjaXR5IiwiYm9yZGVyTGVmdCIsIm1hcmdpbkxlZnQiLCJib3JkZXJMZWZ0Q29sb3IiLCJiYWNrZ3JvdW5kQ29sb3IiLCJjb2xvciIsImluc2V0SW5saW5lU3RhcnQiLCJib3JkZXJSaWdodCIsInRleHRBbGlnbiIsImJvcmRlckJvdHRvbSIsImJvcmRlclRvcCIsInZlcnRpY2FsQWxpZ24iLCJiYWNrZ3JvdW5kSW1hZ2UiLCJiYWNrZ3JvdW5kU2l6ZSIsImJhY2tncm91bmRQb3NpdGlvbiIsImJhY2tncm91bmRSZXBlYXQiLCJmb250U2l6ZSIsImJvcmRlclJhZGl1cyIsImJvcmRlciIsIkxpbmVCcmVha1BsYWNlaG9sZGVyIiwiRE9NUmVhZGVyIiwicG9pbnRzIiwibGluZVNlcGFyYXRvciIsInJlYWRSYW5nZSIsImZpbmRQb2ludEJlZm9yZSIsIm9sZExlbiIsInJlYWROb2RlIiwibmV4dFZpZXciLCJpc0Jsb2NrRWxlbWVudCIsInJlYWRUZXh0Tm9kZSIsInJlIiwibmV4dEJyZWFrIiwiYnJlYWtTaXplIiwiZnJvbVZpZXciLCJmaW5kUG9pbnRJbnNpZGUiLCJpc0F0RW5kIiwiRE9NUG9pbnQiLCJET01DaGFuZ2UiLCJ0eXBlT3ZlciIsImJvdW5kcyIsImlIZWFkIiwiaUFuY2hvciIsInNlbFBvaW50cyIsInNlbGVjdGlvblBvaW50cyIsInNlbGVjdGlvbkZyb21Qb2ludHMiLCJzaW5nbGUiLCJhcHBseURPTUNoYW5nZSIsImRvbUNoYW5nZSIsImNoYW5nZSIsImxhc3RLZXkiLCJwcmVmZXJyZWRQb3MiLCJwcmVmZXJyZWRTaWRlIiwiZmluZERpZmYiLCJnZXRBdHRyaWJ1dGUiLCJkZWZhdWx0VHIiLCJkZWZhdWx0SW5zZXJ0IiwiYXBwbHlEZWZhdWx0SW5zZXJ0IiwibWFpblNlbCIsIm5ld0xlbmd0aCIsInJlcGxhY2VkIiwiY29tcG9zaXRpb25SYW5nZSIsInJhbmdlQ2hhbmdlcyIsInNlbE9mZiIsIm1pbkxlbiIsImFkanVzdCIsIm9ic2VydmVPcHRpb25zIiwiY2hhcmFjdGVyRGF0YSIsInN1YnRyZWUiLCJjaGFyYWN0ZXJEYXRhT2xkVmFsdWUiLCJ1c2VDaGFyRGF0YSIsIkRPTU9ic2VydmVyIiwic2VsZWN0aW9uQ2hhbmdlZCIsImRlbGF5ZWRGbHVzaCIsInJlc2l6ZVRpbWVvdXQiLCJxdWV1ZSIsImRlbGF5ZWRBbmRyb2lkS2V5IiwiZmx1c2hpbmdBbmRyb2lkS2V5IiwibGFzdENoYW5nZSIsInNjcm9sbFRhcmdldHMiLCJpbnRlcnNlY3Rpb24iLCJyZXNpemVTY3JvbGwiLCJpbnRlcnNlY3RpbmciLCJnYXBJbnRlcnNlY3Rpb24iLCJwYXJlbnRDaGVjayIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJtdXRhdGlvbnMiLCJtdXQiLCJyZW1vdmVkTm9kZXMiLCJvbGRWYWx1ZSIsIm9uQ2hhckRhdGEiLCJwcmV2VmFsdWUiLCJvblNlbGVjdGlvbkNoYW5nZSIsIm9uUmVzaXplIiwib25QcmludCIsIm9uU2Nyb2xsIiwiUmVzaXplT2JzZXJ2ZXIiLCJvYnNlcnZlIiwiYWRkV2luZG93TGlzdGVuZXJzIiwiSW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJlbnRyaWVzIiwibGlzdGVuRm9yU2Nyb2xsIiwiaW50ZXJzZWN0aW9uUmF0aW8iLCJvblNjcm9sbENoYW5nZWQiLCJjcmVhdGVFdmVudCIsInRocmVzaG9sZCIsInJlcXVlc3RNZWFzdXJlIiwiZyIsImRpc2Nvbm5lY3QiLCJ3YXNDaGFuZ2VkIiwic2FmYXJpU2VsZWN0aW9uUmFuZ2VIYWNrIiwibG9jYWwiLCJwcm9jZXNzUmVjb3JkcyIsImNsZWFyRGVsYXllZEFuZHJvaWRLZXkiLCJmbHVzaGVkIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJ0YWtlUmVjb3JkcyIsInJlY29yZHMiLCJyZWFkTXV0YXRpb24iLCJyZWFkQ2hhbmdlIiwicmVhZFNlbGVjdGlvbiIsImhhbmRsZWQiLCJyZWMiLCJjaGlsZEJlZm9yZSIsImZpbmRDaGlsZCIsImNoaWxkQWZ0ZXIiLCJzZXRXaW5kb3ciLCJyZW1vdmVXaW5kb3dMaXN0ZW5lcnMiLCJfYyIsImNsZWFyVGltZW91dCIsImN1clZpZXciLCJzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24iLCJnZXRUYXJnZXRSYW5nZXMiLCJleGVjQ29tbWFuZCIsImVuZENvbnRhaW5lciIsImVuZE9mZnNldCIsImN1ckFuY2hvciIsIkVkaXRvclZpZXciLCJjb21wb3NpdGlvblN0YXJ0ZWQiLCJfcm9vdCIsImNvbmZpZyIsInBsdWdpbk1hcCIsIk1hcCIsImVkaXRvckF0dHJzIiwiY29udGVudEF0dHJzIiwiYmlkaUNhY2hlIiwiZGVzdHJveWVkIiwidXBkYXRlU3RhdGUiLCJtZWFzdXJlU2NoZWR1bGVkIiwibWVhc3VyZVJlcXVlc3RzIiwidGFiSW5kZXgiLCJhbm5vdW5jZURPTSIsImRpc3BhdGNoVHJhbnNhY3Rpb25zIiwidHJzIiwic2Nyb2xsVG8iLCJpcyIsIm1vdW50U3R5bGVzIiwicmVkcmF3biIsImF0dHJzQ2hhbmdlZCIsImZvY3VzRmxhZyIsImRpc3BhdGNoRm9jdXMiLCJhbm5vdGF0aW9uIiwicGVuZGluZ0tleSIsInBocmFzZXMiLCJzZXRTdGF0ZSIsIkNhY2hlZE9yZGVyIiwidXBkYXRlUGx1Z2lucyIsInN0eWxlTW9kdWxlcyIsInNob3dBbm5vdW5jZW1lbnRzIiwiaXNVc2VyRXZlbnQiLCJsaXN0ZW5lciIsIm5ld1N0YXRlIiwiaGFkRm9jdXMiLCJwcmV2U3BlY3MiLCJzcGVjcyIsIm5ld1BsdWdpbnMiLCJzRE9NIiwid2FybiIsIm1lYXN1cmluZyIsIkJhZE1lYXN1cmUiLCJ3cml0ZSIsIm5ld0FuY2hvckhlaWdodCIsInRoZW1lQ2xhc3NlcyIsImF0dHJzRnJvbUZhY2V0Iiwic3BlbGxjaGVjayIsImF1dG9jb3JyZWN0IiwiYXV0b2NhcGl0YWxpemUiLCJ0cmFuc2xhdGUiLCJjb250ZW50ZWRpdGFibGUiLCJyb2xlIiwiY2hhbmdlZENvbnRlbnQiLCJjaGFuZ2VkRWRpdG9yIiwiYW5ub3VuY2UiLCJkaXYiLCJub25jZSIsImNzcE5vbmNlIiwibW91bnQiLCJyZXZlcnNlIiwicmVhZE1lYXN1cmVkIiwicmVxdWVzdCIsImtub3duIiwiZG9jdW1lbnRQYWRkaW5nIiwidmlld3BvcnRMaW5lQmxvY2tzIiwibW92ZUJ5R3JvdXAiLCJpbml0aWFsIiwicG9zQXRET00iLCJNYXhCaWRpTGluZSIsImVudHJ5IiwiZnJlc2giLCJzZXRSb290Iiwic2Nyb2xsU25hcHNob3QiLCJwcmVmaXgiLCJkYXJrIiwiYmFzZVRoZW1lIiwibG93ZXN0IiwiZmluZEZyb21ET00iLCJxdWVyeVNlbGVjdG9yIiwiY2FjaGUiLCJsYXN0RGlyIiwic291cmNlcyIsImN1cnJlbnRQbGF0Zm9ybSIsIm5vcm1hbGl6ZUtleU5hbWUiLCJwYXJ0cyIsImFsdCIsImN0cmwiLCJtZXRhIiwibW9kIiwibW9kaWZpZXJzIiwiaGFuZGxlS2V5RXZlbnRzIiwiZGVmYXVsdCIsImdldEtleW1hcCIsImtleW1hcCIsImVuYWJsZXMiLCJLZXltYXBzIiwiV2Vha01hcCIsImJpbmRpbmdzIiwiYnVpbGRLZXltYXAiLCJyZWR1Y2UiLCJydW5TY29wZUhhbmRsZXJzIiwic2NvcGUiLCJzdG9yZWRQcmVmaXgiLCJQcmVmaXhUaW1lb3V0IiwiYm91bmQiLCJpc1ByZWZpeCIsImNoZWNrUHJlZml4IiwiY29tbWFuZCIsInN0b3BQcm9wYWdhdGlvbiIsInNjb3BlT2JqIiwiayIsIm91ck9iaiIsImZ1bGwiLCJiaW5kaW5nIiwiX2FueSIsImFueSIsImNoYXJDb2RlIiwiaXNDaGFyIiwicHJldmVudGVkIiwicmFuIiwicnVuRm9yIiwiY21kIiwiYmFzZU5hbWUiLCJzaGlmdE5hbWUiLCJSZWN0YW5nbGVNYXJrZXIiLCJmb3JSYW5nZSIsImdldEJhc2UiLCJyZWN0YW5nbGVzRm9yUmFuZ2UiLCJ3cmFwcGVkTGluZSIsImxpbmVFbHQiLCJsaW5lU3R5bGUiLCJsZWZ0U2lkZSIsInBhZGRpbmdMZWZ0IiwidGV4dEluZGVudCIsInJpZ2h0U2lkZSIsInBhZGRpbmdSaWdodCIsInN0YXJ0QmxvY2siLCJlbmRCbG9jayIsInZpc3VhbFN0YXJ0IiwidmlzdWFsRW5kIiwicGllY2VzIiwiZHJhd0ZvckxpbmUiLCJkcmF3Rm9yV2lkZ2V0IiwicGllY2UiLCJob3Jpem9udGFsIiwiYWRkU3BhbiIsImZyb21PcGVuIiwidG9PcGVuIiwiZnJvbUNvb3JkcyIsInRvQ29vcmRzIiwiZW5kUG9zIiwiZG9jTGluZSIsInNwYW5Gcm9tIiwic3BhblRvIiwic2FtZU1hcmtlciIsIkxheWVyVmlldyIsImxheWVyIiwiZHJhd24iLCJtZWFzdXJlUmVxIiwic2V0T3JkZXIiLCJsYXllck9yZGVyIiwibWFya2VycyIsInRyYW5zZm9ybSIsIm9sZCIsIm9sZEkiLCJtYXJrZXIiLCJDYW5IaWRlUHJpbWFyeSIsInNlbGVjdGlvbkNvbmZpZyIsImNvbmZpZ3MiLCJjdXJzb3JCbGlua1JhdGUiLCJkcmF3UmFuZ2VDdXJzb3IiLCJkcmF3U2VsZWN0aW9uIiwiY3Vyc29yTGF5ZXIiLCJzZWxlY3Rpb25MYXllciIsImhpZGVOYXRpdmVTZWxlY3Rpb24iLCJnZXREcmF3U2VsZWN0aW9uQ29uZmlnIiwiY29uZmlnQ2hhbmdlZCIsImNvbmYiLCJjdXJzb3JzIiwicHJpbSIsImFuaW1hdGlvbk5hbWUiLCJjb25mQ2hhbmdlIiwic2V0QmxpbmtSYXRlIiwiYW5pbWF0aW9uRHVyYXRpb24iLCJ0aGVtZVNwZWMiLCJoaWdoZXN0Iiwic2V0RHJvcEN1cnNvclBvcyIsIm1hcHBpbmciLCJkcm9wQ3Vyc29yUG9zIiwiZHJhd0Ryb3BDdXJzb3IiLCJyZWFkUG9zIiwiZHJhd0N1cnNvciIsImN1cnNvclBvcyIsImZpZWxkIiwib3V0ZXIiLCJzZXREcm9wUG9zIiwiZHJhZ292ZXIiLCJkcmFnbGVhdmUiLCJyZWxhdGVkVGFyZ2V0IiwiZHJvcEN1cnNvciIsIml0ZXJNYXRjaGVzIiwibGFzdEluZGV4IiwiaXRlclJhbmdlIiwibWF0Y2hSYW5nZXMiLCJtYXhMZW5ndGgiLCJ2aXNpYmxlIiwiTWF0Y2hEZWNvcmF0b3IiLCJyZWdleHAiLCJkZWNvcmF0aW9uIiwiZGVjb3JhdGUiLCJib3VuZGFyeSIsImdsb2JhbCIsImFkZE1hdGNoIiwibWF0Y2giLCJfdmlldyIsImNyZWF0ZURlY28iLCJjaGFuZ2VGcm9tIiwiY2hhbmdlVG8iLCJpdGVyQ2hhbmdlcyIsIl9mIiwiX3QiLCJ1cGRhdGVSYW5nZSIsInVwZGF0ZUZyb20iLCJ1cGRhdGVUbyIsImZyb21MaW5lIiwidG9MaW5lIiwiZmlsdGVyRnJvbSIsImZpbHRlclRvIiwiVW5pY29kZVJlZ2V4cFN1cHBvcnQiLCJ1bmljb2RlIiwiU3BlY2lhbHMiLCJSZWdFeHAiLCJOYW1lcyIsIl9zdXBwb3J0c1RhYlNpemUiLCJzdXBwb3J0c1RhYlNpemUiLCJzdHlsZXMiLCJNb3pUYWJTaXplIiwic3BlY2lhbENoYXJDb25maWciLCJyZW5kZXIiLCJzcGVjaWFsQ2hhcnMiLCJhZGRTcGVjaWFsQ2hhcnMiLCJyZXBsYWNlVGFicyIsImhpZ2hsaWdodFNwZWNpYWxDaGFycyIsInNwZWNpYWxDaGFyUGx1Z2luIiwiX3BsdWdpbiIsImRlY29yYXRpb25DYWNoZSIsImRlY29yYXRvciIsIm1ha2VEZWNvcmF0b3IiLCJjb2wiLCJUYWJXaWRnZXQiLCJTcGVjaWFsQ2hhcldpZGdldCIsIkRlZmF1bHRQbGFjZWhvbGRlciIsInBsYWNlaG9sZGVyJDEiLCJmcm9tQ2hhckNvZGUiLCJwaCIsImRlc2MiLCJwaHJhc2UiLCJ0aXRsZSIsInNjcm9sbFBhc3RFbmQiLCJoaWdobGlnaHRBY3RpdmVMaW5lIiwiYWN0aXZlTGluZUhpZ2hsaWdodGVyIiwibGluZURlY28iLCJnZXREZWNvIiwibGFzdExpbmVTdGFydCIsIlBsYWNlaG9sZGVyIiwid3JhcCIsInBsYWNlaG9sZGVyIiwiTWF4T2ZmIiwicmVjdGFuZ2xlRm9yIiwic3RhcnRMaW5lIiwiZW5kTGluZSIsInN0YXJ0T2ZmIiwiZW5kT2ZmIiwic3RhcnRDb2wiLCJlbmRDb2wiLCJhYnNvbHV0ZUNvbHVtbiIsImdldFBvcyIsInJlY3RhbmdsZVNlbGVjdGlvblN0eWxlIiwibmV3U3RhcnQiLCJuZXdMaW5lIiwiX2V4dGVuZCIsInJlY3Rhbmd1bGFyU2VsZWN0aW9uIiwiZXZlbnRGaWx0ZXIiLCJBbHQiLCJDb250cm9sIiwiU2hpZnQiLCJNZXRhIiwic2hvd0Nyb3NzaGFpciIsImNyb3NzaGFpckN1cnNvciIsImdldHRlciIsImlzRG93biIsImtleXVwIiwibW91c2Vtb3ZlIiwiT3V0c2lkZSIsIlRvb2x0aXBWaWV3TWFuYWdlciIsImNyZWF0ZVRvb2x0aXBWaWV3IiwidG9vbHRpcHMiLCJ0b29sdGlwVmlld3MiLCJuZXdBYm92ZSIsInRpcCIsInRvb2x0aXBWaWV3IiwidG9vbHRpcENvbmZpZyIsIndpbmRvd1NwYWNlIiwidG9vbHRpcFNwYWNlIiwia25vd25IZWlnaHQiLCJ0b29sdGlwUGx1Z2luIiwibWFkZUFic29sdXRlIiwibGFzdFRyYW5zYWN0aW9uIiwibWVhc3VyZVRpbWVvdXQiLCJjbGFzc2VzIiwiY3JlYXRlQ29udGFpbmVyIiwicmVhZE1lYXN1cmUiLCJ3cml0ZU1lYXN1cmUiLCJtYW5hZ2VyIiwic2hvd1Rvb2x0aXAiLCJjcmVhdGVUb29sdGlwIiwiaW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJtZWFzdXJlU29vbiIsIm9ic2VydmVJbnRlcnNlY3Rpb24iLCJtYXliZU1lYXN1cmUiLCJjb250YWluZXIiLCJ0b29sdGlwIiwic2hvdWxkTWVhc3VyZSIsIm5ld0NvbmZpZyIsImFycm93IiwiZWRpdG9yIiwibWFrZUFic29sdXRlIiwidHYiLCJnZXRDb29yZHMiLCJzcGFjZSIsIm90aGVycyIsInRWaWV3IiwiYXJyb3dIZWlnaHQiLCJub09mZnNldCIsInN0cmljdFNpZGUiLCJzcGFjZVZlcnQiLCJyZXNpemUiLCJvdmVybGFwIiwiYXJyb3dMZWZ0IiwidG9nZ2xlIiwicG9zaXRpb25lZCIsImJvcmRlclRvcENvbG9yIiwiYm9yZGVyQm90dG9tQ29sb3IiLCJzaG93SG92ZXJUb29sdGlwIiwiSG92ZXJUb29sdGlwSG9zdCIsIm1vdW50ZWQiLCJjcmVhdGVIb3N0ZWRWaWV3IiwiaG9zdGVkVmlldyIsInBhc3NQcm9wIiwiZ2l2ZW4iLCJzaG93SG92ZXJUb29sdGlwSG9zdCIsImNvbXB1dGUiLCJIb3ZlclBsdWdpbiIsInNldEhvdmVyIiwiaG92ZXJUaW1lIiwiaG92ZXJUaW1lb3V0IiwicmVzdGFydFRpbWVvdXQiLCJsYXN0TW92ZSIsInRpbWUiLCJjaGVja0hvdmVyIiwibW91c2VsZWF2ZSIsInN0YXJ0SG92ZXIiLCJob3ZlcmVkIiwicG9zQ29vcmRzIiwiYmlkaSIsInJ0bCIsImZpbmRJbmRleCIsImlzSW5Ub29sdGlwIiwiaXNPdmVyUmFuZ2UiLCJpblRvb2x0aXAiLCJ3YXRjaFRvb2x0aXBMZWF2ZSIsIndhdGNoIiwidG9vbHRpcE1hcmdpbiIsImRvY0JvdHRvbSIsImhvdmVyVG9vbHRpcCIsImhvdmVyU3RhdGUiLCJoaWRlT25DaGFuZ2UiLCJoaWRlT24iLCJhc3NpZ24iLCJjbG9zZUhvdmVyVG9vbHRpcEVmZmVjdCIsImdldFRvb2x0aXAiLCJoYXNIb3ZlclRvb2x0aXBzIiwiY2xvc2VIb3ZlclRvb2x0aXBzIiwicmVwb3NpdGlvblRvb2x0aXBzIiwicGFuZWxDb25maWciLCJ0b3BDb250YWluZXIiLCJib3R0b21Db250YWluZXIiLCJwYW5lbHMiLCJnZXRQYW5lbCIsInBhbmVsIiwicGFuZWxQbHVnaW4iLCJzaG93UGFuZWwiLCJQYW5lbEdyb3VwIiwic3luY0NsYXNzZXMiLCJzY3JvbGxNYXJnaW4iLCJzeW5jRE9NIiwiY3VyRE9NIiwicm0iLCJHdXR0ZXJNYXJrZXIiLCJlbGVtZW50Q2xhc3MiLCJndXR0ZXJMaW5lQ2xhc3MiLCJkZWZhdWx0cyIsInJlbmRlckVtcHR5RWxlbWVudHMiLCJlbGVtZW50U3R5bGUiLCJsaW5lTWFya2VyIiwid2lkZ2V0TWFya2VyIiwibGluZU1hcmtlckNoYW5nZSIsImluaXRpYWxTcGFjZXIiLCJ1cGRhdGVTcGFjZXIiLCJhY3RpdmVHdXR0ZXJzIiwiZ3V0dGVyIiwiZ3V0dGVycyIsInVuZml4R3V0dGVycyIsImd1dHRlclZpZXciLCJmaXhlZCIsInByZXZWaWV3cG9ydCIsIlNpbmdsZUd1dHRlclZpZXciLCJzeW5jR3V0dGVycyIsInVwZGF0ZUd1dHRlcnMiLCJ2cEEiLCJ2cEIiLCJ2cE92ZXJsYXAiLCJkZXRhY2giLCJsaW5lQ2xhc3NlcyIsImNsYXNzU2V0IiwiY29udGV4dHMiLCJVcGRhdGVDb250ZXh0IiwiYWR2YW5jZUN1cnNvciIsImN4IiwiYXNBcnJheSIsImNvbGxlY3QiLCJhZGRFbGVtZW50IiwiZWxlbWVudHMiLCJuZXdFbHQiLCJHdXR0ZXJFbGVtZW50IiwiZXh0cmFNYXJrZXJzIiwibG9jYWxNYXJrZXJzIiwiZm9yTGluZSIsInNwYWNlciIsInByb3AiLCJwcmV2TWFya2VycyIsInNhbWVNYXJrZXJzIiwic2V0TWFya2VycyIsImRvbVBvcyIsImlOZXciLCJpT2xkIiwic2tpcFRvIiwibWF0Y2hlZCIsImxpbmVOdW1iZXJNYXJrZXJzIiwibGluZU51bWJlckNvbmZpZyIsImZvcm1hdE51bWJlciIsIk51bWJlck1hcmtlciIsImxpbmVOdW1iZXJHdXR0ZXIiLCJtYXhMaW5lTnVtYmVyIiwibGluZU51bWJlcnMiLCJhY3RpdmVMaW5lR3V0dGVyTWFya2VyIiwiYWN0aXZlTGluZUd1dHRlckhpZ2hsaWdodGVyIiwiaGlnaGxpZ2h0QWN0aXZlTGluZUd1dHRlciIsIldoaXRlc3BhY2VEZWNvIiwiZ2V0V2hpdGVzcGFjZURlY28iLCJtYXRjaGVyIiwidSIsIndoaXRlc3BhY2VIaWdobGlnaHRlciIsImhpZ2hsaWdodFdoaXRlc3BhY2UiLCJ0cmFpbGluZ0hpZ2hsaWdodGVyIiwiaGlnaGxpZ2h0VHJhaWxpbmdXaGl0ZXNwYWNlIiwiX190ZXN0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@codemirror/view/dist/index.js\n");

/***/ })

};
;